{"buggy_code": ["Ember.mixin(Flame, {\n    _setupStringMeasurement: function(parentClasses, elementClasses, additionalStyles) {\n        if (!parentClasses) parentClasses = '';\n        if (!elementClasses) elementClasses = '';\n        if (!additionalStyles) additionalStyles = '';\n\n        var element = this._metricsCalculationElement;\n        if (!element) {\n            var parentElement = document.createElement('div');\n            parentElement.style.cssText = 'position:absolute; left:-10010px; top:-10px; width:10000px; visibility:hidden;';\n            element = this._metricsCalculationElement = document.createElement('div');\n            parentElement.appendChild(element);\n            document.body.insertBefore(parentElement, null);\n        }\n\n        element.parentNode.className = parentClasses;\n        element.className = elementClasses;\n        element.style.cssText = 'position:absolute; left: 0; top: 0; bottom: auto; right: auto; width: auto; height: auto;' + additionalStyles;\n        return element;\n    },\n\n    measureString: function(string, parentClasses, elementClasses, additionalStyles) {\n        var element = this._setupStringMeasurement(parentClasses, elementClasses, additionalStyles);\n        element.innerHTML = string;\n        return {\n            width: element.clientWidth,\n            height: element.clientHeight\n        };\n    }\n});\n", "//= require ./button_view\n\n// A checkbox. The state of the checkbox is indicated by the isSelected property.\nFlame.CheckboxView = Flame.ButtonView.extend({\n    classNames: ['flame-checkbox-view'],\n    isSticky: true,\n\n    render: function(buffer) {\n        buffer.push('<div class=\"flame-checkbox-box\"></div>');\n        this.renderCheckMark(buffer);\n        buffer.push('<label class=\"flame-checkbox-label\">');\n        buffer.push(Ember.isNone(this.get('title')) ? '' : this.get('title'));\n        buffer.push('</label>');\n    },\n\n    renderCheckMark: function(buffer) {\n        var imgUrl = Flame.image('checkmark.svg');\n        buffer.push('<div class=\"flame-view flame-checkbox-checkmark\" style=\"left: 4px; top: 2px;\"><img src=\"' + imgUrl + '\"></div>');\n    }\n});\n", "//= require ./panel\n//= require ./collection_view\n//= require ../mixins/action_support\n//= require ./menu_scroll_view\n\n// Only to be used in Flame.MenuView. Represent menu items with normal JS objects as creation of one Ember object took\n// 3.5 ms on fast IE8 machine.\nFlame.MenuItem = function MenuItem(opts) {\n    for (var key in opts) {\n        if (opts.hasOwnProperty(key)) {\n            this[key] = opts[key];\n        }\n    }\n};\n\nFlame.MenuItem.prototype.renderToBuffer = function(buffer) {\n    var classes = ['flame-view', 'flame-list-item-view', 'flame-menu-item-view'];\n    if (this.isSelected) classes.push('is-selected');\n    if (!this.isEnabled()) classes.push('is-disabled');\n    var subMenuLength = Ember.isNone(this.subMenuItems) ? -1 : this.subMenuItems.get('length');\n    var template = '<div id=\"%@\" class=\"%@\" %@>%@%@%@</div>';\n    buffer.push(\n        template.fmt(\n            this.id,\n            classes.join(' '),\n            this.item.tooltip ? 'title=\"%@\"'.fmt(this.item.tooltip) : '',\n            this.isChecked ? '<div class=\"flame-menu-item-view-checkmark\"></div>' : '',\n            Handlebars.Utils.escapeExpression(this.title),\n            subMenuLength > 0 ? '<div class=\"menu-indicator\"></div>' : ''\n        )\n    );\n};\n\nFlame.MenuItem.prototype.isEnabled = function() {\n    return !(this.isDisabled || (this.subMenuItems && this.subMenuItems.length === 0));\n};\n\nFlame.MenuItem.prototype.isSelectable = function() {\n    return this.isEnabled() && !this.subMenuItems;\n};\n\nFlame.MenuItem.prototype.$ = function() {\n    return Ember.$('#%@'.fmt(this.id));\n};\n\nFlame.MenuItem.prototype.closeSubMenu = function() {\n    var subMenu = this.subMenuView;\n    if (!Ember.isNone(subMenu)) {\n        subMenu.close();\n        this.subMenuView = null;\n    }\n};\n\n/**\n  A menu. Can be shown as a \"stand-alone\" menu or in cooperation with a SelectButtonView.\n\n  MenuView has a property 'subMenuKey'. Should objects based on which the menu is created return null/undefined for\n  that property, the item itself will be selectable. Otherwise if the property has more than zero values, a submenu\n  will be shown.\n\n  Because of the implementation details, this menu will hold values of undefined or null as the same as not set. Thus,\n  no selectable menu item must have such value their value.\n*/\nFlame.MenuView = Flame.Panel.extend(Flame.ActionSupport, {\n    classNames: ['flame-menu'],\n    childViews: ['contentView'],\n    contentView: Flame.MenuScrollView,\n    dimBackground: false,\n    subMenuKey: 'subMenu',\n    itemTitleKey: 'title',\n    /* Attribute that can be used to indicate a disabled menu item. The item will be disabled only if\n     * isEnabled === false, not some falseish value. */\n    itemEnabledKey: 'isEnabled',\n    itemCheckedKey: 'isChecked',\n    itemValueKey: 'value',\n    itemActionKey: 'action',\n    itemHeight: 21,\n    /* Margin between the menu and top/bottom of the viewport. */\n    menuMargin: 12,\n    minWidth: null, // Defines minimum width of menu\n    items: null,\n    parentMenu: null,\n    value: null,\n    _allItemsDoNotFit: true,\n    _anchorElement: null,\n    _menuItems: null,\n    _highlightIndex: -1, // Currently highlighted index.\n    _userHighlightIndex: -1, // User selected highlighted index\n    // Reflects the content item in this menu or the deepest currently open submenu that is currently highlighted,\n    // regardless of whether mouse button is up or down. When mouse button is released, this will be set as the real\n    // selection on the top-most menu, unless it's undefined (happens if currently on a non-selectable item)\n    // This is to be handled as a unmodifiable object: always create a new object instead of mutating its properties.\n    _internalSelection: { isSet: false, value: null },\n\n    init: function() {\n        this._super();\n        this._needToRecreateItems();\n    },\n\n    _calculateMenuWidth: function() {\n        var items = this.get('items') || [];\n        if (Ember.get(items, 'length') === 0) {\n            return;\n        }\n        var itemTitleKey = this.get('itemTitleKey');\n        var allTitles = items.reduce(function(currentTitles, item) {\n            var nextTitle = Ember.get(item, itemTitleKey);\n            return currentTitles + nextTitle + '<br>';\n        }, '');\n        // Give the menus a 16px breathing space to account for sub menu indicator, and to give some right margin (+18px for the padding)\n        return Flame.measureString(allTitles, 'ember-view flame-view flame-list-item-view flame-menu-item-view', 'title').width + 16 + 18;\n    },\n\n    _createMenuItems: function() {\n        var items = this.get('items'),\n            itemCheckedKey = this.get('itemCheckedKey'),\n            itemEnabledKey = this.get('itemEnabledKey'),\n            itemTitleKey = this.get('itemTitleKey'),\n            itemValueKey = this.get('itemValueKey'),\n            subMenuKey = this.get('subMenuKey'),\n            selectedValue = this.get('value'),\n            valueIsSet = !Ember.isNone(selectedValue),\n            menuItems;\n        menuItems = (items || []).map(function(item, i) {\n            // Only show the selection on the main menu, not in the submenus.\n            return new Flame.MenuItem({\n                item: item,\n                isSelected: valueIsSet ? Ember.get(item, itemValueKey) === selectedValue : false,\n                isDisabled: Ember.get(item, itemEnabledKey) === false,\n                isChecked: Ember.get(item, itemCheckedKey),\n                subMenuItems: Ember.get(item, subMenuKey),\n                title: Ember.get(item, itemTitleKey),\n                id: this._indexToId(i)\n            });\n        }, this);\n        return menuItems;\n    },\n\n    _needToRecreateItems: function() {\n        var menuItems = this._createMenuItems();\n        this.set('_menuItems', menuItems);\n        if (Ember.isNone(this.get('parentMenu'))) {\n            menuItems.forEach(function(item, i) {\n                if (item.isSelected) this.set('_highlightIndex', i);\n            }, this);\n        }\n        this.get('contentView').setScrolledView(this._createMenuView());\n        if (this.get('_anchorElement')) {\n            this._updateMenuSize();\n        }\n\n        // Set content of scroll stuff\n        // calculate the the height of menu\n    }.observes('items'),\n\n    _createMenuView: function() {\n        var items = this.get('_menuItems');\n        return Flame.View.create({\n            useAbsolutePosition: false,\n            render: function(buffer) {\n                items.forEach(function(menuItem) { menuItem.renderToBuffer(buffer); });\n            }\n        });\n    },\n\n    makeSelection: function() {\n        var parentMenu = this.get('parentMenu');\n        var action, value;\n        if (!Ember.isNone(parentMenu)) {\n            parentMenu.makeSelection();\n            this.close();\n        } else {\n            var internalSelection = this.get('_internalSelection');\n            if (internalSelection.isSet) {\n                value = Ember.get(internalSelection.value, this.get('itemValueKey'));\n                this.set(\"value\", value);\n                // If we have an action, call it on the selection.\n                action = Ember.get(internalSelection.value, this.get('itemActionKey')) || this.get('action');\n            }\n            // Sync the values before we tear down all bindings in close() which calls destroy().\n            Ember.run.sync();\n            // Close this menu before firing an action - the action might open a new popup, and if closing after that,\n            // the new popup panel is popped off the key responder stack instead of this menu.\n            this.close();\n            if (!Ember.isNone(action)) {\n                this.fireAction(action, value);\n            }\n        }\n    },\n\n    subMenu: function() {\n        return Flame.MenuView.extend({\n            isModal: false,\n\n            popup: function(anchor, position) {\n                if (!this.get('layout.width')) {\n                    // We already need to know the width of the menu at this point so that Panel#popup\n                    // can correctly position it.\n                    var menuWidth = Math.max(this.get('minWidth') || 0, this._calculateMenuWidth());\n                    this.set('layout.width', menuWidth);\n                }\n                this._super(anchor, position);\n            },\n\n            _layoutRelativeTo: function(anchor, position) {\n                var layout = this._super(anchor, position);\n                // If already positioned on the left, nothing else needs to be checked.\n                if (this.get('subMenuPosition') === Flame.POSITION_LEFT) return layout;\n\n                if (layout.movedX) {\n                    // Any further opened submenu should be opened on the left side.\n                    this.set('subMenuPosition', Flame.POSITION_LEFT);\n                    layout = this._super(anchor, Flame.POSITION_LEFT);\n                }\n                return layout;\n            }\n        });\n    }.property(),\n\n    // This function is here to break the dependency between MenuView and MenuItemView\n    createSubMenu: function(subMenuItems) {\n        return this.get('subMenu').create({\n            items: subMenuItems,\n            parentMenu: this,\n            subMenuKey: this.get('subMenuKey'),\n            itemEnabledKey: this.get('itemEnabledKey'),\n            itemTitleKey: this.get('itemTitleKey'),\n            itemValueKey: this.get('itemValueKey'),\n            itemHeight: this.get('itemHeight'),\n            subMenuPosition: this.get('subMenuPosition')\n        });\n    },\n\n    closeCurrentlyOpenSubMenu: function() {\n        // observers of highlightIndex should take care that closing is propagated to the every open menu underneath\n        // this menu. Close() sets highlightIndex to -1, _highlightWillChange() will call closeSubMenu() on the item\n        // which then calls close() on the menu it depicts and this is continued until no open menus remain under the\n        // closed menu.\n        var index = this.get('_highlightIndex');\n        if (index >= 0) {\n            this.get('_menuItems').objectAt(index).closeSubMenu();\n        }\n    },\n\n    popup: function(anchorElementOrJQ, position) {\n        if (Ember.isNone(this.get('parentMenu'))) {\n            this._openedAt = new Date().getTime();\n        }\n        var anchorElement = anchorElementOrJQ instanceof jQuery ? anchorElementOrJQ : anchorElementOrJQ.$();\n        this._super(anchorElement, position);\n        this.set('_anchorElement', anchorElement);\n        this._updateMenuSize();\n    },\n\n    _updateMenuSize: function() {\n        var anchorElement = this.get('_anchorElement');\n        // These values come from the CSS but we still need to know them here. Is there a better way?\n        var paddingTop = 5;\n        var paddingBottom = 5;\n        var borderWidth = 1;\n        var totalPadding = paddingTop + paddingBottom;\n        var margin = this.get('menuMargin');\n        var menuOuterHeight = this.get('_menuItems').get('length') * this.get('itemHeight') + totalPadding + 2 * borderWidth;\n        var wh = $(window).height();\n        var anchorTop = anchorElement.offset().top;\n        var anchorHeight = anchorElement.outerHeight();\n        var layout = this.get('layout');\n\n        var isSubMenu = !Ember.isNone(this.get('parentMenu'));\n        var spaceDownwards = wh - anchorTop + (isSubMenu ? (borderWidth + paddingTop) : (-anchorHeight));\n        var needScrolling = false;\n\n        if (menuOuterHeight + margin * 2 <= wh) {\n            if (isSubMenu && spaceDownwards >= menuOuterHeight + margin) {\n                layout.set('top', anchorTop - (borderWidth + paddingTop));\n            } else if (spaceDownwards < menuOuterHeight + margin) {\n                layout.set('top', wh - (menuOuterHeight + margin));\n            }\n        } else {\n            // Constrain menu height\n            menuOuterHeight = wh - 2 * margin;\n            layout.set('top', margin);\n            needScrolling = true;\n        }\n        layout.set('height', menuOuterHeight);\n        if (!layout.width) {\n            var menuWidth = Math.max(this.get('minWidth') || 0, this._calculateMenuWidth());\n            layout.set('width', menuWidth);\n        }\n        this.notifyPropertyChange('layout');\n        this.set('contentView.needScrolling', needScrolling);\n    },\n\n    close: function() {\n        if (this.isDestroyed) { return; }\n        this.set('_highlightIndex', -1);\n        this._clearKeySearch();\n        this._super();\n    },\n\n    /* event handling starts */\n    mouseDown: function() {\n        return true;\n    },\n\n    cancel: function() {\n        this.close();\n    },\n\n    moveUp: function() { return this._selectNext(-1); },\n    moveDown: function() { return this._selectNext(1); },\n\n    moveRight: function() {\n        this._tryOpenSubmenu(true);\n        return true;\n    },\n\n    moveLeft: function() {\n        var parentMenu = this.get('parentMenu');\n        if (!Ember.isNone(parentMenu)) { parentMenu.closeCurrentlyOpenSubMenu(); }\n        return true;\n    },\n\n    insertNewline: function() {\n        this.makeSelection();\n        return true;\n    },\n\n    keyPress: function(event) {\n        var key = String.fromCharCode(event.which);\n        if (event.which > 31 && key !== '') { // Skip control characters.\n            this._doKeySearch(key);\n            return true;\n        }\n        return false;\n    },\n\n    handleMouseEvents: function(event) {\n        // This should probably be combined with our event handling in event_manager.\n        var itemIndex = this._idToIndex(event.currentTarget.id);\n        // jQuery event handling: false bubbles the stuff up.\n        var retVal = false;\n\n        if (event.type === 'mouseenter') {\n            retVal = this.mouseEntered(itemIndex);\n        } else if (event.type === 'mouseup') {\n            retVal = this.mouseClicked(itemIndex);\n        } else if (event.type === 'mousedown') {\n            retVal = true;\n        }\n        return !retVal;\n    },\n\n    /* Event handling ends */\n\n    mouseClicked: function(index) {\n        // If we're just handling a mouseUp that is part of the click that opened this menu, do nothing.\n        // When the mouseUp follows within 100ms of opening the menu, we know that's the case.\n        if (Ember.isNone(this.get('parentMenu')) && new Date().getTime() - this._openedAt < 300) {\n            return;\n        }\n\n        this.set('_highlightIndex', index);\n        // This will currently select the item even if we're not on the the current menu. Will need to figure out how\n        // to deselect an item when cursor leaves the menu totally (that is, does not move to a sub-menu).\n        if (this.get('_userHighlightIndex') >= 0) {\n            this.makeSelection();\n        }\n        return true;\n    },\n\n    mouseEntered: function(index) {\n        this.set('_userHighlightIndex', index);\n        this._tryOpenSubmenu(false);\n        return true;\n    },\n\n    _selectNext: function(increment) {\n        var menuItems = this.get('_menuItems');\n        var len = menuItems.get('length');\n        var item;\n        var index = this.get('_highlightIndex') + increment;\n        for (; index >= 0 && index < len; index += increment) {\n            item = menuItems.objectAt(index);\n            if (item.isEnabled()) {\n                this.set('_highlightIndex', index);\n                break;\n            }\n        }\n        this._clearKeySearch();\n        return true;\n    },\n\n    _valueDidChange: function() {\n        var value = this.get('value');\n        var valueKey = this.get('itemValueKey');\n        if (!Ember.isNone(value) && !Ember.isNone(valueKey)) {\n            var index = this._findIndex(function(item) {\n                return Ember.get(item, valueKey) === value;\n            });\n            if (index >= 0) {\n                this.set('_highlightIndex', index);\n            }\n        }\n    }.observes('value'),\n\n    // Propagate internal selection to possible parent\n    _internalSelectionDidChange: function() {\n        var selected = this.get('_internalSelection');\n        Ember.trySet(this, 'parentMenu._internalSelection', selected);\n    }.observes('_internalSelection'),\n\n    _findIndex: function(identityFunc) {\n        var menuItems = this.get('items');\n        var i = 0, len = menuItems.get('length');\n        for (; i < len; i++) {\n            if (identityFunc(menuItems.objectAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    },\n\n    _findByName: function(name) {\n        var re = new RegExp('^' + name.replace(/[\\^$*+?.(){}\\[\\]|]/g, \"\\\\$&\"), 'i');\n        var titleKey = this.get('itemTitleKey');\n        return this._findIndex(function(menuItem) {\n            return re.test(Ember.get(menuItem, titleKey));\n        });\n    },\n\n    _toggleClass: function(className, index, addOrRemove) {\n        var menuItem = this.get('_menuItems').objectAt(index);\n        menuItem.$().toggleClass(className, addOrRemove);\n    },\n\n    _highlightWillChange: function() {\n        var index = this.get('_highlightIndex');\n        var lastItem = this.get('_menuItems').objectAt(index);\n        if (!Ember.isNone(lastItem)) {\n            this._toggleClass('is-selected', index);\n            lastItem.isSelected = false;\n            lastItem.closeSubMenu();\n        }\n    }.observesBefore('_highlightIndex'),\n\n    _highlightDidChange: function() {\n        var index = this.get('_highlightIndex');\n        var newItem = this.get('_menuItems').objectAt(index);\n        var internalSelection = { isSet: false, value: null };\n        if (!Ember.isNone(newItem)) {\n            this._toggleClass('is-selected', index);\n            newItem.isSelected = true;\n            if (newItem.isSelectable()) {\n                internalSelection = { isSet: true, value: newItem.item };\n            }\n        }\n        this.set('_internalSelection', internalSelection);\n    }.observes('_highlightIndex'),\n\n    /**\n      We only want to allow selecting menu items after the user has moved the mouse. We update\n      userHighlightIndex when user highlights something, and internally we use highlightIndex to keep\n      track of which item is highlighted, only allowing selection if user has highlighted something.\n      If we don't ensure the user has highlighted something before allowing selection, this means that when\n      a user clicks a SelectViewButton to open a menu, the mouseUp event (following the mouseDown on the select)\n      would be triggered on a menu item, and this would cause the menu to close immediately.\n    */\n    _userHighlightIndexDidChange: function() {\n        this.set('_highlightIndex', this.get('_userHighlightIndex'));\n    }.observes('_userHighlightIndex'),\n\n    _clearKeySearch: function() {\n        if (!Ember.isNone(this._timer)) {\n            Ember.run.cancel(this._timer);\n        }\n        this._searchKey = '';\n    },\n\n    _doKeySearch: function(key) {\n        this._searchKey = (this._searchKey || '') + key;\n        var index = this._findByName(this._searchKey);\n        if (index >= 0) {\n            this.set('_highlightIndex', index);\n        }\n\n        if (!Ember.isNone(this._timer)) {\n            Ember.run.cancel(this._timer);\n        }\n        this._timer = Ember.run.later(this, this._clearKeySearch, 1000);\n    },\n\n    _indexToId: function(index) {\n        return \"%@-%@\".fmt(this.get('elementId'), index);\n    },\n\n    _idToIndex: function(id) {\n        var re = new RegExp(\"%@-(\\\\d+)\".fmt(this.get('elementId')));\n        var res = re.exec(id);\n        return res && res.length === 2 ? parseInt(res[1], 10) : -1;\n    },\n\n    _tryOpenSubmenu: function(selectItem) {\n        var index = this.get('_highlightIndex');\n        var item = this.get('_menuItems').objectAt(index);\n        if (!item) {\n            return false;\n        }\n        var subMenuItems = item.subMenuItems;\n        if (!Ember.isNone(subMenuItems) && item.isEnabled() && subMenuItems.get('length') > 0) {\n            this._clearKeySearch();\n            var subMenu = item.subMenuView;\n            if (Ember.isNone(subMenu)) {\n                subMenu = this.createSubMenu(subMenuItems);\n                item.subMenuView = subMenu;\n            }\n            subMenu.popup(item.$(), this.get('subMenuPosition') || Flame.POSITION_RIGHT);\n            if (selectItem) subMenu._selectNext(1);\n            return true;\n        }\n        return false;\n    },\n\n    didInsertElement: function() {\n        this._super();\n        var self = this;\n        this.$().on('mouseenter mouseup mousedown', '.flame-menu-item-view', function(event) {\n            return self.handleMouseEvents(event);\n        });\n    },\n\n    willDestroyElement: function() {\n        this._super();\n        this.$().off('mouseenter mouseup mousedown');\n    }\n});\n", "var isWebKit = /webkit/i.test(window.navigator.userAgent);\n\nFlame.TableDataView = Flame.View.extend(Flame.Statechart, {\n    classNames: ['flame-table-data-view'],\n    acceptsKeyResponder: true,\n    batchUpdates: true,\n    updateBatchSize: 500,\n    _updateCounter: 0,\n    selectedCell: null,\n    selectionEnd: null,\n    editValue: null,\n    content: null,\n    tableViewDelegate: null,\n\n    initialFlameState: 'loaded',\n\n    loaded: Flame.State.extend({\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            if (owner.selectCell(owner._cellForTarget(event.target), false)) {\n                owner.get('selection').show();\n                this.gotoFlameState('mouseIsDown');\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            owner.set('selectedCell', null);\n            owner.set('selectionEnd', null);\n            if (owner.get('_state') === 'inDOM') {\n                owner.get('selection').children().addBack().hide();\n            }\n        }\n    }),\n\n    mouseIsDown: Flame.State.extend({\n        lastTarget: null,\n\n        mouseMove: function(event) {\n            if (event.target !== this.lastTarget) {\n                var owner = this.get('owner');\n                var cell = owner._cellForTarget(event.target);\n                if (cell && owner.isCellSelectable(cell)) {\n                    owner.set('selectionEnd', cell);\n                }\n                this.lastTarget = event.target;\n            }\n            return true;\n        },\n\n        mouseUp: function(event) {\n            this.gotoFlameState('selected');\n            return this.get('owner').invokeStateMethod('mouseUp', event);\n        }\n    }),\n\n    selected: Flame.State.extend({\n        cellUp: function(cell) {\n            return jQuery(cell.parent().prev().children()[cell.attr('data-index')]);\n        },\n\n        cellDown: function(cell) {\n            return jQuery(cell.parent().next().children()[cell.attr('data-index')]);\n        },\n\n        modifySelection: function(cell) {\n            var owner = this.get('owner');\n            if (owner.isCellSelectable(cell)) {\n                owner.set('selectionEnd', cell);\n                owner.notifySelectionChange();\n                return true;\n            }\n            return false;\n        },\n\n        _trim: function(value) {\n            // Trim value to allow correct pasting behavior to cells (normalize line changes, strip leading/trailing whitespace, but preserve tabs)\n            value = value.replace(/\\r\\n|\\r/g, '\\n');\n            value = value.replace(/^[^\\S\\t]+|[^\\S\\t]+$/g, '');\n            return value;\n        },\n\n        pasteValue: function(value) {\n            value = this._trim(value);\n            var owner = this.get('owner');\n            var data = owner.get('data');\n            var selectedCell = this.get('owner.selectedCell');\n            var rowIndex = owner.rowIndex(selectedCell);\n            var columnIndex = owner.columnIndex(selectedCell);\n\n            var pasteFailed = function(pastedValue) {\n                var tableViewDelegate = owner.get('tableViewDelegate');\n                if (tableViewDelegate && tableViewDelegate.pasteDidFail) tableViewDelegate.pasteDidFail(pastedValue);\n            };\n\n            // If only one value is in the clipboard and a range is selected,\n            // copy that value to all selected cells.\n            if (!/\\n|\\t/.test(value) && selectedCell !== this.get('owner.selectionEnd')) {\n                this._forEachSelectedCell(function(i, j, dataCell) {\n                    if (dataCell.isEditable() && dataCell.isPastable()) {\n                        var cell = owner.$('tr[data-index=%@]'.fmt(i)).find('td[data-index=%@]'.fmt(j)).first();\n                        if (!owner._validateAndSet(value, cell)) pasteFailed(value);\n                    }\n                });\n                return;\n            }\n\n            var rows = selectedCell.parent().add(selectedCell.parent().nextAll());\n            value.split('\\n').forEach(function(line, i) {\n                line.split('\\t').forEach(function(field, j) {\n                    var cell = rows[i] && rows.eq(i).children().eq(columnIndex + j);\n                    if (!cell) return;\n                    var dataCell = data[rowIndex + i][columnIndex + j];\n                    if (dataCell && dataCell.isEditable() && dataCell.isPastable()) {\n                        if (dataCell.options()) {\n                            var option = dataCell.options().findBy('title', field);\n                            if (!option) {\n                                pasteFailed(field);\n                                return;\n                            }\n                            field = option.value;\n                        }\n                        if (!owner._validateAndSet(field, cell)) pasteFailed(field);\n                    }\n                });\n            });\n        },\n\n        /**\n          For the current selection, get a value that can be pasted to another\n          TableView or spreadsheet.\n        */\n        valueForCopy: function() {\n            var value = [];\n            var row;\n            this._forEachSelectedCell(function(i, j, cell, newLine) {\n                if (newLine) {\n                    if (!Ember.isEmpty(row)) value.push(row.join('\\t'));\n                    row = [];\n                }\n                row.push(cell.isCopyable() ? cell.editableValue() : '');\n            });\n            if (!Ember.isEmpty(row)) value.push(row.join('\\t'));\n            return value.join('\\n');\n        },\n\n        _forEachSelectedCell: function(callback) {\n            var owner = this.get('owner');\n            var selectedCell = owner.get('selectedCell');\n            var selectionEnd = owner.get('selectionEnd');\n            var minRow = Math.min(owner.rowIndex(selectedCell), owner.rowIndex(selectionEnd));\n            var maxRow = Math.max(owner.rowIndex(selectedCell), owner.rowIndex(selectionEnd));\n            var minCol = Math.min(owner.columnIndex(selectedCell), owner.columnIndex(selectionEnd));\n            var maxCol = Math.max(owner.columnIndex(selectedCell), owner.columnIndex(selectionEnd));\n\n            var data = owner.get('data');\n            for (var i = minRow; i <= maxRow; i++) {\n                var newLine = true;\n                for (var j = minCol; j <= maxCol; j++) {\n                    callback(i, j, data[i][j], newLine);\n                    newLine = false;\n                }\n            }\n        },\n\n        _getCellUnderSelection: function(event) {\n            var owner = this.get('owner');\n            owner.get('selection').hide();\n            var cell = document.elementFromPoint(event.clientX, event.clientY);\n            owner.get('selection').show();\n            return cell;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            // For browsers that don't support pointer-events, clicking the selection div\n            // will absorb the mouseDown event.\n            if (jQuery(event.target).hasClass('table-selection')) {\n                event.target = this._getCellUnderSelection(event);\n            }\n\n            // If a cell is clicked that was already selected and it's a cell\n            // with fixed options, start editing it.\n            var $target = jQuery(event.target);\n            var selectedDataCell = owner.get('selectedDataCell');\n            if (!Ember.isNone(selectedDataCell) &&\n                    selectedDataCell.options && selectedDataCell.options() &&\n                    $target.is('td') &&\n                    owner._cellForTarget(event.target)[0] === owner.get('selectedCell')[0]) {\n                this.startEdit();\n                return true;\n            }\n\n            var target = owner._cellForTarget(event.target);\n            if (event.shiftKey && owner.isCellSelectable(target)) {\n                owner.set('selectionEnd', target);\n                return true;\n            } else if ($target.closest('.table-selection').length) {\n                // If an element inside of the selection div was clicked, we\n                // let the delegate handle the click in mouseUp.\n                return true;\n            } else {\n                this.gotoFlameState('loaded');\n                return owner.invokeStateMethod('mouseDown', event);\n            }\n        },\n\n        mouseUp: function(event) {\n            var tableViewDelegate = this.get('owner.tableViewDelegate');\n            if (tableViewDelegate && tableViewDelegate.mouseUp) {\n                var $target = jQuery(event.target);\n                // Fallback for browsers that don't support pointer-events\n                if ($target.hasClass('table-selection')) {\n                    event.target = this._getCellUnderSelection(event);\n                    $target = jQuery(event.target);\n                }\n\n                // Did we click on the cell or on an element inside the table selection?\n                var cell = $target.is('td') ? $target : jQuery(this._getCellUnderSelection(event));\n                var columnIndex = cell.attr('data-index');\n                var rowIndex = cell.parent().attr('data-index');\n\n                if (columnIndex && rowIndex) {\n                    var dataCell = this.get('owner.data')[rowIndex][columnIndex];\n                    var index = [rowIndex, columnIndex];\n                    tableViewDelegate.mouseUp(event, cell, dataCell, index, this.get('owner'));\n                }\n            }\n        },\n\n        keyDown: function(event, view) {\n            var owner = this.get('owner');\n            var selectedDataCell = owner.get('selectedDataCell');\n            if ((event.ctrlKey || event.metaKey) && !Ember.isNone(selectedDataCell)) {\n                var position = owner.get('selectedCell').position();\n                var scrollable = owner.get('parentView.scrollable');\n                var $container = owner.$('.clipboard-container');\n                $container.css({ left: position.left + scrollable.scrollLeft(), top: position.top + scrollable.scrollTop() });\n                $container.empty().show();\n                var $textarea = jQuery('<textarea></textarea>')\n                    .val(this.valueForCopy())\n                    .appendTo($container)\n                    .focus()\n                    .select();\n\n                var self = this;\n                $textarea.on('paste', function(e) {\n                    var clipboardData = e.originalEvent.clipboardData || window.clipboardData;\n                    var pastedValue = clipboardData.getData('Text');\n                    // IE11 doesn't allow AJAX requests from the paste event,\n                    // this is how we work around it.\n                    Ember.run.later(self, function() {\n                        this.pasteValue(pastedValue);\n                    }, 100);\n                });\n\n                // Make sure that control/command + <other key> combinations will still be handled by the browser\n                return false;\n            }\n\n            return !owner._handleKeyEvent('keyDown', event, view);\n        },\n\n        keyUp: function(event) {\n            var $target = jQuery(event.target);\n            if ($target.hasClass('clipboard-container textarea')) {\n                $target.off('paste');\n                var $container = this.$('.clipboard-container');\n                $container.empty().hide();\n                return true;\n            }\n            return false;\n        },\n\n        // We need to use the keyPress event, as some browsers don't report the character pressed correctly with keyDown\n        keyPress: function(event) {\n            if (event.ctrlKey || event.metaKey) return false;\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell) || !dataCell.isEditable()) {\n                return false;\n            }\n            var key = String.fromCharCode(event.which);\n            if (/[a-zA-Z0-9+*\\-\\[\\/\\=]/.test(key)) {\n                var owner = this.get('owner');\n                owner.set('editValue', key);\n                this.startEdit();\n                return true;\n            }\n            return false;\n        },\n\n        insertNewline: function(event) {\n            return this.startEdit();\n        },\n\n        deleteBackward: function(event) {\n            this.wipeCell();\n            return true;\n        },\n\n        deleteForward: function(event) {\n            this.wipeCell();\n            return true;\n        },\n\n        wipeCell: function() {\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell)) {\n                return;\n            }\n\n            if (dataCell.isEditable()) {\n                this.get('owner')._validateAndSet('');\n            }\n        },\n\n        doubleClick: function() {\n            this.startEdit();\n        },\n\n        startEdit: function(event) {\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell)) {\n                return;\n            }\n            var owner = this.get('owner');\n            if (dataCell.isEditable()) {\n                owner.set('selectionEnd', owner.get('selectedCell'));\n                this.gotoFlameState('editing');\n            } else if (!dataCell.options()) {\n                owner.set('selectionEnd', owner.get('selectedCell'));\n                this.gotoFlameState('selectingReadOnly');\n            }\n        },\n\n        cancel: function(event) {\n            this.get('owner').resignKeyResponder();\n            return true;\n        },\n\n        moveLeft: function(event) {\n            this.get('owner').selectCell(this.get('owner.selectedCell').prev());\n            return true;\n        },\n\n        moveLeftAndModifySelection: function(event) {\n            return this.modifySelection(this.get('owner.selectionEnd').prev());\n        },\n\n        moveRight: function(event) {\n            this.get('owner').selectCell(this.get('owner.selectedCell').next());\n            return true;\n        },\n\n        moveRightAndModifySelection: function(event) {\n            return this.modifySelection(this.get('owner.selectionEnd').next());\n        },\n\n        moveDown: function(event) {\n            this.get('owner').selectCell(this.cellDown(this.get('owner.selectedCell')));\n            return true;\n        },\n\n        moveDownAndModifySelection: function(event) {\n            return this.modifySelection(this.cellDown(this.get('owner.selectionEnd')));\n        },\n\n        moveUp: function(event) {\n            this.get('owner').selectCell(this.cellUp(this.get('owner.selectedCell')));\n            return true;\n        },\n\n        moveUpAndModifySelection: function(event) {\n            return this.modifySelection(this.cellUp(this.get('owner.selectionEnd')));\n        },\n\n        insertTab: function(event) {\n            this.get('owner').invokeStateMethod('moveRight');\n            return true;\n        },\n\n        insertBacktab: function(event) {\n            this.get('owner').invokeStateMethod('moveLeft');\n            return true;\n        },\n\n        enterState: function() {\n            this.get('owner').notifySelectionChange();\n        },\n\n        exitState: function() {\n            if (this.get('owner._state') !== 'inDOM') return;\n            var clipboardContainer = this.$('.clipboard-container');\n            if (clipboardContainer) clipboardContainer.empty().hide();\n        }\n    }),\n\n    // Used to allow users to select text from read-only cells\n    selectingReadOnly: Flame.State.extend({\n        cancel: function(event) {\n            this.get('owner')._cancelEditingOrSelecting();\n            return true;\n        },\n\n        insertNewline: function(event) {\n            var owner = this.get('owner');\n            this.gotoFlameState('selected');\n            owner.invokeStateMethod('moveDown');\n        },\n\n        moveLeft: function(event) {\n            this._invokeInSelected('moveLeft');\n        },\n\n        moveRight: function(event) {\n            this._invokeInSelected('moveRight');\n        },\n\n        moveDown: function(event) {\n            this._invokeInSelected('moveDown');\n        },\n\n        moveUp: function(event) {\n            this._invokeInSelected('moveUp');\n        },\n\n        insertTab: function(event) {\n            this._invokeInSelected('insertTab');\n        },\n\n        insertBacktab: function(event) {\n            this._invokeInSelected('insertBacktab');\n        },\n\n        deleteBackward: function(event) {\n            this.gotoFlameState('selected');\n            return true;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            var cell = owner._cellForTarget(event.target);\n            if (owner.isCellSelectable(cell)) {\n                this.gotoFlameState('selected');\n                owner.selectCell(cell);\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            var selection = owner.get('selection');\n            var dataCell = owner.get('selectedDataCell');\n            var readOnlyValue = owner.editableValue(dataCell, true);\n            this.selectionContent = selection.html();\n            selection.html(readOnlyValue);\n            selection.addClass('read-only is-selectable');\n        },\n\n        exitState: function() {\n            var selection = this.get('owner.selection');\n            selection.html(this.selectionContent);\n            selection.removeClass('read-only is-selectable');\n        },\n\n        _invokeInSelected: function(action) {\n            var owner = this.get('owner');\n            this.gotoFlameState('selected');\n            owner.invokeStateMethod(action);\n        }\n    }),\n\n    editing: Flame.State.extend({\n        cancel: function(event) {\n            this.get('owner')._cancelEditingOrSelecting();\n            return true;\n        },\n\n        moveLeft: function() {\n            return Flame.ALLOW_BROWSER_DEFAULT_HANDLING;\n        },\n\n        moveRight: function() {\n            return Flame.ALLOW_BROWSER_DEFAULT_HANDLING;\n        },\n\n        insertNewline: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('moveDown');\n            }\n            return true;\n        },\n\n        insertTab: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('insertTab');\n            }\n            return true;\n        },\n\n        insertBacktab: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('insertBacktab');\n            }\n            return true;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            var cell = owner._cellForTarget(event.target);\n            var editField = owner.get('editField');\n            if (owner.isCellSelectable(cell) && owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.selectCell(cell);\n                return true;\n            } else if (!Ember.isEmpty(cell) && editField && cell[0] !== editField[0] && !owner._confirmEdit()) {\n                editField.focus();\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            var selectedCell = owner.get('selectedCell');\n            var dataCell = owner.get('selectedDataCell');\n            var editCell = owner.get('editField');\n            var selection = owner.get('selection');\n            var options = dataCell.options();\n\n            selectedCell.addClass('editing');\n\n            if (!dataCell.showEditor(selectedCell, owner, owner.get('content'))) {\n                // No special editor, use one of the defaults\n                if (options) { // Drop down menu for fields with a fixed set of options\n                    var menu = Flame.MenuView.createWithMixins({\n                        minWidth: selectedCell.outerWidth(),\n                        parent: owner, // Reference to the cube table view\n                        items: options.map(function(o) {\n                            return {\n                                title: o.title,\n                                value: o.value,\n                                isChecked: o.value === dataCell.value,\n                                action: function() { owner.didSelectMenuItem(this.get('value')); }\n                            };\n                        }),\n                        // Make the cube table view go back to the selected state when the menu is closed\n                        close: function() {\n                            owner.gotoFlameState('selected');\n                            this._super();\n                        }\n                    });\n                    menu.popup(selectedCell);\n                } else { // Normal edit field for everything else\n                    var backgroundColor = selectedCell.css('backgroundColor');\n\n                    // If background color is unset, it defaults to transparent. Different browser have different\n                    // ways of saying \"transparent\". Let's assume \"transparent\" actually means \"white\".\n                    if (['rgba(0, 0, 0, 0)', 'transparent'].contains(backgroundColor)) {\n                        backgroundColor = 'white';\n                    }\n\n                    editCell.css({\n                        left: parseInt(selection.css('left'), 10) + parseInt(selection.css('border-left-width'), 10) + 'px',\n                        top: parseInt(selection.css('top'), 10) + parseInt(selection.css('border-top-width'), 10) + 'px',\n                        width: selection.outerWidth() - parseInt(selection.css('border-left-width'), 10) - parseInt(selection.css('border-right-width'), 10) + 'px',\n                        height: selection.outerHeight() - parseInt(selection.css('border-top-width'), 10) - parseInt(selection.css('border-bottom-width'), 10) + 'px',\n                        backgroundColor: backgroundColor\n                    });\n                    var editValue = owner.editableValue(dataCell);\n                    editCell.val(editValue);\n                    editCell.attr('placeholder', dataCell.placeholder());\n                    owner.set('editValue', null);\n                    editCell.show();\n                    // Put cursor at end of value\n                    editCell.selectRange(editValue.length, editValue.length);\n                }\n            }\n        },\n\n        exitState: function() {\n            var owner = this.get('owner');\n            var editField = owner.get('editField');\n            editField.hide();\n            editField.removeClass('invalid');\n\n            owner.get('selectedCell').removeClass('editing');\n        }\n    }),\n\n    notifySelectionChange: function() {\n        var tableViewDelegate = this.get('tableViewDelegate');\n        if (tableViewDelegate && tableViewDelegate.didMakeSelection) {\n            tableViewDelegate.didMakeSelection(\n                this,\n                this.get('selectedCell'),\n                this.get('selectionEnd'),\n                this.get('selectedDataCell')\n            );\n        }\n    },\n\n    didSelectMenuItem: function(value) {\n        var editField = this.get('editField');\n        editField.val(value || '');\n        this._confirmEdit();\n        this.invokeStateMethod('moveDown');\n    },\n\n    willLoseKeyResponder: function() {\n        this.gotoFlameState('loaded');\n    },\n\n    columnIndex: function(cell) {\n        return parseInt(cell.attr('data-index'), 10);\n    },\n\n    rowIndex: function(cell) {\n        return parseInt(cell.parent().attr('data-index'), 10);\n    },\n\n    // Get the Cell instance that corresponds to the selected cell in the view\n    selectedDataCell: function() {\n        var selectedCell = this.get('selectedCell');\n        return this.get('data')[this.rowIndex(selectedCell)][this.columnIndex(selectedCell)];\n    }.property().volatile(),\n\n    editableValue: function(dataCell, readOnly) {\n        var editValue = this.get('editValue');\n        if (editValue !== null) {\n            return editValue;\n        } else {\n            editValue = readOnly ? dataCell.formattedValue() : dataCell.editableValue();\n            return !Ember.isNone(editValue) ? editValue : '';\n        }\n    },\n\n    didInsertElement: function() {\n        this.set('selection', this.$('.table-selection'));\n        this.set('editField', this.$('.table-edit-field'));\n    },\n\n    _selectionDidChange: function() {\n        Ember.run.once(this, this._updateSelection);\n    }.observes('selectedCell', 'selectionEnd'),\n\n    _updateSelection: function() {\n        var selectedCell = this.get('selectedCell');\n        if (!selectedCell) return;\n\n        var selection = this.get('selection');\n        var scrollable = this.get('parentView.scrollable');\n        var position = selectedCell.position();\n        var scrollTop = scrollable.scrollTop();\n        var scrollLeft = scrollable.scrollLeft();\n\n        selectedCell.addClass('active-cell');\n        selection.css(this._selectionCSS(selectedCell, this.get('selectionEnd'), scrollTop, scrollLeft, position));\n\n        if (this.get('parentView.currentFlameState.name') === 'resizing') {\n            return; // Scrolling the viewport used to mess up resizing columns when the selected cell was not in view\n        }\n\n        // Ensure the selection is within the visible area of the scrollview\n        if (position.top < 0) {\n            scrollable.scrollTop(scrollTop + position.top);\n        } else if (position.top + selectedCell.outerHeight() > scrollable.outerHeight()) {\n            var top = position.top + selectedCell.outerHeight() - scrollable.outerHeight();\n            scrollable.scrollTop(top + scrollTop + 17);\n        } else if (position.left < 0) {\n            scrollable.scrollLeft(scrollLeft + position.left);\n        } else if (position.left + selectedCell.outerWidth() > scrollable.outerWidth()) {\n            var left = position.left + selectedCell.outerWidth() - scrollable.outerWidth();\n            scrollable.scrollLeft(left + scrollLeft + 17);\n        }\n    },\n\n    _selectionCSS: function(startCell, endCell, scrollTop, scrollLeft, position) {\n        var offset = isWebKit ? 0 : 1;\n        endCell = endCell || startCell;\n        var startPosition = position;\n        var endPosition = startCell === endCell ? position : endCell.position();\n\n        var minLeft = Math.min(startPosition.left, endPosition.left);\n        var minTop = Math.min(startPosition.top, endPosition.top);\n        var maxLeft = Math.max(startPosition.left, endPosition.left);\n        var maxTop = Math.max(startPosition.top, endPosition.top);\n\n        var cellWidth = startPosition.left < endPosition.left ? endCell.outerWidth() : startCell.outerWidth();\n        var cellHeight = startPosition.top < endPosition.top ? endCell.outerHeight() : startCell.outerHeight();\n\n        return {\n            left: minLeft + scrollLeft - offset,\n            top: minTop + scrollTop - offset,\n            width: maxLeft + cellWidth - minLeft - 5,\n            height: maxTop + cellHeight - minTop - 3\n        };\n    },\n\n    _selectionWillChange: function() {\n        var selectedCell = this.get('selectedCell');\n        if (selectedCell) {\n            selectedCell.removeClass('active-cell');\n        }\n    }.observesBefore('selectedCell'),\n\n    _confirmEdit: function() {\n        var newValue = this.get('editField').val();\n        if (!this._validateAndSet(newValue)) {\n            this.get('editField').addClass('invalid');\n            return false;\n        }\n        return true;\n    },\n\n    // Returns true if cell valid, or false otherwise\n    _validateAndSet: function(newValue, cell) {\n        var data = this.get('data');\n        var selectedCell = cell || this.get('selectedCell');\n        var columnIndex = this.columnIndex(selectedCell);\n        var rowIndex = this.rowIndex(selectedCell);\n        var dataCell = data[rowIndex][columnIndex];\n\n        // Skip saving if value has not been changed\n        if (Ember.compare(dataCell.editableValue(), newValue) === 0) {\n            return true;\n        } else if (dataCell.validate(newValue)) {\n            var tableViewDelegate = this.get('tableViewDelegate');\n            Ember.assert('No tableViewDelegate set!', !!tableViewDelegate || !!tableViewDelegate.cellUpdated);\n\n            var index = [rowIndex, columnIndex];\n            if (tableViewDelegate.cellUpdated(dataCell, newValue, index)) {\n                var dirtyCells = this.get('dirtyCells').slice();\n                dirtyCells.push([rowIndex, columnIndex]);\n                this.set('dirtyCells', dirtyCells);\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    _cancelEditingOrSelecting: function() {\n        this.gotoFlameState('selected');\n    },\n\n    selectCell: function(newSelection, notify) {\n        if (this.get('parentView.allowSelection') && this.isCellSelectable(newSelection)) {\n            this.setProperties({\n                selectedCell: newSelection,\n                selectionEnd: newSelection\n            });\n            if (notify !== false) this.notifySelectionChange();\n            return true;\n        }\n        return false;\n    },\n\n    isCellSelectable: function(cell) {\n        return cell && cell[0] && cell[0].nodeName === 'TD';\n    },\n\n    _cellForTarget: function(target) {\n        return jQuery(target).closest('td', this.$());\n    },\n\n    updateColumnWidth: function(index, width) {\n        var cells = this.$('td[data-index=%@]'.fmt(index));\n        cells.first().css('width', width);\n        this.propertyDidChange('selectedCell'); // Let the size of the selection div be updated\n    },\n\n    render: function(buffer) {\n        this.gotoFlameState('loaded');\n        this._renderTable(buffer);\n    },\n\n    _renderTable: function(buffer) {\n        var data = this.get('data');\n        if (!(data && data[0])) return;\n\n        var rowCount = data.length;\n        var columnCount = data[0].length;\n        var defaultCellWidth = this.get('parentView.defaultColumnWidth');\n        var columnLeafs = this.get('parentView.content.columnLeafs');\n        var cellWidth;\n\n        var classes = 'flame-table';\n        if (!this.get('parentView.allowSelection')) classes += ' is-selectable';\n        var div = document.createElement('div');\n        buffer.begin('table').attr('class', classes).attr('width', '1px');\n        buffer.pushOpeningTag();\n        for (var i = 0; i < rowCount; i++) {\n            buffer.push('<tr data-index=\"' + i + '\">');\n            for (var j = 0; j < columnCount; j++) {\n                var content;\n                var cell = data[i][j];\n                var cssClassesString = '';\n                var titleValue = '';\n                var inlineStyles = '';\n                if (cell) {\n                    content = cell.content();\n                    content = (Ember.isNone(content) ? '' : content);\n                    if (content instanceof HTMLElement || content instanceof DocumentFragment) {\n                        while (div.firstChild) div.removeChild(div.firstChild);\n                        div.appendChild(content);\n                        content = div.innerHTML;\n                    }\n                    cssClassesString = cell.cssClassesString();\n                    if (cell.inlineStyles) inlineStyles = cell.inlineStyles();\n                    titleValue = (cell.titleValue && cell.titleValue() ? 'title=\"%@\"'.fmt(cell.titleValue()) : '');\n                } else {\n                    content = '<span style=\"color: #999\">...</span>';\n                }\n                cellWidth = columnLeafs[j].get('render_width') || defaultCellWidth;\n                buffer.push('<td data-index=\"%@\" class=\"%@\" style=\"width: %@px; %@\" %@>%@</td>'.fmt(\n                    j,\n                    (cssClassesString + (j % 2 === 0 ? ' even-col' : ' odd-col')),\n                    cellWidth,\n                    titleValue,\n                    inlineStyles,\n                    content\n                ));\n            }\n            buffer.push('</tr>');\n        }\n        buffer.pushClosingTag(); // table\n\n        // Selection indicator\n        buffer.push('<div class=\"table-selection\"></div>');\n\n        // Edit field (text)\n        buffer.push('<input type=\"text\" class=\"table-edit-field\">');\n\n        // Container that will hold the textarea used for copy/pasting cells\n        buffer.push('<div class=\"clipboard-container\"></div>');\n    },\n\n    // Update dirty cells\n    _cellsDidChange: function() {\n        this.manipulateCells(this.get('dirtyCells'), function(cell, element, isEvenColumn) {\n            var cssClassesString = (cell ? cell.cssClassesString() : '') + (isEvenColumn ? \" even-col\" : \" odd-col\");\n            var content = cell.content();\n            var titleValue = cell.titleValue && cell.titleValue();\n            var inlineStyles = cell.inlineStyles ? cell.inlineStyles() : '';\n            var cellWidth = element.style.width;\n            if (!Ember.isNone(cellWidth)) inlineStyles = 'width: %@; %@'.fmt(cellWidth, inlineStyles);\n            element.setAttribute('style', inlineStyles);\n            element.className = cssClassesString;\n\n            if (content instanceof HTMLElement || content instanceof DocumentFragment) {\n                while (element.firstChild) element.removeChild(element.firstChild);\n                element.appendChild(content);\n            } else {\n                element.textContent = Ember.isNone(content) ? '' : content;\n            }\n\n            if (titleValue) {\n                element.title = titleValue;\n            }\n        }, ++this._updateCounter);\n    }.observes('dirtyCells').on('init'),\n\n    // Mark and disable updating cells\n    _updatingCellsDidChange: function() {\n        this.manipulateCells(this.get('cellsMarkedForUpdate'), function(cell, element, isEvenColumn) {\n            if (cell.pending) {\n                // Cell isn't loaded yet, insert a placeholder value\n                cell.pending.isUpdating = true;\n                element.className += (isEvenColumn ? ' even-col' : ' odd-col');\n            } else {\n                cell.isUpdating = true;\n                var cssClassesString = cell.cssClassesString() + (isEvenColumn ? ' even-col' : ' odd-col');\n                element.className = cssClassesString;\n            }\n        });\n    }.observes('cellsMarkedForUpdate'),\n\n    manipulateCells: function(cellRefs, callback, updateCounter) {\n        var data = this.get('data');\n        if (!cellRefs || cellRefs.length === 0 || !this.$()) return;\n        var table = this.$('table.flame-table');\n\n        var allCells = table.find('td');\n        // Everyone expects that the cellRefs array is empty when we return from this function. We still need the\n        // content so save it elsewhere.\n        var content = cellRefs.splice(0, cellRefs.length);\n        var updateBatchSize = this.get('batchUpdates') ? this.get('updateBatchSize') : -1;\n        this._batchUpdate(updateBatchSize, 0, updateCounter, content, data, allCells, callback);\n    },\n\n    _batchUpdate: function(maxUpdates, startIx, updateCounter, cellRefs, data, allCells, callback) {\n        if (typeof updateCounter !== 'undefined' && updateCounter !== this._updateCounter) return;\n        // If we for some reason update / change the table before all these calls have gone through, we may update\n        // nodes that no longer exist in DOM but that shouldn't cause problems.\n        var len = cellRefs.length;\n        var element, index, cell;\n        var columnLength = data[0].length;\n        // If maxUpdates is -1, we fetch everything in one batch\n        var upTo = maxUpdates === -1 ? len : maxUpdates;\n\n        for (var i = startIx; i < len && (i - startIx) < upTo; i++) {\n            index = cellRefs[i];\n            var x = index[0], y = index[1];\n            if (!data[x][y]) {\n                // Possibly updating a cell that's still being batch loaded, insert a placeholder for update attributes\n                data[x][y] = {pending: {}};\n            }\n            cell = data[x][y];\n            element = allCells[x * columnLength + y];\n            if (element) {\n                callback(cell, element, y % 2 === 0);\n            }\n        }\n        if (i < len) {\n            // We've still got some updating to do so let's do it in the next run loop. Thus we should not get any slow\n            // script errors but that doesn't mean that the interface is responsive at any degree.\n            var self = this;\n            Ember.run.next(function() {\n                self._batchUpdate(maxUpdates, i, updateCounter, cellRefs, data, allCells, callback);\n            });\n        }\n    }\n});\n", "//= require ./table_data_view\n\nvar alias = Ember.computed.alias;\n\nvar unbindScroll = function() {\n    var scrollable = this.get('scrollable');\n    if (scrollable) {\n        scrollable.off('scroll');\n    }\n};\n\nFlame.TableView = Flame.View.extend(Flame.Statechart, {\n    MIN_COLUMN_WIDTH: 30,\n\n    classNames: ['flame-table-view'],\n    childViews: ['tableDataView'],\n    displayProperties: ['contentAdapter.headers'],\n    acceptsKeyResponder: false,\n\n    // References to DOM elements\n    scrollable: null, // the scrollable div that holds the data table\n    rowHeader: null, // the row header table element\n    columnHeader: null, // the column header table element\n    tableCorner: null,\n\n    renderColumnHeader: true,\n    renderRowHeader: true,\n    isRowHeaderClickable: true,\n    isResizable: true,\n    allowSelection: false,\n\n    initialFlameState: 'idle',\n\n    defaultColumnWidth: 88,\n    rowHeaderWidth: null,\n    content: null, // Set to a Flame.TableController\n    allowRefresh: true,\n    batchUpdates: true,\n    useAutoWidth: false,\n    tableViewDelegate: null,\n\n    contentAdapter: function() {\n        return Flame.TableViewContentAdapter.create({\n            content: this.get('content')\n        });\n    }.property('content'),\n\n    tableDataView: Flame.TableDataView.extend({\n        dataBinding: 'parentView.content._data',\n        content: alias('parentView.content'),\n        dirtyCells: alias('parentView.content.dirtyCells'),\n        areValuesOnRows: alias('parentView.content.areValuesOnRows'),\n        totalRowIds: alias('parentView.content.totalRowIds'),\n        totalColumnIds: alias('parentView.content.totalColumnIds'),\n        tableViewDelegate: alias('parentView.tableViewDelegate'),\n        cellsMarkedForUpdate: alias('parentView.content.cellsMarkedForUpdate'),\n        batchUpdates: alias('parentView.batchUpdates')\n    }),\n\n    rowDepth: function() {\n        return this.get('contentAdapter.rowHeaderRows.maxDepth');\n    }.property('contentAdapter.rowHeaderRows'),\n\n    /* IE 5-8 trigger mouse events in unorthodox order:\n\n     IE 5-8:        Any sane browser:\n     mousedown      mousedown\n     mouseup        mouseup\n     click          click\n     mouseup        mousedown\n     dblclick       mouseup\n                    click\n                    dblclick\n\n     Normally, the dblclick event works as expected, because the mouseup event is not being triggered for idle state\n     if mouseDown precedes it (because mouseup event is handled in resizing state). However, because IE8 triggers\n     two mouseups but only one mousedown for a dblclick event, the mouseUp function is called for idle state - which\n     in turn opens the sort order panel.\n\n     By adding another state we can mitigate the issue. The mousedown event puts the view into clickInProgress\n     state, and in clickInProgress mouseup returns it back to idle state. So, the state transition works as before.\n     However, if user clicks the resize-handle the view goes to resizing state. The first mouseup event moves the view\n     back to idle state, where the second redundant mouseup gets eaten silently.\n    */\n    idle: Flame.State.extend({\n        mouseDown: function(event) {\n            this.gotoFlameState('clickInProgress');\n\n            var target = jQuery(event.target);\n            if (target.is('div.resize-handle')) {\n                var owner = this.get('owner');\n                // If a table cell is being edited at this point, its 'editField' would get displaced by the resizing operation, so we just turn the editing off\n                var tableDataView = owner.get('tableDataView');\n                if (tableDataView.get('currentFlameState.name') === 'editing') {\n                    tableDataView.cancel();\n                }\n                var cell = target.closest('td');\n                owner.setProperties({\n                    resizingCell: cell,\n                    dragStartX: event.pageX,\n                    startX: cell.get(0).clientWidth + 1,\n                    offset: parseInt(this.get('owner.tableCorner').css('width'), 10),\n                    type: cell.is('.column-header td') ? 'column' : 'row'\n                });\n                this.gotoFlameState('resizing');\n                return true;\n            } else if (!!target.closest('.column-header').length) {\n                return true;\n            } else if (target.is('a')) {\n                return true;\n            }\n\n            return false;\n        },\n\n        doubleClick: function(event) {\n            var owner = this.get('owner');\n            if (!owner.get('useAutoWidth')) return false;\n\n            var target = jQuery(event.target), index, header;\n            if (!!target.closest('.column-header').length && (index = target.closest('td').attr('data-leaf-index'))) {\n                header = this.get('owner.content.columnLeafs')[index];\n\n                var columnDataAsString = owner.getColumnContents(header).map(function(e) { return e; }).join('<br>');\n                var columnDimensions = Flame.measureString(columnDataAsString, 'ember-view');\n\n                var isBold = target.closest('td').css('font-weight') === 'bold';\n                var headerLabelDimensions = Flame.measureString(owner.getLeafHeaderLabel(header), 'ember-view', 'label', isBold ? 'font-weight:bold;' : '');\n\n                var width = Math.max(columnDimensions.width, headerLabelDimensions.width) + 40;\n\n                if (width < owner.MIN_COLUMN_WIDTH) width = owner.MIN_COLUMN_WIDTH;\n                owner.setColumnWidth(header.leafIndex, width);\n                var resizeDelegate = owner.get('tableViewDelegate');\n                if (resizeDelegate && resizeDelegate.columnResized) {\n                    resizeDelegate.columnResized(index, width);\n                }\n                return true;\n            }\n            return false;\n        }\n    }),\n\n    clickInProgress: Flame.State.extend({\n        mouseUp: function(event) {\n            this.gotoFlameState('idle');\n            var clickDelegate = this.get('owner.tableViewDelegate');\n            if (clickDelegate) {\n                var target = jQuery(event.target);\n                var header;\n                if (!!target.closest('.column-header').length) {\n                    if (clickDelegate.columnHeaderClicked) {\n                        // Find the corresponding TableHeader instance for the clicked cell.\n                        var level = parseInt(target.closest('tr').attr('class').match(/level\\-(\\d+)/)[1], 10);\n                        var row = this.get('owner.contentAdapter.columnHeaderRows')[level - 1];\n                        header = row[target.closest('tr').find('td').index(target.closest('td'))];\n                        clickDelegate.columnHeaderClicked(header, target);\n                    }\n                    return true;\n                } else if (!!target.closest('.row-header').length) {\n                    if (clickDelegate.rowHeaderClicked) {\n                        var cell = target.closest('td');\n                        var index = parseInt(cell.attr('data-index'), 10);\n                        header = this.get('owner.content._headers.rowHeaders')[index];\n                        if (!header) return false;\n                        clickDelegate.rowHeaderClicked(header, target, index);\n                    }\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }),\n\n    resizing: Flame.State.extend({\n        enterState: function() {\n            var cell = this.get('owner.resizingCell');\n            var $table = cell.closest('table');\n            var columns = $table.find('col');\n\n            if (this.get('owner.type') === 'column') {\n                var column = parseInt(cell.attr('data-leaf-index'), 10);\n                this.set('resizingColumn', columns.eq(column));\n            } else {\n                var totalDepth = columns.length;\n                var cells = [];\n                $table.find('td').each(function() {\n                    var $cell = $(this);\n                    if (!$cell.attr('colspan')) cells.push($cell);\n                    if (cells.length === totalDepth) return false;\n                });\n                this.set('cells', cells);\n\n                // Get column index for resized cell\n                // must account for row headers spanning multiple columns to get the right leafIndex and width\n                var remainingDepth = 0;\n                cell.nextAll().each(function() {\n                    remainingDepth += $(this).attr('colspan') || 1;\n                });\n                var leafIndex = totalDepth - remainingDepth - 1;\n\n                this.set('resizingColumn', columns.eq(leafIndex));\n                this.set('owner.resizingCell', cells[leafIndex]);\n                this.set('owner.startX', cells[leafIndex].get(0).clientWidth + 1);\n            }\n        },\n\n        mouseMove: function(event) {\n            var owner = this.get('owner');\n            var deltaX = event.pageX - owner.get('dragStartX');\n            var minWidth = owner.get('MIN_COLUMN_WIDTH');\n            var cellWidth = owner.get('startX') + deltaX;\n            if (cellWidth < minWidth) cellWidth = minWidth;\n            // Adjust size of the cell\n            if (owner.get('type') === 'column') { // Update data table column width\n                this.get('resizingColumn').css('width', cellWidth);\n                owner._synchronizeColumnWidth(cellWidth);\n            } else {\n                var width = owner.get('offset') + cellWidth - owner.get('startX');\n\n                // Move data table and column header\n                owner.get('scrollable').css('left', width);\n                owner.get('columnHeader').parent().css('left', width);\n                owner.get('tableCorner').css('width', width);\n\n                this.get('resizingColumn').css('width', cellWidth);\n            }\n        },\n\n        mouseUp: function(event) {\n            var owner = this.get('owner');\n            var resizeDelegate = owner.get('tableViewDelegate');\n            if (resizeDelegate) {\n                var cell = owner.get('resizingCell');\n                if (owner.get('type') === 'column' && resizeDelegate.columnResized) {\n                    var width = parseInt(cell.css('width'), 10);\n                    var index = parseInt(cell.attr('data-leaf-index'), 10);\n                    resizeDelegate.columnResized(index, width);\n                } else if (resizeDelegate.rowHeaderResized) {\n                    // Can't use col-element to get the width from as it does not work correctly in IE\n                    var widths = this.get('cells').map(function(cell) { return cell.outerWidth(); });\n                    resizeDelegate.rowHeaderResized(widths);\n                }\n            }\n            this.gotoFlameState('idle');\n            return true;\n        }\n    }),\n\n    setColumnWidth: function(columnIndex, cellWidth) {\n        this.$('.column-header col').eq(columnIndex).css('width', cellWidth + 3);\n        var table = this.objectAt(0);\n        table.updateColumnWidth(columnIndex, cellWidth + 3);\n    },\n\n    getColumnContents: function(columnHeader) {\n        return this.get('content.tableData').map(function(e) {\n            var elem = e[columnHeader.leafIndex];\n            return Ember.isNone(elem) ? '' : elem.formattedValue();\n        });\n    },\n\n    getLeafHeaderLabel: function(header) {\n        var leaf = this.get('content.columnLeafs')[header.leafIndex];\n        return leaf.get('headerLabel');\n    },\n\n    _synchronizeColumnWidth: function(width) {\n        // Update data table columns\n        var cell = this.get('resizingCell');\n        var table = this.objectAt(0);\n        var index = parseInt(cell.attr('data-leaf-index'), 10);\n        table.updateColumnWidth(index, width);\n    },\n\n    willInsertElement: unbindScroll,\n    willDestroyElement: unbindScroll,\n\n    didInsertElement: function() {\n        this.set('scrollable', this.$('.scrollable'));\n        this.set('rowHeader', this.$('.row-header table'));\n        this.set('columnHeader', this.$('.column-header table'));\n        this.set('tableCorner', this.$('.table-corner'));\n        this.get('scrollable').on('scroll', jQuery.proxy(this.didScroll, this));\n    },\n\n    isScrolling: false,\n    didScroll: function(event) {\n        var scrollable = this.get('scrollable');\n        this.lastScrollTop = scrollable.scrollTop();\n        this.lastScrollLeft = scrollable.scrollLeft();\n        if (!this.isScrolling) {\n            requestAnimationFrame(jQuery.proxy(this._updateHeaderPositions, this));\n        }\n        this.isScrolling = true;\n    },\n\n    _updateHeaderPositions: function() {\n        if (this.lastScrollTop !== this.lastSetScrollTop) {\n            this.get('rowHeader').css('top', -this.lastScrollTop);\n            this.lastSetScrollTop = this.lastScrollTop;\n        }\n        if (this.lastScrollLeft !== this.lastSetScrollLeft) {\n            this.get('columnHeader').css('left', -this.lastScrollLeft);\n            this.lastSetScrollLeft = this.lastScrollLeft;\n        }\n        this.isScrolling = false;\n    },\n\n    render: function(buffer) {\n        var renderColumnHeader = this.get('renderColumnHeader');\n        var renderRowHeader = this.get('renderRowHeader');\n        var didRenderTitle = false;\n\n        var headers = this.get('contentAdapter.headers');\n        if (!headers) {\n            return; // Nothing to render\n        }\n\n        if (this.get('content.title')) {\n            buffer.push('<div class=\"panel-title\">%@</div>'.fmt(this.get('content.title')));\n            didRenderTitle = true;\n        }\n\n        var defaultColumnWidth = this.get('defaultColumnWidth');\n        var defaultRowHeaderWidth = this.get('rowHeaderWidth') || defaultColumnWidth;\n        var rowHeaderWidths = this.get('content').rowHeaderWidths ? this.get('content').rowHeaderWidths() : null;\n\n        var columnHeaderRows = this.get('contentAdapter.columnHeaderRows');\n        var rowHeaderRows = this.get('contentAdapter.rowHeaderRows');\n        var columnHeaderHeight = columnHeaderRows.maxDepth * 21 + 1 + columnHeaderRows.maxDepth;\n        var leftOffset = 0;\n        if (renderRowHeader) {\n            if (rowHeaderWidths) {\n                var totalWidth = 0;\n                for (var i = 0; i < Math.max(rowHeaderRows.maxDepth, 1); i++) {\n                    totalWidth += isNaN(rowHeaderWidths[i]) ? defaultRowHeaderWidth : rowHeaderWidths[i];\n                }\n                leftOffset = totalWidth + 1 + (renderColumnHeader ? 0 : 5);\n            } else {\n                leftOffset = rowHeaderRows.maxDepth * defaultRowHeaderWidth + 1 + (renderColumnHeader ? 0 : 5);\n            }\n        }\n        var topOffset = didRenderTitle ? 18 : 0;\n\n        if (renderColumnHeader) {\n            // Top left corner of the headers\n            buffer.push('<div class=\"table-corner\" style=\"top: %@px; left: 0; height: %@px; width: %@px;\"></div>'.fmt(topOffset, columnHeaderHeight, leftOffset));\n            // Column headers\n            this._renderHeader(buffer, 'column', leftOffset, defaultColumnWidth);\n            topOffset += columnHeaderHeight;\n        }\n        if (renderRowHeader) {\n            // Row headers\n            this._renderHeader(buffer, 'row', topOffset, defaultRowHeaderWidth);\n        }\n\n        // Scrollable div\n        buffer.push('<div class=\"scrollable\" style=\"overflow: auto; bottom: 0; top: %@px; left: %@px; right: 0;\">'.fmt(topOffset, leftOffset));\n        // There should really only be one child view, the TableDataView\n        this.forEach(function(view) {\n            view.renderToBuffer(buffer);\n        });\n        buffer.push('</div>');\n    },\n\n    _renderHeader: function(buffer, type, offset, defaultColumnWidth) {\n        var headers = this.get('contentAdapter.headers');\n        if (!headers) {\n            buffer.push('<div></div>');\n            return;\n        }\n\n        var position, i;\n        if (type === 'column') {\n            headers = this.get('contentAdapter.columnHeaderRows');\n            position = 'left';\n        } else {\n            headers = this.get('contentAdapter.rowHeaderRows');\n            position = 'top';\n        }\n        var length = headers.length;\n\n        buffer.begin('div').addClass('%@-header'.fmt(type)).attr('style', 'position: absolute; %@: %@px'.fmt(position, offset));\n        buffer.pushOpeningTag();\n        buffer.begin('table').attr('style', 'position: absolute').attr('width', '1px');\n        buffer.pushOpeningTag();\n\n        buffer.push('<colgroup>');\n        if (type === 'row') {\n            var widths = this.get('content').rowHeaderWidths ? this.get('content').rowHeaderWidths() : null;\n            for (i = 0; i < (headers.maxDepth || 1); i++) {\n                var width = (widths && widths[i]) ? widths[i] : defaultColumnWidth;\n                buffer.push('<col style=\"width: %@px;\" class=\"level-%@\">'.fmt(width, i + 1));\n            }\n        } else {\n            var l = this.get('content.columnLeafs').length;\n            for (i = 0; i < l; i++) {\n                buffer.push('<col style=\"width: %@px;\">'.fmt(this.get('content.columnLeafs')[i].get('render_width') || defaultColumnWidth));\n            }\n        }\n        buffer.push('</colgroup>');\n\n        for (i = 0; i < length; i++) {\n            if (type === 'column') {\n                buffer.push('<tr class=\"level-%@\">'.fmt(i + 1));\n            } else {\n                buffer.push('<tr>');\n            }\n            this._renderRow(buffer, headers[i], type, i);\n            buffer.push('</tr>');\n        }\n\n        buffer.pushClosingTag(); // table\n        buffer.pushClosingTag(); // div\n    },\n\n    _renderRow: function(buffer, row, type, rowIndex) {\n        var length = row.length;\n        var label, sortDirection, headerLabel;\n\n        function countLeaves(headerNode) {\n            if (headerNode.hasOwnProperty('children')) {\n                var count = 0;\n                for (var idx = 0; idx < headerNode.children.length; idx++) {\n                    count += countLeaves(headerNode.children[idx]);\n                }\n                return count;\n            } else {\n                return 1;\n            }\n        }\n\n        for (var i = 0; i < length; i++) {\n            var header = row[i];\n            buffer.begin('td');\n\n            headerLabel = header.get ? header.get('headerLabel') : header.label;\n            if (!headerLabel) headerLabel = \"\";\n\n            buffer.attr('title', headerLabel.replace(/<br>/g, '\\n'));\n\n            if (header.rowspan > 1) {\n                buffer.attr('rowspan', header.rowspan);\n            }\n            if (header.colspan > 1) {\n                buffer.attr('colspan', header.colspan);\n            }\n\n            label = '<div class=\"label\">%@</div>';\n            var resizeHandle = \"\";\n            buffer.attr('class', (i % 2 === 0 ? \"even-col\" : \"odd-col\"));\n            if (type === 'column' && !header.hasOwnProperty('children')) { // Leaf node\n                buffer.attr('data-index', i);\n                // Mark the leafIndex, so when sorting it's trivial to find the correct field to sort by\n                buffer.attr('data-leaf-index', header.leafIndex);\n                if (this.get('isResizable') && this.get('renderColumnHeader')) {\n                    resizeHandle = '<div class=\"resize-handle\">&nbsp;</div>';\n                }\n\n                var headerSortDelegate = this.get('tableViewDelegate');\n                if (headerSortDelegate && headerSortDelegate.getSortForHeader) {\n                    var activeSort = headerSortDelegate.getSortForHeader(header);\n                    sortDirection = activeSort ? activeSort.direction : null;\n                }\n                var sortClass = sortDirection ? 'sort-%@'.fmt(sortDirection) : '';\n                label = '<div class=\"label ' + sortClass + '\">%@</div>';\n            } else if (type === 'row') {\n                buffer.attr('data-index', header.dataIndex);\n                if (this.get('renderColumnHeader')) {\n                    if (this.get(\"isResizable\")) {\n                        if (header.hasOwnProperty('children')) {\n                            // Ensure that resize-handle covers the whole height of the cell border. Mere child count\n                            // does not suffice with multi-level row headers.\n                            var leafCount = countLeaves(header);\n                            resizeHandle = '<div class=\"resize-handle\" style=\"height: %@px\"></div>'.fmt(leafCount * 21);\n                        } else {\n                            resizeHandle = '<div class=\"resize-handle\"></div>';\n                        }\n                    }\n                    if (this.get('isRowHeaderClickable') && header.get('isClickable')) {\n                        label = '%@';\n                    }\n                }\n            }\n\n            buffer.pushOpeningTag(); // td\n            buffer.push('<div class=\"content-container\">');\n            buffer.push(resizeHandle);\n            buffer.push(label.fmt(headerLabel));\n            buffer.push('</div>');\n            buffer.pushClosingTag(); // td\n        }\n    }\n});\n"], "fixing_code": ["Ember.mixin(Flame, {\n    _setupStringMeasurement: function(parentClasses, elementClasses, additionalStyles) {\n        if (!parentClasses) parentClasses = '';\n        if (!elementClasses) elementClasses = '';\n        if (!additionalStyles) additionalStyles = '';\n\n        var element = this._metricsCalculationElement;\n        if (!element) {\n            var parentElement = document.createElement('div');\n            parentElement.style.cssText = 'position:absolute; left:-10010px; top:-10px; width:10000px; visibility:hidden;';\n            element = this._metricsCalculationElement = document.createElement('div');\n            parentElement.appendChild(element);\n            document.body.insertBefore(parentElement, null);\n        }\n\n        element.parentNode.className = parentClasses;\n        element.className = elementClasses;\n        element.style.cssText = 'position:absolute; left: 0; top: 0; bottom: auto; right: auto; width: auto; height: auto;' + additionalStyles;\n        return element;\n    },\n\n    measureString: function(stringOrArray, parentClasses, elementClasses, additionalStyles) {\n        var escape = Handlebars.Utils.escapeExpression;\n        var measuredString;\n        // We also accept an array of strings and then return the width of the longest one by joining them with <br>.\n        if (Ember.isArray(stringOrArray)) {\n            measuredString = stringOrArray.reduce(function(currentStrings, nextString) {\n                        return currentStrings + escape(nextString) + '<br>';\n                    }, '');\n        } else {\n            measuredString = escape(stringOrArray);\n        }\n        var element = this._setupStringMeasurement(parentClasses, elementClasses, additionalStyles);\n        element.innerHTML = measuredString;\n        return {\n            width: element.clientWidth,\n            height: element.clientHeight\n        };\n    }\n});\n", "//= require ./button_view\n\n// A checkbox. The state of the checkbox is indicated by the isSelected property.\nFlame.CheckboxView = Flame.ButtonView.extend({\n    classNames: ['flame-checkbox-view'],\n    isSticky: true,\n\n    render: function(buffer) {\n        buffer.push('<div class=\"flame-checkbox-box\"></div>');\n        this.renderCheckMark(buffer);\n        buffer.push('<label class=\"flame-checkbox-label\">');\n        buffer.push(Ember.isNone(this.get('title')) ? '' : Handlebars.Utils.escapeExpression(this.get('title')));\n        buffer.push('</label>');\n    },\n\n    renderCheckMark: function(buffer) {\n        var imgUrl = Flame.image('checkmark.svg');\n        buffer.push('<div class=\"flame-view flame-checkbox-checkmark\" style=\"left: 4px; top: 2px;\"><img src=\"' + imgUrl + '\"></div>');\n    }\n});\n", "//= require ./panel\n//= require ./collection_view\n//= require ../mixins/action_support\n//= require ./menu_scroll_view\n\n// Only to be used in Flame.MenuView. Represent menu items with normal JS objects as creation of one Ember object took\n// 3.5 ms on fast IE8 machine.\nFlame.MenuItem = function MenuItem(opts) {\n    for (var key in opts) {\n        if (opts.hasOwnProperty(key)) {\n            this[key] = opts[key];\n        }\n    }\n};\n\nFlame.MenuItem.prototype.renderToBuffer = function(buffer) {\n    var classes = ['flame-view', 'flame-list-item-view', 'flame-menu-item-view'];\n    if (this.isSelected) classes.push('is-selected');\n    if (!this.isEnabled()) classes.push('is-disabled');\n    var subMenuLength = Ember.isNone(this.subMenuItems) ? -1 : this.subMenuItems.get('length');\n    var template = '<div id=\"%@\" class=\"%@\" %@>%@%@%@</div>';\n    buffer.push(\n        template.fmt(\n            this.id,\n            classes.join(' '),\n            this.item.tooltip ? 'title=\"%@\"'.fmt(this.item.tooltip) : '',\n            this.isChecked ? '<div class=\"flame-menu-item-view-checkmark\"></div>' : '',\n            Handlebars.Utils.escapeExpression(this.title),\n            subMenuLength > 0 ? '<div class=\"menu-indicator\"></div>' : ''\n        )\n    );\n};\n\nFlame.MenuItem.prototype.isEnabled = function() {\n    return !(this.isDisabled || (this.subMenuItems && this.subMenuItems.length === 0));\n};\n\nFlame.MenuItem.prototype.isSelectable = function() {\n    return this.isEnabled() && !this.subMenuItems;\n};\n\nFlame.MenuItem.prototype.$ = function() {\n    return Ember.$('#%@'.fmt(this.id));\n};\n\nFlame.MenuItem.prototype.closeSubMenu = function() {\n    var subMenu = this.subMenuView;\n    if (!Ember.isNone(subMenu)) {\n        subMenu.close();\n        this.subMenuView = null;\n    }\n};\n\n/**\n  A menu. Can be shown as a \"stand-alone\" menu or in cooperation with a SelectButtonView.\n\n  MenuView has a property 'subMenuKey'. Should objects based on which the menu is created return null/undefined for\n  that property, the item itself will be selectable. Otherwise if the property has more than zero values, a submenu\n  will be shown.\n\n  Because of the implementation details, this menu will hold values of undefined or null as the same as not set. Thus,\n  no selectable menu item must have such value their value.\n*/\nFlame.MenuView = Flame.Panel.extend(Flame.ActionSupport, {\n    classNames: ['flame-menu'],\n    childViews: ['contentView'],\n    contentView: Flame.MenuScrollView,\n    dimBackground: false,\n    subMenuKey: 'subMenu',\n    itemTitleKey: 'title',\n    /* Attribute that can be used to indicate a disabled menu item. The item will be disabled only if\n     * isEnabled === false, not some falseish value. */\n    itemEnabledKey: 'isEnabled',\n    itemCheckedKey: 'isChecked',\n    itemValueKey: 'value',\n    itemActionKey: 'action',\n    itemHeight: 21,\n    /* Margin between the menu and top/bottom of the viewport. */\n    menuMargin: 12,\n    minWidth: null, // Defines minimum width of menu\n    items: null,\n    parentMenu: null,\n    value: null,\n    _allItemsDoNotFit: true,\n    _anchorElement: null,\n    _menuItems: null,\n    _highlightIndex: -1, // Currently highlighted index.\n    _userHighlightIndex: -1, // User selected highlighted index\n    // Reflects the content item in this menu or the deepest currently open submenu that is currently highlighted,\n    // regardless of whether mouse button is up or down. When mouse button is released, this will be set as the real\n    // selection on the top-most menu, unless it's undefined (happens if currently on a non-selectable item)\n    // This is to be handled as a unmodifiable object: always create a new object instead of mutating its properties.\n    _internalSelection: { isSet: false, value: null },\n\n    init: function() {\n        this._super();\n        this._needToRecreateItems();\n    },\n\n    _calculateMenuWidth: function() {\n        var items = this.get('items') || [];\n        if (Ember.get(items, 'length') === 0) {\n            return;\n        }\n        var itemTitleKey = this.get('itemTitleKey');\n        var allTitles = items.map(function(currentTitles, item) { Ember.get(item, itemTitleKey); });\n        // Give the menus a 16px breathing space to account for sub menu indicator, and to give some right margin (+18px for the padding)\n        return Flame.measureString(allTitles, 'ember-view flame-view flame-list-item-view flame-menu-item-view', 'title').width + 16 + 18;\n    },\n\n    _createMenuItems: function() {\n        var items = this.get('items'),\n            itemCheckedKey = this.get('itemCheckedKey'),\n            itemEnabledKey = this.get('itemEnabledKey'),\n            itemTitleKey = this.get('itemTitleKey'),\n            itemValueKey = this.get('itemValueKey'),\n            subMenuKey = this.get('subMenuKey'),\n            selectedValue = this.get('value'),\n            valueIsSet = !Ember.isNone(selectedValue),\n            menuItems;\n        menuItems = (items || []).map(function(item, i) {\n            // Only show the selection on the main menu, not in the submenus.\n            return new Flame.MenuItem({\n                item: item,\n                isSelected: valueIsSet ? Ember.get(item, itemValueKey) === selectedValue : false,\n                isDisabled: Ember.get(item, itemEnabledKey) === false,\n                isChecked: Ember.get(item, itemCheckedKey),\n                subMenuItems: Ember.get(item, subMenuKey),\n                title: Ember.get(item, itemTitleKey),\n                id: this._indexToId(i)\n            });\n        }, this);\n        return menuItems;\n    },\n\n    _needToRecreateItems: function() {\n        var menuItems = this._createMenuItems();\n        this.set('_menuItems', menuItems);\n        if (Ember.isNone(this.get('parentMenu'))) {\n            menuItems.forEach(function(item, i) {\n                if (item.isSelected) this.set('_highlightIndex', i);\n            }, this);\n        }\n        this.get('contentView').setScrolledView(this._createMenuView());\n        if (this.get('_anchorElement')) {\n            this._updateMenuSize();\n        }\n\n        // Set content of scroll stuff\n        // calculate the the height of menu\n    }.observes('items'),\n\n    _createMenuView: function() {\n        var items = this.get('_menuItems');\n        return Flame.View.create({\n            useAbsolutePosition: false,\n            render: function(buffer) {\n                items.forEach(function(menuItem) { menuItem.renderToBuffer(buffer); });\n            }\n        });\n    },\n\n    makeSelection: function() {\n        var parentMenu = this.get('parentMenu');\n        var action, value;\n        if (!Ember.isNone(parentMenu)) {\n            parentMenu.makeSelection();\n            this.close();\n        } else {\n            var internalSelection = this.get('_internalSelection');\n            if (internalSelection.isSet) {\n                value = Ember.get(internalSelection.value, this.get('itemValueKey'));\n                this.set(\"value\", value);\n                // If we have an action, call it on the selection.\n                action = Ember.get(internalSelection.value, this.get('itemActionKey')) || this.get('action');\n            }\n            // Sync the values before we tear down all bindings in close() which calls destroy().\n            Ember.run.sync();\n            // Close this menu before firing an action - the action might open a new popup, and if closing after that,\n            // the new popup panel is popped off the key responder stack instead of this menu.\n            this.close();\n            if (!Ember.isNone(action)) {\n                this.fireAction(action, value);\n            }\n        }\n    },\n\n    subMenu: function() {\n        return Flame.MenuView.extend({\n            isModal: false,\n\n            popup: function(anchor, position) {\n                if (!this.get('layout.width')) {\n                    // We already need to know the width of the menu at this point so that Panel#popup\n                    // can correctly position it.\n                    var menuWidth = Math.max(this.get('minWidth') || 0, this._calculateMenuWidth());\n                    this.set('layout.width', menuWidth);\n                }\n                this._super(anchor, position);\n            },\n\n            _layoutRelativeTo: function(anchor, position) {\n                var layout = this._super(anchor, position);\n                // If already positioned on the left, nothing else needs to be checked.\n                if (this.get('subMenuPosition') === Flame.POSITION_LEFT) return layout;\n\n                if (layout.movedX) {\n                    // Any further opened submenu should be opened on the left side.\n                    this.set('subMenuPosition', Flame.POSITION_LEFT);\n                    layout = this._super(anchor, Flame.POSITION_LEFT);\n                }\n                return layout;\n            }\n        });\n    }.property(),\n\n    // This function is here to break the dependency between MenuView and MenuItemView\n    createSubMenu: function(subMenuItems) {\n        return this.get('subMenu').create({\n            items: subMenuItems,\n            parentMenu: this,\n            subMenuKey: this.get('subMenuKey'),\n            itemEnabledKey: this.get('itemEnabledKey'),\n            itemTitleKey: this.get('itemTitleKey'),\n            itemValueKey: this.get('itemValueKey'),\n            itemHeight: this.get('itemHeight'),\n            subMenuPosition: this.get('subMenuPosition')\n        });\n    },\n\n    closeCurrentlyOpenSubMenu: function() {\n        // observers of highlightIndex should take care that closing is propagated to the every open menu underneath\n        // this menu. Close() sets highlightIndex to -1, _highlightWillChange() will call closeSubMenu() on the item\n        // which then calls close() on the menu it depicts and this is continued until no open menus remain under the\n        // closed menu.\n        var index = this.get('_highlightIndex');\n        if (index >= 0) {\n            this.get('_menuItems').objectAt(index).closeSubMenu();\n        }\n    },\n\n    popup: function(anchorElementOrJQ, position) {\n        if (Ember.isNone(this.get('parentMenu'))) {\n            this._openedAt = new Date().getTime();\n        }\n        var anchorElement = anchorElementOrJQ instanceof jQuery ? anchorElementOrJQ : anchorElementOrJQ.$();\n        this._super(anchorElement, position);\n        this.set('_anchorElement', anchorElement);\n        this._updateMenuSize();\n    },\n\n    _updateMenuSize: function() {\n        var anchorElement = this.get('_anchorElement');\n        // These values come from the CSS but we still need to know them here. Is there a better way?\n        var paddingTop = 5;\n        var paddingBottom = 5;\n        var borderWidth = 1;\n        var totalPadding = paddingTop + paddingBottom;\n        var margin = this.get('menuMargin');\n        var menuOuterHeight = this.get('_menuItems').get('length') * this.get('itemHeight') + totalPadding + 2 * borderWidth;\n        var wh = $(window).height();\n        var anchorTop = anchorElement.offset().top;\n        var anchorHeight = anchorElement.outerHeight();\n        var layout = this.get('layout');\n\n        var isSubMenu = !Ember.isNone(this.get('parentMenu'));\n        var spaceDownwards = wh - anchorTop + (isSubMenu ? (borderWidth + paddingTop) : (-anchorHeight));\n        var needScrolling = false;\n\n        if (menuOuterHeight + margin * 2 <= wh) {\n            if (isSubMenu && spaceDownwards >= menuOuterHeight + margin) {\n                layout.set('top', anchorTop - (borderWidth + paddingTop));\n            } else if (spaceDownwards < menuOuterHeight + margin) {\n                layout.set('top', wh - (menuOuterHeight + margin));\n            }\n        } else {\n            // Constrain menu height\n            menuOuterHeight = wh - 2 * margin;\n            layout.set('top', margin);\n            needScrolling = true;\n        }\n        layout.set('height', menuOuterHeight);\n        if (!layout.width) {\n            var menuWidth = Math.max(this.get('minWidth') || 0, this._calculateMenuWidth());\n            layout.set('width', menuWidth);\n        }\n        this.notifyPropertyChange('layout');\n        this.set('contentView.needScrolling', needScrolling);\n    },\n\n    close: function() {\n        if (this.isDestroyed) { return; }\n        this.set('_highlightIndex', -1);\n        this._clearKeySearch();\n        this._super();\n    },\n\n    /* event handling starts */\n    mouseDown: function() {\n        return true;\n    },\n\n    cancel: function() {\n        this.close();\n    },\n\n    moveUp: function() { return this._selectNext(-1); },\n    moveDown: function() { return this._selectNext(1); },\n\n    moveRight: function() {\n        this._tryOpenSubmenu(true);\n        return true;\n    },\n\n    moveLeft: function() {\n        var parentMenu = this.get('parentMenu');\n        if (!Ember.isNone(parentMenu)) { parentMenu.closeCurrentlyOpenSubMenu(); }\n        return true;\n    },\n\n    insertNewline: function() {\n        this.makeSelection();\n        return true;\n    },\n\n    keyPress: function(event) {\n        var key = String.fromCharCode(event.which);\n        if (event.which > 31 && key !== '') { // Skip control characters.\n            this._doKeySearch(key);\n            return true;\n        }\n        return false;\n    },\n\n    handleMouseEvents: function(event) {\n        // This should probably be combined with our event handling in event_manager.\n        var itemIndex = this._idToIndex(event.currentTarget.id);\n        // jQuery event handling: false bubbles the stuff up.\n        var retVal = false;\n\n        if (event.type === 'mouseenter') {\n            retVal = this.mouseEntered(itemIndex);\n        } else if (event.type === 'mouseup') {\n            retVal = this.mouseClicked(itemIndex);\n        } else if (event.type === 'mousedown') {\n            retVal = true;\n        }\n        return !retVal;\n    },\n\n    /* Event handling ends */\n\n    mouseClicked: function(index) {\n        // If we're just handling a mouseUp that is part of the click that opened this menu, do nothing.\n        // When the mouseUp follows within 100ms of opening the menu, we know that's the case.\n        if (Ember.isNone(this.get('parentMenu')) && new Date().getTime() - this._openedAt < 300) {\n            return;\n        }\n\n        this.set('_highlightIndex', index);\n        // This will currently select the item even if we're not on the the current menu. Will need to figure out how\n        // to deselect an item when cursor leaves the menu totally (that is, does not move to a sub-menu).\n        if (this.get('_userHighlightIndex') >= 0) {\n            this.makeSelection();\n        }\n        return true;\n    },\n\n    mouseEntered: function(index) {\n        this.set('_userHighlightIndex', index);\n        this._tryOpenSubmenu(false);\n        return true;\n    },\n\n    _selectNext: function(increment) {\n        var menuItems = this.get('_menuItems');\n        var len = menuItems.get('length');\n        var item;\n        var index = this.get('_highlightIndex') + increment;\n        for (; index >= 0 && index < len; index += increment) {\n            item = menuItems.objectAt(index);\n            if (item.isEnabled()) {\n                this.set('_highlightIndex', index);\n                break;\n            }\n        }\n        this._clearKeySearch();\n        return true;\n    },\n\n    _valueDidChange: function() {\n        var value = this.get('value');\n        var valueKey = this.get('itemValueKey');\n        if (!Ember.isNone(value) && !Ember.isNone(valueKey)) {\n            var index = this._findIndex(function(item) {\n                return Ember.get(item, valueKey) === value;\n            });\n            if (index >= 0) {\n                this.set('_highlightIndex', index);\n            }\n        }\n    }.observes('value'),\n\n    // Propagate internal selection to possible parent\n    _internalSelectionDidChange: function() {\n        var selected = this.get('_internalSelection');\n        Ember.trySet(this, 'parentMenu._internalSelection', selected);\n    }.observes('_internalSelection'),\n\n    _findIndex: function(identityFunc) {\n        var menuItems = this.get('items');\n        var i = 0, len = menuItems.get('length');\n        for (; i < len; i++) {\n            if (identityFunc(menuItems.objectAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    },\n\n    _findByName: function(name) {\n        var re = new RegExp('^' + name.replace(/[\\^$*+?.(){}\\[\\]|]/g, \"\\\\$&\"), 'i');\n        var titleKey = this.get('itemTitleKey');\n        return this._findIndex(function(menuItem) {\n            return re.test(Ember.get(menuItem, titleKey));\n        });\n    },\n\n    _toggleClass: function(className, index, addOrRemove) {\n        var menuItem = this.get('_menuItems').objectAt(index);\n        menuItem.$().toggleClass(className, addOrRemove);\n    },\n\n    _highlightWillChange: function() {\n        var index = this.get('_highlightIndex');\n        var lastItem = this.get('_menuItems').objectAt(index);\n        if (!Ember.isNone(lastItem)) {\n            this._toggleClass('is-selected', index);\n            lastItem.isSelected = false;\n            lastItem.closeSubMenu();\n        }\n    }.observesBefore('_highlightIndex'),\n\n    _highlightDidChange: function() {\n        var index = this.get('_highlightIndex');\n        var newItem = this.get('_menuItems').objectAt(index);\n        var internalSelection = { isSet: false, value: null };\n        if (!Ember.isNone(newItem)) {\n            this._toggleClass('is-selected', index);\n            newItem.isSelected = true;\n            if (newItem.isSelectable()) {\n                internalSelection = { isSet: true, value: newItem.item };\n            }\n        }\n        this.set('_internalSelection', internalSelection);\n    }.observes('_highlightIndex'),\n\n    /**\n      We only want to allow selecting menu items after the user has moved the mouse. We update\n      userHighlightIndex when user highlights something, and internally we use highlightIndex to keep\n      track of which item is highlighted, only allowing selection if user has highlighted something.\n      If we don't ensure the user has highlighted something before allowing selection, this means that when\n      a user clicks a SelectViewButton to open a menu, the mouseUp event (following the mouseDown on the select)\n      would be triggered on a menu item, and this would cause the menu to close immediately.\n    */\n    _userHighlightIndexDidChange: function() {\n        this.set('_highlightIndex', this.get('_userHighlightIndex'));\n    }.observes('_userHighlightIndex'),\n\n    _clearKeySearch: function() {\n        if (!Ember.isNone(this._timer)) {\n            Ember.run.cancel(this._timer);\n        }\n        this._searchKey = '';\n    },\n\n    _doKeySearch: function(key) {\n        this._searchKey = (this._searchKey || '') + key;\n        var index = this._findByName(this._searchKey);\n        if (index >= 0) {\n            this.set('_highlightIndex', index);\n        }\n\n        if (!Ember.isNone(this._timer)) {\n            Ember.run.cancel(this._timer);\n        }\n        this._timer = Ember.run.later(this, this._clearKeySearch, 1000);\n    },\n\n    _indexToId: function(index) {\n        return \"%@-%@\".fmt(this.get('elementId'), index);\n    },\n\n    _idToIndex: function(id) {\n        var re = new RegExp(\"%@-(\\\\d+)\".fmt(this.get('elementId')));\n        var res = re.exec(id);\n        return res && res.length === 2 ? parseInt(res[1], 10) : -1;\n    },\n\n    _tryOpenSubmenu: function(selectItem) {\n        var index = this.get('_highlightIndex');\n        var item = this.get('_menuItems').objectAt(index);\n        if (!item) {\n            return false;\n        }\n        var subMenuItems = item.subMenuItems;\n        if (!Ember.isNone(subMenuItems) && item.isEnabled() && subMenuItems.get('length') > 0) {\n            this._clearKeySearch();\n            var subMenu = item.subMenuView;\n            if (Ember.isNone(subMenu)) {\n                subMenu = this.createSubMenu(subMenuItems);\n                item.subMenuView = subMenu;\n            }\n            subMenu.popup(item.$(), this.get('subMenuPosition') || Flame.POSITION_RIGHT);\n            if (selectItem) subMenu._selectNext(1);\n            return true;\n        }\n        return false;\n    },\n\n    didInsertElement: function() {\n        this._super();\n        var self = this;\n        this.$().on('mouseenter mouseup mousedown', '.flame-menu-item-view', function(event) {\n            return self.handleMouseEvents(event);\n        });\n    },\n\n    willDestroyElement: function() {\n        this._super();\n        this.$().off('mouseenter mouseup mousedown');\n    }\n});\n", "var isWebKit = /webkit/i.test(window.navigator.userAgent);\n\nFlame.TableDataView = Flame.View.extend(Flame.Statechart, {\n    classNames: ['flame-table-data-view'],\n    acceptsKeyResponder: true,\n    batchUpdates: true,\n    updateBatchSize: 500,\n    _updateCounter: 0,\n    selectedCell: null,\n    selectionEnd: null,\n    editValue: null,\n    content: null,\n    tableViewDelegate: null,\n\n    initialFlameState: 'loaded',\n\n    loaded: Flame.State.extend({\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            if (owner.selectCell(owner._cellForTarget(event.target), false)) {\n                owner.get('selection').show();\n                this.gotoFlameState('mouseIsDown');\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            owner.set('selectedCell', null);\n            owner.set('selectionEnd', null);\n            if (owner.get('_state') === 'inDOM') {\n                owner.get('selection').children().addBack().hide();\n            }\n        }\n    }),\n\n    mouseIsDown: Flame.State.extend({\n        lastTarget: null,\n\n        mouseMove: function(event) {\n            if (event.target !== this.lastTarget) {\n                var owner = this.get('owner');\n                var cell = owner._cellForTarget(event.target);\n                if (cell && owner.isCellSelectable(cell)) {\n                    owner.set('selectionEnd', cell);\n                }\n                this.lastTarget = event.target;\n            }\n            return true;\n        },\n\n        mouseUp: function(event) {\n            this.gotoFlameState('selected');\n            return this.get('owner').invokeStateMethod('mouseUp', event);\n        }\n    }),\n\n    selected: Flame.State.extend({\n        cellUp: function(cell) {\n            return jQuery(cell.parent().prev().children()[cell.attr('data-index')]);\n        },\n\n        cellDown: function(cell) {\n            return jQuery(cell.parent().next().children()[cell.attr('data-index')]);\n        },\n\n        modifySelection: function(cell) {\n            var owner = this.get('owner');\n            if (owner.isCellSelectable(cell)) {\n                owner.set('selectionEnd', cell);\n                owner.notifySelectionChange();\n                return true;\n            }\n            return false;\n        },\n\n        _trim: function(value) {\n            // Trim value to allow correct pasting behavior to cells (normalize line changes, strip leading/trailing whitespace, but preserve tabs)\n            value = value.replace(/\\r\\n|\\r/g, '\\n');\n            value = value.replace(/^[^\\S\\t]+|[^\\S\\t]+$/g, '');\n            return value;\n        },\n\n        pasteValue: function(value) {\n            value = this._trim(value);\n            var owner = this.get('owner');\n            var data = owner.get('data');\n            var selectedCell = this.get('owner.selectedCell');\n            var rowIndex = owner.rowIndex(selectedCell);\n            var columnIndex = owner.columnIndex(selectedCell);\n\n            var pasteFailed = function(pastedValue) {\n                var tableViewDelegate = owner.get('tableViewDelegate');\n                if (tableViewDelegate && tableViewDelegate.pasteDidFail) tableViewDelegate.pasteDidFail(pastedValue);\n            };\n\n            // If only one value is in the clipboard and a range is selected,\n            // copy that value to all selected cells.\n            if (!/\\n|\\t/.test(value) && selectedCell !== this.get('owner.selectionEnd')) {\n                this._forEachSelectedCell(function(i, j, dataCell) {\n                    if (dataCell.isEditable() && dataCell.isPastable()) {\n                        var cell = owner.$('tr[data-index=%@]'.fmt(i)).find('td[data-index=%@]'.fmt(j)).first();\n                        if (!owner._validateAndSet(value, cell)) pasteFailed(value);\n                    }\n                });\n                return;\n            }\n\n            var rows = selectedCell.parent().add(selectedCell.parent().nextAll());\n            value.split('\\n').forEach(function(line, i) {\n                line.split('\\t').forEach(function(field, j) {\n                    var cell = rows[i] && rows.eq(i).children().eq(columnIndex + j);\n                    if (!cell) return;\n                    var dataCell = data[rowIndex + i][columnIndex + j];\n                    if (dataCell && dataCell.isEditable() && dataCell.isPastable()) {\n                        if (dataCell.options()) {\n                            var option = dataCell.options().findBy('title', field);\n                            if (!option) {\n                                pasteFailed(field);\n                                return;\n                            }\n                            field = option.value;\n                        }\n                        if (!owner._validateAndSet(field, cell)) pasteFailed(field);\n                    }\n                });\n            });\n        },\n\n        /**\n          For the current selection, get a value that can be pasted to another\n          TableView or spreadsheet.\n        */\n        valueForCopy: function() {\n            var value = [];\n            var row;\n            this._forEachSelectedCell(function(i, j, cell, newLine) {\n                if (newLine) {\n                    if (!Ember.isEmpty(row)) value.push(row.join('\\t'));\n                    row = [];\n                }\n                row.push(cell.isCopyable() ? cell.editableValue() : '');\n            });\n            if (!Ember.isEmpty(row)) value.push(row.join('\\t'));\n            return value.join('\\n');\n        },\n\n        _forEachSelectedCell: function(callback) {\n            var owner = this.get('owner');\n            var selectedCell = owner.get('selectedCell');\n            var selectionEnd = owner.get('selectionEnd');\n            var minRow = Math.min(owner.rowIndex(selectedCell), owner.rowIndex(selectionEnd));\n            var maxRow = Math.max(owner.rowIndex(selectedCell), owner.rowIndex(selectionEnd));\n            var minCol = Math.min(owner.columnIndex(selectedCell), owner.columnIndex(selectionEnd));\n            var maxCol = Math.max(owner.columnIndex(selectedCell), owner.columnIndex(selectionEnd));\n\n            var data = owner.get('data');\n            for (var i = minRow; i <= maxRow; i++) {\n                var newLine = true;\n                for (var j = minCol; j <= maxCol; j++) {\n                    callback(i, j, data[i][j], newLine);\n                    newLine = false;\n                }\n            }\n        },\n\n        _getCellUnderSelection: function(event) {\n            var owner = this.get('owner');\n            owner.get('selection').hide();\n            var cell = document.elementFromPoint(event.clientX, event.clientY);\n            owner.get('selection').show();\n            return cell;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            // For browsers that don't support pointer-events, clicking the selection div\n            // will absorb the mouseDown event.\n            if (jQuery(event.target).hasClass('table-selection')) {\n                event.target = this._getCellUnderSelection(event);\n            }\n\n            // If a cell is clicked that was already selected and it's a cell\n            // with fixed options, start editing it.\n            var $target = jQuery(event.target);\n            var selectedDataCell = owner.get('selectedDataCell');\n            if (!Ember.isNone(selectedDataCell) &&\n                    selectedDataCell.options && selectedDataCell.options() &&\n                    $target.is('td') &&\n                    owner._cellForTarget(event.target)[0] === owner.get('selectedCell')[0]) {\n                this.startEdit();\n                return true;\n            }\n\n            var target = owner._cellForTarget(event.target);\n            if (event.shiftKey && owner.isCellSelectable(target)) {\n                owner.set('selectionEnd', target);\n                return true;\n            } else if ($target.closest('.table-selection').length) {\n                // If an element inside of the selection div was clicked, we\n                // let the delegate handle the click in mouseUp.\n                return true;\n            } else {\n                this.gotoFlameState('loaded');\n                return owner.invokeStateMethod('mouseDown', event);\n            }\n        },\n\n        mouseUp: function(event) {\n            var tableViewDelegate = this.get('owner.tableViewDelegate');\n            if (tableViewDelegate && tableViewDelegate.mouseUp) {\n                var $target = jQuery(event.target);\n                // Fallback for browsers that don't support pointer-events\n                if ($target.hasClass('table-selection')) {\n                    event.target = this._getCellUnderSelection(event);\n                    $target = jQuery(event.target);\n                }\n\n                // Did we click on the cell or on an element inside the table selection?\n                var cell = $target.is('td') ? $target : jQuery(this._getCellUnderSelection(event));\n                var columnIndex = cell.attr('data-index');\n                var rowIndex = cell.parent().attr('data-index');\n\n                if (columnIndex && rowIndex) {\n                    var dataCell = this.get('owner.data')[rowIndex][columnIndex];\n                    var index = [rowIndex, columnIndex];\n                    tableViewDelegate.mouseUp(event, cell, dataCell, index, this.get('owner'));\n                }\n            }\n        },\n\n        keyDown: function(event, view) {\n            var owner = this.get('owner');\n            var selectedDataCell = owner.get('selectedDataCell');\n            if ((event.ctrlKey || event.metaKey) && !Ember.isNone(selectedDataCell)) {\n                var position = owner.get('selectedCell').position();\n                var scrollable = owner.get('parentView.scrollable');\n                var $container = owner.$('.clipboard-container');\n                $container.css({ left: position.left + scrollable.scrollLeft(), top: position.top + scrollable.scrollTop() });\n                $container.empty().show();\n                var $textarea = jQuery('<textarea></textarea>')\n                    .val(this.valueForCopy())\n                    .appendTo($container)\n                    .focus()\n                    .select();\n\n                var self = this;\n                $textarea.on('paste', function(e) {\n                    var clipboardData = e.originalEvent.clipboardData || window.clipboardData;\n                    var pastedValue = clipboardData.getData('Text');\n                    // IE11 doesn't allow AJAX requests from the paste event,\n                    // this is how we work around it.\n                    Ember.run.later(self, function() {\n                        this.pasteValue(pastedValue);\n                    }, 100);\n                });\n\n                // Make sure that control/command + <other key> combinations will still be handled by the browser\n                return false;\n            }\n\n            return !owner._handleKeyEvent('keyDown', event, view);\n        },\n\n        keyUp: function(event) {\n            var $target = jQuery(event.target);\n            if ($target.hasClass('clipboard-container textarea')) {\n                $target.off('paste');\n                var $container = this.$('.clipboard-container');\n                $container.empty().hide();\n                return true;\n            }\n            return false;\n        },\n\n        // We need to use the keyPress event, as some browsers don't report the character pressed correctly with keyDown\n        keyPress: function(event) {\n            if (event.ctrlKey || event.metaKey) return false;\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell) || !dataCell.isEditable()) {\n                return false;\n            }\n            var key = String.fromCharCode(event.which);\n            if (/[a-zA-Z0-9+*\\-\\[\\/\\=]/.test(key)) {\n                var owner = this.get('owner');\n                owner.set('editValue', key);\n                this.startEdit();\n                return true;\n            }\n            return false;\n        },\n\n        insertNewline: function(event) {\n            return this.startEdit();\n        },\n\n        deleteBackward: function(event) {\n            this.wipeCell();\n            return true;\n        },\n\n        deleteForward: function(event) {\n            this.wipeCell();\n            return true;\n        },\n\n        wipeCell: function() {\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell)) {\n                return;\n            }\n\n            if (dataCell.isEditable()) {\n                this.get('owner')._validateAndSet('');\n            }\n        },\n\n        doubleClick: function() {\n            this.startEdit();\n        },\n\n        startEdit: function(event) {\n            var dataCell = this.get('owner.selectedDataCell');\n            if (Ember.isNone(dataCell)) {\n                return;\n            }\n            var owner = this.get('owner');\n            if (dataCell.isEditable()) {\n                owner.set('selectionEnd', owner.get('selectedCell'));\n                this.gotoFlameState('editing');\n            } else if (!dataCell.options()) {\n                owner.set('selectionEnd', owner.get('selectedCell'));\n                this.gotoFlameState('selectingReadOnly');\n            }\n        },\n\n        cancel: function(event) {\n            this.get('owner').resignKeyResponder();\n            return true;\n        },\n\n        moveLeft: function(event) {\n            this.get('owner').selectCell(this.get('owner.selectedCell').prev());\n            return true;\n        },\n\n        moveLeftAndModifySelection: function(event) {\n            return this.modifySelection(this.get('owner.selectionEnd').prev());\n        },\n\n        moveRight: function(event) {\n            this.get('owner').selectCell(this.get('owner.selectedCell').next());\n            return true;\n        },\n\n        moveRightAndModifySelection: function(event) {\n            return this.modifySelection(this.get('owner.selectionEnd').next());\n        },\n\n        moveDown: function(event) {\n            this.get('owner').selectCell(this.cellDown(this.get('owner.selectedCell')));\n            return true;\n        },\n\n        moveDownAndModifySelection: function(event) {\n            return this.modifySelection(this.cellDown(this.get('owner.selectionEnd')));\n        },\n\n        moveUp: function(event) {\n            this.get('owner').selectCell(this.cellUp(this.get('owner.selectedCell')));\n            return true;\n        },\n\n        moveUpAndModifySelection: function(event) {\n            return this.modifySelection(this.cellUp(this.get('owner.selectionEnd')));\n        },\n\n        insertTab: function(event) {\n            this.get('owner').invokeStateMethod('moveRight');\n            return true;\n        },\n\n        insertBacktab: function(event) {\n            this.get('owner').invokeStateMethod('moveLeft');\n            return true;\n        },\n\n        enterState: function() {\n            this.get('owner').notifySelectionChange();\n        },\n\n        exitState: function() {\n            if (this.get('owner._state') !== 'inDOM') return;\n            var clipboardContainer = this.$('.clipboard-container');\n            if (clipboardContainer) clipboardContainer.empty().hide();\n        }\n    }),\n\n    // Used to allow users to select text from read-only cells\n    selectingReadOnly: Flame.State.extend({\n        cancel: function(event) {\n            this.get('owner')._cancelEditingOrSelecting();\n            return true;\n        },\n\n        insertNewline: function(event) {\n            var owner = this.get('owner');\n            this.gotoFlameState('selected');\n            owner.invokeStateMethod('moveDown');\n        },\n\n        moveLeft: function(event) {\n            this._invokeInSelected('moveLeft');\n        },\n\n        moveRight: function(event) {\n            this._invokeInSelected('moveRight');\n        },\n\n        moveDown: function(event) {\n            this._invokeInSelected('moveDown');\n        },\n\n        moveUp: function(event) {\n            this._invokeInSelected('moveUp');\n        },\n\n        insertTab: function(event) {\n            this._invokeInSelected('insertTab');\n        },\n\n        insertBacktab: function(event) {\n            this._invokeInSelected('insertBacktab');\n        },\n\n        deleteBackward: function(event) {\n            this.gotoFlameState('selected');\n            return true;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            var cell = owner._cellForTarget(event.target);\n            if (owner.isCellSelectable(cell)) {\n                this.gotoFlameState('selected');\n                owner.selectCell(cell);\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            var selection = owner.get('selection');\n            var dataCell = owner.get('selectedDataCell');\n            var readOnlyValue = Handlebars.Utils.escapeExpression(owner.editableValue(dataCell, true));\n            this.selectionContent = selection.html();\n            selection.html(readOnlyValue);\n            selection.addClass('read-only is-selectable');\n        },\n\n        exitState: function() {\n            var selection = this.get('owner.selection');\n            selection.html(this.selectionContent);\n            selection.removeClass('read-only is-selectable');\n        },\n\n        _invokeInSelected: function(action) {\n            var owner = this.get('owner');\n            this.gotoFlameState('selected');\n            owner.invokeStateMethod(action);\n        }\n    }),\n\n    editing: Flame.State.extend({\n        cancel: function(event) {\n            this.get('owner')._cancelEditingOrSelecting();\n            return true;\n        },\n\n        moveLeft: function() {\n            return Flame.ALLOW_BROWSER_DEFAULT_HANDLING;\n        },\n\n        moveRight: function() {\n            return Flame.ALLOW_BROWSER_DEFAULT_HANDLING;\n        },\n\n        insertNewline: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('moveDown');\n            }\n            return true;\n        },\n\n        insertTab: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('insertTab');\n            }\n            return true;\n        },\n\n        insertBacktab: function(event) {\n            var owner = this.get('owner');\n            if (owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.invokeStateMethod('insertBacktab');\n            }\n            return true;\n        },\n\n        mouseDown: function(event) {\n            var owner = this.get('owner');\n            var cell = owner._cellForTarget(event.target);\n            var editField = owner.get('editField');\n            if (owner.isCellSelectable(cell) && owner._confirmEdit()) {\n                this.gotoFlameState('selected');\n                owner.selectCell(cell);\n                return true;\n            } else if (!Ember.isEmpty(cell) && editField && cell[0] !== editField[0] && !owner._confirmEdit()) {\n                editField.focus();\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        enterState: function() {\n            var owner = this.get('owner');\n            var selectedCell = owner.get('selectedCell');\n            var dataCell = owner.get('selectedDataCell');\n            var editCell = owner.get('editField');\n            var selection = owner.get('selection');\n            var options = dataCell.options();\n\n            selectedCell.addClass('editing');\n\n            if (!dataCell.showEditor(selectedCell, owner, owner.get('content'))) {\n                // No special editor, use one of the defaults\n                if (options) { // Drop down menu for fields with a fixed set of options\n                    var menu = Flame.MenuView.createWithMixins({\n                        minWidth: selectedCell.outerWidth(),\n                        parent: owner, // Reference to the cube table view\n                        items: options.map(function(o) {\n                            return {\n                                title: o.title,\n                                value: o.value,\n                                isChecked: o.value === dataCell.value,\n                                action: function() { owner.didSelectMenuItem(this.get('value')); }\n                            };\n                        }),\n                        // Make the cube table view go back to the selected state when the menu is closed\n                        close: function() {\n                            owner.gotoFlameState('selected');\n                            this._super();\n                        }\n                    });\n                    menu.popup(selectedCell);\n                } else { // Normal edit field for everything else\n                    var backgroundColor = selectedCell.css('backgroundColor');\n\n                    // If background color is unset, it defaults to transparent. Different browser have different\n                    // ways of saying \"transparent\". Let's assume \"transparent\" actually means \"white\".\n                    if (['rgba(0, 0, 0, 0)', 'transparent'].contains(backgroundColor)) {\n                        backgroundColor = 'white';\n                    }\n\n                    editCell.css({\n                        left: parseInt(selection.css('left'), 10) + parseInt(selection.css('border-left-width'), 10) + 'px',\n                        top: parseInt(selection.css('top'), 10) + parseInt(selection.css('border-top-width'), 10) + 'px',\n                        width: selection.outerWidth() - parseInt(selection.css('border-left-width'), 10) - parseInt(selection.css('border-right-width'), 10) + 'px',\n                        height: selection.outerHeight() - parseInt(selection.css('border-top-width'), 10) - parseInt(selection.css('border-bottom-width'), 10) + 'px',\n                        backgroundColor: backgroundColor\n                    });\n                    var editValue = owner.editableValue(dataCell);\n                    editCell.val(editValue);\n                    editCell.attr('placeholder', dataCell.placeholder());\n                    owner.set('editValue', null);\n                    editCell.show();\n                    // Put cursor at end of value\n                    editCell.selectRange(editValue.length, editValue.length);\n                }\n            }\n        },\n\n        exitState: function() {\n            var owner = this.get('owner');\n            var editField = owner.get('editField');\n            editField.hide();\n            editField.removeClass('invalid');\n\n            owner.get('selectedCell').removeClass('editing');\n        }\n    }),\n\n    notifySelectionChange: function() {\n        var tableViewDelegate = this.get('tableViewDelegate');\n        if (tableViewDelegate && tableViewDelegate.didMakeSelection) {\n            tableViewDelegate.didMakeSelection(\n                this,\n                this.get('selectedCell'),\n                this.get('selectionEnd'),\n                this.get('selectedDataCell')\n            );\n        }\n    },\n\n    didSelectMenuItem: function(value) {\n        var editField = this.get('editField');\n        editField.val(value || '');\n        this._confirmEdit();\n        this.invokeStateMethod('moveDown');\n    },\n\n    willLoseKeyResponder: function() {\n        this.gotoFlameState('loaded');\n    },\n\n    columnIndex: function(cell) {\n        return parseInt(cell.attr('data-index'), 10);\n    },\n\n    rowIndex: function(cell) {\n        return parseInt(cell.parent().attr('data-index'), 10);\n    },\n\n    // Get the Cell instance that corresponds to the selected cell in the view\n    selectedDataCell: function() {\n        var selectedCell = this.get('selectedCell');\n        return this.get('data')[this.rowIndex(selectedCell)][this.columnIndex(selectedCell)];\n    }.property().volatile(),\n\n    editableValue: function(dataCell, readOnly) {\n        var editValue = this.get('editValue');\n        if (editValue !== null) {\n            return editValue;\n        } else {\n            editValue = readOnly ? dataCell.formattedValue() : dataCell.editableValue();\n            return !Ember.isNone(editValue) ? editValue : '';\n        }\n    },\n\n    didInsertElement: function() {\n        this.set('selection', this.$('.table-selection'));\n        this.set('editField', this.$('.table-edit-field'));\n    },\n\n    _selectionDidChange: function() {\n        Ember.run.once(this, this._updateSelection);\n    }.observes('selectedCell', 'selectionEnd'),\n\n    _updateSelection: function() {\n        var selectedCell = this.get('selectedCell');\n        if (!selectedCell) return;\n\n        var selection = this.get('selection');\n        var scrollable = this.get('parentView.scrollable');\n        var position = selectedCell.position();\n        var scrollTop = scrollable.scrollTop();\n        var scrollLeft = scrollable.scrollLeft();\n\n        selectedCell.addClass('active-cell');\n        selection.css(this._selectionCSS(selectedCell, this.get('selectionEnd'), scrollTop, scrollLeft, position));\n\n        if (this.get('parentView.currentFlameState.name') === 'resizing') {\n            return; // Scrolling the viewport used to mess up resizing columns when the selected cell was not in view\n        }\n\n        // Ensure the selection is within the visible area of the scrollview\n        if (position.top < 0) {\n            scrollable.scrollTop(scrollTop + position.top);\n        } else if (position.top + selectedCell.outerHeight() > scrollable.outerHeight()) {\n            var top = position.top + selectedCell.outerHeight() - scrollable.outerHeight();\n            scrollable.scrollTop(top + scrollTop + 17);\n        } else if (position.left < 0) {\n            scrollable.scrollLeft(scrollLeft + position.left);\n        } else if (position.left + selectedCell.outerWidth() > scrollable.outerWidth()) {\n            var left = position.left + selectedCell.outerWidth() - scrollable.outerWidth();\n            scrollable.scrollLeft(left + scrollLeft + 17);\n        }\n    },\n\n    _selectionCSS: function(startCell, endCell, scrollTop, scrollLeft, position) {\n        var offset = isWebKit ? 0 : 1;\n        endCell = endCell || startCell;\n        var startPosition = position;\n        var endPosition = startCell === endCell ? position : endCell.position();\n\n        var minLeft = Math.min(startPosition.left, endPosition.left);\n        var minTop = Math.min(startPosition.top, endPosition.top);\n        var maxLeft = Math.max(startPosition.left, endPosition.left);\n        var maxTop = Math.max(startPosition.top, endPosition.top);\n\n        var cellWidth = startPosition.left < endPosition.left ? endCell.outerWidth() : startCell.outerWidth();\n        var cellHeight = startPosition.top < endPosition.top ? endCell.outerHeight() : startCell.outerHeight();\n\n        return {\n            left: minLeft + scrollLeft - offset,\n            top: minTop + scrollTop - offset,\n            width: maxLeft + cellWidth - minLeft - 5,\n            height: maxTop + cellHeight - minTop - 3\n        };\n    },\n\n    _selectionWillChange: function() {\n        var selectedCell = this.get('selectedCell');\n        if (selectedCell) {\n            selectedCell.removeClass('active-cell');\n        }\n    }.observesBefore('selectedCell'),\n\n    _confirmEdit: function() {\n        var newValue = this.get('editField').val();\n        if (!this._validateAndSet(newValue)) {\n            this.get('editField').addClass('invalid');\n            return false;\n        }\n        return true;\n    },\n\n    // Returns true if cell valid, or false otherwise\n    _validateAndSet: function(newValue, cell) {\n        var data = this.get('data');\n        var selectedCell = cell || this.get('selectedCell');\n        var columnIndex = this.columnIndex(selectedCell);\n        var rowIndex = this.rowIndex(selectedCell);\n        var dataCell = data[rowIndex][columnIndex];\n\n        // Skip saving if value has not been changed\n        if (Ember.compare(dataCell.editableValue(), newValue) === 0) {\n            return true;\n        } else if (dataCell.validate(newValue)) {\n            var tableViewDelegate = this.get('tableViewDelegate');\n            Ember.assert('No tableViewDelegate set!', !!tableViewDelegate || !!tableViewDelegate.cellUpdated);\n\n            var index = [rowIndex, columnIndex];\n            if (tableViewDelegate.cellUpdated(dataCell, newValue, index)) {\n                var dirtyCells = this.get('dirtyCells').slice();\n                dirtyCells.push([rowIndex, columnIndex]);\n                this.set('dirtyCells', dirtyCells);\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    _cancelEditingOrSelecting: function() {\n        this.gotoFlameState('selected');\n    },\n\n    selectCell: function(newSelection, notify) {\n        if (this.get('parentView.allowSelection') && this.isCellSelectable(newSelection)) {\n            this.setProperties({\n                selectedCell: newSelection,\n                selectionEnd: newSelection\n            });\n            if (notify !== false) this.notifySelectionChange();\n            return true;\n        }\n        return false;\n    },\n\n    isCellSelectable: function(cell) {\n        return cell && cell[0] && cell[0].nodeName === 'TD';\n    },\n\n    _cellForTarget: function(target) {\n        return jQuery(target).closest('td', this.$());\n    },\n\n    updateColumnWidth: function(index, width) {\n        var cells = this.$('td[data-index=%@]'.fmt(index));\n        cells.first().css('width', width);\n        this.propertyDidChange('selectedCell'); // Let the size of the selection div be updated\n    },\n\n    render: function(buffer) {\n        this.gotoFlameState('loaded');\n        this._renderTable(buffer);\n    },\n\n    _renderTable: function(buffer) {\n        var data = this.get('data');\n        if (!(data && data[0])) return;\n\n        var rowCount = data.length;\n        var columnCount = data[0].length;\n        var defaultCellWidth = this.get('parentView.defaultColumnWidth');\n        var columnLeafs = this.get('parentView.content.columnLeafs');\n        var cellWidth;\n        var escape = Handlebars.Utils.escapeExpression;\n\n        var classes = 'flame-table';\n        if (!this.get('parentView.allowSelection')) classes += ' is-selectable';\n        var div = document.createElement('div');\n        buffer.begin('table').attr('class', classes).attr('width', '1px');\n        buffer.pushOpeningTag();\n        for (var i = 0; i < rowCount; i++) {\n            buffer.push('<tr data-index=\"' + i + '\">');\n            for (var j = 0; j < columnCount; j++) {\n                var content;\n                var cell = data[i][j];\n                var cssClassesString = '';\n                var titleValue = '';\n                var inlineStyles = '';\n                if (cell) {\n                    content = cell.content();\n                    content = (Ember.isNone(content) ? '' : content);\n                    if (content instanceof HTMLElement || content instanceof DocumentFragment) {\n                        while (div.firstChild) div.removeChild(div.firstChild);\n                        div.appendChild(content);\n                        content = div.innerHTML;\n                    } else {\n                        // Escape the cell content unless there is a deliberate implementation for cells with HTML content.\n                        content = escape(content);\n                    }\n                    cssClassesString = cell.cssClassesString();\n                    if (cell.inlineStyles) inlineStyles = cell.inlineStyles();\n                    titleValue = (cell.titleValue && cell.titleValue() ? 'title=\"%@\"'.fmt(escape(cell.titleValue())) : '');\n                } else {\n                    content = '<span style=\"color: #999\">...</span>';\n                }\n                cellWidth = columnLeafs[j].get('render_width') || defaultCellWidth;\n                buffer.push('<td data-index=\"%@\" class=\"%@\" style=\"width: %@px; %@\" %@>%@</td>'.fmt(\n                    j,\n                    (cssClassesString + (j % 2 === 0 ? ' even-col' : ' odd-col')),\n                    cellWidth,\n                    titleValue,\n                    inlineStyles,\n                    content\n                ));\n            }\n            buffer.push('</tr>');\n        }\n        buffer.pushClosingTag(); // table\n\n        // Selection indicator\n        buffer.push('<div class=\"table-selection\"></div>');\n\n        // Edit field (text)\n        buffer.push('<input type=\"text\" class=\"table-edit-field\">');\n\n        // Container that will hold the textarea used for copy/pasting cells\n        buffer.push('<div class=\"clipboard-container\"></div>');\n    },\n\n    // Update dirty cells\n    _cellsDidChange: function() {\n        this.manipulateCells(this.get('dirtyCells'), function(cell, element, isEvenColumn) {\n            var cssClassesString = (cell ? cell.cssClassesString() : '') + (isEvenColumn ? \" even-col\" : \" odd-col\");\n            var content = cell.content();\n            var titleValue = cell.titleValue && cell.titleValue();\n            var inlineStyles = cell.inlineStyles ? cell.inlineStyles() : '';\n            var cellWidth = element.style.width;\n            if (!Ember.isNone(cellWidth)) inlineStyles = 'width: %@; %@'.fmt(cellWidth, inlineStyles);\n            element.setAttribute('style', inlineStyles);\n            element.className = cssClassesString;\n\n            if (content instanceof HTMLElement || content instanceof DocumentFragment) {\n                while (element.firstChild) element.removeChild(element.firstChild);\n                element.appendChild(content);\n            } else {\n                element.textContent = Ember.isNone(content) ? '' : content;\n            }\n\n            if (titleValue) {\n                element.title = titleValue;\n            }\n        }, ++this._updateCounter);\n    }.observes('dirtyCells').on('init'),\n\n    // Mark and disable updating cells\n    _updatingCellsDidChange: function() {\n        this.manipulateCells(this.get('cellsMarkedForUpdate'), function(cell, element, isEvenColumn) {\n            if (cell.pending) {\n                // Cell isn't loaded yet, insert a placeholder value\n                cell.pending.isUpdating = true;\n                element.className += (isEvenColumn ? ' even-col' : ' odd-col');\n            } else {\n                cell.isUpdating = true;\n                var cssClassesString = cell.cssClassesString() + (isEvenColumn ? ' even-col' : ' odd-col');\n                element.className = cssClassesString;\n            }\n        });\n    }.observes('cellsMarkedForUpdate'),\n\n    manipulateCells: function(cellRefs, callback, updateCounter) {\n        var data = this.get('data');\n        if (!cellRefs || cellRefs.length === 0 || !this.$()) return;\n        var table = this.$('table.flame-table');\n\n        var allCells = table.find('td');\n        // Everyone expects that the cellRefs array is empty when we return from this function. We still need the\n        // content so save it elsewhere.\n        var content = cellRefs.splice(0, cellRefs.length);\n        var updateBatchSize = this.get('batchUpdates') ? this.get('updateBatchSize') : -1;\n        this._batchUpdate(updateBatchSize, 0, updateCounter, content, data, allCells, callback);\n    },\n\n    _batchUpdate: function(maxUpdates, startIx, updateCounter, cellRefs, data, allCells, callback) {\n        if (typeof updateCounter !== 'undefined' && updateCounter !== this._updateCounter) return;\n        // If we for some reason update / change the table before all these calls have gone through, we may update\n        // nodes that no longer exist in DOM but that shouldn't cause problems.\n        var len = cellRefs.length;\n        var element, index, cell;\n        var columnLength = data[0].length;\n        // If maxUpdates is -1, we fetch everything in one batch\n        var upTo = maxUpdates === -1 ? len : maxUpdates;\n\n        for (var i = startIx; i < len && (i - startIx) < upTo; i++) {\n            index = cellRefs[i];\n            var x = index[0], y = index[1];\n            if (!data[x][y]) {\n                // Possibly updating a cell that's still being batch loaded, insert a placeholder for update attributes\n                data[x][y] = {pending: {}};\n            }\n            cell = data[x][y];\n            element = allCells[x * columnLength + y];\n            if (element) {\n                callback(cell, element, y % 2 === 0);\n            }\n        }\n        if (i < len) {\n            // We've still got some updating to do so let's do it in the next run loop. Thus we should not get any slow\n            // script errors but that doesn't mean that the interface is responsive at any degree.\n            var self = this;\n            Ember.run.next(function() {\n                self._batchUpdate(maxUpdates, i, updateCounter, cellRefs, data, allCells, callback);\n            });\n        }\n    }\n});\n", "//= require ./table_data_view\n\nvar alias = Ember.computed.alias;\n\nvar unbindScroll = function() {\n    var scrollable = this.get('scrollable');\n    if (scrollable) {\n        scrollable.off('scroll');\n    }\n};\n\nFlame.TableView = Flame.View.extend(Flame.Statechart, {\n    MIN_COLUMN_WIDTH: 30,\n\n    classNames: ['flame-table-view'],\n    childViews: ['tableDataView'],\n    displayProperties: ['contentAdapter.headers'],\n    acceptsKeyResponder: false,\n\n    // References to DOM elements\n    scrollable: null, // the scrollable div that holds the data table\n    rowHeader: null, // the row header table element\n    columnHeader: null, // the column header table element\n    tableCorner: null,\n\n    renderColumnHeader: true,\n    renderRowHeader: true,\n    isRowHeaderClickable: true,\n    isResizable: true,\n    allowSelection: false,\n\n    initialFlameState: 'idle',\n\n    defaultColumnWidth: 88,\n    rowHeaderWidth: null,\n    content: null, // Set to a Flame.TableController\n    allowRefresh: true,\n    batchUpdates: true,\n    useAutoWidth: false,\n    tableViewDelegate: null,\n\n    contentAdapter: function() {\n        return Flame.TableViewContentAdapter.create({\n            content: this.get('content')\n        });\n    }.property('content'),\n\n    tableDataView: Flame.TableDataView.extend({\n        dataBinding: 'parentView.content._data',\n        content: alias('parentView.content'),\n        dirtyCells: alias('parentView.content.dirtyCells'),\n        areValuesOnRows: alias('parentView.content.areValuesOnRows'),\n        totalRowIds: alias('parentView.content.totalRowIds'),\n        totalColumnIds: alias('parentView.content.totalColumnIds'),\n        tableViewDelegate: alias('parentView.tableViewDelegate'),\n        cellsMarkedForUpdate: alias('parentView.content.cellsMarkedForUpdate'),\n        batchUpdates: alias('parentView.batchUpdates')\n    }),\n\n    rowDepth: function() {\n        return this.get('contentAdapter.rowHeaderRows.maxDepth');\n    }.property('contentAdapter.rowHeaderRows'),\n\n    /* IE 5-8 trigger mouse events in unorthodox order:\n\n     IE 5-8:        Any sane browser:\n     mousedown      mousedown\n     mouseup        mouseup\n     click          click\n     mouseup        mousedown\n     dblclick       mouseup\n                    click\n                    dblclick\n\n     Normally, the dblclick event works as expected, because the mouseup event is not being triggered for idle state\n     if mouseDown precedes it (because mouseup event is handled in resizing state). However, because IE8 triggers\n     two mouseups but only one mousedown for a dblclick event, the mouseUp function is called for idle state - which\n     in turn opens the sort order panel.\n\n     By adding another state we can mitigate the issue. The mousedown event puts the view into clickInProgress\n     state, and in clickInProgress mouseup returns it back to idle state. So, the state transition works as before.\n     However, if user clicks the resize-handle the view goes to resizing state. The first mouseup event moves the view\n     back to idle state, where the second redundant mouseup gets eaten silently.\n    */\n    idle: Flame.State.extend({\n        mouseDown: function(event) {\n            this.gotoFlameState('clickInProgress');\n\n            var target = jQuery(event.target);\n            if (target.is('div.resize-handle')) {\n                var owner = this.get('owner');\n                // If a table cell is being edited at this point, its 'editField' would get displaced by the resizing operation, so we just turn the editing off\n                var tableDataView = owner.get('tableDataView');\n                if (tableDataView.get('currentFlameState.name') === 'editing') {\n                    tableDataView.cancel();\n                }\n                var cell = target.closest('td');\n                owner.setProperties({\n                    resizingCell: cell,\n                    dragStartX: event.pageX,\n                    startX: cell.get(0).clientWidth + 1,\n                    offset: parseInt(this.get('owner.tableCorner').css('width'), 10),\n                    type: cell.is('.column-header td') ? 'column' : 'row'\n                });\n                this.gotoFlameState('resizing');\n                return true;\n            } else if (!!target.closest('.column-header').length) {\n                return true;\n            } else if (target.is('a')) {\n                return true;\n            }\n\n            return false;\n        },\n\n        doubleClick: function(event) {\n            var owner = this.get('owner');\n            if (!owner.get('useAutoWidth')) return false;\n\n            var target = jQuery(event.target), index, header;\n            if (!!target.closest('.column-header').length && (index = target.closest('td').attr('data-leaf-index'))) {\n                header = this.get('owner.content.columnLeafs')[index];\n\n                var columnDataAsString = owner.getColumnContents(header).map(function(e) { return e; }).join('<br>');\n                var columnDimensions = Flame.measureString(columnDataAsString, 'ember-view');\n\n                var isBold = target.closest('td').css('font-weight') === 'bold';\n                var headerLabelDimensions = Flame.measureString(owner.getLeafHeaderLabel(header), 'ember-view', 'label', isBold ? 'font-weight:bold;' : '');\n\n                var width = Math.max(columnDimensions.width, headerLabelDimensions.width) + 40;\n\n                if (width < owner.MIN_COLUMN_WIDTH) width = owner.MIN_COLUMN_WIDTH;\n                owner.setColumnWidth(header.leafIndex, width);\n                var resizeDelegate = owner.get('tableViewDelegate');\n                if (resizeDelegate && resizeDelegate.columnResized) {\n                    resizeDelegate.columnResized(index, width);\n                }\n                return true;\n            }\n            return false;\n        }\n    }),\n\n    clickInProgress: Flame.State.extend({\n        mouseUp: function(event) {\n            this.gotoFlameState('idle');\n            var clickDelegate = this.get('owner.tableViewDelegate');\n            if (clickDelegate) {\n                var target = jQuery(event.target);\n                var header;\n                if (!!target.closest('.column-header').length) {\n                    if (clickDelegate.columnHeaderClicked) {\n                        // Find the corresponding TableHeader instance for the clicked cell.\n                        var level = parseInt(target.closest('tr').attr('class').match(/level\\-(\\d+)/)[1], 10);\n                        var row = this.get('owner.contentAdapter.columnHeaderRows')[level - 1];\n                        header = row[target.closest('tr').find('td').index(target.closest('td'))];\n                        clickDelegate.columnHeaderClicked(header, target);\n                    }\n                    return true;\n                } else if (!!target.closest('.row-header').length) {\n                    if (clickDelegate.rowHeaderClicked) {\n                        var cell = target.closest('td');\n                        var index = parseInt(cell.attr('data-index'), 10);\n                        header = this.get('owner.content._headers.rowHeaders')[index];\n                        if (!header) return false;\n                        clickDelegate.rowHeaderClicked(header, target, index);\n                    }\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }),\n\n    resizing: Flame.State.extend({\n        enterState: function() {\n            var cell = this.get('owner.resizingCell');\n            var $table = cell.closest('table');\n            var columns = $table.find('col');\n\n            if (this.get('owner.type') === 'column') {\n                var column = parseInt(cell.attr('data-leaf-index'), 10);\n                this.set('resizingColumn', columns.eq(column));\n            } else {\n                var totalDepth = columns.length;\n                var cells = [];\n                $table.find('td').each(function() {\n                    var $cell = $(this);\n                    if (!$cell.attr('colspan')) cells.push($cell);\n                    if (cells.length === totalDepth) return false;\n                });\n                this.set('cells', cells);\n\n                // Get column index for resized cell\n                // must account for row headers spanning multiple columns to get the right leafIndex and width\n                var remainingDepth = 0;\n                cell.nextAll().each(function() {\n                    remainingDepth += $(this).attr('colspan') || 1;\n                });\n                var leafIndex = totalDepth - remainingDepth - 1;\n\n                this.set('resizingColumn', columns.eq(leafIndex));\n                this.set('owner.resizingCell', cells[leafIndex]);\n                this.set('owner.startX', cells[leafIndex].get(0).clientWidth + 1);\n            }\n        },\n\n        mouseMove: function(event) {\n            var owner = this.get('owner');\n            var deltaX = event.pageX - owner.get('dragStartX');\n            var minWidth = owner.get('MIN_COLUMN_WIDTH');\n            var cellWidth = owner.get('startX') + deltaX;\n            if (cellWidth < minWidth) cellWidth = minWidth;\n            // Adjust size of the cell\n            if (owner.get('type') === 'column') { // Update data table column width\n                this.get('resizingColumn').css('width', cellWidth);\n                owner._synchronizeColumnWidth(cellWidth);\n            } else {\n                var width = owner.get('offset') + cellWidth - owner.get('startX');\n\n                // Move data table and column header\n                owner.get('scrollable').css('left', width);\n                owner.get('columnHeader').parent().css('left', width);\n                owner.get('tableCorner').css('width', width);\n\n                this.get('resizingColumn').css('width', cellWidth);\n            }\n        },\n\n        mouseUp: function(event) {\n            var owner = this.get('owner');\n            var resizeDelegate = owner.get('tableViewDelegate');\n            if (resizeDelegate) {\n                var cell = owner.get('resizingCell');\n                if (owner.get('type') === 'column' && resizeDelegate.columnResized) {\n                    var width = parseInt(cell.css('width'), 10);\n                    var index = parseInt(cell.attr('data-leaf-index'), 10);\n                    resizeDelegate.columnResized(index, width);\n                } else if (resizeDelegate.rowHeaderResized) {\n                    // Can't use col-element to get the width from as it does not work correctly in IE\n                    var widths = this.get('cells').map(function(cell) { return cell.outerWidth(); });\n                    resizeDelegate.rowHeaderResized(widths);\n                }\n            }\n            this.gotoFlameState('idle');\n            return true;\n        }\n    }),\n\n    setColumnWidth: function(columnIndex, cellWidth) {\n        this.$('.column-header col').eq(columnIndex).css('width', cellWidth + 3);\n        var table = this.objectAt(0);\n        table.updateColumnWidth(columnIndex, cellWidth + 3);\n    },\n\n    getColumnContents: function(columnHeader) {\n        return this.get('content.tableData').map(function(e) {\n            var elem = e[columnHeader.leafIndex];\n            return Ember.isNone(elem) ? '' : elem.formattedValue();\n        });\n    },\n\n    getLeafHeaderLabel: function(header) {\n        var leaf = this.get('content.columnLeafs')[header.leafIndex];\n        return leaf.get('headerLabel');\n    },\n\n    _synchronizeColumnWidth: function(width) {\n        // Update data table columns\n        var cell = this.get('resizingCell');\n        var table = this.objectAt(0);\n        var index = parseInt(cell.attr('data-leaf-index'), 10);\n        table.updateColumnWidth(index, width);\n    },\n\n    willInsertElement: unbindScroll,\n    willDestroyElement: unbindScroll,\n\n    didInsertElement: function() {\n        this.set('scrollable', this.$('.scrollable'));\n        this.set('rowHeader', this.$('.row-header table'));\n        this.set('columnHeader', this.$('.column-header table'));\n        this.set('tableCorner', this.$('.table-corner'));\n        this.get('scrollable').on('scroll', jQuery.proxy(this.didScroll, this));\n    },\n\n    isScrolling: false,\n    didScroll: function(event) {\n        var scrollable = this.get('scrollable');\n        this.lastScrollTop = scrollable.scrollTop();\n        this.lastScrollLeft = scrollable.scrollLeft();\n        if (!this.isScrolling) {\n            requestAnimationFrame(jQuery.proxy(this._updateHeaderPositions, this));\n        }\n        this.isScrolling = true;\n    },\n\n    _updateHeaderPositions: function() {\n        if (this.lastScrollTop !== this.lastSetScrollTop) {\n            this.get('rowHeader').css('top', -this.lastScrollTop);\n            this.lastSetScrollTop = this.lastScrollTop;\n        }\n        if (this.lastScrollLeft !== this.lastSetScrollLeft) {\n            this.get('columnHeader').css('left', -this.lastScrollLeft);\n            this.lastSetScrollLeft = this.lastScrollLeft;\n        }\n        this.isScrolling = false;\n    },\n\n    render: function(buffer) {\n        var renderColumnHeader = this.get('renderColumnHeader');\n        var renderRowHeader = this.get('renderRowHeader');\n        var didRenderTitle = false;\n\n        var headers = this.get('contentAdapter.headers');\n        if (!headers) {\n            return; // Nothing to render\n        }\n\n        if (this.get('content.title')) {\n            buffer.push('<div class=\"panel-title\">%@</div>'.fmt(Handlebars.Utils.escapeExpression(this.get('content.title'))));\n            didRenderTitle = true;\n        }\n\n        var defaultColumnWidth = this.get('defaultColumnWidth');\n        var defaultRowHeaderWidth = this.get('rowHeaderWidth') || defaultColumnWidth;\n        var rowHeaderWidths = this.get('content').rowHeaderWidths ? this.get('content').rowHeaderWidths() : null;\n\n        var columnHeaderRows = this.get('contentAdapter.columnHeaderRows');\n        var rowHeaderRows = this.get('contentAdapter.rowHeaderRows');\n        var columnHeaderHeight = columnHeaderRows.maxDepth * 21 + 1 + columnHeaderRows.maxDepth;\n        var leftOffset = 0;\n        if (renderRowHeader) {\n            if (rowHeaderWidths) {\n                var totalWidth = 0;\n                for (var i = 0; i < Math.max(rowHeaderRows.maxDepth, 1); i++) {\n                    totalWidth += isNaN(rowHeaderWidths[i]) ? defaultRowHeaderWidth : rowHeaderWidths[i];\n                }\n                leftOffset = totalWidth + 1 + (renderColumnHeader ? 0 : 5);\n            } else {\n                leftOffset = rowHeaderRows.maxDepth * defaultRowHeaderWidth + 1 + (renderColumnHeader ? 0 : 5);\n            }\n        }\n        var topOffset = didRenderTitle ? 18 : 0;\n\n        if (renderColumnHeader) {\n            // Top left corner of the headers\n            buffer.push('<div class=\"table-corner\" style=\"top: %@px; left: 0; height: %@px; width: %@px;\"></div>'.fmt(topOffset, columnHeaderHeight, leftOffset));\n            // Column headers\n            this._renderHeader(buffer, 'column', leftOffset, defaultColumnWidth);\n            topOffset += columnHeaderHeight;\n        }\n        if (renderRowHeader) {\n            // Row headers\n            this._renderHeader(buffer, 'row', topOffset, defaultRowHeaderWidth);\n        }\n\n        // Scrollable div\n        buffer.push('<div class=\"scrollable\" style=\"overflow: auto; bottom: 0; top: %@px; left: %@px; right: 0;\">'.fmt(topOffset, leftOffset));\n        // There should really only be one child view, the TableDataView\n        this.forEach(function(view) {\n            view.renderToBuffer(buffer);\n        });\n        buffer.push('</div>');\n    },\n\n    _renderHeader: function(buffer, type, offset, defaultColumnWidth) {\n        var headers = this.get('contentAdapter.headers');\n        if (!headers) {\n            buffer.push('<div></div>');\n            return;\n        }\n\n        var position, i;\n        if (type === 'column') {\n            headers = this.get('contentAdapter.columnHeaderRows');\n            position = 'left';\n        } else {\n            headers = this.get('contentAdapter.rowHeaderRows');\n            position = 'top';\n        }\n        var length = headers.length;\n\n        buffer.begin('div').addClass('%@-header'.fmt(type)).attr('style', 'position: absolute; %@: %@px'.fmt(position, offset));\n        buffer.pushOpeningTag();\n        buffer.begin('table').attr('style', 'position: absolute').attr('width', '1px');\n        buffer.pushOpeningTag();\n\n        buffer.push('<colgroup>');\n        if (type === 'row') {\n            var widths = this.get('content').rowHeaderWidths ? this.get('content').rowHeaderWidths() : null;\n            for (i = 0; i < (headers.maxDepth || 1); i++) {\n                var width = (widths && widths[i]) ? widths[i] : defaultColumnWidth;\n                buffer.push('<col style=\"width: %@px;\" class=\"level-%@\">'.fmt(width, i + 1));\n            }\n        } else {\n            var l = this.get('content.columnLeafs').length;\n            for (i = 0; i < l; i++) {\n                buffer.push('<col style=\"width: %@px;\">'.fmt(this.get('content.columnLeafs')[i].get('render_width') || defaultColumnWidth));\n            }\n        }\n        buffer.push('</colgroup>');\n\n        for (i = 0; i < length; i++) {\n            if (type === 'column') {\n                buffer.push('<tr class=\"level-%@\">'.fmt(i + 1));\n            } else {\n                buffer.push('<tr>');\n            }\n            this._renderRow(buffer, headers[i], type, i);\n            buffer.push('</tr>');\n        }\n\n        buffer.pushClosingTag(); // table\n        buffer.pushClosingTag(); // div\n    },\n\n    _renderRow: function(buffer, row, type, rowIndex) {\n        var length = row.length;\n        var label, sortDirection, headerLabel;\n\n        function countLeaves(headerNode) {\n            if (headerNode.hasOwnProperty('children')) {\n                var count = 0;\n                for (var idx = 0; idx < headerNode.children.length; idx++) {\n                    count += countLeaves(headerNode.children[idx]);\n                }\n                return count;\n            } else {\n                return 1;\n            }\n        }\n\n        for (var i = 0; i < length; i++) {\n            var header = row[i];\n            buffer.begin('td');\n\n            headerLabel = header.get ? header.get('headerLabel') : header.label;\n            if (!headerLabel) headerLabel = \"\";\n            // We have to support <br> for row headers, so we'll replace them back after escaping\n            headerLabel = Ember.Handlebars.Utils.escapeExpression(headerLabel).replace(/&lt;br&gt;/g, '<br>');\n            buffer.attr('title', headerLabel.replace(/<br>/g, '\\n'));\n\n            if (header.rowspan > 1) {\n                buffer.attr('rowspan', header.rowspan);\n            }\n            if (header.colspan > 1) {\n                buffer.attr('colspan', header.colspan);\n            }\n\n            label = '<div class=\"label\">%@</div>';\n            var resizeHandle = \"\";\n            buffer.attr('class', (i % 2 === 0 ? \"even-col\" : \"odd-col\"));\n            if (type === 'column' && !header.hasOwnProperty('children')) { // Leaf node\n                buffer.attr('data-index', i);\n                // Mark the leafIndex, so when sorting it's trivial to find the correct field to sort by\n                buffer.attr('data-leaf-index', header.leafIndex);\n                if (this.get('isResizable') && this.get('renderColumnHeader')) {\n                    resizeHandle = '<div class=\"resize-handle\">&nbsp;</div>';\n                }\n\n                var headerSortDelegate = this.get('tableViewDelegate');\n                if (headerSortDelegate && headerSortDelegate.getSortForHeader) {\n                    var activeSort = headerSortDelegate.getSortForHeader(header);\n                    sortDirection = activeSort ? activeSort.direction : null;\n                }\n                var sortClass = sortDirection ? 'sort-%@'.fmt(sortDirection) : '';\n                label = '<div class=\"label ' + sortClass + '\">%@</div>';\n            } else if (type === 'row') {\n                buffer.attr('data-index', header.dataIndex);\n                if (this.get('renderColumnHeader')) {\n                    if (this.get(\"isResizable\")) {\n                        if (header.hasOwnProperty('children')) {\n                            // Ensure that resize-handle covers the whole height of the cell border. Mere child count\n                            // does not suffice with multi-level row headers.\n                            var leafCount = countLeaves(header);\n                            resizeHandle = '<div class=\"resize-handle\" style=\"height: %@px\"></div>'.fmt(leafCount * 21);\n                        } else {\n                            resizeHandle = '<div class=\"resize-handle\"></div>';\n                        }\n                    }\n                    if (this.get('isRowHeaderClickable') && header.get('isClickable')) {\n                        label = '%@';\n                    }\n                }\n            }\n\n            buffer.pushOpeningTag(); // td\n            buffer.push('<div class=\"content-container\">');\n            buffer.push(resizeHandle);\n            buffer.push(label.fmt(headerLabel));\n            buffer.push('</div>');\n            buffer.pushClosingTag(); // td\n        }\n    }\n});\n"], "filenames": ["utils/string_measurement.js", "views/checkbox_view.js", "views/menu_view.js", "views/table_data_view.js", "views/table_view.js"], "buggy_code_start_loc": [22, 12, 106, 459, 322], "buggy_code_end_loc": [25, 13, 110, 825, 442], "fixing_code_start_loc": [22, 12, 106, 459, 322], "fixing_code_end_loc": [35, 13, 107, 829, 443], "type": "CWE-79", "message": "A vulnerability classified as problematic has been found in flame.js. This affects an unknown part. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The name of the patch is e6c49b5f6179e31a534b7c3264e1d36aa99728ac. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-222291.", "other": {"cve": {"id": "CVE-2015-10089", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-05T14:15:08.953", "lastModified": "2023-03-13T16:54:53.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in flame.js. This affects an unknown part. The manipulation leads to cross site scripting. It is possible to initiate the attack remotely. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The name of the patch is e6c49b5f6179e31a534b7c3264e1d36aa99728ac. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-222291."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flame.js_project:flame.js:-:*:*:*:*:*:*:*", "matchCriteriaId": "02350CE0-814E-4A3F-AC65-CB4EFCECF7F7"}]}]}], "references": [{"url": "https://github.com/flamejs/flame.js/commit/e6c49b5f6179e31a534b7c3264e1d36aa99728ac", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flamejs/flame.js/pull/209", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.222291", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.222291", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/flamejs/flame.js/commit/e6c49b5f6179e31a534b7c3264e1d36aa99728ac"}}