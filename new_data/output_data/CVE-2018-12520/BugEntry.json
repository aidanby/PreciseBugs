{"buggy_code": ["/*\n *\n * (C) 2013-18 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#define USE_LUA\n#include \"../third-party/mongoose/mongoose.c\"\n#undef USE_LUA\n\nextern \"C\" {\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n};\n\nstatic HTTPserver *httpserver;\n\n/* ****************************************** */\n\n/*\n * Send error message back to a client.\n */\nint send_error(struct mg_connection *conn, int status, const char *reason, const char *fmt, ...) {\n  va_list ap;\n\n  conn->status_code = status;\n\n  (void) mg_printf(conn,\n\t\t   \"HTTP/1.1 %d %s\\r\\n\"\n\t\t   \"Content-Type: text/html\\r\\n\"\n\t\t   \"Connection: close\\r\\n\"\n\t\t   \"\\r\\n\", status, reason);\n\n  /* Errors 1xx, 204 and 304 MUST NOT send a body */\n  if(status > 199 && status != 204 && status != 304) {\n    char buf[BUFSIZ];\n    int  len;\n\n    conn->num_bytes_sent = 0;\n    va_start(ap, fmt);\n    len = mg_vsnprintf(conn, buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    conn->num_bytes_sent += mg_write(conn, buf, len);\n    cry_connection(conn, buf);\n  }\n\n  return(1);\n}\n\n/* ****************************************** */\n\nconst char *get_secure_cookie_attributes(const struct mg_request_info *request_info) {\n  if(request_info->is_ssl)\n    return \" HttpOnly; SameSite=lax; Secure\";\n  else\n    return \" HttpOnly; SameSite=lax\";\n}\n\n/* ****************************************** */\n\n#ifndef HAVE_NEDGE\nstatic void redirect_to_ssl(struct mg_connection *conn,\n                            const struct mg_request_info *request_info) {\n  const char *host = mg_get_header(conn, \"Host\");\n  //  u_int16_t port = ntop->get_HTTPserver()->get_port();\n\n  if(host != NULL) {\n    const char *p = strchr(host, ':');\n\n    if(p)\n      mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: https://%.*s:%u/%s\\r\\n\\r\\n\",\n\t\t(int) (p - host), host, ntop->getPrefs()->get_https_port(), request_info->uri);\n    else\n      mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: https://%s:%u/%s\\r\\n\\r\\n\",\n\t\thost, ntop->getPrefs()->get_https_port(), request_info->uri);\n  } else {\n    mg_printf(conn, \"%s\", \"HTTP/1.1 500 Error\\r\\n\\r\\nHost: header is not set\");\n  }\n}\n#endif\n\n/* ****************************************** */\n\n// Generate session ID. buf must be 33 bytes in size.\n// Note that it is easy to steal session cookies by sniffing traffic.\n// This is why all communication must be SSL-ed.\nstatic void generate_session_id(char *buf, const char *random, const char *user) {\n  mg_md5(buf, random, user, NULL);\n}\n\n/* ****************************************** */\n\nstatic inline bool authorized_localhost_users_login_disabled(const struct mg_connection *conn) {\n  if(ntop->getPrefs()->is_localhost_users_login_disabled()\n     && (conn->request_info.remote_ip == 0x7F000001 /* 127.0.0.1 */))\n    return true;\n  return false;\n}\n\n/* ****************************************** */\n\nstatic void set_cookie(const struct mg_connection *conn,\n                       char *user, char *referer) {\n  char key[256], session_id[64], random[64];\n\n  if(!strcmp(mg_get_request_info((struct mg_connection*)conn)->uri, \"/metrics\")\n     || !strncmp(mg_get_request_info((struct mg_connection*)conn)->uri, GRAFANA_URL, strlen(GRAFANA_URL))\n     || !strncmp(mg_get_request_info((struct mg_connection*)conn)->uri, POOL_MEMBERS_ASSOC_URL, strlen(POOL_MEMBERS_ASSOC_URL)))\n    return;\n\n  if(authorized_localhost_users_login_disabled(conn))\n    return;\n  \n  // Authentication success:\n  //   1. create new session\n  //   2. set session ID token in the cookie\n  //\n  // The most secure way is to stay HTTPS all the time. However, just to\n  // show the technique, we redirect to HTTP after the successful\n  // authentication. The danger of doing this is that session cookie can\n  // be stolen and an attacker may impersonate the user.\n  // Secure application must use HTTPS all the time.\n\n  snprintf(random, sizeof(random), \"%d\", rand());\n\n  generate_session_id(session_id, random, user);\n\n  // ntop->getTrace()->traceEvent(TRACE_ERROR, \"==> %s\\t%s\", random, session_id);\n\n  /* http://en.wikipedia.org/wiki/HTTP_cookie */\n  mg_printf((struct mg_connection *)conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t    \"Set-Cookie: session=%s; path=/; max-age=%u;%s\\r\\n\"  // Session ID\n\t    \"Set-Cookie: user=%s; path=/; max-age=%u;%s\\r\\n\"  // Set user, needed by JavaScript code\n\t    \"Location: %s%s\\r\\n\\r\\n\",\n\t    session_id, HTTP_SESSION_DURATION, get_secure_cookie_attributes(mg_get_request_info((struct mg_connection*)conn)),\n\t    user, HTTP_SESSION_DURATION, get_secure_cookie_attributes(mg_get_request_info((struct mg_connection*)conn)),\n\t    ntop->getPrefs()->get_http_prefix(), referer ? referer : \"/\");\n\n  /* Save session in redis */\n  snprintf(key, sizeof(key), \"sessions.%s\", session_id);\n  ntop->getRedis()->set(key, user, HTTP_SESSION_DURATION);\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Set session sessions.%s\", session_id);\n}\n\n/* ****************************************** */\n\nstatic void get_qsvar(const struct mg_request_info *request_info,\n                      const char *name, char *dst, size_t dst_len) {\n  const char *qs = request_info->query_string;\n  mg_get_var(qs, strlen(qs == NULL ? \"\" : qs), name, dst, dst_len);\n}\n\n/* ****************************************** */\n\nstatic int checkCaptive(const struct mg_connection *conn,\n\t\t\tconst struct mg_request_info *request_info,\n\t\t\tchar *username, char *password) {\n#ifdef NTOPNG_PRO\n  if(ntop->getPrefs()->isCaptivePortalEnabled()\n     && ntop->isCaptivePortalUser(username)) {\n    /*\n      This user logged onto ntopng via the captive portal\n    */\n    u_int16_t host_pool_id;\n    int32_t limited_lifetime = -1; /* Unlimited by default */\n    char label[128];\n\n    get_qsvar(request_info, \"label\", label, sizeof(label));\n\n#ifdef DEBUG\n    char buf[32];\n\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[CAPTIVE] %s @ %s/%08X [Redirecting to %s%s]\",\n\t\t\t\t username, Utils::intoaV4((unsigned int)conn->request_info.remote_ip, buf, sizeof(buf)),\n\t\t\t\t (unsigned int)conn->request_info.remote_ip,\n\t\t\t\t mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t\t request_info->uri);\n#endif\n\n    char bridge_interface[32];\n\n    if(!ntop->getUserAllowedIfname(username, bridge_interface, sizeof(bridge_interface)))\n      return(0);\n\n    ntop->getUserHostPool(username, &host_pool_id);\n    ntop->hasUserLimitedLifetime(username, &limited_lifetime);\n\n    if(!ntop->addIPToLRUMatches(htonl((unsigned int)conn->request_info.remote_ip),\n\t\t\t    host_pool_id, label, limited_lifetime, bridge_interface))\n      return(0);\n\n    /* Success */\n    return(1);\n  }\n#endif\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int checkInformativeCaptive(const struct mg_connection *conn,\n\t\t\t\t   const struct mg_request_info *request_info) {\n#ifdef NTOPNG_PRO\n#ifdef DEBUG\n  char buf[32];\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[CAPTIVE] @ %s/%08X [Redirecting to %s%s]\",\n\t\t\t       Utils::intoaV4((unsigned int)conn->request_info.remote_ip, buf, sizeof(buf)),\n\t\t\t       (unsigned int)conn->request_info.remote_ip,\n\t\t\t       mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t       request_info->uri);\n#endif\n\n  if(!ntop->addToNotifiedInformativeCaptivePortal(htonl((unsigned int)conn->request_info.remote_ip)))\n    return(0);\n\n  /* Success */\n  return(1);\n#endif\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int checkGrafana(const struct mg_connection *conn,\n\t\t\tconst struct mg_request_info *request_info) {\n\n  if(!strcmp(request_info->request_method, \"OPTIONS\") /* Allow for CORS inflight requests */\n    && !strncmp(request_info->uri, GRAFANA_URL, strlen(GRAFANA_URL)))\n    /* Success */\n    return(1);\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int isWhitelistedURI(char *uri) {\n  /* URL whitelist */\n  if((!strcmp(uri,    LOGIN_URL))\n     || (!strcmp(uri, AUTHORIZE_URL))\n     || (!strcmp(uri, BANNED_SITE_URL))\n     || (!strcmp(uri, PLEASE_WAIT_URL))\n     || (!strcmp(uri, HOTSPOT_DETECT_URL))\n     || (!strcmp(uri, HOTSPOT_DETECT_LUA_URL))\n     || (!strcmp(uri, ntop->getPrefs()->getCaptivePortalUrl()))\n     || (!strcmp(uri, KINDLE_WIFISTUB_URL))\n     )\n    return(1);\n  else\n    return(0);\n}\n\n/* ****************************************** */\n\n// Return 1 if request is authorized, 0 otherwise.\nstatic int is_authorized(const struct mg_connection *conn,\n                         const struct mg_request_info *request_info,\n\t\t\t char *username, u_int username_len) {\n  char session_id[33], buf[128];\n  char key[64], user[32];\n  char password[32];\n  const char *auth_header_p;\n  string auth_type = \"\", auth_string = \"\";\n  bool user_login_disabled = !ntop->getPrefs()->is_users_login_enabled() ||\n    authorized_localhost_users_login_disabled(conn);\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"[AUTHORIZATION] [%s][%s]\",\n\t\t\t       request_info->uri, request_info->query_string ? request_info->query_string : \"\");\n#endif\n\n  /*\n    iOS / MacOS\n    1. HOTSPOT_DETECT_URL        \"/hotspot-detect.html\"\n    2. HOTSPOT_DETECT_LUA_URL    \"/lua/hotspot-detect.lua\"\n    3. CAPTIVE_PORTAL_URL        \"/lua/captive_portal.lua\"\n    4. AUTHORIZE_CAPTIVE_LUA_URL \"/lua/authorize_captive.lua\"\n    5. logged in\n\n    Kindle\n    1. KINDLE_WIFISTUB_URL\n  */\n  if(!strcmp(request_info->uri, AUTHORIZE_CAPTIVE_LUA_URL)) {\n    /* A captive portal request has been issued to the authorization url */\n\n    if(ntop->getPrefs()->isInformativeCaptivePortalEnabled()) {\n      /* If the captive portal is just informative, there's no need to check\n\t any username or password. The request per se means the internet user\n\t has accepted the 'terms of service'. */\n      return(checkInformativeCaptive(conn, request_info));\n    } else {\n      /* Here the captive portal is not just informative; it requires authentication.\n         For this reason it is necessary to check submitted username and password. */\n      if(request_info->query_string) {\n\tget_qsvar(request_info, \"username\", username, username_len);\n\tget_qsvar(request_info, \"password\", password, sizeof(password));\n      }\n\n      return(ntop->checkUserPassword(username, password)\n\t     && checkCaptive(conn, request_info, username, password));\n    }\n  }\n\n  if(checkGrafana(conn, request_info) == 1) {\n    return(1);\n  }\n\n  if(user_login_disabled) {\n    mg_get_cookie(conn, \"user\", username, username_len);\n    if(strncmp(username, NTOP_NOLOGIN_USER, username_len)) {\n      set_cookie(conn, (char *)NTOP_NOLOGIN_USER, NULL);\n    }\n    return 1;\n  }\n\n  /* Try to decode Authorization header if present */\n  auth_header_p = mg_get_header(conn, \"Authorization\");\n  string auth_header = auth_header_p ? auth_header_p  : \"\";\n  istringstream iss(auth_header);\n  getline(iss, auth_type, ' ');\n  if(auth_type == \"Basic\") {\n    string decoded_auth, user_s = \"\", pword_s = \"\";\n    /* In case auth type is Basic, info are encoded in base64 */\n    getline(iss, auth_string, ' ');\n    decoded_auth = Utils::base64_decode(auth_string);\n    istringstream authss(decoded_auth);\n    getline(authss, user_s, ':');\n    getline(authss, pword_s, ':');\n\n    return ntop->checkUserPassword(user_s.c_str(), pword_s.c_str());\n  }\n\n  mg_get_cookie(conn, \"user\", username, username_len);\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n\n  if(!strcmp(username, NTOP_NOLOGIN_USER) && !user_login_disabled)\n    /* Trying to access web interface with nologin after ntopng restart\n       with different settings */\n    return 0;\n\n  if(session_id[0] == '\\0') {\n    /* Last resort: see if we have a user and password matching */\n    mg_get_cookie(conn, \"password\", password, sizeof(password));\n\n    return(ntop->checkUserPassword(username, password));\n  }\n\n  // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] Received session %s/%s\", session_id, username);\n\n  snprintf(key, sizeof(key), CONST_RUNTIME_IS_AUTOLOGOUT_ENABLED);\n  ntop->getRedis()->get(key, buf, sizeof(buf), true);\n  // do_auto_logout() is the getter for the command-line specified\n  // preference that defaults to true (i.e., auto_logout is enabled by default)\n  // If do_auto_logout() is disabled, then the runtime auto logout preference\n  // is taken into account.\n  // If do_auto_logout() is false, then the auto logout is disabled regardless\n  // of runtime preferences.\n  if(ntop->getPrefs()->do_auto_logout() && strncmp(buf, (char*)\"1\", 1) == 0) {\n    snprintf(key, sizeof(key), \"sessions.%s\", session_id);\n    if((ntop->getRedis()->get(key, user, sizeof(user), true) < 0)\n       || strcmp(user, username) /* Users don't match */) {\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Session %s/%s is expired or empty user\",\n\t\t\t\t   session_id, username);\n      return(0);\n    } else {\n      ntop->getRedis()->expire(key, HTTP_SESSION_DURATION); /* Extend session */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Session %s is OK: extended for %u sec\",\n\t\t\t\t   session_id, HTTP_SESSION_DURATION);\n      return(1);\n    }\n  } else\n    return(1);\n}\n\n/* ****************************************** */\n\nstatic int isCaptiveConnection(struct mg_connection *conn) {\n  char *host = (char*)mg_get_header(conn, \"Host\");\n\n  return(ntop->getPrefs()->isCaptivePortalEnabled()\n\t && (ntohs(conn->client.lsa.sin.sin_port) == 80\n\t     || ntohs(conn->client.lsa.sin.sin_port) == 443)\n\t && (ntop->getPrefs()->get_alt_http_port() != 0)\n\t && host\n\t && (strcasestr(host, CONST_HELLO_HOST) == NULL)\n\t );\n}\n\n/* ****************************************** */\n\nstatic int isCaptiveURL(char *url) {\n  if((!strcmp(url, KINDLE_WIFISTUB_URL))\n     || (!strcmp(url, HOTSPOT_DETECT_URL))\n     || (!strcmp(url, HOTSPOT_DETECT_LUA_URL))\n     || (!strcmp(url, ntop->getPrefs()->getCaptivePortalUrl()))\n     || (!strcmp(url, AUTHORIZE_CAPTIVE_LUA_URL))\n     || (!strcmp(url, \"/\"))\n     )\n    return(1);\n  else\n    return(0);\n}\n\n/* ****************************************** */\n\nstatic bool isStaticResourceUrl(const struct mg_request_info *request_info, u_int len) {\n  if((len >= 3 && (!strncmp(&request_info->uri[len - 3], \".js\", 3)))\n     || (len >= 4 && (!strncmp(&request_info->uri[len - 4], \".css\", 4)\n\t\t      || !strncmp(&request_info->uri[len - 4], \".map\", 4)\n\t\t      || !strncmp(&request_info->uri[len - 4], \".ttf\", 4)))\n     || (len >= 6 && (!strncmp(&request_info->uri[len - 6], \".woff2\", 6))))\n    return true;\n\n  return false;\n}\n\n/* ****************************************** */\n\n// Redirect user to the login form. In the cookie, store the original URL\n// we came from, so that after the authorization we could redirect back.\nstatic void redirect_to_login(struct mg_connection *conn,\n                              const struct mg_request_info *request_info,\n\t\t\t      const char *referer) {\n  char session_id[33], buf[128];\n\n  if(isCaptiveConnection(conn)) {\n    if(referer)\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\", /* FIX */\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(), ntop->getPrefs()->getCaptivePortalUrl(), referer);\n    else\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s\\r\\n\\r\\n\", /* FIX */\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(), ntop->getPrefs()->getCaptivePortalUrl());\n  } else {\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[LOGIN] [Host: %s][URI: %s]\",\n\t\t\t\t mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t\t request_info->uri);\n#endif\n\n    mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n    if(referer)\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\",\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(),\n\t\tUtils::getURL((char*)LOGIN_URL, buf, sizeof(buf)), referer);\n    else\n      mg_printf(conn,\n\t      \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t      \"Location: %s%s\\r\\n\\r\\n\",\n\t      session_id,\n\t      get_secure_cookie_attributes(request_info),\n\t      ntop->getPrefs()->get_http_prefix(),\n\t      Utils::getURL((char*)LOGIN_URL, buf, sizeof(buf)));\n  }\n}\n\n/* ****************************************** */\n\n#ifdef HAVE_MYSQL\n/* Redirect user to a courtesy page that is used when database schema is being updated.\n   In the cookie, store the original URL we came from, so that after the authorization\n   we could redirect back.\n*/\nstatic void redirect_to_please_wait(struct mg_connection *conn,\n\t\t\t\t    const struct mg_request_info *request_info) {\n  char session_id[33], buf[128];\n\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n  mg_printf(conn,\n\t    \"HTTP/1.1 302 Found\\r\\n\"\n\t    // \"HTTP/1.1 401 Unauthorized\\r\\n\"\n\t    // \"WWW-Authenticate: Basic\\r\\n\"\n\t    \"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t    \"Location: %s%s?referer=%s%s%s\\r\\n\\r\\n\",\n\t    session_id,\n\t    get_secure_cookie_attributes(request_info),\n\t    ntop->getPrefs()->get_http_prefix(),\n\t    Utils::getURL((char*)PLEASE_WAIT_URL, buf, sizeof(buf)),\n\t    conn->request_info.uri,\n\t    conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t    conn->request_info.query_string ? conn->request_info.query_string : \"\");\n}\n#endif\n\n/* ****************************************** */\n\nstatic void redirect_to_password_change(struct mg_connection *conn,\n\t\t\t\t    const struct mg_request_info *request_info) {\n  char session_id[33], buf[128];\n\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n    mg_printf(conn,\n\t      \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Set-Cookie: session=%s; path=/;%s\\r\\n\"  // Session ID\n\t      \"Location: %s%s?referer=%s%s%s%s\\r\\n\\r\\n\", /* FIX */\n\t      session_id,\n\t      get_secure_cookie_attributes(request_info),\n\t      ntop->getPrefs()->get_http_prefix(),\n\t      Utils::getURL((char*)CHANGE_PASSWORD_ULR, buf, sizeof(buf)),\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      conn->request_info.uri,\n\t      conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t      conn->request_info.query_string ? conn->request_info.query_string : \"\");\n}\n\n/* ****************************************** */\n\n// A handler for the /authorize endpoint.\n// Login page form sends user name and password to this endpoint.\nstatic void authorize(struct mg_connection *conn,\n                      const struct mg_request_info *request_info,\n\t\t      char *username) {\n  char user[32] = { '\\0' }, password[32] = { '\\0' }, referer[256] = { '\\0' };\n\n  if(!strcmp(request_info->request_method, \"POST\")) {\n    char post_data[1024];\n    int post_data_len = mg_read(conn, post_data, sizeof(post_data));\n\n    mg_get_var(post_data, post_data_len, \"user\", user, sizeof(user));\n    mg_get_var(post_data, post_data_len, \"password\", password, sizeof(password));\n    mg_get_var(post_data, post_data_len, \"referer\", referer, sizeof(referer));\n  } else {\n    // Fetch user name and password.\n    get_qsvar(request_info, \"user\", user, sizeof(user));\n    get_qsvar(request_info, \"password\", password, sizeof(password));\n    get_qsvar(request_info, \"ref\", referer, sizeof(referer));\n\n    if(referer[0] == '\\0') {\n      for(int i=0; request_info->http_headers[i].name != NULL; i++) {\n\tif(strcmp(request_info->http_headers[i].name, \"Referer\") == 0) {\n\t  snprintf(referer, sizeof(referer), \"%s\", request_info->http_headers[i].value);\n\t  break;\n\t}\n      }\n    }\n  }\n\n  if(isCaptiveConnection(conn) || ntop->isCaptivePortalUser(user) ||\n\t    (!ntop->checkUserPassword(user, password))) {\n    // Authentication failure, redirect to login\n    redirect_to_login(conn, request_info, (referer[0] == '\\0') ? NULL : referer);\n  } else {\n    /* Referer url must begin with '/' */\n    if((referer[0] != '/') || (strcmp(referer, AUTHORIZE_URL) == 0)) {\n      char *r = strchr(referer, '/');\n      strcpy(referer, r ? r : \"/\");\n    }\n\n    set_cookie(conn, user, referer);\n  }\n}\n\n/* ****************************************** */\n\nstatic void uri_encode(const char *src, char *dst, u_int dst_len) {\n  u_int i = 0, j = 0;\n\n  memset(dst, 0, dst_len);\n\n  while(src[i] != '\\0') {\n    if(src[i] == '<') {\n      dst[j++] = '&'; if(j == (dst_len-1)) break;\n      dst[j++] = 'l'; if(j == (dst_len-1)) break;\n      dst[j++] = 't'; if(j == (dst_len-1)) break;\n      dst[j++] = ';'; if(j == (dst_len-1)) break;\n    } else if(src[i] == '>') {\n      dst[j++] = '&'; if(j == (dst_len-1)) break;\n      dst[j++] = 'g'; if(j == (dst_len-1)) break;\n      dst[j++] = 't'; if(j == (dst_len-1)) break;\n      dst[j++] = ';'; if(j == (dst_len-1)) break;\n    } else {\n      dst[j++] = src[i]; if(j == (dst_len-1)) break;\n    }\n\n    i++;\n  }\n}\n\n/* ****************************************** */\n\nstatic int handle_lua_request(struct mg_connection *conn) {\n  struct mg_request_info *request_info = mg_get_request_info(conn);\n  char *crlf;\n  u_int len;\n  char username[33] = { 0 };\n  char *referer = (char*)mg_get_header(conn, \"Referer\");\n  u_int8_t whitelisted, authorized;\n\n  if(referer == NULL)\n    referer = (char*)\"\";\n\n  if((crlf = strstr(request_info->uri, \"\\r\\n\")))\n    *crlf = '\\0'; /* Prevents HTTP splitting attacks */\n\n  len = (u_int)strlen(request_info->uri);\n\n#ifdef HAVE_NEDGE\n  if(!ntop->getPro()->has_valid_license()) {\n    if (! ntop->getGlobals()->isShutdown()) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"License expired, shutting down...\");\n      ntop->getGlobals()->shutdown();\n      ntop->shutdown();\n    }\n  }\n#endif\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[Host: %s][URI: %s][%s][Referer: %s]\",\n\t\t\t       mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t       request_info->uri,\n\t\t\t       request_info->query_string ? request_info->query_string : \"\",\n\t\t\t       (char*)mg_get_header(conn, \"Referer\"));\n#endif\n\n  if((ntop->getGlobals()->isShutdown())\n     //|| (strcmp(request_info->request_method, \"GET\"))\n     || (ntop->getRedis() == NULL /* Starting up... */)\n     || (ntop->get_HTTPserver() == NULL))\n    return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t      \"Unexpected HTTP method or ntopng still starting up...\"));\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"################# [HTTP] %s [%s]\",\n\t\t\t       request_info->uri, referer);\n#endif\n\n#ifdef HAVE_MYSQL\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()\n     && !MySQLDB::isDbCreated()\n     && strcmp(request_info->uri, PLEASE_WAIT_URL)) {\n    redirect_to_please_wait(conn, request_info);\n  } else\n#endif\n#ifndef HAVE_NEDGE\n  if(ntop->get_HTTPserver()->is_ssl_enabled()\n     && (!request_info->is_ssl)\n     && isCaptiveURL(request_info->uri)\n     && (!strstr(referer, HOTSPOT_DETECT_LUA_URL))\n     && (!strstr(referer, ntop->getPrefs()->getCaptivePortalUrl()))\n     // && ((mg_get_header(conn, \"Host\") == NULL) || (mg_get_header(conn, \"Host\")[0] == '\\0'))\n     ) {\n    redirect_to_ssl(conn, request_info);\n    return(1);\n  } else\n#endif\n  if(!strcmp(request_info->uri, HOTSPOT_DETECT_URL)) {\n    mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Expires: 0\\r\\n\"\n\t      \"Cache-Control: no-store, no-cache, must-revalidate\\t\\n\"\n\t      \"Pragma: no-cache\\r\\n\"\n\t      \"Location: http://%s%s%s%s\\r\\n\\r\\n\",\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      HOTSPOT_DETECT_LUA_URL,\n\t      request_info->query_string ? \"?\" : \"\",\n\t      request_info->query_string ? request_info->query_string : \"\");\n    return(1);\n  }\n#if 0\n else if(!strcmp(request_info->uri, KINDLE_WIFISTUB_URL)) {\n    mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Expires: 0\\r\\n\"\n\t      \"Cache-Control: no-store, no-cache, must-revalidate\\t\\n\"\n\t      \"Pragma: no-cache\\r\\n\"\n\t      \"Referer: %s\\r\\n\"\n\t      \"Location: http://%s%s%s%s\\r\\n\\r\\n\",\n\t      request_info->uri,\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      ntop->getPrefs()->getCaptivePortalUrl(),\n\t      request_info->query_string ? \"?\" : \"\",\n\t      request_info->query_string ? request_info->query_string : \"\");\n    return(1);\n  }\n#endif\n\n  whitelisted = isWhitelistedURI(request_info->uri);\n  authorized = is_authorized(conn, request_info, username, sizeof(username));\n\n  if(isStaticResourceUrl(request_info, len))\n    ;\n  else if((!whitelisted) && (!authorized)) {\n    if(conn->client.lsa.sin.sin_port == ntop->get_HTTPserver()->getSplashPort())\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\",\n\t\tntop->getPrefs()->get_http_prefix(), BANNED_SITE_URL,\n\t\tmg_get_header(conn, \"Host\"));\n    else if(strcmp(request_info->uri, NETWORK_LOAD_URL) == 0) {\n      // avoid sending login redirect to allow js itself to redirect the user\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri, \"Login Required\"));\n    } else {\n      char referer[255];\n\n      snprintf(referer, sizeof(referer), \"%s%s%s%s\",\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      conn->request_info.uri,\n\t      conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t      conn->request_info.query_string ? conn->request_info.query_string : \"\");\n\n      redirect_to_login(conn, request_info, referer);\n    }\n\n    return(1);\n  } else if ((strcmp(request_info->uri, CHANGE_PASSWORD_ULR) != 0)\n      && (strcmp(request_info->uri, LOGOUT_URL) != 0)\n\t     && authorized\n      && ntop->mustChangePassword(username)) {\n    redirect_to_password_change(conn, request_info);\n    return(1);\n  } else if(strcmp(request_info->uri, AUTHORIZE_URL) == 0) {\n    authorize(conn, request_info, username);\n    return(1);\n  }\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Username = %s\", username);\n#endif\n\n  if(strstr(request_info->uri, \"//\")\n     || strstr(request_info->uri, \"&&\")\n     || strstr(request_info->uri, \"??\")\n     || strstr(request_info->uri, \"..\")\n     || strstr(request_info->uri, \"\\r\")\n     || strstr(request_info->uri, \"\\n\")\n     ) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] The URL %s is invalid/dangerous\",\n\t\t\t\t request_info->uri);\n    return(send_error(conn, 400 /* Bad Request */, request_info->uri,\n\t\t      \"The URL specified contains invalid/dangerous characters\"));\n  }\n\n  if((strncmp(request_info->uri, \"/lua/\", 5) == 0)\n     || (strcmp(request_info->uri, \"/metrics\") == 0)\n     || (strcmp(request_info->uri, \"/\") == 0)) {\n    /* Lua Script */\n    char path[255] = { 0 }, uri[2048];\n    struct stat buf;\n    bool found;\n\n    if(strstr(request_info->uri, \"/lua/pro\")\n       && (!ntop->getPrefs()->is_pro_edition())) {\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t\t\"Professional edition license required\"));\n    }\n\n    if(strstr(request_info->uri, \"/lua/pro/enterprise\")\n       && (!ntop->getPrefs()->is_enterprise_edition())) {\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t\t\"Enterprise edition license required\"));\n    }\n\n    if((!whitelisted)\n       && isCaptiveConnection(conn)\n       && (!isCaptiveURL(request_info->uri))) {\n      redirect_to_login(conn, request_info, (referer[0] == '\\0') ? NULL : referer);\n      return(0);\n    } else {\n      if(strcmp(request_info->uri, \"/metrics\") == 0)\n\tsnprintf(path, sizeof(path), \"%s/lua/metrics.lua\",\n\t  httpserver->get_scripts_dir());\n      else\n\tsnprintf(path, sizeof(path), \"%s%s%s\",\n\t       httpserver->get_scripts_dir(),\n\t       Utils::getURL(len == 1 ? (char*)\"/lua/index.lua\" : request_info->uri, uri, sizeof(uri)),\n\t       len > 1 && request_info->uri[len-1] == '/' ? (char*)\"index.lua\" : (char*)\"\");\n\n      if(strlen(path) > 4 && strncmp(&path[strlen(path) - 4], \".lua\", 4))\n\tsnprintf(&path[strlen(path)], sizeof(path) - strlen(path) - 1, \"%s\", (char*)\".lua\");\n\n      ntop->fixPath(path);\n      found = ((stat(path, &buf) == 0) && (S_ISREG(buf.st_mode))) ? true : false;\n    }\n\n    if(found) {\n      LuaEngine *l = new LuaEngine();\n\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s [%s]\", request_info->uri, path);\n\n      if(l == NULL) {\n\tntop->getTrace()->traceEvent(TRACE_ERROR, \"[HTTP] Unable to start Lua interpreter\");\n\treturn(send_error(conn, 500 /* Internal server error */,\n\t\t\t  \"Internal server error\", \"%s\", \"Unable to start Lua interpreter\"));\n      } else {\n\tl->handle_script_request(conn, request_info, path);\n\tdelete l;\n\treturn(1); /* Handled */\n      }\n    }\n\n    uri_encode(request_info->uri, uri, sizeof(uri)-1);\n\n    return(send_error(conn, 404, \"Not Found\", PAGE_NOT_FOUND, uri));\n  } else {\n    /* Prevent short URI or .inc files to be served */\n    if((len < 4) || (strncmp(&request_info->uri[len-4], \".inc\", 4) == 0)) {\n      return(send_error(conn, 403, \"Forbidden\",\n\t\t\tACCESS_FORBIDDEN, request_info->uri));\n    } else {\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Serving file %s%s\",\n\t\t\t\t   ntop->get_HTTPserver()->get_docs_dir(), request_info->uri);\n      request_info->query_string = \"\"; /* Discard things like ?v=4.4.0 */\n      return(0); /* This is a static document so let mongoose handle it */\n    }\n  }\n}\n\n/* ****************************************** */\n\nstatic int handle_http_message(const struct mg_connection *conn, const char *message) {\n  ntop->getTrace()->traceEvent(TRACE_ERROR, \"[HTTP] %s\", message);\n  return 1;\n}\n\nHTTPserver::HTTPserver(const char *_docs_dir, const char *_scripts_dir) {\n  struct mg_callbacks callbacks;\n  static char ports[256], ssl_cert_path[MAX_PATH] = { 0 }, access_log_path[MAX_PATH] = { 0 };\n  const char *http_binding_addr = ntop->getPrefs()->get_http_binding_address();\n  const char *https_binding_addr = ntop->getPrefs()->get_https_binding_address();\n  char tmpBuf[8];\n  bool use_ssl = false;\n  bool use_http = true;\n  struct stat statsBuf;\n  int stat_rc;\n\n  static char *http_options[] = {\n    (char*)\"listening_ports\", ports,\n    (char*)\"enable_directory_listing\", (char*)\"no\",\n    (char*)\"document_root\",  (char*)_docs_dir,\n    /* (char*)\"extra_mime_types\", (char*)\"\" */ /* see mongoose.c */\n    (char*)\"num_threads\", (char*)\"5\",\n    NULL, NULL, NULL, NULL,\n    NULL\n  };\n\n  docs_dir = strdup(_docs_dir), scripts_dir = strdup(_scripts_dir);\n  httpserver = this;\n  if(ntop->getPrefs()->get_http_port() == 0) use_http = false;\n\n  if(use_http) {\n    snprintf(ports, sizeof(ports), \"%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_http_port());\n  }\n\n  snprintf(ssl_cert_path, sizeof(ssl_cert_path), \"%s/ssl/%s\",\n\t   docs_dir, CONST_HTTPS_CERT_NAME);\n\n  stat_rc = stat(ssl_cert_path, &statsBuf);\n\n  if((ntop->getPrefs()->get_https_port() > 0) && (stat_rc == 0)) {\n    int i;\n\n    use_ssl = true;\n    if(use_http)\n      snprintf(ports, sizeof(ports), \"%s%s%d,%s%s%ds\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_http_port(),\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n    else\n      snprintf(ports, sizeof(ports), \"%s%s%ds\",\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Found SSL certificate %s\", ssl_cert_path);\n\n    for(i=0; http_options[i] != NULL; i++) ;\n\n    http_options[i] = (char*)\"ssl_certificate\", http_options[i+1] = ssl_cert_path;\n    ssl_enabled = true;\n  } else {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t   \"HTTPS Disabled: missing SSL certificate %s\", ssl_cert_path);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Please read https://github.com/ntop/ntopng/blob/dev/doc/README.SSL if you want to enable SSL.\");\n    ssl_enabled = false;\n  }\n\n  /* Alternate HTTP port (required for Captive Portal) */\n  if(use_http && ntop->getPrefs()->get_alt_http_port()) {\n    snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_alt_http_port());\n  }\n\n  if((!use_http) && (!use_ssl) & (!ssl_enabled)) {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t   \"Unable to start HTTP server: HTTP is disabled and the SSL certificate is missing.\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t \"Starting the HTTP server on the default port\");\n    snprintf(ports, sizeof(ports), \"%d\", ntop->getPrefs()->get_http_port());\n    use_http = true;\n  }\n\n  ntop->getRedis()->get((char*)SPLASH_HTTP_PORT, tmpBuf, sizeof(tmpBuf), true);\n  if(tmpBuf[0] != '\\0') {\n    http_splash_port = atoi(tmpBuf);\n\n    if(http_splash_port > 0) {\n      snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       http_splash_port);\n\n      /* Mongoose uses network byte order */\n      http_splash_port = ntohs(http_splash_port);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Ignoring HTTP splash port (%s)\", tmpBuf);\n  } else\n    http_splash_port = 0;\n\n  if(ntop->getPrefs()->is_access_log_enabled()) {\n    int i;\n\n    snprintf(access_log_path, sizeof(access_log_path), \"%s/ntopng_access.log\",\n\t     ntop->get_working_dir());\n\n    for(i=0; http_options[i] != NULL; i++)\n      ;\n\n    http_options[i] = (char*)\"access_log_file\", http_options[i+1] = access_log_path;\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP logs will be stored on %s\", access_log_path);\n  }\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.begin_request = handle_lua_request;\n  callbacks.log_message = handle_http_message;\n\n  /* mongoose */\n  http_prefix = ntop->getPrefs()->get_http_prefix(),\n    http_prefix_len = strlen(ntop->getPrefs()->get_http_prefix());\n\n  httpd_v4 = mg_start(&callbacks, NULL, (const char**)http_options);\n\n  if(httpd_v4 == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to start HTTP server (IPv4) on ports %s\", ports);\n    if (errno)\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s\", strerror(errno));\n    exit(-1);\n  }\n\n  /* ***************************** */\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Web server dirs [%s][%s]\", docs_dir, scripts_dir);\n\n  if(use_http)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server listening on port(s) %s\",\n\t\t\t\t ports);\n\n  if(use_ssl & ssl_enabled)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTPS server listening on port %d\",\n\t\t\t\t ntop->getPrefs()->get_https_port());\n};\n\n/* ****************************************** */\n\nHTTPserver::~HTTPserver() {\n  if(httpd_v4) mg_stop(httpd_v4);\n\n  free(docs_dir), free(scripts_dir);\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server terminated\");\n};\n\n/* ****************************************** */\n"], "fixing_code": ["/*\n *\n * (C) 2013-18 - ntop.org\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"ntop_includes.h\"\n\n#define USE_LUA\n#include \"../third-party/mongoose/mongoose.c\"\n#undef USE_LUA\n\nextern \"C\" {\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n};\n\nstatic HTTPserver *httpserver;\n\n/* ****************************************** */\n\n/*\n * Send error message back to a client.\n */\nint send_error(struct mg_connection *conn, int status, const char *reason, const char *fmt, ...) {\n  va_list ap;\n\n  conn->status_code = status;\n\n  (void) mg_printf(conn,\n\t\t   \"HTTP/1.1 %d %s\\r\\n\"\n\t\t   \"Content-Type: text/html\\r\\n\"\n\t\t   \"Connection: close\\r\\n\"\n\t\t   \"\\r\\n\", status, reason);\n\n  /* Errors 1xx, 204 and 304 MUST NOT send a body */\n  if(status > 199 && status != 204 && status != 304) {\n    char buf[BUFSIZ];\n    int  len;\n\n    conn->num_bytes_sent = 0;\n    va_start(ap, fmt);\n    len = mg_vsnprintf(conn, buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    conn->num_bytes_sent += mg_write(conn, buf, len);\n    cry_connection(conn, buf);\n  }\n\n  return(1);\n}\n\n/* ****************************************** */\n\nconst char *get_secure_cookie_attributes(const struct mg_request_info *request_info) {\n  if(request_info->is_ssl)\n    return \" HttpOnly; SameSite=lax; Secure\";\n  else\n    return \" HttpOnly; SameSite=lax\";\n}\n\n/* ****************************************** */\n\n#ifndef HAVE_NEDGE\nstatic void redirect_to_ssl(struct mg_connection *conn,\n                            const struct mg_request_info *request_info) {\n  const char *host = mg_get_header(conn, \"Host\");\n  //  u_int16_t port = ntop->get_HTTPserver()->get_port();\n\n  if(host != NULL) {\n    const char *p = strchr(host, ':');\n\n    if(p)\n      mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: https://%.*s:%u/%s\\r\\n\\r\\n\",\n\t\t(int) (p - host), host, ntop->getPrefs()->get_https_port(), request_info->uri);\n    else\n      mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: https://%s:%u/%s\\r\\n\\r\\n\",\n\t\thost, ntop->getPrefs()->get_https_port(), request_info->uri);\n  } else {\n    mg_printf(conn, \"%s\", \"HTTP/1.1 500 Error\\r\\n\\r\\nHost: header is not set\");\n  }\n}\n#endif\n\n/* ****************************************** */\n\n// Generate session ID. buf must be 33 bytes in size.\n// Note that it is easy to steal session cookies by sniffing traffic.\n// This is why all communication must be SSL-ed.\nstatic void generate_session_id(char *buf, const char *random, const char *user) {\n  mg_md5(buf, random, user, NULL);\n}\n\n/* ****************************************** */\n\nstatic inline bool authorized_localhost_users_login_disabled(const struct mg_connection *conn) {\n  if(ntop->getPrefs()->is_localhost_users_login_disabled()\n     && (conn->request_info.remote_ip == 0x7F000001 /* 127.0.0.1 */))\n    return true;\n  return false;\n}\n\n/* ****************************************** */\n\nstatic void set_cookie(const struct mg_connection *conn,\n                       char *user, char *referer) {\n  char key[256], session_id[64], random[64];\n\n  if(!strcmp(mg_get_request_info((struct mg_connection*)conn)->uri, \"/metrics\")\n     || !strncmp(mg_get_request_info((struct mg_connection*)conn)->uri, GRAFANA_URL, strlen(GRAFANA_URL))\n     || !strncmp(mg_get_request_info((struct mg_connection*)conn)->uri, POOL_MEMBERS_ASSOC_URL, strlen(POOL_MEMBERS_ASSOC_URL)))\n    return;\n\n  if(authorized_localhost_users_login_disabled(conn))\n    return;\n  \n  // Authentication success:\n  //   1. create new session\n  //   2. set session ID token in the cookie\n  //\n  // The most secure way is to stay HTTPS all the time. However, just to\n  // show the technique, we redirect to HTTP after the successful\n  // authentication. The danger of doing this is that session cookie can\n  // be stolen and an attacker may impersonate the user.\n  // Secure application must use HTTPS all the time.\n\n  snprintf(random, sizeof(random), \"%d\", rand());\n\n  generate_session_id(session_id, random, user);\n\n  // ntop->getTrace()->traceEvent(TRACE_ERROR, \"==> %s\\t%s\", random, session_id);\n\n  /* http://en.wikipedia.org/wiki/HTTP_cookie */\n  mg_printf((struct mg_connection *)conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t    \"Set-Cookie: session=%s; path=/; max-age=%u;%s\\r\\n\"  // Session ID\n\t    \"Set-Cookie: user=%s; path=/; max-age=%u;%s\\r\\n\"  // Set user, needed by JavaScript code\n\t    \"Location: %s%s\\r\\n\\r\\n\",\n\t    session_id, HTTP_SESSION_DURATION, get_secure_cookie_attributes(mg_get_request_info((struct mg_connection*)conn)),\n\t    user, HTTP_SESSION_DURATION, get_secure_cookie_attributes(mg_get_request_info((struct mg_connection*)conn)),\n\t    ntop->getPrefs()->get_http_prefix(), referer ? referer : \"/\");\n\n  /* Save session in redis */\n  snprintf(key, sizeof(key), \"sessions.%s\", session_id);\n  ntop->getRedis()->set(key, user, HTTP_SESSION_DURATION);\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Set session sessions.%s\", session_id);\n}\n\n/* ****************************************** */\n\nstatic void get_qsvar(const struct mg_request_info *request_info,\n                      const char *name, char *dst, size_t dst_len) {\n  const char *qs = request_info->query_string;\n  mg_get_var(qs, strlen(qs == NULL ? \"\" : qs), name, dst, dst_len);\n}\n\n/* ****************************************** */\n\nstatic int checkCaptive(const struct mg_connection *conn,\n\t\t\tconst struct mg_request_info *request_info,\n\t\t\tchar *username, char *password) {\n#ifdef NTOPNG_PRO\n  if(ntop->getPrefs()->isCaptivePortalEnabled()\n     && ntop->isCaptivePortalUser(username)) {\n    /*\n      This user logged onto ntopng via the captive portal\n    */\n    u_int16_t host_pool_id;\n    int32_t limited_lifetime = -1; /* Unlimited by default */\n    char label[128];\n\n    get_qsvar(request_info, \"label\", label, sizeof(label));\n\n#ifdef DEBUG\n    char buf[32];\n\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[CAPTIVE] %s @ %s/%08X [Redirecting to %s%s]\",\n\t\t\t\t username, Utils::intoaV4((unsigned int)conn->request_info.remote_ip, buf, sizeof(buf)),\n\t\t\t\t (unsigned int)conn->request_info.remote_ip,\n\t\t\t\t mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t\t request_info->uri);\n#endif\n\n    char bridge_interface[32];\n\n    if(!ntop->getUserAllowedIfname(username, bridge_interface, sizeof(bridge_interface)))\n      return(0);\n\n    ntop->getUserHostPool(username, &host_pool_id);\n    ntop->hasUserLimitedLifetime(username, &limited_lifetime);\n\n    if(!ntop->addIPToLRUMatches(htonl((unsigned int)conn->request_info.remote_ip),\n\t\t\t    host_pool_id, label, limited_lifetime, bridge_interface))\n      return(0);\n\n    /* Success */\n    return(1);\n  }\n#endif\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int checkInformativeCaptive(const struct mg_connection *conn,\n\t\t\t\t   const struct mg_request_info *request_info) {\n#ifdef NTOPNG_PRO\n#ifdef DEBUG\n  char buf[32];\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[CAPTIVE] @ %s/%08X [Redirecting to %s%s]\",\n\t\t\t       Utils::intoaV4((unsigned int)conn->request_info.remote_ip, buf, sizeof(buf)),\n\t\t\t       (unsigned int)conn->request_info.remote_ip,\n\t\t\t       mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t       request_info->uri);\n#endif\n\n  if(!ntop->addToNotifiedInformativeCaptivePortal(htonl((unsigned int)conn->request_info.remote_ip)))\n    return(0);\n\n  /* Success */\n  return(1);\n#endif\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int checkGrafana(const struct mg_connection *conn,\n\t\t\tconst struct mg_request_info *request_info) {\n\n  if(!strcmp(request_info->request_method, \"OPTIONS\") /* Allow for CORS inflight requests */\n    && !strncmp(request_info->uri, GRAFANA_URL, strlen(GRAFANA_URL)))\n    /* Success */\n    return(1);\n\n  return(0);\n}\n\n/* ****************************************** */\n\nstatic int isWhitelistedURI(char *uri) {\n  /* URL whitelist */\n  if((!strcmp(uri,    LOGIN_URL))\n     || (!strcmp(uri, AUTHORIZE_URL))\n     || (!strcmp(uri, BANNED_SITE_URL))\n     || (!strcmp(uri, PLEASE_WAIT_URL))\n     || (!strcmp(uri, HOTSPOT_DETECT_URL))\n     || (!strcmp(uri, HOTSPOT_DETECT_LUA_URL))\n     || (!strcmp(uri, ntop->getPrefs()->getCaptivePortalUrl()))\n     || (!strcmp(uri, KINDLE_WIFISTUB_URL))\n     )\n    return(1);\n  else\n    return(0);\n}\n\n/* ****************************************** */\n\n// Return 1 if request is authorized, 0 otherwise.\nstatic int is_authorized(const struct mg_connection *conn,\n                         const struct mg_request_info *request_info,\n\t\t\t char *username, u_int username_len) {\n  char session_id[33], buf[128];\n  char key[64], user[32];\n  char password[32];\n  const char *auth_header_p;\n  string auth_type = \"\", auth_string = \"\";\n  bool user_login_disabled = !ntop->getPrefs()->is_users_login_enabled() ||\n    authorized_localhost_users_login_disabled(conn);\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"[AUTHORIZATION] [%s][%s]\",\n\t\t\t       request_info->uri, request_info->query_string ? request_info->query_string : \"\");\n#endif\n\n  /*\n    iOS / MacOS\n    1. HOTSPOT_DETECT_URL        \"/hotspot-detect.html\"\n    2. HOTSPOT_DETECT_LUA_URL    \"/lua/hotspot-detect.lua\"\n    3. CAPTIVE_PORTAL_URL        \"/lua/captive_portal.lua\"\n    4. AUTHORIZE_CAPTIVE_LUA_URL \"/lua/authorize_captive.lua\"\n    5. logged in\n\n    Kindle\n    1. KINDLE_WIFISTUB_URL\n  */\n  if(!strcmp(request_info->uri, AUTHORIZE_CAPTIVE_LUA_URL)) {\n    /* A captive portal request has been issued to the authorization url */\n\n    if(ntop->getPrefs()->isInformativeCaptivePortalEnabled()) {\n      /* If the captive portal is just informative, there's no need to check\n\t any username or password. The request per se means the internet user\n\t has accepted the 'terms of service'. */\n      return(checkInformativeCaptive(conn, request_info));\n    } else {\n      /* Here the captive portal is not just informative; it requires authentication.\n         For this reason it is necessary to check submitted username and password. */\n      if(request_info->query_string) {\n\tget_qsvar(request_info, \"username\", username, username_len);\n\tget_qsvar(request_info, \"password\", password, sizeof(password));\n      }\n\n      return(ntop->checkUserPassword(username, password)\n\t     && checkCaptive(conn, request_info, username, password));\n    }\n  }\n\n  if(checkGrafana(conn, request_info) == 1) {\n    return(1);\n  }\n\n  if(user_login_disabled) {\n    mg_get_cookie(conn, \"user\", username, username_len);\n    if(strncmp(username, NTOP_NOLOGIN_USER, username_len)) {\n      set_cookie(conn, (char *)NTOP_NOLOGIN_USER, NULL);\n    }\n    return 1;\n  }\n\n  /* Try to decode Authorization header if present */\n  auth_header_p = mg_get_header(conn, \"Authorization\");\n  string auth_header = auth_header_p ? auth_header_p  : \"\";\n  istringstream iss(auth_header);\n  getline(iss, auth_type, ' ');\n  if(auth_type == \"Basic\") {\n    string decoded_auth, user_s = \"\", pword_s = \"\";\n    /* In case auth type is Basic, info are encoded in base64 */\n    getline(iss, auth_string, ' ');\n    decoded_auth = Utils::base64_decode(auth_string);\n    istringstream authss(decoded_auth);\n    getline(authss, user_s, ':');\n    getline(authss, pword_s, ':');\n\n    return ntop->checkUserPassword(user_s.c_str(), pword_s.c_str());\n  }\n\n  mg_get_cookie(conn, \"user\", username, username_len);\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n\n  if(!strcmp(username, NTOP_NOLOGIN_USER) && !user_login_disabled)\n    /* Trying to access web interface with nologin after ntopng restart\n       with different settings */\n    return 0;\n\n  if(session_id[0] == '\\0') {\n    /* Last resort: see if we have a user and password matching */\n    mg_get_cookie(conn, \"password\", password, sizeof(password));\n\n    return(ntop->checkUserPassword(username, password));\n  }\n\n  // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] Received session %s/%s\", session_id, username);\n\n  snprintf(key, sizeof(key), CONST_RUNTIME_IS_AUTOLOGOUT_ENABLED);\n  ntop->getRedis()->get(key, buf, sizeof(buf), true);\n  // do_auto_logout() is the getter for the command-line specified\n  // preference that defaults to true (i.e., auto_logout is enabled by default)\n  // If do_auto_logout() is disabled, then the runtime auto logout preference\n  // is taken into account.\n  // If do_auto_logout() is false, then the auto logout is disabled regardless\n  // of runtime preferences.\n  if(ntop->getPrefs()->do_auto_logout() && strncmp(buf, (char*)\"1\", 1) == 0) {\n    snprintf(key, sizeof(key), \"sessions.%s\", session_id);\n    if((ntop->getRedis()->get(key, user, sizeof(user), true) < 0)\n       || strcmp(user, username) /* Users don't match */) {\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Session %s/%s is expired or empty user\",\n\t\t\t\t   session_id, username);\n      return(0);\n    } else {\n      ntop->getRedis()->expire(key, HTTP_SESSION_DURATION); /* Extend session */\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Session %s is OK: extended for %u sec\",\n\t\t\t\t   session_id, HTTP_SESSION_DURATION);\n      return(1);\n    }\n  } else\n    return(1);\n}\n\n/* ****************************************** */\n\nstatic int isCaptiveConnection(struct mg_connection *conn) {\n  char *host = (char*)mg_get_header(conn, \"Host\");\n\n  return(ntop->getPrefs()->isCaptivePortalEnabled()\n\t && (ntohs(conn->client.lsa.sin.sin_port) == 80\n\t     || ntohs(conn->client.lsa.sin.sin_port) == 443)\n\t && (ntop->getPrefs()->get_alt_http_port() != 0)\n\t && host\n\t && (strcasestr(host, CONST_HELLO_HOST) == NULL)\n\t );\n}\n\n/* ****************************************** */\n\nstatic int isCaptiveURL(char *url) {\n  if((!strcmp(url, KINDLE_WIFISTUB_URL))\n     || (!strcmp(url, HOTSPOT_DETECT_URL))\n     || (!strcmp(url, HOTSPOT_DETECT_LUA_URL))\n     || (!strcmp(url, ntop->getPrefs()->getCaptivePortalUrl()))\n     || (!strcmp(url, AUTHORIZE_CAPTIVE_LUA_URL))\n     || (!strcmp(url, \"/\"))\n     )\n    return(1);\n  else\n    return(0);\n}\n\n/* ****************************************** */\n\nstatic bool isStaticResourceUrl(const struct mg_request_info *request_info, u_int len) {\n  if((len >= 3 && (!strncmp(&request_info->uri[len - 3], \".js\", 3)))\n     || (len >= 4 && (!strncmp(&request_info->uri[len - 4], \".css\", 4)\n\t\t      || !strncmp(&request_info->uri[len - 4], \".map\", 4)\n\t\t      || !strncmp(&request_info->uri[len - 4], \".ttf\", 4)))\n     || (len >= 6 && (!strncmp(&request_info->uri[len - 6], \".woff2\", 6))))\n    return true;\n\n  return false;\n}\n\n/* ****************************************** */\n\n// Redirect user to the login form. In the cookie, store the original URL\n// we came from, so that after the authorization we could redirect back.\nstatic void redirect_to_login(struct mg_connection *conn,\n                              const struct mg_request_info *request_info,\n\t\t\t      const char *referer) {\n  char session_id[33], buf[128];\n\n  if(isCaptiveConnection(conn)) {\n    if(referer)\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\", /* FIX */\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(), ntop->getPrefs()->getCaptivePortalUrl(), referer);\n    else\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s\\r\\n\\r\\n\", /* FIX */\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(), ntop->getPrefs()->getCaptivePortalUrl());\n  } else {\n#ifdef DEBUG\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[LOGIN] [Host: %s][URI: %s]\",\n\t\t\t\t mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t\t request_info->uri);\n#endif\n\n    mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n    if(referer)\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\",\n\t\tsession_id,\n\t\tget_secure_cookie_attributes(request_info),\n\t\tntop->getPrefs()->get_http_prefix(),\n\t\tUtils::getURL((char*)LOGIN_URL, buf, sizeof(buf)), referer);\n    else\n      mg_printf(conn,\n\t      \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t      \"Location: %s%s\\r\\n\\r\\n\",\n\t      session_id,\n\t      get_secure_cookie_attributes(request_info),\n\t      ntop->getPrefs()->get_http_prefix(),\n\t      Utils::getURL((char*)LOGIN_URL, buf, sizeof(buf)));\n  }\n}\n\n/* ****************************************** */\n\n#ifdef HAVE_MYSQL\n/* Redirect user to a courtesy page that is used when database schema is being updated.\n   In the cookie, store the original URL we came from, so that after the authorization\n   we could redirect back.\n*/\nstatic void redirect_to_please_wait(struct mg_connection *conn,\n\t\t\t\t    const struct mg_request_info *request_info) {\n  char session_id[33], buf[128];\n\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n  mg_printf(conn,\n\t    \"HTTP/1.1 302 Found\\r\\n\"\n\t    // \"HTTP/1.1 401 Unauthorized\\r\\n\"\n\t    // \"WWW-Authenticate: Basic\\r\\n\"\n\t    \"Set-Cookie: session=%s; path=/; expires=Thu, 01-Jan-1970 00:00:01 GMT; max-age=0;%s\\r\\n\"  // Session ID\n\t    \"Location: %s%s?referer=%s%s%s\\r\\n\\r\\n\",\n\t    session_id,\n\t    get_secure_cookie_attributes(request_info),\n\t    ntop->getPrefs()->get_http_prefix(),\n\t    Utils::getURL((char*)PLEASE_WAIT_URL, buf, sizeof(buf)),\n\t    conn->request_info.uri,\n\t    conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t    conn->request_info.query_string ? conn->request_info.query_string : \"\");\n}\n#endif\n\n/* ****************************************** */\n\nstatic void redirect_to_password_change(struct mg_connection *conn,\n\t\t\t\t    const struct mg_request_info *request_info) {\n  char session_id[33], buf[128];\n\n  mg_get_cookie(conn, \"session\", session_id, sizeof(session_id));\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s(%s)\", __FUNCTION__, session_id);\n\n    mg_printf(conn,\n\t      \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Set-Cookie: session=%s; path=/;%s\\r\\n\"  // Session ID\n\t      \"Location: %s%s?referer=%s%s%s%s\\r\\n\\r\\n\", /* FIX */\n\t      session_id,\n\t      get_secure_cookie_attributes(request_info),\n\t      ntop->getPrefs()->get_http_prefix(),\n\t      Utils::getURL((char*)CHANGE_PASSWORD_ULR, buf, sizeof(buf)),\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      conn->request_info.uri,\n\t      conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t      conn->request_info.query_string ? conn->request_info.query_string : \"\");\n}\n\n/* ****************************************** */\n\n// A handler for the /authorize endpoint.\n// Login page form sends user name and password to this endpoint.\nstatic void authorize(struct mg_connection *conn,\n                      const struct mg_request_info *request_info,\n\t\t      char *username) {\n  char user[32] = { '\\0' }, password[32] = { '\\0' }, referer[256] = { '\\0' };\n\n  if(!strcmp(request_info->request_method, \"POST\")) {\n    char post_data[1024];\n    int post_data_len = mg_read(conn, post_data, sizeof(post_data));\n\n    mg_get_var(post_data, post_data_len, \"user\", user, sizeof(user));\n    mg_get_var(post_data, post_data_len, \"password\", password, sizeof(password));\n    mg_get_var(post_data, post_data_len, \"referer\", referer, sizeof(referer));\n  } else {\n    // Fetch user name and password.\n    get_qsvar(request_info, \"user\", user, sizeof(user));\n    get_qsvar(request_info, \"password\", password, sizeof(password));\n    get_qsvar(request_info, \"ref\", referer, sizeof(referer));\n\n    if(referer[0] == '\\0') {\n      for(int i=0; request_info->http_headers[i].name != NULL; i++) {\n\tif(strcmp(request_info->http_headers[i].name, \"Referer\") == 0) {\n\t  snprintf(referer, sizeof(referer), \"%s\", request_info->http_headers[i].value);\n\t  break;\n\t}\n      }\n    }\n  }\n\n  if(isCaptiveConnection(conn) || ntop->isCaptivePortalUser(user) ||\n\t    (!ntop->checkUserPassword(user, password))) {\n    // Authentication failure, redirect to login\n    redirect_to_login(conn, request_info, (referer[0] == '\\0') ? NULL : referer);\n  } else {\n    /* Referer url must begin with '/' */\n    if((referer[0] != '/') || (strcmp(referer, AUTHORIZE_URL) == 0)) {\n      char *r = strchr(referer, '/');\n      strcpy(referer, r ? r : \"/\");\n    }\n\n    set_cookie(conn, user, referer);\n  }\n}\n\n/* ****************************************** */\n\nstatic void uri_encode(const char *src, char *dst, u_int dst_len) {\n  u_int i = 0, j = 0;\n\n  memset(dst, 0, dst_len);\n\n  while(src[i] != '\\0') {\n    if(src[i] == '<') {\n      dst[j++] = '&'; if(j == (dst_len-1)) break;\n      dst[j++] = 'l'; if(j == (dst_len-1)) break;\n      dst[j++] = 't'; if(j == (dst_len-1)) break;\n      dst[j++] = ';'; if(j == (dst_len-1)) break;\n    } else if(src[i] == '>') {\n      dst[j++] = '&'; if(j == (dst_len-1)) break;\n      dst[j++] = 'g'; if(j == (dst_len-1)) break;\n      dst[j++] = 't'; if(j == (dst_len-1)) break;\n      dst[j++] = ';'; if(j == (dst_len-1)) break;\n    } else {\n      dst[j++] = src[i]; if(j == (dst_len-1)) break;\n    }\n\n    i++;\n  }\n}\n\n/* ****************************************** */\n\nstatic int handle_lua_request(struct mg_connection *conn) {\n  struct mg_request_info *request_info = mg_get_request_info(conn);\n  char *crlf;\n  u_int len;\n  char username[33] = { 0 };\n  char *referer = (char*)mg_get_header(conn, \"Referer\");\n  u_int8_t whitelisted, authorized;\n\n  if(referer == NULL)\n    referer = (char*)\"\";\n\n  if((crlf = strstr(request_info->uri, \"\\r\\n\")))\n    *crlf = '\\0'; /* Prevents HTTP splitting attacks */\n\n  len = (u_int)strlen(request_info->uri);\n\n#ifdef HAVE_NEDGE\n  if(!ntop->getPro()->has_valid_license()) {\n    if (! ntop->getGlobals()->isShutdown()) {\n      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"License expired, shutting down...\");\n      ntop->getGlobals()->shutdown();\n      ntop->shutdown();\n    }\n  }\n#endif\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[Host: %s][URI: %s][%s][Referer: %s]\",\n\t\t\t       mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t\t\t       request_info->uri,\n\t\t\t       request_info->query_string ? request_info->query_string : \"\",\n\t\t\t       (char*)mg_get_header(conn, \"Referer\"));\n#endif\n\n  if((ntop->getGlobals()->isShutdown())\n     //|| (strcmp(request_info->request_method, \"GET\"))\n     || (ntop->getRedis() == NULL /* Starting up... */)\n     || (ntop->get_HTTPserver() == NULL))\n    return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t      \"Unexpected HTTP method or ntopng still starting up...\"));\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"################# [HTTP] %s [%s]\",\n\t\t\t       request_info->uri, referer);\n#endif\n\n#ifdef HAVE_MYSQL\n  if(ntop->getPrefs()->do_dump_flows_on_mysql()\n     && !MySQLDB::isDbCreated()\n     && strcmp(request_info->uri, PLEASE_WAIT_URL)) {\n    redirect_to_please_wait(conn, request_info);\n  } else\n#endif\n#ifndef HAVE_NEDGE\n  if(ntop->get_HTTPserver()->is_ssl_enabled()\n     && (!request_info->is_ssl)\n     && isCaptiveURL(request_info->uri)\n     && (!strstr(referer, HOTSPOT_DETECT_LUA_URL))\n     && (!strstr(referer, ntop->getPrefs()->getCaptivePortalUrl()))\n     // && ((mg_get_header(conn, \"Host\") == NULL) || (mg_get_header(conn, \"Host\")[0] == '\\0'))\n     ) {\n    redirect_to_ssl(conn, request_info);\n    return(1);\n  } else\n#endif\n  if(!strcmp(request_info->uri, HOTSPOT_DETECT_URL)) {\n    mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Expires: 0\\r\\n\"\n\t      \"Cache-Control: no-store, no-cache, must-revalidate\\t\\n\"\n\t      \"Pragma: no-cache\\r\\n\"\n\t      \"Location: http://%s%s%s%s\\r\\n\\r\\n\",\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      HOTSPOT_DETECT_LUA_URL,\n\t      request_info->query_string ? \"?\" : \"\",\n\t      request_info->query_string ? request_info->query_string : \"\");\n    return(1);\n  }\n#if 0\n else if(!strcmp(request_info->uri, KINDLE_WIFISTUB_URL)) {\n    mg_printf(conn, \"HTTP/1.1 302 Found\\r\\n\"\n\t      \"Expires: 0\\r\\n\"\n\t      \"Cache-Control: no-store, no-cache, must-revalidate\\t\\n\"\n\t      \"Pragma: no-cache\\r\\n\"\n\t      \"Referer: %s\\r\\n\"\n\t      \"Location: http://%s%s%s%s\\r\\n\\r\\n\",\n\t      request_info->uri,\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      ntop->getPrefs()->getCaptivePortalUrl(),\n\t      request_info->query_string ? \"?\" : \"\",\n\t      request_info->query_string ? request_info->query_string : \"\");\n    return(1);\n  }\n#endif\n\n  whitelisted = isWhitelistedURI(request_info->uri);\n  authorized = is_authorized(conn, request_info, username, sizeof(username));\n\n  if(isStaticResourceUrl(request_info, len))\n    ;\n  else if((!whitelisted) && (!authorized)) {\n    if(conn->client.lsa.sin.sin_port == ntop->get_HTTPserver()->getSplashPort())\n      mg_printf(conn,\n\t\t\"HTTP/1.1 302 Found\\r\\n\"\n\t\t\"Location: %s%s?referer=%s\\r\\n\\r\\n\",\n\t\tntop->getPrefs()->get_http_prefix(), BANNED_SITE_URL,\n\t\tmg_get_header(conn, \"Host\"));\n    else if(strcmp(request_info->uri, NETWORK_LOAD_URL) == 0) {\n      // avoid sending login redirect to allow js itself to redirect the user\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri, \"Login Required\"));\n    } else {\n      char referer[255];\n\n      snprintf(referer, sizeof(referer), \"%s%s%s%s\",\n\t      mg_get_header(conn, \"Host\") ? mg_get_header(conn, \"Host\") : (char*)\"\",\n\t      conn->request_info.uri,\n\t      conn->request_info.query_string ? \"%3F\" /* ? */: \"\",\n\t      conn->request_info.query_string ? conn->request_info.query_string : \"\");\n\n      redirect_to_login(conn, request_info, referer);\n    }\n\n    return(1);\n  } else if ((strcmp(request_info->uri, CHANGE_PASSWORD_ULR) != 0)\n      && (strcmp(request_info->uri, LOGOUT_URL) != 0)\n\t     && authorized\n      && ntop->mustChangePassword(username)) {\n    redirect_to_password_change(conn, request_info);\n    return(1);\n  } else if(strcmp(request_info->uri, AUTHORIZE_URL) == 0) {\n    authorize(conn, request_info, username);\n    return(1);\n  }\n\n#ifdef DEBUG\n  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Username = %s\", username);\n#endif\n\n  if(strstr(request_info->uri, \"//\")\n     || strstr(request_info->uri, \"&&\")\n     || strstr(request_info->uri, \"??\")\n     || strstr(request_info->uri, \"..\")\n     || strstr(request_info->uri, \"\\r\")\n     || strstr(request_info->uri, \"\\n\")\n     ) {\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] The URL %s is invalid/dangerous\",\n\t\t\t\t request_info->uri);\n    return(send_error(conn, 400 /* Bad Request */, request_info->uri,\n\t\t      \"The URL specified contains invalid/dangerous characters\"));\n  }\n\n  if((strncmp(request_info->uri, \"/lua/\", 5) == 0)\n     || (strcmp(request_info->uri, \"/metrics\") == 0)\n     || (strcmp(request_info->uri, \"/\") == 0)) {\n    /* Lua Script */\n    char path[255] = { 0 }, uri[2048];\n    struct stat buf;\n    bool found;\n\n    if(strstr(request_info->uri, \"/lua/pro\")\n       && (!ntop->getPrefs()->is_pro_edition())) {\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t\t\"Professional edition license required\"));\n    }\n\n    if(strstr(request_info->uri, \"/lua/pro/enterprise\")\n       && (!ntop->getPrefs()->is_enterprise_edition())) {\n      return(send_error(conn, 403 /* Forbidden */, request_info->uri,\n\t\t\t\"Enterprise edition license required\"));\n    }\n\n    if((!whitelisted)\n       && isCaptiveConnection(conn)\n       && (!isCaptiveURL(request_info->uri))) {\n      redirect_to_login(conn, request_info, (referer[0] == '\\0') ? NULL : referer);\n      return(0);\n    } else {\n      if(strcmp(request_info->uri, \"/metrics\") == 0)\n\tsnprintf(path, sizeof(path), \"%s/lua/metrics.lua\",\n\t  httpserver->get_scripts_dir());\n      else\n\tsnprintf(path, sizeof(path), \"%s%s%s\",\n\t       httpserver->get_scripts_dir(),\n\t       Utils::getURL(len == 1 ? (char*)\"/lua/index.lua\" : request_info->uri, uri, sizeof(uri)),\n\t       len > 1 && request_info->uri[len-1] == '/' ? (char*)\"index.lua\" : (char*)\"\");\n\n      if(strlen(path) > 4 && strncmp(&path[strlen(path) - 4], \".lua\", 4))\n\tsnprintf(&path[strlen(path)], sizeof(path) - strlen(path) - 1, \"%s\", (char*)\".lua\");\n\n      ntop->fixPath(path);\n      found = ((stat(path, &buf) == 0) && (S_ISREG(buf.st_mode))) ? true : false;\n    }\n\n    if(found) {\n      LuaEngine *l = new LuaEngine();\n\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] %s [%s]\", request_info->uri, path);\n\n      if(l == NULL) {\n\tntop->getTrace()->traceEvent(TRACE_ERROR, \"[HTTP] Unable to start Lua interpreter\");\n\treturn(send_error(conn, 500 /* Internal server error */,\n\t\t\t  \"Internal server error\", \"%s\", \"Unable to start Lua interpreter\"));\n      } else {\n\tl->handle_script_request(conn, request_info, path);\n\tdelete l;\n\treturn(1); /* Handled */\n      }\n    }\n\n    uri_encode(request_info->uri, uri, sizeof(uri)-1);\n\n    return(send_error(conn, 404, \"Not Found\", PAGE_NOT_FOUND, uri));\n  } else {\n    /* Prevent short URI or .inc files to be served */\n    if((len < 4) || (strncmp(&request_info->uri[len-4], \".inc\", 4) == 0)) {\n      return(send_error(conn, 403, \"Forbidden\",\n\t\t\tACCESS_FORBIDDEN, request_info->uri));\n    } else {\n      ntop->getTrace()->traceEvent(TRACE_INFO, \"[HTTP] Serving file %s%s\",\n\t\t\t\t   ntop->get_HTTPserver()->get_docs_dir(), request_info->uri);\n      request_info->query_string = \"\"; /* Discard things like ?v=4.4.0 */\n      return(0); /* This is a static document so let mongoose handle it */\n    }\n  }\n}\n\n/* ****************************************** */\n\nstatic int handle_http_message(const struct mg_connection *conn, const char *message) {\n  ntop->getTrace()->traceEvent(TRACE_ERROR, \"[HTTP] %s\", message);\n  return 1;\n}\n\nHTTPserver::HTTPserver(const char *_docs_dir, const char *_scripts_dir) {\n  struct mg_callbacks callbacks;\n  static char ports[256], ssl_cert_path[MAX_PATH] = { 0 }, access_log_path[MAX_PATH] = { 0 };\n  const char *http_binding_addr = ntop->getPrefs()->get_http_binding_address();\n  const char *https_binding_addr = ntop->getPrefs()->get_https_binding_address();\n  char tmpBuf[8];\n  bool use_ssl = false;\n  bool use_http = true;\n  struct stat statsBuf;\n  int stat_rc;\n  struct timeval tv;\n\n  /* Randomize data */\n  gettimeofday(&tv, NULL);\n  srand(tv.tv_sec + tv.tv_usec);\n  \n  static char *http_options[] = {\n    (char*)\"listening_ports\", ports,\n    (char*)\"enable_directory_listing\", (char*)\"no\",\n    (char*)\"document_root\",  (char*)_docs_dir,\n    /* (char*)\"extra_mime_types\", (char*)\"\" */ /* see mongoose.c */\n    (char*)\"num_threads\", (char*)\"5\",\n    NULL, NULL, NULL, NULL,\n    NULL\n  };\n\n  docs_dir = strdup(_docs_dir), scripts_dir = strdup(_scripts_dir);\n  httpserver = this;\n  if(ntop->getPrefs()->get_http_port() == 0) use_http = false;\n\n  if(use_http) {\n    snprintf(ports, sizeof(ports), \"%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_http_port());\n  }\n\n  snprintf(ssl_cert_path, sizeof(ssl_cert_path), \"%s/ssl/%s\",\n\t   docs_dir, CONST_HTTPS_CERT_NAME);\n\n  stat_rc = stat(ssl_cert_path, &statsBuf);\n\n  if((ntop->getPrefs()->get_https_port() > 0) && (stat_rc == 0)) {\n    int i;\n\n    use_ssl = true;\n    if(use_http)\n      snprintf(ports, sizeof(ports), \"%s%s%d,%s%s%ds\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_http_port(),\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n    else\n      snprintf(ports, sizeof(ports), \"%s%s%ds\",\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Found SSL certificate %s\", ssl_cert_path);\n\n    for(i=0; http_options[i] != NULL; i++) ;\n\n    http_options[i] = (char*)\"ssl_certificate\", http_options[i+1] = ssl_cert_path;\n    ssl_enabled = true;\n  } else {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t   \"HTTPS Disabled: missing SSL certificate %s\", ssl_cert_path);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Please read https://github.com/ntop/ntopng/blob/dev/doc/README.SSL if you want to enable SSL.\");\n    ssl_enabled = false;\n  }\n\n  /* Alternate HTTP port (required for Captive Portal) */\n  if(use_http && ntop->getPrefs()->get_alt_http_port()) {\n    snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_alt_http_port());\n  }\n\n  if((!use_http) && (!use_ssl) & (!ssl_enabled)) {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t   \"Unable to start HTTP server: HTTP is disabled and the SSL certificate is missing.\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t \"Starting the HTTP server on the default port\");\n    snprintf(ports, sizeof(ports), \"%d\", ntop->getPrefs()->get_http_port());\n    use_http = true;\n  }\n\n  ntop->getRedis()->get((char*)SPLASH_HTTP_PORT, tmpBuf, sizeof(tmpBuf), true);\n  if(tmpBuf[0] != '\\0') {\n    http_splash_port = atoi(tmpBuf);\n\n    if(http_splash_port > 0) {\n      snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       http_splash_port);\n\n      /* Mongoose uses network byte order */\n      http_splash_port = ntohs(http_splash_port);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Ignoring HTTP splash port (%s)\", tmpBuf);\n  } else\n    http_splash_port = 0;\n\n  if(ntop->getPrefs()->is_access_log_enabled()) {\n    int i;\n\n    snprintf(access_log_path, sizeof(access_log_path), \"%s/ntopng_access.log\",\n\t     ntop->get_working_dir());\n\n    for(i=0; http_options[i] != NULL; i++)\n      ;\n\n    http_options[i] = (char*)\"access_log_file\", http_options[i+1] = access_log_path;\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP logs will be stored on %s\", access_log_path);\n  }\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.begin_request = handle_lua_request;\n  callbacks.log_message = handle_http_message;\n\n  /* mongoose */\n  http_prefix = ntop->getPrefs()->get_http_prefix(),\n    http_prefix_len = strlen(ntop->getPrefs()->get_http_prefix());\n\n  httpd_v4 = mg_start(&callbacks, NULL, (const char**)http_options);\n\n  if(httpd_v4 == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to start HTTP server (IPv4) on ports %s\", ports);\n    if (errno)\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s\", strerror(errno));\n    exit(-1);\n  }\n\n  /* ***************************** */\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Web server dirs [%s][%s]\", docs_dir, scripts_dir);\n\n  if(use_http)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server listening on port(s) %s\",\n\t\t\t\t ports);\n\n  if(use_ssl & ssl_enabled)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTPS server listening on port %d\",\n\t\t\t\t ntop->getPrefs()->get_https_port());\n};\n\n/* ****************************************** */\n\nHTTPserver::~HTTPserver() {\n  if(httpd_v4) mg_stop(httpd_v4);\n\n  free(docs_dir), free(scripts_dir);\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server terminated\");\n};\n\n/* ****************************************** */\n"], "filenames": ["src/HTTPserver.cpp"], "buggy_code_start_loc": [867], "buggy_code_end_loc": [868], "fixing_code_start_loc": [867], "fixing_code_end_loc": [873], "type": "CWE-335", "message": "An issue was discovered in ntopng 3.4 before 3.4.180617. The PRNG involved in the generation of session IDs is not seeded at program startup. This results in deterministic session IDs being allocated for active user sessions. An attacker with foreknowledge of the operating system and standard library in use by the host running the service and the username of the user whose session they're targeting can abuse the deterministic random number generation in order to hijack the user's session, thus escalating their access.", "other": {"cve": {"id": "CVE-2018-12520", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T20:29:00.527", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ntopng 3.4 before 3.4.180617. The PRNG involved in the generation of session IDs is not seeded at program startup. This results in deterministic session IDs being allocated for active user sessions. An attacker with foreknowledge of the operating system and standard library in use by the host running the service and the username of the user whose session they're targeting can abuse the deterministic random number generation in order to hijack the user's session, thus escalating their access."}, {"lang": "es", "value": "Se ha descubierto un problema en ntopng, en versiones 3.4 anteriores a la 3.4.180617. El PRNG implicado en la generaci\u00f3n de ID de sesi\u00f3n no se propaga al iniciar el programa. Esto resulta en que se asignan ID de sesi\u00f3n deterministas para las sesiones activas de usuario. Un atacante con conocimientos del sistema operativo y biblioteca est\u00e1ndar en uso por parte del host que ejecuta el servicio y el nombre de usuario del usuario cuya sesi\u00f3n est\u00e1 en el punto de mira puede abusar de la generaci\u00f3n determinista de n\u00fameros aleatorios para secuestrar la sesi\u00f3n del usuario y escalando su acceso."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-335"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ntopng:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4", "versionEndExcluding": "3.4.180617", "matchCriteriaId": "4430DA75-F986-4B4E-9163-789C6269C328"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2018/Jul/14", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://gist.github.com/Psychotropos/3e8c047cada9b1fb716e6a014a428b7f", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ntop/ntopng/commit/30610bda60cbfc058f90a1c0a17d0e8f4516221a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44973/", "source": "cve@mitre.org", "tags": ["Exploit", "VDB Entry", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/ntopng/commit/30610bda60cbfc058f90a1c0a17d0e8f4516221a"}}