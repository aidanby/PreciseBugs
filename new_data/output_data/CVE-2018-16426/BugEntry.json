{"buggy_code": ["/*\n * card-iasecc.c: Support for IAS/ECC smart cards\n *\n * Copyright (C) 2010  Viktor Tarasov <vtarasov@gmail.com>\n *\t\t\tOpenTrust <www.opentrust.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef ENABLE_OPENSSL   /* empty file without openssl */\n\n#include <string.h>\n#include <stdlib.h>\n\n#include <openssl/bn.h>\n#include <openssl/evp.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/sha.h>\n#include <openssl/rsa.h>\n#include <openssl/pkcs12.h>\n#include <openssl/x509v3.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#include \"opensc.h\"\n/* #include \"sm.h\" */\n#include \"pkcs15.h\"\n/* #include \"hash-strings.h\" */\n#include \"gp.h\"\n\n#include \"iasecc.h\"\n\n#define IASECC_CARD_DEFAULT_FLAGS ( 0\t\t\t\\\n\t\t| SC_ALGORITHM_ONBOARD_KEY_GEN\t\t\\\n\t\t| SC_ALGORITHM_RSA_PAD_ISO9796\t\t\\\n\t\t| SC_ALGORITHM_RSA_PAD_PKCS1\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_NONE\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_SHA1\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_SHA256)\n\n/* generic iso 7816 operations table */\nstatic const struct sc_card_operations *iso_ops = NULL;\n\n/* our operations table with overrides */\nstatic struct sc_card_operations iasecc_ops;\n\nstatic struct sc_card_driver iasecc_drv = {\n\t\"IAS-ECC\",\n\t\"iasecc\",\n\t&iasecc_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_atr_table iasecc_known_atrs[] = {\n\t{ \"3B:7F:96:00:00:00:31:B8:64:40:70:14:10:73:94:01:80:82:90:00\",\n\t  \"FF:FF:FF:FF:FF:FF:FF:FE:FF:FF:00:00:FF:FF:FF:FF:FF:FF:FF:FF\",\n\t\t\"IAS/ECC Gemalto\", SC_CARD_TYPE_IASECC_GEMALTO,  0, NULL },\n        { \"3B:DD:18:00:81:31:FE:45:80:F9:A0:00:00:00:77:01:08:00:07:90:00:FE\", NULL,\n\t\t\"IAS/ECC v1.0.1 Oberthur\", SC_CARD_TYPE_IASECC_OBERTHUR,  0, NULL },\n\t{ \"3B:7D:13:00:00:4D:44:57:2D:49:41:53:2D:43:41:52:44:32\", NULL,\n\t\t\"IAS/ECC v1.0.1 Sagem MDW-IAS-CARD2\", SC_CARD_TYPE_IASECC_SAGEM,  0, NULL },\n\t{ \"3B:7F:18:00:00:00:31:B8:64:50:23:EC:C1:73:94:01:80:82:90:00\", NULL,\n\t\t\"IAS/ECC v1.0.1 Sagem ypsID S3\", SC_CARD_TYPE_IASECC_SAGEM,  0, NULL },\n\t{ \"3B:DF:96:00:80:31:FE:45:00:31:B8:64:04:1F:EC:C1:73:94:01:80:82:90:00:EC\", NULL,\n\t\t\"IAS/ECC Morpho MinInt - Agent Card\", SC_CARD_TYPE_IASECC_MI, 0, NULL },\n\t{ \"3B:DF:18:FF:81:91:FE:1F:C3:00:31:B8:64:0C:01:EC:C1:73:94:01:80:82:90:00:B3\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ \"3B:DC:18:FF:81:91:FE:1F:C3:80:73:C8:21:13:66:02:04:03:55:00:02:34\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ \"3B:DC:18:FF:81:91:FE:1F:C3:80:73:C8:21:13:66:01:0B:03:52:00:05:38\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\nstatic struct sc_aid OberthurIASECC_AID = {\n\t{0xA0,0x00,0x00,0x00,0x77,0x01,0x08,0x00,0x07,0x00,0x00,0xFE,0x00,0x00,0x01,0x00}, 16\n};\n\nstatic struct sc_aid MIIASECC_AID = {\n\t{ 0x4D, 0x49, 0x4F, 0x4D, 0x43, 0x54}, 6\n};\n\nstruct iasecc_pin_status  {\n\tunsigned char sha1[SHA_DIGEST_LENGTH];\n\tunsigned char reference;\n\n\tstruct iasecc_pin_status *next;\n\tstruct iasecc_pin_status *prev;\n};\n\nstruct iasecc_pin_status *checked_pins = NULL;\n\nstatic int iasecc_select_file(struct sc_card *card, const struct sc_path *path, struct sc_file **file_out);\nstatic int iasecc_process_fci(struct sc_card *card, struct sc_file *file, const unsigned char *buf, size_t buflen);\nstatic int iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial);\nstatic int iasecc_sdo_get_data(struct sc_card *card, struct iasecc_sdo *sdo);\nstatic int iasecc_pin_get_policy (struct sc_card *card, struct sc_pin_cmd_data *data);\nstatic int iasecc_pin_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, int *tries_left);\nstatic int iasecc_get_free_reference(struct sc_card *card, struct iasecc_ctl_get_free_reference *ctl_data);\nstatic int iasecc_sdo_put_data(struct sc_card *card, struct iasecc_sdo_update *update);\n\n#ifdef ENABLE_SM\nstatic int _iasecc_sm_read_binary(struct sc_card *card, unsigned int offs, unsigned char *buf, size_t count);\nstatic int _iasecc_sm_update_binary(struct sc_card *card, unsigned int offs, const unsigned char *buff, size_t count);\n#endif\n\nstatic int\niasecc_chv_cache_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *pin_status = NULL, *current = NULL;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (current)   {\n\t\tsc_log(ctx, \"iasecc_chv_cache_verified() current PIN-%i\", current->reference);\n\t\tpin_status = current;\n\t}\n\telse   {\n\t\tpin_status = calloc(1, sizeof(struct iasecc_pin_status));\n\t\tif (!pin_status)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot callocate PIN status info\");\n\t\tsc_log(ctx, \"iasecc_chv_cache_verified() allocated %p\", pin_status);\n\t}\n\n\tpin_status->reference = pin_cmd->pin_reference;\n\tif (pin_cmd->pin1.data)\n\t\tSHA1(pin_cmd->pin1.data, pin_cmd->pin1.len, pin_status->sha1);\n\telse\n\t\tmemset(pin_status->sha1, 0, SHA_DIGEST_LENGTH);\n\n\tsc_log_hex(ctx, \"iasecc_chv_cache_verified() sha1(PIN)\", pin_status->sha1, SHA_DIGEST_LENGTH);\n\n\tif (!current)   {\n\t\tif (!checked_pins)   {\n\t\t\tchecked_pins = pin_status;\n\t\t}\n\t\telse   {\n\t\tchecked_pins->prev = pin_status;\n\t\t\tpin_status->next = checked_pins;\n\t\t\tchecked_pins = pin_status;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_chv_cache_clean(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *current = NULL;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (!current)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\n\tif (current->next && current->prev)   {\n\t\tcurrent->prev->next = current->next;\n\t\tcurrent->next->prev = current->prev;\n\t}\n\telse if (!current->prev)   {\n\t\tchecked_pins = current->next;\n\t}\n\telse if (!current->next && current->prev)   {\n\t\tcurrent->prev->next = NULL;\n\t}\n\n\tfree(current);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic struct iasecc_pin_status *\niasecc_chv_cache_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *current = NULL;\n\tunsigned char data_sha1[SHA_DIGEST_LENGTH];\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (pin_cmd->pin1.data)\n\t\tSHA1(pin_cmd->pin1.data, pin_cmd->pin1.len, data_sha1);\n\telse\n\t\tmemset(data_sha1, 0, SHA_DIGEST_LENGTH);\n\tsc_log_hex(ctx, \"data_sha1: %s\", data_sha1, SHA_DIGEST_LENGTH);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (current && !memcmp(data_sha1, current->sha1, SHA_DIGEST_LENGTH))   {\n\t\tsc_log(ctx, \"PIN-%i status 'verified'\", pin_cmd->pin_reference);\n\t\treturn current;\n\t}\n\n\tsc_log(ctx, \"PIN-%i status 'not verified'\", pin_cmd->pin_reference);\n\treturn NULL;\n}\n\n\nstatic int\niasecc_select_mf(struct sc_card *card, struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *mf_file = NULL;\n\tstruct sc_path path;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tmemset(&path, 0, sizeof(struct sc_path));\n\tif (!card->ef_atr || !card->ef_atr->aid.len)   {\n\t\tstruct sc_apdu apdu;\n\t\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\n\t\t/* ISO 'select' command fails when not FCP data returned */\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x00, 0x00);\n\t\tapdu.lc = path.len;\n\t\tapdu.data = path.value;\n\t\tapdu.datalen = path.len;\n\t\tapdu.resplen = sizeof(apdu_resp);\n\t\tapdu.resp = apdu_resp;\n\n\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\tapdu.p2 = 0x04;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, rv, \"Cannot select MF\");\n\t}\n\telse   {\n\t\tmemset(&path, 0, sizeof(path));\n\t\tpath.type = SC_PATH_TYPE_DF_NAME;\n\t\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\t\tpath.len = card->ef_atr->aid.len;\n\t\trv = iasecc_select_file(card, &path, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"Unable to ROOT selection\");\n\t}\n\n\t/* Ignore the FCP of the MF, because:\n\t * - some cards do not return it;\n\t * - there is not need of it -- create/delete of the files in MF is not envisaged.\n\t */\n\tmf_file = sc_file_new();\n\tif (mf_file == NULL)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot allocate MF file\");\n\tmf_file->type = SC_FILE_TYPE_DF;\n\tmf_file->path = path;\n\n\tif (card->cache.valid)\n\t\t sc_file_free(card->cache.current_df);\n\tcard->cache.current_df = NULL;\n\n\tif (card->cache.valid)\n\t\tsc_file_free(card->cache.current_ef);\n\tcard->cache.current_ef = NULL;\n\n\tsc_file_dup(&card->cache.current_df, mf_file);\n\tcard->cache.valid = 1;\n\n\tif (file_out && *file_out == NULL)\n\t\t*file_out = mf_file;\n\telse\n\t\tsc_file_free(mf_file);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_select_aid(struct sc_card *card, struct sc_aid *aid, unsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\t/* Select application (deselect previously selected application) */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid->len;\n\tapdu.data = aid->value;\n\tapdu.datalen = aid->len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\n\tif (*out_len < apdu.resplen)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID\");\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\niasecc_match_card(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint i;\n\n\ti = _sc_match_atr(card, iasecc_known_atrs, &card->type);\n\tif (i < 0)   {\n\t\tsc_log(ctx, \"card not matched\");\n\t\treturn 0;\n\t}\n\n\tsc_log(ctx, \"'%s' card matched\", iasecc_known_atrs[i].name);\n\treturn 1;\n}\n\n\nstatic int iasecc_parse_ef_atr(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *pdata = (struct iasecc_private_data *) card->drv_data;\n\tstruct iasecc_version *version = &pdata->version;\n\tstruct iasecc_io_buffer_sizes *sizes = &pdata->max_sizes;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\trv = sc_parse_ef_atr(card);\n\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\tif (card->ef_atr->pre_issuing_len < 4)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid pre-issuing data\");\n\n\tversion->ic_manufacturer =\tcard->ef_atr->pre_issuing[0];\n\tversion->ic_type =\t\tcard->ef_atr->pre_issuing[1];\n\tversion->os_version =\t\tcard->ef_atr->pre_issuing[2];\n\tversion->iasecc_version =\tcard->ef_atr->pre_issuing[3];\n\tsc_log(ctx, \"EF.ATR: IC manufacturer/type %X/%X, OS/IasEcc versions %X/%X\",\n\t\tversion->ic_manufacturer, version->ic_type, version->os_version, version->iasecc_version);\n\n\tif (card->ef_atr->issuer_data_len < 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid issuer data\");\n\n\tsizes->send =\t card->ef_atr->issuer_data[2] * 0x100 + card->ef_atr->issuer_data[3];\n\tsizes->send_sc = card->ef_atr->issuer_data[6] * 0x100 + card->ef_atr->issuer_data[7];\n\tsizes->recv =\t card->ef_atr->issuer_data[10] * 0x100 + card->ef_atr->issuer_data[11];\n\tsizes->recv_sc = card->ef_atr->issuer_data[14] * 0x100 + card->ef_atr->issuer_data[15];\n\n\tcard->max_send_size = sizes->send;\n\tcard->max_recv_size = sizes->recv;\n\n\t/* Most of the card producers interpret 'send' values as \"maximum APDU data size\".\n\t * Oberthur strictly follows specification and interpret these values as \"maximum APDU command size\".\n\t * Here we need 'data size'.\n\t */\n\tif (card->max_send_size > 0xFF)\n\t\tcard->max_send_size -= 5;\n\n\tsc_log(ctx,\n\t       \"EF.ATR: max send/recv sizes %\"SC_FORMAT_LEN_SIZE_T\"X/%\"SC_FORMAT_LEN_SIZE_T\"X\",\n\t       card->max_send_size, card->max_recv_size);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_gemalto(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path path;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tsc_format_path(\"3F00\", &path);\n\trv = sc_select_file(card, &path, NULL);\n\t/* Result ignored*/\n\n\trv = iasecc_parse_ef_atr(card);\n\tsc_log(ctx, \"rv %i\", rv);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\tsc_log(ctx, \"Select MF\");\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tsc_log(ctx, \"rv %i\", rv);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\trv = iasecc_parse_ef_atr(card);\n\t\tsc_log(ctx, \"rv %i\", rv);\n\t}\n\tsc_log(ctx, \"rv %i\", rv);\n\tLOG_TEST_RET(ctx, rv, \"Cannot read/parse EF.ATR\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_oberthur_match(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char *hist = card->reader->atr_info.hist_bytes;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (*hist != 0x80 || ((*(hist+1)&0xF0) != 0xF0))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OBJECT_NOT_FOUND);\n\n\tsc_log_hex(ctx, \"AID in historical_bytes\", hist + 2, *(hist+1) & 0x0F);\n\n\tif (memcmp(hist + 2, OberthurIASECC_AID.value, *(hist+1) & 0x0F))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_RECORD_NOT_FOUND);\n\n\tif (!card->ef_atr)\n\t\tcard->ef_atr = calloc(1, sizeof(struct sc_ef_atr));\n\tif (!card->ef_atr)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(card->ef_atr->aid.value, OberthurIASECC_AID.value, OberthurIASECC_AID.len);\n\tcard->ef_atr->aid.len = OberthurIASECC_AID.len;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_oberthur(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tiasecc_parse_ef_atr(card);\n\n\t/* if we fail to select CM, */\n\tif (gp_select_card_manager(card)) {\n\t\tgp_select_isd_rid(card);\n\t}\n\n\trv = iasecc_oberthur_match(card);\n\tLOG_TEST_RET(ctx, rv, \"unknown Oberthur's IAS/ECC card\");\n\n\trv = iasecc_select_mf(card, NULL);\n\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\trv = iasecc_parse_ef_atr(card);\n\tLOG_TEST_RET(ctx, rv, \"EF.ATR read or parse error\");\n\n\tsc_log(ctx, \"EF.ATR(aid:'%s')\", sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len));\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_mi_match(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char resp[0x100];\n\tsize_t resp_len;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tresp_len = sizeof(resp);\n\trv = iasecc_select_aid(card, &MIIASECC_AID, resp, &resp_len);\n\tLOG_TEST_RET(ctx, rv, \"IASECC: failed to select MI IAS/ECC applet\");\n\n\tif (!card->ef_atr)\n\t\tcard->ef_atr = calloc(1, sizeof(struct sc_ef_atr));\n\tif (!card->ef_atr)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(card->ef_atr->aid.value, MIIASECC_AID.value, MIIASECC_AID.len);\n\tcard->ef_atr->aid.len = MIIASECC_AID.len;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *private_data = NULL;\n\tint rv = SC_ERROR_NO_CARD_SUPPORT;\n\n\tLOG_FUNC_CALLED(ctx);\n\tprivate_data = (struct iasecc_private_data *) calloc(1, sizeof(struct iasecc_private_data));\n\tif (private_data == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tcard->cla  = 0x00;\n\tcard->drv_data = private_data;\n\n\tif (card->type == SC_CARD_TYPE_IASECC_GEMALTO)\n\t\trv = iasecc_init_gemalto(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\trv = iasecc_init_oberthur(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_SAGEM)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_CARD);\n\n\n\tif (!rv)   {\n\t\tif (card->ef_atr && card->ef_atr->aid.len)   {\n\t\t\tstruct sc_path path;\n\n\t\t\tmemset(&path, 0, sizeof(struct sc_path));\n\t\t\tpath.type = SC_PATH_TYPE_DF_NAME;\n\t\t\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\t\t\tpath.len = card->ef_atr->aid.len;\n\n\t\t\trv = iasecc_select_file(card, &path, NULL);\n\t\t\tsc_log(ctx, \"Select ECC ROOT with the AID from EF.ATR: rv %i\", rv);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Select EF.ATR AID failed\");\n\t\t}\n\n\t\trv = iasecc_get_serialnr(card, NULL);\n\t}\n\n#ifdef ENABLE_SM\n\tcard->sm_ctx.ops.read_binary = _iasecc_sm_read_binary;\n\tcard->sm_ctx.ops.update_binary = _iasecc_sm_update_binary;\n#endif\n\n\tif (!rv) {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len));\n\t\trv = SC_ERROR_INVALID_CARD;\n\t}\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_read_binary(struct sc_card *card, unsigned int offs,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_read_binary(card:%p) offs %i; count %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, offs, count);\n\tif (offs > 0x7fff) {\n\t\tsc_log(ctx, \"invalid EF offset: 0x%X > 0x7FFF\", offs);\n\t\treturn SC_ERROR_OFFSET_TOO_LARGE;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, (offs >> 8) & 0x7F, offs & 0xFF);\n\tapdu.le = count < 0x100 ? count : 0x100;\n\tapdu.resplen = count;\n\tapdu.resp = buf;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_read_binary() failed\");\n\tsc_log(ctx,\n\t       \"iasecc_read_binary() apdu.resplen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       apdu.resplen);\n\n\tif (apdu.resplen == IASECC_READ_BINARY_LENGTH_MAX && apdu.resplen < count)   {\n\t\trv = iasecc_read_binary(card, offs + apdu.resplen, buf + apdu.resplen, count - apdu.resplen, flags);\n\t\tif (rv != SC_ERROR_WRONG_LENGTH)   {\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_read_binary() read tail failed\");\n\t\t\tapdu.resplen += rv;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\nstatic int\niasecc_erase_binary(struct sc_card *card, unsigned int offs, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char *tmp = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_erase_binary(card:%p) count %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, count);\n\tif (!count)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"'ERASE BINARY' failed: invalid size to erase\");\n\n\ttmp = malloc(count);\n\tif (!tmp)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot allocate temporary buffer\");\n\tmemset(tmp, 0xFF, count);\n\n\trv = sc_update_binary(card, offs, tmp, count, flags);\n\tfree(tmp);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_erase_binary() update binary error\");\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n#if ENABLE_SM\nstatic int\n_iasecc_sm_read_binary(struct sc_card *card, unsigned int offs,\n\t\tunsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tif (offs > 0x7fff)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OFFSET_TOO_LARGE, \"Invalid arguments\");\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_READ);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_read() 'READ' ACL not present\");\n\n\t\tsc_log(ctx, \"READ method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif ((entry->method == SC_AC_SCB) && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = (entry->method == SC_AC_SCB) ? (entry->key_ref & IASECC_SCB_METHOD_MASK_REF) : 0;\n\n\t\t\trv = iasecc_sm_read_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\n_iasecc_sm_update_binary(struct sc_card *card, unsigned int offs,\n\t\tconst unsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\n\tif (count == 0)\n\t\treturn SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_UPDATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_update() 'UPDATE' ACL not present\");\n\n\t\tsc_log(ctx, \"UPDATE method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = entry->method == SC_AC_SCB ? entry->key_ref & IASECC_SCB_METHOD_MASK_REF : 0;\n\n\t\t\trv = iasecc_sm_update_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n#endif\n\n\nstatic int\niasecc_emulate_fcp(struct sc_context *ctx, struct sc_apdu *apdu)\n{\n\tunsigned char dummy_df_fcp[] = {\n\t\t0x62,0xFF,\n\t\t\t0x82,0x01,0x38,\n\t\t\t0x8A,0x01,0x05,\n\t\t\t0xA1,0x04,0x8C,0x02,0x02,0x00,\n\t\t\t0x84,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (apdu->p1 != 0x04)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"FCP emulation supported only for the DF-NAME selection type\");\n\tif (apdu->datalen > 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid DF-NAME length\");\n\tif (apdu->resplen < apdu->datalen + 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"not enough space for FCP data\");\n\n\tmemcpy(dummy_df_fcp + 16, apdu->data, apdu->datalen);\n\tdummy_df_fcp[15] = apdu->datalen;\n\tdummy_df_fcp[1] = apdu->datalen + 14;\n\tmemcpy(apdu->resp, dummy_df_fcp, apdu->datalen + 16);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n/* TODO: redesign using of cache\n * TODO: do not keep intermediate results in 'file_out' argument */\nstatic int\niasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n\tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n\n\tsc_print_cache(card);\n\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n\n\t\trv = iasecc_select_mf(card, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {\n\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\t\tlpath.len -=  2;\n\t\t}\n\t}\n\n\tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t const unsigned char *buf, size_t buflen)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tsize_t taglen;\n\tint rv, ii, offs;\n\tconst unsigned char *acls = NULL, *tag = NULL;\n\tunsigned char mask;\n\tunsigned char ops_DF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_CREATE, 0xFF\n\t};\n\tunsigned char ops_EF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x6F, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x6F tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x62, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x62 tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\trv = iso_ops->process_fci(card, file, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");\n/*\n\tGemalto:  6F 19 80 02 02 ED 82 01 01 83 02 B0 01 88 00\t8C 07 7B 17 17 17 17 17 00 8A 01 05 90 00\n\tSagem:    6F 17 62 15 80 02 00 7D 82 01 01                   8C 02 01 00 83 02 2F 00 88 01 F0 8A 01 05 90 00\n\tOberthur: 62 1B 80 02 05 DC 82 01 01 83 02 B0 01 88 00 A1 09 8C 07 7B 17 FF 17 17 17 00 8A 01 05 90 00\n*/\n\n\tsc_log(ctx, \"iasecc_process_fci() type %i; let's parse file ACLs\", file->type);\n\ttag = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS, &taglen);\n\tif (tag)\n\t\tacls = sc_asn1_find_tag(ctx, tag, taglen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\telse\n\t\tacls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\n\tif (!acls)   {\n\t\tsc_log(ctx,\n\t\t       \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",\n\t\t       buflen, sc_dump_hex(buf, buflen));\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");\n\t}\n\n\tsc_log(ctx, \"ACLs(%\"SC_FORMAT_LEN_SIZE_T\"u) '%s'\", taglen,\n\t       sc_dump_hex(acls, taglen));\n\tmask = 0x40, offs = 1;\n\tfor (ii = 0; ii < 7; ii++, mask /= 2)  {\n\t\tunsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];\n\n\t\tif (!(mask & acls[0]))\n\t\t\tcontinue;\n\n\t\tsc_log(ctx, \"ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);\n\t\tif (op == 0xFF)   {\n\t\t\t;\n\t\t}\n\t\telse if (acls[offs] == 0)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NONE, 0);\n\t\t}\n\t\telse if (acls[offs] == 0xFF)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\t\telse if ((acls[offs] & IASECC_SCB_METHOD_MASK) == IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SEN, acls[offs] & IASECC_SCB_METHOD_MASK_REF);\n\t\t}\n\t\telse if (acls[offs] & IASECC_SCB_METHOD_MASK)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SCB, acls[offs]);\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Warning: non supported SCB method: %X\", acls[offs]);\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\n\t\toffs++;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n\n\nstatic int\niasecc_fcp_encode(struct sc_card *card, struct sc_file *file, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char buf[0x80], type;\n\tunsigned char  ops[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ\n\t};\n\tunsigned char smbs[8];\n\tsize_t ii, offs = 0, amb, mask, nn_smb;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (file->type == SC_FILE_TYPE_DF)\n\t\ttype = IASECC_FCP_TYPE_DF;\n\telse\n\t\ttype = IASECC_FCP_TYPE_EF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_SIZE;\n\tbuf[offs++] = 2;\n\tbuf[offs++] = (file->size >> 8) & 0xFF;\n\tbuf[offs++] = file->size & 0xFF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_TYPE;\n\tbuf[offs++] = 1;\n\tbuf[offs++] = type;\n\n\tbuf[offs++] = IASECC_FCP_TAG_FID;\n\tbuf[offs++] = 2;\n\tbuf[offs++] = (file->id >> 8) & 0xFF;\n\tbuf[offs++] = file->id & 0xFF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_SFID;\n\tbuf[offs++] = 0;\n\n\tamb = 0, mask = 0x40, nn_smb = 0;\n\tfor (ii = 0; ii < sizeof(ops); ii++, mask >>= 1) {\n\t\tconst struct sc_acl_entry *entry;\n\n\t\tif (ops[ii]==0xFF)\n\t\t\tcontinue;\n\n\t\tentry = sc_file_get_acl_entry(file, ops[ii]);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\tsc_log(ctx, \"method %X; reference %X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_NEVER)\n\t\t\tcontinue;\n\t\telse if (entry->method == SC_AC_NONE)\n\t\t\tsmbs[nn_smb++] = 0x00;\n\t\telse if (entry->method == SC_AC_CHV)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_USER_AUTH;\n\t\telse if (entry->method == SC_AC_SEN)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_USER_AUTH;\n\t\telse if (entry->method == SC_AC_SCB)\n\t\t\tsmbs[nn_smb++] = entry->key_ref;\n\t\telse if (entry->method == SC_AC_PRO)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_SM;\n\t\telse\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Non supported AC method\");\n\n\t\tamb |= mask;\n\t\tsc_log(ctx,\n\t\t       \"%\"SC_FORMAT_LEN_SIZE_T\"u: AMB %\"SC_FORMAT_LEN_SIZE_T\"X; nn_smb %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       ii, amb, nn_smb);\n\t}\n\n\t/* TODO: Encode contactless ACLs and life cycle status for all IAS/ECC cards */\n\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM ||\n\t\t\tcard->type == SC_CARD_TYPE_IASECC_AMOS )  {\n\t\tunsigned char status = 0;\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS;\n\t\tbuf[offs++] = 2*(2 + 1 + nn_smb);\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACT;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\n\t\t/* Same ACLs for contactless */\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACTLESS;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\n\t\tif (file->status == SC_FILE_STATUS_ACTIVATED)\n\t\t\tstatus = 0x05;\n\t\telse if (file->status == SC_FILE_STATUS_CREATION)\n\t\t\tstatus = 0x01;\n\n\t\tif (status)   {\n\t\t\tbuf[offs++] = 0x8A;\n\t\t\tbuf[offs++] = 0x01;\n\t\t\tbuf[offs++] = status;\n\t\t}\n\t}\n\telse   {\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS;\n\t\tbuf[offs++] = 2 + 1 + nn_smb;\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACT;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\t}\n\n\tif (out)   {\n\t\tif (out_len < offs)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small to encode FCP\");\n\t\tmemcpy(out, buf, offs);\n\t}\n\n\tLOG_FUNC_RETURN(ctx, offs);\n}\n\n\nstatic int\niasecc_create_file(struct sc_card *card, struct sc_file *file)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tconst struct sc_acl_entry *entry = NULL;\n\tunsigned char sbuf[0x100];\n\tsize_t sbuf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\tif (file->type != SC_FILE_TYPE_WORKING_EF)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Creation of the file with of this type is not supported\");\n\n\tsbuf_len = iasecc_fcp_encode(card, file, sbuf + 2, sizeof(sbuf)-2);\n\tLOG_TEST_RET(ctx, sbuf_len, \"FCP encode error\");\n\n\tsbuf[0] = IASECC_FCP_TAG;\n\tsbuf[1] = sbuf_len;\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_df, SC_AC_OP_CREATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_create_file() 'CREATE' ACL not present\");\n\n\t\tsc_log(ctx, \"iasecc_create_file() 'CREATE' method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tsc_log(ctx, \"iasecc_create_file() create data: '%s'\", sc_dump_hex(sbuf, sbuf_len + 2));\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n                        rv = iasecc_sm_create_file(card, entry->key_ref & IASECC_SCB_METHOD_MASK_REF, sbuf, sbuf_len + 2);\n                        LOG_TEST_RET(ctx, rv, \"iasecc_create_file() SM create file error\");\n\n                        rv = iasecc_select_file(card, &file->path, NULL);\n                        LOG_FUNC_RETURN(ctx, rv);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0, 0);\n\tapdu.data = sbuf;\n\tapdu.datalen = sbuf_len + 2;\n\tapdu.lc = sbuf_len + 2;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_create_file() create file error\");\n\n\trv = iasecc_select_file(card, &file->path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select newly created file\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_logout(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path path;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!card->ef_atr || !card->ef_atr->aid.len)\n\t\treturn SC_SUCCESS;\n\n\tmemset(&path, 0, sizeof(struct sc_path));\n\tpath.type = SC_PATH_TYPE_DF_NAME;\n\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\tpath.len = card->ef_atr->aid.len;\n\n\trv = iasecc_select_file(card, &path, NULL);\n\tsc_log(ctx, \"Select ECC ROOT with the AID from EF.ATR: rv %i\", rv);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_finish(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *private_data = (struct iasecc_private_data *)card->drv_data;\n\tstruct iasecc_se_info *se_info = private_data->se_info, *next;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\twhile (se_info)   {\n\t\tsc_file_free(se_info->df);\n\t\tnext = se_info->next;\n\t\tfree(se_info);\n\t\tse_info = next;\n\t}\n\n\tfree(card->drv_data);\n\tcard->drv_data = NULL;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tstruct sc_apdu apdu;\n\tstruct sc_file *file = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\trv = iasecc_select_file(card, path, &file);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select file to delete\");\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\tif (!entry)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"Cannot delete file: no 'DELETE' acl\");\n\n\tsc_log(ctx, \"DELETE method/reference %X/%X\", entry->method, entry->key_ref);\n\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\tunsigned char se_num = (entry->method == SC_AC_SCB) ? (entry->key_ref & IASECC_SCB_METHOD_MASK_REF) : 0;\n\t\trv = iasecc_sm_delete_file(card, se_num, file->id);\n\t}\n\telse   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"Delete file failed\");\n\n\t\tif (card->cache.valid)\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\tcard->cache.current_ef = NULL;\n\t}\n\n\tsc_file_free(file);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_check_sw(struct sc_card *card, unsigned int sw1, unsigned int sw2)\n{\n\tif (sw1 == 0x62 && sw2 == 0x82)\n\t\treturn SC_SUCCESS;\n\n\treturn iso_ops->check_sw(card, sw1, sw2);\n}\n\n\nstatic unsigned\niasecc_get_algorithm(struct sc_context *ctx, const struct sc_security_env *env,\n\t\tunsigned operation, unsigned mechanism)\n{\n    const struct sc_supported_algo_info *info = NULL;\n    int ii;\n\n    if (!env)\n        return 0;\n\n    for (ii=0;ii<SC_MAX_SUPPORTED_ALGORITHMS && env->supported_algos[ii].reference; ii++)\n        if ((env->supported_algos[ii].operations & operation)\n\t\t\t&& (env->supported_algos[ii].mechanism == mechanism))\n            break;\n\n    if (ii < SC_MAX_SUPPORTED_ALGORITHMS && env->supported_algos[ii].reference)   {\n        info = &env->supported_algos[ii];\n        sc_log(ctx, \"found IAS/ECC algorithm %X:%X:%X:%X\",\n\t\t\tinfo->reference, info->mechanism, info->operations, info->algo_ref);\n    }\n    else   {\n        sc_log(ctx, \"cannot find IAS/ECC algorithm (operation:%X,mechanism:%X)\", operation, mechanism);\n    }\n\n    return info ? info->algo_ref : 0;\n}\n\n\nstatic int\niasecc_se_cache_info(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info *se_info = NULL, *si = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tse_info = calloc(1, sizeof(struct iasecc_se_info));\n\tif (!se_info)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"SE info allocation error\");\n\tmemcpy(se_info, se, sizeof(struct iasecc_se_info));\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tsc_file_dup(&se_info->df, card->cache.current_df);\n\t\tif (se_info->df == NULL)   {\n\t\t\tfree(se_info);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\t\t}\n\t}\n\n\trv = iasecc_docp_copy(ctx, &se->docp, &se_info->docp);\n\tif (rv < 0)   {\n\t\tfree(se_info->df);\n\t\tfree(se_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot make copy of DOCP\");\n\t}\n\n\tif (!prv->se_info)   {\n\t\tprv->se_info = se_info;\n\t}\n\telse    {\n\t\tfor (si = prv->se_info; si->next; si = si->next)\n\t\t\t;\n\t\tsi->next = se_info;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_se_get_info_from_cache(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info *si = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(si = prv->se_info; si; si = si->next)   {\n\t\tif (si->reference != se->reference)\n\t\t\tcontinue;\n\t\tif (!(card->cache.valid && card->cache.current_df) && si->df)\n\t\t\tcontinue;\n\t\tif (card->cache.valid && card->cache.current_df && !si->df)\n\t\t\tcontinue;\n\t\tif (card->cache.valid && card->cache.current_df && si->df)\n\t\t\tif (memcmp(&card->cache.current_df->path, &si->df->path, sizeof(struct sc_path)))\n\t\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (!si)\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\n\tmemcpy(se, si, sizeof(struct iasecc_se_info));\n\n\tif (si->df)   {\n\t\tsc_file_dup(&se->df, si->df);\n\t\tif (se->df == NULL)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\t}\n\n\trv = iasecc_docp_copy(ctx, &si->docp, &se->docp);\n\tLOG_TEST_RET(ctx, rv, \"Cannot make copy of DOCP\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nint\niasecc_se_get_info(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[0x100];\n\tunsigned char sbuf_iasecc[10] = {\n\t\t0x4D, 0x08, IASECC_SDO_TEMPLATE_TAG, 0x06,\n\t\tIASECC_SDO_TAG_HEADER, IASECC_SDO_CLASS_SE | IASECC_OBJECT_REF_LOCAL,\n\t\tse->reference & 0x3F,\n\t\t0x02, IASECC_SDO_CLASS_SE, 0x80\n\t};\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (se->reference > IASECC_SE_REF_MAX)\n                LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\trv = iasecc_se_get_info_from_cache(card, se);\n\tif (rv == SC_ERROR_OBJECT_NOT_FOUND)   {\n\t\tsc_log(ctx, \"No SE#%X info in cache, try to use 'GET DATA'\", se->reference);\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xCB, 0x3F, 0xFF);\n\t\tapdu.data = sbuf_iasecc;\n\t\tapdu.datalen = sizeof(sbuf_iasecc);\n\t\tapdu.lc = apdu.datalen;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = sizeof(rbuf);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"get SE data  error\");\n\n\t\trv = iasecc_se_parse(card, apdu.resp, apdu.resplen, se);\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse SE data\");\n\n\t\trv = iasecc_se_cache_info(card, se);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to put SE data into cache\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo sdo;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tunsigned algo_ref;\n\tstruct sc_apdu apdu;\n\tunsigned sign_meth, sign_ref, auth_meth, auth_ref, aflags;\n\tunsigned char cse_crt_at[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, IASECC_ALGORITHM_RSA_PKCS\n\t};\n\tunsigned char cse_crt_dst[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1)\n\t};\n\tunsigned char cse_crt_ht[] = {\n\t\t0x80, 0x01, IASECC_ALGORITHM_SHA1\n\t};\n\tunsigned char cse_crt_ct[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1)\n\t};\n\tint rv, operation = env->operation;\n\n\t/* TODO: take algorithm references from 5032, not from header file. */\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_set_security_env(card:%p) operation 0x%X; senv.algorithm 0x%X, senv.algorithm_ref 0x%X\",\n\t\t\tcard, env->operation, env->algorithm, env->algorithm_ref);\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_RSA_PRIVATE;\n\tsdo.sdo_ref  = env->key_ref[0] & ~IASECC_OBJECT_REF_LOCAL;\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get RSA PRIVATE SDO data\");\n\n\t/* To made by iasecc_sdo_convert_to_file() */\n\tprv->key_size = *(sdo.docp.size.value + 0) * 0x100 + *(sdo.docp.size.value + 1);\n\tsc_log(ctx, \"prv->key_size 0x%\"SC_FORMAT_LEN_SIZE_T\"X\", prv->key_size);\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_COMPUTE_SIGNATURE, &sign_meth, &sign_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_SIGN acl\");\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_INTERNAL_AUTHENTICATE, &auth_meth, &auth_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_INT_AUTH acl\");\n\n\taflags = env->algorithm_flags;\n\n\tif (!(aflags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Only supported signature with PKCS1 padding\");\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tif (!(aflags & (SC_ALGORITHM_RSA_HASH_SHA1 | SC_ALGORITHM_RSA_HASH_SHA256)))   {\n\t\t\tsc_log(ctx, \"CKM_RSA_PKCS asked -- use 'AUTHENTICATE' sign operation instead of 'SIGN'\");\n\t\t\toperation = SC_SEC_OPERATION_AUTHENTICATE;\n\t\t}\n\t\telse if (sign_meth == SC_AC_NEVER)   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PSO_DST not allowed for this key\");\n\t\t}\n\t}\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tprv->op_method = sign_meth;\n\t\tprv->op_ref = sign_ref;\n\t}\n\telse if (operation == SC_SEC_OPERATION_AUTHENTICATE)   {\n\t\tif (auth_meth == SC_AC_NEVER)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"INTERNAL_AUTHENTICATE is not allowed for this key\");\n\n\t\tprv->op_method = auth_meth;\n\t\tprv->op_ref = auth_ref;\n\t}\n\n\tsc_log(ctx, \"senv.algorithm 0x%X, senv.algorithm_ref 0x%X\", env->algorithm, env->algorithm_ref);\n\tsc_log(ctx,\n\t       \"se_num %i, operation 0x%X, algorithm 0x%X, algorithm_ref 0x%X, flags 0x%X; key size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       se_num, operation, env->algorithm, env->algorithm_ref,\n\t       env->algorithm_flags, prv->key_size);\n\tswitch (operation)  {\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tif (!(env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_PKCS1 specified\");\n\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA256)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH, CKM_SHA256);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA256\");\n\n\t\t\tcse_crt_ht[2] = algo_ref; /* IASECC_ALGORITHM_SHA2 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA256_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA2 */\n\t\t}\n\t\telse if (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH,  CKM_SHA_1);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA1\");\n\n\t\t\tcse_crt_ht[2] = algo_ref;\t/* IASECC_ALGORITHM_SHA1 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA1_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1 */\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_HASH_SHA[1,256] specified\");\n\t\t}\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_HT);\n\t\tapdu.data = cse_crt_ht;\n\t\tapdu.datalen = sizeof(cse_crt_ht);\n\t\tapdu.lc = sizeof(cse_crt_ht);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_DST);\n\t\tapdu.data = cse_crt_dst;\n\t\tapdu.datalen = sizeof(cse_crt_dst);\n\t\tapdu.lc = sizeof(cse_crt_dst);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_AUTHENTICATE:\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports SIGNATURE:RSA_PKCS\");\n\n\t\tcse_crt_at[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_at[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_AT);\n\t\tapdu.data = cse_crt_at;\n\t\tapdu.datalen = sizeof(cse_crt_at);\n\t\tapdu.lc = sizeof(cse_crt_at);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_DECRYPT, &prv->op_method, &prv->op_ref);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_PSO_DECRYPT acl\");\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_DECIPHER,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports DECIPHER:RSA_PKCS\");\n\n\t\tcse_crt_ct[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_ct[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1 */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_CT);\n\t\tapdu.data = cse_crt_ct;\n\t\tapdu.datalen = sizeof(cse_crt_ct);\n\t\tapdu.lc = sizeof(cse_crt_ct);\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\tprv->security_env = *env;\n\tprv->security_env.operation = operation;\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n\n\nstatic int\niasecc_chv_verify_pinpad(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char buffer[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"CHV PINPAD PIN reference %i\", pin_cmd->pin_reference);\n\n\trv = iasecc_pin_is_verified(card, pin_cmd, tries_left);\n\tif (!rv)\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\t/* When PIN stored length available\n\t *     P10 verify data contains full template of 'VERIFY PIN' APDU.\n\t * Without PIN stored length\n\t *     pin-pad has to set the Lc and fill PIN data itself.\n\t *     Not all pin-pads support this case\n\t */\n\tpin_cmd->pin1.len = pin_cmd->pin1.stored_length;\n\tpin_cmd->pin1.length_offset = 5;\n\n\tmemset(buffer, 0xFF, sizeof(buffer));\n\tpin_cmd->pin1.data = buffer;\n\n\tpin_cmd->cmd = SC_PIN_CMD_VERIFY;\n\tpin_cmd->flags |= SC_PIN_CMD_USE_PINPAD;\n\n\t/*\n\tif (card->reader && card->reader->ops && card->reader->ops->load_message) {\n\t\trv = card->reader->ops->load_message(card->reader, card->slot, 0, \"Here we are!\");\n\t\tsc_log(ctx, \"Load message returned %i\", rv);\n\t}\n\t*/\n\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tsc_log(ctx, \"rv %i\", rv);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_acl_entry acl = pin_cmd->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tstruct sc_apdu apdu;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,acl:%X:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t\t\tacl.method, acl.key_ref);\n\n\tif (acl.method & IASECC_SCB_METHOD_SM)   {\n\t\trv = iasecc_sm_pin_verify(card, acl.key_ref, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\n\tif (pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_cmd->pin_reference);\n\t}\n\telse if (pin_cmd->pin1.data && pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20, 0, pin_cmd->pin_reference);\n\t\tapdu.data = pin_cmd->pin1.data;\n\t\tapdu.datalen = pin_cmd->pin1.len;\n\t\tapdu.lc = pin_cmd->pin1.len;\n\t}\n\telse if ((card->reader->capabilities & SC_READER_CAP_PIN_PAD) && !pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\trv = iasecc_chv_verify_pinpad(card, pin_cmd, tries_left);\n\t\tsc_log(ctx, \"Result of verifying CHV with PIN pad %i\", rv);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_se_at_to_chv_reference(struct sc_card *card, unsigned reference,\n\t\tunsigned *chv_reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info se;\n\tstruct sc_crt crt;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"SE reference %i\", reference);\n\n\tif (reference > IASECC_SE_REF_MAX)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tmemset(&se, 0, sizeof(se));\n\tse.reference = reference;\n\n\trv = iasecc_se_get_info(card, &se);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\tmemset(&crt, 0, sizeof(crt));\n\tcrt.tag = IASECC_CRT_TAG_AT;\n\tcrt.usage = IASECC_UQB_AT_USER_PASSWORD;\n\n\trv = iasecc_se_get_crt(card, &se, &crt);\n\tLOG_TEST_RET(ctx, rv, \"no authentication template for USER PASSWORD\");\n\n\tif (chv_reference)\n\t\t*chv_reference = crt.refs[0];\n\n\tsc_file_free(se.df);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd_data,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n        struct sc_acl_entry acl = pin_cmd_data->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tint rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (pin_cmd_data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for the verification\");\n\n\tsc_log(ctx, \"Verify ACL(method:%X;ref:%X)\", acl.method, acl.key_ref);\n\tif (acl.method != IASECC_SCB_ALWAYS)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_SECURITY_STATUS_NOT_SATISFIED);\n\n\tpin_cmd = *pin_cmd_data;\n\tpin_cmd.pin1.data = (unsigned char *)\"\";\n\tpin_cmd.pin1.len = 0;\n\n\trv = iasecc_chv_verify(card, &pin_cmd, tries_left);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_verify(struct sc_card *card, unsigned type, unsigned reference,\n\t\tconst unsigned char *data, size_t data_len, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned chv_ref = reference;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"Verify PIN(type:%X,ref:%i,data(len:%\"SC_FORMAT_LEN_SIZE_T\"u,%p)\",\n\t       type, reference, data_len, data);\n\n\tif (type == SC_AC_AUT)   {\n\t\trv =  iasecc_sm_external_authentication(card, reference, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse if (type == SC_AC_SCB)   {\n\t\tif (reference & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\ttype = SC_AC_SEN;\n\t\t\treference = reference & IASECC_SCB_METHOD_MASK_REF;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Do not try to verify non CHV PINs\");\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t}\n\t}\n\n\tif (type == SC_AC_SEN)   {\n\t\trv = iasecc_se_at_to_chv_reference(card, reference,  &chv_ref);\n\t\tLOG_TEST_RET(ctx, rv, \"SE AT to CHV reference error\");\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = chv_ref;\n\tpin_cmd.cmd = SC_PIN_CMD_VERIFY;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\tpin_cmd.pin1.data = data;\n\tpin_cmd.pin1.len = data_len;\n\n\trv = iasecc_pin_is_verified(card, &pin_cmd, tries_left);\n\tif (data && !data_len)\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\n\tif (!rv)   {\n\t\tif (iasecc_chv_cache_is_verified(card, &pin_cmd))\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\telse if (rv != SC_ERROR_PIN_CODE_INCORRECT && rv != SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\n\tiasecc_chv_cache_clean(card, &pin_cmd);\n\n\trv = iasecc_chv_verify(card, &pin_cmd, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"PIN CHV verification error\");\n\n\trv = iasecc_chv_cache_verified(card, &pin_cmd);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_chv_change_pinpad(struct sc_card *card, unsigned reference, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned char pin1_data[0x100], pin2_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"CHV PINPAD PIN reference %i\", reference);\n\n\tmemset(pin1_data, 0xFF, sizeof(pin1_data));\n\tmemset(pin2_data, 0xFF, sizeof(pin2_data));\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = reference;\n\tpin_cmd.cmd = SC_PIN_CMD_CHANGE;\n\tpin_cmd.flags |= SC_PIN_CMD_USE_PINPAD;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\t/* Some pin-pads do not support mode with Lc=0.\n\t * Give them a chance to work with some cards.\n\t */\n\tif ((pin_cmd.pin1.min_length == pin_cmd.pin1.stored_length) && (pin_cmd.pin1.max_length == pin_cmd.pin1.min_length))\n\t\tpin_cmd.pin1.len = pin_cmd.pin1.stored_length;\n\telse\n\t\tpin_cmd.pin1.len = 0;\n\n\tpin_cmd.pin1.length_offset = 5;\n\tpin_cmd.pin1.data = pin1_data;\n\n\tmemcpy(&pin_cmd.pin2, &pin_cmd.pin1, sizeof(pin_cmd.pin1));\n\tpin_cmd.pin2.data = pin2_data;\n\n\tsc_log(ctx,\n\t       \"PIN1 max/min/stored: %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       pin_cmd.pin1.max_length, pin_cmd.pin1.min_length,\n\t       pin_cmd.pin1.stored_length);\n\tsc_log(ctx,\n\t       \"PIN2 max/min/stored: %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       pin_cmd.pin2.max_length, pin_cmd.pin2.min_length,\n\t       pin_cmd.pin2.stored_length);\n\trv = iso_ops->pin_cmd(card, &pin_cmd, tries_left);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n#if 0\nstatic int\niasecc_chv_set_pinpad(struct sc_card *card, unsigned char reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned char pin_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Set CHV PINPAD PIN reference %i\", reference);\n\n\tmemset(pin_data, 0xFF, sizeof(pin_data));\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = reference;\n\tpin_cmd.cmd = SC_PIN_CMD_UNBLOCK;\n\tpin_cmd.flags |= SC_PIN_CMD_USE_PINPAD;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\tif ((pin_cmd.pin1.min_length == pin_cmd.pin1.stored_length) && (pin_cmd.pin1.max_length == pin_cmd.pin1.min_length))\n\t\tpin_cmd.pin1.len = pin_cmd.pin1.stored_length;\n\telse\n\t\tpin_cmd.pin1.len = 0;\n\n\tpin_cmd.pin1.length_offset = 5;\n\tpin_cmd.pin1.data = pin_data;\n\n\tmemcpy(&pin_cmd.pin2, &pin_cmd.pin1, sizeof(pin_cmd.pin1));\n\tmemset(&pin_cmd.pin1, 0, sizeof(pin_cmd.pin1));\n\tpin_cmd.flags |= SC_PIN_CMD_IMPLICIT_CHANGE;\n\n\tsc_log(ctx, \"PIN1(max:%i,min:%i)\", pin_cmd.pin1.max_length, pin_cmd.pin1.min_length);\n\tsc_log(ctx, \"PIN2(max:%i,min:%i)\", pin_cmd.pin2.max_length, pin_cmd.pin2.min_length);\n\n\trv = iso_ops->pin_cmd(card, &pin_cmd, NULL);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n#endif\n\n\nstatic int\niasecc_pin_get_policy (struct sc_card *card, struct sc_pin_cmd_data *data)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *save_current_df = NULL, *save_current_ef = NULL;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_path path;\n\tunsigned ii;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_pin_get_policy(card:%p)\", card);\n\n\tif (data->pin_type != SC_AC_CHV)   {\n\t\tsc_log(ctx, \"To unblock PIN it's CHV reference should be presented\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tsc_file_dup(&save_current_df, card->cache.current_df);\n\t\tif (save_current_df == NULL) {\n\t\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tsc_log(ctx, \"Cannot duplicate current DF file\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tsc_file_dup(&save_current_ef, card->cache.current_ef);\n\t\tif (save_current_ef == NULL) {\n\t\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tsc_log(ctx, \"Cannot duplicate current EF file\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!(data->pin_reference & IASECC_OBJECT_REF_LOCAL) && card->cache.valid && card->cache.current_df) {\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\t\trv = iasecc_select_file(card, &path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Unable to select MF\");\n\t}\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_CHV;\n\n\tsdo.sdo_ref = data->pin_reference & ~IASECC_OBJECT_REF_LOCAL;\n\n\tsc_log(ctx, \"iasecc_pin_get_policy() reference %i\", sdo.sdo_ref);\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot get SDO PIN data\");\n\n\tif (sdo.docp.acls_contact.size == 0) {\n\t\trv = SC_ERROR_INVALID_DATA;\n\t\tsc_log(ctx, \"Extremely strange ... there is no ACLs\");\n\t\tgoto err;\n\t}\n\n\tsc_log(ctx,\n\t       \"iasecc_pin_get_policy() sdo.docp.size.size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       sdo.docp.size.size);\n\tfor (ii=0; ii<sizeof(sdo.docp.scbs); ii++)   {\n\t\tstruct iasecc_se_info se;\n\t\tunsigned char scb = sdo.docp.scbs[ii];\n\t\tstruct sc_acl_entry *acl = &data->pin1.acls[ii];\n\t\tint crt_num = 0;\n\n\t\tmemset(&se, 0, sizeof(se));\n\t\tmemset(&acl->crts, 0, sizeof(acl->crts));\n\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() set info acls: SCB 0x%X\", scb);\n\t\t/* acl->raw_value = scb; */\n\t\tacl->method = scb & IASECC_SCB_METHOD_MASK;\n\t\tacl->key_ref = scb & IASECC_SCB_METHOD_MASK_REF;\n\n\t\tif (scb==0 || scb==0xFF)\n\t\t\tcontinue;\n\n\t\tif (se.reference != (int)acl->key_ref)   {\n\t\t\tmemset(&se, 0, sizeof(se));\n\n\t\t\tse.reference = acl->key_ref;\n\n\t\t\trv = iasecc_se_get_info(card, &se);\n\t\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"SDO get data error\");\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\trv = iasecc_se_get_crt_by_usage(card, &se,\n\t\t\t\t\tIASECC_CRT_TAG_AT, IASECC_UQB_AT_USER_PASSWORD, &acl->crts[crt_num]);\n\t\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"no authentication template for 'USER PASSWORD'\");\n\t\t\tsc_log(ctx, \"iasecc_pin_get_policy() scb:0x%X; sdo_ref:[%i,%i,...]\",\n\t\t\t\t\tscb, acl->crts[crt_num].refs[0], acl->crts[crt_num].refs[1]);\n\t\t\tcrt_num++;\n\t\t}\n\n\t\tif (scb & (IASECC_SCB_METHOD_SM | IASECC_SCB_METHOD_EXT_AUTH))   {\n\t\t\tsc_log(ctx, \"'SM' and 'EXTERNAL AUTHENTICATION' protection methods are not supported: SCB:0x%X\", scb);\n\t\t\t/* Set to 'NEVER' if all conditions are needed or\n\t\t\t * there is no user authentication method allowed */\n\t\t\tif (!crt_num || (scb & IASECC_SCB_METHOD_NEED_ALL))\n\t\t\t\tacl->method = SC_AC_NEVER;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc_file_free(se.df);\n\t}\n\n\tif (sdo.data.chv.size_max.value)\n\t\tdata->pin1.max_length = *sdo.data.chv.size_max.value;\n\tif (sdo.data.chv.size_min.value)\n\t\tdata->pin1.min_length = *sdo.data.chv.size_min.value;\n\tif (sdo.docp.tries_maximum.value)\n\t\tdata->pin1.max_tries = *sdo.docp.tries_maximum.value;\n\tif (sdo.docp.tries_remaining.value)\n\t\tdata->pin1.tries_left = *sdo.docp.tries_remaining.value;\n\tif (sdo.docp.size.value)   {\n\t\tfor (ii=0; ii<sdo.docp.size.size; ii++)\n\t\t\tdata->pin1.stored_length = ((data->pin1.stored_length) << 8) + *(sdo.docp.size.value + ii);\n\t}\n\n\tdata->pin1.encoding = SC_PIN_ENCODING_ASCII;\n\tdata->pin1.offset = 5;\n\tdata->pin1.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tsc_log(ctx,\n\t       \"PIN policy: size max/min %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u, tries max/left %i/%i\",\n\t       data->pin1.max_length, data->pin1.min_length,\n\t       data->pin1.max_tries, data->pin1.tries_left);\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tif (save_current_df)   {\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() restore current DF\");\n\t\trv = iasecc_select_file(card, &save_current_df->path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot return to saved DF\");\n\t}\n\n\tif (save_current_ef)   {\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() restore current EF\");\n\t\trv = iasecc_select_file(card, &save_current_ef->path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot return to saved EF\");\n\t}\n\nerr:\n\tsc_file_free(save_current_df);\n\tsc_file_free(save_current_ef);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_keyset_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_sdo sdo;\n\tunsigned scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change keyset(ref:%i,lengths:%i)\", data->pin_reference, data->pin2.len);\n\tif (!data->pin2.data || data->pin2.len < 32)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Needs at least 32 bytes for a new keyset value\");\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_KEYSET;\n\tsdo.sdo_ref  = data->pin_reference;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get keyset data\");\n\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\tscb = sdo.docp.scbs[IASECC_ACLS_KEYSET_PUT_DATA];\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tsc_log(ctx, \"SCB:0x%X\", scb);\n\tif (!(scb & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Other then protected by SM, the keyset change is not supported\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo.sdo_class;\n\tupdate.sdo_ref = sdo.sdo_ref;\n\n\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[0].tag = IASECC_SDO_KEYSET_TAG_MAC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[0].value = (unsigned char *) data->pin2.data;\n\tupdate.fields[0].size = 16;\n\n\tupdate.fields[1].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[1].tag = IASECC_SDO_KEYSET_TAG_ENC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[1].value = (unsigned char *) data->pin2.data + 16;\n\tupdate.fields[1].size = 16;\n\n\trv = iasecc_sm_sdo_update(card, (scb & IASECC_SCB_METHOD_MASK_REF), &update);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned reference = data->pin_reference;\n\tunsigned char pin_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change PIN(ref:%i,type:0x%X,lengths:%i/%i)\", reference, data->pin_type, data->pin1.len, data->pin2.len);\n\n\tif ((card->reader->capabilities & SC_READER_CAP_PIN_PAD))   {\n\t\tif (!data->pin1.data && !data->pin1.len && !data->pin2.data && !data->pin2.len)   {\n\t\t\trv = iasecc_chv_change_pinpad(card, reference, tries_left);\n\t\t\tsc_log(ctx, \"iasecc_pin_cmd(SC_PIN_CMD_CHANGE) chv_change_pinpad returned %i\", rv);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tif (!data->pin1.data && data->pin1.len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid PIN1 arguments\");\n\n\tif (!data->pin2.data && data->pin2.len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid PIN2 arguments\");\n\n\trv = iasecc_pin_verify(card, data->pin_type, reference, data->pin1.data, data->pin1.len, tries_left);\n\tsc_log(ctx, \"iasecc_pin_cmd(SC_PIN_CMD_CHANGE) pin_verify returned %i\", rv);\n\tLOG_TEST_RET(ctx, rv, \"PIN verification error\");\n\n\tif ((unsigned)(data->pin1.len + data->pin2.len) > sizeof(pin_data))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small for the 'Change PIN' data\");\n\n\tif (data->pin1.data)\n\t\tmemcpy(pin_data, data->pin1.data, data->pin1.len);\n\tif (data->pin2.data)\n\t\tmemcpy(pin_data + data->pin1.len, data->pin2.data, data->pin2.len);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x24, 0, reference);\n\tapdu.data = pin_data;\n\tapdu.datalen = data->pin1.len + data->pin2.len;\n\tapdu.lc = apdu.datalen;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_reset(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *save_current = NULL;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_apdu apdu;\n\tunsigned reference, scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Reset PIN(ref:%i,lengths:%i/%i)\", data->pin_reference, data->pin1.len, data->pin2.len);\n\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Unblock procedure can be used only with the PINs of type CHV\");\n\n\treference = data->pin_reference;\n\n\tif (!(data->pin_reference & IASECC_OBJECT_REF_LOCAL) && card->cache.valid && card->cache.current_df)  {\n\t\tstruct sc_path path;\n\n\t\tsc_file_dup(&save_current, card->cache.current_df);\n\t\tif (save_current == NULL)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\t\trv = iasecc_select_file(card, &path, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"Unable to select MF\");\n\t}\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_CHV;\n\tsdo.sdo_ref = reference & ~IASECC_OBJECT_REF_LOCAL;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get PIN data\");\n\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Extremely strange ... there are no ACLs\");\n\n\tscb = sdo.docp.scbs[IASECC_ACLS_CHV_RESET];\n\tdo   {\n\t\tunsigned need_all = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\t\tunsigned char se_num = scb & IASECC_SCB_METHOD_MASK_REF;\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\tsc_log(ctx, \"Verify PIN in SE %X\", se_num);\n\t\t\trv = iasecc_pin_verify(card, SC_AC_SEN, se_num, data->pin1.data, data->pin1.len, tries_left);\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_pin_reset() verify PUK error\");\n\n\t\t\tif (!need_all)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n\t\t\trv = iasecc_sm_pin_reset(card, se_num, data);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)   {\n\t\t\trv =  iasecc_sm_external_authentication(card, reference, tries_left);\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_pin_reset() external authentication error\");\n\t\t}\n\t} while(0);\n\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tif (data->pin2.len)   {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value\", reference);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2C, 0x02, reference);\n\t\tapdu.data = data->pin2.data;\n\t\tapdu.datalen = data->pin2.len;\n\t\tapdu.lc = apdu.datalen;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse if (data->pin2.data) {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value\", reference);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x2C, 3, reference);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse   {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value with PIN-PAD\", reference);\n#if 0\n\t\trv = iasecc_chv_set_pinpad(card, reference);\n\t\tLOG_TEST_RET(ctx, rv, \"Reset PIN failed\");\n#else\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Reset retry counter with PIN PAD not supported \");\n#endif\n\t}\n\n\tif (save_current)   {\n\t\trv = iasecc_select_file(card, &save_current->path, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot return to saved PATH\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_cmd(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_pin_cmd() cmd 0x%X, PIN type 0x%X, PIN reference %i, PIN-1 %p:%i, PIN-2 %p:%i\",\n\t\t\tdata->cmd, data->pin_type, data->pin_reference,\n\t\t\tdata->pin1.data, data->pin1.len, data->pin2.data, data->pin2.len);\n\n\tswitch (data->cmd)   {\n\tcase SC_PIN_CMD_VERIFY:\n\t\trv = iasecc_pin_verify(card, data->pin_type, data->pin_reference, data->pin1.data, data->pin1.len, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_CHANGE:\n\t\tif (data->pin_type == SC_AC_AUT)\n\t\t\trv = iasecc_keyset_change(card, data, tries_left);\n\t\telse\n\t\t\trv = iasecc_pin_change(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_UNBLOCK:\n\t\trv = iasecc_pin_reset(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_GET_INFO:\n\t\trv = iasecc_pin_get_policy(card, data);\n\t\tbreak;\n\tdefault:\n\t\tsc_log(ctx, \"Other pin commands not supported yet: 0x%X\", data->cmd);\n\t\trv = SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_iin *iin = &card->serialnr.iin;\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[0xC0];\n\tsize_t ii, offs;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (card->serialnr.len)\n\t\tgoto end;\n\n\tmemset(&card->serialnr, 0, sizeof(card->serialnr));\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);\n\tapdu.le = sizeof(rbuf);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Get 'serial number' data failed\");\n\n\tif (rbuf[0] != ISO7812_PAN_SN_TAG)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"serial number parse error\");\n\n\tiin->mii = (rbuf[2] >> 4) & 0x0F;\n\n\tiin->country = 0;\n\tfor (ii=5; ii<8; ii++)   {\n\t\tiin->country *= 10;\n\t\tiin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;\n\t}\n\n\tiin->issuer_id = 0;\n\tfor (ii=8; ii<10; ii++)   {\n\t\tiin->issuer_id *= 10;\n\t\tiin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;\n\t}\n\n\toffs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;\n\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {\n\t\t/* 5A 0A 92 50 00 20 10 10 25 00 01 3F */\n\t\t/*            00 02 01 01 02 50 00 13  */\n\t\tfor (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)\n\t\t\t*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)\n\t\t\t\t+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;\n\t\tcard->serialnr.len = ii;\n\t}\n\telse   {\n\t\tfor (ii=0; ii < rbuf[1] - offs; ii++)\n\t\t\t*(card->serialnr.value + ii) = rbuf[ii + offs + 2];\n\t\tcard->serialnr.len = ii;\n\t}\n\n\tdo  {\n\t\tchar txt[0x200];\n\n\t\tfor (ii=0;ii<card->serialnr.len;ii++)\n\t\t\tsprintf(txt + ii*2, \"%02X\", *(card->serialnr.value + ii));\n\n\t\tsc_log(ctx, \"serial number '%s'; mii %i; country %i; issuer_id %li\", txt, iin->mii, iin->country, iin->issuer_id);\n\t} while(0);\n\nend:\n\tif (serial)\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_create(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char *data = NULL, sdo_class = sdo->sdo_class;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_extended_tlv *field = NULL;\n\tint rv = SC_ERROR_NOT_SUPPORTED, data_len;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (sdo->magic != SC_CARDCTL_IASECC_SDO_MAGIC)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO data\");\n\n\tsc_log(ctx, \"iasecc_sdo_create(card:%p) %02X%02X%02X\", card,\n\t\t\tIASECC_SDO_TAG_HEADER, sdo->sdo_class | 0x80, sdo->sdo_ref);\n\n\tdata_len = iasecc_sdo_encode_create(ctx, sdo, &data);\n\tLOG_TEST_RET(ctx, data_len, \"iasecc_sdo_create() cannot encode SDO create data\");\n\tsc_log(ctx, \"iasecc_sdo_create() create data(%i):%s\", data_len, sc_dump_hex(data, data_len));\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\tapdu.data = data;\n\tapdu.datalen = data_len;\n\tapdu.lc = data_len;\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_sdo_create() SDO put data error\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo->sdo_class;\n\tupdate.sdo_ref = sdo->sdo_ref;\n\n\tif (sdo_class == IASECC_SDO_CLASS_RSA_PRIVATE)   {\n\t\tupdate.fields[0] = sdo->data.prv_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PRVKEY_TAG;\n\t\tfield = &sdo->data.prv_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_RSA_PUBLIC)   {\n\t\tupdate.fields[0] = sdo->data.pub_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PUBKEY_TAG;\n\t\tfield = &sdo->data.pub_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_KEYSET)   {\n\t\tupdate.fields[0] = sdo->data.keyset.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\t\tfield = &sdo->data.keyset.compulsory;\n\t}\n\n\tif (update.fields[0].value && !update.fields[0].on_card)   {\n\t\trv = iasecc_sdo_put_data(card, &update);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update 'Compulsory usage' data\");\n\n\t\tif (field)\n\t\t\tfield->on_card = 1;\n\t}\n\n\tfree(data);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n/* Oberthur's specific */\nstatic int\niasecc_sdo_delete(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char data[6] = {\n\t\t0x70, 0x04, 0xBF, 0xFF, 0xFF, 0x00\n\t};\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (sdo->magic != SC_CARDCTL_IASECC_SDO_MAGIC)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO data\");\n\n\tdata[2] = IASECC_SDO_TAG_HEADER;\n\tdata[3] = sdo->sdo_class | 0x80;\n\tdata[4] = sdo->sdo_ref;\n\tsc_log(ctx, \"delete SDO %02X%02X%02X\", data[2], data[3], data[4]);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\tapdu.data = data;\n\tapdu.datalen = sizeof(data);\n\tapdu.lc = sizeof(data);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"delete SDO error\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_put_data(struct sc_card *card, struct iasecc_sdo_update *update)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint ii, rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (update->magic != SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO update data\");\n\n\tfor(ii=0; update->fields[ii].tag && ii < IASECC_SDO_TAGS_UPDATE_MAX; ii++)   {\n\t\tunsigned char *encoded = NULL;\n\t\tint encoded_len;\n\n\t\tencoded_len = iasecc_sdo_encode_update_field(ctx, update->sdo_class, update->sdo_ref,\n\t\t\t\t\t\t\t&update->fields[ii], &encoded);\n\t\tsc_log(ctx, \"iasecc_sdo_put_data() encode[%i]; tag %X; encoded_len %i\", ii, update->fields[ii].tag, encoded_len);\n\t\tLOG_TEST_RET(ctx, encoded_len, \"Cannot encode update data\");\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\t\tapdu.data = encoded;\n\t\tapdu.datalen = encoded_len;\n\t\tapdu.lc = encoded_len;\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"SDO put data error\");\n\n\t\tfree(encoded);\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_key_rsa_put_data(struct sc_card *card, struct iasecc_sdo_rsa_update *update)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (update->sdo_prv_key)   {\n\t\tsc_log(ctx, \"encode private rsa in %p\", &update->update_prv);\n\t\trv = iasecc_sdo_encode_rsa_update(card->ctx, update->sdo_prv_key, update->p15_rsa, &update->update_prv);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to encode update of RSA private key\");\n\t}\n\n\tif (update->sdo_pub_key)   {\n\t\tsc_log(ctx, \"encode public rsa in %p\", &update->update_pub);\n\t\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {\n\t\t\tif (update->sdo_pub_key->data.pub_key.cha.value)   {\n\t\t\t\tfree(update->sdo_pub_key->data.pub_key.cha.value);\n\t\t\t\tmemset(&update->sdo_pub_key->data.pub_key.cha, 0, sizeof(update->sdo_pub_key->data.pub_key.cha));\n\t\t\t}\n\t\t}\n\t\trv = iasecc_sdo_encode_rsa_update(card->ctx, update->sdo_pub_key, update->p15_rsa, &update->update_pub);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to encode update of RSA public key\");\n\t}\n\n\tif (update->sdo_prv_key)   {\n\t\tsc_log(ctx, \"reference of the private key to store: %X\", update->sdo_prv_key->sdo_ref);\n\n\t\tif (update->sdo_prv_key->docp.acls_contact.size == 0)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"extremely strange ... there are no ACLs\");\n\n\t\tscb = update->sdo_prv_key->docp.scbs[IASECC_ACLS_RSAKEY_PUT_DATA];\n\t\tsc_log(ctx, \"'UPDATE PRIVATE RSA' scb 0x%X\", scb);\n\n\t\tdo   {\n\t\t\tunsigned all_conditions = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\n\t\t\tif ((scb & IASECC_SCB_METHOD_USER_AUTH) && !all_conditions)\n\t\t\t\tbreak;\n\n\t\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\t\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n#ifdef ENABLE_SM\n\t\t\t\trv = iasecc_sm_rsa_update(card, scb & IASECC_SCB_METHOD_MASK_REF, update);\n\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n#else\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"built without support of Secure-Messaging\");\n#endif\n\t\t\t}\n\t\t} while(0);\n\n\t\trv = iasecc_sdo_put_data(card, &update->update_prv);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update of RSA private key\");\n\t}\n\n\tif (update->sdo_pub_key)   {\n\t\tsc_log(ctx, \"reference of the public key to store: %X\", update->sdo_pub_key->sdo_ref);\n\n\t\trv = iasecc_sdo_put_data(card, &update->update_pub);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update of RSA public key\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_tag_from_class(unsigned sdo_class)\n{\n\tswitch (sdo_class & ~IASECC_OBJECT_REF_LOCAL)   {\n\tcase IASECC_SDO_CLASS_CHV:\n\t\treturn IASECC_SDO_CHV_TAG;\n\tcase IASECC_SDO_CLASS_RSA_PRIVATE:\n\t\treturn IASECC_SDO_PRVKEY_TAG;\n\tcase IASECC_SDO_CLASS_RSA_PUBLIC:\n\t\treturn IASECC_SDO_PUBKEY_TAG;\n\tcase IASECC_SDO_CLASS_SE:\n\t\treturn IASECC_SDO_CLASS_SE;\n\tcase IASECC_SDO_CLASS_KEYSET:\n\t\treturn IASECC_SDO_KEYSET_TAG;\n\t}\n\n\treturn -1;\n}\n\n\nstatic int\niasecc_sdo_get_tagged_data(struct sc_card *card, int sdo_tag, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[0x100];\n\tsize_t offs = sizeof(sbuf) - 1;\n\tunsigned char rbuf[0x400];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tsbuf[offs--] = 0x80;\n\tsbuf[offs--] = sdo_tag & 0xFF;\n\tif ((sdo_tag >> 8) & 0xFF)\n\t\tsbuf[offs--] = (sdo_tag >> 8) & 0xFF;\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\n\tsbuf[offs--] = sdo->sdo_ref & 0x9F;\n\tsbuf[offs--] = sdo->sdo_class | IASECC_OBJECT_REF_LOCAL;\n\tsbuf[offs--] = IASECC_SDO_TAG_HEADER;\n\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\tsbuf[offs--] = IASECC_SDO_TEMPLATE_TAG;\n\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\tsbuf[offs] = 0x4D;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xCB, 0x3F, 0xFF);\n\tapdu.data = sbuf + offs;\n\tapdu.datalen = sizeof(sbuf) - offs;\n\tapdu.lc = sizeof(sbuf) - offs;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\trv = iasecc_sdo_parse(card, apdu.resp, apdu.resplen, sdo);\n\tLOG_TEST_RET(ctx, rv, \"cannot parse SDO data\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_get_data(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv, sdo_tag;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tsdo_tag = iasecc_sdo_tag_from_class(sdo->sdo_class);\n\n\trv = iasecc_sdo_get_tagged_data(card, sdo_tag, sdo);\n\t/* When there is no public data 'GET DATA' returns error */\n\tif (rv != SC_ERROR_INCORRECT_PARAMETERS)\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse ECC SDO data\");\n\n\trv = iasecc_sdo_get_tagged_data(card, IASECC_DOCP_TAG, sdo);\n\tLOG_TEST_RET(ctx, rv, \"cannot parse ECC DOCP data\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_generate(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update_pubkey;\n\tstruct sc_apdu apdu;\n\tunsigned char scb, sbuf[5], rbuf[0x400], exponent[3] = {0x01, 0x00, 0x01};\n\tint offs = 0, rv = SC_ERROR_NOT_SUPPORTED;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (sdo->sdo_class != IASECC_SDO_CLASS_RSA_PRIVATE)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"For a moment, only RSA_PRIVATE class can be accepted for the SDO generation\");\n\n\tif (sdo->docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\n\tscb = sdo->docp.scbs[IASECC_ACLS_RSAKEY_GENERATE];\n\tsc_log(ctx, \"'generate RSA key' SCB 0x%X\", scb);\n\tdo   {\n\t\tunsigned all_conditions = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)\n\t\t\tif (!all_conditions)\n\t\t\t\tbreak;\n\n\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n\t\t\trv = iasecc_sm_rsa_generate(card, scb & IASECC_SCB_METHOD_MASK_REF, sdo);\n                        LOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t} while(0);\n\n\tmemset(&update_pubkey, 0, sizeof(update_pubkey));\n\tupdate_pubkey.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate_pubkey.sdo_class = IASECC_SDO_CLASS_RSA_PUBLIC;\n\tupdate_pubkey.sdo_ref = sdo->sdo_ref;\n\n\tupdate_pubkey.fields[0].parent_tag = IASECC_SDO_PUBKEY_TAG;\n\tupdate_pubkey.fields[0].tag = IASECC_SDO_PUBKEY_TAG_E;\n\tupdate_pubkey.fields[0].value = exponent;\n\tupdate_pubkey.fields[0].size = sizeof(exponent);\n\n\trv = iasecc_sdo_put_data(card, &update_pubkey);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_sdo_generate() update SDO public key failed\");\n\n\toffs = 0;\n\tsbuf[offs++] = IASECC_SDO_TEMPLATE_TAG;\n\tsbuf[offs++] = 0x03;\n\tsbuf[offs++] = IASECC_SDO_TAG_HEADER;\n\tsbuf[offs++] = IASECC_SDO_CLASS_RSA_PRIVATE | IASECC_OBJECT_REF_LOCAL;\n\tsbuf[offs++] = sdo->sdo_ref & ~IASECC_OBJECT_REF_LOCAL;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x47, 0x00, 0x00);\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_get_chv_reference_from_se(struct sc_card *card, int *se_reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info se;\n\tstruct sc_crt crt;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!se_reference)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid arguments\");\n\n\tmemset(&se, 0, sizeof(se));\n\tse.reference = *se_reference;\n\n\trv = iasecc_se_get_info(card, &se);\n\tLOG_TEST_RET(ctx, rv, \"get SE info error\");\n\n\tmemset(&crt, 0, sizeof(crt));\n\tcrt.tag = IASECC_CRT_TAG_AT;\n\tcrt.usage = IASECC_UQB_AT_USER_PASSWORD;\n\n\trv = iasecc_se_get_crt(card, &se, &crt);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get 'USER PASSWORD' authentication template\");\n\n\tsc_file_free(se.df);\n\tLOG_FUNC_RETURN(ctx, crt.refs[0]);\n}\n\n\nstatic int\niasecc_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo *sdo = (struct iasecc_sdo *) ptr;\n\n\tswitch (cmd) {\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn iasecc_get_serialnr(card, (struct sc_serial_number *)ptr);\n\tcase SC_CARDCTL_IASECC_SDO_CREATE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_CREATE: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_create(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_DELETE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_DELETE: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_delete(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_PUT_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_PUT_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_put_data(card, (struct iasecc_sdo_update *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_KEY_RSA_PUT_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_KEY_RSA_PUT_DATA\");\n\t\treturn iasecc_sdo_key_rsa_put_data(card, (struct iasecc_sdo_rsa_update *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_GET_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_GET_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_get_data(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_GENERATE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_GET_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_generate(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_GET_SE_INFO:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_GET_SE_INFO: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_se_get_info(card, (struct iasecc_se_info *) ptr);\n\tcase SC_CARDCTL_GET_CHV_REFERENCE_IN_SE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_GET_CHV_REFERENCE_IN_SE\");\n\t\treturn iasecc_get_chv_reference_from_se(card, (int *)ptr);\n\tcase SC_CARDCTL_IASECC_GET_FREE_KEY_REFERENCE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_GET_FREE_KEY_REFERENCE\");\n\t\treturn iasecc_get_free_reference(card, (struct iasecc_ctl_get_free_reference *)ptr);\n\t}\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n\nstatic int\niasecc_decipher(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len,\n\t\tunsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[0x200];\n\tunsigned char resp[SC_MAX_APDU_BUFFER_SIZE];\n\tsize_t offs;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(card->ctx,\n\t       \"crgram_len %\"SC_FORMAT_LEN_SIZE_T\"u;  outlen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len, out_len);\n\tif (!out || !out_len || in_len > SC_MAX_APDU_BUFFER_SIZE)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\toffs = 0;\n\tsbuf[offs++] = 0x81;\n\tmemcpy(sbuf + offs, in, in_len);\n\toffs += in_len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\tapdu.resp = resp;\n\tapdu.resplen = sizeof(resp);\n\tapdu.le = 256;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Card returned error\");\n\n\tif (out_len > apdu.resplen)\n\t\tout_len = apdu.resplen;\n\n\tmemcpy(out, apdu.resp, out_len);\n\trv = out_len;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_qsign_data_sha1(struct sc_context *ctx, const unsigned char *in, size_t in_len,\n\t\t\t\tstruct iasecc_qsign_data *out)\n{\n\tSHA_CTX sha;\n\tSHA_LONG pre_hash_Nl, *hh[5] = {\n\t\t&sha.h0, &sha.h1, &sha.h2, &sha.h3, &sha.h4\n\t};\n\tint jj, ii;\n\tint hh_size = sizeof(SHA_LONG), hh_num = SHA_DIGEST_LENGTH / sizeof(SHA_LONG);\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!in || !in_len || !out)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx,\n\t       \"sc_pkcs15_get_qsign_data() input data length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tmemset(out, 0, sizeof(struct iasecc_qsign_data));\n\n\tSHA1_Init(&sha);\n\tSHA1_Update(&sha, in, in_len);\n\n\tfor (jj=0; jj<hh_num; jj++)\n\t\tfor(ii=0; ii<hh_size; ii++)\n\t\t\tout->pre_hash[jj*hh_size + ii] = ((*hh[jj] >> 8*(hh_size-1-ii)) & 0xFF);\n\tout->pre_hash_size = SHA_DIGEST_LENGTH;\n\tsc_log(ctx, \"Pre SHA1:%s\", sc_dump_hex(out->pre_hash, out->pre_hash_size));\n\n\tpre_hash_Nl = sha.Nl - (sha.Nl % (sizeof(sha.data) * 8));\n\tfor (ii=0; ii<hh_size; ii++)   {\n\t\tout->counter[ii] = (sha.Nh >> 8*(hh_size-1-ii)) &0xFF;\n\t\tout->counter[hh_size+ii] = (pre_hash_Nl >> 8*(hh_size-1-ii)) &0xFF;\n\t}\n\tfor (ii=0, out->counter_long=0; ii<(int)sizeof(out->counter); ii++)\n\t\tout->counter_long = out->counter_long*0x100 + out->counter[ii];\n\tsc_log(ctx, \"Pre counter(%li):%s\", out->counter_long, sc_dump_hex(out->counter, sizeof(out->counter)));\n\n\tif (sha.num)   {\n\t\tmemcpy(out->last_block, in + in_len - sha.num, sha.num);\n\t\tout->last_block_size = sha.num;\n\t\tsc_log(ctx, \"Last block(%\"SC_FORMAT_LEN_SIZE_T\"u):%s\",\n\t\t       out->last_block_size,\n\t\t       sc_dump_hex(out->last_block, out->last_block_size));\n\t}\n\n\tSHA1_Final(out->hash, &sha);\n\tout->hash_size = SHA_DIGEST_LENGTH;\n\tsc_log(ctx, \"Expected digest %s\\n\", sc_dump_hex(out->hash, out->hash_size));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n#if OPENSSL_VERSION_NUMBER >= 0x00908000L\nstatic int\niasecc_qsign_data_sha256(struct sc_context *ctx, const unsigned char *in, size_t in_len,\n\t\t\t\tstruct iasecc_qsign_data *out)\n{\n\tSHA256_CTX sha256;\n\tSHA_LONG pre_hash_Nl;\n\tint jj, ii;\n\tint hh_size = sizeof(SHA_LONG), hh_num = SHA256_DIGEST_LENGTH / sizeof(SHA_LONG);\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in || !in_len || !out)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx,\n\t       \"sc_pkcs15_get_qsign_data() input data length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tmemset(out, 0, sizeof(struct iasecc_qsign_data));\n\n\tSHA256_Init(&sha256);\n\tSHA256_Update(&sha256, in, in_len);\n\n\tfor (jj=0; jj<hh_num; jj++)\n\t\tfor(ii=0; ii<hh_size; ii++)\n\t\t\tout->pre_hash[jj*hh_size + ii] = ((sha256.h[jj] >> 8*(hh_size-1-ii)) & 0xFF);\n\tout->pre_hash_size = SHA256_DIGEST_LENGTH;\n\tsc_log(ctx, \"Pre hash:%s\", sc_dump_hex(out->pre_hash, out->pre_hash_size));\n\n\tpre_hash_Nl = sha256.Nl - (sha256.Nl % (sizeof(sha256.data) * 8));\n\tfor (ii=0; ii<hh_size; ii++)   {\n\t\tout->counter[ii] = (sha256.Nh >> 8*(hh_size-1-ii)) &0xFF;\n\t\tout->counter[hh_size+ii] = (pre_hash_Nl >> 8*(hh_size-1-ii)) &0xFF;\n\t}\n\tfor (ii=0, out->counter_long=0; ii<(int)sizeof(out->counter); ii++)\n\t\tout->counter_long = out->counter_long*0x100 + out->counter[ii];\n\tsc_log(ctx, \"Pre counter(%li):%s\", out->counter_long, sc_dump_hex(out->counter, sizeof(out->counter)));\n\n\tif (sha256.num)   {\n\t\tmemcpy(out->last_block, in + in_len - sha256.num, sha256.num);\n\t\tout->last_block_size = sha256.num;\n\t\tsc_log(ctx, \"Last block(%\"SC_FORMAT_LEN_SIZE_T\"u):%s\",\n\t\t       out->last_block_size,\n\t\t       sc_dump_hex(out->last_block, out->last_block_size));\n\t}\n\n\tSHA256_Final(out->hash, &sha256);\n\tout->hash_size = SHA256_DIGEST_LENGTH;\n\tsc_log(ctx, \"Expected digest %s\\n\", sc_dump_hex(out->hash, out->hash_size));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n#endif\n\n\nstatic int\niasecc_compute_signature_dst(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_security_env *env = &prv->security_env;\n\tstruct iasecc_qsign_data qsign_data;\n\tstruct sc_apdu apdu;\n\tsize_t offs = 0, hash_len = 0;\n\tunsigned char sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv = SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() input length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tif (env->operation != SC_SEC_OPERATION_SIGN)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"It's not SC_SEC_OPERATION_SIGN\");\n\telse if (!(prv->key_size & 0x1E0) || (prv->key_size & ~0x1E0))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid key size for SC_SEC_OPERATION_SIGN\");\n\n\tmemset(&qsign_data, 0, sizeof(qsign_data));\n\tif (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)   {\n\t\trv = iasecc_qsign_data_sha1(card->ctx, in, in_len, &qsign_data);\n\t}\n\telse if (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA256)   {\n#if OPENSSL_VERSION_NUMBER >= 0x00908000L\n\t\trv = iasecc_qsign_data_sha256(card->ctx, in, in_len, &qsign_data);\n#else\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"SHA256 is not supported by OpenSSL previous to v0.9.8\");\n#endif\n\t}\n\telse\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_HASH_SHA1 or RSA_HASH_SHA256 algorithm\");\n\tLOG_TEST_RET(ctx, rv, \"Cannot get QSign data\");\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() hash_len %\"SC_FORMAT_LEN_SIZE_T\"u; key_size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       hash_len, prv->key_size);\n\n\tmemset(sbuf, 0, sizeof(sbuf));\n\tsbuf[offs++] = 0x90;\n\tif (qsign_data.counter_long)   {\n\t\tsbuf[offs++] = qsign_data.hash_size + 8;\n\t\tmemcpy(sbuf + offs, qsign_data.pre_hash, qsign_data.pre_hash_size);\n\t\toffs += qsign_data.pre_hash_size;\n\t\tmemcpy(sbuf + offs, qsign_data.counter, sizeof(qsign_data.counter));\n\t\toffs += sizeof(qsign_data.counter);\n\t}\n\telse   {\n\t\tsbuf[offs++] = 0;\n\t}\n\n\tsbuf[offs++] = 0x80;\n\tsbuf[offs++] = qsign_data.last_block_size;\n\tmemcpy(sbuf + offs, qsign_data.last_block, qsign_data.last_block_size);\n\toffs += qsign_data.last_block_size;\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() offs %\"SC_FORMAT_LEN_SIZE_T\"u; OP(meth:%X,ref:%X)\",\n\t       offs, prv->op_method, prv->op_ref);\n\tif (prv->op_method == SC_AC_SCB && (prv->op_ref & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2A, 0x90, 0xA0);\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tsc_log(ctx, \"iasecc_compute_signature_dst() partial hash OK\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x2A, 0x9E, 0x9A);\n\tapdu.resp = rbuf;\n\tapdu.resplen = prv->key_size;\n\tapdu.le = prv->key_size;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() DST resplen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       apdu.resplen);\n\tif (apdu.resplen > out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Result buffer too small for the DST signature\");\n\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\nstatic int\niasecc_compute_signature_at(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_security_env *env = &prv->security_env;\n\tstruct sc_apdu apdu;\n\tsize_t offs = 0, sz = 0;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (env->operation != SC_SEC_OPERATION_AUTHENTICATE)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"It's not SC_SEC_OPERATION_AUTHENTICATE\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x88, 0x00, 0x00);\n\tapdu.datalen = in_len;\n\tapdu.data = in;\n\tapdu.lc = in_len;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tdo   {\n\t\tif (offs + apdu.resplen > out_len)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small to return signature\");\n\n\t\tmemcpy(out + offs, rbuf, apdu.resplen);\n\t\toffs += apdu.resplen;\n\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\t\tbreak;\n\n\t\tif (apdu.sw1 == 0x61)   {\n\t\t\tsz = apdu.sw2 == 0x00 ? 0x100 : apdu.sw2;\n\t\t\trv = iso_ops->get_response(card, &sz, rbuf);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get response error\");\n\n\t\t\tapdu.resplen = rv;\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"Impossible error: SW1 is not 0x90 neither 0x61\");\n\t\t}\n\n\t} while(rv > 0);\n\n\tLOG_FUNC_RETURN(ctx, offs);\n}\n\n\nstatic int\niasecc_compute_signature(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx;\n\tstruct iasecc_private_data *prv;\n\tstruct sc_security_env *env;\n\n\tif (!card || !in || !out)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tctx = card->ctx;\n\tprv = (struct iasecc_private_data *) card->drv_data;\n\tenv = &prv->security_env;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"inlen %\"SC_FORMAT_LEN_SIZE_T\"u, outlen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len, out_len);\n\n\tif (env->operation == SC_SEC_OPERATION_SIGN)\n\t\treturn iasecc_compute_signature_dst(card, in, in_len, out,  out_len);\n\telse if (env->operation == SC_SEC_OPERATION_AUTHENTICATE)\n\t\treturn iasecc_compute_signature_at(card, in, in_len, out,  out_len);\n\n\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\n\nstatic int\niasecc_read_public_key(struct sc_card *card, unsigned type,\n\t\tstruct sc_path *key_path, unsigned ref, unsigned size,\n\t\tunsigned char **out, size_t *out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_pkcs15_bignum bn[2];\n\tstruct sc_pkcs15_pubkey_rsa rsa_key;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (type != SC_ALGORITHM_RSA)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tsc_log(ctx, \"read public kay(ref:%i;size:%i)\", ref, size);\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_RSA_PUBLIC;\n\tsdo.sdo_ref  = ref & ~IASECC_OBJECT_REF_LOCAL;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"failed to read public key: cannot get RSA SDO data\");\n\n\tif (out)\n\t\t*out = NULL;\n\tif (out_len)\n\t\t*out_len = 0;\n\n\tbn[0].data = (unsigned char *) malloc(sdo.data.pub_key.n.size);\n\tif (!bn[0].data)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"failed to read public key: cannot allocate modulus\");\n\tbn[0].len = sdo.data.pub_key.n.size;\n\tmemcpy(bn[0].data, sdo.data.pub_key.n.value, sdo.data.pub_key.n.size);\n\n\tbn[1].data = (unsigned char *) malloc(sdo.data.pub_key.e.size);\n\tif (!bn[1].data)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"failed to read public key: cannot allocate exponent\");\n\tbn[1].len = sdo.data.pub_key.e.size;\n\tmemcpy(bn[1].data, sdo.data.pub_key.e.value, sdo.data.pub_key.e.size);\n\n\trsa_key.modulus = bn[0];\n\trsa_key.exponent = bn[1];\n\n\trv = sc_pkcs15_encode_pubkey_rsa(ctx, &rsa_key, out, out_len);\n\tLOG_TEST_RET(ctx, rv, \"failed to read public key: cannot encode RSA public key\");\n\n\tif (out && out_len)\n\t\tsc_log(ctx, \"encoded public key: %s\", sc_dump_hex(*out, *out_len));\n\n\tif (bn[0].data)\n\t\tfree(bn[0].data);\n\tif (bn[1].data)\n\t\tfree(bn[1].data);\n\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_get_free_reference(struct sc_card *card, struct iasecc_ctl_get_free_reference *ctl_data)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo *sdo = NULL;\n\tint idx, rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif ((ctl_data->key_size % 0x40) || ctl_data->index < 1 || (ctl_data->index > IASECC_OBJECT_REF_MAX))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx, \"get reference for key(index:%i,usage:%X,access:%X)\", ctl_data->index, ctl_data->usage, ctl_data->access);\n\t/* TODO: when looking for the slot for the signature keys, check also PSO_SIGNATURE ACL */\n\tfor (idx = ctl_data->index; idx <= IASECC_OBJECT_REF_MAX; idx++)   {\n\t\tunsigned char sdo_tag[3] = {\n\t\t\tIASECC_SDO_TAG_HEADER, IASECC_OBJECT_REF_LOCAL | IASECC_SDO_CLASS_RSA_PRIVATE, idx\n\t\t};\n\t\tsize_t sz;\n\n\t\tif (sdo)\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\trv = iasecc_sdo_allocate_and_parse(card, sdo_tag, 3, &sdo);\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse SDO data\");\n\n\t\trv = iasecc_sdo_get_data(card, sdo);\n\t\tif (rv == SC_ERROR_DATA_OBJECT_NOT_FOUND)   {\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\t\tsc_log(ctx, \"found empty key slot %i\", idx);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tLOG_TEST_RET(ctx, rv, \"get new key reference failed\");\n\n\t\tsz = *(sdo->docp.size.value + 0) * 0x100 + *(sdo->docp.size.value + 1);\n\t\tsc_log(ctx,\n\t\t       \"SDO(idx:%i) size %\"SC_FORMAT_LEN_SIZE_T\"u; key_size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       idx, sz, ctl_data->key_size);\n\n\t\tif (sz != ctl_data->key_size / 8)   {\n\t\t\tsc_log(ctx,\n\t\t\t       \"key index %i ignored: different key sizes %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       idx, sz, ctl_data->key_size / 8);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sdo->docp.non_repudiation.value)   {\n\t\t\tsc_log(ctx, \"non repudiation flag %X\", sdo->docp.non_repudiation.value[0]);\n\t\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && !(*sdo->docp.non_repudiation.value))   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: need non repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && *sdo->docp.non_repudiation.value)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: don't need non-repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->access & SC_PKCS15_PRKEY_ACCESS_LOCAL)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_GENERATE] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: GENERATE KEY not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PUT_DATA] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PUT DATA not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_SIGN] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO SIGN not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_INTERNAL_AUTH] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: INTERNAL AUTHENTICATE not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->usage & (SC_PKCS15_PRKEY_USAGE_DECRYPT | SC_PKCS15_PRKEY_USAGE_UNWRAP))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_DECIPHER] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO DECIPHER not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tctl_data->index = idx;\n\n\tif (idx > IASECC_OBJECT_REF_MAX)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic struct sc_card_driver *\nsc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (!iso_ops)\n\t\tiso_ops = iso_drv->ops;\n\n\tiasecc_ops = *iso_ops;\n\n\tiasecc_ops.match_card = iasecc_match_card;\n\tiasecc_ops.init = iasecc_init;\n\tiasecc_ops.finish = iasecc_finish;\n\tiasecc_ops.read_binary = iasecc_read_binary;\n\t/*\twrite_binary: ISO7816 implementation works\t*/\n\t/*\tupdate_binary: ISO7816 implementation works\t*/\n\tiasecc_ops.erase_binary = iasecc_erase_binary;\n\t/*\tresize_binary\t*/\n\t/* \tread_record: Untested\t*/\n\t/*\twrite_record: Untested\t*/\n\t/*\tappend_record: Untested\t*/\n\t/*\tupdate_record: Untested\t*/\n\tiasecc_ops.select_file = iasecc_select_file;\n\t/*\tget_response: Untested\t*/\n\t/*\tget_challenge: ISO7816 implementation works\t*/\n\tiasecc_ops.logout = iasecc_logout;\n\t/*\trestore_security_env\t*/\n\tiasecc_ops.set_security_env = iasecc_set_security_env;\n\tiasecc_ops.decipher = iasecc_decipher;\n\tiasecc_ops.compute_signature = iasecc_compute_signature;\n\tiasecc_ops.create_file = iasecc_create_file;\n\tiasecc_ops.delete_file = iasecc_delete_file;\n\t/*\tlist_files\t*/\n\tiasecc_ops.check_sw = iasecc_check_sw;\n\tiasecc_ops.card_ctl = iasecc_card_ctl;\n\tiasecc_ops.process_fci = iasecc_process_fci;\n\t/*\tconstruct_fci: Not needed\t*/\n\tiasecc_ops.pin_cmd = iasecc_pin_cmd;\n\t/*\tget_data: Not implemented\t*/\n\t/*\tput_data: Not implemented\t*/\n\t/*\tdelete_record: Not implemented\t*/\n\n\tiasecc_ops.read_public_key = iasecc_read_public_key;\n\n\treturn &iasecc_drv;\n}\n\nstruct sc_card_driver *\nsc_get_iasecc_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n#else\n\n/* we need to define the functions below to export them */\n#include \"errors.h\"\n\nint\niasecc_se_get_info()\n{\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n#endif /* ENABLE_OPENSSL */\n"], "fixing_code": ["/*\n * card-iasecc.c: Support for IAS/ECC smart cards\n *\n * Copyright (C) 2010  Viktor Tarasov <vtarasov@gmail.com>\n *\t\t\tOpenTrust <www.opentrust.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef ENABLE_OPENSSL   /* empty file without openssl */\n\n#include <string.h>\n#include <stdlib.h>\n\n#include <openssl/bn.h>\n#include <openssl/evp.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/sha.h>\n#include <openssl/rsa.h>\n#include <openssl/pkcs12.h>\n#include <openssl/x509v3.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#include \"opensc.h\"\n/* #include \"sm.h\" */\n#include \"pkcs15.h\"\n/* #include \"hash-strings.h\" */\n#include \"gp.h\"\n\n#include \"iasecc.h\"\n\n#define IASECC_CARD_DEFAULT_FLAGS ( 0\t\t\t\\\n\t\t| SC_ALGORITHM_ONBOARD_KEY_GEN\t\t\\\n\t\t| SC_ALGORITHM_RSA_PAD_ISO9796\t\t\\\n\t\t| SC_ALGORITHM_RSA_PAD_PKCS1\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_NONE\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_SHA1\t\t\\\n\t\t| SC_ALGORITHM_RSA_HASH_SHA256)\n\n/* generic iso 7816 operations table */\nstatic const struct sc_card_operations *iso_ops = NULL;\n\n/* our operations table with overrides */\nstatic struct sc_card_operations iasecc_ops;\n\nstatic struct sc_card_driver iasecc_drv = {\n\t\"IAS-ECC\",\n\t\"iasecc\",\n\t&iasecc_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_atr_table iasecc_known_atrs[] = {\n\t{ \"3B:7F:96:00:00:00:31:B8:64:40:70:14:10:73:94:01:80:82:90:00\",\n\t  \"FF:FF:FF:FF:FF:FF:FF:FE:FF:FF:00:00:FF:FF:FF:FF:FF:FF:FF:FF\",\n\t\t\"IAS/ECC Gemalto\", SC_CARD_TYPE_IASECC_GEMALTO,  0, NULL },\n        { \"3B:DD:18:00:81:31:FE:45:80:F9:A0:00:00:00:77:01:08:00:07:90:00:FE\", NULL,\n\t\t\"IAS/ECC v1.0.1 Oberthur\", SC_CARD_TYPE_IASECC_OBERTHUR,  0, NULL },\n\t{ \"3B:7D:13:00:00:4D:44:57:2D:49:41:53:2D:43:41:52:44:32\", NULL,\n\t\t\"IAS/ECC v1.0.1 Sagem MDW-IAS-CARD2\", SC_CARD_TYPE_IASECC_SAGEM,  0, NULL },\n\t{ \"3B:7F:18:00:00:00:31:B8:64:50:23:EC:C1:73:94:01:80:82:90:00\", NULL,\n\t\t\"IAS/ECC v1.0.1 Sagem ypsID S3\", SC_CARD_TYPE_IASECC_SAGEM,  0, NULL },\n\t{ \"3B:DF:96:00:80:31:FE:45:00:31:B8:64:04:1F:EC:C1:73:94:01:80:82:90:00:EC\", NULL,\n\t\t\"IAS/ECC Morpho MinInt - Agent Card\", SC_CARD_TYPE_IASECC_MI, 0, NULL },\n\t{ \"3B:DF:18:FF:81:91:FE:1F:C3:00:31:B8:64:0C:01:EC:C1:73:94:01:80:82:90:00:B3\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ \"3B:DC:18:FF:81:91:FE:1F:C3:80:73:C8:21:13:66:02:04:03:55:00:02:34\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ \"3B:DC:18:FF:81:91:FE:1F:C3:80:73:C8:21:13:66:01:0B:03:52:00:05:38\", NULL,\n\t\t\"IAS/ECC v1.0.1 Amos\", SC_CARD_TYPE_IASECC_AMOS, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n\nstatic struct sc_aid OberthurIASECC_AID = {\n\t{0xA0,0x00,0x00,0x00,0x77,0x01,0x08,0x00,0x07,0x00,0x00,0xFE,0x00,0x00,0x01,0x00}, 16\n};\n\nstatic struct sc_aid MIIASECC_AID = {\n\t{ 0x4D, 0x49, 0x4F, 0x4D, 0x43, 0x54}, 6\n};\n\nstruct iasecc_pin_status  {\n\tunsigned char sha1[SHA_DIGEST_LENGTH];\n\tunsigned char reference;\n\n\tstruct iasecc_pin_status *next;\n\tstruct iasecc_pin_status *prev;\n};\n\nstruct iasecc_pin_status *checked_pins = NULL;\n\nstatic int iasecc_select_file(struct sc_card *card, const struct sc_path *path, struct sc_file **file_out);\nstatic int iasecc_process_fci(struct sc_card *card, struct sc_file *file, const unsigned char *buf, size_t buflen);\nstatic int iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial);\nstatic int iasecc_sdo_get_data(struct sc_card *card, struct iasecc_sdo *sdo);\nstatic int iasecc_pin_get_policy (struct sc_card *card, struct sc_pin_cmd_data *data);\nstatic int iasecc_pin_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, int *tries_left);\nstatic int iasecc_get_free_reference(struct sc_card *card, struct iasecc_ctl_get_free_reference *ctl_data);\nstatic int iasecc_sdo_put_data(struct sc_card *card, struct iasecc_sdo_update *update);\n\n#ifdef ENABLE_SM\nstatic int _iasecc_sm_read_binary(struct sc_card *card, unsigned int offs, unsigned char *buf, size_t count);\nstatic int _iasecc_sm_update_binary(struct sc_card *card, unsigned int offs, const unsigned char *buff, size_t count);\n#endif\n\nstatic int\niasecc_chv_cache_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *pin_status = NULL, *current = NULL;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (current)   {\n\t\tsc_log(ctx, \"iasecc_chv_cache_verified() current PIN-%i\", current->reference);\n\t\tpin_status = current;\n\t}\n\telse   {\n\t\tpin_status = calloc(1, sizeof(struct iasecc_pin_status));\n\t\tif (!pin_status)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot callocate PIN status info\");\n\t\tsc_log(ctx, \"iasecc_chv_cache_verified() allocated %p\", pin_status);\n\t}\n\n\tpin_status->reference = pin_cmd->pin_reference;\n\tif (pin_cmd->pin1.data)\n\t\tSHA1(pin_cmd->pin1.data, pin_cmd->pin1.len, pin_status->sha1);\n\telse\n\t\tmemset(pin_status->sha1, 0, SHA_DIGEST_LENGTH);\n\n\tsc_log_hex(ctx, \"iasecc_chv_cache_verified() sha1(PIN)\", pin_status->sha1, SHA_DIGEST_LENGTH);\n\n\tif (!current)   {\n\t\tif (!checked_pins)   {\n\t\t\tchecked_pins = pin_status;\n\t\t}\n\t\telse   {\n\t\tchecked_pins->prev = pin_status;\n\t\t\tpin_status->next = checked_pins;\n\t\t\tchecked_pins = pin_status;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_chv_cache_clean(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *current = NULL;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (!current)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\n\tif (current->next && current->prev)   {\n\t\tcurrent->prev->next = current->next;\n\t\tcurrent->next->prev = current->prev;\n\t}\n\telse if (!current->prev)   {\n\t\tchecked_pins = current->next;\n\t}\n\telse if (!current->next && current->prev)   {\n\t\tcurrent->prev->next = NULL;\n\t}\n\n\tfree(current);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic struct iasecc_pin_status *\niasecc_chv_cache_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_pin_status *current = NULL;\n\tunsigned char data_sha1[SHA_DIGEST_LENGTH];\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (pin_cmd->pin1.data)\n\t\tSHA1(pin_cmd->pin1.data, pin_cmd->pin1.len, data_sha1);\n\telse\n\t\tmemset(data_sha1, 0, SHA_DIGEST_LENGTH);\n\tsc_log_hex(ctx, \"data_sha1: %s\", data_sha1, SHA_DIGEST_LENGTH);\n\n\tfor(current = checked_pins; current; current = current->next)\n\t\tif (current->reference == pin_cmd->pin_reference)\n\t\t\tbreak;\n\n\tif (current && !memcmp(data_sha1, current->sha1, SHA_DIGEST_LENGTH))   {\n\t\tsc_log(ctx, \"PIN-%i status 'verified'\", pin_cmd->pin_reference);\n\t\treturn current;\n\t}\n\n\tsc_log(ctx, \"PIN-%i status 'not verified'\", pin_cmd->pin_reference);\n\treturn NULL;\n}\n\n\nstatic int\niasecc_select_mf(struct sc_card *card, struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *mf_file = NULL;\n\tstruct sc_path path;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tmemset(&path, 0, sizeof(struct sc_path));\n\tif (!card->ef_atr || !card->ef_atr->aid.len)   {\n\t\tstruct sc_apdu apdu;\n\t\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\n\t\t/* ISO 'select' command fails when not FCP data returned */\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x00, 0x00);\n\t\tapdu.lc = path.len;\n\t\tapdu.data = path.value;\n\t\tapdu.datalen = path.len;\n\t\tapdu.resplen = sizeof(apdu_resp);\n\t\tapdu.resp = apdu_resp;\n\n\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\tapdu.p2 = 0x04;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, rv, \"Cannot select MF\");\n\t}\n\telse   {\n\t\tmemset(&path, 0, sizeof(path));\n\t\tpath.type = SC_PATH_TYPE_DF_NAME;\n\t\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\t\tpath.len = card->ef_atr->aid.len;\n\t\trv = iasecc_select_file(card, &path, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"Unable to ROOT selection\");\n\t}\n\n\t/* Ignore the FCP of the MF, because:\n\t * - some cards do not return it;\n\t * - there is not need of it -- create/delete of the files in MF is not envisaged.\n\t */\n\tmf_file = sc_file_new();\n\tif (mf_file == NULL)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot allocate MF file\");\n\tmf_file->type = SC_FILE_TYPE_DF;\n\tmf_file->path = path;\n\n\tif (card->cache.valid)\n\t\t sc_file_free(card->cache.current_df);\n\tcard->cache.current_df = NULL;\n\n\tif (card->cache.valid)\n\t\tsc_file_free(card->cache.current_ef);\n\tcard->cache.current_ef = NULL;\n\n\tsc_file_dup(&card->cache.current_df, mf_file);\n\tcard->cache.valid = 1;\n\n\tif (file_out && *file_out == NULL)\n\t\t*file_out = mf_file;\n\telse\n\t\tsc_file_free(mf_file);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_select_aid(struct sc_card *card, struct sc_aid *aid, unsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\t/* Select application (deselect previously selected application) */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid->len;\n\tapdu.data = aid->value;\n\tapdu.datalen = aid->len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\n\tif (*out_len < apdu.resplen)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID\");\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\treturn SC_SUCCESS;\n}\n\n\nstatic int\niasecc_match_card(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint i;\n\n\ti = _sc_match_atr(card, iasecc_known_atrs, &card->type);\n\tif (i < 0)   {\n\t\tsc_log(ctx, \"card not matched\");\n\t\treturn 0;\n\t}\n\n\tsc_log(ctx, \"'%s' card matched\", iasecc_known_atrs[i].name);\n\treturn 1;\n}\n\n\nstatic int iasecc_parse_ef_atr(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *pdata = (struct iasecc_private_data *) card->drv_data;\n\tstruct iasecc_version *version = &pdata->version;\n\tstruct iasecc_io_buffer_sizes *sizes = &pdata->max_sizes;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\trv = sc_parse_ef_atr(card);\n\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\tif (card->ef_atr->pre_issuing_len < 4)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid pre-issuing data\");\n\n\tversion->ic_manufacturer =\tcard->ef_atr->pre_issuing[0];\n\tversion->ic_type =\t\tcard->ef_atr->pre_issuing[1];\n\tversion->os_version =\t\tcard->ef_atr->pre_issuing[2];\n\tversion->iasecc_version =\tcard->ef_atr->pre_issuing[3];\n\tsc_log(ctx, \"EF.ATR: IC manufacturer/type %X/%X, OS/IasEcc versions %X/%X\",\n\t\tversion->ic_manufacturer, version->ic_type, version->os_version, version->iasecc_version);\n\n\tif (card->ef_atr->issuer_data_len < 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid issuer data\");\n\n\tsizes->send =\t card->ef_atr->issuer_data[2] * 0x100 + card->ef_atr->issuer_data[3];\n\tsizes->send_sc = card->ef_atr->issuer_data[6] * 0x100 + card->ef_atr->issuer_data[7];\n\tsizes->recv =\t card->ef_atr->issuer_data[10] * 0x100 + card->ef_atr->issuer_data[11];\n\tsizes->recv_sc = card->ef_atr->issuer_data[14] * 0x100 + card->ef_atr->issuer_data[15];\n\n\tcard->max_send_size = sizes->send;\n\tcard->max_recv_size = sizes->recv;\n\n\t/* Most of the card producers interpret 'send' values as \"maximum APDU data size\".\n\t * Oberthur strictly follows specification and interpret these values as \"maximum APDU command size\".\n\t * Here we need 'data size'.\n\t */\n\tif (card->max_send_size > 0xFF)\n\t\tcard->max_send_size -= 5;\n\n\tsc_log(ctx,\n\t       \"EF.ATR: max send/recv sizes %\"SC_FORMAT_LEN_SIZE_T\"X/%\"SC_FORMAT_LEN_SIZE_T\"X\",\n\t       card->max_send_size, card->max_recv_size);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_gemalto(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path path;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tsc_format_path(\"3F00\", &path);\n\trv = sc_select_file(card, &path, NULL);\n\t/* Result ignored*/\n\n\trv = iasecc_parse_ef_atr(card);\n\tsc_log(ctx, \"rv %i\", rv);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\tsc_log(ctx, \"Select MF\");\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tsc_log(ctx, \"rv %i\", rv);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\trv = iasecc_parse_ef_atr(card);\n\t\tsc_log(ctx, \"rv %i\", rv);\n\t}\n\tsc_log(ctx, \"rv %i\", rv);\n\tLOG_TEST_RET(ctx, rv, \"Cannot read/parse EF.ATR\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_oberthur_match(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char *hist = card->reader->atr_info.hist_bytes;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (*hist != 0x80 || ((*(hist+1)&0xF0) != 0xF0))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OBJECT_NOT_FOUND);\n\n\tsc_log_hex(ctx, \"AID in historical_bytes\", hist + 2, *(hist+1) & 0x0F);\n\n\tif (memcmp(hist + 2, OberthurIASECC_AID.value, *(hist+1) & 0x0F))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_RECORD_NOT_FOUND);\n\n\tif (!card->ef_atr)\n\t\tcard->ef_atr = calloc(1, sizeof(struct sc_ef_atr));\n\tif (!card->ef_atr)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(card->ef_atr->aid.value, OberthurIASECC_AID.value, OberthurIASECC_AID.len);\n\tcard->ef_atr->aid.len = OberthurIASECC_AID.len;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_oberthur(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tiasecc_parse_ef_atr(card);\n\n\t/* if we fail to select CM, */\n\tif (gp_select_card_manager(card)) {\n\t\tgp_select_isd_rid(card);\n\t}\n\n\trv = iasecc_oberthur_match(card);\n\tLOG_TEST_RET(ctx, rv, \"unknown Oberthur's IAS/ECC card\");\n\n\trv = iasecc_select_mf(card, NULL);\n\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\trv = iasecc_parse_ef_atr(card);\n\tLOG_TEST_RET(ctx, rv, \"EF.ATR read or parse error\");\n\n\tsc_log(ctx, \"EF.ATR(aid:'%s')\", sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len));\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_mi_match(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char resp[0x100];\n\tsize_t resp_len;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tresp_len = sizeof(resp);\n\trv = iasecc_select_aid(card, &MIIASECC_AID, resp, &resp_len);\n\tLOG_TEST_RET(ctx, rv, \"IASECC: failed to select MI IAS/ECC applet\");\n\n\tif (!card->ef_atr)\n\t\tcard->ef_atr = calloc(1, sizeof(struct sc_ef_atr));\n\tif (!card->ef_atr)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(card->ef_atr->aid.value, MIIASECC_AID.value, MIIASECC_AID.len);\n\tcard->ef_atr->aid.len = MIIASECC_AID.len;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_init(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *private_data = NULL;\n\tint rv = SC_ERROR_NO_CARD_SUPPORT;\n\n\tLOG_FUNC_CALLED(ctx);\n\tprivate_data = (struct iasecc_private_data *) calloc(1, sizeof(struct iasecc_private_data));\n\tif (private_data == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tcard->cla  = 0x00;\n\tcard->drv_data = private_data;\n\n\tif (card->type == SC_CARD_TYPE_IASECC_GEMALTO)\n\t\trv = iasecc_init_gemalto(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\trv = iasecc_init_oberthur(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_SAGEM)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse if (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\trv = iasecc_init_amos_or_sagem(card);\n\telse\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_CARD);\n\n\n\tif (!rv)   {\n\t\tif (card->ef_atr && card->ef_atr->aid.len)   {\n\t\t\tstruct sc_path path;\n\n\t\t\tmemset(&path, 0, sizeof(struct sc_path));\n\t\t\tpath.type = SC_PATH_TYPE_DF_NAME;\n\t\t\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\t\t\tpath.len = card->ef_atr->aid.len;\n\n\t\t\trv = iasecc_select_file(card, &path, NULL);\n\t\t\tsc_log(ctx, \"Select ECC ROOT with the AID from EF.ATR: rv %i\", rv);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Select EF.ATR AID failed\");\n\t\t}\n\n\t\trv = iasecc_get_serialnr(card, NULL);\n\t}\n\n#ifdef ENABLE_SM\n\tcard->sm_ctx.ops.read_binary = _iasecc_sm_read_binary;\n\tcard->sm_ctx.ops.update_binary = _iasecc_sm_update_binary;\n#endif\n\n\tif (!rv) {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len));\n\t\trv = SC_ERROR_INVALID_CARD;\n\t}\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_read_binary(struct sc_card *card, unsigned int offs,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_read_binary(card:%p) offs %i; count %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, offs, count);\n\tif (offs > 0x7fff) {\n\t\tsc_log(ctx, \"invalid EF offset: 0x%X > 0x7FFF\", offs);\n\t\treturn SC_ERROR_OFFSET_TOO_LARGE;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, (offs >> 8) & 0x7F, offs & 0xFF);\n\tapdu.le = count < 0x100 ? count : 0x100;\n\tapdu.resplen = count;\n\tapdu.resp = buf;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_read_binary() failed\");\n\tsc_log(ctx,\n\t       \"iasecc_read_binary() apdu.resplen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       apdu.resplen);\n\n\tif (apdu.resplen == IASECC_READ_BINARY_LENGTH_MAX && apdu.resplen < count)   {\n\t\trv = iasecc_read_binary(card, offs + apdu.resplen, buf + apdu.resplen, count - apdu.resplen, flags);\n\t\tif (rv != SC_ERROR_WRONG_LENGTH)   {\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_read_binary() read tail failed\");\n\t\t\tapdu.resplen += rv;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\nstatic int\niasecc_erase_binary(struct sc_card *card, unsigned int offs, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char *tmp = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_erase_binary(card:%p) count %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, count);\n\tif (!count)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"'ERASE BINARY' failed: invalid size to erase\");\n\n\ttmp = malloc(count);\n\tif (!tmp)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot allocate temporary buffer\");\n\tmemset(tmp, 0xFF, count);\n\n\trv = sc_update_binary(card, offs, tmp, count, flags);\n\tfree(tmp);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_erase_binary() update binary error\");\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n#if ENABLE_SM\nstatic int\n_iasecc_sm_read_binary(struct sc_card *card, unsigned int offs,\n\t\tunsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tif (offs > 0x7fff)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OFFSET_TOO_LARGE, \"Invalid arguments\");\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_READ);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_read() 'READ' ACL not present\");\n\n\t\tsc_log(ctx, \"READ method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif ((entry->method == SC_AC_SCB) && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = (entry->method == SC_AC_SCB) ? (entry->key_ref & IASECC_SCB_METHOD_MASK_REF) : 0;\n\n\t\t\trv = iasecc_sm_read_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\n_iasecc_sm_update_binary(struct sc_card *card, unsigned int offs,\n\t\tconst unsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\n\tif (count == 0)\n\t\treturn SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_UPDATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_update() 'UPDATE' ACL not present\");\n\n\t\tsc_log(ctx, \"UPDATE method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = entry->method == SC_AC_SCB ? entry->key_ref & IASECC_SCB_METHOD_MASK_REF : 0;\n\n\t\t\trv = iasecc_sm_update_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n#endif\n\n\nstatic int\niasecc_emulate_fcp(struct sc_context *ctx, struct sc_apdu *apdu)\n{\n\tunsigned char dummy_df_fcp[] = {\n\t\t0x62,0xFF,\n\t\t\t0x82,0x01,0x38,\n\t\t\t0x8A,0x01,0x05,\n\t\t\t0xA1,0x04,0x8C,0x02,0x02,0x00,\n\t\t\t0x84,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (apdu->p1 != 0x04)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"FCP emulation supported only for the DF-NAME selection type\");\n\tif (apdu->datalen > 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid DF-NAME length\");\n\tif (apdu->resplen < apdu->datalen + 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"not enough space for FCP data\");\n\n\tmemcpy(dummy_df_fcp + 16, apdu->data, apdu->datalen);\n\tdummy_df_fcp[15] = apdu->datalen;\n\tdummy_df_fcp[1] = apdu->datalen + 14;\n\tmemcpy(apdu->resp, dummy_df_fcp, apdu->datalen + 16);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n/* TODO: redesign using of cache\n * TODO: do not keep intermediate results in 'file_out' argument */\nstatic int\niasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n\tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n\n\tsc_print_cache(card);\n\tif (path->type != SC_PATH_TYPE_DF_NAME\n\t\t\t&& lpath.len >= 2\n\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n\n\t\trv = iasecc_select_mf(card, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\tlpath.len -=  2;\n\t}\n\n\tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t const unsigned char *buf, size_t buflen)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tsize_t taglen;\n\tint rv, ii, offs;\n\tconst unsigned char *acls = NULL, *tag = NULL;\n\tunsigned char mask;\n\tunsigned char ops_DF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_CREATE, 0xFF\n\t};\n\tunsigned char ops_EF[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x6F, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x6F tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\ttag = sc_asn1_find_tag(ctx,  buf, buflen, 0x62, &taglen);\n\tsc_log(ctx, \"processing FCI: 0x62 tag %p\", tag);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\trv = iso_ops->process_fci(card, file, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");\n/*\n\tGemalto:  6F 19 80 02 02 ED 82 01 01 83 02 B0 01 88 00\t8C 07 7B 17 17 17 17 17 00 8A 01 05 90 00\n\tSagem:    6F 17 62 15 80 02 00 7D 82 01 01                   8C 02 01 00 83 02 2F 00 88 01 F0 8A 01 05 90 00\n\tOberthur: 62 1B 80 02 05 DC 82 01 01 83 02 B0 01 88 00 A1 09 8C 07 7B 17 FF 17 17 17 00 8A 01 05 90 00\n*/\n\n\tsc_log(ctx, \"iasecc_process_fci() type %i; let's parse file ACLs\", file->type);\n\ttag = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS, &taglen);\n\tif (tag)\n\t\tacls = sc_asn1_find_tag(ctx, tag, taglen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\telse\n\t\tacls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);\n\n\tif (!acls)   {\n\t\tsc_log(ctx,\n\t\t       \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",\n\t\t       buflen, sc_dump_hex(buf, buflen));\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");\n\t}\n\n\tsc_log(ctx, \"ACLs(%\"SC_FORMAT_LEN_SIZE_T\"u) '%s'\", taglen,\n\t       sc_dump_hex(acls, taglen));\n\tmask = 0x40, offs = 1;\n\tfor (ii = 0; ii < 7; ii++, mask /= 2)  {\n\t\tunsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];\n\n\t\tif (!(mask & acls[0]))\n\t\t\tcontinue;\n\n\t\tsc_log(ctx, \"ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);\n\t\tif (op == 0xFF)   {\n\t\t\t;\n\t\t}\n\t\telse if (acls[offs] == 0)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NONE, 0);\n\t\t}\n\t\telse if (acls[offs] == 0xFF)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\t\telse if ((acls[offs] & IASECC_SCB_METHOD_MASK) == IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SEN, acls[offs] & IASECC_SCB_METHOD_MASK_REF);\n\t\t}\n\t\telse if (acls[offs] & IASECC_SCB_METHOD_MASK)   {\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SCB, acls[offs]);\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Warning: non supported SCB method: %X\", acls[offs]);\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\t}\n\n\t\toffs++;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n\n\nstatic int\niasecc_fcp_encode(struct sc_card *card, struct sc_file *file, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char buf[0x80], type;\n\tunsigned char  ops[7] = {\n\t\tSC_AC_OP_DELETE, 0xFF, SC_AC_OP_ACTIVATE, SC_AC_OP_DEACTIVATE, 0xFF, SC_AC_OP_UPDATE, SC_AC_OP_READ\n\t};\n\tunsigned char smbs[8];\n\tsize_t ii, offs = 0, amb, mask, nn_smb;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (file->type == SC_FILE_TYPE_DF)\n\t\ttype = IASECC_FCP_TYPE_DF;\n\telse\n\t\ttype = IASECC_FCP_TYPE_EF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_SIZE;\n\tbuf[offs++] = 2;\n\tbuf[offs++] = (file->size >> 8) & 0xFF;\n\tbuf[offs++] = file->size & 0xFF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_TYPE;\n\tbuf[offs++] = 1;\n\tbuf[offs++] = type;\n\n\tbuf[offs++] = IASECC_FCP_TAG_FID;\n\tbuf[offs++] = 2;\n\tbuf[offs++] = (file->id >> 8) & 0xFF;\n\tbuf[offs++] = file->id & 0xFF;\n\n\tbuf[offs++] = IASECC_FCP_TAG_SFID;\n\tbuf[offs++] = 0;\n\n\tamb = 0, mask = 0x40, nn_smb = 0;\n\tfor (ii = 0; ii < sizeof(ops); ii++, mask >>= 1) {\n\t\tconst struct sc_acl_entry *entry;\n\n\t\tif (ops[ii]==0xFF)\n\t\t\tcontinue;\n\n\t\tentry = sc_file_get_acl_entry(file, ops[ii]);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\tsc_log(ctx, \"method %X; reference %X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_NEVER)\n\t\t\tcontinue;\n\t\telse if (entry->method == SC_AC_NONE)\n\t\t\tsmbs[nn_smb++] = 0x00;\n\t\telse if (entry->method == SC_AC_CHV)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_USER_AUTH;\n\t\telse if (entry->method == SC_AC_SEN)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_USER_AUTH;\n\t\telse if (entry->method == SC_AC_SCB)\n\t\t\tsmbs[nn_smb++] = entry->key_ref;\n\t\telse if (entry->method == SC_AC_PRO)\n\t\t\tsmbs[nn_smb++] = entry->key_ref | IASECC_SCB_METHOD_SM;\n\t\telse\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Non supported AC method\");\n\n\t\tamb |= mask;\n\t\tsc_log(ctx,\n\t\t       \"%\"SC_FORMAT_LEN_SIZE_T\"u: AMB %\"SC_FORMAT_LEN_SIZE_T\"X; nn_smb %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       ii, amb, nn_smb);\n\t}\n\n\t/* TODO: Encode contactless ACLs and life cycle status for all IAS/ECC cards */\n\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM ||\n\t\t\tcard->type == SC_CARD_TYPE_IASECC_AMOS )  {\n\t\tunsigned char status = 0;\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS;\n\t\tbuf[offs++] = 2*(2 + 1 + nn_smb);\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACT;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\n\t\t/* Same ACLs for contactless */\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACTLESS;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\n\t\tif (file->status == SC_FILE_STATUS_ACTIVATED)\n\t\t\tstatus = 0x05;\n\t\telse if (file->status == SC_FILE_STATUS_CREATION)\n\t\t\tstatus = 0x01;\n\n\t\tif (status)   {\n\t\t\tbuf[offs++] = 0x8A;\n\t\t\tbuf[offs++] = 0x01;\n\t\t\tbuf[offs++] = status;\n\t\t}\n\t}\n\telse   {\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS;\n\t\tbuf[offs++] = 2 + 1 + nn_smb;\n\n\t\tbuf[offs++] = IASECC_FCP_TAG_ACLS_CONTACT;\n\t\tbuf[offs++] = nn_smb + 1;\n\t\tbuf[offs++] = amb;\n\t\tmemcpy(buf + offs, smbs, nn_smb);\n\t\toffs += nn_smb;\n\t}\n\n\tif (out)   {\n\t\tif (out_len < offs)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small to encode FCP\");\n\t\tmemcpy(out, buf, offs);\n\t}\n\n\tLOG_FUNC_RETURN(ctx, offs);\n}\n\n\nstatic int\niasecc_create_file(struct sc_card *card, struct sc_file *file)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tconst struct sc_acl_entry *entry = NULL;\n\tunsigned char sbuf[0x100];\n\tsize_t sbuf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\tif (file->type != SC_FILE_TYPE_WORKING_EF)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Creation of the file with of this type is not supported\");\n\n\tsbuf_len = iasecc_fcp_encode(card, file, sbuf + 2, sizeof(sbuf)-2);\n\tLOG_TEST_RET(ctx, sbuf_len, \"FCP encode error\");\n\n\tsbuf[0] = IASECC_FCP_TAG;\n\tsbuf[1] = sbuf_len;\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_df, SC_AC_OP_CREATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_create_file() 'CREATE' ACL not present\");\n\n\t\tsc_log(ctx, \"iasecc_create_file() 'CREATE' method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tsc_log(ctx, \"iasecc_create_file() create data: '%s'\", sc_dump_hex(sbuf, sbuf_len + 2));\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n                        rv = iasecc_sm_create_file(card, entry->key_ref & IASECC_SCB_METHOD_MASK_REF, sbuf, sbuf_len + 2);\n                        LOG_TEST_RET(ctx, rv, \"iasecc_create_file() SM create file error\");\n\n                        rv = iasecc_select_file(card, &file->path, NULL);\n                        LOG_FUNC_RETURN(ctx, rv);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0, 0);\n\tapdu.data = sbuf;\n\tapdu.datalen = sbuf_len + 2;\n\tapdu.lc = sbuf_len + 2;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_create_file() create file error\");\n\n\trv = iasecc_select_file(card, &file->path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select newly created file\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_logout(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path path;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!card->ef_atr || !card->ef_atr->aid.len)\n\t\treturn SC_SUCCESS;\n\n\tmemset(&path, 0, sizeof(struct sc_path));\n\tpath.type = SC_PATH_TYPE_DF_NAME;\n\tmemcpy(path.value, card->ef_atr->aid.value, card->ef_atr->aid.len);\n\tpath.len = card->ef_atr->aid.len;\n\n\trv = iasecc_select_file(card, &path, NULL);\n\tsc_log(ctx, \"Select ECC ROOT with the AID from EF.ATR: rv %i\", rv);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_finish(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *private_data = (struct iasecc_private_data *)card->drv_data;\n\tstruct iasecc_se_info *se_info = private_data->se_info, *next;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\twhile (se_info)   {\n\t\tsc_file_free(se_info->df);\n\t\tnext = se_info->next;\n\t\tfree(se_info);\n\t\tse_info = next;\n\t}\n\n\tfree(card->drv_data);\n\tcard->drv_data = NULL;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tstruct sc_apdu apdu;\n\tstruct sc_file *file = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\trv = iasecc_select_file(card, path, &file);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select file to delete\");\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\tif (!entry)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"Cannot delete file: no 'DELETE' acl\");\n\n\tsc_log(ctx, \"DELETE method/reference %X/%X\", entry->method, entry->key_ref);\n\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\tunsigned char se_num = (entry->method == SC_AC_SCB) ? (entry->key_ref & IASECC_SCB_METHOD_MASK_REF) : 0;\n\t\trv = iasecc_sm_delete_file(card, se_num, file->id);\n\t}\n\telse   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"Delete file failed\");\n\n\t\tif (card->cache.valid)\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\tcard->cache.current_ef = NULL;\n\t}\n\n\tsc_file_free(file);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_check_sw(struct sc_card *card, unsigned int sw1, unsigned int sw2)\n{\n\tif (sw1 == 0x62 && sw2 == 0x82)\n\t\treturn SC_SUCCESS;\n\n\treturn iso_ops->check_sw(card, sw1, sw2);\n}\n\n\nstatic unsigned\niasecc_get_algorithm(struct sc_context *ctx, const struct sc_security_env *env,\n\t\tunsigned operation, unsigned mechanism)\n{\n    const struct sc_supported_algo_info *info = NULL;\n    int ii;\n\n    if (!env)\n        return 0;\n\n    for (ii=0;ii<SC_MAX_SUPPORTED_ALGORITHMS && env->supported_algos[ii].reference; ii++)\n        if ((env->supported_algos[ii].operations & operation)\n\t\t\t&& (env->supported_algos[ii].mechanism == mechanism))\n            break;\n\n    if (ii < SC_MAX_SUPPORTED_ALGORITHMS && env->supported_algos[ii].reference)   {\n        info = &env->supported_algos[ii];\n        sc_log(ctx, \"found IAS/ECC algorithm %X:%X:%X:%X\",\n\t\t\tinfo->reference, info->mechanism, info->operations, info->algo_ref);\n    }\n    else   {\n        sc_log(ctx, \"cannot find IAS/ECC algorithm (operation:%X,mechanism:%X)\", operation, mechanism);\n    }\n\n    return info ? info->algo_ref : 0;\n}\n\n\nstatic int\niasecc_se_cache_info(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info *se_info = NULL, *si = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tse_info = calloc(1, sizeof(struct iasecc_se_info));\n\tif (!se_info)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"SE info allocation error\");\n\tmemcpy(se_info, se, sizeof(struct iasecc_se_info));\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tsc_file_dup(&se_info->df, card->cache.current_df);\n\t\tif (se_info->df == NULL)   {\n\t\t\tfree(se_info);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\t\t}\n\t}\n\n\trv = iasecc_docp_copy(ctx, &se->docp, &se_info->docp);\n\tif (rv < 0)   {\n\t\tfree(se_info->df);\n\t\tfree(se_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot make copy of DOCP\");\n\t}\n\n\tif (!prv->se_info)   {\n\t\tprv->se_info = se_info;\n\t}\n\telse    {\n\t\tfor (si = prv->se_info; si->next; si = si->next)\n\t\t\t;\n\t\tsi->next = se_info;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_se_get_info_from_cache(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info *si = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tfor(si = prv->se_info; si; si = si->next)   {\n\t\tif (si->reference != se->reference)\n\t\t\tcontinue;\n\t\tif (!(card->cache.valid && card->cache.current_df) && si->df)\n\t\t\tcontinue;\n\t\tif (card->cache.valid && card->cache.current_df && !si->df)\n\t\t\tcontinue;\n\t\tif (card->cache.valid && card->cache.current_df && si->df)\n\t\t\tif (memcmp(&card->cache.current_df->path, &si->df->path, sizeof(struct sc_path)))\n\t\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (!si)\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\n\tmemcpy(se, si, sizeof(struct iasecc_se_info));\n\n\tif (si->df)   {\n\t\tsc_file_dup(&se->df, si->df);\n\t\tif (se->df == NULL)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\t}\n\n\trv = iasecc_docp_copy(ctx, &si->docp, &se->docp);\n\tLOG_TEST_RET(ctx, rv, \"Cannot make copy of DOCP\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nint\niasecc_se_get_info(struct sc_card *card, struct iasecc_se_info *se)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[0x100];\n\tunsigned char sbuf_iasecc[10] = {\n\t\t0x4D, 0x08, IASECC_SDO_TEMPLATE_TAG, 0x06,\n\t\tIASECC_SDO_TAG_HEADER, IASECC_SDO_CLASS_SE | IASECC_OBJECT_REF_LOCAL,\n\t\tse->reference & 0x3F,\n\t\t0x02, IASECC_SDO_CLASS_SE, 0x80\n\t};\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (se->reference > IASECC_SE_REF_MAX)\n                LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\trv = iasecc_se_get_info_from_cache(card, se);\n\tif (rv == SC_ERROR_OBJECT_NOT_FOUND)   {\n\t\tsc_log(ctx, \"No SE#%X info in cache, try to use 'GET DATA'\", se->reference);\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xCB, 0x3F, 0xFF);\n\t\tapdu.data = sbuf_iasecc;\n\t\tapdu.datalen = sizeof(sbuf_iasecc);\n\t\tapdu.lc = apdu.datalen;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = sizeof(rbuf);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"get SE data  error\");\n\n\t\trv = iasecc_se_parse(card, apdu.resp, apdu.resplen, se);\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse SE data\");\n\n\t\trv = iasecc_se_cache_info(card, se);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to put SE data into cache\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo sdo;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tunsigned algo_ref;\n\tstruct sc_apdu apdu;\n\tunsigned sign_meth, sign_ref, auth_meth, auth_ref, aflags;\n\tunsigned char cse_crt_at[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, IASECC_ALGORITHM_RSA_PKCS\n\t};\n\tunsigned char cse_crt_dst[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1)\n\t};\n\tunsigned char cse_crt_ht[] = {\n\t\t0x80, 0x01, IASECC_ALGORITHM_SHA1\n\t};\n\tunsigned char cse_crt_ct[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1)\n\t};\n\tint rv, operation = env->operation;\n\n\t/* TODO: take algorithm references from 5032, not from header file. */\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_set_security_env(card:%p) operation 0x%X; senv.algorithm 0x%X, senv.algorithm_ref 0x%X\",\n\t\t\tcard, env->operation, env->algorithm, env->algorithm_ref);\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_RSA_PRIVATE;\n\tsdo.sdo_ref  = env->key_ref[0] & ~IASECC_OBJECT_REF_LOCAL;\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get RSA PRIVATE SDO data\");\n\n\t/* To made by iasecc_sdo_convert_to_file() */\n\tprv->key_size = *(sdo.docp.size.value + 0) * 0x100 + *(sdo.docp.size.value + 1);\n\tsc_log(ctx, \"prv->key_size 0x%\"SC_FORMAT_LEN_SIZE_T\"X\", prv->key_size);\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_COMPUTE_SIGNATURE, &sign_meth, &sign_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_SIGN acl\");\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_INTERNAL_AUTHENTICATE, &auth_meth, &auth_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_INT_AUTH acl\");\n\n\taflags = env->algorithm_flags;\n\n\tif (!(aflags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Only supported signature with PKCS1 padding\");\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tif (!(aflags & (SC_ALGORITHM_RSA_HASH_SHA1 | SC_ALGORITHM_RSA_HASH_SHA256)))   {\n\t\t\tsc_log(ctx, \"CKM_RSA_PKCS asked -- use 'AUTHENTICATE' sign operation instead of 'SIGN'\");\n\t\t\toperation = SC_SEC_OPERATION_AUTHENTICATE;\n\t\t}\n\t\telse if (sign_meth == SC_AC_NEVER)   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PSO_DST not allowed for this key\");\n\t\t}\n\t}\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tprv->op_method = sign_meth;\n\t\tprv->op_ref = sign_ref;\n\t}\n\telse if (operation == SC_SEC_OPERATION_AUTHENTICATE)   {\n\t\tif (auth_meth == SC_AC_NEVER)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"INTERNAL_AUTHENTICATE is not allowed for this key\");\n\n\t\tprv->op_method = auth_meth;\n\t\tprv->op_ref = auth_ref;\n\t}\n\n\tsc_log(ctx, \"senv.algorithm 0x%X, senv.algorithm_ref 0x%X\", env->algorithm, env->algorithm_ref);\n\tsc_log(ctx,\n\t       \"se_num %i, operation 0x%X, algorithm 0x%X, algorithm_ref 0x%X, flags 0x%X; key size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       se_num, operation, env->algorithm, env->algorithm_ref,\n\t       env->algorithm_flags, prv->key_size);\n\tswitch (operation)  {\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tif (!(env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_PKCS1 specified\");\n\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA256)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH, CKM_SHA256);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA256\");\n\n\t\t\tcse_crt_ht[2] = algo_ref; /* IASECC_ALGORITHM_SHA2 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA256_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA2 */\n\t\t}\n\t\telse if (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH,  CKM_SHA_1);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA1\");\n\n\t\t\tcse_crt_ht[2] = algo_ref;\t/* IASECC_ALGORITHM_SHA1 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA1_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1 */\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_HASH_SHA[1,256] specified\");\n\t\t}\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_HT);\n\t\tapdu.data = cse_crt_ht;\n\t\tapdu.datalen = sizeof(cse_crt_ht);\n\t\tapdu.lc = sizeof(cse_crt_ht);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_DST);\n\t\tapdu.data = cse_crt_dst;\n\t\tapdu.datalen = sizeof(cse_crt_dst);\n\t\tapdu.lc = sizeof(cse_crt_dst);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_AUTHENTICATE:\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports SIGNATURE:RSA_PKCS\");\n\n\t\tcse_crt_at[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_at[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_AT);\n\t\tapdu.data = cse_crt_at;\n\t\tapdu.datalen = sizeof(cse_crt_at);\n\t\tapdu.lc = sizeof(cse_crt_at);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_DECRYPT, &prv->op_method, &prv->op_ref);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_PSO_DECRYPT acl\");\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_DECIPHER,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports DECIPHER:RSA_PKCS\");\n\n\t\tcse_crt_ct[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_ct[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1 */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_CT);\n\t\tapdu.data = cse_crt_ct;\n\t\tapdu.datalen = sizeof(cse_crt_ct);\n\t\tapdu.lc = sizeof(cse_crt_ct);\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\tprv->security_env = *env;\n\tprv->security_env.operation = operation;\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n\n\nstatic int\niasecc_chv_verify_pinpad(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char buffer[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"CHV PINPAD PIN reference %i\", pin_cmd->pin_reference);\n\n\trv = iasecc_pin_is_verified(card, pin_cmd, tries_left);\n\tif (!rv)\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\t/* When PIN stored length available\n\t *     P10 verify data contains full template of 'VERIFY PIN' APDU.\n\t * Without PIN stored length\n\t *     pin-pad has to set the Lc and fill PIN data itself.\n\t *     Not all pin-pads support this case\n\t */\n\tpin_cmd->pin1.len = pin_cmd->pin1.stored_length;\n\tpin_cmd->pin1.length_offset = 5;\n\n\tmemset(buffer, 0xFF, sizeof(buffer));\n\tpin_cmd->pin1.data = buffer;\n\n\tpin_cmd->cmd = SC_PIN_CMD_VERIFY;\n\tpin_cmd->flags |= SC_PIN_CMD_USE_PINPAD;\n\n\t/*\n\tif (card->reader && card->reader->ops && card->reader->ops->load_message) {\n\t\trv = card->reader->ops->load_message(card->reader, card->slot, 0, \"Here we are!\");\n\t\tsc_log(ctx, \"Load message returned %i\", rv);\n\t}\n\t*/\n\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tsc_log(ctx, \"rv %i\", rv);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_acl_entry acl = pin_cmd->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tstruct sc_apdu apdu;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,acl:%X:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t\t\tacl.method, acl.key_ref);\n\n\tif (acl.method & IASECC_SCB_METHOD_SM)   {\n\t\trv = iasecc_sm_pin_verify(card, acl.key_ref, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\n\tif (pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_cmd->pin_reference);\n\t}\n\telse if (pin_cmd->pin1.data && pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20, 0, pin_cmd->pin_reference);\n\t\tapdu.data = pin_cmd->pin1.data;\n\t\tapdu.datalen = pin_cmd->pin1.len;\n\t\tapdu.lc = pin_cmd->pin1.len;\n\t}\n\telse if ((card->reader->capabilities & SC_READER_CAP_PIN_PAD) && !pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\trv = iasecc_chv_verify_pinpad(card, pin_cmd, tries_left);\n\t\tsc_log(ctx, \"Result of verifying CHV with PIN pad %i\", rv);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_se_at_to_chv_reference(struct sc_card *card, unsigned reference,\n\t\tunsigned *chv_reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info se;\n\tstruct sc_crt crt;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"SE reference %i\", reference);\n\n\tif (reference > IASECC_SE_REF_MAX)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tmemset(&se, 0, sizeof(se));\n\tse.reference = reference;\n\n\trv = iasecc_se_get_info(card, &se);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\tmemset(&crt, 0, sizeof(crt));\n\tcrt.tag = IASECC_CRT_TAG_AT;\n\tcrt.usage = IASECC_UQB_AT_USER_PASSWORD;\n\n\trv = iasecc_se_get_crt(card, &se, &crt);\n\tLOG_TEST_RET(ctx, rv, \"no authentication template for USER PASSWORD\");\n\n\tif (chv_reference)\n\t\t*chv_reference = crt.refs[0];\n\n\tsc_file_free(se.df);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_is_verified(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd_data,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n        struct sc_acl_entry acl = pin_cmd_data->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tint rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (pin_cmd_data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for the verification\");\n\n\tsc_log(ctx, \"Verify ACL(method:%X;ref:%X)\", acl.method, acl.key_ref);\n\tif (acl.method != IASECC_SCB_ALWAYS)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_SECURITY_STATUS_NOT_SATISFIED);\n\n\tpin_cmd = *pin_cmd_data;\n\tpin_cmd.pin1.data = (unsigned char *)\"\";\n\tpin_cmd.pin1.len = 0;\n\n\trv = iasecc_chv_verify(card, &pin_cmd, tries_left);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_verify(struct sc_card *card, unsigned type, unsigned reference,\n\t\tconst unsigned char *data, size_t data_len, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned chv_ref = reference;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"Verify PIN(type:%X,ref:%i,data(len:%\"SC_FORMAT_LEN_SIZE_T\"u,%p)\",\n\t       type, reference, data_len, data);\n\n\tif (type == SC_AC_AUT)   {\n\t\trv =  iasecc_sm_external_authentication(card, reference, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse if (type == SC_AC_SCB)   {\n\t\tif (reference & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\ttype = SC_AC_SEN;\n\t\t\treference = reference & IASECC_SCB_METHOD_MASK_REF;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Do not try to verify non CHV PINs\");\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t}\n\t}\n\n\tif (type == SC_AC_SEN)   {\n\t\trv = iasecc_se_at_to_chv_reference(card, reference,  &chv_ref);\n\t\tLOG_TEST_RET(ctx, rv, \"SE AT to CHV reference error\");\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = chv_ref;\n\tpin_cmd.cmd = SC_PIN_CMD_VERIFY;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\tpin_cmd.pin1.data = data;\n\tpin_cmd.pin1.len = data_len;\n\n\trv = iasecc_pin_is_verified(card, &pin_cmd, tries_left);\n\tif (data && !data_len)\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\n\tif (!rv)   {\n\t\tif (iasecc_chv_cache_is_verified(card, &pin_cmd))\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\telse if (rv != SC_ERROR_PIN_CODE_INCORRECT && rv != SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\n\tiasecc_chv_cache_clean(card, &pin_cmd);\n\n\trv = iasecc_chv_verify(card, &pin_cmd, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"PIN CHV verification error\");\n\n\trv = iasecc_chv_cache_verified(card, &pin_cmd);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_chv_change_pinpad(struct sc_card *card, unsigned reference, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned char pin1_data[0x100], pin2_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"CHV PINPAD PIN reference %i\", reference);\n\n\tmemset(pin1_data, 0xFF, sizeof(pin1_data));\n\tmemset(pin2_data, 0xFF, sizeof(pin2_data));\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = reference;\n\tpin_cmd.cmd = SC_PIN_CMD_CHANGE;\n\tpin_cmd.flags |= SC_PIN_CMD_USE_PINPAD;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\t/* Some pin-pads do not support mode with Lc=0.\n\t * Give them a chance to work with some cards.\n\t */\n\tif ((pin_cmd.pin1.min_length == pin_cmd.pin1.stored_length) && (pin_cmd.pin1.max_length == pin_cmd.pin1.min_length))\n\t\tpin_cmd.pin1.len = pin_cmd.pin1.stored_length;\n\telse\n\t\tpin_cmd.pin1.len = 0;\n\n\tpin_cmd.pin1.length_offset = 5;\n\tpin_cmd.pin1.data = pin1_data;\n\n\tmemcpy(&pin_cmd.pin2, &pin_cmd.pin1, sizeof(pin_cmd.pin1));\n\tpin_cmd.pin2.data = pin2_data;\n\n\tsc_log(ctx,\n\t       \"PIN1 max/min/stored: %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       pin_cmd.pin1.max_length, pin_cmd.pin1.min_length,\n\t       pin_cmd.pin1.stored_length);\n\tsc_log(ctx,\n\t       \"PIN2 max/min/stored: %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       pin_cmd.pin2.max_length, pin_cmd.pin2.min_length,\n\t       pin_cmd.pin2.stored_length);\n\trv = iso_ops->pin_cmd(card, &pin_cmd, tries_left);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\n#if 0\nstatic int\niasecc_chv_set_pinpad(struct sc_card *card, unsigned char reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tunsigned char pin_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Set CHV PINPAD PIN reference %i\", reference);\n\n\tmemset(pin_data, 0xFF, sizeof(pin_data));\n\n\tif (!card->reader || !card->reader->ops || !card->reader->ops->perform_verify)   {\n\t\tsc_log(ctx, \"Reader not ready for PIN PAD\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_READER);\n\t}\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_type = SC_AC_CHV;\n\tpin_cmd.pin_reference = reference;\n\tpin_cmd.cmd = SC_PIN_CMD_UNBLOCK;\n\tpin_cmd.flags |= SC_PIN_CMD_USE_PINPAD;\n\n\trv = iasecc_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\tif ((pin_cmd.pin1.min_length == pin_cmd.pin1.stored_length) && (pin_cmd.pin1.max_length == pin_cmd.pin1.min_length))\n\t\tpin_cmd.pin1.len = pin_cmd.pin1.stored_length;\n\telse\n\t\tpin_cmd.pin1.len = 0;\n\n\tpin_cmd.pin1.length_offset = 5;\n\tpin_cmd.pin1.data = pin_data;\n\n\tmemcpy(&pin_cmd.pin2, &pin_cmd.pin1, sizeof(pin_cmd.pin1));\n\tmemset(&pin_cmd.pin1, 0, sizeof(pin_cmd.pin1));\n\tpin_cmd.flags |= SC_PIN_CMD_IMPLICIT_CHANGE;\n\n\tsc_log(ctx, \"PIN1(max:%i,min:%i)\", pin_cmd.pin1.max_length, pin_cmd.pin1.min_length);\n\tsc_log(ctx, \"PIN2(max:%i,min:%i)\", pin_cmd.pin2.max_length, pin_cmd.pin2.min_length);\n\n\trv = iso_ops->pin_cmd(card, &pin_cmd, NULL);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n#endif\n\n\nstatic int\niasecc_pin_get_policy (struct sc_card *card, struct sc_pin_cmd_data *data)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *save_current_df = NULL, *save_current_ef = NULL;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_path path;\n\tunsigned ii;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_pin_get_policy(card:%p)\", card);\n\n\tif (data->pin_type != SC_AC_CHV)   {\n\t\tsc_log(ctx, \"To unblock PIN it's CHV reference should be presented\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (card->cache.valid && card->cache.current_df)   {\n\t\tsc_file_dup(&save_current_df, card->cache.current_df);\n\t\tif (save_current_df == NULL) {\n\t\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tsc_log(ctx, \"Cannot duplicate current DF file\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tsc_file_dup(&save_current_ef, card->cache.current_ef);\n\t\tif (save_current_ef == NULL) {\n\t\t\trv = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tsc_log(ctx, \"Cannot duplicate current EF file\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!(data->pin_reference & IASECC_OBJECT_REF_LOCAL) && card->cache.valid && card->cache.current_df) {\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\t\trv = iasecc_select_file(card, &path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Unable to select MF\");\n\t}\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_CHV;\n\n\tsdo.sdo_ref = data->pin_reference & ~IASECC_OBJECT_REF_LOCAL;\n\n\tsc_log(ctx, \"iasecc_pin_get_policy() reference %i\", sdo.sdo_ref);\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot get SDO PIN data\");\n\n\tif (sdo.docp.acls_contact.size == 0) {\n\t\trv = SC_ERROR_INVALID_DATA;\n\t\tsc_log(ctx, \"Extremely strange ... there is no ACLs\");\n\t\tgoto err;\n\t}\n\n\tsc_log(ctx,\n\t       \"iasecc_pin_get_policy() sdo.docp.size.size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       sdo.docp.size.size);\n\tfor (ii=0; ii<sizeof(sdo.docp.scbs); ii++)   {\n\t\tstruct iasecc_se_info se;\n\t\tunsigned char scb = sdo.docp.scbs[ii];\n\t\tstruct sc_acl_entry *acl = &data->pin1.acls[ii];\n\t\tint crt_num = 0;\n\n\t\tmemset(&se, 0, sizeof(se));\n\t\tmemset(&acl->crts, 0, sizeof(acl->crts));\n\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() set info acls: SCB 0x%X\", scb);\n\t\t/* acl->raw_value = scb; */\n\t\tacl->method = scb & IASECC_SCB_METHOD_MASK;\n\t\tacl->key_ref = scb & IASECC_SCB_METHOD_MASK_REF;\n\n\t\tif (scb==0 || scb==0xFF)\n\t\t\tcontinue;\n\n\t\tif (se.reference != (int)acl->key_ref)   {\n\t\t\tmemset(&se, 0, sizeof(se));\n\n\t\t\tse.reference = acl->key_ref;\n\n\t\t\trv = iasecc_se_get_info(card, &se);\n\t\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"SDO get data error\");\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\trv = iasecc_se_get_crt_by_usage(card, &se,\n\t\t\t\t\tIASECC_CRT_TAG_AT, IASECC_UQB_AT_USER_PASSWORD, &acl->crts[crt_num]);\n\t\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"no authentication template for 'USER PASSWORD'\");\n\t\t\tsc_log(ctx, \"iasecc_pin_get_policy() scb:0x%X; sdo_ref:[%i,%i,...]\",\n\t\t\t\t\tscb, acl->crts[crt_num].refs[0], acl->crts[crt_num].refs[1]);\n\t\t\tcrt_num++;\n\t\t}\n\n\t\tif (scb & (IASECC_SCB_METHOD_SM | IASECC_SCB_METHOD_EXT_AUTH))   {\n\t\t\tsc_log(ctx, \"'SM' and 'EXTERNAL AUTHENTICATION' protection methods are not supported: SCB:0x%X\", scb);\n\t\t\t/* Set to 'NEVER' if all conditions are needed or\n\t\t\t * there is no user authentication method allowed */\n\t\t\tif (!crt_num || (scb & IASECC_SCB_METHOD_NEED_ALL))\n\t\t\t\tacl->method = SC_AC_NEVER;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsc_file_free(se.df);\n\t}\n\n\tif (sdo.data.chv.size_max.value)\n\t\tdata->pin1.max_length = *sdo.data.chv.size_max.value;\n\tif (sdo.data.chv.size_min.value)\n\t\tdata->pin1.min_length = *sdo.data.chv.size_min.value;\n\tif (sdo.docp.tries_maximum.value)\n\t\tdata->pin1.max_tries = *sdo.docp.tries_maximum.value;\n\tif (sdo.docp.tries_remaining.value)\n\t\tdata->pin1.tries_left = *sdo.docp.tries_remaining.value;\n\tif (sdo.docp.size.value)   {\n\t\tfor (ii=0; ii<sdo.docp.size.size; ii++)\n\t\t\tdata->pin1.stored_length = ((data->pin1.stored_length) << 8) + *(sdo.docp.size.value + ii);\n\t}\n\n\tdata->pin1.encoding = SC_PIN_ENCODING_ASCII;\n\tdata->pin1.offset = 5;\n\tdata->pin1.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tsc_log(ctx,\n\t       \"PIN policy: size max/min %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u, tries max/left %i/%i\",\n\t       data->pin1.max_length, data->pin1.min_length,\n\t       data->pin1.max_tries, data->pin1.tries_left);\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tif (save_current_df)   {\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() restore current DF\");\n\t\trv = iasecc_select_file(card, &save_current_df->path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot return to saved DF\");\n\t}\n\n\tif (save_current_ef)   {\n\t\tsc_log(ctx, \"iasecc_pin_get_policy() restore current EF\");\n\t\trv = iasecc_select_file(card, &save_current_ef->path, NULL);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"Cannot return to saved EF\");\n\t}\n\nerr:\n\tsc_file_free(save_current_df);\n\tsc_file_free(save_current_ef);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_keyset_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_sdo sdo;\n\tunsigned scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change keyset(ref:%i,lengths:%i)\", data->pin_reference, data->pin2.len);\n\tif (!data->pin2.data || data->pin2.len < 32)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Needs at least 32 bytes for a new keyset value\");\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_KEYSET;\n\tsdo.sdo_ref  = data->pin_reference;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get keyset data\");\n\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\tscb = sdo.docp.scbs[IASECC_ACLS_KEYSET_PUT_DATA];\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tsc_log(ctx, \"SCB:0x%X\", scb);\n\tif (!(scb & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Other then protected by SM, the keyset change is not supported\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo.sdo_class;\n\tupdate.sdo_ref = sdo.sdo_ref;\n\n\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[0].tag = IASECC_SDO_KEYSET_TAG_MAC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[0].value = (unsigned char *) data->pin2.data;\n\tupdate.fields[0].size = 16;\n\n\tupdate.fields[1].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[1].tag = IASECC_SDO_KEYSET_TAG_ENC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[1].value = (unsigned char *) data->pin2.data + 16;\n\tupdate.fields[1].size = 16;\n\n\trv = iasecc_sm_sdo_update(card, (scb & IASECC_SCB_METHOD_MASK_REF), &update);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned reference = data->pin_reference;\n\tunsigned char pin_data[0x100];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change PIN(ref:%i,type:0x%X,lengths:%i/%i)\", reference, data->pin_type, data->pin1.len, data->pin2.len);\n\n\tif ((card->reader->capabilities & SC_READER_CAP_PIN_PAD))   {\n\t\tif (!data->pin1.data && !data->pin1.len && !data->pin2.data && !data->pin2.len)   {\n\t\t\trv = iasecc_chv_change_pinpad(card, reference, tries_left);\n\t\t\tsc_log(ctx, \"iasecc_pin_cmd(SC_PIN_CMD_CHANGE) chv_change_pinpad returned %i\", rv);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tif (!data->pin1.data && data->pin1.len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid PIN1 arguments\");\n\n\tif (!data->pin2.data && data->pin2.len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid PIN2 arguments\");\n\n\trv = iasecc_pin_verify(card, data->pin_type, reference, data->pin1.data, data->pin1.len, tries_left);\n\tsc_log(ctx, \"iasecc_pin_cmd(SC_PIN_CMD_CHANGE) pin_verify returned %i\", rv);\n\tLOG_TEST_RET(ctx, rv, \"PIN verification error\");\n\n\tif ((unsigned)(data->pin1.len + data->pin2.len) > sizeof(pin_data))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small for the 'Change PIN' data\");\n\n\tif (data->pin1.data)\n\t\tmemcpy(pin_data, data->pin1.data, data->pin1.len);\n\tif (data->pin2.data)\n\t\tmemcpy(pin_data + data->pin1.len, data->pin2.data, data->pin2.len);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x24, 0, reference);\n\tapdu.data = pin_data;\n\tapdu.datalen = data->pin1.len + data->pin2.len;\n\tapdu.lc = apdu.datalen;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_reset(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_file *save_current = NULL;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_apdu apdu;\n\tunsigned reference, scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Reset PIN(ref:%i,lengths:%i/%i)\", data->pin_reference, data->pin1.len, data->pin2.len);\n\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Unblock procedure can be used only with the PINs of type CHV\");\n\n\treference = data->pin_reference;\n\n\tif (!(data->pin_reference & IASECC_OBJECT_REF_LOCAL) && card->cache.valid && card->cache.current_df)  {\n\t\tstruct sc_path path;\n\n\t\tsc_file_dup(&save_current, card->cache.current_df);\n\t\tif (save_current == NULL)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot duplicate current DF file\");\n\n\t\tsc_format_path(\"3F00\", &path);\n\t\tpath.type = SC_PATH_TYPE_FILE_ID;\n\t\trv = iasecc_select_file(card, &path, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"Unable to select MF\");\n\t}\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_CHV;\n\tsdo.sdo_ref = reference & ~IASECC_OBJECT_REF_LOCAL;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get PIN data\");\n\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Extremely strange ... there are no ACLs\");\n\n\tscb = sdo.docp.scbs[IASECC_ACLS_CHV_RESET];\n\tdo   {\n\t\tunsigned need_all = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\t\tunsigned char se_num = scb & IASECC_SCB_METHOD_MASK_REF;\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)   {\n\t\t\tsc_log(ctx, \"Verify PIN in SE %X\", se_num);\n\t\t\trv = iasecc_pin_verify(card, SC_AC_SEN, se_num, data->pin1.data, data->pin1.len, tries_left);\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_pin_reset() verify PUK error\");\n\n\t\t\tif (!need_all)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n\t\t\trv = iasecc_sm_pin_reset(card, se_num, data);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)   {\n\t\t\trv =  iasecc_sm_external_authentication(card, reference, tries_left);\n\t\t\tLOG_TEST_RET(ctx, rv, \"iasecc_pin_reset() external authentication error\");\n\t\t}\n\t} while(0);\n\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tif (data->pin2.len)   {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value\", reference);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2C, 0x02, reference);\n\t\tapdu.data = data->pin2.data;\n\t\tapdu.datalen = data->pin2.len;\n\t\tapdu.lc = apdu.datalen;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse if (data->pin2.data) {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value\", reference);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x2C, 3, reference);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse   {\n\t\tsc_log(ctx, \"Reset PIN %X and set new value with PIN-PAD\", reference);\n#if 0\n\t\trv = iasecc_chv_set_pinpad(card, reference);\n\t\tLOG_TEST_RET(ctx, rv, \"Reset PIN failed\");\n#else\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Reset retry counter with PIN PAD not supported \");\n#endif\n\t}\n\n\tif (save_current)   {\n\t\trv = iasecc_select_file(card, &save_current->path, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot return to saved PATH\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_pin_cmd(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_pin_cmd() cmd 0x%X, PIN type 0x%X, PIN reference %i, PIN-1 %p:%i, PIN-2 %p:%i\",\n\t\t\tdata->cmd, data->pin_type, data->pin_reference,\n\t\t\tdata->pin1.data, data->pin1.len, data->pin2.data, data->pin2.len);\n\n\tswitch (data->cmd)   {\n\tcase SC_PIN_CMD_VERIFY:\n\t\trv = iasecc_pin_verify(card, data->pin_type, data->pin_reference, data->pin1.data, data->pin1.len, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_CHANGE:\n\t\tif (data->pin_type == SC_AC_AUT)\n\t\t\trv = iasecc_keyset_change(card, data, tries_left);\n\t\telse\n\t\t\trv = iasecc_pin_change(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_UNBLOCK:\n\t\trv = iasecc_pin_reset(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_GET_INFO:\n\t\trv = iasecc_pin_get_policy(card, data);\n\t\tbreak;\n\tdefault:\n\t\tsc_log(ctx, \"Other pin commands not supported yet: 0x%X\", data->cmd);\n\t\trv = SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_iin *iin = &card->serialnr.iin;\n\tstruct sc_apdu apdu;\n\tunsigned char rbuf[0xC0];\n\tsize_t ii, offs;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (card->serialnr.len)\n\t\tgoto end;\n\n\tmemset(&card->serialnr, 0, sizeof(card->serialnr));\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);\n\tapdu.le = sizeof(rbuf);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Get 'serial number' data failed\");\n\n\tif (rbuf[0] != ISO7812_PAN_SN_TAG)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"serial number parse error\");\n\n\tiin->mii = (rbuf[2] >> 4) & 0x0F;\n\n\tiin->country = 0;\n\tfor (ii=5; ii<8; ii++)   {\n\t\tiin->country *= 10;\n\t\tiin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;\n\t}\n\n\tiin->issuer_id = 0;\n\tfor (ii=8; ii<10; ii++)   {\n\t\tiin->issuer_id *= 10;\n\t\tiin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;\n\t}\n\n\toffs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;\n\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {\n\t\t/* 5A 0A 92 50 00 20 10 10 25 00 01 3F */\n\t\t/*            00 02 01 01 02 50 00 13  */\n\t\tfor (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)\n\t\t\t*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)\n\t\t\t\t+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;\n\t\tcard->serialnr.len = ii;\n\t}\n\telse   {\n\t\tfor (ii=0; ii < rbuf[1] - offs; ii++)\n\t\t\t*(card->serialnr.value + ii) = rbuf[ii + offs + 2];\n\t\tcard->serialnr.len = ii;\n\t}\n\n\tdo  {\n\t\tchar txt[0x200];\n\n\t\tfor (ii=0;ii<card->serialnr.len;ii++)\n\t\t\tsprintf(txt + ii*2, \"%02X\", *(card->serialnr.value + ii));\n\n\t\tsc_log(ctx, \"serial number '%s'; mii %i; country %i; issuer_id %li\", txt, iin->mii, iin->country, iin->issuer_id);\n\t} while(0);\n\nend:\n\tif (serial)\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_create(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char *data = NULL, sdo_class = sdo->sdo_class;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_extended_tlv *field = NULL;\n\tint rv = SC_ERROR_NOT_SUPPORTED, data_len;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (sdo->magic != SC_CARDCTL_IASECC_SDO_MAGIC)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO data\");\n\n\tsc_log(ctx, \"iasecc_sdo_create(card:%p) %02X%02X%02X\", card,\n\t\t\tIASECC_SDO_TAG_HEADER, sdo->sdo_class | 0x80, sdo->sdo_ref);\n\n\tdata_len = iasecc_sdo_encode_create(ctx, sdo, &data);\n\tLOG_TEST_RET(ctx, data_len, \"iasecc_sdo_create() cannot encode SDO create data\");\n\tsc_log(ctx, \"iasecc_sdo_create() create data(%i):%s\", data_len, sc_dump_hex(data, data_len));\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\tapdu.data = data;\n\tapdu.datalen = data_len;\n\tapdu.lc = data_len;\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_sdo_create() SDO put data error\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo->sdo_class;\n\tupdate.sdo_ref = sdo->sdo_ref;\n\n\tif (sdo_class == IASECC_SDO_CLASS_RSA_PRIVATE)   {\n\t\tupdate.fields[0] = sdo->data.prv_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PRVKEY_TAG;\n\t\tfield = &sdo->data.prv_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_RSA_PUBLIC)   {\n\t\tupdate.fields[0] = sdo->data.pub_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PUBKEY_TAG;\n\t\tfield = &sdo->data.pub_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_KEYSET)   {\n\t\tupdate.fields[0] = sdo->data.keyset.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\t\tfield = &sdo->data.keyset.compulsory;\n\t}\n\n\tif (update.fields[0].value && !update.fields[0].on_card)   {\n\t\trv = iasecc_sdo_put_data(card, &update);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update 'Compulsory usage' data\");\n\n\t\tif (field)\n\t\t\tfield->on_card = 1;\n\t}\n\n\tfree(data);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n/* Oberthur's specific */\nstatic int\niasecc_sdo_delete(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char data[6] = {\n\t\t0x70, 0x04, 0xBF, 0xFF, 0xFF, 0x00\n\t};\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (sdo->magic != SC_CARDCTL_IASECC_SDO_MAGIC)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO data\");\n\n\tdata[2] = IASECC_SDO_TAG_HEADER;\n\tdata[3] = sdo->sdo_class | 0x80;\n\tdata[4] = sdo->sdo_ref;\n\tsc_log(ctx, \"delete SDO %02X%02X%02X\", data[2], data[3], data[4]);\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\tapdu.data = data;\n\tapdu.datalen = sizeof(data);\n\tapdu.lc = sizeof(data);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"delete SDO error\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_put_data(struct sc_card *card, struct iasecc_sdo_update *update)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint ii, rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (update->magic != SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO update data\");\n\n\tfor(ii=0; update->fields[ii].tag && ii < IASECC_SDO_TAGS_UPDATE_MAX; ii++)   {\n\t\tunsigned char *encoded = NULL;\n\t\tint encoded_len;\n\n\t\tencoded_len = iasecc_sdo_encode_update_field(ctx, update->sdo_class, update->sdo_ref,\n\t\t\t\t\t\t\t&update->fields[ii], &encoded);\n\t\tsc_log(ctx, \"iasecc_sdo_put_data() encode[%i]; tag %X; encoded_len %i\", ii, update->fields[ii].tag, encoded_len);\n\t\tLOG_TEST_RET(ctx, encoded_len, \"Cannot encode update data\");\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\t\tapdu.data = encoded;\n\t\tapdu.datalen = encoded_len;\n\t\tapdu.lc = encoded_len;\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"SDO put data error\");\n\n\t\tfree(encoded);\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_key_rsa_put_data(struct sc_card *card, struct iasecc_sdo_rsa_update *update)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (update->sdo_prv_key)   {\n\t\tsc_log(ctx, \"encode private rsa in %p\", &update->update_prv);\n\t\trv = iasecc_sdo_encode_rsa_update(card->ctx, update->sdo_prv_key, update->p15_rsa, &update->update_prv);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to encode update of RSA private key\");\n\t}\n\n\tif (update->sdo_pub_key)   {\n\t\tsc_log(ctx, \"encode public rsa in %p\", &update->update_pub);\n\t\tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {\n\t\t\tif (update->sdo_pub_key->data.pub_key.cha.value)   {\n\t\t\t\tfree(update->sdo_pub_key->data.pub_key.cha.value);\n\t\t\t\tmemset(&update->sdo_pub_key->data.pub_key.cha, 0, sizeof(update->sdo_pub_key->data.pub_key.cha));\n\t\t\t}\n\t\t}\n\t\trv = iasecc_sdo_encode_rsa_update(card->ctx, update->sdo_pub_key, update->p15_rsa, &update->update_pub);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to encode update of RSA public key\");\n\t}\n\n\tif (update->sdo_prv_key)   {\n\t\tsc_log(ctx, \"reference of the private key to store: %X\", update->sdo_prv_key->sdo_ref);\n\n\t\tif (update->sdo_prv_key->docp.acls_contact.size == 0)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"extremely strange ... there are no ACLs\");\n\n\t\tscb = update->sdo_prv_key->docp.scbs[IASECC_ACLS_RSAKEY_PUT_DATA];\n\t\tsc_log(ctx, \"'UPDATE PRIVATE RSA' scb 0x%X\", scb);\n\n\t\tdo   {\n\t\t\tunsigned all_conditions = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\n\t\t\tif ((scb & IASECC_SCB_METHOD_USER_AUTH) && !all_conditions)\n\t\t\t\tbreak;\n\n\t\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\t\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n#ifdef ENABLE_SM\n\t\t\t\trv = iasecc_sm_rsa_update(card, scb & IASECC_SCB_METHOD_MASK_REF, update);\n\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n#else\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"built without support of Secure-Messaging\");\n#endif\n\t\t\t}\n\t\t} while(0);\n\n\t\trv = iasecc_sdo_put_data(card, &update->update_prv);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update of RSA private key\");\n\t}\n\n\tif (update->sdo_pub_key)   {\n\t\tsc_log(ctx, \"reference of the public key to store: %X\", update->sdo_pub_key->sdo_ref);\n\n\t\trv = iasecc_sdo_put_data(card, &update->update_pub);\n\t\tLOG_TEST_RET(ctx, rv, \"failed to update of RSA public key\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_sdo_tag_from_class(unsigned sdo_class)\n{\n\tswitch (sdo_class & ~IASECC_OBJECT_REF_LOCAL)   {\n\tcase IASECC_SDO_CLASS_CHV:\n\t\treturn IASECC_SDO_CHV_TAG;\n\tcase IASECC_SDO_CLASS_RSA_PRIVATE:\n\t\treturn IASECC_SDO_PRVKEY_TAG;\n\tcase IASECC_SDO_CLASS_RSA_PUBLIC:\n\t\treturn IASECC_SDO_PUBKEY_TAG;\n\tcase IASECC_SDO_CLASS_SE:\n\t\treturn IASECC_SDO_CLASS_SE;\n\tcase IASECC_SDO_CLASS_KEYSET:\n\t\treturn IASECC_SDO_KEYSET_TAG;\n\t}\n\n\treturn -1;\n}\n\n\nstatic int\niasecc_sdo_get_tagged_data(struct sc_card *card, int sdo_tag, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[0x100];\n\tsize_t offs = sizeof(sbuf) - 1;\n\tunsigned char rbuf[0x400];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tsbuf[offs--] = 0x80;\n\tsbuf[offs--] = sdo_tag & 0xFF;\n\tif ((sdo_tag >> 8) & 0xFF)\n\t\tsbuf[offs--] = (sdo_tag >> 8) & 0xFF;\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\n\tsbuf[offs--] = sdo->sdo_ref & 0x9F;\n\tsbuf[offs--] = sdo->sdo_class | IASECC_OBJECT_REF_LOCAL;\n\tsbuf[offs--] = IASECC_SDO_TAG_HEADER;\n\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\tsbuf[offs--] = IASECC_SDO_TEMPLATE_TAG;\n\n\tsbuf[offs] = sizeof(sbuf) - offs - 1;\n\toffs--;\n\tsbuf[offs] = 0x4D;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xCB, 0x3F, 0xFF);\n\tapdu.data = sbuf + offs;\n\tapdu.datalen = sizeof(sbuf) - offs;\n\tapdu.lc = sizeof(sbuf) - offs;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\trv = iasecc_sdo_parse(card, apdu.resp, apdu.resplen, sdo);\n\tLOG_TEST_RET(ctx, rv, \"cannot parse SDO data\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_get_data(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv, sdo_tag;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tsdo_tag = iasecc_sdo_tag_from_class(sdo->sdo_class);\n\n\trv = iasecc_sdo_get_tagged_data(card, sdo_tag, sdo);\n\t/* When there is no public data 'GET DATA' returns error */\n\tif (rv != SC_ERROR_INCORRECT_PARAMETERS)\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse ECC SDO data\");\n\n\trv = iasecc_sdo_get_tagged_data(card, IASECC_DOCP_TAG, sdo);\n\tLOG_TEST_RET(ctx, rv, \"cannot parse ECC DOCP data\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_sdo_generate(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update_pubkey;\n\tstruct sc_apdu apdu;\n\tunsigned char scb, sbuf[5], rbuf[0x400], exponent[3] = {0x01, 0x00, 0x01};\n\tint offs = 0, rv = SC_ERROR_NOT_SUPPORTED;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (sdo->sdo_class != IASECC_SDO_CLASS_RSA_PRIVATE)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"For a moment, only RSA_PRIVATE class can be accepted for the SDO generation\");\n\n\tif (sdo->docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\n\tscb = sdo->docp.scbs[IASECC_ACLS_RSAKEY_GENERATE];\n\tsc_log(ctx, \"'generate RSA key' SCB 0x%X\", scb);\n\tdo   {\n\t\tunsigned all_conditions = scb & IASECC_SCB_METHOD_NEED_ALL ? 1 : 0;\n\n\t\tif (scb & IASECC_SCB_METHOD_USER_AUTH)\n\t\t\tif (!all_conditions)\n\t\t\t\tbreak;\n\n\t\tif (scb & IASECC_SCB_METHOD_EXT_AUTH)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\t\tif (scb & IASECC_SCB_METHOD_SM)   {\n\t\t\trv = iasecc_sm_rsa_generate(card, scb & IASECC_SCB_METHOD_MASK_REF, sdo);\n                        LOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t} while(0);\n\n\tmemset(&update_pubkey, 0, sizeof(update_pubkey));\n\tupdate_pubkey.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate_pubkey.sdo_class = IASECC_SDO_CLASS_RSA_PUBLIC;\n\tupdate_pubkey.sdo_ref = sdo->sdo_ref;\n\n\tupdate_pubkey.fields[0].parent_tag = IASECC_SDO_PUBKEY_TAG;\n\tupdate_pubkey.fields[0].tag = IASECC_SDO_PUBKEY_TAG_E;\n\tupdate_pubkey.fields[0].value = exponent;\n\tupdate_pubkey.fields[0].size = sizeof(exponent);\n\n\trv = iasecc_sdo_put_data(card, &update_pubkey);\n\tLOG_TEST_RET(ctx, rv, \"iasecc_sdo_generate() update SDO public key failed\");\n\n\toffs = 0;\n\tsbuf[offs++] = IASECC_SDO_TEMPLATE_TAG;\n\tsbuf[offs++] = 0x03;\n\tsbuf[offs++] = IASECC_SDO_TAG_HEADER;\n\tsbuf[offs++] = IASECC_SDO_CLASS_RSA_PRIVATE | IASECC_OBJECT_REF_LOCAL;\n\tsbuf[offs++] = sdo->sdo_ref & ~IASECC_OBJECT_REF_LOCAL;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x47, 0x00, 0x00);\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"SDO get data error\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_get_chv_reference_from_se(struct sc_card *card, int *se_reference)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_se_info se;\n\tstruct sc_crt crt;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!se_reference)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid arguments\");\n\n\tmemset(&se, 0, sizeof(se));\n\tse.reference = *se_reference;\n\n\trv = iasecc_se_get_info(card, &se);\n\tLOG_TEST_RET(ctx, rv, \"get SE info error\");\n\n\tmemset(&crt, 0, sizeof(crt));\n\tcrt.tag = IASECC_CRT_TAG_AT;\n\tcrt.usage = IASECC_UQB_AT_USER_PASSWORD;\n\n\trv = iasecc_se_get_crt(card, &se, &crt);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get 'USER PASSWORD' authentication template\");\n\n\tsc_file_free(se.df);\n\tLOG_FUNC_RETURN(ctx, crt.refs[0]);\n}\n\n\nstatic int\niasecc_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo *sdo = (struct iasecc_sdo *) ptr;\n\n\tswitch (cmd) {\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn iasecc_get_serialnr(card, (struct sc_serial_number *)ptr);\n\tcase SC_CARDCTL_IASECC_SDO_CREATE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_CREATE: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_create(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_DELETE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_DELETE: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_delete(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_PUT_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_PUT_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_put_data(card, (struct iasecc_sdo_update *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_KEY_RSA_PUT_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_KEY_RSA_PUT_DATA\");\n\t\treturn iasecc_sdo_key_rsa_put_data(card, (struct iasecc_sdo_rsa_update *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_GET_DATA:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_GET_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_get_data(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_IASECC_SDO_GENERATE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_SDO_GET_DATA: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_sdo_generate(card, (struct iasecc_sdo *) ptr);\n\tcase SC_CARDCTL_GET_SE_INFO:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_GET_SE_INFO: sdo_class %X\", sdo->sdo_class);\n\t\treturn iasecc_se_get_info(card, (struct iasecc_se_info *) ptr);\n\tcase SC_CARDCTL_GET_CHV_REFERENCE_IN_SE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_GET_CHV_REFERENCE_IN_SE\");\n\t\treturn iasecc_get_chv_reference_from_se(card, (int *)ptr);\n\tcase SC_CARDCTL_IASECC_GET_FREE_KEY_REFERENCE:\n\t\tsc_log(ctx, \"CMD SC_CARDCTL_IASECC_GET_FREE_KEY_REFERENCE\");\n\t\treturn iasecc_get_free_reference(card, (struct iasecc_ctl_get_free_reference *)ptr);\n\t}\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n\nstatic int\niasecc_decipher(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len,\n\t\tunsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[0x200];\n\tunsigned char resp[SC_MAX_APDU_BUFFER_SIZE];\n\tsize_t offs;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(card->ctx,\n\t       \"crgram_len %\"SC_FORMAT_LEN_SIZE_T\"u;  outlen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len, out_len);\n\tif (!out || !out_len || in_len > SC_MAX_APDU_BUFFER_SIZE)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\toffs = 0;\n\tsbuf[offs++] = 0x81;\n\tmemcpy(sbuf + offs, in, in_len);\n\toffs += in_len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\tapdu.resp = resp;\n\tapdu.resplen = sizeof(resp);\n\tapdu.le = 256;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Card returned error\");\n\n\tif (out_len > apdu.resplen)\n\t\tout_len = apdu.resplen;\n\n\tmemcpy(out, apdu.resp, out_len);\n\trv = out_len;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\n\nstatic int\niasecc_qsign_data_sha1(struct sc_context *ctx, const unsigned char *in, size_t in_len,\n\t\t\t\tstruct iasecc_qsign_data *out)\n{\n\tSHA_CTX sha;\n\tSHA_LONG pre_hash_Nl, *hh[5] = {\n\t\t&sha.h0, &sha.h1, &sha.h2, &sha.h3, &sha.h4\n\t};\n\tint jj, ii;\n\tint hh_size = sizeof(SHA_LONG), hh_num = SHA_DIGEST_LENGTH / sizeof(SHA_LONG);\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!in || !in_len || !out)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx,\n\t       \"sc_pkcs15_get_qsign_data() input data length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tmemset(out, 0, sizeof(struct iasecc_qsign_data));\n\n\tSHA1_Init(&sha);\n\tSHA1_Update(&sha, in, in_len);\n\n\tfor (jj=0; jj<hh_num; jj++)\n\t\tfor(ii=0; ii<hh_size; ii++)\n\t\t\tout->pre_hash[jj*hh_size + ii] = ((*hh[jj] >> 8*(hh_size-1-ii)) & 0xFF);\n\tout->pre_hash_size = SHA_DIGEST_LENGTH;\n\tsc_log(ctx, \"Pre SHA1:%s\", sc_dump_hex(out->pre_hash, out->pre_hash_size));\n\n\tpre_hash_Nl = sha.Nl - (sha.Nl % (sizeof(sha.data) * 8));\n\tfor (ii=0; ii<hh_size; ii++)   {\n\t\tout->counter[ii] = (sha.Nh >> 8*(hh_size-1-ii)) &0xFF;\n\t\tout->counter[hh_size+ii] = (pre_hash_Nl >> 8*(hh_size-1-ii)) &0xFF;\n\t}\n\tfor (ii=0, out->counter_long=0; ii<(int)sizeof(out->counter); ii++)\n\t\tout->counter_long = out->counter_long*0x100 + out->counter[ii];\n\tsc_log(ctx, \"Pre counter(%li):%s\", out->counter_long, sc_dump_hex(out->counter, sizeof(out->counter)));\n\n\tif (sha.num)   {\n\t\tmemcpy(out->last_block, in + in_len - sha.num, sha.num);\n\t\tout->last_block_size = sha.num;\n\t\tsc_log(ctx, \"Last block(%\"SC_FORMAT_LEN_SIZE_T\"u):%s\",\n\t\t       out->last_block_size,\n\t\t       sc_dump_hex(out->last_block, out->last_block_size));\n\t}\n\n\tSHA1_Final(out->hash, &sha);\n\tout->hash_size = SHA_DIGEST_LENGTH;\n\tsc_log(ctx, \"Expected digest %s\\n\", sc_dump_hex(out->hash, out->hash_size));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\n#if OPENSSL_VERSION_NUMBER >= 0x00908000L\nstatic int\niasecc_qsign_data_sha256(struct sc_context *ctx, const unsigned char *in, size_t in_len,\n\t\t\t\tstruct iasecc_qsign_data *out)\n{\n\tSHA256_CTX sha256;\n\tSHA_LONG pre_hash_Nl;\n\tint jj, ii;\n\tint hh_size = sizeof(SHA_LONG), hh_num = SHA256_DIGEST_LENGTH / sizeof(SHA_LONG);\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in || !in_len || !out)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx,\n\t       \"sc_pkcs15_get_qsign_data() input data length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tmemset(out, 0, sizeof(struct iasecc_qsign_data));\n\n\tSHA256_Init(&sha256);\n\tSHA256_Update(&sha256, in, in_len);\n\n\tfor (jj=0; jj<hh_num; jj++)\n\t\tfor(ii=0; ii<hh_size; ii++)\n\t\t\tout->pre_hash[jj*hh_size + ii] = ((sha256.h[jj] >> 8*(hh_size-1-ii)) & 0xFF);\n\tout->pre_hash_size = SHA256_DIGEST_LENGTH;\n\tsc_log(ctx, \"Pre hash:%s\", sc_dump_hex(out->pre_hash, out->pre_hash_size));\n\n\tpre_hash_Nl = sha256.Nl - (sha256.Nl % (sizeof(sha256.data) * 8));\n\tfor (ii=0; ii<hh_size; ii++)   {\n\t\tout->counter[ii] = (sha256.Nh >> 8*(hh_size-1-ii)) &0xFF;\n\t\tout->counter[hh_size+ii] = (pre_hash_Nl >> 8*(hh_size-1-ii)) &0xFF;\n\t}\n\tfor (ii=0, out->counter_long=0; ii<(int)sizeof(out->counter); ii++)\n\t\tout->counter_long = out->counter_long*0x100 + out->counter[ii];\n\tsc_log(ctx, \"Pre counter(%li):%s\", out->counter_long, sc_dump_hex(out->counter, sizeof(out->counter)));\n\n\tif (sha256.num)   {\n\t\tmemcpy(out->last_block, in + in_len - sha256.num, sha256.num);\n\t\tout->last_block_size = sha256.num;\n\t\tsc_log(ctx, \"Last block(%\"SC_FORMAT_LEN_SIZE_T\"u):%s\",\n\t\t       out->last_block_size,\n\t\t       sc_dump_hex(out->last_block, out->last_block_size));\n\t}\n\n\tSHA256_Final(out->hash, &sha256);\n\tout->hash_size = SHA256_DIGEST_LENGTH;\n\tsc_log(ctx, \"Expected digest %s\\n\", sc_dump_hex(out->hash, out->hash_size));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n#endif\n\n\nstatic int\niasecc_compute_signature_dst(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_security_env *env = &prv->security_env;\n\tstruct iasecc_qsign_data qsign_data;\n\tstruct sc_apdu apdu;\n\tsize_t offs = 0, hash_len = 0;\n\tunsigned char sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv = SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() input length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len);\n\tif (env->operation != SC_SEC_OPERATION_SIGN)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"It's not SC_SEC_OPERATION_SIGN\");\n\telse if (!(prv->key_size & 0x1E0) || (prv->key_size & ~0x1E0))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid key size for SC_SEC_OPERATION_SIGN\");\n\n\tmemset(&qsign_data, 0, sizeof(qsign_data));\n\tif (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)   {\n\t\trv = iasecc_qsign_data_sha1(card->ctx, in, in_len, &qsign_data);\n\t}\n\telse if (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA256)   {\n#if OPENSSL_VERSION_NUMBER >= 0x00908000L\n\t\trv = iasecc_qsign_data_sha256(card->ctx, in, in_len, &qsign_data);\n#else\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"SHA256 is not supported by OpenSSL previous to v0.9.8\");\n#endif\n\t}\n\telse\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_HASH_SHA1 or RSA_HASH_SHA256 algorithm\");\n\tLOG_TEST_RET(ctx, rv, \"Cannot get QSign data\");\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() hash_len %\"SC_FORMAT_LEN_SIZE_T\"u; key_size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       hash_len, prv->key_size);\n\n\tmemset(sbuf, 0, sizeof(sbuf));\n\tsbuf[offs++] = 0x90;\n\tif (qsign_data.counter_long)   {\n\t\tsbuf[offs++] = qsign_data.hash_size + 8;\n\t\tmemcpy(sbuf + offs, qsign_data.pre_hash, qsign_data.pre_hash_size);\n\t\toffs += qsign_data.pre_hash_size;\n\t\tmemcpy(sbuf + offs, qsign_data.counter, sizeof(qsign_data.counter));\n\t\toffs += sizeof(qsign_data.counter);\n\t}\n\telse   {\n\t\tsbuf[offs++] = 0;\n\t}\n\n\tsbuf[offs++] = 0x80;\n\tsbuf[offs++] = qsign_data.last_block_size;\n\tmemcpy(sbuf + offs, qsign_data.last_block, qsign_data.last_block_size);\n\toffs += qsign_data.last_block_size;\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() offs %\"SC_FORMAT_LEN_SIZE_T\"u; OP(meth:%X,ref:%X)\",\n\t       offs, prv->op_method, prv->op_ref);\n\tif (prv->op_method == SC_AC_SCB && (prv->op_ref & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Not yet\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2A, 0x90, 0xA0);\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tsc_log(ctx, \"iasecc_compute_signature_dst() partial hash OK\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x2A, 0x9E, 0x9A);\n\tapdu.resp = rbuf;\n\tapdu.resplen = prv->key_size;\n\tapdu.le = prv->key_size;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tsc_log(ctx,\n\t       \"iasecc_compute_signature_dst() DST resplen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       apdu.resplen);\n\tif (apdu.resplen > out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Result buffer too small for the DST signature\");\n\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\n\nstatic int\niasecc_compute_signature_at(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tstruct sc_security_env *env = &prv->security_env;\n\tstruct sc_apdu apdu;\n\tsize_t offs = 0, sz = 0;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (env->operation != SC_SEC_OPERATION_AUTHENTICATE)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"It's not SC_SEC_OPERATION_AUTHENTICATE\");\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x88, 0x00, 0x00);\n\tapdu.datalen = in_len;\n\tapdu.data = in;\n\tapdu.lc = in_len;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0x100;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Compute signature failed\");\n\n\tdo   {\n\t\tif (offs + apdu.resplen > out_len)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Buffer too small to return signature\");\n\n\t\tmemcpy(out + offs, rbuf, apdu.resplen);\n\t\toffs += apdu.resplen;\n\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\t\tbreak;\n\n\t\tif (apdu.sw1 == 0x61)   {\n\t\t\tsz = apdu.sw2 == 0x00 ? 0x100 : apdu.sw2;\n\t\t\trv = iso_ops->get_response(card, &sz, rbuf);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get response error\");\n\n\t\t\tapdu.resplen = rv;\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"Impossible error: SW1 is not 0x90 neither 0x61\");\n\t\t}\n\n\t} while(rv > 0);\n\n\tLOG_FUNC_RETURN(ctx, offs);\n}\n\n\nstatic int\niasecc_compute_signature(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len, unsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx;\n\tstruct iasecc_private_data *prv;\n\tstruct sc_security_env *env;\n\n\tif (!card || !in || !out)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tctx = card->ctx;\n\tprv = (struct iasecc_private_data *) card->drv_data;\n\tenv = &prv->security_env;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"inlen %\"SC_FORMAT_LEN_SIZE_T\"u, outlen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len, out_len);\n\n\tif (env->operation == SC_SEC_OPERATION_SIGN)\n\t\treturn iasecc_compute_signature_dst(card, in, in_len, out,  out_len);\n\telse if (env->operation == SC_SEC_OPERATION_AUTHENTICATE)\n\t\treturn iasecc_compute_signature_at(card, in, in_len, out,  out_len);\n\n\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\n\nstatic int\niasecc_read_public_key(struct sc_card *card, unsigned type,\n\t\tstruct sc_path *key_path, unsigned ref, unsigned size,\n\t\tunsigned char **out, size_t *out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo sdo;\n\tstruct sc_pkcs15_bignum bn[2];\n\tstruct sc_pkcs15_pubkey_rsa rsa_key;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (type != SC_ALGORITHM_RSA)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tsc_log(ctx, \"read public kay(ref:%i;size:%i)\", ref, size);\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_RSA_PUBLIC;\n\tsdo.sdo_ref  = ref & ~IASECC_OBJECT_REF_LOCAL;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"failed to read public key: cannot get RSA SDO data\");\n\n\tif (out)\n\t\t*out = NULL;\n\tif (out_len)\n\t\t*out_len = 0;\n\n\tbn[0].data = (unsigned char *) malloc(sdo.data.pub_key.n.size);\n\tif (!bn[0].data)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"failed to read public key: cannot allocate modulus\");\n\tbn[0].len = sdo.data.pub_key.n.size;\n\tmemcpy(bn[0].data, sdo.data.pub_key.n.value, sdo.data.pub_key.n.size);\n\n\tbn[1].data = (unsigned char *) malloc(sdo.data.pub_key.e.size);\n\tif (!bn[1].data)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"failed to read public key: cannot allocate exponent\");\n\tbn[1].len = sdo.data.pub_key.e.size;\n\tmemcpy(bn[1].data, sdo.data.pub_key.e.value, sdo.data.pub_key.e.size);\n\n\trsa_key.modulus = bn[0];\n\trsa_key.exponent = bn[1];\n\n\trv = sc_pkcs15_encode_pubkey_rsa(ctx, &rsa_key, out, out_len);\n\tLOG_TEST_RET(ctx, rv, \"failed to read public key: cannot encode RSA public key\");\n\n\tif (out && out_len)\n\t\tsc_log(ctx, \"encoded public key: %s\", sc_dump_hex(*out, *out_len));\n\n\tif (bn[0].data)\n\t\tfree(bn[0].data);\n\tif (bn[1].data)\n\t\tfree(bn[1].data);\n\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic int\niasecc_get_free_reference(struct sc_card *card, struct iasecc_ctl_get_free_reference *ctl_data)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo *sdo = NULL;\n\tint idx, rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif ((ctl_data->key_size % 0x40) || ctl_data->index < 1 || (ctl_data->index > IASECC_OBJECT_REF_MAX))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx, \"get reference for key(index:%i,usage:%X,access:%X)\", ctl_data->index, ctl_data->usage, ctl_data->access);\n\t/* TODO: when looking for the slot for the signature keys, check also PSO_SIGNATURE ACL */\n\tfor (idx = ctl_data->index; idx <= IASECC_OBJECT_REF_MAX; idx++)   {\n\t\tunsigned char sdo_tag[3] = {\n\t\t\tIASECC_SDO_TAG_HEADER, IASECC_OBJECT_REF_LOCAL | IASECC_SDO_CLASS_RSA_PRIVATE, idx\n\t\t};\n\t\tsize_t sz;\n\n\t\tif (sdo)\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\trv = iasecc_sdo_allocate_and_parse(card, sdo_tag, 3, &sdo);\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse SDO data\");\n\n\t\trv = iasecc_sdo_get_data(card, sdo);\n\t\tif (rv == SC_ERROR_DATA_OBJECT_NOT_FOUND)   {\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\t\tsc_log(ctx, \"found empty key slot %i\", idx);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tLOG_TEST_RET(ctx, rv, \"get new key reference failed\");\n\n\t\tsz = *(sdo->docp.size.value + 0) * 0x100 + *(sdo->docp.size.value + 1);\n\t\tsc_log(ctx,\n\t\t       \"SDO(idx:%i) size %\"SC_FORMAT_LEN_SIZE_T\"u; key_size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       idx, sz, ctl_data->key_size);\n\n\t\tif (sz != ctl_data->key_size / 8)   {\n\t\t\tsc_log(ctx,\n\t\t\t       \"key index %i ignored: different key sizes %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       idx, sz, ctl_data->key_size / 8);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sdo->docp.non_repudiation.value)   {\n\t\t\tsc_log(ctx, \"non repudiation flag %X\", sdo->docp.non_repudiation.value[0]);\n\t\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && !(*sdo->docp.non_repudiation.value))   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: need non repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && *sdo->docp.non_repudiation.value)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: don't need non-repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->access & SC_PKCS15_PRKEY_ACCESS_LOCAL)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_GENERATE] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: GENERATE KEY not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PUT_DATA] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PUT DATA not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_SIGN] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO SIGN not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_INTERNAL_AUTH] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: INTERNAL AUTHENTICATE not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->usage & (SC_PKCS15_PRKEY_USAGE_DECRYPT | SC_PKCS15_PRKEY_USAGE_UNWRAP))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_DECIPHER] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO DECIPHER not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tctl_data->index = idx;\n\n\tif (idx > IASECC_OBJECT_REF_MAX)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nstatic struct sc_card_driver *\nsc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tif (!iso_ops)\n\t\tiso_ops = iso_drv->ops;\n\n\tiasecc_ops = *iso_ops;\n\n\tiasecc_ops.match_card = iasecc_match_card;\n\tiasecc_ops.init = iasecc_init;\n\tiasecc_ops.finish = iasecc_finish;\n\tiasecc_ops.read_binary = iasecc_read_binary;\n\t/*\twrite_binary: ISO7816 implementation works\t*/\n\t/*\tupdate_binary: ISO7816 implementation works\t*/\n\tiasecc_ops.erase_binary = iasecc_erase_binary;\n\t/*\tresize_binary\t*/\n\t/* \tread_record: Untested\t*/\n\t/*\twrite_record: Untested\t*/\n\t/*\tappend_record: Untested\t*/\n\t/*\tupdate_record: Untested\t*/\n\tiasecc_ops.select_file = iasecc_select_file;\n\t/*\tget_response: Untested\t*/\n\t/*\tget_challenge: ISO7816 implementation works\t*/\n\tiasecc_ops.logout = iasecc_logout;\n\t/*\trestore_security_env\t*/\n\tiasecc_ops.set_security_env = iasecc_set_security_env;\n\tiasecc_ops.decipher = iasecc_decipher;\n\tiasecc_ops.compute_signature = iasecc_compute_signature;\n\tiasecc_ops.create_file = iasecc_create_file;\n\tiasecc_ops.delete_file = iasecc_delete_file;\n\t/*\tlist_files\t*/\n\tiasecc_ops.check_sw = iasecc_check_sw;\n\tiasecc_ops.card_ctl = iasecc_card_ctl;\n\tiasecc_ops.process_fci = iasecc_process_fci;\n\t/*\tconstruct_fci: Not needed\t*/\n\tiasecc_ops.pin_cmd = iasecc_pin_cmd;\n\t/*\tget_data: Not implemented\t*/\n\t/*\tput_data: Not implemented\t*/\n\t/*\tdelete_record: Not implemented\t*/\n\n\tiasecc_ops.read_public_key = iasecc_read_public_key;\n\n\treturn &iasecc_drv;\n}\n\nstruct sc_card_driver *\nsc_get_iasecc_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n#else\n\n/* we need to define the functions below to export them */\n#include \"errors.h\"\n\nint\niasecc_se_get_info()\n{\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n\n#endif /* ENABLE_OPENSSL */\n"], "filenames": ["src/libopensc/card-iasecc.c"], "buggy_code_start_loc": [830], "buggy_code_end_loc": [840], "fixing_code_start_loc": [830], "fixing_code_end_loc": [840], "type": "CWE-674", "message": "Endless recursion when handling responses from an IAS-ECC card in iasecc_select_file in libopensc/card-iasecc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to hang or crash the opensc library using programs.", "other": {"cve": {"id": "CVE-2018-16426", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-04T00:29:01.293", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Endless recursion when handling responses from an IAS-ECC card in iasecc_select_file in libopensc/card-iasecc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to hang or crash the opensc library using programs."}, {"lang": "es", "value": "Una recursi\u00f3n infinita al manejar las respuestas de una tarjeta IAS-ECC en iasecc_select_file en libopensc/card-iasecc.c en OpenSC en versiones anteriores a la 0.19.0-rc1 podr\u00eda ser empleada por atacantes para proporcionar smartcards manipuladas para provocar el bloqueo o el cierre inesperado de la librer\u00eda opensc mediante programas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.18.0", "matchCriteriaId": "85C3EC93-1A01-4E7D-9730-F8429C1CD145"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2154", "source": "cve@mitre.org"}, {"url": "https://github.com/OpenSC/OpenSC/commit/03628449b75a93787eb2359412a3980365dda49b#diff-f8c0128e14031ed9307d47f10f601b54", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/releases/tag/0.19.0-rc1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00009.html", "source": "cve@mitre.org"}, {"url": "https://www.x41-dsec.de/lab/advisories/x41-2018-002-OpenSC/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/03628449b75a93787eb2359412a3980365dda49b#diff-f8c0128e14031ed9307d47f10f601b54"}}