{"buggy_code": ["/*  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */\n/*\n    Copyright (c) 2001, 2002 by D-Link Corporation\n    Written by Edward Peng.<edward_peng@dlink.com.tw>\n    Created 03-May-2001, base on Linux' sundance.c.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#define DRV_NAME\t\"DL2000/TC902x-based linux driver\"\n#define DRV_VERSION\t\"v1.19\"\n#define DRV_RELDATE\t\"2007/08/12\"\n#include \"dl2k.h\"\n#include <linux/dma-mapping.h>\n\nstatic char version[] __devinitdata =\n      KERN_INFO DRV_NAME \" \" DRV_VERSION \" \" DRV_RELDATE \"\\n\";\n#define MAX_UNITS 8\nstatic int mtu[MAX_UNITS];\nstatic int vlan[MAX_UNITS];\nstatic int jumbo[MAX_UNITS];\nstatic char *media[MAX_UNITS];\nstatic int tx_flow=-1;\nstatic int rx_flow=-1;\nstatic int copy_thresh;\nstatic int rx_coalesce=10;\t/* Rx frame count each interrupt */\nstatic int rx_timeout=200;\t/* Rx DMA wait time in 640ns increments */\nstatic int tx_coalesce=16;\t/* HW xmit count each TxDMAComplete */\n\n\nMODULE_AUTHOR (\"Edward Peng\");\nMODULE_DESCRIPTION (\"D-Link DL2000-based Gigabit Ethernet Adapter\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(mtu, int, NULL, 0);\nmodule_param_array(media, charp, NULL, 0);\nmodule_param_array(vlan, int, NULL, 0);\nmodule_param_array(jumbo, int, NULL, 0);\nmodule_param(tx_flow, int, 0);\nmodule_param(rx_flow, int, 0);\nmodule_param(copy_thresh, int, 0);\nmodule_param(rx_coalesce, int, 0);\t/* Rx frame count each interrupt */\nmodule_param(rx_timeout, int, 0);\t/* Rx DMA wait time in 64ns increments */\nmodule_param(tx_coalesce, int, 0); /* HW xmit count each TxDMAComplete */\n\n\n/* Enable the default interrupts */\n#define DEFAULT_INTR (RxDMAComplete | HostError | IntRequested | TxDMAComplete| \\\n       UpdateStats | LinkEvent)\n#define EnableInt() \\\nwritew(DEFAULT_INTR, ioaddr + IntEnable)\n\nstatic const int max_intrloop = 50;\nstatic const int multicast_filter_limit = 0x40;\n\nstatic int rio_open (struct net_device *dev);\nstatic void rio_timer (unsigned long data);\nstatic void rio_tx_timeout (struct net_device *dev);\nstatic void alloc_list (struct net_device *dev);\nstatic netdev_tx_t start_xmit (struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t rio_interrupt (int irq, void *dev_instance);\nstatic void rio_free_tx (struct net_device *dev, int irq);\nstatic void tx_error (struct net_device *dev, int tx_status);\nstatic int receive_packet (struct net_device *dev);\nstatic void rio_error (struct net_device *dev, int int_status);\nstatic int change_mtu (struct net_device *dev, int new_mtu);\nstatic void set_multicast (struct net_device *dev);\nstatic struct net_device_stats *get_stats (struct net_device *dev);\nstatic int clear_stats (struct net_device *dev);\nstatic int rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int rio_close (struct net_device *dev);\nstatic int find_miiphy (struct net_device *dev);\nstatic int parse_eeprom (struct net_device *dev);\nstatic int read_eeprom (long ioaddr, int eep_addr);\nstatic int mii_wait_link (struct net_device *dev, int wait);\nstatic int mii_set_media (struct net_device *dev);\nstatic int mii_get_media (struct net_device *dev);\nstatic int mii_set_media_pcs (struct net_device *dev);\nstatic int mii_get_media_pcs (struct net_device *dev);\nstatic int mii_read (struct net_device *dev, int phy_addr, int reg_num);\nstatic int mii_write (struct net_device *dev, int phy_addr, int reg_num,\n\t\t      u16 data);\n\nstatic const struct ethtool_ops ethtool_ops;\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= rio_open,\n\t.ndo_start_xmit\t= start_xmit,\n\t.ndo_stop\t\t= rio_close,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_set_rx_mode\t= set_multicast,\n\t.ndo_do_ioctl\t\t= rio_ioctl,\n\t.ndo_tx_timeout\t\t= rio_tx_timeout,\n\t.ndo_change_mtu\t\t= change_mtu,\n};\n\nstatic int __devinit\nrio_probe1 (struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct netdev_private *np;\n\tstatic int card_idx;\n\tint chip_idx = ent->driver_data;\n\tint err, irq;\n\tlong ioaddr;\n\tstatic int version_printed;\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\n\tif (!version_printed++)\n\t\tprintk (\"%s\", version);\n\n\terr = pci_enable_device (pdev);\n\tif (err)\n\t\treturn err;\n\n\tirq = pdev->irq;\n\terr = pci_request_regions (pdev, \"dl2k\");\n\tif (err)\n\t\tgoto err_out_disable;\n\n\tpci_set_master (pdev);\n\tdev = alloc_etherdev (sizeof (*np));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_res;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n#ifdef MEM_MAPPING\n\tioaddr = pci_resource_start (pdev, 1);\n\tioaddr = (long) ioremap (ioaddr, RIO_IO_SIZE);\n\tif (!ioaddr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_dev;\n\t}\n#else\n\tioaddr = pci_resource_start (pdev, 0);\n#endif\n\tdev->base_addr = ioaddr;\n\tdev->irq = irq;\n\tnp = netdev_priv(dev);\n\tnp->chip_id = chip_idx;\n\tnp->pdev = pdev;\n\tspin_lock_init (&np->tx_lock);\n\tspin_lock_init (&np->rx_lock);\n\n\t/* Parse manual configuration */\n\tnp->an_enable = 1;\n\tnp->tx_coalesce = 1;\n\tif (card_idx < MAX_UNITS) {\n\t\tif (media[card_idx] != NULL) {\n\t\t\tnp->an_enable = 0;\n\t\t\tif (strcmp (media[card_idx], \"auto\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"autosense\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"0\") == 0 ) {\n\t\t\t\tnp->an_enable = 2;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_fd\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"4\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"3\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_fd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"2\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"1\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_fd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"6\") == 0) {\n\t\t\t\tnp->speed=1000;\n\t\t\t\tnp->full_duplex=1;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_hd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"5\") == 0) {\n\t\t\t\tnp->speed = 1000;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else {\n\t\t\t\tnp->an_enable = 1;\n\t\t\t}\n\t\t}\n\t\tif (jumbo[card_idx] != 0) {\n\t\t\tnp->jumbo = 1;\n\t\t\tdev->mtu = MAX_JUMBO;\n\t\t} else {\n\t\t\tnp->jumbo = 0;\n\t\t\tif (mtu[card_idx] > 0 && mtu[card_idx] < PACKET_SIZE)\n\t\t\t\tdev->mtu = mtu[card_idx];\n\t\t}\n\t\tnp->vlan = (vlan[card_idx] > 0 && vlan[card_idx] < 4096) ?\n\t\t    vlan[card_idx] : 0;\n\t\tif (rx_coalesce > 0 && rx_timeout > 0) {\n\t\t\tnp->rx_coalesce = rx_coalesce;\n\t\t\tnp->rx_timeout = rx_timeout;\n\t\t\tnp->coalesce = 1;\n\t\t}\n\t\tnp->tx_flow = (tx_flow == 0) ? 0 : 1;\n\t\tnp->rx_flow = (rx_flow == 0) ? 0 : 1;\n\n\t\tif (tx_coalesce < 1)\n\t\t\ttx_coalesce = 1;\n\t\telse if (tx_coalesce > TX_RING_SIZE-1)\n\t\t\ttx_coalesce = TX_RING_SIZE - 1;\n\t}\n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tSET_ETHTOOL_OPS(dev, &ethtool_ops);\n#if 0\n\tdev->features = NETIF_F_IP_CSUM;\n#endif\n\tpci_set_drvdata (pdev, dev);\n\n\tring_space = pci_alloc_consistent (pdev, TX_TOTAL_SIZE, &ring_dma);\n\tif (!ring_space)\n\t\tgoto err_out_iounmap;\n\tnp->tx_ring = ring_space;\n\tnp->tx_ring_dma = ring_dma;\n\n\tring_space = pci_alloc_consistent (pdev, RX_TOTAL_SIZE, &ring_dma);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\tnp->rx_ring = ring_space;\n\tnp->rx_ring_dma = ring_dma;\n\n\t/* Parse eeprom data */\n\tparse_eeprom (dev);\n\n\t/* Find PHY address */\n\terr = find_miiphy (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\t/* Fiber device? */\n\tnp->phy_media = (readw(ioaddr + ASICCtrl) & PhyMedia) ? 1 : 0;\n\tnp->link_status = 0;\n\t/* Set media and reset PHY */\n\tif (np->phy_media) {\n\t\t/* default Auto-Negotiation for fiber deivices */\n\t \tif (np->an_enable == 2) {\n\t\t\tnp->an_enable = 1;\n\t\t}\n\t\tmii_set_media_pcs (dev);\n\t} else {\n\t\t/* Auto-Negotiation is mandatory for 1000BASE-T,\n\t\t   IEEE 802.3ab Annex 28D page 14 */\n\t\tif (np->speed == 1000)\n\t\t\tnp->an_enable = 1;\n\t\tmii_set_media (dev);\n\t}\n\n\terr = register_netdev (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\tcard_idx++;\n\n\tprintk (KERN_INFO \"%s: %s, %pM, IRQ %d\\n\",\n\t\tdev->name, np->name, dev->dev_addr, irq);\n\tif (tx_coalesce > 1)\n\t\tprintk(KERN_INFO \"tx_coalesce:\\t%d packets\\n\",\n\t\t\t\ttx_coalesce);\n\tif (np->coalesce)\n\t\tprintk(KERN_INFO\n\t\t       \"rx_coalesce:\\t%d packets\\n\"\n\t\t       \"rx_timeout: \\t%d ns\\n\",\n\t\t\t\tnp->rx_coalesce, np->rx_timeout*640);\n\tif (np->vlan)\n\t\tprintk(KERN_INFO \"vlan(id):\\t%d\\n\", np->vlan);\n\treturn 0;\n\n      err_out_unmap_rx:\n\tpci_free_consistent (pdev, RX_TOTAL_SIZE, np->rx_ring, np->rx_ring_dma);\n      err_out_unmap_tx:\n\tpci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring, np->tx_ring_dma);\n      err_out_iounmap:\n#ifdef MEM_MAPPING\n\tiounmap ((void *) ioaddr);\n\n      err_out_dev:\n#endif\n\tfree_netdev (dev);\n\n      err_out_res:\n\tpci_release_regions (pdev);\n\n      err_out_disable:\n\tpci_disable_device (pdev);\n\treturn err;\n}\n\nstatic int\nfind_miiphy (struct net_device *dev)\n{\n\tint i, phy_found = 0;\n\tstruct netdev_private *np;\n\tlong ioaddr;\n\tnp = netdev_priv(dev);\n\tioaddr = dev->base_addr;\n\tnp->phy_addr = 1;\n\n\tfor (i = 31; i >= 0; i--) {\n\t\tint mii_status = mii_read (dev, i, 1);\n\t\tif (mii_status != 0xffff && mii_status != 0x0000) {\n\t\t\tnp->phy_addr = i;\n\t\t\tphy_found++;\n\t\t}\n\t}\n\tif (!phy_found) {\n\t\tprintk (KERN_ERR \"%s: No MII PHY found!\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int\nparse_eeprom (struct net_device *dev)\n{\n\tint i, j;\n\tlong ioaddr = dev->base_addr;\n\tu8 sromdata[256];\n\tu8 *psib;\n\tu32 crc;\n\tPSROM_t psrom = (PSROM_t) sromdata;\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tint cid, next;\n\n#ifdef\tMEM_MAPPING\n\tioaddr = pci_resource_start (np->pdev, 0);\n#endif\n\t/* Read eeprom */\n\tfor (i = 0; i < 128; i++) {\n\t\t((__le16 *) sromdata)[i] = cpu_to_le16(read_eeprom (ioaddr, i));\n\t}\n#ifdef\tMEM_MAPPING\n\tioaddr = dev->base_addr;\n#endif\n\tif (np->pdev->vendor == PCI_VENDOR_ID_DLINK) {\t/* D-Link Only */\n\t\t/* Check CRC */\n\t\tcrc = ~ether_crc_le (256 - 4, sromdata);\n\t\tif (psrom->crc != cpu_to_le32(crc)) {\n\t\t\tprintk (KERN_ERR \"%s: EEPROM data CRC error.\\n\",\n\t\t\t\t\tdev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Set MAC address */\n\tfor (i = 0; i < 6; i++)\n\t\tdev->dev_addr[i] = psrom->mac_addr[i];\n\n\tif (np->pdev->vendor != PCI_VENDOR_ID_DLINK) {\n\t\treturn 0;\n\t}\n\n\t/* Parse Software Information Block */\n\ti = 0x30;\n\tpsib = (u8 *) sromdata;\n\tdo {\n\t\tcid = psib[i++];\n\t\tnext = psib[i++];\n\t\tif ((cid == 0 && next == 0) || (cid == 0xff && next == 0xff)) {\n\t\t\tprintk (KERN_ERR \"Cell data error\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (cid) {\n\t\tcase 0:\t/* Format version */\n\t\t\tbreak;\n\t\tcase 1:\t/* End of cell */\n\t\t\treturn 0;\n\t\tcase 2:\t/* Duplex Polarity */\n\t\t\tnp->duplex_polarity = psib[i];\n\t\t\twriteb (readb (ioaddr + PhyCtrl) | psib[i],\n\t\t\t\tioaddr + PhyCtrl);\n\t\t\tbreak;\n\t\tcase 3:\t/* Wake Polarity */\n\t\t\tnp->wake_polarity = psib[i];\n\t\t\tbreak;\n\t\tcase 9:\t/* Adapter description */\n\t\t\tj = (next - i > 255) ? 255 : next - i;\n\t\t\tmemcpy (np->name, &(psib[i]), j);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\t/* Reversed */\n\t\t\tbreak;\n\t\tdefault:\t/* Unknown cell */\n\t\t\treturn -1;\n\t\t}\n\t\ti = next;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int\nrio_open (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\tint i;\n\tu16 macctrl;\n\n\ti = request_irq (dev->irq, rio_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (i)\n\t\treturn i;\n\n\t/* Reset all logic functions */\n\twritew (GlobalReset | DMAReset | FIFOReset | NetworkReset | HostReset,\n\t\tioaddr + ASICCtrl + 2);\n\tmdelay(10);\n\n\t/* DebugCtrl bit 4, 5, 9 must set */\n\twritel (readl (ioaddr + DebugCtrl) | 0x0230, ioaddr + DebugCtrl);\n\n\t/* Jumbo frame */\n\tif (np->jumbo != 0)\n\t\twritew (MAX_JUMBO+14, ioaddr + MaxFrameSize);\n\n\talloc_list (dev);\n\n\t/* Get station address */\n\tfor (i = 0; i < 6; i++)\n\t\twriteb (dev->dev_addr[i], ioaddr + StationAddr0 + i);\n\n\tset_multicast (dev);\n\tif (np->coalesce) {\n\t\twritel (np->rx_coalesce | np->rx_timeout << 16,\n\t\t\tioaddr + RxDMAIntCtrl);\n\t}\n\t/* Set RIO to poll every N*320nsec. */\n\twriteb (0x20, ioaddr + RxDMAPollPeriod);\n\twriteb (0xff, ioaddr + TxDMAPollPeriod);\n\twriteb (0x30, ioaddr + RxDMABurstThresh);\n\twriteb (0x30, ioaddr + RxDMAUrgentThresh);\n\twritel (0x0007ffff, ioaddr + RmonStatMask);\n\t/* clear statistics */\n\tclear_stats (dev);\n\n\t/* VLAN supported */\n\tif (np->vlan) {\n\t\t/* priority field in RxDMAIntCtrl  */\n\t\twritel (readl(ioaddr + RxDMAIntCtrl) | 0x7 << 10,\n\t\t\tioaddr + RxDMAIntCtrl);\n\t\t/* VLANId */\n\t\twritew (np->vlan, ioaddr + VLANId);\n\t\t/* Length/Type should be 0x8100 */\n\t\twritel (0x8100 << 16 | np->vlan, ioaddr + VLANTag);\n\t\t/* Enable AutoVLANuntagging, but disable AutoVLANtagging.\n\t\t   VLAN information tagged by TFC' VID, CFI fields. */\n\t\twritel (readl (ioaddr + MACCtrl) | AutoVLANuntagging,\n\t\t\tioaddr + MACCtrl);\n\t}\n\n\tinit_timer (&np->timer);\n\tnp->timer.expires = jiffies + 1*HZ;\n\tnp->timer.data = (unsigned long) dev;\n\tnp->timer.function = rio_timer;\n\tadd_timer (&np->timer);\n\n\t/* Start Tx/Rx */\n\twritel (readl (ioaddr + MACCtrl) | StatsEnable | RxEnable | TxEnable,\n\t\t\tioaddr + MACCtrl);\n\n\tmacctrl = 0;\n\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\tmacctrl |= (np->tx_flow) ? TxFlowControlEnable : 0;\n\tmacctrl |= (np->rx_flow) ? RxFlowControlEnable : 0;\n\twritew(macctrl,\tioaddr + MACCtrl);\n\n\tnetif_start_queue (dev);\n\n\t/* Enable default interrupts */\n\tEnableInt ();\n\treturn 0;\n}\n\nstatic void\nrio_timer (unsigned long data)\n{\n\tstruct net_device *dev = (struct net_device *)data;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned int entry;\n\tint next_tick = 1*HZ;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&np->rx_lock, flags);\n\t/* Recover rx ring exhausted error */\n\tif (np->cur_rx - np->old_rx >= RX_RING_SIZE) {\n\t\tprintk(KERN_INFO \"Try to recover rx ring exhausted...\\n\");\n\t\t/* Re-allocate skbuffs to fill the descriptor ring */\n\t\tfor (; np->cur_rx - np->old_rx > 0; np->old_rx++) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tentry = np->old_rx % RX_RING_SIZE;\n\t\t\t/* Dropped packets don't need to re-allocate */\n\t\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\t\tskb = netdev_alloc_skb_ip_align(dev,\n\t\t\t\t\t\t\t\tnp->rx_buf_sz);\n\t\t\t\tif (skb == NULL) {\n\t\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\t\"%s: Still unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\t\tdev->name, entry);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t\t    cpu_to_le64 (pci_map_single\n\t\t\t\t\t (np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\t\t}\n\t\t\tnp->rx_ring[entry].fraginfo |=\n\t\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\t\tnp->rx_ring[entry].status = 0;\n\t\t} /* end for */\n\t} /* end if */\n\tspin_unlock_irqrestore (&np->rx_lock, flags);\n\tnp->timer.expires = jiffies + next_tick;\n\tadd_timer(&np->timer);\n}\n\nstatic void\nrio_tx_timeout (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\n\tprintk (KERN_INFO \"%s: Tx timed out (%4.4x), is buffer full?\\n\",\n\t\tdev->name, readl (ioaddr + TxStatus));\n\trio_free_tx(dev, 0);\n\tdev->if_port = 0;\n\tdev->trans_start = jiffies; /* prevent tx timeout */\n}\n\n /* allocate and initialize Tx and Rx descriptors */\nstatic void\nalloc_list (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\tnp->cur_rx = np->cur_tx = 0;\n\tnp->old_rx = np->old_tx = 0;\n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PACKET_SIZE : dev->mtu + 32);\n\n\t/* Initialize Tx descriptors, TFDListPtr leaves in start_xmit(). */\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_skbuff[i] = NULL;\n\t\tnp->tx_ring[i].status = cpu_to_le64 (TFDDone);\n\t\tnp->tx_ring[i].next_desc = cpu_to_le64 (np->tx_ring_dma +\n\t\t\t\t\t      ((i+1)%TX_RING_SIZE) *\n\t\t\t\t\t      sizeof (struct netdev_desc));\n\t}\n\n\t/* Initialize Rx descriptors */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].next_desc = cpu_to_le64 (np->rx_ring_dma +\n\t\t\t\t\t\t((i + 1) % RX_RING_SIZE) *\n\t\t\t\t\t\tsizeof (struct netdev_desc));\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].fraginfo = 0;\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n\n\t/* Allocate the rx buffers */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t/* Allocated fixed size of skbuff */\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\tnp->rx_skbuff[i] = skb;\n\t\tif (skb == NULL) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"%s: alloc_list: allocate Rx buffer error! \",\n\t\t\t\tdev->name);\n\t\t\tbreak;\n\t\t}\n\t\t/* Rubicon now supports 40 bits of addressing space. */\n\t\tnp->rx_ring[i].fraginfo =\n\t\t    cpu_to_le64 ( pci_map_single (\n\t\t\t \t  np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\tnp->rx_ring[i].fraginfo |= cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t}\n\n\t/* Set RFDListPtr */\n\twritel (np->rx_ring_dma, dev->base_addr + RFDListPtr0);\n\twritel (0, dev->base_addr + RFDListPtr1);\n}\n\nstatic netdev_tx_t\nstart_xmit (struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct netdev_desc *txdesc;\n\tunsigned entry;\n\tu32 ioaddr;\n\tu64 tfc_vlan_tag = 0;\n\n\tif (np->link_status == 0) {\t/* Link Down */\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tioaddr = dev->base_addr;\n\tentry = np->cur_tx % TX_RING_SIZE;\n\tnp->tx_skbuff[entry] = skb;\n\ttxdesc = &np->tx_ring[entry];\n\n#if 0\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxdesc->status |=\n\t\t    cpu_to_le64 (TCPChecksumEnable | UDPChecksumEnable |\n\t\t\t\t IPChecksumEnable);\n\t}\n#endif\n\tif (np->vlan) {\n\t\ttfc_vlan_tag = VLANTagInsert |\n\t\t    ((u64)np->vlan << 32) |\n\t\t    ((u64)skb->priority << 45);\n\t}\n\ttxdesc->fraginfo = cpu_to_le64 (pci_map_single (np->pdev, skb->data,\n\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\tPCI_DMA_TODEVICE));\n\ttxdesc->fraginfo |= cpu_to_le64((u64)skb->len << 48);\n\n\t/* DL2K bug: DMA fails to get next descriptor ptr in 10Mbps mode\n\t * Work around: Always use 1 descriptor in 10Mbps mode */\n\tif (entry % np->tx_coalesce == 0 || np->speed == 10)\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      TxDMAIndicate |\n\t\t\t\t\t      (1 << FragCountShift));\n\telse\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      (1 << FragCountShift));\n\n\t/* TxDMAPollNow */\n\twritel (readl (ioaddr + DMACtrl) | 0x00001000, ioaddr + DMACtrl);\n\t/* Schedule ISR */\n\twritel(10000, ioaddr + CountDown);\n\tnp->cur_tx = (np->cur_tx + 1) % TX_RING_SIZE;\n\tif ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t\t\t< TX_QUEUE_LEN - 1 && np->speed != 10) {\n\t\t/* do nothing */\n\t} else if (!netif_queue_stopped(dev)) {\n\t\tnetif_stop_queue (dev);\n\t}\n\n\t/* The first TFDListPtr */\n\tif (readl (dev->base_addr + TFDListPtr0) == 0) {\n\t\twritel (np->tx_ring_dma + entry * sizeof (struct netdev_desc),\n\t\t\tdev->base_addr + TFDListPtr0);\n\t\twritel (0, dev->base_addr + TFDListPtr1);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic irqreturn_t\nrio_interrupt (int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct netdev_private *np;\n\tunsigned int_status;\n\tlong ioaddr;\n\tint cnt = max_intrloop;\n\tint handled = 0;\n\n\tioaddr = dev->base_addr;\n\tnp = netdev_priv(dev);\n\twhile (1) {\n\t\tint_status = readw (ioaddr + IntStatus);\n\t\twritew (int_status, ioaddr + IntStatus);\n\t\tint_status &= DEFAULT_INTR;\n\t\tif (int_status == 0 || --cnt < 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\t/* Processing received packets */\n\t\tif (int_status & RxDMAComplete)\n\t\t\treceive_packet (dev);\n\t\t/* TxDMAComplete interrupt */\n\t\tif ((int_status & (TxDMAComplete|IntRequested))) {\n\t\t\tint tx_status;\n\t\t\ttx_status = readl (ioaddr + TxStatus);\n\t\t\tif (tx_status & 0x01)\n\t\t\t\ttx_error (dev, tx_status);\n\t\t\t/* Free used tx skbuffs */\n\t\t\trio_free_tx (dev, 1);\n\t\t}\n\n\t\t/* Handle uncommon events */\n\t\tif (int_status &\n\t\t    (HostError | LinkEvent | UpdateStats))\n\t\t\trio_error (dev, int_status);\n\t}\n\tif (np->cur_tx != np->old_tx)\n\t\twritel (100, ioaddr + CountDown);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic inline dma_addr_t desc_to_dma(struct netdev_desc *desc)\n{\n\treturn le64_to_cpu(desc->fraginfo) & DMA_BIT_MASK(48);\n}\n\nstatic void\nrio_free_tx (struct net_device *dev, int irq)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->old_tx % TX_RING_SIZE;\n\tint tx_use = 0;\n\tunsigned long flag = 0;\n\n\tif (irq)\n\t\tspin_lock(&np->tx_lock);\n\telse\n\t\tspin_lock_irqsave(&np->tx_lock, flag);\n\n\t/* Free used tx skbuffs */\n\twhile (entry != np->cur_tx) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (!(np->tx_ring[entry].status & cpu_to_le64(TFDDone)))\n\t\t\tbreak;\n\t\tskb = np->tx_skbuff[entry];\n\t\tpci_unmap_single (np->pdev,\n\t\t\t\t  desc_to_dma(&np->tx_ring[entry]),\n\t\t\t\t  skb->len, PCI_DMA_TODEVICE);\n\t\tif (irq)\n\t\t\tdev_kfree_skb_irq (skb);\n\t\telse\n\t\t\tdev_kfree_skb (skb);\n\n\t\tnp->tx_skbuff[entry] = NULL;\n\t\tentry = (entry + 1) % TX_RING_SIZE;\n\t\ttx_use++;\n\t}\n\tif (irq)\n\t\tspin_unlock(&np->tx_lock);\n\telse\n\t\tspin_unlock_irqrestore(&np->tx_lock, flag);\n\tnp->old_tx = entry;\n\n\t/* If the ring is no longer full, clear tx_full and\n\t   call netif_wake_queue() */\n\n\tif (netif_queue_stopped(dev) &&\n\t    ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t    < TX_QUEUE_LEN - 1 || np->speed == 10)) {\n\t\tnetif_wake_queue (dev);\n\t}\n}\n\nstatic void\ntx_error (struct net_device *dev, int tx_status)\n{\n\tstruct netdev_private *np;\n\tlong ioaddr = dev->base_addr;\n\tint frame_id;\n\tint i;\n\n\tnp = netdev_priv(dev);\n\n\tframe_id = (tx_status & 0xffff0000);\n\tprintk (KERN_ERR \"%s: Transmit error, TxStatus %4.4x, FrameId %d.\\n\",\n\t\tdev->name, tx_status, frame_id);\n\tnp->stats.tx_errors++;\n\t/* Ttransmit Underrun */\n\tif (tx_status & 0x10) {\n\t\tnp->stats.tx_fifo_errors++;\n\t\twritew (readw (ioaddr + TxStartThresh) + 0x10,\n\t\t\tioaddr + TxStartThresh);\n\t\t/* Transmit Underrun need to set TxReset, DMARest, FIFOReset */\n\t\twritew (TxReset | DMAReset | FIFOReset | NetworkReset,\n\t\t\tioaddr + ASICCtrl + 2);\n\t\t/* Wait for ResetBusy bit clear */\n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif ((readw (ioaddr + ASICCtrl + 2) & ResetBusy) == 0)\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\trio_free_tx (dev, 1);\n\t\t/* Reset TFDListPtr */\n\t\twritel (np->tx_ring_dma +\n\t\t\tnp->old_tx * sizeof (struct netdev_desc),\n\t\t\tdev->base_addr + TFDListPtr0);\n\t\twritel (0, dev->base_addr + TFDListPtr1);\n\n\t\t/* Let TxStartThresh stay default value */\n\t}\n\t/* Late Collision */\n\tif (tx_status & 0x04) {\n\t\tnp->stats.tx_fifo_errors++;\n\t\t/* TxReset and clear FIFO */\n\t\twritew (TxReset | FIFOReset, ioaddr + ASICCtrl + 2);\n\t\t/* Wait reset done */\n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif ((readw (ioaddr + ASICCtrl + 2) & ResetBusy) == 0)\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\t/* Let TxStartThresh stay default value */\n\t}\n\t/* Maximum Collisions */\n#ifdef ETHER_STATS\n\tif (tx_status & 0x08)\n\t\tnp->stats.collisions16++;\n#else\n\tif (tx_status & 0x08)\n\t\tnp->stats.collisions++;\n#endif\n\t/* Restart the Tx */\n\twritel (readw (dev->base_addr + MACCtrl) | TxEnable, ioaddr + MACCtrl);\n}\n\nstatic int\nreceive_packet (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->cur_rx % RX_RING_SIZE;\n\tint cnt = 30;\n\n\t/* If RFDDone, FrameStart and FrameEnd set, there is a new packet in. */\n\twhile (1) {\n\t\tstruct netdev_desc *desc = &np->rx_ring[entry];\n\t\tint pkt_len;\n\t\tu64 frame_status;\n\n\t\tif (!(desc->status & cpu_to_le64(RFDDone)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameStart)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameEnd)))\n\t\t\tbreak;\n\n\t\t/* Chip omits the CRC. */\n\t\tframe_status = le64_to_cpu(desc->status);\n\t\tpkt_len = frame_status & 0xffff;\n\t\tif (--cnt < 0)\n\t\t\tbreak;\n\t\t/* Update rx error statistics, drop packet. */\n\t\tif (frame_status & RFS_Errors) {\n\t\t\tnp->stats.rx_errors++;\n\t\t\tif (frame_status & (RxRuntFrame | RxLengthError))\n\t\t\t\tnp->stats.rx_length_errors++;\n\t\t\tif (frame_status & RxFCSError)\n\t\t\t\tnp->stats.rx_crc_errors++;\n\t\t\tif (frame_status & RxAlignmentError && np->speed != 1000)\n\t\t\t\tnp->stats.rx_frame_errors++;\n\t\t\tif (frame_status & RxFIFOOverrun)\n\t \t\t\tnp->stats.rx_fifo_errors++;\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\t/* Small skbuffs for short packets */\n\t\t\tif (pkt_len > copy_thresh) {\n\t\t\t\tpci_unmap_single (np->pdev,\n\t\t\t\t\t\t  desc_to_dma(desc),\n\t\t\t\t\t\t  np->rx_buf_sz,\n\t\t\t\t\t\t  PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_put (skb = np->rx_skbuff[entry], pkt_len);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t} else if ((skb = netdev_alloc_skb_ip_align(dev, pkt_len))) {\n\t\t\t\tpci_dma_sync_single_for_cpu(np->pdev,\n\t\t\t\t\t\t\t    desc_to_dma(desc),\n\t\t\t\t\t\t\t    np->rx_buf_sz,\n\t\t\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_copy_to_linear_data (skb,\n\t\t\t\t\t\t  np->rx_skbuff[entry]->data,\n\t\t\t\t\t\t  pkt_len);\n\t\t\t\tskb_put (skb, pkt_len);\n\t\t\t\tpci_dma_sync_single_for_device(np->pdev,\n\t\t\t\t\t\t\t       desc_to_dma(desc),\n\t\t\t\t\t\t\t       np->rx_buf_sz,\n\t\t\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans (skb, dev);\n#if 0\n\t\t\t/* Checksum done by hw, but csum value unavailable. */\n\t\t\tif (np->pdev->pci_rev_id >= 0x0c &&\n\t\t\t\t!(frame_status & (TCPError | UDPError | IPError))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t}\n#endif\n\t\t\tnetif_rx (skb);\n\t\t}\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tspin_lock(&np->rx_lock);\n\tnp->cur_rx = entry;\n\t/* Re-allocate skbuffs to fill the descriptor ring */\n\tentry = np->old_rx;\n\twhile (entry != np->cur_rx) {\n\t\tstruct sk_buff *skb;\n\t\t/* Dropped packets don't need to re-allocate */\n\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\t\tif (skb == NULL) {\n\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\"%s: receive_packet: \"\n\t\t\t\t\t\"Unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\tdev->name, entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t    cpu_to_le64 (pci_map_single\n\t\t\t\t\t (np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\t}\n\t\tnp->rx_ring[entry].fraginfo |=\n\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\tnp->rx_ring[entry].status = 0;\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tnp->old_rx = entry;\n\tspin_unlock(&np->rx_lock);\n\treturn 0;\n}\n\nstatic void\nrio_error (struct net_device *dev, int int_status)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu16 macctrl;\n\n\t/* Link change event */\n\tif (int_status & LinkEvent) {\n\t\tif (mii_wait_link (dev, 10) == 0) {\n\t\t\tprintk (KERN_INFO \"%s: Link up\\n\", dev->name);\n\t\t\tif (np->phy_media)\n\t\t\t\tmii_get_media_pcs (dev);\n\t\t\telse\n\t\t\t\tmii_get_media (dev);\n\t\t\tif (np->speed == 1000)\n\t\t\t\tnp->tx_coalesce = tx_coalesce;\n\t\t\telse\n\t\t\t\tnp->tx_coalesce = 1;\n\t\t\tmacctrl = 0;\n\t\t\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\t\t\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\t\t\tmacctrl |= (np->tx_flow) ?\n\t\t\t\tTxFlowControlEnable : 0;\n\t\t\tmacctrl |= (np->rx_flow) ?\n\t\t\t\tRxFlowControlEnable : 0;\n\t\t\twritew(macctrl,\tioaddr + MACCtrl);\n\t\t\tnp->link_status = 1;\n\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"%s: Link off\\n\", dev->name);\n\t\t\tnp->link_status = 0;\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\n\t/* UpdateStats statistics registers */\n\tif (int_status & UpdateStats) {\n\t\tget_stats (dev);\n\t}\n\n\t/* PCI Error, a catastronphic error related to the bus interface\n\t   occurs, set GlobalReset and HostReset to reset. */\n\tif (int_status & HostError) {\n\t\tprintk (KERN_ERR \"%s: HostError! IntStatus %4.4x.\\n\",\n\t\t\tdev->name, int_status);\n\t\twritew (GlobalReset | HostReset, ioaddr + ASICCtrl + 2);\n\t\tmdelay (500);\n\t}\n}\n\nstatic struct net_device_stats *\nget_stats (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\tunsigned int stat_reg;\n\n\t/* All statistics registers need to be acknowledged,\n\t   else statistic overflow could cause problems */\n\n\tnp->stats.rx_packets += readl (ioaddr + FramesRcvOk);\n\tnp->stats.tx_packets += readl (ioaddr + FramesXmtOk);\n\tnp->stats.rx_bytes += readl (ioaddr + OctetRcvOk);\n\tnp->stats.tx_bytes += readl (ioaddr + OctetXmtOk);\n\n\tnp->stats.multicast = readl (ioaddr + McstFramesRcvdOk);\n\tnp->stats.collisions += readl (ioaddr + SingleColFrames)\n\t\t\t     +  readl (ioaddr + MultiColFrames);\n\n\t/* detailed tx errors */\n\tstat_reg = readw (ioaddr + FramesAbortXSColls);\n\tnp->stats.tx_aborted_errors += stat_reg;\n\tnp->stats.tx_errors += stat_reg;\n\n\tstat_reg = readw (ioaddr + CarrierSenseErrors);\n\tnp->stats.tx_carrier_errors += stat_reg;\n\tnp->stats.tx_errors += stat_reg;\n\n\t/* Clear all other statistic register. */\n\treadl (ioaddr + McstOctetXmtOk);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadw (ioaddr + BcstFramesRcvdOk);\n\treadw (ioaddr + MacControlFramesRcvd);\n\treadw (ioaddr + FrameTooLongErrors);\n\treadw (ioaddr + InRangeLengthErrors);\n\treadw (ioaddr + FramesCheckSeqErrors);\n\treadw (ioaddr + FramesLostRxErrors);\n\treadl (ioaddr + McstOctetXmtOk);\n\treadl (ioaddr + BcstOctetXmtOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadl (ioaddr + FramesWDeferredXmt);\n\treadl (ioaddr + LateCollisions);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadw (ioaddr + MacControlFramesXmtd);\n\treadw (ioaddr + FramesWEXDeferal);\n\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\treadl (ioaddr + i);\n#endif\n\treadw (ioaddr + TxJumboFrames);\n\treadw (ioaddr + RxJumboFrames);\n\treadw (ioaddr + TCPCheckSumErrors);\n\treadw (ioaddr + UDPCheckSumErrors);\n\treadw (ioaddr + IPCheckSumErrors);\n\treturn &np->stats;\n}\n\nstatic int\nclear_stats (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\n\t/* All statistics registers need to be acknowledged,\n\t   else statistic overflow could cause problems */\n\treadl (ioaddr + FramesRcvOk);\n\treadl (ioaddr + FramesXmtOk);\n\treadl (ioaddr + OctetRcvOk);\n\treadl (ioaddr + OctetXmtOk);\n\n\treadl (ioaddr + McstFramesRcvdOk);\n\treadl (ioaddr + SingleColFrames);\n\treadl (ioaddr + MultiColFrames);\n\treadl (ioaddr + LateCollisions);\n\t/* detailed rx errors */\n\treadw (ioaddr + FrameTooLongErrors);\n\treadw (ioaddr + InRangeLengthErrors);\n\treadw (ioaddr + FramesCheckSeqErrors);\n\treadw (ioaddr + FramesLostRxErrors);\n\n\t/* detailed tx errors */\n\treadw (ioaddr + FramesAbortXSColls);\n\treadw (ioaddr + CarrierSenseErrors);\n\n\t/* Clear all other statistic register. */\n\treadl (ioaddr + McstOctetXmtOk);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadw (ioaddr + BcstFramesRcvdOk);\n\treadw (ioaddr + MacControlFramesRcvd);\n\treadl (ioaddr + McstOctetXmtOk);\n\treadl (ioaddr + BcstOctetXmtOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadl (ioaddr + FramesWDeferredXmt);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadw (ioaddr + MacControlFramesXmtd);\n\treadw (ioaddr + FramesWEXDeferal);\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\treadl (ioaddr + i);\n#endif\n\treadw (ioaddr + TxJumboFrames);\n\treadw (ioaddr + RxJumboFrames);\n\treadw (ioaddr + TCPCheckSumErrors);\n\treadw (ioaddr + UDPCheckSumErrors);\n\treadw (ioaddr + IPCheckSumErrors);\n\treturn 0;\n}\n\n\nstatic int\nchange_mtu (struct net_device *dev, int new_mtu)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint max = (np->jumbo) ? MAX_JUMBO : 1536;\n\n\tif ((new_mtu < 68) || (new_mtu > max)) {\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic void\nset_multicast (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tu32 hash_table[2];\n\tu16 rx_mode = 0;\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\thash_table[0] = hash_table[1] = 0;\n\t/* RxFlowcontrol DA: 01-80-C2-00-00-01. Hash index=0x39 */\n\thash_table[1] |= 0x02000000;\n\tif (dev->flags & IFF_PROMISC) {\n\t\t/* Receive all frames promiscuously. */\n\t\trx_mode = ReceiveAllFrames;\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t\t(netdev_mc_count(dev) > multicast_filter_limit)) {\n\t\t/* Receive broadcast and multicast frames */\n\t\trx_mode = ReceiveBroadcast | ReceiveMulticast | ReceiveUnicast;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\t/* Receive broadcast frames and multicast frames filtering\n\t\t   by Hashtable */\n\t\trx_mode =\n\t\t    ReceiveBroadcast | ReceiveMulticastHash | ReceiveUnicast;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit, index = 0;\n\t\t\tint crc = ether_crc_le(ETH_ALEN, ha->addr);\n\t\t\t/* The inverted high significant 6 bits of CRC are\n\t\t\t   used as an index to hashtable */\n\t\t\tfor (bit = 0; bit < 6; bit++)\n\t\t\t\tif (crc & (1 << (31 - bit)))\n\t\t\t\t\tindex |= (1 << bit);\n\t\t\thash_table[index / 32] |= (1 << (index % 32));\n\t\t}\n\t} else {\n\t\trx_mode = ReceiveBroadcast | ReceiveUnicast;\n\t}\n\tif (np->vlan) {\n\t\t/* ReceiveVLANMatch field in ReceiveMode */\n\t\trx_mode |= ReceiveVLANMatch;\n\t}\n\n\twritel (hash_table[0], ioaddr + HashTable0);\n\twritel (hash_table[1], ioaddr + HashTable1);\n\twritew (rx_mode, ioaddr + ReceiveMode);\n}\n\nstatic void rio_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstrcpy(info->driver, \"dl2k\");\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->bus_info, pci_name(np->pdev));\n}\n\nstatic int rio_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tif (np->phy_media) {\n\t\t/* fiber device */\n\t\tcmd->supported = SUPPORTED_Autoneg | SUPPORTED_FIBRE;\n\t\tcmd->advertising= ADVERTISED_Autoneg | ADVERTISED_FIBRE;\n\t\tcmd->port = PORT_FIBRE;\n\t\tcmd->transceiver = XCVR_INTERNAL;\n\t} else {\n\t\t/* copper device */\n\t\tcmd->supported = SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half\n\t\t\t| SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_Autoneg | SUPPORTED_MII;\n\t\tcmd->advertising = ADVERTISED_10baseT_Half |\n\t\t\tADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half |\n\t\t\tADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Full|\n\t\t\tADVERTISED_Autoneg | ADVERTISED_MII;\n\t\tcmd->port = PORT_MII;\n\t\tcmd->transceiver = XCVR_INTERNAL;\n\t}\n\tif ( np->link_status ) {\n\t\tethtool_cmd_speed_set(cmd, np->speed);\n\t\tcmd->duplex = np->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tethtool_cmd_speed_set(cmd, -1);\n\t\tcmd->duplex = -1;\n\t}\n\tif ( np->an_enable)\n\t\tcmd->autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->autoneg = AUTONEG_DISABLE;\n\n\tcmd->phy_address = np->phy_addr;\n\treturn 0;\n}\n\nstatic int rio_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tnetif_carrier_off(dev);\n\tif (cmd->autoneg == AUTONEG_ENABLE) {\n\t\tif (np->an_enable)\n\t\t\treturn 0;\n\t\telse {\n\t\t\tnp->an_enable = 1;\n\t\t\tmii_set_media(dev);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tnp->an_enable = 0;\n\t\tif (np->speed == 1000) {\n\t\t\tethtool_cmd_speed_set(cmd, SPEED_100);\n\t\t\tcmd->duplex = DUPLEX_FULL;\n\t\t\tprintk(\"Warning!! Can't disable Auto negotiation in 1000Mbps, change to Manual 100Mbps, Full duplex.\\n\");\n\t\t}\n\t\tswitch (ethtool_cmd_speed(cmd)) {\n\t\tcase SPEED_10:\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = (cmd->duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = (cmd->duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_1000: /* not supported */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmii_set_media(dev);\n\t}\n\treturn 0;\n}\n\nstatic u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = rio_get_drvinfo,\n\t.get_settings = rio_get_settings,\n\t.set_settings = rio_set_settings,\n\t.get_link = rio_get_link,\n};\n\nstatic int\nrio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\n\tstruct netdev_desc *desc;\n\tint i;\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n#define EEP_READ 0x0200\n#define EEP_BUSY 0x8000\n/* Read the EEPROM word */\n/* We use I/O instruction to read/write eeprom to avoid fail on some machines */\nstatic int\nread_eeprom (long ioaddr, int eep_addr)\n{\n\tint i = 1000;\n\toutw (EEP_READ | (eep_addr & 0xff), ioaddr + EepromCtrl);\n\twhile (i-- > 0) {\n\t\tif (!(inw (ioaddr + EepromCtrl) & EEP_BUSY)) {\n\t\t\treturn inw (ioaddr + EepromData);\n\t\t}\n\t}\n\treturn 0;\n}\n\nenum phy_ctrl_bits {\n\tMII_READ = 0x00, MII_CLK = 0x01, MII_DATA1 = 0x02, MII_WRITE = 0x04,\n\tMII_DUPLEX = 0x08,\n};\n\n#define mii_delay() readb(ioaddr)\nstatic void\nmii_sendbit (struct net_device *dev, u32 data)\n{\n\tlong ioaddr = dev->base_addr + PhyCtrl;\n\tdata = (data) ? MII_DATA1 : 0;\n\tdata |= MII_WRITE;\n\tdata |= (readb (ioaddr) & 0xf8) | MII_WRITE;\n\twriteb (data, ioaddr);\n\tmii_delay ();\n\twriteb (data | MII_CLK, ioaddr);\n\tmii_delay ();\n}\n\nstatic int\nmii_getbit (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr + PhyCtrl;\n\tu8 data;\n\n\tdata = (readb (ioaddr) & 0xf8) | MII_READ;\n\twriteb (data, ioaddr);\n\tmii_delay ();\n\twriteb (data | MII_CLK, ioaddr);\n\tmii_delay ();\n\treturn ((readb (ioaddr) >> 1) & 1);\n}\n\nstatic void\nmii_send_bits (struct net_device *dev, u32 data, int len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tmii_sendbit (dev, data & (1 << i));\n\t}\n}\n\nstatic int\nmii_read (struct net_device *dev, int phy_addr, int reg_num)\n{\n\tu32 cmd;\n\tint i;\n\tu32 retval = 0;\n\n\t/* Preamble */\n\tmii_send_bits (dev, 0xffffffff, 32);\n\t/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */\n\t/* ST,OP = 0110'b for read operation */\n\tcmd = (0x06 << 10 | phy_addr << 5 | reg_num);\n\tmii_send_bits (dev, cmd, 14);\n\t/* Turnaround */\n\tif (mii_getbit (dev))\n\t\tgoto err_out;\n\t/* Read data */\n\tfor (i = 0; i < 16; i++) {\n\t\tretval |= mii_getbit (dev);\n\t\tretval <<= 1;\n\t}\n\t/* End cycle */\n\tmii_getbit (dev);\n\treturn (retval >> 1) & 0xffff;\n\n      err_out:\n\treturn 0;\n}\nstatic int\nmii_write (struct net_device *dev, int phy_addr, int reg_num, u16 data)\n{\n\tu32 cmd;\n\n\t/* Preamble */\n\tmii_send_bits (dev, 0xffffffff, 32);\n\t/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */\n\t/* ST,OP,AAAAA,RRRRR,TA = 0101xxxxxxxxxx10'b = 0x5002 for write */\n\tcmd = (0x5002 << 16) | (phy_addr << 23) | (reg_num << 18) | data;\n\tmii_send_bits (dev, cmd, 32);\n\t/* End cycle */\n\tmii_getbit (dev);\n\treturn 0;\n}\nstatic int\nmii_wait_link (struct net_device *dev, int wait)\n{\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tdo {\n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tif (bmsr & BMSR_LSTATUS)\n\t\t\treturn 0;\n\t\tmdelay (1);\n\t} while (--wait > 0);\n\treturn -1;\n}\nstatic int\nmii_get_media (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\t__u16 mscr;\n\t__u16 mssr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t/* Auto-Negotiation not completed */\n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\tmii_read (dev, phy_addr, MII_LPA);\n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmssr = mii_read (dev, phy_addr, MII_STAT1000);\n\t\tif (mscr & ADVERTISE_1000FULL && mssr & LPA_1000FULL) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t} else if (mscr & ADVERTISE_1000HALF && mssr & LPA_1000HALF) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100FULL) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100HALF) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10FULL) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10HALF) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Half duplex\\n\");\n\t\t}\n\t\tif (negotiate & ADVERTISE_PAUSE_CAP) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & ADVERTISE_PAUSE_ASYM) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t/* else tx_flow, rx_flow = user select  */\n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tswitch (bmcr & (BMCR_SPEED100 | BMCR_SPEED1000)) {\n\t\tcase BMCR_SPEED1000:\n\t\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\t\tbreak;\n\t\tcase BMCR_SPEED100:\n\t\t\tprintk (KERN_INFO \"Operating at 100 Mbps, \");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintk (KERN_INFO \"Operating at 10 Mbps, \");\n\t\t}\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media (struct net_device *dev)\n{\n\t__u16 pscr;\n\t__u16 bmcr;\n\t__u16 bmsr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t/* Does user set speed? */\n\tif (np->an_enable) {\n\t\t/* Advertise capabilities */\n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~(ADVERTISE_100FULL | ADVERTISE_10FULL |\n\t\t\t  ADVERTISE_100HALF | ADVERTISE_10HALF |\n\t\t\t  ADVERTISE_100BASE4);\n\t\tif (bmsr & BMSR_100FULL)\n\t\t\tanar |= ADVERTISE_100FULL;\n\t\tif (bmsr & BMSR_100HALF)\n\t\t\tanar |= ADVERTISE_100HALF;\n\t\tif (bmsr & BMSR_100BASE4)\n\t\t\tanar |= ADVERTISE_100BASE4;\n\t\tif (bmsr & BMSR_10FULL)\n\t\t\tanar |= ADVERTISE_10FULL;\n\t\tif (bmsr & BMSR_10HALF)\n\t\t\tanar |= ADVERTISE_10HALF;\n\t\tanar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t/* Enable Auto crossover */\n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr |= 3 << 5;\t/* 11'b */\n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t/* Soft reset PHY */\n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t/* Force speed setting */\n\t\t/* 1) Disable Auto crossover */\n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr &= ~(3 << 5);\n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t/* 2) PHY Reset */\n\t\tbmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tbmcr |= BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\n\t\t/* 3) Power Down */\n\t\tbmcr = 0x1940;\t/* must be 0x1940 */\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay (100);\t/* wait a certain time */\n\n\t\t/* 4) Advertise nothing */\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\n\t\t/* 5) Set media and Power Up */\n\t\tbmcr = BMCR_PDOWN;\n\t\tif (np->speed == 100) {\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t\tprintk (KERN_INFO \"Manual 100 Mbps, \");\n\t\t} else if (np->speed == 10) {\n\t\t\tprintk (KERN_INFO \"Manual 10 Mbps, \");\n\t\t}\n\t\tif (np->full_duplex) {\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n#if 0\n\t\t/* Set 1000BaseT Master/Slave setting */\n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmscr |= MII_MSCR_CFG_ENABLE;\n\t\tmscr &= ~MII_MSCR_CFG_VALUE = 0;\n#endif\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t}\n\treturn 0;\n}\n\nstatic int\nmii_get_media_pcs (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, PCS_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t/* Auto-Negotiation not completed */\n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, PCS_ANAR) &\n\t\t\tmii_read (dev, phy_addr, PCS_ANLPAR);\n\t\tnp->speed = 1000;\n\t\tif (negotiate & PCS_ANAR_FULL_DUPLEX) {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t\tnp->full_duplex = 1;\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, half duplex\\n\");\n\t\t\tnp->full_duplex = 0;\n\t\t}\n\t\tif (negotiate & PCS_ANAR_PAUSE) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & PCS_ANAR_ASYMMETRIC) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t/* else tx_flow, rx_flow = user select  */\n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, PCS_BMCR);\n\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media_pcs (struct net_device *dev)\n{\n\t__u16 bmcr;\n\t__u16 esr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t/* Auto-Negotiation? */\n\tif (np->an_enable) {\n\t\t/* Advertise capabilities */\n\t\tesr = mii_read (dev, phy_addr, PCS_ESR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~PCS_ANAR_HALF_DUPLEX &\n\t\t\t~PCS_ANAR_FULL_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_HD | MII_ESR_1000BX_HD))\n\t\t\tanar |= PCS_ANAR_HALF_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_FD | MII_ESR_1000BX_FD))\n\t\t\tanar |= PCS_ANAR_FULL_DUPLEX;\n\t\tanar |= PCS_ANAR_PAUSE | PCS_ANAR_ASYMMETRIC;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t/* Soft reset PHY */\n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t/* Force speed setting */\n\t\t/* PHY Reset */\n\t\tbmcr = BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t\tif (np->full_duplex) {\n\t\t\tbmcr = BMCR_FULLDPLX;\n\t\t\tprintk (KERN_INFO \"Manual full duplex\\n\");\n\t\t} else {\n\t\t\tbmcr = 0;\n\t\t\tprintk (KERN_INFO \"Manual half duplex\\n\");\n\t\t}\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\n\t\t/*  Advertise nothing */\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int\nrio_close (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint i;\n\n\tnetif_stop_queue (dev);\n\n\t/* Disable interrupts */\n\twritew (0, ioaddr + IntEnable);\n\n\t/* Stop Tx and Rx logics */\n\twritel (TxDisable | RxDisable | StatsDisable, ioaddr + MACCtrl);\n\n\tfree_irq (dev->irq, dev);\n\tdel_timer_sync (&np->timer);\n\n\t/* Free all the skbuffs in the queue. */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tskb = np->rx_skbuff[i];\n\t\tif (skb) {\n\t\t\tpci_unmap_single(np->pdev,\n\t\t\t\t\t desc_to_dma(&np->rx_ring[i]),\n\t\t\t\t\t skb->len, PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t\tnp->rx_skbuff[i] = NULL;\n\t\t}\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].fraginfo = 0;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tskb = np->tx_skbuff[i];\n\t\tif (skb) {\n\t\t\tpci_unmap_single(np->pdev,\n\t\t\t\t\t desc_to_dma(&np->tx_ring[i]),\n\t\t\t\t\t skb->len, PCI_DMA_TODEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t\tnp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __devexit\nrio_remove1 (struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata (pdev);\n\n\tif (dev) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\n\t\tunregister_netdev (dev);\n\t\tpci_free_consistent (pdev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t\t     np->rx_ring_dma);\n\t\tpci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t\t     np->tx_ring_dma);\n#ifdef MEM_MAPPING\n\t\tiounmap ((char *) (dev->base_addr));\n#endif\n\t\tfree_netdev (dev);\n\t\tpci_release_regions (pdev);\n\t\tpci_disable_device (pdev);\n\t}\n\tpci_set_drvdata (pdev, NULL);\n}\n\nstatic struct pci_driver rio_driver = {\n\t.name\t\t= \"dl2k\",\n\t.id_table\t= rio_pci_tbl,\n\t.probe\t\t= rio_probe1,\n\t.remove\t\t= __devexit_p(rio_remove1),\n};\n\nstatic int __init\nrio_init (void)\n{\n\treturn pci_register_driver(&rio_driver);\n}\n\nstatic void __exit\nrio_exit (void)\n{\n\tpci_unregister_driver (&rio_driver);\n}\n\nmodule_init (rio_init);\nmodule_exit (rio_exit);\n\n/*\n\nCompile command:\n\ngcc -D__KERNEL__ -DMODULE -I/usr/src/linux/include -Wall -Wstrict-prototypes -O2 -c dl2k.c\n\nRead Documentation/networking/dl2k.txt for details.\n\n*/\n\n", "/*  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */\n/*\n    Copyright (c) 2001, 2002 by D-Link Corporation\n    Written by Edward Peng.<edward_peng@dlink.com.tw>\n    Created 03-May-2001, base on Linux' sundance.c.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#ifndef __DL2K_H__\n#define __DL2K_H__\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/bitops.h>\n#include <asm/processor.h>\t/* Processor type for cache alignment. */\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#define TX_RING_SIZE\t256\n#define TX_QUEUE_LEN\t(TX_RING_SIZE - 1) /* Limit ring entries actually used.*/\n#define RX_RING_SIZE \t256\n#define TX_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct netdev_desc)\n#define RX_TOTAL_SIZE\tRX_RING_SIZE*sizeof(struct netdev_desc)\n\n/* This driver was written to use PCI memory space, however x86-oriented\n   hardware often uses I/O space accesses. */\n#ifndef MEM_MAPPING\n#undef readb\n#undef readw\n#undef readl\n#undef writeb\n#undef writew\n#undef writel\n#define readb inb\n#define readw inw\n#define readl inl\n#define writeb outb\n#define writew outw\n#define writel outl\n#endif\n\n/* Offsets to the device registers.\n   Unlike software-only systems, device drivers interact with complex hardware.\n   It's not useful to define symbolic names for every register bit in the\n   device.  The name can only partially document the semantics and make\n   the driver longer and more difficult to read.\n   In general, only the important configuration values or bits changed\n   multiple times should be defined symbolically.\n*/\nenum dl2x_offsets {\n\t/* I/O register offsets */\n\tDMACtrl = 0x00,\n\tRxDMAStatus = 0x08,\n\tTFDListPtr0 = 0x10,\n\tTFDListPtr1 = 0x14,\n\tTxDMABurstThresh = 0x18,\n\tTxDMAUrgentThresh = 0x19,\n\tTxDMAPollPeriod = 0x1a,\n\tRFDListPtr0 = 0x1c,\n\tRFDListPtr1 = 0x20,\n\tRxDMABurstThresh = 0x24,\n\tRxDMAUrgentThresh = 0x25,\n\tRxDMAPollPeriod = 0x26,\n\tRxDMAIntCtrl = 0x28,\n\tDebugCtrl = 0x2c,\n\tASICCtrl = 0x30,\n\tFifoCtrl = 0x38,\n\tRxEarlyThresh = 0x3a,\n\tFlowOffThresh = 0x3c,\n\tFlowOnThresh = 0x3e,\n\tTxStartThresh = 0x44,\n\tEepromData = 0x48,\n\tEepromCtrl = 0x4a,\n\tExpromAddr = 0x4c,\n\tExprodata = 0x50,\n\tWakeEvent = 0x51,\n\tCountDown = 0x54,\n\tIntStatusAck = 0x5a,\n\tIntEnable = 0x5c,\n\tIntStatus = 0x5e,\n\tTxStatus = 0x60,\n\tMACCtrl = 0x6c,\n\tVLANTag = 0x70,\n\tPhyCtrl = 0x76,\n\tStationAddr0 = 0x78,\n\tStationAddr1 = 0x7a,\n\tStationAddr2 = 0x7c,\n\tVLANId = 0x80,\n\tMaxFrameSize = 0x86,\n\tReceiveMode = 0x88,\n\tHashTable0 = 0x8c,\n\tHashTable1 = 0x90,\n\tRmonStatMask = 0x98,\n\tStatMask = 0x9c,\n\tRxJumboFrames = 0xbc,\n\tTCPCheckSumErrors = 0xc0,\n\tIPCheckSumErrors = 0xc2,\n\tUDPCheckSumErrors = 0xc4,\n\tTxJumboFrames = 0xf4,\n\t/* Ethernet MIB statistic register offsets */\n\tOctetRcvOk = 0xa8,\n\tMcstOctetRcvOk = 0xac,\n\tBcstOctetRcvOk = 0xb0,\n\tFramesRcvOk = 0xb4,\n\tMcstFramesRcvdOk = 0xb8,\n\tBcstFramesRcvdOk = 0xbe,\n\tMacControlFramesRcvd = 0xc6,\n\tFrameTooLongErrors = 0xc8,\n\tInRangeLengthErrors = 0xca,\n\tFramesCheckSeqErrors = 0xcc,\n\tFramesLostRxErrors = 0xce,\n\tOctetXmtOk = 0xd0,\n\tMcstOctetXmtOk = 0xd4,\n\tBcstOctetXmtOk = 0xd8,\n\tFramesXmtOk = 0xdc,\n\tMcstFramesXmtdOk = 0xe0,\n\tFramesWDeferredXmt = 0xe4,\n\tLateCollisions = 0xe8,\n\tMultiColFrames = 0xec,\n\tSingleColFrames = 0xf0,\n\tBcstFramesXmtdOk = 0xf6,\n\tCarrierSenseErrors = 0xf8,\n\tMacControlFramesXmtd = 0xfa,\n\tFramesAbortXSColls = 0xfc,\n\tFramesWEXDeferal = 0xfe,\n\t/* RMON statistic register offsets */\n\tEtherStatsCollisions = 0x100,\n\tEtherStatsOctetsTransmit = 0x104,\n\tEtherStatsPktsTransmit = 0x108,\n\tEtherStatsPkts64OctetTransmit = 0x10c,\n\tEtherStats65to127OctetsTransmit = 0x110,\n\tEtherStatsPkts128to255OctetsTransmit = 0x114,\n\tEtherStatsPkts256to511OctetsTransmit = 0x118,\n\tEtherStatsPkts512to1023OctetsTransmit = 0x11c,\n\tEtherStatsPkts1024to1518OctetsTransmit = 0x120,\n\tEtherStatsCRCAlignErrors = 0x124,\n\tEtherStatsUndersizePkts = 0x128,\n\tEtherStatsFragments = 0x12c,\n\tEtherStatsJabbers = 0x130,\n\tEtherStatsOctets = 0x134,\n\tEtherStatsPkts = 0x138,\n\tEtherStats64Octets = 0x13c,\n\tEtherStatsPkts65to127Octets = 0x140,\n\tEtherStatsPkts128to255Octets = 0x144,\n\tEtherStatsPkts256to511Octets = 0x148,\n\tEtherStatsPkts512to1023Octets = 0x14c,\n\tEtherStatsPkts1024to1518Octets = 0x150,\n};\n\n/* Bits in the interrupt status/mask registers. */\nenum IntStatus_bits {\n\tInterruptStatus = 0x0001,\n\tHostError = 0x0002,\n\tMACCtrlFrame = 0x0008,\n\tTxComplete = 0x0004,\n\tRxComplete = 0x0010,\n\tRxEarly = 0x0020,\n\tIntRequested = 0x0040,\n\tUpdateStats = 0x0080,\n\tLinkEvent = 0x0100,\n\tTxDMAComplete = 0x0200,\n\tRxDMAComplete = 0x0400,\n\tRFDListEnd = 0x0800,\n\tRxDMAPriority = 0x1000,\n};\n\n/* Bits in the ReceiveMode register. */\nenum ReceiveMode_bits {\n\tReceiveUnicast = 0x0001,\n\tReceiveMulticast = 0x0002,\n\tReceiveBroadcast = 0x0004,\n\tReceiveAllFrames = 0x0008,\n\tReceiveMulticastHash = 0x0010,\n\tReceiveIPMulticast = 0x0020,\n\tReceiveVLANMatch = 0x0100,\n\tReceiveVLANHash = 0x0200,\n};\n/* Bits in MACCtrl. */\nenum MACCtrl_bits {\n\tDuplexSelect = 0x20,\n\tTxFlowControlEnable = 0x80,\n\tRxFlowControlEnable = 0x0100,\n\tRcvFCS = 0x200,\n\tAutoVLANtagging = 0x1000,\n\tAutoVLANuntagging = 0x2000,\n\tStatsEnable = 0x00200000,\n\tStatsDisable = 0x00400000,\n\tStatsEnabled = 0x00800000,\n\tTxEnable = 0x01000000,\n\tTxDisable = 0x02000000,\n\tTxEnabled = 0x04000000,\n\tRxEnable = 0x08000000,\n\tRxDisable = 0x10000000,\n\tRxEnabled = 0x20000000,\n};\n\nenum ASICCtrl_LoWord_bits {\n\tPhyMedia = 0x0080,\n};\n\nenum ASICCtrl_HiWord_bits {\n\tGlobalReset = 0x0001,\n\tRxReset = 0x0002,\n\tTxReset = 0x0004,\n\tDMAReset = 0x0008,\n\tFIFOReset = 0x0010,\n\tNetworkReset = 0x0020,\n\tHostReset = 0x0040,\n\tResetBusy = 0x0400,\n};\n\n/* Transmit Frame Control bits */\nenum TFC_bits {\n\tDwordAlign = 0x00000000,\n\tWordAlignDisable = 0x00030000,\n\tWordAlign = 0x00020000,\n\tTCPChecksumEnable = 0x00040000,\n\tUDPChecksumEnable = 0x00080000,\n\tIPChecksumEnable = 0x00100000,\n\tFCSAppendDisable = 0x00200000,\n\tTxIndicate = 0x00400000,\n\tTxDMAIndicate = 0x00800000,\n\tFragCountShift = 24,\n\tVLANTagInsert = 0x0000000010000000,\n\tTFDDone = 0x80000000,\n\tVIDShift = 32,\n\tUsePriorityShift = 48,\n};\n\n/* Receive Frames Status bits */\nenum RFS_bits {\n\tRxFIFOOverrun = 0x00010000,\n\tRxRuntFrame = 0x00020000,\n\tRxAlignmentError = 0x00040000,\n\tRxFCSError = 0x00080000,\n\tRxOverSizedFrame = 0x00100000,\n\tRxLengthError = 0x00200000,\n\tVLANDetected = 0x00400000,\n\tTCPDetected = 0x00800000,\n\tTCPError = 0x01000000,\n\tUDPDetected = 0x02000000,\n\tUDPError = 0x04000000,\n\tIPDetected = 0x08000000,\n\tIPError = 0x10000000,\n\tFrameStart = 0x20000000,\n\tFrameEnd = 0x40000000,\n\tRFDDone = 0x80000000,\n\tTCIShift = 32,\n\tRFS_Errors = 0x003f0000,\n};\n\n#define MII_RESET_TIME_OUT\t\t10000\n/* MII register */\nenum _mii_reg {\n\tMII_PHY_SCR = 16,\n};\n\n/* PCS register */\nenum _pcs_reg {\n\tPCS_BMCR = 0,\n\tPCS_BMSR = 1,\n\tPCS_ANAR = 4,\n\tPCS_ANLPAR = 5,\n\tPCS_ANER = 6,\n\tPCS_ANNPT = 7,\n\tPCS_ANLPRNP = 8,\n\tPCS_ESR = 15,\n};\n\n/* IEEE Extened Status Register */\nenum _mii_esr {\n\tMII_ESR_1000BX_FD = 0x8000,\n\tMII_ESR_1000BX_HD = 0x4000,\n\tMII_ESR_1000BT_FD = 0x2000,\n\tMII_ESR_1000BT_HD = 0x1000,\n};\n/* PHY Specific Control Register */\n#if 0\ntypedef union t_MII_PHY_SCR {\n\tu16 image;\n\tstruct {\n\t\tu16 disable_jabber:1;\t// bit 0\n\t\tu16 polarity_reversal:1;\t// bit 1\n\t\tu16 SEQ_test:1;\t// bit 2\n\t\tu16 _bit_3:1;\t// bit 3\n\t\tu16 disable_CLK125:1;\t// bit 4\n\t\tu16 mdi_crossover_mode:2;\t// bit 6:5\n\t\tu16 enable_ext_dist:1;\t// bit 7\n\t\tu16 _bit_8_9:2;\t// bit 9:8\n\t\tu16 force_link:1;\t// bit 10\n\t\tu16 assert_CRS:1;\t// bit 11\n\t\tu16 rcv_fifo_depth:2;\t// bit 13:12\n\t\tu16 xmit_fifo_depth:2;\t// bit 15:14\n\t} bits;\n} PHY_SCR_t, *PPHY_SCR_t;\n#endif\n\ntypedef enum t_MII_ADMIN_STATUS {\n\tadm_reset,\n\tadm_operational,\n\tadm_loopback,\n\tadm_power_down,\n\tadm_isolate\n} MII_ADMIN_t, *PMII_ADMIN_t;\n\n/* Physical Coding Sublayer Management (PCS) */\n/* PCS control and status registers bitmap as the same as MII */\n/* PCS Extended Status register bitmap as the same as MII */\n/* PCS ANAR */\nenum _pcs_anar {\n\tPCS_ANAR_NEXT_PAGE = 0x8000,\n\tPCS_ANAR_REMOTE_FAULT = 0x3000,\n\tPCS_ANAR_ASYMMETRIC = 0x0100,\n\tPCS_ANAR_PAUSE = 0x0080,\n\tPCS_ANAR_HALF_DUPLEX = 0x0040,\n\tPCS_ANAR_FULL_DUPLEX = 0x0020,\n};\n/* PCS ANLPAR */\nenum _pcs_anlpar {\n\tPCS_ANLPAR_NEXT_PAGE = PCS_ANAR_NEXT_PAGE,\n\tPCS_ANLPAR_REMOTE_FAULT = PCS_ANAR_REMOTE_FAULT,\n\tPCS_ANLPAR_ASYMMETRIC = PCS_ANAR_ASYMMETRIC,\n\tPCS_ANLPAR_PAUSE = PCS_ANAR_PAUSE,\n\tPCS_ANLPAR_HALF_DUPLEX = PCS_ANAR_HALF_DUPLEX,\n\tPCS_ANLPAR_FULL_DUPLEX = PCS_ANAR_FULL_DUPLEX,\n};\n\ntypedef struct t_SROM {\n\tu16 config_param;\t/* 0x00 */\n\tu16 asic_ctrl;\t\t/* 0x02 */\n\tu16 sub_vendor_id;\t/* 0x04 */\n\tu16 sub_system_id;\t/* 0x06 */\n\tu16 reserved1[12];\t/* 0x08-0x1f */\n\tu8 mac_addr[6];\t\t/* 0x20-0x25 */\n\tu8 reserved2[10];\t/* 0x26-0x2f */\n\tu8 sib[204];\t\t/* 0x30-0xfb */\n\tu32 crc;\t\t/* 0xfc-0xff */\n} SROM_t, *PSROM_t;\n\n/* Ioctl custom data */\nstruct ioctl_data {\n\tchar signature[10];\n\tint cmd;\n\tint len;\n\tchar *data;\n};\n\nstruct mii_data {\n\t__u16 reserved;\n\t__u16 reg_num;\n\t__u16 in_value;\n\t__u16 out_value;\n};\n\n/* The Rx and Tx buffer descriptors. */\nstruct netdev_desc {\n\t__le64 next_desc;\n\t__le64 status;\n\t__le64 fraginfo;\n};\n\n#define PRIV_ALIGN\t15\t/* Required alignment mask */\n/* Use  __attribute__((aligned (L1_CACHE_BYTES)))  to maintain alignment\n   within the structure. */\nstruct netdev_private {\n\t/* Descriptor rings first for alignment. */\n\tstruct netdev_desc *rx_ring;\n\tstruct netdev_desc *tx_ring;\n\tstruct sk_buff *rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff *tx_skbuff[TX_RING_SIZE];\n\tdma_addr_t tx_ring_dma;\n\tdma_addr_t rx_ring_dma;\n\tstruct pci_dev *pdev;\n\tspinlock_t tx_lock;\n\tspinlock_t rx_lock;\n\tstruct net_device_stats stats;\n\tunsigned int rx_buf_sz;\t\t/* Based on MTU+slack. */\n\tunsigned int speed;\t\t/* Operating speed */\n\tunsigned int vlan;\t\t/* VLAN Id */\n\tunsigned int chip_id;\t\t/* PCI table chip id */\n\tunsigned int rx_coalesce; \t/* Maximum frames each RxDMAComplete intr */\n\tunsigned int rx_timeout; \t/* Wait time between RxDMAComplete intr */\n\tunsigned int tx_coalesce;\t/* Maximum frames each tx interrupt */\n\tunsigned int full_duplex:1;\t/* Full-duplex operation requested. */\n\tunsigned int an_enable:2;\t/* Auto-Negotiated Enable */\n\tunsigned int jumbo:1;\t\t/* Jumbo frame enable */\n\tunsigned int coalesce:1;\t/* Rx coalescing enable */\n\tunsigned int tx_flow:1;\t\t/* Tx flow control enable */\n\tunsigned int rx_flow:1;\t\t/* Rx flow control enable */\n\tunsigned int phy_media:1;\t/* 1: fiber, 0: copper */\n\tunsigned int link_status:1;\t/* Current link status */\n\tstruct netdev_desc *last_tx;\t/* Last Tx descriptor used. */\n\tunsigned long cur_rx, old_rx;\t/* Producer/consumer ring indices */\n\tunsigned long cur_tx, old_tx;\n\tstruct timer_list timer;\n\tint wake_polarity;\n\tchar name[256];\t\t/* net device description */\n\tu8 duplex_polarity;\n\tu16 mcast_filter[4];\n\tu16 advertising;\t/* NWay media advertisement */\n\tu16 negotiate;\t\t/* Negotiated media */\n\tint phy_addr;\t\t/* PHY addresses. */\n};\n\n/* The station address location in the EEPROM. */\n/* The struct pci_device_id consist of:\n        vendor, device          Vendor and device ID to match (or PCI_ANY_ID)\n        subvendor, subdevice    Subsystem vendor and device ID to match (or PCI_ANY_ID)\n        class                   Device class to match. The class_mask tells which bits\n        class_mask              of the class are honored during the comparison.\n        driver_data             Data private to the driver.\n*/\n\nstatic DEFINE_PCI_DEVICE_TABLE(rio_pci_tbl) = {\n\t{0x1186, 0x4000, PCI_ANY_ID, PCI_ANY_ID, },\n\t{0x13f0, 0x1021, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ }\n};\nMODULE_DEVICE_TABLE (pci, rio_pci_tbl);\n#define TX_TIMEOUT  (4*HZ)\n#define PACKET_SIZE\t\t1536\n#define MAX_JUMBO\t\t8000\n#define RIO_IO_SIZE             340\n#define DEFAULT_RXC\t\t5\n#define DEFAULT_RXT\t\t750\n#define DEFAULT_TXC\t\t1\n#define MAX_TXC\t\t\t8\n#endif\t\t\t\t/* __DL2K_H__ */\n"], "fixing_code": ["/*  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */\n/*\n    Copyright (c) 2001, 2002 by D-Link Corporation\n    Written by Edward Peng.<edward_peng@dlink.com.tw>\n    Created 03-May-2001, base on Linux' sundance.c.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#define DRV_NAME\t\"DL2000/TC902x-based linux driver\"\n#define DRV_VERSION\t\"v1.19\"\n#define DRV_RELDATE\t\"2007/08/12\"\n#include \"dl2k.h\"\n#include <linux/dma-mapping.h>\n\nstatic char version[] __devinitdata =\n      KERN_INFO DRV_NAME \" \" DRV_VERSION \" \" DRV_RELDATE \"\\n\";\n#define MAX_UNITS 8\nstatic int mtu[MAX_UNITS];\nstatic int vlan[MAX_UNITS];\nstatic int jumbo[MAX_UNITS];\nstatic char *media[MAX_UNITS];\nstatic int tx_flow=-1;\nstatic int rx_flow=-1;\nstatic int copy_thresh;\nstatic int rx_coalesce=10;\t/* Rx frame count each interrupt */\nstatic int rx_timeout=200;\t/* Rx DMA wait time in 640ns increments */\nstatic int tx_coalesce=16;\t/* HW xmit count each TxDMAComplete */\n\n\nMODULE_AUTHOR (\"Edward Peng\");\nMODULE_DESCRIPTION (\"D-Link DL2000-based Gigabit Ethernet Adapter\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(mtu, int, NULL, 0);\nmodule_param_array(media, charp, NULL, 0);\nmodule_param_array(vlan, int, NULL, 0);\nmodule_param_array(jumbo, int, NULL, 0);\nmodule_param(tx_flow, int, 0);\nmodule_param(rx_flow, int, 0);\nmodule_param(copy_thresh, int, 0);\nmodule_param(rx_coalesce, int, 0);\t/* Rx frame count each interrupt */\nmodule_param(rx_timeout, int, 0);\t/* Rx DMA wait time in 64ns increments */\nmodule_param(tx_coalesce, int, 0); /* HW xmit count each TxDMAComplete */\n\n\n/* Enable the default interrupts */\n#define DEFAULT_INTR (RxDMAComplete | HostError | IntRequested | TxDMAComplete| \\\n       UpdateStats | LinkEvent)\n#define EnableInt() \\\nwritew(DEFAULT_INTR, ioaddr + IntEnable)\n\nstatic const int max_intrloop = 50;\nstatic const int multicast_filter_limit = 0x40;\n\nstatic int rio_open (struct net_device *dev);\nstatic void rio_timer (unsigned long data);\nstatic void rio_tx_timeout (struct net_device *dev);\nstatic void alloc_list (struct net_device *dev);\nstatic netdev_tx_t start_xmit (struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t rio_interrupt (int irq, void *dev_instance);\nstatic void rio_free_tx (struct net_device *dev, int irq);\nstatic void tx_error (struct net_device *dev, int tx_status);\nstatic int receive_packet (struct net_device *dev);\nstatic void rio_error (struct net_device *dev, int int_status);\nstatic int change_mtu (struct net_device *dev, int new_mtu);\nstatic void set_multicast (struct net_device *dev);\nstatic struct net_device_stats *get_stats (struct net_device *dev);\nstatic int clear_stats (struct net_device *dev);\nstatic int rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int rio_close (struct net_device *dev);\nstatic int find_miiphy (struct net_device *dev);\nstatic int parse_eeprom (struct net_device *dev);\nstatic int read_eeprom (long ioaddr, int eep_addr);\nstatic int mii_wait_link (struct net_device *dev, int wait);\nstatic int mii_set_media (struct net_device *dev);\nstatic int mii_get_media (struct net_device *dev);\nstatic int mii_set_media_pcs (struct net_device *dev);\nstatic int mii_get_media_pcs (struct net_device *dev);\nstatic int mii_read (struct net_device *dev, int phy_addr, int reg_num);\nstatic int mii_write (struct net_device *dev, int phy_addr, int reg_num,\n\t\t      u16 data);\n\nstatic const struct ethtool_ops ethtool_ops;\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= rio_open,\n\t.ndo_start_xmit\t= start_xmit,\n\t.ndo_stop\t\t= rio_close,\n\t.ndo_get_stats\t\t= get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_set_rx_mode\t= set_multicast,\n\t.ndo_do_ioctl\t\t= rio_ioctl,\n\t.ndo_tx_timeout\t\t= rio_tx_timeout,\n\t.ndo_change_mtu\t\t= change_mtu,\n};\n\nstatic int __devinit\nrio_probe1 (struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct netdev_private *np;\n\tstatic int card_idx;\n\tint chip_idx = ent->driver_data;\n\tint err, irq;\n\tlong ioaddr;\n\tstatic int version_printed;\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\n\tif (!version_printed++)\n\t\tprintk (\"%s\", version);\n\n\terr = pci_enable_device (pdev);\n\tif (err)\n\t\treturn err;\n\n\tirq = pdev->irq;\n\terr = pci_request_regions (pdev, \"dl2k\");\n\tif (err)\n\t\tgoto err_out_disable;\n\n\tpci_set_master (pdev);\n\tdev = alloc_etherdev (sizeof (*np));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_res;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n#ifdef MEM_MAPPING\n\tioaddr = pci_resource_start (pdev, 1);\n\tioaddr = (long) ioremap (ioaddr, RIO_IO_SIZE);\n\tif (!ioaddr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_dev;\n\t}\n#else\n\tioaddr = pci_resource_start (pdev, 0);\n#endif\n\tdev->base_addr = ioaddr;\n\tdev->irq = irq;\n\tnp = netdev_priv(dev);\n\tnp->chip_id = chip_idx;\n\tnp->pdev = pdev;\n\tspin_lock_init (&np->tx_lock);\n\tspin_lock_init (&np->rx_lock);\n\n\t/* Parse manual configuration */\n\tnp->an_enable = 1;\n\tnp->tx_coalesce = 1;\n\tif (card_idx < MAX_UNITS) {\n\t\tif (media[card_idx] != NULL) {\n\t\t\tnp->an_enable = 0;\n\t\t\tif (strcmp (media[card_idx], \"auto\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"autosense\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"0\") == 0 ) {\n\t\t\t\tnp->an_enable = 2;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_fd\") == 0 ||\n\t\t\t    strcmp (media[card_idx], \"4\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"100mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"3\") == 0) {\n\t\t\t\tnp->speed = 100;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_fd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"2\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 1;\n\t\t\t} else if (strcmp (media[card_idx], \"10mbps_hd\") == 0 ||\n\t\t\t\t   strcmp (media[card_idx], \"1\") == 0) {\n\t\t\t\tnp->speed = 10;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_fd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"6\") == 0) {\n\t\t\t\tnp->speed=1000;\n\t\t\t\tnp->full_duplex=1;\n\t\t\t} else if (strcmp (media[card_idx], \"1000mbps_hd\") == 0 ||\n\t\t\t\t strcmp (media[card_idx], \"5\") == 0) {\n\t\t\t\tnp->speed = 1000;\n\t\t\t\tnp->full_duplex = 0;\n\t\t\t} else {\n\t\t\t\tnp->an_enable = 1;\n\t\t\t}\n\t\t}\n\t\tif (jumbo[card_idx] != 0) {\n\t\t\tnp->jumbo = 1;\n\t\t\tdev->mtu = MAX_JUMBO;\n\t\t} else {\n\t\t\tnp->jumbo = 0;\n\t\t\tif (mtu[card_idx] > 0 && mtu[card_idx] < PACKET_SIZE)\n\t\t\t\tdev->mtu = mtu[card_idx];\n\t\t}\n\t\tnp->vlan = (vlan[card_idx] > 0 && vlan[card_idx] < 4096) ?\n\t\t    vlan[card_idx] : 0;\n\t\tif (rx_coalesce > 0 && rx_timeout > 0) {\n\t\t\tnp->rx_coalesce = rx_coalesce;\n\t\t\tnp->rx_timeout = rx_timeout;\n\t\t\tnp->coalesce = 1;\n\t\t}\n\t\tnp->tx_flow = (tx_flow == 0) ? 0 : 1;\n\t\tnp->rx_flow = (rx_flow == 0) ? 0 : 1;\n\n\t\tif (tx_coalesce < 1)\n\t\t\ttx_coalesce = 1;\n\t\telse if (tx_coalesce > TX_RING_SIZE-1)\n\t\t\ttx_coalesce = TX_RING_SIZE - 1;\n\t}\n\tdev->netdev_ops = &netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tSET_ETHTOOL_OPS(dev, &ethtool_ops);\n#if 0\n\tdev->features = NETIF_F_IP_CSUM;\n#endif\n\tpci_set_drvdata (pdev, dev);\n\n\tring_space = pci_alloc_consistent (pdev, TX_TOTAL_SIZE, &ring_dma);\n\tif (!ring_space)\n\t\tgoto err_out_iounmap;\n\tnp->tx_ring = ring_space;\n\tnp->tx_ring_dma = ring_dma;\n\n\tring_space = pci_alloc_consistent (pdev, RX_TOTAL_SIZE, &ring_dma);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\tnp->rx_ring = ring_space;\n\tnp->rx_ring_dma = ring_dma;\n\n\t/* Parse eeprom data */\n\tparse_eeprom (dev);\n\n\t/* Find PHY address */\n\terr = find_miiphy (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\t/* Fiber device? */\n\tnp->phy_media = (readw(ioaddr + ASICCtrl) & PhyMedia) ? 1 : 0;\n\tnp->link_status = 0;\n\t/* Set media and reset PHY */\n\tif (np->phy_media) {\n\t\t/* default Auto-Negotiation for fiber deivices */\n\t \tif (np->an_enable == 2) {\n\t\t\tnp->an_enable = 1;\n\t\t}\n\t\tmii_set_media_pcs (dev);\n\t} else {\n\t\t/* Auto-Negotiation is mandatory for 1000BASE-T,\n\t\t   IEEE 802.3ab Annex 28D page 14 */\n\t\tif (np->speed == 1000)\n\t\t\tnp->an_enable = 1;\n\t\tmii_set_media (dev);\n\t}\n\n\terr = register_netdev (dev);\n\tif (err)\n\t\tgoto err_out_unmap_rx;\n\n\tcard_idx++;\n\n\tprintk (KERN_INFO \"%s: %s, %pM, IRQ %d\\n\",\n\t\tdev->name, np->name, dev->dev_addr, irq);\n\tif (tx_coalesce > 1)\n\t\tprintk(KERN_INFO \"tx_coalesce:\\t%d packets\\n\",\n\t\t\t\ttx_coalesce);\n\tif (np->coalesce)\n\t\tprintk(KERN_INFO\n\t\t       \"rx_coalesce:\\t%d packets\\n\"\n\t\t       \"rx_timeout: \\t%d ns\\n\",\n\t\t\t\tnp->rx_coalesce, np->rx_timeout*640);\n\tif (np->vlan)\n\t\tprintk(KERN_INFO \"vlan(id):\\t%d\\n\", np->vlan);\n\treturn 0;\n\n      err_out_unmap_rx:\n\tpci_free_consistent (pdev, RX_TOTAL_SIZE, np->rx_ring, np->rx_ring_dma);\n      err_out_unmap_tx:\n\tpci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring, np->tx_ring_dma);\n      err_out_iounmap:\n#ifdef MEM_MAPPING\n\tiounmap ((void *) ioaddr);\n\n      err_out_dev:\n#endif\n\tfree_netdev (dev);\n\n      err_out_res:\n\tpci_release_regions (pdev);\n\n      err_out_disable:\n\tpci_disable_device (pdev);\n\treturn err;\n}\n\nstatic int\nfind_miiphy (struct net_device *dev)\n{\n\tint i, phy_found = 0;\n\tstruct netdev_private *np;\n\tlong ioaddr;\n\tnp = netdev_priv(dev);\n\tioaddr = dev->base_addr;\n\tnp->phy_addr = 1;\n\n\tfor (i = 31; i >= 0; i--) {\n\t\tint mii_status = mii_read (dev, i, 1);\n\t\tif (mii_status != 0xffff && mii_status != 0x0000) {\n\t\t\tnp->phy_addr = i;\n\t\t\tphy_found++;\n\t\t}\n\t}\n\tif (!phy_found) {\n\t\tprintk (KERN_ERR \"%s: No MII PHY found!\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int\nparse_eeprom (struct net_device *dev)\n{\n\tint i, j;\n\tlong ioaddr = dev->base_addr;\n\tu8 sromdata[256];\n\tu8 *psib;\n\tu32 crc;\n\tPSROM_t psrom = (PSROM_t) sromdata;\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\tint cid, next;\n\n#ifdef\tMEM_MAPPING\n\tioaddr = pci_resource_start (np->pdev, 0);\n#endif\n\t/* Read eeprom */\n\tfor (i = 0; i < 128; i++) {\n\t\t((__le16 *) sromdata)[i] = cpu_to_le16(read_eeprom (ioaddr, i));\n\t}\n#ifdef\tMEM_MAPPING\n\tioaddr = dev->base_addr;\n#endif\n\tif (np->pdev->vendor == PCI_VENDOR_ID_DLINK) {\t/* D-Link Only */\n\t\t/* Check CRC */\n\t\tcrc = ~ether_crc_le (256 - 4, sromdata);\n\t\tif (psrom->crc != cpu_to_le32(crc)) {\n\t\t\tprintk (KERN_ERR \"%s: EEPROM data CRC error.\\n\",\n\t\t\t\t\tdev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Set MAC address */\n\tfor (i = 0; i < 6; i++)\n\t\tdev->dev_addr[i] = psrom->mac_addr[i];\n\n\tif (np->pdev->vendor != PCI_VENDOR_ID_DLINK) {\n\t\treturn 0;\n\t}\n\n\t/* Parse Software Information Block */\n\ti = 0x30;\n\tpsib = (u8 *) sromdata;\n\tdo {\n\t\tcid = psib[i++];\n\t\tnext = psib[i++];\n\t\tif ((cid == 0 && next == 0) || (cid == 0xff && next == 0xff)) {\n\t\t\tprintk (KERN_ERR \"Cell data error\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (cid) {\n\t\tcase 0:\t/* Format version */\n\t\t\tbreak;\n\t\tcase 1:\t/* End of cell */\n\t\t\treturn 0;\n\t\tcase 2:\t/* Duplex Polarity */\n\t\t\tnp->duplex_polarity = psib[i];\n\t\t\twriteb (readb (ioaddr + PhyCtrl) | psib[i],\n\t\t\t\tioaddr + PhyCtrl);\n\t\t\tbreak;\n\t\tcase 3:\t/* Wake Polarity */\n\t\t\tnp->wake_polarity = psib[i];\n\t\t\tbreak;\n\t\tcase 9:\t/* Adapter description */\n\t\t\tj = (next - i > 255) ? 255 : next - i;\n\t\t\tmemcpy (np->name, &(psib[i]), j);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\t/* Reversed */\n\t\t\tbreak;\n\t\tdefault:\t/* Unknown cell */\n\t\t\treturn -1;\n\t\t}\n\t\ti = next;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int\nrio_open (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\tint i;\n\tu16 macctrl;\n\n\ti = request_irq (dev->irq, rio_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (i)\n\t\treturn i;\n\n\t/* Reset all logic functions */\n\twritew (GlobalReset | DMAReset | FIFOReset | NetworkReset | HostReset,\n\t\tioaddr + ASICCtrl + 2);\n\tmdelay(10);\n\n\t/* DebugCtrl bit 4, 5, 9 must set */\n\twritel (readl (ioaddr + DebugCtrl) | 0x0230, ioaddr + DebugCtrl);\n\n\t/* Jumbo frame */\n\tif (np->jumbo != 0)\n\t\twritew (MAX_JUMBO+14, ioaddr + MaxFrameSize);\n\n\talloc_list (dev);\n\n\t/* Get station address */\n\tfor (i = 0; i < 6; i++)\n\t\twriteb (dev->dev_addr[i], ioaddr + StationAddr0 + i);\n\n\tset_multicast (dev);\n\tif (np->coalesce) {\n\t\twritel (np->rx_coalesce | np->rx_timeout << 16,\n\t\t\tioaddr + RxDMAIntCtrl);\n\t}\n\t/* Set RIO to poll every N*320nsec. */\n\twriteb (0x20, ioaddr + RxDMAPollPeriod);\n\twriteb (0xff, ioaddr + TxDMAPollPeriod);\n\twriteb (0x30, ioaddr + RxDMABurstThresh);\n\twriteb (0x30, ioaddr + RxDMAUrgentThresh);\n\twritel (0x0007ffff, ioaddr + RmonStatMask);\n\t/* clear statistics */\n\tclear_stats (dev);\n\n\t/* VLAN supported */\n\tif (np->vlan) {\n\t\t/* priority field in RxDMAIntCtrl  */\n\t\twritel (readl(ioaddr + RxDMAIntCtrl) | 0x7 << 10,\n\t\t\tioaddr + RxDMAIntCtrl);\n\t\t/* VLANId */\n\t\twritew (np->vlan, ioaddr + VLANId);\n\t\t/* Length/Type should be 0x8100 */\n\t\twritel (0x8100 << 16 | np->vlan, ioaddr + VLANTag);\n\t\t/* Enable AutoVLANuntagging, but disable AutoVLANtagging.\n\t\t   VLAN information tagged by TFC' VID, CFI fields. */\n\t\twritel (readl (ioaddr + MACCtrl) | AutoVLANuntagging,\n\t\t\tioaddr + MACCtrl);\n\t}\n\n\tinit_timer (&np->timer);\n\tnp->timer.expires = jiffies + 1*HZ;\n\tnp->timer.data = (unsigned long) dev;\n\tnp->timer.function = rio_timer;\n\tadd_timer (&np->timer);\n\n\t/* Start Tx/Rx */\n\twritel (readl (ioaddr + MACCtrl) | StatsEnable | RxEnable | TxEnable,\n\t\t\tioaddr + MACCtrl);\n\n\tmacctrl = 0;\n\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\tmacctrl |= (np->tx_flow) ? TxFlowControlEnable : 0;\n\tmacctrl |= (np->rx_flow) ? RxFlowControlEnable : 0;\n\twritew(macctrl,\tioaddr + MACCtrl);\n\n\tnetif_start_queue (dev);\n\n\t/* Enable default interrupts */\n\tEnableInt ();\n\treturn 0;\n}\n\nstatic void\nrio_timer (unsigned long data)\n{\n\tstruct net_device *dev = (struct net_device *)data;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tunsigned int entry;\n\tint next_tick = 1*HZ;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&np->rx_lock, flags);\n\t/* Recover rx ring exhausted error */\n\tif (np->cur_rx - np->old_rx >= RX_RING_SIZE) {\n\t\tprintk(KERN_INFO \"Try to recover rx ring exhausted...\\n\");\n\t\t/* Re-allocate skbuffs to fill the descriptor ring */\n\t\tfor (; np->cur_rx - np->old_rx > 0; np->old_rx++) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tentry = np->old_rx % RX_RING_SIZE;\n\t\t\t/* Dropped packets don't need to re-allocate */\n\t\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\t\tskb = netdev_alloc_skb_ip_align(dev,\n\t\t\t\t\t\t\t\tnp->rx_buf_sz);\n\t\t\t\tif (skb == NULL) {\n\t\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\t\"%s: Still unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\t\tdev->name, entry);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t\t    cpu_to_le64 (pci_map_single\n\t\t\t\t\t (np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\t\t}\n\t\t\tnp->rx_ring[entry].fraginfo |=\n\t\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\t\tnp->rx_ring[entry].status = 0;\n\t\t} /* end for */\n\t} /* end if */\n\tspin_unlock_irqrestore (&np->rx_lock, flags);\n\tnp->timer.expires = jiffies + next_tick;\n\tadd_timer(&np->timer);\n}\n\nstatic void\nrio_tx_timeout (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\n\tprintk (KERN_INFO \"%s: Tx timed out (%4.4x), is buffer full?\\n\",\n\t\tdev->name, readl (ioaddr + TxStatus));\n\trio_free_tx(dev, 0);\n\tdev->if_port = 0;\n\tdev->trans_start = jiffies; /* prevent tx timeout */\n}\n\n /* allocate and initialize Tx and Rx descriptors */\nstatic void\nalloc_list (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint i;\n\n\tnp->cur_rx = np->cur_tx = 0;\n\tnp->old_rx = np->old_tx = 0;\n\tnp->rx_buf_sz = (dev->mtu <= 1500 ? PACKET_SIZE : dev->mtu + 32);\n\n\t/* Initialize Tx descriptors, TFDListPtr leaves in start_xmit(). */\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tnp->tx_skbuff[i] = NULL;\n\t\tnp->tx_ring[i].status = cpu_to_le64 (TFDDone);\n\t\tnp->tx_ring[i].next_desc = cpu_to_le64 (np->tx_ring_dma +\n\t\t\t\t\t      ((i+1)%TX_RING_SIZE) *\n\t\t\t\t\t      sizeof (struct netdev_desc));\n\t}\n\n\t/* Initialize Rx descriptors */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tnp->rx_ring[i].next_desc = cpu_to_le64 (np->rx_ring_dma +\n\t\t\t\t\t\t((i + 1) % RX_RING_SIZE) *\n\t\t\t\t\t\tsizeof (struct netdev_desc));\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].fraginfo = 0;\n\t\tnp->rx_skbuff[i] = NULL;\n\t}\n\n\t/* Allocate the rx buffers */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t/* Allocated fixed size of skbuff */\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\tnp->rx_skbuff[i] = skb;\n\t\tif (skb == NULL) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"%s: alloc_list: allocate Rx buffer error! \",\n\t\t\t\tdev->name);\n\t\t\tbreak;\n\t\t}\n\t\t/* Rubicon now supports 40 bits of addressing space. */\n\t\tnp->rx_ring[i].fraginfo =\n\t\t    cpu_to_le64 ( pci_map_single (\n\t\t\t \t  np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\tnp->rx_ring[i].fraginfo |= cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t}\n\n\t/* Set RFDListPtr */\n\twritel (np->rx_ring_dma, dev->base_addr + RFDListPtr0);\n\twritel (0, dev->base_addr + RFDListPtr1);\n}\n\nstatic netdev_tx_t\nstart_xmit (struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct netdev_desc *txdesc;\n\tunsigned entry;\n\tu32 ioaddr;\n\tu64 tfc_vlan_tag = 0;\n\n\tif (np->link_status == 0) {\t/* Link Down */\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tioaddr = dev->base_addr;\n\tentry = np->cur_tx % TX_RING_SIZE;\n\tnp->tx_skbuff[entry] = skb;\n\ttxdesc = &np->tx_ring[entry];\n\n#if 0\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxdesc->status |=\n\t\t    cpu_to_le64 (TCPChecksumEnable | UDPChecksumEnable |\n\t\t\t\t IPChecksumEnable);\n\t}\n#endif\n\tif (np->vlan) {\n\t\ttfc_vlan_tag = VLANTagInsert |\n\t\t    ((u64)np->vlan << 32) |\n\t\t    ((u64)skb->priority << 45);\n\t}\n\ttxdesc->fraginfo = cpu_to_le64 (pci_map_single (np->pdev, skb->data,\n\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\tPCI_DMA_TODEVICE));\n\ttxdesc->fraginfo |= cpu_to_le64((u64)skb->len << 48);\n\n\t/* DL2K bug: DMA fails to get next descriptor ptr in 10Mbps mode\n\t * Work around: Always use 1 descriptor in 10Mbps mode */\n\tif (entry % np->tx_coalesce == 0 || np->speed == 10)\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      TxDMAIndicate |\n\t\t\t\t\t      (1 << FragCountShift));\n\telse\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      (1 << FragCountShift));\n\n\t/* TxDMAPollNow */\n\twritel (readl (ioaddr + DMACtrl) | 0x00001000, ioaddr + DMACtrl);\n\t/* Schedule ISR */\n\twritel(10000, ioaddr + CountDown);\n\tnp->cur_tx = (np->cur_tx + 1) % TX_RING_SIZE;\n\tif ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t\t\t< TX_QUEUE_LEN - 1 && np->speed != 10) {\n\t\t/* do nothing */\n\t} else if (!netif_queue_stopped(dev)) {\n\t\tnetif_stop_queue (dev);\n\t}\n\n\t/* The first TFDListPtr */\n\tif (readl (dev->base_addr + TFDListPtr0) == 0) {\n\t\twritel (np->tx_ring_dma + entry * sizeof (struct netdev_desc),\n\t\t\tdev->base_addr + TFDListPtr0);\n\t\twritel (0, dev->base_addr + TFDListPtr1);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic irqreturn_t\nrio_interrupt (int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct netdev_private *np;\n\tunsigned int_status;\n\tlong ioaddr;\n\tint cnt = max_intrloop;\n\tint handled = 0;\n\n\tioaddr = dev->base_addr;\n\tnp = netdev_priv(dev);\n\twhile (1) {\n\t\tint_status = readw (ioaddr + IntStatus);\n\t\twritew (int_status, ioaddr + IntStatus);\n\t\tint_status &= DEFAULT_INTR;\n\t\tif (int_status == 0 || --cnt < 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\t\t/* Processing received packets */\n\t\tif (int_status & RxDMAComplete)\n\t\t\treceive_packet (dev);\n\t\t/* TxDMAComplete interrupt */\n\t\tif ((int_status & (TxDMAComplete|IntRequested))) {\n\t\t\tint tx_status;\n\t\t\ttx_status = readl (ioaddr + TxStatus);\n\t\t\tif (tx_status & 0x01)\n\t\t\t\ttx_error (dev, tx_status);\n\t\t\t/* Free used tx skbuffs */\n\t\t\trio_free_tx (dev, 1);\n\t\t}\n\n\t\t/* Handle uncommon events */\n\t\tif (int_status &\n\t\t    (HostError | LinkEvent | UpdateStats))\n\t\t\trio_error (dev, int_status);\n\t}\n\tif (np->cur_tx != np->old_tx)\n\t\twritel (100, ioaddr + CountDown);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic inline dma_addr_t desc_to_dma(struct netdev_desc *desc)\n{\n\treturn le64_to_cpu(desc->fraginfo) & DMA_BIT_MASK(48);\n}\n\nstatic void\nrio_free_tx (struct net_device *dev, int irq)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->old_tx % TX_RING_SIZE;\n\tint tx_use = 0;\n\tunsigned long flag = 0;\n\n\tif (irq)\n\t\tspin_lock(&np->tx_lock);\n\telse\n\t\tspin_lock_irqsave(&np->tx_lock, flag);\n\n\t/* Free used tx skbuffs */\n\twhile (entry != np->cur_tx) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (!(np->tx_ring[entry].status & cpu_to_le64(TFDDone)))\n\t\t\tbreak;\n\t\tskb = np->tx_skbuff[entry];\n\t\tpci_unmap_single (np->pdev,\n\t\t\t\t  desc_to_dma(&np->tx_ring[entry]),\n\t\t\t\t  skb->len, PCI_DMA_TODEVICE);\n\t\tif (irq)\n\t\t\tdev_kfree_skb_irq (skb);\n\t\telse\n\t\t\tdev_kfree_skb (skb);\n\n\t\tnp->tx_skbuff[entry] = NULL;\n\t\tentry = (entry + 1) % TX_RING_SIZE;\n\t\ttx_use++;\n\t}\n\tif (irq)\n\t\tspin_unlock(&np->tx_lock);\n\telse\n\t\tspin_unlock_irqrestore(&np->tx_lock, flag);\n\tnp->old_tx = entry;\n\n\t/* If the ring is no longer full, clear tx_full and\n\t   call netif_wake_queue() */\n\n\tif (netif_queue_stopped(dev) &&\n\t    ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t    < TX_QUEUE_LEN - 1 || np->speed == 10)) {\n\t\tnetif_wake_queue (dev);\n\t}\n}\n\nstatic void\ntx_error (struct net_device *dev, int tx_status)\n{\n\tstruct netdev_private *np;\n\tlong ioaddr = dev->base_addr;\n\tint frame_id;\n\tint i;\n\n\tnp = netdev_priv(dev);\n\n\tframe_id = (tx_status & 0xffff0000);\n\tprintk (KERN_ERR \"%s: Transmit error, TxStatus %4.4x, FrameId %d.\\n\",\n\t\tdev->name, tx_status, frame_id);\n\tnp->stats.tx_errors++;\n\t/* Ttransmit Underrun */\n\tif (tx_status & 0x10) {\n\t\tnp->stats.tx_fifo_errors++;\n\t\twritew (readw (ioaddr + TxStartThresh) + 0x10,\n\t\t\tioaddr + TxStartThresh);\n\t\t/* Transmit Underrun need to set TxReset, DMARest, FIFOReset */\n\t\twritew (TxReset | DMAReset | FIFOReset | NetworkReset,\n\t\t\tioaddr + ASICCtrl + 2);\n\t\t/* Wait for ResetBusy bit clear */\n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif ((readw (ioaddr + ASICCtrl + 2) & ResetBusy) == 0)\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\trio_free_tx (dev, 1);\n\t\t/* Reset TFDListPtr */\n\t\twritel (np->tx_ring_dma +\n\t\t\tnp->old_tx * sizeof (struct netdev_desc),\n\t\t\tdev->base_addr + TFDListPtr0);\n\t\twritel (0, dev->base_addr + TFDListPtr1);\n\n\t\t/* Let TxStartThresh stay default value */\n\t}\n\t/* Late Collision */\n\tif (tx_status & 0x04) {\n\t\tnp->stats.tx_fifo_errors++;\n\t\t/* TxReset and clear FIFO */\n\t\twritew (TxReset | FIFOReset, ioaddr + ASICCtrl + 2);\n\t\t/* Wait reset done */\n\t\tfor (i = 50; i > 0; i--) {\n\t\t\tif ((readw (ioaddr + ASICCtrl + 2) & ResetBusy) == 0)\n\t\t\t\tbreak;\n\t\t\tmdelay (1);\n\t\t}\n\t\t/* Let TxStartThresh stay default value */\n\t}\n\t/* Maximum Collisions */\n#ifdef ETHER_STATS\n\tif (tx_status & 0x08)\n\t\tnp->stats.collisions16++;\n#else\n\tif (tx_status & 0x08)\n\t\tnp->stats.collisions++;\n#endif\n\t/* Restart the Tx */\n\twritel (readw (dev->base_addr + MACCtrl) | TxEnable, ioaddr + MACCtrl);\n}\n\nstatic int\nreceive_packet (struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint entry = np->cur_rx % RX_RING_SIZE;\n\tint cnt = 30;\n\n\t/* If RFDDone, FrameStart and FrameEnd set, there is a new packet in. */\n\twhile (1) {\n\t\tstruct netdev_desc *desc = &np->rx_ring[entry];\n\t\tint pkt_len;\n\t\tu64 frame_status;\n\n\t\tif (!(desc->status & cpu_to_le64(RFDDone)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameStart)) ||\n\t\t    !(desc->status & cpu_to_le64(FrameEnd)))\n\t\t\tbreak;\n\n\t\t/* Chip omits the CRC. */\n\t\tframe_status = le64_to_cpu(desc->status);\n\t\tpkt_len = frame_status & 0xffff;\n\t\tif (--cnt < 0)\n\t\t\tbreak;\n\t\t/* Update rx error statistics, drop packet. */\n\t\tif (frame_status & RFS_Errors) {\n\t\t\tnp->stats.rx_errors++;\n\t\t\tif (frame_status & (RxRuntFrame | RxLengthError))\n\t\t\t\tnp->stats.rx_length_errors++;\n\t\t\tif (frame_status & RxFCSError)\n\t\t\t\tnp->stats.rx_crc_errors++;\n\t\t\tif (frame_status & RxAlignmentError && np->speed != 1000)\n\t\t\t\tnp->stats.rx_frame_errors++;\n\t\t\tif (frame_status & RxFIFOOverrun)\n\t \t\t\tnp->stats.rx_fifo_errors++;\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\t/* Small skbuffs for short packets */\n\t\t\tif (pkt_len > copy_thresh) {\n\t\t\t\tpci_unmap_single (np->pdev,\n\t\t\t\t\t\t  desc_to_dma(desc),\n\t\t\t\t\t\t  np->rx_buf_sz,\n\t\t\t\t\t\t  PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_put (skb = np->rx_skbuff[entry], pkt_len);\n\t\t\t\tnp->rx_skbuff[entry] = NULL;\n\t\t\t} else if ((skb = netdev_alloc_skb_ip_align(dev, pkt_len))) {\n\t\t\t\tpci_dma_sync_single_for_cpu(np->pdev,\n\t\t\t\t\t\t\t    desc_to_dma(desc),\n\t\t\t\t\t\t\t    np->rx_buf_sz,\n\t\t\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_copy_to_linear_data (skb,\n\t\t\t\t\t\t  np->rx_skbuff[entry]->data,\n\t\t\t\t\t\t  pkt_len);\n\t\t\t\tskb_put (skb, pkt_len);\n\t\t\t\tpci_dma_sync_single_for_device(np->pdev,\n\t\t\t\t\t\t\t       desc_to_dma(desc),\n\t\t\t\t\t\t\t       np->rx_buf_sz,\n\t\t\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans (skb, dev);\n#if 0\n\t\t\t/* Checksum done by hw, but csum value unavailable. */\n\t\t\tif (np->pdev->pci_rev_id >= 0x0c &&\n\t\t\t\t!(frame_status & (TCPError | UDPError | IPError))) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t}\n#endif\n\t\t\tnetif_rx (skb);\n\t\t}\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tspin_lock(&np->rx_lock);\n\tnp->cur_rx = entry;\n\t/* Re-allocate skbuffs to fill the descriptor ring */\n\tentry = np->old_rx;\n\twhile (entry != np->cur_rx) {\n\t\tstruct sk_buff *skb;\n\t\t/* Dropped packets don't need to re-allocate */\n\t\tif (np->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb_ip_align(dev, np->rx_buf_sz);\n\t\t\tif (skb == NULL) {\n\t\t\t\tnp->rx_ring[entry].fraginfo = 0;\n\t\t\t\tprintk (KERN_INFO\n\t\t\t\t\t\"%s: receive_packet: \"\n\t\t\t\t\t\"Unable to re-allocate Rx skbuff.#%d\\n\",\n\t\t\t\t\tdev->name, entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnp->rx_skbuff[entry] = skb;\n\t\t\tnp->rx_ring[entry].fraginfo =\n\t\t\t    cpu_to_le64 (pci_map_single\n\t\t\t\t\t (np->pdev, skb->data, np->rx_buf_sz,\n\t\t\t\t\t  PCI_DMA_FROMDEVICE));\n\t\t}\n\t\tnp->rx_ring[entry].fraginfo |=\n\t\t    cpu_to_le64((u64)np->rx_buf_sz << 48);\n\t\tnp->rx_ring[entry].status = 0;\n\t\tentry = (entry + 1) % RX_RING_SIZE;\n\t}\n\tnp->old_rx = entry;\n\tspin_unlock(&np->rx_lock);\n\treturn 0;\n}\n\nstatic void\nrio_error (struct net_device *dev, int int_status)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tu16 macctrl;\n\n\t/* Link change event */\n\tif (int_status & LinkEvent) {\n\t\tif (mii_wait_link (dev, 10) == 0) {\n\t\t\tprintk (KERN_INFO \"%s: Link up\\n\", dev->name);\n\t\t\tif (np->phy_media)\n\t\t\t\tmii_get_media_pcs (dev);\n\t\t\telse\n\t\t\t\tmii_get_media (dev);\n\t\t\tif (np->speed == 1000)\n\t\t\t\tnp->tx_coalesce = tx_coalesce;\n\t\t\telse\n\t\t\t\tnp->tx_coalesce = 1;\n\t\t\tmacctrl = 0;\n\t\t\tmacctrl |= (np->vlan) ? AutoVLANuntagging : 0;\n\t\t\tmacctrl |= (np->full_duplex) ? DuplexSelect : 0;\n\t\t\tmacctrl |= (np->tx_flow) ?\n\t\t\t\tTxFlowControlEnable : 0;\n\t\t\tmacctrl |= (np->rx_flow) ?\n\t\t\t\tRxFlowControlEnable : 0;\n\t\t\twritew(macctrl,\tioaddr + MACCtrl);\n\t\t\tnp->link_status = 1;\n\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"%s: Link off\\n\", dev->name);\n\t\t\tnp->link_status = 0;\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\n\t/* UpdateStats statistics registers */\n\tif (int_status & UpdateStats) {\n\t\tget_stats (dev);\n\t}\n\n\t/* PCI Error, a catastronphic error related to the bus interface\n\t   occurs, set GlobalReset and HostReset to reset. */\n\tif (int_status & HostError) {\n\t\tprintk (KERN_ERR \"%s: HostError! IntStatus %4.4x.\\n\",\n\t\t\tdev->name, int_status);\n\t\twritew (GlobalReset | HostReset, ioaddr + ASICCtrl + 2);\n\t\tmdelay (500);\n\t}\n}\n\nstatic struct net_device_stats *\nget_stats (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\tunsigned int stat_reg;\n\n\t/* All statistics registers need to be acknowledged,\n\t   else statistic overflow could cause problems */\n\n\tnp->stats.rx_packets += readl (ioaddr + FramesRcvOk);\n\tnp->stats.tx_packets += readl (ioaddr + FramesXmtOk);\n\tnp->stats.rx_bytes += readl (ioaddr + OctetRcvOk);\n\tnp->stats.tx_bytes += readl (ioaddr + OctetXmtOk);\n\n\tnp->stats.multicast = readl (ioaddr + McstFramesRcvdOk);\n\tnp->stats.collisions += readl (ioaddr + SingleColFrames)\n\t\t\t     +  readl (ioaddr + MultiColFrames);\n\n\t/* detailed tx errors */\n\tstat_reg = readw (ioaddr + FramesAbortXSColls);\n\tnp->stats.tx_aborted_errors += stat_reg;\n\tnp->stats.tx_errors += stat_reg;\n\n\tstat_reg = readw (ioaddr + CarrierSenseErrors);\n\tnp->stats.tx_carrier_errors += stat_reg;\n\tnp->stats.tx_errors += stat_reg;\n\n\t/* Clear all other statistic register. */\n\treadl (ioaddr + McstOctetXmtOk);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadw (ioaddr + BcstFramesRcvdOk);\n\treadw (ioaddr + MacControlFramesRcvd);\n\treadw (ioaddr + FrameTooLongErrors);\n\treadw (ioaddr + InRangeLengthErrors);\n\treadw (ioaddr + FramesCheckSeqErrors);\n\treadw (ioaddr + FramesLostRxErrors);\n\treadl (ioaddr + McstOctetXmtOk);\n\treadl (ioaddr + BcstOctetXmtOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadl (ioaddr + FramesWDeferredXmt);\n\treadl (ioaddr + LateCollisions);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadw (ioaddr + MacControlFramesXmtd);\n\treadw (ioaddr + FramesWEXDeferal);\n\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\treadl (ioaddr + i);\n#endif\n\treadw (ioaddr + TxJumboFrames);\n\treadw (ioaddr + RxJumboFrames);\n\treadw (ioaddr + TCPCheckSumErrors);\n\treadw (ioaddr + UDPCheckSumErrors);\n\treadw (ioaddr + IPCheckSumErrors);\n\treturn &np->stats;\n}\n\nstatic int\nclear_stats (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n#ifdef MEM_MAPPING\n\tint i;\n#endif\n\n\t/* All statistics registers need to be acknowledged,\n\t   else statistic overflow could cause problems */\n\treadl (ioaddr + FramesRcvOk);\n\treadl (ioaddr + FramesXmtOk);\n\treadl (ioaddr + OctetRcvOk);\n\treadl (ioaddr + OctetXmtOk);\n\n\treadl (ioaddr + McstFramesRcvdOk);\n\treadl (ioaddr + SingleColFrames);\n\treadl (ioaddr + MultiColFrames);\n\treadl (ioaddr + LateCollisions);\n\t/* detailed rx errors */\n\treadw (ioaddr + FrameTooLongErrors);\n\treadw (ioaddr + InRangeLengthErrors);\n\treadw (ioaddr + FramesCheckSeqErrors);\n\treadw (ioaddr + FramesLostRxErrors);\n\n\t/* detailed tx errors */\n\treadw (ioaddr + FramesAbortXSColls);\n\treadw (ioaddr + CarrierSenseErrors);\n\n\t/* Clear all other statistic register. */\n\treadl (ioaddr + McstOctetXmtOk);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadw (ioaddr + BcstFramesRcvdOk);\n\treadw (ioaddr + MacControlFramesRcvd);\n\treadl (ioaddr + McstOctetXmtOk);\n\treadl (ioaddr + BcstOctetXmtOk);\n\treadl (ioaddr + McstFramesXmtdOk);\n\treadl (ioaddr + FramesWDeferredXmt);\n\treadw (ioaddr + BcstFramesXmtdOk);\n\treadw (ioaddr + MacControlFramesXmtd);\n\treadw (ioaddr + FramesWEXDeferal);\n#ifdef MEM_MAPPING\n\tfor (i = 0x100; i <= 0x150; i += 4)\n\t\treadl (ioaddr + i);\n#endif\n\treadw (ioaddr + TxJumboFrames);\n\treadw (ioaddr + RxJumboFrames);\n\treadw (ioaddr + TCPCheckSumErrors);\n\treadw (ioaddr + UDPCheckSumErrors);\n\treadw (ioaddr + IPCheckSumErrors);\n\treturn 0;\n}\n\n\nstatic int\nchange_mtu (struct net_device *dev, int new_mtu)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tint max = (np->jumbo) ? MAX_JUMBO : 1536;\n\n\tif ((new_mtu < 68) || (new_mtu > max)) {\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic void\nset_multicast (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tu32 hash_table[2];\n\tu16 rx_mode = 0;\n\tstruct netdev_private *np = netdev_priv(dev);\n\n\thash_table[0] = hash_table[1] = 0;\n\t/* RxFlowcontrol DA: 01-80-C2-00-00-01. Hash index=0x39 */\n\thash_table[1] |= 0x02000000;\n\tif (dev->flags & IFF_PROMISC) {\n\t\t/* Receive all frames promiscuously. */\n\t\trx_mode = ReceiveAllFrames;\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t\t(netdev_mc_count(dev) > multicast_filter_limit)) {\n\t\t/* Receive broadcast and multicast frames */\n\t\trx_mode = ReceiveBroadcast | ReceiveMulticast | ReceiveUnicast;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\t/* Receive broadcast frames and multicast frames filtering\n\t\t   by Hashtable */\n\t\trx_mode =\n\t\t    ReceiveBroadcast | ReceiveMulticastHash | ReceiveUnicast;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit, index = 0;\n\t\t\tint crc = ether_crc_le(ETH_ALEN, ha->addr);\n\t\t\t/* The inverted high significant 6 bits of CRC are\n\t\t\t   used as an index to hashtable */\n\t\t\tfor (bit = 0; bit < 6; bit++)\n\t\t\t\tif (crc & (1 << (31 - bit)))\n\t\t\t\t\tindex |= (1 << bit);\n\t\t\thash_table[index / 32] |= (1 << (index % 32));\n\t\t}\n\t} else {\n\t\trx_mode = ReceiveBroadcast | ReceiveUnicast;\n\t}\n\tif (np->vlan) {\n\t\t/* ReceiveVLANMatch field in ReceiveMode */\n\t\trx_mode |= ReceiveVLANMatch;\n\t}\n\n\twritel (hash_table[0], ioaddr + HashTable0);\n\twritel (hash_table[1], ioaddr + HashTable1);\n\twritew (rx_mode, ioaddr + ReceiveMode);\n}\n\nstatic void rio_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstrcpy(info->driver, \"dl2k\");\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->bus_info, pci_name(np->pdev));\n}\n\nstatic int rio_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tif (np->phy_media) {\n\t\t/* fiber device */\n\t\tcmd->supported = SUPPORTED_Autoneg | SUPPORTED_FIBRE;\n\t\tcmd->advertising= ADVERTISED_Autoneg | ADVERTISED_FIBRE;\n\t\tcmd->port = PORT_FIBRE;\n\t\tcmd->transceiver = XCVR_INTERNAL;\n\t} else {\n\t\t/* copper device */\n\t\tcmd->supported = SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half\n\t\t\t| SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full |\n\t\t\tSUPPORTED_Autoneg | SUPPORTED_MII;\n\t\tcmd->advertising = ADVERTISED_10baseT_Half |\n\t\t\tADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half |\n\t\t\tADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Full|\n\t\t\tADVERTISED_Autoneg | ADVERTISED_MII;\n\t\tcmd->port = PORT_MII;\n\t\tcmd->transceiver = XCVR_INTERNAL;\n\t}\n\tif ( np->link_status ) {\n\t\tethtool_cmd_speed_set(cmd, np->speed);\n\t\tcmd->duplex = np->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tethtool_cmd_speed_set(cmd, -1);\n\t\tcmd->duplex = -1;\n\t}\n\tif ( np->an_enable)\n\t\tcmd->autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->autoneg = AUTONEG_DISABLE;\n\n\tcmd->phy_address = np->phy_addr;\n\treturn 0;\n}\n\nstatic int rio_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tnetif_carrier_off(dev);\n\tif (cmd->autoneg == AUTONEG_ENABLE) {\n\t\tif (np->an_enable)\n\t\t\treturn 0;\n\t\telse {\n\t\t\tnp->an_enable = 1;\n\t\t\tmii_set_media(dev);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tnp->an_enable = 0;\n\t\tif (np->speed == 1000) {\n\t\t\tethtool_cmd_speed_set(cmd, SPEED_100);\n\t\t\tcmd->duplex = DUPLEX_FULL;\n\t\t\tprintk(\"Warning!! Can't disable Auto negotiation in 1000Mbps, change to Manual 100Mbps, Full duplex.\\n\");\n\t\t}\n\t\tswitch (ethtool_cmd_speed(cmd)) {\n\t\tcase SPEED_10:\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = (cmd->duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = (cmd->duplex == DUPLEX_FULL);\n\t\t\tbreak;\n\t\tcase SPEED_1000: /* not supported */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmii_set_media(dev);\n\t}\n\treturn 0;\n}\n\nstatic u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = rio_get_drvinfo,\n\t.get_settings = rio_get_settings,\n\t.set_settings = rio_set_settings,\n\t.get_link = rio_get_link,\n};\n\nstatic int\nrio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n#define EEP_READ 0x0200\n#define EEP_BUSY 0x8000\n/* Read the EEPROM word */\n/* We use I/O instruction to read/write eeprom to avoid fail on some machines */\nstatic int\nread_eeprom (long ioaddr, int eep_addr)\n{\n\tint i = 1000;\n\toutw (EEP_READ | (eep_addr & 0xff), ioaddr + EepromCtrl);\n\twhile (i-- > 0) {\n\t\tif (!(inw (ioaddr + EepromCtrl) & EEP_BUSY)) {\n\t\t\treturn inw (ioaddr + EepromData);\n\t\t}\n\t}\n\treturn 0;\n}\n\nenum phy_ctrl_bits {\n\tMII_READ = 0x00, MII_CLK = 0x01, MII_DATA1 = 0x02, MII_WRITE = 0x04,\n\tMII_DUPLEX = 0x08,\n};\n\n#define mii_delay() readb(ioaddr)\nstatic void\nmii_sendbit (struct net_device *dev, u32 data)\n{\n\tlong ioaddr = dev->base_addr + PhyCtrl;\n\tdata = (data) ? MII_DATA1 : 0;\n\tdata |= MII_WRITE;\n\tdata |= (readb (ioaddr) & 0xf8) | MII_WRITE;\n\twriteb (data, ioaddr);\n\tmii_delay ();\n\twriteb (data | MII_CLK, ioaddr);\n\tmii_delay ();\n}\n\nstatic int\nmii_getbit (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr + PhyCtrl;\n\tu8 data;\n\n\tdata = (readb (ioaddr) & 0xf8) | MII_READ;\n\twriteb (data, ioaddr);\n\tmii_delay ();\n\twriteb (data | MII_CLK, ioaddr);\n\tmii_delay ();\n\treturn ((readb (ioaddr) >> 1) & 1);\n}\n\nstatic void\nmii_send_bits (struct net_device *dev, u32 data, int len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tmii_sendbit (dev, data & (1 << i));\n\t}\n}\n\nstatic int\nmii_read (struct net_device *dev, int phy_addr, int reg_num)\n{\n\tu32 cmd;\n\tint i;\n\tu32 retval = 0;\n\n\t/* Preamble */\n\tmii_send_bits (dev, 0xffffffff, 32);\n\t/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */\n\t/* ST,OP = 0110'b for read operation */\n\tcmd = (0x06 << 10 | phy_addr << 5 | reg_num);\n\tmii_send_bits (dev, cmd, 14);\n\t/* Turnaround */\n\tif (mii_getbit (dev))\n\t\tgoto err_out;\n\t/* Read data */\n\tfor (i = 0; i < 16; i++) {\n\t\tretval |= mii_getbit (dev);\n\t\tretval <<= 1;\n\t}\n\t/* End cycle */\n\tmii_getbit (dev);\n\treturn (retval >> 1) & 0xffff;\n\n      err_out:\n\treturn 0;\n}\nstatic int\nmii_write (struct net_device *dev, int phy_addr, int reg_num, u16 data)\n{\n\tu32 cmd;\n\n\t/* Preamble */\n\tmii_send_bits (dev, 0xffffffff, 32);\n\t/* ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */\n\t/* ST,OP,AAAAA,RRRRR,TA = 0101xxxxxxxxxx10'b = 0x5002 for write */\n\tcmd = (0x5002 << 16) | (phy_addr << 23) | (reg_num << 18) | data;\n\tmii_send_bits (dev, cmd, 32);\n\t/* End cycle */\n\tmii_getbit (dev);\n\treturn 0;\n}\nstatic int\nmii_wait_link (struct net_device *dev, int wait)\n{\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tdo {\n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tif (bmsr & BMSR_LSTATUS)\n\t\t\treturn 0;\n\t\tmdelay (1);\n\t} while (--wait > 0);\n\treturn -1;\n}\nstatic int\nmii_get_media (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\t__u16 mscr;\n\t__u16 mssr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t/* Auto-Negotiation not completed */\n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\tmii_read (dev, phy_addr, MII_LPA);\n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmssr = mii_read (dev, phy_addr, MII_STAT1000);\n\t\tif (mscr & ADVERTISE_1000FULL && mssr & LPA_1000FULL) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t} else if (mscr & ADVERTISE_1000HALF && mssr & LPA_1000HALF) {\n\t\t\tnp->speed = 1000;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100FULL) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_100HALF) {\n\t\t\tnp->speed = 100;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 100 Mbps, Half duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10FULL) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 1;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Full duplex\\n\");\n\t\t} else if (negotiate & ADVERTISE_10HALF) {\n\t\t\tnp->speed = 10;\n\t\t\tnp->full_duplex = 0;\n\t\t\tprintk (KERN_INFO \"Auto 10 Mbps, Half duplex\\n\");\n\t\t}\n\t\tif (negotiate & ADVERTISE_PAUSE_CAP) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & ADVERTISE_PAUSE_ASYM) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t/* else tx_flow, rx_flow = user select  */\n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tswitch (bmcr & (BMCR_SPEED100 | BMCR_SPEED1000)) {\n\t\tcase BMCR_SPEED1000:\n\t\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\t\tbreak;\n\t\tcase BMCR_SPEED100:\n\t\t\tprintk (KERN_INFO \"Operating at 100 Mbps, \");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintk (KERN_INFO \"Operating at 10 Mbps, \");\n\t\t}\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media (struct net_device *dev)\n{\n\t__u16 pscr;\n\t__u16 bmcr;\n\t__u16 bmsr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t/* Does user set speed? */\n\tif (np->an_enable) {\n\t\t/* Advertise capabilities */\n\t\tbmsr = mii_read (dev, phy_addr, MII_BMSR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~(ADVERTISE_100FULL | ADVERTISE_10FULL |\n\t\t\t  ADVERTISE_100HALF | ADVERTISE_10HALF |\n\t\t\t  ADVERTISE_100BASE4);\n\t\tif (bmsr & BMSR_100FULL)\n\t\t\tanar |= ADVERTISE_100FULL;\n\t\tif (bmsr & BMSR_100HALF)\n\t\t\tanar |= ADVERTISE_100HALF;\n\t\tif (bmsr & BMSR_100BASE4)\n\t\t\tanar |= ADVERTISE_100BASE4;\n\t\tif (bmsr & BMSR_10FULL)\n\t\t\tanar |= ADVERTISE_10FULL;\n\t\tif (bmsr & BMSR_10HALF)\n\t\t\tanar |= ADVERTISE_10HALF;\n\t\tanar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t/* Enable Auto crossover */\n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr |= 3 << 5;\t/* 11'b */\n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t/* Soft reset PHY */\n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t/* Force speed setting */\n\t\t/* 1) Disable Auto crossover */\n\t\tpscr = mii_read (dev, phy_addr, MII_PHY_SCR);\n\t\tpscr &= ~(3 << 5);\n\t\tmii_write (dev, phy_addr, MII_PHY_SCR, pscr);\n\n\t\t/* 2) PHY Reset */\n\t\tbmcr = mii_read (dev, phy_addr, MII_BMCR);\n\t\tbmcr |= BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\n\t\t/* 3) Power Down */\n\t\tbmcr = 0x1940;\t/* must be 0x1940 */\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay (100);\t/* wait a certain time */\n\n\t\t/* 4) Advertise nothing */\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\n\t\t/* 5) Set media and Power Up */\n\t\tbmcr = BMCR_PDOWN;\n\t\tif (np->speed == 100) {\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t\tprintk (KERN_INFO \"Manual 100 Mbps, \");\n\t\t} else if (np->speed == 10) {\n\t\t\tprintk (KERN_INFO \"Manual 10 Mbps, \");\n\t\t}\n\t\tif (np->full_duplex) {\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n#if 0\n\t\t/* Set 1000BaseT Master/Slave setting */\n\t\tmscr = mii_read (dev, phy_addr, MII_CTRL1000);\n\t\tmscr |= MII_MSCR_CFG_ENABLE;\n\t\tmscr &= ~MII_MSCR_CFG_VALUE = 0;\n#endif\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t}\n\treturn 0;\n}\n\nstatic int\nmii_get_media_pcs (struct net_device *dev)\n{\n\t__u16 negotiate;\n\t__u16 bmsr;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\tbmsr = mii_read (dev, phy_addr, PCS_BMSR);\n\tif (np->an_enable) {\n\t\tif (!(bmsr & BMSR_ANEGCOMPLETE)) {\n\t\t\t/* Auto-Negotiation not completed */\n\t\t\treturn -1;\n\t\t}\n\t\tnegotiate = mii_read (dev, phy_addr, PCS_ANAR) &\n\t\t\tmii_read (dev, phy_addr, PCS_ANLPAR);\n\t\tnp->speed = 1000;\n\t\tif (negotiate & PCS_ANAR_FULL_DUPLEX) {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, Full duplex\\n\");\n\t\t\tnp->full_duplex = 1;\n\t\t} else {\n\t\t\tprintk (KERN_INFO \"Auto 1000 Mbps, half duplex\\n\");\n\t\t\tnp->full_duplex = 0;\n\t\t}\n\t\tif (negotiate & PCS_ANAR_PAUSE) {\n\t\t\tnp->tx_flow &= 1;\n\t\t\tnp->rx_flow &= 1;\n\t\t} else if (negotiate & PCS_ANAR_ASYMMETRIC) {\n\t\t\tnp->tx_flow = 0;\n\t\t\tnp->rx_flow &= 1;\n\t\t}\n\t\t/* else tx_flow, rx_flow = user select  */\n\t} else {\n\t\t__u16 bmcr = mii_read (dev, phy_addr, PCS_BMCR);\n\t\tprintk (KERN_INFO \"Operating at 1000 Mbps, \");\n\t\tif (bmcr & BMCR_FULLDPLX) {\n\t\t\tprintk (KERN_CONT \"Full duplex\\n\");\n\t\t} else {\n\t\t\tprintk (KERN_CONT \"Half duplex\\n\");\n\t\t}\n\t}\n\tif (np->tx_flow)\n\t\tprintk(KERN_INFO \"Enable Tx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Tx Flow Control\\n\");\n\tif (np->rx_flow)\n\t\tprintk(KERN_INFO \"Enable Rx Flow Control\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Disable Rx Flow Control\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmii_set_media_pcs (struct net_device *dev)\n{\n\t__u16 bmcr;\n\t__u16 esr;\n\t__u16 anar;\n\tint phy_addr;\n\tstruct netdev_private *np;\n\tnp = netdev_priv(dev);\n\tphy_addr = np->phy_addr;\n\n\t/* Auto-Negotiation? */\n\tif (np->an_enable) {\n\t\t/* Advertise capabilities */\n\t\tesr = mii_read (dev, phy_addr, PCS_ESR);\n\t\tanar = mii_read (dev, phy_addr, MII_ADVERTISE) &\n\t\t\t~PCS_ANAR_HALF_DUPLEX &\n\t\t\t~PCS_ANAR_FULL_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_HD | MII_ESR_1000BX_HD))\n\t\t\tanar |= PCS_ANAR_HALF_DUPLEX;\n\t\tif (esr & (MII_ESR_1000BT_FD | MII_ESR_1000BX_FD))\n\t\t\tanar |= PCS_ANAR_FULL_DUPLEX;\n\t\tanar |= PCS_ANAR_PAUSE | PCS_ANAR_ASYMMETRIC;\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, anar);\n\n\t\t/* Soft reset PHY */\n\t\tmii_write (dev, phy_addr, MII_BMCR, BMCR_RESET);\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(1);\n\t} else {\n\t\t/* Force speed setting */\n\t\t/* PHY Reset */\n\t\tbmcr = BMCR_RESET;\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\t\tif (np->full_duplex) {\n\t\t\tbmcr = BMCR_FULLDPLX;\n\t\t\tprintk (KERN_INFO \"Manual full duplex\\n\");\n\t\t} else {\n\t\t\tbmcr = 0;\n\t\t\tprintk (KERN_INFO \"Manual half duplex\\n\");\n\t\t}\n\t\tmii_write (dev, phy_addr, MII_BMCR, bmcr);\n\t\tmdelay(10);\n\n\t\t/*  Advertise nothing */\n\t\tmii_write (dev, phy_addr, MII_ADVERTISE, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int\nrio_close (struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint i;\n\n\tnetif_stop_queue (dev);\n\n\t/* Disable interrupts */\n\twritew (0, ioaddr + IntEnable);\n\n\t/* Stop Tx and Rx logics */\n\twritel (TxDisable | RxDisable | StatsDisable, ioaddr + MACCtrl);\n\n\tfree_irq (dev->irq, dev);\n\tdel_timer_sync (&np->timer);\n\n\t/* Free all the skbuffs in the queue. */\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tskb = np->rx_skbuff[i];\n\t\tif (skb) {\n\t\t\tpci_unmap_single(np->pdev,\n\t\t\t\t\t desc_to_dma(&np->rx_ring[i]),\n\t\t\t\t\t skb->len, PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t\tnp->rx_skbuff[i] = NULL;\n\t\t}\n\t\tnp->rx_ring[i].status = 0;\n\t\tnp->rx_ring[i].fraginfo = 0;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tskb = np->tx_skbuff[i];\n\t\tif (skb) {\n\t\t\tpci_unmap_single(np->pdev,\n\t\t\t\t\t desc_to_dma(&np->tx_ring[i]),\n\t\t\t\t\t skb->len, PCI_DMA_TODEVICE);\n\t\t\tdev_kfree_skb (skb);\n\t\t\tnp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __devexit\nrio_remove1 (struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata (pdev);\n\n\tif (dev) {\n\t\tstruct netdev_private *np = netdev_priv(dev);\n\n\t\tunregister_netdev (dev);\n\t\tpci_free_consistent (pdev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t\t     np->rx_ring_dma);\n\t\tpci_free_consistent (pdev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t\t     np->tx_ring_dma);\n#ifdef MEM_MAPPING\n\t\tiounmap ((char *) (dev->base_addr));\n#endif\n\t\tfree_netdev (dev);\n\t\tpci_release_regions (pdev);\n\t\tpci_disable_device (pdev);\n\t}\n\tpci_set_drvdata (pdev, NULL);\n}\n\nstatic struct pci_driver rio_driver = {\n\t.name\t\t= \"dl2k\",\n\t.id_table\t= rio_pci_tbl,\n\t.probe\t\t= rio_probe1,\n\t.remove\t\t= __devexit_p(rio_remove1),\n};\n\nstatic int __init\nrio_init (void)\n{\n\treturn pci_register_driver(&rio_driver);\n}\n\nstatic void __exit\nrio_exit (void)\n{\n\tpci_unregister_driver (&rio_driver);\n}\n\nmodule_init (rio_init);\nmodule_exit (rio_exit);\n\n/*\n\nCompile command:\n\ngcc -D__KERNEL__ -DMODULE -I/usr/src/linux/include -Wall -Wstrict-prototypes -O2 -c dl2k.c\n\nRead Documentation/networking/dl2k.txt for details.\n\n*/\n\n", "/*  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */\n/*\n    Copyright (c) 2001, 2002 by D-Link Corporation\n    Written by Edward Peng.<edward_peng@dlink.com.tw>\n    Created 03-May-2001, base on Linux' sundance.c.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#ifndef __DL2K_H__\n#define __DL2K_H__\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/bitops.h>\n#include <asm/processor.h>\t/* Processor type for cache alignment. */\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#define TX_RING_SIZE\t256\n#define TX_QUEUE_LEN\t(TX_RING_SIZE - 1) /* Limit ring entries actually used.*/\n#define RX_RING_SIZE \t256\n#define TX_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct netdev_desc)\n#define RX_TOTAL_SIZE\tRX_RING_SIZE*sizeof(struct netdev_desc)\n\n/* This driver was written to use PCI memory space, however x86-oriented\n   hardware often uses I/O space accesses. */\n#ifndef MEM_MAPPING\n#undef readb\n#undef readw\n#undef readl\n#undef writeb\n#undef writew\n#undef writel\n#define readb inb\n#define readw inw\n#define readl inl\n#define writeb outb\n#define writew outw\n#define writel outl\n#endif\n\n/* Offsets to the device registers.\n   Unlike software-only systems, device drivers interact with complex hardware.\n   It's not useful to define symbolic names for every register bit in the\n   device.  The name can only partially document the semantics and make\n   the driver longer and more difficult to read.\n   In general, only the important configuration values or bits changed\n   multiple times should be defined symbolically.\n*/\nenum dl2x_offsets {\n\t/* I/O register offsets */\n\tDMACtrl = 0x00,\n\tRxDMAStatus = 0x08,\n\tTFDListPtr0 = 0x10,\n\tTFDListPtr1 = 0x14,\n\tTxDMABurstThresh = 0x18,\n\tTxDMAUrgentThresh = 0x19,\n\tTxDMAPollPeriod = 0x1a,\n\tRFDListPtr0 = 0x1c,\n\tRFDListPtr1 = 0x20,\n\tRxDMABurstThresh = 0x24,\n\tRxDMAUrgentThresh = 0x25,\n\tRxDMAPollPeriod = 0x26,\n\tRxDMAIntCtrl = 0x28,\n\tDebugCtrl = 0x2c,\n\tASICCtrl = 0x30,\n\tFifoCtrl = 0x38,\n\tRxEarlyThresh = 0x3a,\n\tFlowOffThresh = 0x3c,\n\tFlowOnThresh = 0x3e,\n\tTxStartThresh = 0x44,\n\tEepromData = 0x48,\n\tEepromCtrl = 0x4a,\n\tExpromAddr = 0x4c,\n\tExprodata = 0x50,\n\tWakeEvent = 0x51,\n\tCountDown = 0x54,\n\tIntStatusAck = 0x5a,\n\tIntEnable = 0x5c,\n\tIntStatus = 0x5e,\n\tTxStatus = 0x60,\n\tMACCtrl = 0x6c,\n\tVLANTag = 0x70,\n\tPhyCtrl = 0x76,\n\tStationAddr0 = 0x78,\n\tStationAddr1 = 0x7a,\n\tStationAddr2 = 0x7c,\n\tVLANId = 0x80,\n\tMaxFrameSize = 0x86,\n\tReceiveMode = 0x88,\n\tHashTable0 = 0x8c,\n\tHashTable1 = 0x90,\n\tRmonStatMask = 0x98,\n\tStatMask = 0x9c,\n\tRxJumboFrames = 0xbc,\n\tTCPCheckSumErrors = 0xc0,\n\tIPCheckSumErrors = 0xc2,\n\tUDPCheckSumErrors = 0xc4,\n\tTxJumboFrames = 0xf4,\n\t/* Ethernet MIB statistic register offsets */\n\tOctetRcvOk = 0xa8,\n\tMcstOctetRcvOk = 0xac,\n\tBcstOctetRcvOk = 0xb0,\n\tFramesRcvOk = 0xb4,\n\tMcstFramesRcvdOk = 0xb8,\n\tBcstFramesRcvdOk = 0xbe,\n\tMacControlFramesRcvd = 0xc6,\n\tFrameTooLongErrors = 0xc8,\n\tInRangeLengthErrors = 0xca,\n\tFramesCheckSeqErrors = 0xcc,\n\tFramesLostRxErrors = 0xce,\n\tOctetXmtOk = 0xd0,\n\tMcstOctetXmtOk = 0xd4,\n\tBcstOctetXmtOk = 0xd8,\n\tFramesXmtOk = 0xdc,\n\tMcstFramesXmtdOk = 0xe0,\n\tFramesWDeferredXmt = 0xe4,\n\tLateCollisions = 0xe8,\n\tMultiColFrames = 0xec,\n\tSingleColFrames = 0xf0,\n\tBcstFramesXmtdOk = 0xf6,\n\tCarrierSenseErrors = 0xf8,\n\tMacControlFramesXmtd = 0xfa,\n\tFramesAbortXSColls = 0xfc,\n\tFramesWEXDeferal = 0xfe,\n\t/* RMON statistic register offsets */\n\tEtherStatsCollisions = 0x100,\n\tEtherStatsOctetsTransmit = 0x104,\n\tEtherStatsPktsTransmit = 0x108,\n\tEtherStatsPkts64OctetTransmit = 0x10c,\n\tEtherStats65to127OctetsTransmit = 0x110,\n\tEtherStatsPkts128to255OctetsTransmit = 0x114,\n\tEtherStatsPkts256to511OctetsTransmit = 0x118,\n\tEtherStatsPkts512to1023OctetsTransmit = 0x11c,\n\tEtherStatsPkts1024to1518OctetsTransmit = 0x120,\n\tEtherStatsCRCAlignErrors = 0x124,\n\tEtherStatsUndersizePkts = 0x128,\n\tEtherStatsFragments = 0x12c,\n\tEtherStatsJabbers = 0x130,\n\tEtherStatsOctets = 0x134,\n\tEtherStatsPkts = 0x138,\n\tEtherStats64Octets = 0x13c,\n\tEtherStatsPkts65to127Octets = 0x140,\n\tEtherStatsPkts128to255Octets = 0x144,\n\tEtherStatsPkts256to511Octets = 0x148,\n\tEtherStatsPkts512to1023Octets = 0x14c,\n\tEtherStatsPkts1024to1518Octets = 0x150,\n};\n\n/* Bits in the interrupt status/mask registers. */\nenum IntStatus_bits {\n\tInterruptStatus = 0x0001,\n\tHostError = 0x0002,\n\tMACCtrlFrame = 0x0008,\n\tTxComplete = 0x0004,\n\tRxComplete = 0x0010,\n\tRxEarly = 0x0020,\n\tIntRequested = 0x0040,\n\tUpdateStats = 0x0080,\n\tLinkEvent = 0x0100,\n\tTxDMAComplete = 0x0200,\n\tRxDMAComplete = 0x0400,\n\tRFDListEnd = 0x0800,\n\tRxDMAPriority = 0x1000,\n};\n\n/* Bits in the ReceiveMode register. */\nenum ReceiveMode_bits {\n\tReceiveUnicast = 0x0001,\n\tReceiveMulticast = 0x0002,\n\tReceiveBroadcast = 0x0004,\n\tReceiveAllFrames = 0x0008,\n\tReceiveMulticastHash = 0x0010,\n\tReceiveIPMulticast = 0x0020,\n\tReceiveVLANMatch = 0x0100,\n\tReceiveVLANHash = 0x0200,\n};\n/* Bits in MACCtrl. */\nenum MACCtrl_bits {\n\tDuplexSelect = 0x20,\n\tTxFlowControlEnable = 0x80,\n\tRxFlowControlEnable = 0x0100,\n\tRcvFCS = 0x200,\n\tAutoVLANtagging = 0x1000,\n\tAutoVLANuntagging = 0x2000,\n\tStatsEnable = 0x00200000,\n\tStatsDisable = 0x00400000,\n\tStatsEnabled = 0x00800000,\n\tTxEnable = 0x01000000,\n\tTxDisable = 0x02000000,\n\tTxEnabled = 0x04000000,\n\tRxEnable = 0x08000000,\n\tRxDisable = 0x10000000,\n\tRxEnabled = 0x20000000,\n};\n\nenum ASICCtrl_LoWord_bits {\n\tPhyMedia = 0x0080,\n};\n\nenum ASICCtrl_HiWord_bits {\n\tGlobalReset = 0x0001,\n\tRxReset = 0x0002,\n\tTxReset = 0x0004,\n\tDMAReset = 0x0008,\n\tFIFOReset = 0x0010,\n\tNetworkReset = 0x0020,\n\tHostReset = 0x0040,\n\tResetBusy = 0x0400,\n};\n\n/* Transmit Frame Control bits */\nenum TFC_bits {\n\tDwordAlign = 0x00000000,\n\tWordAlignDisable = 0x00030000,\n\tWordAlign = 0x00020000,\n\tTCPChecksumEnable = 0x00040000,\n\tUDPChecksumEnable = 0x00080000,\n\tIPChecksumEnable = 0x00100000,\n\tFCSAppendDisable = 0x00200000,\n\tTxIndicate = 0x00400000,\n\tTxDMAIndicate = 0x00800000,\n\tFragCountShift = 24,\n\tVLANTagInsert = 0x0000000010000000,\n\tTFDDone = 0x80000000,\n\tVIDShift = 32,\n\tUsePriorityShift = 48,\n};\n\n/* Receive Frames Status bits */\nenum RFS_bits {\n\tRxFIFOOverrun = 0x00010000,\n\tRxRuntFrame = 0x00020000,\n\tRxAlignmentError = 0x00040000,\n\tRxFCSError = 0x00080000,\n\tRxOverSizedFrame = 0x00100000,\n\tRxLengthError = 0x00200000,\n\tVLANDetected = 0x00400000,\n\tTCPDetected = 0x00800000,\n\tTCPError = 0x01000000,\n\tUDPDetected = 0x02000000,\n\tUDPError = 0x04000000,\n\tIPDetected = 0x08000000,\n\tIPError = 0x10000000,\n\tFrameStart = 0x20000000,\n\tFrameEnd = 0x40000000,\n\tRFDDone = 0x80000000,\n\tTCIShift = 32,\n\tRFS_Errors = 0x003f0000,\n};\n\n#define MII_RESET_TIME_OUT\t\t10000\n/* MII register */\nenum _mii_reg {\n\tMII_PHY_SCR = 16,\n};\n\n/* PCS register */\nenum _pcs_reg {\n\tPCS_BMCR = 0,\n\tPCS_BMSR = 1,\n\tPCS_ANAR = 4,\n\tPCS_ANLPAR = 5,\n\tPCS_ANER = 6,\n\tPCS_ANNPT = 7,\n\tPCS_ANLPRNP = 8,\n\tPCS_ESR = 15,\n};\n\n/* IEEE Extened Status Register */\nenum _mii_esr {\n\tMII_ESR_1000BX_FD = 0x8000,\n\tMII_ESR_1000BX_HD = 0x4000,\n\tMII_ESR_1000BT_FD = 0x2000,\n\tMII_ESR_1000BT_HD = 0x1000,\n};\n/* PHY Specific Control Register */\n#if 0\ntypedef union t_MII_PHY_SCR {\n\tu16 image;\n\tstruct {\n\t\tu16 disable_jabber:1;\t// bit 0\n\t\tu16 polarity_reversal:1;\t// bit 1\n\t\tu16 SEQ_test:1;\t// bit 2\n\t\tu16 _bit_3:1;\t// bit 3\n\t\tu16 disable_CLK125:1;\t// bit 4\n\t\tu16 mdi_crossover_mode:2;\t// bit 6:5\n\t\tu16 enable_ext_dist:1;\t// bit 7\n\t\tu16 _bit_8_9:2;\t// bit 9:8\n\t\tu16 force_link:1;\t// bit 10\n\t\tu16 assert_CRS:1;\t// bit 11\n\t\tu16 rcv_fifo_depth:2;\t// bit 13:12\n\t\tu16 xmit_fifo_depth:2;\t// bit 15:14\n\t} bits;\n} PHY_SCR_t, *PPHY_SCR_t;\n#endif\n\ntypedef enum t_MII_ADMIN_STATUS {\n\tadm_reset,\n\tadm_operational,\n\tadm_loopback,\n\tadm_power_down,\n\tadm_isolate\n} MII_ADMIN_t, *PMII_ADMIN_t;\n\n/* Physical Coding Sublayer Management (PCS) */\n/* PCS control and status registers bitmap as the same as MII */\n/* PCS Extended Status register bitmap as the same as MII */\n/* PCS ANAR */\nenum _pcs_anar {\n\tPCS_ANAR_NEXT_PAGE = 0x8000,\n\tPCS_ANAR_REMOTE_FAULT = 0x3000,\n\tPCS_ANAR_ASYMMETRIC = 0x0100,\n\tPCS_ANAR_PAUSE = 0x0080,\n\tPCS_ANAR_HALF_DUPLEX = 0x0040,\n\tPCS_ANAR_FULL_DUPLEX = 0x0020,\n};\n/* PCS ANLPAR */\nenum _pcs_anlpar {\n\tPCS_ANLPAR_NEXT_PAGE = PCS_ANAR_NEXT_PAGE,\n\tPCS_ANLPAR_REMOTE_FAULT = PCS_ANAR_REMOTE_FAULT,\n\tPCS_ANLPAR_ASYMMETRIC = PCS_ANAR_ASYMMETRIC,\n\tPCS_ANLPAR_PAUSE = PCS_ANAR_PAUSE,\n\tPCS_ANLPAR_HALF_DUPLEX = PCS_ANAR_HALF_DUPLEX,\n\tPCS_ANLPAR_FULL_DUPLEX = PCS_ANAR_FULL_DUPLEX,\n};\n\ntypedef struct t_SROM {\n\tu16 config_param;\t/* 0x00 */\n\tu16 asic_ctrl;\t\t/* 0x02 */\n\tu16 sub_vendor_id;\t/* 0x04 */\n\tu16 sub_system_id;\t/* 0x06 */\n\tu16 reserved1[12];\t/* 0x08-0x1f */\n\tu8 mac_addr[6];\t\t/* 0x20-0x25 */\n\tu8 reserved2[10];\t/* 0x26-0x2f */\n\tu8 sib[204];\t\t/* 0x30-0xfb */\n\tu32 crc;\t\t/* 0xfc-0xff */\n} SROM_t, *PSROM_t;\n\n/* Ioctl custom data */\nstruct ioctl_data {\n\tchar signature[10];\n\tint cmd;\n\tint len;\n\tchar *data;\n};\n\n/* The Rx and Tx buffer descriptors. */\nstruct netdev_desc {\n\t__le64 next_desc;\n\t__le64 status;\n\t__le64 fraginfo;\n};\n\n#define PRIV_ALIGN\t15\t/* Required alignment mask */\n/* Use  __attribute__((aligned (L1_CACHE_BYTES)))  to maintain alignment\n   within the structure. */\nstruct netdev_private {\n\t/* Descriptor rings first for alignment. */\n\tstruct netdev_desc *rx_ring;\n\tstruct netdev_desc *tx_ring;\n\tstruct sk_buff *rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff *tx_skbuff[TX_RING_SIZE];\n\tdma_addr_t tx_ring_dma;\n\tdma_addr_t rx_ring_dma;\n\tstruct pci_dev *pdev;\n\tspinlock_t tx_lock;\n\tspinlock_t rx_lock;\n\tstruct net_device_stats stats;\n\tunsigned int rx_buf_sz;\t\t/* Based on MTU+slack. */\n\tunsigned int speed;\t\t/* Operating speed */\n\tunsigned int vlan;\t\t/* VLAN Id */\n\tunsigned int chip_id;\t\t/* PCI table chip id */\n\tunsigned int rx_coalesce; \t/* Maximum frames each RxDMAComplete intr */\n\tunsigned int rx_timeout; \t/* Wait time between RxDMAComplete intr */\n\tunsigned int tx_coalesce;\t/* Maximum frames each tx interrupt */\n\tunsigned int full_duplex:1;\t/* Full-duplex operation requested. */\n\tunsigned int an_enable:2;\t/* Auto-Negotiated Enable */\n\tunsigned int jumbo:1;\t\t/* Jumbo frame enable */\n\tunsigned int coalesce:1;\t/* Rx coalescing enable */\n\tunsigned int tx_flow:1;\t\t/* Tx flow control enable */\n\tunsigned int rx_flow:1;\t\t/* Rx flow control enable */\n\tunsigned int phy_media:1;\t/* 1: fiber, 0: copper */\n\tunsigned int link_status:1;\t/* Current link status */\n\tstruct netdev_desc *last_tx;\t/* Last Tx descriptor used. */\n\tunsigned long cur_rx, old_rx;\t/* Producer/consumer ring indices */\n\tunsigned long cur_tx, old_tx;\n\tstruct timer_list timer;\n\tint wake_polarity;\n\tchar name[256];\t\t/* net device description */\n\tu8 duplex_polarity;\n\tu16 mcast_filter[4];\n\tu16 advertising;\t/* NWay media advertisement */\n\tu16 negotiate;\t\t/* Negotiated media */\n\tint phy_addr;\t\t/* PHY addresses. */\n};\n\n/* The station address location in the EEPROM. */\n/* The struct pci_device_id consist of:\n        vendor, device          Vendor and device ID to match (or PCI_ANY_ID)\n        subvendor, subdevice    Subsystem vendor and device ID to match (or PCI_ANY_ID)\n        class                   Device class to match. The class_mask tells which bits\n        class_mask              of the class are honored during the comparison.\n        driver_data             Data private to the driver.\n*/\n\nstatic DEFINE_PCI_DEVICE_TABLE(rio_pci_tbl) = {\n\t{0x1186, 0x4000, PCI_ANY_ID, PCI_ANY_ID, },\n\t{0x13f0, 0x1021, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ }\n};\nMODULE_DEVICE_TABLE (pci, rio_pci_tbl);\n#define TX_TIMEOUT  (4*HZ)\n#define PACKET_SIZE\t\t1536\n#define MAX_JUMBO\t\t8000\n#define RIO_IO_SIZE             340\n#define DEFAULT_RXC\t\t5\n#define DEFAULT_RXT\t\t750\n#define DEFAULT_TXC\t\t1\n#define MAX_TXC\t\t\t8\n#endif\t\t\t\t/* __DL2K_H__ */\n"], "filenames": ["drivers/net/ethernet/dlink/dl2k.c", "drivers/net/ethernet/dlink/dl2k.h"], "buggy_code_start_loc": [1262, 368], "buggy_code_end_loc": [1311, 375], "fixing_code_start_loc": [1262, 367], "fixing_code_end_loc": [1276, 367], "type": "CWE-264", "message": "The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call.", "other": {"cve": {"id": "CVE-2012-2313", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:55.920", "lastModified": "2023-02-13T00:24:25.350", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call."}, {"lang": "es", "value": "La funci\u00f3n rio_ioctl de drivers/net/ethernet/dlink/dl2k.c del kernel de Linux en versiones anteriores a la 3.3.7 no restringe el acceso al comando SIOCSMIIREG, lo que permite a usuarios locales escribir datos a un adaptador Ethernet a trav\u00e9s de una llamada ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.2}, "baseSeverity": "LOW", "exploitabilityScore": 1.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.6", "matchCriteriaId": "0EC88F78-D859-4665-9333-D770D2BDAC4E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:10.0:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "1D421F7F-A203-4868-846D-3A057610D399"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5:*:server:*:*:*:*:*", "matchCriteriaId": "5833A489-D6DE-4D51-9E74-189CBC2E28CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:5.0:*:client:*:*:*:*:*", "matchCriteriaId": "13B6DE5F-3143-4C63-8D8D-4679CF0F9DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:5.6.z:*:server:*:*:*:*:*", "matchCriteriaId": "026F2D9B-DE83-4C80-AE90-6302BAE9A41B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_long_life:5.6:*:server:*:*:*:*:*", "matchCriteriaId": "45857E5F-C284-4056-90F5-715931D59D55"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.2:*:*:*:*:*:*:*", "matchCriteriaId": "AD6D0378-F0F4-4AAA-80AF-8287C790EC96"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.1.z:*:*:*:*:*:*:*", "matchCriteriaId": "AB558E85-8929-4685-8F58-D9DA0EC8BE48"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.2.z:*:*:*:*:*:*:*", "matchCriteriaId": "BE3115B4-5DF0-415B-83D9-CC460AF75586"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=1bb57e940e1958e40d51f2078f50c3a96a9b2d75", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1174.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1481.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1541.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1589.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.7", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/04/8", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/53965", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=818820", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75"}}