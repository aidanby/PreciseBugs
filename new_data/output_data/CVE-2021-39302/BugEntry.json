{"buggy_code": ["<?php\n\nApp::uses('AppModel', 'Model');\n\nclass Log extends AppModel\n{\n    public $warningActions = array(\n        'warning',\n        'change_pw',\n        'login_fail',\n        'version_warning',\n        'auth_fail'\n    );\n    public $errorActions = array(\n        'error'\n    );\n    public $validate = array(\n            'action' => array(\n            'rule' => array(\n                'inList',\n                array( // ensure that the length of the rules is < 20 in length\n                    'accept',\n                    'accept_delegation',\n                    'acceptRegistrations',\n                    'add',\n                    'admin_email',\n                    'attachTags',\n                    'auth',\n                    'auth_fail',\n                    'blocklisted',\n                    'captureRelations',\n                    'change_pw',\n                    'delete',\n                    'disable',\n                    'discard',\n                    'discardRegistrations',\n                    'edit',\n                    'email',\n                    'enable',\n                    'enrichment',\n                    'error',\n                    'export',\n                    'fetchEvent',\n                    'file_upload',\n                    'galaxy',\n                    'include_formula',\n                    'login',\n                    'login_fail',\n                    'logout',\n                    'merge',\n                    'pruneUpdateLogs',\n                    'publish',\n                    'publish_sightings',\n                    'publish alert',\n                    'pull',\n                    'purge_events',\n                    'push',\n                    'registration',\n                    'registration_error',\n                    'remove_dead_workers',\n                    'request',\n                    'request_delegation',\n                    'reset_auth_key',\n                    'send_mail',\n                    'security',\n                    'serverSettingsEdit',\n                    'tag',\n                    'undelete',\n                    'update',\n                    'update_database',\n                    'update_db_worker',\n                    'upgrade_24',\n                    'upload_sample',\n                    'version_warning',\n                    'warning',\n                    'wipe_default'\n                )\n            ),\n            'message' => 'Options : ...'\n        )\n    );\n\n    public $actionDefinitions = array(\n        'login' => array('desc' => 'Login action', 'formdesc' => \"Login action\"),\n        'logout' => array('desc' => 'Logout action', 'formdesc' => \"Logout action\"),\n        'add' => array('desc' => 'Add action', 'formdesc' => \"Add action\"),\n        'edit' => array('desc' => 'Edit action', 'formdesc' => \"Edit action\"),\n        'change_pw' => array('desc' => 'Change_pw action', 'formdesc' => \"Change_pw action\"),\n        'delete' => array('desc' => 'Delete action', 'formdesc' => \"Delete action\"),\n        'publish' => array('desc' => \"Publish action\", 'formdesc' => \"Publish action\")\n    );\n\n    public $logMeta = array(\n        'email' => array('values' => array('email'), 'name' => 'Emails'),\n        'auth_issues' => array('values' => array('login_fail', 'auth_fail'), 'name' => 'Authentication issues')\n    );\n\n    public $logMetaAdmin = array(\n        'update' => array('values' => array('update_database'), 'name' => 'MISP Update results'),\n        'settings' => array('values' => array('serverSettingsEdit', 'remove_dead_workers'), 'name' => 'Setting changes'),\n        'errors' => array('values' => array('warning', 'error', 'version_warning'), 'name' => 'Warnings and errors'),\n        'email' => array('values' => array('admin_email'))\n    );\n\n    /**\n     * Null when not defined, false when not enabled\n     * @var Syslog|null|false\n     */\n    private $syslog;\n\n    public function beforeSave($options = array())\n    {\n        if (!empty(Configure::read('MISP.log_skip_db_logs_completely'))) {\n            return false;\n        }\n        if (Configure::read('MISP.log_client_ip')) {\n            $ip_header = 'REMOTE_ADDR';\n            if (Configure::read('MISP.log_client_ip_header')) {\n                $ip_header = Configure::read('MISP.log_client_ip_header');\n            }\n\n            if (isset($_SERVER[$ip_header])) {\n                $this->data['Log']['ip'] = $_SERVER[$ip_header];\n            }\n        }\n        $setEmpty = array('title' => '', 'model' => '', 'model_id' => 0, 'action' => '', 'user_id' => 0, 'change' => '', 'email' => '', 'org' => '', 'description' => '', 'ip' => '');\n        foreach ($setEmpty as $field => $empty) {\n            if (!isset($this->data['Log'][$field]) || empty($this->data['Log'][$field])) {\n                $this->data['Log'][$field] = $empty;\n            }\n        }\n        if (!isset($this->data['Log']['created'])) {\n            $this->data['Log']['created'] = date('Y-m-d H:i:s');\n        }\n        if (!isset($this->data['Log']['org']) || empty($this->data['Log']['org'])) {\n            $this->data['Log']['org'] = 'SYSTEM';\n        }\n        $truncate_fields = array('title', 'change', 'description');\n        foreach ($truncate_fields as $tf) {\n            if (isset($this->data['Log'][$tf]) && strlen($this->data['Log'][$tf]) >= 65535) {\n                $this->data['Log'][$tf] = substr($this->data['Log'][$tf], 0, 65532) . '...';\n            }\n        }\n        $this->logData($this->data);\n        if ($this->data['Log']['action'] === 'request' && !empty(Configure::read('MISP.log_paranoid_skip_db'))) {\n            return false;\n        }\n        return true;\n    }\n\n    public function returnDates($org = 'all')\n    {\n        $dataSourceConfig = ConnectionManager::getDataSource('default')->config;\n        $dataSource = $dataSourceConfig['datasource'];\n        $conditions = array();\n        $this->Organisation = ClassRegistry::init('Organisation');\n        if ($org !== 'all') {\n            $org = $this->Organisation->fetchOrg($org);\n            if (empty($org)) {\n                throw new MethodNotAllowedException('Invalid organisation.');\n            }\n            $conditions['org'] = $org['name'];\n        }\n        $conditions['AND']['NOT'] = array('action' => array('login', 'logout', 'changepw'));\n        if ($dataSource == 'Database/Mysql' || $dataSource == 'Database/MysqlObserver') {\n            $validDates = $this->find('all', array(\n                    'fields' => array('DISTINCT UNIX_TIMESTAMP(DATE(created)) AS Date', 'count(id) AS count'),\n                    'conditions' => $conditions,\n                    'group' => array('Date'),\n                    'order' => array('Date')\n            ));\n        } elseif ($dataSource == 'Database/Postgres') {\n            // manually generate the query for Postgres\n            // cakephp ORM would escape \"DATE\" datatype in CAST expression\n            $condnotinaction = \"'\" . implode(\"', '\", $conditions['AND']['NOT']['action']) . \"'\";\n            if (!empty($conditions['org'])) {\n                $condOrg = ' AND org = \"' . $conditions['org'] . '\"';\n            } else {\n                $condOrg = '';\n            }\n            $sql = 'SELECT DISTINCT EXTRACT(EPOCH FROM CAST(created AS DATE)) AS \"Date\",\n                                    COUNT(id) AS count\n                    FROM logs\n                    WHERE action NOT IN (' . $condnotinaction . ')\n                    ' . $condOrg . '\n                    GROUP BY \"Date\" ORDER BY \"Date\"';\n            $validDates = $this->query($sql);\n        }\n        $data = array();\n        foreach ($validDates as $k => $date) {\n            $data[$date[0]['Date']] = intval($date[0]['count']);\n        }\n        return $data;\n    }\n\n    /**\n     * @param string|array $user\n     * @param string $action\n     * @param string $model\n     * @param int $modelId\n     * @param string $title\n     * @param string|array $change\n     * @return array|null\n     * @throws Exception\n     * @throws InvalidArgumentException\n     */\n    public function createLogEntry($user, $action, $model, $modelId = 0, $title = '', $change = '')\n    {\n        if (in_array($action, ['tag', 'galaxy', 'publish', 'publish_sightings'], true) && Configure::read('MISP.log_new_audit')) {\n            return; // Do not store tag changes when new audit is enabled\n        }\n        if ($user === 'SYSTEM') {\n            $user = array('Organisation' => array('name' => 'SYSTEM'), 'email' => 'SYSTEM', 'id' => 0);\n        } else if (!is_array($user)) {\n            throw new InvalidArgumentException(\"User must be array or 'SYSTEM' string.\");\n        }\n\n        if (is_array($change)) {\n            $output = array();\n            foreach ($change as $field => $values) {\n                $isSecret = strpos($field, 'password') !== false || ($field === 'authkey' && Configure::read('Security.do_not_log_authkeys'));\n                if ($isSecret) {\n                    $oldValue = $newValue = \"*****\";\n                } else {\n                    list($oldValue, $newValue) = $values;\n                }\n                $output[] = \"$field ($oldValue) => ($newValue)\";\n            }\n            $change = implode(\", \", $output);\n        }\n\n        $this->create();\n        $result = $this->save(array(\n            'org' => $user['Organisation']['name'],\n            'email' => $user['email'],\n            'user_id' => $user['id'],\n            'action' => $action,\n            'title' => $title,\n            'change' => $change,\n            'model' => $model,\n            'model_id' => $modelId,\n        ));\n\n        if (!$result) {\n            if ($action === 'request' && !empty(Configure::read('MISP.log_paranoid_skip_db'))) {\n                return null;\n            }\n\n            throw new Exception(\"Cannot save log because of validation errors: \" . json_encode($this->validationErrors));\n        }\n\n        return $result;\n    }\n\n    // to combat a certain bug that causes the upgrade scripts to loop without being able to set the correct version\n    // this function remedies a fixed upgrade bug instance by eliminating the massive number of erroneous upgrade log entries\n    public function pruneUpdateLogs($jobId = false, $user)\n    {\n        $max = $this->find('first', array('fields' => array('MAX(id) AS lastid')));\n        if (!empty($max)) {\n            $max = $max[0]['lastid'];\n        }\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $iterations = ($max / 1000);\n        for ($i = 0; $i < $iterations; $i++) {\n            $this->deleteAll(array(\n                'OR' => array(\n                        'action' => 'update_database',\n                        'AND' => array(\n                            'action' => 'edit',\n                            'model' => 'AdminSetting'\n                        )\n                ),\n                'id >' => $i * 1000,\n                'id <' => ($i+1) * 1000));\n            if ($jobId) {\n                $this->Job->saveField('progress', $i * 100 / $iterations);\n            }\n        }\n        $this->create();\n        $this->save(array(\n                'org' => $user['Organisation']['name'],\n                'email' =>$user['email'],\n                'user_id' => $user['id'],\n                'action' => 'pruneUpdateLogs',\n                'title' => 'Pruning updates',\n                'change' => 'Pruning completed in ' . $i . ' iteration(s).',\n                'model' => 'Log',\n                'model_id' => 0\n        ));\n    }\n\n\n    public function pruneUpdateLogsRouter($user)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'default',\n                    'job_type' => 'prune_update_logs',\n                    'job_input' => 'All update entries',\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Purging the heretic.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'default',\n                    'AdminShell',\n                    array('prune_update_logs', $jobId, $user['id']),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return $process_id;\n        } else {\n            $result = $this->pruneUpdateLogs(false, $user);\n            return $result;\n        }\n    }\n\n    public function logData($data)\n    {\n        if (Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_audit_notifications_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $pubSubTool->publish($data, 'audit', 'log');\n        }\n\n        $this->publishKafkaNotification('audit', $data, 'log');\n\n        if (Configure::read('Plugin.ElasticSearch_logging_enable')) {\n            // send off our logs to distributed /dev/null\n            $logIndex = Configure::read(\"Plugin.ElasticSearch_log_index\");\n            $elasticSearchClient = $this->getElasticSearchTool();\n            $elasticSearchClient->pushDocument($logIndex, \"log\", $data);\n        }\n\n        // Do not save request action logs to syslog, because they contain no information\n        if ($data['Log']['action'] === 'request') {\n            return true;\n        }\n\n        // write to syslogd as well if enabled\n        if ($this->syslog === null) {\n            if (Configure::read('Security.syslog')) {\n                $options = [];\n                $syslogToStdErr = Configure::read('Security.syslog_to_stderr');\n                if ($syslogToStdErr !== null) {\n                    $options['to_stderr'] = $syslogToStdErr;\n                }\n                $syslogIdent = Configure::read('Security.syslog_ident');\n                if ($syslogIdent) {\n                    $options['ident'] = $syslogIdent;\n                }\n                $this->syslog = new SysLog($options);\n            } else {\n                $this->syslog = false;\n            }\n        }\n        if ($this->syslog) {\n            $action = 'info';\n            if (isset($data['Log']['action'])) {\n                if (in_array($data['Log']['action'], $this->errorActions)) {\n                    $action = 'err';\n                }\n                if (in_array($data['Log']['action'], $this->warningActions)) {\n                    $action = 'warning';\n                }\n            }\n\n            $entry = $data['Log']['action'];\n            if (!empty($data['Log']['title'])) {\n                $entry .= \" -- {$data['Log']['title']}\";\n            }\n            if (!empty($data['Log']['description'])) {\n                $entry .= \" -- {$data['Log']['description']}\";\n            }\n            $this->syslog->write($action, $entry);\n        }\n        return true;\n    }\n\n    public function filterSiteAdminSensitiveLogs($list)\n    {\n        $this->User = ClassRegistry::init('User');\n        $site_admin_roles = $this->User->Role->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Role.perm_site_admin' => 1),\n            'fields' => array('Role.id', 'Role.id')\n        ));\n        $site_admins = $this->User->find('list', array(\n            'recursive' => -1,\n            'conditions' => array(\n                'User.role_id' => array_values($site_admin_roles)\n            ),\n            'fields' => array('User.id', 'User.id')\n        ));\n        foreach ($list as $k => $v) {\n            if (\n                $v['Log']['model'] === 'User' &&\n                in_array($v['Log']['model_id'], array_values($site_admins)) &&\n                in_array($v['Log']['action'], array('add', 'edit', 'reset_auth_key'))\n            ) {\n                $list[$k]['Log']['change'] = __('Redacted');\n            }\n        }\n        return $list;\n    }\n\n    public function changeParser($change)\n    {\n        $change = explode(',', $change);\n        $data = [];\n        foreach ($change as $entry) {\n            $entry = trim($entry);\n            $fieldName = explode(' ', $entry)[0];\n            $entry = substr($entry, strlen($fieldName));\n            $entry = trim($entry);\n            if (strpos($entry, ') => (')) {\n                list($before, $after) = explode(') => (', $entry);\n                $before = substr($before, 1);\n                $after = substr($after, 0, -1);\n                $data[$fieldName] = $after;\n            }\n        }\n        return $data;\n    }\n\n    public function findDeletedEvents($conditions)\n    {\n        $conditions['model'] = 'Event';\n        $conditions['action'] = 'delete';\n        $this->Event = ClassRegistry::init('Event');\n        $deletions = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => $conditions,\n            'order' => ['Log.id']\n        ]);\n        $deleted_events = [];\n        $users = [];\n        $orgs = [];\n        $deleted_event_ids = [];\n        foreach ($deletions as $deletion_entry) {\n            if (!empty($deleted_event_ids[$deletion_entry['Log']['model_id']])) {\n                continue;\n            } else {\n                $deleted_event_ids[$deletion_entry['Log']['model_id']] = true;\n            }\n            $event = $this->Event->find('first', [\n                'conditions' => ['Event.id' => $deletion_entry['Log']['model_id']],\n                'recursive' => -1,\n                'fields' => ['Event.id']\n            ]);\n            if (!empty($event)) {\n                // event is already restored / not deleted\n                continue;\n            }\n            $temp = [\n                'event_id' => $deletion_entry['Log']['model_id'],\n                'user_id' => $deletion_entry['Log']['user_id'],\n                'created' => $deletion_entry['Log']['created']\n            ];\n            $event_creation_entry = $this->find('first', [\n                'recursive' => -1,\n                'conditions' => [\n                    'model_id' => $temp['event_id'],\n                    'model' => 'Event',\n                    'action' => 'add'\n                ]\n            ]);\n            $event = $this->changeParser($event_creation_entry['Log']['change']);\n            $temp['event_info'] = $event['info'];\n            $temp['event_org_id'] = $event['org_id'];\n            $temp['event_orgc_id'] = $event['orgc_id'];\n            $temp['event_user_id'] = $event['user_id'];\n            $temp['event_info'] = $event['info'];\n            $temp['event_created'] = $event_creation_entry['Log']['created'];\n            foreach (['org', 'orgc'] as $scope) {\n                if (empty($orgs[$temp['event_' . $scope . '_id']])) {\n                    $orgs[$temp['event_' . $scope . '_id']] = array_values($this->Event->Orgc->find('list', [\n                        'recursive' => -1,\n                        'conditions' => array('id' => $temp['event_' . $scope . '_id']),\n                        'fields' => array('id', 'name')\n                    ]))[0];\n                }\n                $temp['event_' . $scope . '_name'] = $orgs[$temp['event_' . $scope . '_id']];\n            }\n            $users[$temp['user_id']] = array_values($this->Event->User->find('list', [\n                'recursive' => -1,\n                'conditions' => array('id' => $temp['user_id']),\n                'fields' => array('id', 'email')\n            ]))[0];\n            $temp['user_name'] = $users[$temp['user_id']];\n            $users[$temp['event_user_id']] = array_values($this->Event->User->find('list', [\n                'recursive' => -1,\n                'conditions' => array('id' => $temp['event_user_id']),\n                'fields' => array('id', 'email')\n            ]))[0];\n            $temp['event_user_name'] = $users[$temp['event_user_id']];\n            $deleted_events[] = $temp;\n        }\n        return $deleted_events;\n    }\n\n    public function recoverDeletedEvent($id, $mock = false)\n    {\n        if ($mock) {\n            $this->mockRecovery = true;\n            $this->mockLog = [];\n        }\n        $objectMap = [];\n        $logEntries = [];\n        $this->__recoverDeletedEventContainer($id, $objectMap, $logEntries);\n        $this->__recoverDeletedObjects($id, $objectMap, $logEntries);\n        $this->__recoverDeletedAttributes($id, $objectMap, $logEntries);\n        $this->__recoverDeletedObjectReferences($id, $objectMap, $logEntries);\n        $this->__recoverDeletedTagConnectors($id, $objectMap, $logEntries, 'Event');\n        $this->__recoverDeletedTagConnectors($id, $objectMap, $logEntries, 'Attribute');\n        $this->__recoverDeletedProposals($id, $objectMap, $logEntries);\n        ksort($logEntries);\n        foreach ($logEntries as $logEntry) {\n            $this->{'__executeRecovery' . $logEntry['model']}($logEntry, $id);\n        }\n        return count($logEntries);\n        // order: event -> object -> attribute -> object reference -> tag -> galaxy -> shadow_attribute -> sighting\n    }\n\n    private function __recoverDeletedEventContainer($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Event',\n                'model_id' => $id,\n                'action' => ['add', 'edit', 'publish', 'alert']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['Event'][$log['Log']['model_id']] = true;\n        }\n    }\n\n    private function __recoverDeletedObjects($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'MispObject',\n                'change LIKE ' => '%event_id () => (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['MispObject'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'MispObject',\n                'model_id' => array_keys($objectMap['MispObject']),\n                'action' => ['add', 'edit', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n        }\n    }\n\n    private function __recoverDeletedObjectReferences($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ObjectReference',\n                'change LIKE ' => '%event_id () => (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['ObjectReference'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ObjectReference',\n                'model_id' => array_keys($objectMap['ObjectReference']),\n                'action' => ['add', 'edit']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n        }\n    }\n\n    private function __recoverDeletedTagConnectors($id, &$objectMap, &$logEntries, $scope)\n    {\n        if (empty($objectMap[$scope])) {\n            // example: we have no attributes, so we return\n            return;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => $scope,\n                'action' => ['tag', 'galaxy'],\n                'model_id' => array_keys($objectMap[$scope])\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            if ($log['Log']['action'] === 'tag') {\n                $temp = explode(' ', $log['Log']['title']);\n                $local = ($temp[1] === 'local' ? true : false);\n                $tag_id = ($local ? $temp[3] : $temp[2]);\n                $tag_id = substr($tag_id, 1, -1);\n            } else {\n                $matches = [];\n                preg_match('/\\(([0-9]*)\\)\\s(from|to)/', $log['Log']['title'], $matches);\n                if (!isset($matches[1])) {\n                    continue;\n                }\n                $local = false;\n                $tag_id = $matches[1];\n            }\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => (strpos($log['Log']['title'], 'Attached')) === false ? 'remove_tag' : 'add_tag',\n                'data' => [\n                    'tag_id' => $tag_id,\n                    'id' => $log['Log']['model_id'],\n                    'target_type' => $log['Log']['model'],\n                    'tag_type' => $log['Log']['action'],\n                    'local' => $local\n                ]\n            ];\n        }\n    }\n\n    private function __recoverDeletedAttributes($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Attribute',\n                'title LIKE ' => '%from Event (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['Attribute'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Attribute',\n                'model_id' => array_keys($objectMap['Attribute']),\n                'action' => ['add', 'edit', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['Attribute'][$log['Log']['model_id']] = true;\n        }\n    }\n\n    private function __recoverDeletedProposals($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ShadowAttribute',\n                'title LIKE ' => '%: to Event (' . $id . '): %',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['ShadowAttribute'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ShadowAttribute',\n                'model_id' => array_keys($objectMap['ShadowAttribute']),\n                'action' => ['add', 'accept', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['ShadowAttribute'][$log['Log']['model_id']] = true;\n        }\n    }\n\n\n    private function __executeRecoveryEvent($logEntry, $id)\n    {\n        if (empty($this->Event)) {\n            $this->Event = ClassRegistry::init('Event');\n        }\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        if (empty($this->EventBlocklist)) {\n            $this->EventBlocklist = ClassRegistry::init('EventBlocklist');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'Event', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->Event->create();\n                    $this->Event->save($logEntry['data']);\n                    $blockListEntry = $this->EventBlocklist->find('first', array(\n                        'conditions' => array('event_uuid' => $logEntry['data']['uuid']),\n                        'fields' => 'id'\n                    ));\n                    if (!empty($blockListEntry)) {\n                        $this->EventBlocklist->delete($blockListEntry['EventBlocklist']['id']);\n                    }\n                }\n                break;\n            case 'edit':\n            case 'publish':\n                $event = $this->Event->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Event.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($event)) {\n                    if ($logEntry['action'] === 'publish' || $logEntry['action'] === 'alert') {\n                        $event['Event']['published'] = 1;\n                        $event['Event']['publish_timestamp'] = strtotime($logEntry['data']['timestamp']);\n                    } else {\n                        foreach ($logEntry['data'] as $field => $value) {\n                            $event['Event'][$field] = $value;\n                        }\n                    }\n                    $this->Event->create();\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Event', 'action' => 'edit', 'data' => $event];\n                    } else {\n                        $this->Event->save($event);\n                    }\n                }\n                break;\n            case 'add_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $this->Event->EventTag->create();\n                $this->Event->create();\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'EventTag', 'action' => 'add', 'data' => [\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id'],\n                        'local' => !empty($logEntry['data']['local'])\n                    ]];\n                } else {\n                    $this->Event->EventTag->save([\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id'],\n                        'local' => !empty($logEntry['data']['local'])\n                    ]);\n                }\n                break;\n            case 'remove_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $et = $this->Event->EventTag->find('first', [\n                    'recursive' => -1,\n                    'conditions' => [\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id']\n                    ]\n                ]);\n                if (!empty($et)) {\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'EventTag', 'action' => 'delete', 'data' => $et['EventTag']['id']];\n                    } else {\n                        $this->Event->EventTag->delete($et['EventTag']['id']);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryAttribute($logEntry, $id)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        if (!empty($logEntry['data']['value1'])) {\n            $logEntry['data']['value'] = $logEntry['data']['value1'];\n            if (!empty($logEntry['data']['value2'])) {\n                $logEntry .= '|' . $logEntry['data']['value2'];\n            }\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data'] = $this->Attribute->UTCToISODatetime(['Attribute' => $logEntry['data']], 'Attribute');\n                $logEntry['data'] = $logEntry['data']['Attribute'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'Attribute', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->Attribute->create();\n                    if (!isset($logEntry['data']['to_ids'])) {\n                        $logEntry['data']['to_ids'] = 0;\n                    }\n                    $this->Attribute->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $attribute = $this->Attribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Attribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($attribute)) {\n                    $logEntry['data'] = $this->Attribute->UTCToISODatetime(['Attribute' => $logEntry['data']], 'Attribute');\n                    $logEntry['data'] = $logEntry['data']['Attribute'];\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $attribute['Attribute'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'edit', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                break;\n            case 'delete':\n                $attribute = $this->Attribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Attribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($attribute)) {\n                    $attribute['Attribute']['deleted'] = 1;\n                    $attribute['Attribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'delete', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                break;\n            case 'add_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'AttributeTag', 'action' => 'add', 'data' => [\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id,\n                        'local' => !empty($logEntry['data']['local'])\n                    ]];\n                } else {\n                    $this->Attribute->AttributeTag->create();\n                    $this->Attribute->AttributeTag->save([\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id,\n                        'local' => !empty($logEntry['data']['local'])\n                    ]);\n                }\n                break;\n            case 'remove_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $at = $this->Attribute->AttributeTag->find('first', [\n                    'recursive' => -1,\n                    'conditions' => [\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id\n                    ]\n                ]);\n                if (!empty($at)) {\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'AttributeTag', 'action' => 'delete', 'data' => $at['AttributeTag']['id']];\n                    } else {\n                        $this->Attribute->AttributeTag->delete($at['AttributeTag']['id']);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryShadowAttribute($logEntry, $id)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->ShadowAttribute)) {\n            $this->ShadowAttribute = ClassRegistry::init('ShadowAttribute');\n        }\n        if (!empty($logEntry['data']['value1'])) {\n            $logEntry['data']['value'] = $logEntry['data']['value1'];\n            if (!empty($logEntry['data']['value2'])) {\n                $logEntry .= '|' . $logEntry['data']['value2'];\n            }\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data']['value'] = $logEntry['data']['value1'];\n                if (!empty($logEntry['data']['value2'])) {\n                    $logEntry['data']['value'] .= '|' . $logEntry['data']['value2'];\n                }\n                $logEntry['data'] = $this->Attribute->UTCToISODatetime(['ShadowAttribute' => $logEntry['data']], 'ShadowAttribute');\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->ShadowAttribute->create();\n                    $this->ShadowAttribute->save($logEntry['data']);\n                }\n                break;\n            case 'delete':\n                $shadow_attribute = $this->ShadowAttribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ShadowAttribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($shadow_attribute)) {\n                    $shadow_attribute['ShadowAttribute']['deleted'] = 1;\n                    $shadow_attribute['ShadowAttribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'delete', 'data' => $attribute];\n                    } else {\n                        $this->ShadowAttribute->save($attribute);\n                    }\n                }\n                break;\n            case 'accept':\n                $shadow_attribute = $this->ShadowAttribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ShadowAttribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($shadow_attribute['ShadowAttribute']['old_id'])) {\n                    $attribute = $this->Attribute->find('first', [\n                        'conditions' => ['Attribute.id' => $shadow_attribute['ShadowAttribute']['old_id']],\n                        'recursive' => -1\n                    ]);\n                    if (!empty($shadow_attribute['ShadowAttribute']['proposal_to_delete'])) {\n                        $attribute['Attribute']['deleted'] = 1;\n                    } else {\n                        foreach(['category', 'type', 'value', 'to_ids', 'comment', 'first_seen', 'last_seen'] as $field) {\n                            if (isset($shadow_attribute['ShadowAttribute'][$field])) {\n                                $attribute['Attribute'][$field] = $shadow_attribute['ShadowAttribute'][$field];\n                            }\n                        }\n                    }\n                    $attribute['Attribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'edit', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                } else {\n                    $this->Attribute->create();\n                    $attribute = $shadow_attribute['ShadowAttribute'];\n                    if (isset($attribute['id'])) {\n                        unset($attribute['id']);\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'add', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                $shadow_attribute['ShadowAttribute']['deleted'] = 1;\n                $shadow_attribute['ShadowAttribute']['timestamp'] = $logEntry['data']['timestamp'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'delete', 'data' => $shadow_attribute];\n                } else {\n                    $this->ShadowAttribute->save($shadow_attribute);\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryObjectReference($logEntry, $id)\n    {\n        if (empty($this->ObjectReference)) {\n            $this->ObjectReference = ClassRegistry::init('ObjectReference');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ObjectReference', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->ObjectReference->create();\n                    $this->ObjectReference->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $objectRef = $this->ObjectReference->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ObjectReference.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($object)) {\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $object['ObjectReference'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'ObjectReference', 'action' => 'edit', 'data' => $object];\n                    } else {\n                        $this->ObjectReference->save($object);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryMispObject($logEntry)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->MispObject)) {\n            $this->MispObject = ClassRegistry::init('MispObject');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data'] = $this->MispObject->Attribute->UTCToISODatetime(['Object' => $logEntry['data']], 'Object');\n                $logEntry['data'] = $logEntry['data']['Object'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'MispObject', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->MispObject->create();\n                    $this->MispObject->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $logEntry['data'] = $this->MispObject->Attribute->UTCToISODatetime(['Object' => $logEntry['data']], 'Object');\n                $logEntry['data'] = $logEntry['data']['Object'];\n                $object = $this->MispObject->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Object.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($object)) {\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $object['Object'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'MispObject', 'action' => 'add', 'data' => $object];\n                    } else {\n                        $this->MispObject->save($object);\n                    }\n                }\n                break;\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\nApp::uses('AppModel', 'Model');\n\nclass Log extends AppModel\n{\n    public $warningActions = array(\n        'warning',\n        'change_pw',\n        'login_fail',\n        'version_warning',\n        'auth_fail'\n    );\n    public $errorActions = array(\n        'error'\n    );\n    public $validate = array(\n            'action' => array(\n            'rule' => array(\n                'inList',\n                array( // ensure that the length of the rules is < 20 in length\n                    'accept',\n                    'accept_delegation',\n                    'acceptRegistrations',\n                    'add',\n                    'admin_email',\n                    'attachTags',\n                    'auth',\n                    'auth_fail',\n                    'blocklisted',\n                    'captureRelations',\n                    'change_pw',\n                    'delete',\n                    'disable',\n                    'discard',\n                    'discardRegistrations',\n                    'edit',\n                    'email',\n                    'enable',\n                    'enrichment',\n                    'error',\n                    'export',\n                    'fetchEvent',\n                    'file_upload',\n                    'galaxy',\n                    'include_formula',\n                    'login',\n                    'login_fail',\n                    'logout',\n                    'merge',\n                    'pruneUpdateLogs',\n                    'publish',\n                    'publish_sightings',\n                    'publish alert',\n                    'pull',\n                    'purge_events',\n                    'push',\n                    'registration',\n                    'registration_error',\n                    'remove_dead_workers',\n                    'request',\n                    'request_delegation',\n                    'reset_auth_key',\n                    'send_mail',\n                    'security',\n                    'serverSettingsEdit',\n                    'tag',\n                    'undelete',\n                    'update',\n                    'update_database',\n                    'update_db_worker',\n                    'upgrade_24',\n                    'upload_sample',\n                    'version_warning',\n                    'warning',\n                    'wipe_default'\n                )\n            ),\n            'message' => 'Options : ...'\n        )\n    );\n\n    public $actionDefinitions = array(\n        'login' => array('desc' => 'Login action', 'formdesc' => \"Login action\"),\n        'logout' => array('desc' => 'Logout action', 'formdesc' => \"Logout action\"),\n        'add' => array('desc' => 'Add action', 'formdesc' => \"Add action\"),\n        'edit' => array('desc' => 'Edit action', 'formdesc' => \"Edit action\"),\n        'change_pw' => array('desc' => 'Change_pw action', 'formdesc' => \"Change_pw action\"),\n        'delete' => array('desc' => 'Delete action', 'formdesc' => \"Delete action\"),\n        'publish' => array('desc' => \"Publish action\", 'formdesc' => \"Publish action\")\n    );\n\n    public $logMeta = array(\n        'email' => array('values' => array('email'), 'name' => 'Emails'),\n        'auth_issues' => array('values' => array('login_fail', 'auth_fail'), 'name' => 'Authentication issues')\n    );\n\n    public $logMetaAdmin = array(\n        'update' => array('values' => array('update_database'), 'name' => 'MISP Update results'),\n        'settings' => array('values' => array('serverSettingsEdit', 'remove_dead_workers'), 'name' => 'Setting changes'),\n        'errors' => array('values' => array('warning', 'error', 'version_warning'), 'name' => 'Warnings and errors'),\n        'email' => array('values' => array('admin_email'))\n    );\n\n    /**\n     * Null when not defined, false when not enabled\n     * @var Syslog|null|false\n     */\n    private $syslog;\n\n    public function beforeSave($options = array())\n    {\n        if (!empty(Configure::read('MISP.log_skip_db_logs_completely'))) {\n            return false;\n        }\n        if (Configure::read('MISP.log_client_ip')) {\n            $ip_header = 'REMOTE_ADDR';\n            if (Configure::read('MISP.log_client_ip_header')) {\n                $ip_header = Configure::read('MISP.log_client_ip_header');\n            }\n\n            if (isset($_SERVER[$ip_header])) {\n                $this->data['Log']['ip'] = $_SERVER[$ip_header];\n            }\n        }\n        $setEmpty = array('title' => '', 'model' => '', 'model_id' => 0, 'action' => '', 'user_id' => 0, 'change' => '', 'email' => '', 'org' => '', 'description' => '', 'ip' => '');\n        foreach ($setEmpty as $field => $empty) {\n            if (!isset($this->data['Log'][$field]) || empty($this->data['Log'][$field])) {\n                $this->data['Log'][$field] = $empty;\n            }\n        }\n        if (!isset($this->data['Log']['created'])) {\n            $this->data['Log']['created'] = date('Y-m-d H:i:s');\n        }\n        if (!isset($this->data['Log']['org']) || empty($this->data['Log']['org'])) {\n            $this->data['Log']['org'] = 'SYSTEM';\n        }\n        $truncate_fields = array('title', 'change', 'description');\n        foreach ($truncate_fields as $tf) {\n            if (isset($this->data['Log'][$tf]) && strlen($this->data['Log'][$tf]) >= 65535) {\n                $this->data['Log'][$tf] = substr($this->data['Log'][$tf], 0, 65532) . '...';\n            }\n        }\n        $this->logData($this->data);\n        if ($this->data['Log']['action'] === 'request' && !empty(Configure::read('MISP.log_paranoid_skip_db'))) {\n            return false;\n        }\n        return true;\n    }\n\n    public function returnDates($org = 'all')\n    {\n        $dataSourceConfig = ConnectionManager::getDataSource('default')->config;\n        $dataSource = $dataSourceConfig['datasource'];\n        $conditions = array();\n        $this->Organisation = ClassRegistry::init('Organisation');\n        if ($org !== 'all') {\n            $org = $this->Organisation->fetchOrg($org);\n            if (empty($org)) {\n                throw new MethodNotAllowedException('Invalid organisation.');\n            }\n            $conditions['org'] = $org['name'];\n        }\n        $conditions['AND']['NOT'] = array('action' => array('login', 'logout', 'changepw'));\n        if ($dataSource == 'Database/Mysql' || $dataSource == 'Database/MysqlObserver') {\n            $validDates = $this->find('all', array(\n                    'fields' => array('DISTINCT UNIX_TIMESTAMP(DATE(created)) AS Date', 'count(id) AS count'),\n                    'conditions' => $conditions,\n                    'group' => array('Date'),\n                    'order' => array('Date')\n            ));\n        } elseif ($dataSource == 'Database/Postgres') {\n            // manually generate the query for Postgres\n            // cakephp ORM would escape \"DATE\" datatype in CAST expression\n            $condnotinaction = \"'\" . implode(\"', '\", $conditions['AND']['NOT']['action']) . \"'\";\n            if (!empty($conditions['org'])) {\n                $condOrg = sprintf('AND org = %s', $this->getDataSource()->value($conditions['org']));\n            } else {\n                $condOrg = '';\n            }\n            $sql = 'SELECT DISTINCT EXTRACT(EPOCH FROM CAST(created AS DATE)) AS \"Date\",\n                                    COUNT(id) AS count\n                    FROM logs\n                    WHERE action NOT IN (' . $condnotinaction . ')\n                    ' . $condOrg . '\n                    GROUP BY \"Date\" ORDER BY \"Date\"';\n            $validDates = $this->query($sql);\n        }\n        $data = array();\n        foreach ($validDates as $k => $date) {\n            $data[$date[0]['Date']] = intval($date[0]['count']);\n        }\n        return $data;\n    }\n\n    /**\n     * @param string|array $user\n     * @param string $action\n     * @param string $model\n     * @param int $modelId\n     * @param string $title\n     * @param string|array $change\n     * @return array|null\n     * @throws Exception\n     * @throws InvalidArgumentException\n     */\n    public function createLogEntry($user, $action, $model, $modelId = 0, $title = '', $change = '')\n    {\n        if (in_array($action, ['tag', 'galaxy', 'publish', 'publish_sightings'], true) && Configure::read('MISP.log_new_audit')) {\n            return; // Do not store tag changes when new audit is enabled\n        }\n        if ($user === 'SYSTEM') {\n            $user = array('Organisation' => array('name' => 'SYSTEM'), 'email' => 'SYSTEM', 'id' => 0);\n        } else if (!is_array($user)) {\n            throw new InvalidArgumentException(\"User must be array or 'SYSTEM' string.\");\n        }\n\n        if (is_array($change)) {\n            $output = array();\n            foreach ($change as $field => $values) {\n                $isSecret = strpos($field, 'password') !== false || ($field === 'authkey' && Configure::read('Security.do_not_log_authkeys'));\n                if ($isSecret) {\n                    $oldValue = $newValue = \"*****\";\n                } else {\n                    list($oldValue, $newValue) = $values;\n                }\n                $output[] = \"$field ($oldValue) => ($newValue)\";\n            }\n            $change = implode(\", \", $output);\n        }\n\n        $this->create();\n        $result = $this->save(array(\n            'org' => $user['Organisation']['name'],\n            'email' => $user['email'],\n            'user_id' => $user['id'],\n            'action' => $action,\n            'title' => $title,\n            'change' => $change,\n            'model' => $model,\n            'model_id' => $modelId,\n        ));\n\n        if (!$result) {\n            if ($action === 'request' && !empty(Configure::read('MISP.log_paranoid_skip_db'))) {\n                return null;\n            }\n\n            throw new Exception(\"Cannot save log because of validation errors: \" . json_encode($this->validationErrors));\n        }\n\n        return $result;\n    }\n\n    // to combat a certain bug that causes the upgrade scripts to loop without being able to set the correct version\n    // this function remedies a fixed upgrade bug instance by eliminating the massive number of erroneous upgrade log entries\n    public function pruneUpdateLogs($jobId = false, $user)\n    {\n        $max = $this->find('first', array('fields' => array('MAX(id) AS lastid')));\n        if (!empty($max)) {\n            $max = $max[0]['lastid'];\n        }\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $iterations = ($max / 1000);\n        for ($i = 0; $i < $iterations; $i++) {\n            $this->deleteAll(array(\n                'OR' => array(\n                        'action' => 'update_database',\n                        'AND' => array(\n                            'action' => 'edit',\n                            'model' => 'AdminSetting'\n                        )\n                ),\n                'id >' => $i * 1000,\n                'id <' => ($i+1) * 1000));\n            if ($jobId) {\n                $this->Job->saveField('progress', $i * 100 / $iterations);\n            }\n        }\n        $this->create();\n        $this->save(array(\n                'org' => $user['Organisation']['name'],\n                'email' =>$user['email'],\n                'user_id' => $user['id'],\n                'action' => 'pruneUpdateLogs',\n                'title' => 'Pruning updates',\n                'change' => 'Pruning completed in ' . $i . ' iteration(s).',\n                'model' => 'Log',\n                'model_id' => 0\n        ));\n    }\n\n\n    public function pruneUpdateLogsRouter($user)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'default',\n                    'job_type' => 'prune_update_logs',\n                    'job_input' => 'All update entries',\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Purging the heretic.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'default',\n                    'AdminShell',\n                    array('prune_update_logs', $jobId, $user['id']),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return $process_id;\n        } else {\n            $result = $this->pruneUpdateLogs(false, $user);\n            return $result;\n        }\n    }\n\n    public function logData($data)\n    {\n        if (Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_audit_notifications_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $pubSubTool->publish($data, 'audit', 'log');\n        }\n\n        $this->publishKafkaNotification('audit', $data, 'log');\n\n        if (Configure::read('Plugin.ElasticSearch_logging_enable')) {\n            // send off our logs to distributed /dev/null\n            $logIndex = Configure::read(\"Plugin.ElasticSearch_log_index\");\n            $elasticSearchClient = $this->getElasticSearchTool();\n            $elasticSearchClient->pushDocument($logIndex, \"log\", $data);\n        }\n\n        // Do not save request action logs to syslog, because they contain no information\n        if ($data['Log']['action'] === 'request') {\n            return true;\n        }\n\n        // write to syslogd as well if enabled\n        if ($this->syslog === null) {\n            if (Configure::read('Security.syslog')) {\n                $options = [];\n                $syslogToStdErr = Configure::read('Security.syslog_to_stderr');\n                if ($syslogToStdErr !== null) {\n                    $options['to_stderr'] = $syslogToStdErr;\n                }\n                $syslogIdent = Configure::read('Security.syslog_ident');\n                if ($syslogIdent) {\n                    $options['ident'] = $syslogIdent;\n                }\n                $this->syslog = new SysLog($options);\n            } else {\n                $this->syslog = false;\n            }\n        }\n        if ($this->syslog) {\n            $action = 'info';\n            if (isset($data['Log']['action'])) {\n                if (in_array($data['Log']['action'], $this->errorActions)) {\n                    $action = 'err';\n                }\n                if (in_array($data['Log']['action'], $this->warningActions)) {\n                    $action = 'warning';\n                }\n            }\n\n            $entry = $data['Log']['action'];\n            if (!empty($data['Log']['title'])) {\n                $entry .= \" -- {$data['Log']['title']}\";\n            }\n            if (!empty($data['Log']['description'])) {\n                $entry .= \" -- {$data['Log']['description']}\";\n            }\n            $this->syslog->write($action, $entry);\n        }\n        return true;\n    }\n\n    public function filterSiteAdminSensitiveLogs($list)\n    {\n        $this->User = ClassRegistry::init('User');\n        $site_admin_roles = $this->User->Role->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Role.perm_site_admin' => 1),\n            'fields' => array('Role.id', 'Role.id')\n        ));\n        $site_admins = $this->User->find('list', array(\n            'recursive' => -1,\n            'conditions' => array(\n                'User.role_id' => array_values($site_admin_roles)\n            ),\n            'fields' => array('User.id', 'User.id')\n        ));\n        foreach ($list as $k => $v) {\n            if (\n                $v['Log']['model'] === 'User' &&\n                in_array($v['Log']['model_id'], array_values($site_admins)) &&\n                in_array($v['Log']['action'], array('add', 'edit', 'reset_auth_key'))\n            ) {\n                $list[$k]['Log']['change'] = __('Redacted');\n            }\n        }\n        return $list;\n    }\n\n    public function changeParser($change)\n    {\n        $change = explode(',', $change);\n        $data = [];\n        foreach ($change as $entry) {\n            $entry = trim($entry);\n            $fieldName = explode(' ', $entry)[0];\n            $entry = substr($entry, strlen($fieldName));\n            $entry = trim($entry);\n            if (strpos($entry, ') => (')) {\n                list($before, $after) = explode(') => (', $entry);\n                $before = substr($before, 1);\n                $after = substr($after, 0, -1);\n                $data[$fieldName] = $after;\n            }\n        }\n        return $data;\n    }\n\n    public function findDeletedEvents($conditions)\n    {\n        $conditions['model'] = 'Event';\n        $conditions['action'] = 'delete';\n        $this->Event = ClassRegistry::init('Event');\n        $deletions = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => $conditions,\n            'order' => ['Log.id']\n        ]);\n        $deleted_events = [];\n        $users = [];\n        $orgs = [];\n        $deleted_event_ids = [];\n        foreach ($deletions as $deletion_entry) {\n            if (!empty($deleted_event_ids[$deletion_entry['Log']['model_id']])) {\n                continue;\n            } else {\n                $deleted_event_ids[$deletion_entry['Log']['model_id']] = true;\n            }\n            $event = $this->Event->find('first', [\n                'conditions' => ['Event.id' => $deletion_entry['Log']['model_id']],\n                'recursive' => -1,\n                'fields' => ['Event.id']\n            ]);\n            if (!empty($event)) {\n                // event is already restored / not deleted\n                continue;\n            }\n            $temp = [\n                'event_id' => $deletion_entry['Log']['model_id'],\n                'user_id' => $deletion_entry['Log']['user_id'],\n                'created' => $deletion_entry['Log']['created']\n            ];\n            $event_creation_entry = $this->find('first', [\n                'recursive' => -1,\n                'conditions' => [\n                    'model_id' => $temp['event_id'],\n                    'model' => 'Event',\n                    'action' => 'add'\n                ]\n            ]);\n            $event = $this->changeParser($event_creation_entry['Log']['change']);\n            $temp['event_info'] = $event['info'];\n            $temp['event_org_id'] = $event['org_id'];\n            $temp['event_orgc_id'] = $event['orgc_id'];\n            $temp['event_user_id'] = $event['user_id'];\n            $temp['event_info'] = $event['info'];\n            $temp['event_created'] = $event_creation_entry['Log']['created'];\n            foreach (['org', 'orgc'] as $scope) {\n                if (empty($orgs[$temp['event_' . $scope . '_id']])) {\n                    $orgs[$temp['event_' . $scope . '_id']] = array_values($this->Event->Orgc->find('list', [\n                        'recursive' => -1,\n                        'conditions' => array('id' => $temp['event_' . $scope . '_id']),\n                        'fields' => array('id', 'name')\n                    ]))[0];\n                }\n                $temp['event_' . $scope . '_name'] = $orgs[$temp['event_' . $scope . '_id']];\n            }\n            $users[$temp['user_id']] = array_values($this->Event->User->find('list', [\n                'recursive' => -1,\n                'conditions' => array('id' => $temp['user_id']),\n                'fields' => array('id', 'email')\n            ]))[0];\n            $temp['user_name'] = $users[$temp['user_id']];\n            $users[$temp['event_user_id']] = array_values($this->Event->User->find('list', [\n                'recursive' => -1,\n                'conditions' => array('id' => $temp['event_user_id']),\n                'fields' => array('id', 'email')\n            ]))[0];\n            $temp['event_user_name'] = $users[$temp['event_user_id']];\n            $deleted_events[] = $temp;\n        }\n        return $deleted_events;\n    }\n\n    public function recoverDeletedEvent($id, $mock = false)\n    {\n        if ($mock) {\n            $this->mockRecovery = true;\n            $this->mockLog = [];\n        }\n        $objectMap = [];\n        $logEntries = [];\n        $this->__recoverDeletedEventContainer($id, $objectMap, $logEntries);\n        $this->__recoverDeletedObjects($id, $objectMap, $logEntries);\n        $this->__recoverDeletedAttributes($id, $objectMap, $logEntries);\n        $this->__recoverDeletedObjectReferences($id, $objectMap, $logEntries);\n        $this->__recoverDeletedTagConnectors($id, $objectMap, $logEntries, 'Event');\n        $this->__recoverDeletedTagConnectors($id, $objectMap, $logEntries, 'Attribute');\n        $this->__recoverDeletedProposals($id, $objectMap, $logEntries);\n        ksort($logEntries);\n        foreach ($logEntries as $logEntry) {\n            $this->{'__executeRecovery' . $logEntry['model']}($logEntry, $id);\n        }\n        return count($logEntries);\n        // order: event -> object -> attribute -> object reference -> tag -> galaxy -> shadow_attribute -> sighting\n    }\n\n    private function __recoverDeletedEventContainer($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Event',\n                'model_id' => $id,\n                'action' => ['add', 'edit', 'publish', 'alert']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['Event'][$log['Log']['model_id']] = true;\n        }\n    }\n\n    private function __recoverDeletedObjects($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'MispObject',\n                'change LIKE ' => '%event_id () => (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['MispObject'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'MispObject',\n                'model_id' => array_keys($objectMap['MispObject']),\n                'action' => ['add', 'edit', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n        }\n    }\n\n    private function __recoverDeletedObjectReferences($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ObjectReference',\n                'change LIKE ' => '%event_id () => (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['ObjectReference'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ObjectReference',\n                'model_id' => array_keys($objectMap['ObjectReference']),\n                'action' => ['add', 'edit']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n        }\n    }\n\n    private function __recoverDeletedTagConnectors($id, &$objectMap, &$logEntries, $scope)\n    {\n        if (empty($objectMap[$scope])) {\n            // example: we have no attributes, so we return\n            return;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => $scope,\n                'action' => ['tag', 'galaxy'],\n                'model_id' => array_keys($objectMap[$scope])\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            if ($log['Log']['action'] === 'tag') {\n                $temp = explode(' ', $log['Log']['title']);\n                $local = ($temp[1] === 'local' ? true : false);\n                $tag_id = ($local ? $temp[3] : $temp[2]);\n                $tag_id = substr($tag_id, 1, -1);\n            } else {\n                $matches = [];\n                preg_match('/\\(([0-9]*)\\)\\s(from|to)/', $log['Log']['title'], $matches);\n                if (!isset($matches[1])) {\n                    continue;\n                }\n                $local = false;\n                $tag_id = $matches[1];\n            }\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => (strpos($log['Log']['title'], 'Attached')) === false ? 'remove_tag' : 'add_tag',\n                'data' => [\n                    'tag_id' => $tag_id,\n                    'id' => $log['Log']['model_id'],\n                    'target_type' => $log['Log']['model'],\n                    'tag_type' => $log['Log']['action'],\n                    'local' => $local\n                ]\n            ];\n        }\n    }\n\n    private function __recoverDeletedAttributes($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Attribute',\n                'title LIKE ' => '%from Event (' . $id . ')%',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['Attribute'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'Attribute',\n                'model_id' => array_keys($objectMap['Attribute']),\n                'action' => ['add', 'edit', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['Attribute'][$log['Log']['model_id']] = true;\n        }\n    }\n\n    private function __recoverDeletedProposals($id, &$objectMap, &$logEntries)\n    {\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ShadowAttribute',\n                'title LIKE ' => '%: to Event (' . $id . '): %',\n                'action' => ['add']\n            ]\n        ]);\n        if (empty($logs)) {\n            return;\n        }\n        foreach ($logs as $log) {\n            $objectMap['ShadowAttribute'][$log['Log']['model_id']] = true;\n        }\n        $logs = $this->find('all', [\n            'recursive' => -1,\n            'conditions' => [\n                'model' => 'ShadowAttribute',\n                'model_id' => array_keys($objectMap['ShadowAttribute']),\n                'action' => ['add', 'accept', 'delete']\n            ]\n        ]);\n        foreach ($logs as $log) {\n            $logEntries[$log['Log']['id']] = [\n                'model_id' => $log['Log']['model_id'],\n                'model' => $log['Log']['model'],\n                'action' => $log['Log']['action'],\n                'data' => array_merge(\n                    $this->changeParser($log['Log']['change']),\n                    [\n                        'timestamp' => strtotime($log['Log']['created']),\n                        'id' => $log['Log']['model_id']\n                    ]\n                )\n            ];\n            $objectMap['ShadowAttribute'][$log['Log']['model_id']] = true;\n        }\n    }\n\n\n    private function __executeRecoveryEvent($logEntry, $id)\n    {\n        if (empty($this->Event)) {\n            $this->Event = ClassRegistry::init('Event');\n        }\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        if (empty($this->EventBlocklist)) {\n            $this->EventBlocklist = ClassRegistry::init('EventBlocklist');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'Event', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->Event->create();\n                    $this->Event->save($logEntry['data']);\n                    $blockListEntry = $this->EventBlocklist->find('first', array(\n                        'conditions' => array('event_uuid' => $logEntry['data']['uuid']),\n                        'fields' => 'id'\n                    ));\n                    if (!empty($blockListEntry)) {\n                        $this->EventBlocklist->delete($blockListEntry['EventBlocklist']['id']);\n                    }\n                }\n                break;\n            case 'edit':\n            case 'publish':\n                $event = $this->Event->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Event.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($event)) {\n                    if ($logEntry['action'] === 'publish' || $logEntry['action'] === 'alert') {\n                        $event['Event']['published'] = 1;\n                        $event['Event']['publish_timestamp'] = strtotime($logEntry['data']['timestamp']);\n                    } else {\n                        foreach ($logEntry['data'] as $field => $value) {\n                            $event['Event'][$field] = $value;\n                        }\n                    }\n                    $this->Event->create();\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Event', 'action' => 'edit', 'data' => $event];\n                    } else {\n                        $this->Event->save($event);\n                    }\n                }\n                break;\n            case 'add_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $this->Event->EventTag->create();\n                $this->Event->create();\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'EventTag', 'action' => 'add', 'data' => [\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id'],\n                        'local' => !empty($logEntry['data']['local'])\n                    ]];\n                } else {\n                    $this->Event->EventTag->save([\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id'],\n                        'local' => !empty($logEntry['data']['local'])\n                    ]);\n                }\n                break;\n            case 'remove_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $et = $this->Event->EventTag->find('first', [\n                    'recursive' => -1,\n                    'conditions' => [\n                        'tag_id' => $tag_id,\n                        'event_id' => $logEntry['data']['id']\n                    ]\n                ]);\n                if (!empty($et)) {\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'EventTag', 'action' => 'delete', 'data' => $et['EventTag']['id']];\n                    } else {\n                        $this->Event->EventTag->delete($et['EventTag']['id']);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryAttribute($logEntry, $id)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        if (!empty($logEntry['data']['value1'])) {\n            $logEntry['data']['value'] = $logEntry['data']['value1'];\n            if (!empty($logEntry['data']['value2'])) {\n                $logEntry .= '|' . $logEntry['data']['value2'];\n            }\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data'] = $this->Attribute->UTCToISODatetime(['Attribute' => $logEntry['data']], 'Attribute');\n                $logEntry['data'] = $logEntry['data']['Attribute'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'Attribute', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->Attribute->create();\n                    if (!isset($logEntry['data']['to_ids'])) {\n                        $logEntry['data']['to_ids'] = 0;\n                    }\n                    $this->Attribute->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $attribute = $this->Attribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Attribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($attribute)) {\n                    $logEntry['data'] = $this->Attribute->UTCToISODatetime(['Attribute' => $logEntry['data']], 'Attribute');\n                    $logEntry['data'] = $logEntry['data']['Attribute'];\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $attribute['Attribute'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'edit', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                break;\n            case 'delete':\n                $attribute = $this->Attribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Attribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($attribute)) {\n                    $attribute['Attribute']['deleted'] = 1;\n                    $attribute['Attribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'delete', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                break;\n            case 'add_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'AttributeTag', 'action' => 'add', 'data' => [\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id,\n                        'local' => !empty($logEntry['data']['local'])\n                    ]];\n                } else {\n                    $this->Attribute->AttributeTag->create();\n                    $this->Attribute->AttributeTag->save([\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id,\n                        'local' => !empty($logEntry['data']['local'])\n                    ]);\n                }\n                break;\n            case 'remove_tag':\n                $tag_id = $logEntry['data']['tag_type'] === 'galaxy' ? $this->GalaxyCluster->getTagIdByClusterId($logEntry['data']['tag_id']) : $logEntry['data']['tag_id'];\n                $at = $this->Attribute->AttributeTag->find('first', [\n                    'recursive' => -1,\n                    'conditions' => [\n                        'tag_id' => $tag_id,\n                        'attribute_id' => $logEntry['data']['id'],\n                        'event_id' => $id\n                    ]\n                ]);\n                if (!empty($at)) {\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'AttributeTag', 'action' => 'delete', 'data' => $at['AttributeTag']['id']];\n                    } else {\n                        $this->Attribute->AttributeTag->delete($at['AttributeTag']['id']);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryShadowAttribute($logEntry, $id)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->ShadowAttribute)) {\n            $this->ShadowAttribute = ClassRegistry::init('ShadowAttribute');\n        }\n        if (!empty($logEntry['data']['value1'])) {\n            $logEntry['data']['value'] = $logEntry['data']['value1'];\n            if (!empty($logEntry['data']['value2'])) {\n                $logEntry .= '|' . $logEntry['data']['value2'];\n            }\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data']['value'] = $logEntry['data']['value1'];\n                if (!empty($logEntry['data']['value2'])) {\n                    $logEntry['data']['value'] .= '|' . $logEntry['data']['value2'];\n                }\n                $logEntry['data'] = $this->Attribute->UTCToISODatetime(['ShadowAttribute' => $logEntry['data']], 'ShadowAttribute');\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->ShadowAttribute->create();\n                    $this->ShadowAttribute->save($logEntry['data']);\n                }\n                break;\n            case 'delete':\n                $shadow_attribute = $this->ShadowAttribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ShadowAttribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($shadow_attribute)) {\n                    $shadow_attribute['ShadowAttribute']['deleted'] = 1;\n                    $shadow_attribute['ShadowAttribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'delete', 'data' => $attribute];\n                    } else {\n                        $this->ShadowAttribute->save($attribute);\n                    }\n                }\n                break;\n            case 'accept':\n                $shadow_attribute = $this->ShadowAttribute->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ShadowAttribute.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($shadow_attribute['ShadowAttribute']['old_id'])) {\n                    $attribute = $this->Attribute->find('first', [\n                        'conditions' => ['Attribute.id' => $shadow_attribute['ShadowAttribute']['old_id']],\n                        'recursive' => -1\n                    ]);\n                    if (!empty($shadow_attribute['ShadowAttribute']['proposal_to_delete'])) {\n                        $attribute['Attribute']['deleted'] = 1;\n                    } else {\n                        foreach(['category', 'type', 'value', 'to_ids', 'comment', 'first_seen', 'last_seen'] as $field) {\n                            if (isset($shadow_attribute['ShadowAttribute'][$field])) {\n                                $attribute['Attribute'][$field] = $shadow_attribute['ShadowAttribute'][$field];\n                            }\n                        }\n                    }\n                    $attribute['Attribute']['timestamp'] = $logEntry['data']['timestamp'];\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'edit', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                } else {\n                    $this->Attribute->create();\n                    $attribute = $shadow_attribute['ShadowAttribute'];\n                    if (isset($attribute['id'])) {\n                        unset($attribute['id']);\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'Attribute', 'action' => 'add', 'data' => $attribute];\n                    } else {\n                        $this->Attribute->save($attribute);\n                    }\n                }\n                $shadow_attribute['ShadowAttribute']['deleted'] = 1;\n                $shadow_attribute['ShadowAttribute']['timestamp'] = $logEntry['data']['timestamp'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ShadowAttribute', 'action' => 'delete', 'data' => $shadow_attribute];\n                } else {\n                    $this->ShadowAttribute->save($shadow_attribute);\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryObjectReference($logEntry, $id)\n    {\n        if (empty($this->ObjectReference)) {\n            $this->ObjectReference = ClassRegistry::init('ObjectReference');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'ObjectReference', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->ObjectReference->create();\n                    $this->ObjectReference->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $objectRef = $this->ObjectReference->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['ObjectReference.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($object)) {\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $object['ObjectReference'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'ObjectReference', 'action' => 'edit', 'data' => $object];\n                    } else {\n                        $this->ObjectReference->save($object);\n                    }\n                }\n                break;\n        }\n    }\n\n    private function __executeRecoveryMispObject($logEntry)\n    {\n        if (empty($this->Attribute)) {\n            $this->Attribute = ClassRegistry::init('Attribute');\n        }\n        if (empty($this->MispObject)) {\n            $this->MispObject = ClassRegistry::init('MispObject');\n        }\n        switch($logEntry['action']) {\n            case 'add':\n                $logEntry['data'] = $this->MispObject->Attribute->UTCToISODatetime(['Object' => $logEntry['data']], 'Object');\n                $logEntry['data'] = $logEntry['data']['Object'];\n                if (!empty($this->mockRecovery)) {\n                    $this->mockLog[] = ['model' => 'MispObject', 'action' => 'add', 'data' => $logEntry['data']];\n                } else {\n                    $this->MispObject->create();\n                    $this->MispObject->save($logEntry['data']);\n                }\n                break;\n            case 'edit':\n                $logEntry['data'] = $this->MispObject->Attribute->UTCToISODatetime(['Object' => $logEntry['data']], 'Object');\n                $logEntry['data'] = $logEntry['data']['Object'];\n                $object = $this->MispObject->find('first', [\n                    'recursive' => -1,\n                    'conditions' => ['Object.id' => $logEntry['model_id']]\n                ]);\n                if (!empty($object)) {\n                    foreach ($logEntry['data'] as $field => $value) {\n                        $object['Object'][$field] = $value;\n                    }\n                    if (!empty($this->mockRecovery)) {\n                        $this->mockLog[] = ['model' => 'MispObject', 'action' => 'add', 'data' => $object];\n                    } else {\n                        $this->MispObject->save($object);\n                    }\n                }\n                break;\n        }\n    }\n}\n"], "filenames": ["app/Model/Log.php"], "buggy_code_start_loc": [177], "buggy_code_end_loc": [178], "fixing_code_start_loc": [177], "fixing_code_end_loc": [178], "type": "CWE-89", "message": "MISP 2.4.148, in certain configurations, allows SQL injection via the app/Model/Log.php $conditions['org'] value.", "other": {"cve": {"id": "CVE-2021-39302", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-19T17:15:07.313", "lastModified": "2021-08-23T15:00:13.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MISP 2.4.148, in certain configurations, allows SQL injection via the app/Model/Log.php $conditions['org'] value."}, {"lang": "es", "value": "MISP versi\u00f3n 2.4.148, en determinadas configuraciones, permite una inyecci\u00f3n SQL por medio del valor $conditions[\"org\"] del componente app/Model/Log.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:2.4.148:*:*:*:*:*:*:*", "matchCriteriaId": "F2AEA4D8-AEB9-4F4A-8BCD-25B28BDB6709"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/20d9020b76d1f6790c4d84e020d0cc97c929f66b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/20d9020b76d1f6790c4d84e020d0cc97c929f66b"}}