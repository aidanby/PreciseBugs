{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * (C) Copyright 2009\n * Sergey Kubushyn, himself, ksi@koi8.net\n *\n * Changes for unified multibus/multiadapter I2C support.\n *\n * (C) Copyright 2001\n * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.\n */\n\n/*\n * I2C Functions similar to the standard memory functions.\n *\n * There are several parameters in many of the commands that bear further\n * explanations:\n *\n * {i2c_chip} is the I2C chip address (the first byte sent on the bus).\n *   Each I2C chip on the bus has a unique address.  On the I2C data bus,\n *   the address is the upper seven bits and the LSB is the \"read/write\"\n *   bit.  Note that the {i2c_chip} address specified on the command\n *   line is not shifted up: e.g. a typical EEPROM memory chip may have\n *   an I2C address of 0x50, but the data put on the bus will be 0xA0\n *   for write and 0xA1 for read.  This \"non shifted\" address notation\n *   matches at least half of the data sheets :-/.\n *\n * {addr} is the address (or offset) within the chip.  Small memory\n *   chips have 8 bit addresses.  Large memory chips have 16 bit\n *   addresses.  Other memory chips have 9, 10, or 11 bit addresses.\n *   Many non-memory chips have multiple registers and {addr} is used\n *   as the register index.  Some non-memory chips have only one register\n *   and therefore don't need any {addr} parameter.\n *\n *   The default {addr} parameter is one byte (.1) which works well for\n *   memories and registers with 8 bits of address space.\n *\n *   You can specify the length of the {addr} field with the optional .0,\n *   .1, or .2 modifier (similar to the .b, .w, .l modifier).  If you are\n *   manipulating a single register device which doesn't use an address\n *   field, use \"0.0\" for the address and the \".0\" length field will\n *   suppress the address in the I2C data stream.  This also works for\n *   successive reads using the I2C auto-incrementing memory pointer.\n *\n *   If you are manipulating a large memory with 2-byte addresses, use\n *   the .2 address modifier, e.g. 210.2 addresses location 528 (decimal).\n *\n *   Then there are the unfortunate memory chips that spill the most\n *   significant 1, 2, or 3 bits of address into the chip address byte.\n *   This effectively makes one chip (logically) look like 2, 4, or\n *   8 chips.  This is handled (awkwardly) by #defining\n *   CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW and using the .1 modifier on the\n *   {addr} field (since .1 is the default, it doesn't actually have to\n *   be specified).  Examples: given a memory chip at I2C chip address\n *   0x50, the following would happen...\n *     i2c md 50 0 10   display 16 bytes starting at 0x000\n *                      On the bus: <S> A0 00 <E> <S> A1 <rd> ... <rd>\n *     i2c md 50 100 10 display 16 bytes starting at 0x100\n *                      On the bus: <S> A2 00 <E> <S> A3 <rd> ... <rd>\n *     i2c md 50 210 10 display 16 bytes starting at 0x210\n *                      On the bus: <S> A4 10 <E> <S> A5 <rd> ... <rd>\n *   This is awfully ugly.  It would be nice if someone would think up\n *   a better way of handling this.\n *\n * Adapted from cmd_mem.c which is copyright Wolfgang Denk (wd@denx.de).\n */\n\n#include <common.h>\n#include <bootretry.h>\n#include <cli.h>\n#include <command.h>\n#include <console.h>\n#include <dm.h>\n#include <edid.h>\n#include <errno.h>\n#include <i2c.h>\n#include <log.h>\n#include <malloc.h>\n#include <asm/byteorder.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <u-boot/crc.h>\n\n/* Display values from last command.\n * Memory modify remembered values are different from display memory.\n */\nstatic uint\ti2c_dp_last_chip;\nstatic uint\ti2c_dp_last_addr;\nstatic uint\ti2c_dp_last_alen;\nstatic uint\ti2c_dp_last_length = 0x10;\n\nstatic uint\ti2c_mm_last_chip;\nstatic uint\ti2c_mm_last_addr;\nstatic uint\ti2c_mm_last_alen;\n\n/* If only one I2C bus is present, the list of devices to ignore when\n * the probe command is issued is represented by a 1D array of addresses.\n * When multiple buses are present, the list is an array of bus-address\n * pairs.  The following macros take care of this */\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || defined(CONFIG_I2C_MULTI_BUS)\nstatic struct\n{\n\tuchar\tbus;\n\tuchar\taddr;\n} i2c_no_probes[] = CONFIG_SYS_I2C_NOPROBES;\n#define GET_BUS_NUM\ti2c_get_bus_num()\n#define COMPARE_BUS(b,i)\t(i2c_no_probes[(i)].bus == (b))\n#define COMPARE_ADDR(a,i)\t(i2c_no_probes[(i)].addr == (a))\n#define NO_PROBE_ADDR(i)\ti2c_no_probes[(i)].addr\n#else\t\t/* single bus */\nstatic uchar i2c_no_probes[] = CONFIG_SYS_I2C_NOPROBES;\n#define GET_BUS_NUM\t0\n#define COMPARE_BUS(b,i)\t((b) == 0)\t/* Make compiler happy */\n#define COMPARE_ADDR(a,i)\t(i2c_no_probes[(i)] == (a))\n#define NO_PROBE_ADDR(i)\ti2c_no_probes[(i)]\n#endif\t/* CONFIG_IS_ENABLED(SYS_I2C_LEGACY) */\n#endif\n\n#define DISP_LINE_LEN\t16\n\n/*\n * Default for driver model is to use the chip's existing address length.\n * For legacy code, this is not stored, so we need to use a suitable\n * default.\n */\n#if CONFIG_IS_ENABLED(DM_I2C)\n#define DEFAULT_ADDR_LEN\t(-1)\n#else\n#define DEFAULT_ADDR_LEN\t1\n#endif\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic struct udevice *i2c_cur_bus;\n\nstatic int cmd_i2c_set_bus_num(unsigned int busnum)\n{\n\tstruct udevice *bus;\n\tint ret;\n\n\tret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);\n\tif (ret) {\n\t\tdebug(\"%s: No bus %d\\n\", __func__, busnum);\n\t\treturn ret;\n\t}\n\ti2c_cur_bus = bus;\n\n\treturn 0;\n}\n\nstatic int i2c_get_cur_bus(struct udevice **busp)\n{\n#ifdef CONFIG_I2C_SET_DEFAULT_BUS_NUM\n\tif (!i2c_cur_bus) {\n\t\tif (cmd_i2c_set_bus_num(CONFIG_I2C_DEFAULT_BUS_NUMBER)) {\n\t\t\tprintf(\"Default I2C bus %d not found\\n\",\n\t\t\t       CONFIG_I2C_DEFAULT_BUS_NUMBER);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\tif (!i2c_cur_bus) {\n\t\tputs(\"No I2C bus selected\\n\");\n\t\treturn -ENODEV;\n\t}\n\t*busp = i2c_cur_bus;\n\n\treturn 0;\n}\n\nstatic int i2c_get_cur_bus_chip(uint chip_addr, struct udevice **devp)\n{\n\tstruct udevice *bus;\n\tint ret;\n\n\tret = i2c_get_cur_bus(&bus);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i2c_get_chip(bus, chip_addr, 1, devp);\n}\n\n#endif\n\n/**\n * i2c_init_board() - Board-specific I2C bus init\n *\n * This function is the default no-op implementation of I2C bus\n * initialization. This function can be overridden by board-specific\n * implementation if needed.\n */\n__weak\nvoid i2c_init_board(void)\n{\n}\n\n/**\n * get_alen() - Small parser helper function to get address length\n *\n * Returns the address length.\n */\nstatic uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}\n\nenum i2c_err_op {\n\tI2C_ERR_READ,\n\tI2C_ERR_WRITE,\n};\n\nstatic int i2c_report_err(int ret, enum i2c_err_op op)\n{\n\tprintf(\"Error %s the chip: %d\\n\",\n\t       op == I2C_ERR_READ ? \"reading\" : \"writing\", ret);\n\n\treturn CMD_RET_FAILURE;\n}\n\n/**\n * do_i2c_read() - Handle the \"i2c read\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c read {i2c_chip} {devaddr}{.0, .1, .2} {len} {memaddr}\n */\nstatic int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = hextoul(argv[3], NULL);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n\nstatic int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[2], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * Length is the number of bytes.\n\t */\n\tlength = hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n\t\t/*\n\t\t * Write all bytes in a single I2C transaction. If the target\n\t\t * device is an EEPROM, it is your responsibility to not cross\n\t\t * a page boundary. No write delay upon completion, take this\n\t\t * into account if linking commands.\n\t\t */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\t/*\n\t\t * Repeated addressing - perform <length> separate\n\t\t * write transactions of one byte each\n\t\t */\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_flags(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tstruct udevice *dev;\n\tuint flags;\n\tint chip;\n\tint ret;\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\tchip = hextoul(argv[1], NULL);\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (argc > 2) {\n\t\tflags = hextoul(argv[2], NULL);\n\t\tret = i2c_set_chip_flags(dev, flags);\n\t} else  {\n\t\tret = i2c_get_chip_flags(dev, &flags);\n\t\tif (!ret)\n\t\t\tprintf(\"%x\\n\", flags);\n\t}\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n\nstatic int do_i2c_olen(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tstruct udevice *dev;\n\tuint olen;\n\tint chip;\n\tint ret;\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\tchip = hextoul(argv[1], NULL);\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (argc > 2) {\n\t\tolen = hextoul(argv[2], NULL);\n\t\tret = i2c_set_chip_offset_len(dev, olen);\n\t} else  {\n\t\tret = i2c_get_chip_offset_len(dev);\n\t\tif (ret >= 0) {\n\t\t\tprintf(\"%x\\n\", ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n#endif\n\n/**\n * do_i2c_md() - Handle the \"i2c md\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c md {i2c_chip} {addr}{.0, .1, .2} {len}\n */\nstatic int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tint alen;\n\tint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}\n\n/**\n * do_i2c_mw() - Handle the \"i2c mw\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]\n */\nstatic int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\t/*\n\t * Value to write is always specified.\n\t */\n\tbyte = hextoul(argv[3], NULL);\n\n\t/*\n\t * Optional count\n\t */\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t\t/*\n\t\t * Wait for the write to complete.  The write can take\n\t\t * up to 10mSec (we allow a little more time).\n\t\t */\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_i2c_crc() - Handle the \"i2c crc32\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Calculate a CRC on memory\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c crc32 {i2c_chip} {addr}{.0, .1, .2} {count}\n */\nstatic int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\t/*\n\t * Count is always specified\n\t */\n\tcount = hextoul(argv[3], NULL);\n\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\t/*\n\t * CRC a byte at a time.  This is going to be slooow, but hey, the\n\t * memories are small and slow too so hopefully nobody notices.\n\t */\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\n\treturn 0;\n}\n\n/**\n * mod_i2c_mem() - Handle the \"i2c mm\" and \"i2c nm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Modify memory.\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c mm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}\n *\ti2c nm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}\n */\nstatic int mod_i2c_mem(struct cmd_tbl *cmdtp, int incrflag, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tulong\tdata;\n\tint\tsize = 1;\n\tint\tnbytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 3)\n\t\treturn CMD_RET_USAGE;\n\n\tbootretry_reset_cmd_timeout();\t/* got a good command to get here */\n\t/*\n\t * We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip = i2c_mm_last_chip;\n\taddr = i2c_mm_last_addr;\n\talen = i2c_mm_last_alen;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.  Check for a size specification.\n\t\t * Defaults to byte if no or incorrect specification.\n\t\t */\n\t\tsize = cmd_get_data_size(argv[0], 1);\n\n\t\t/*\n\t\t * Chip is always specified.\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * Address is always specified.\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\t/*\n\t * Print the address, followed by value.  Then accept input for\n\t * the next value.  A non-converted value exits.\n\t */\n\tdo {\n\t\tprintf(\"%08lx:\", addr);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, (uchar *)&data, size);\n#else\n\t\tret = i2c_read(chip, addr, alen, (uchar *)&data, size);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\t\tdata = cpu_to_be32(data);\n\t\tif (size == 1)\n\t\t\tprintf(\" %02lx\", (data >> 24) & 0x000000FF);\n\t\telse if (size == 2)\n\t\t\tprintf(\" %04lx\", (data >> 16) & 0x0000FFFF);\n\t\telse\n\t\t\tprintf(\" %08lx\", data);\n\n\t\tnbytes = cli_readline(\" ? \");\n\t\tif (nbytes == 0) {\n\t\t\t/*\n\t\t\t * <CR> pressed as only input, don't modify current\n\t\t\t * location and move to next.\n\t\t\t */\n\t\t\tif (incrflag)\n\t\t\t\taddr += size;\n\t\t\tnbytes = size;\n\t\t\t/* good enough to not time out */\n\t\t\tbootretry_reset_cmd_timeout();\n\t\t}\n#ifdef CONFIG_BOOT_RETRY_TIME\n\t\telse if (nbytes == -2)\n\t\t\tbreak;\t/* timed out, exit the command\t*/\n#endif\n\t\telse {\n\t\t\tchar *endp;\n\n\t\t\tdata = hextoul(console_buffer, &endp);\n\t\t\tif (size == 1)\n\t\t\t\tdata = data << 24;\n\t\t\telse if (size == 2)\n\t\t\t\tdata = data << 16;\n\t\t\tdata = be32_to_cpu(data);\n\t\t\tnbytes = endp - console_buffer;\n\t\t\tif (nbytes) {\n\t\t\t\t/*\n\t\t\t\t * good enough to not time out\n\t\t\t\t */\n\t\t\t\tbootretry_reset_cmd_timeout();\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\t\tret = dm_i2c_write(dev, addr, (uchar *)&data,\n\t\t\t\t\t\t   size);\n#else\n\t\t\t\tret = i2c_write(chip, addr, alen,\n\t\t\t\t\t\t(uchar *)&data, size);\n#endif\n\t\t\t\tif (ret)\n\t\t\t\t\treturn i2c_report_err(ret,\n\t\t\t\t\t\t\t      I2C_ERR_WRITE);\n#if CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS > 0\n\t\t\t\tudelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);\n#endif\n\t\t\t\tif (incrflag)\n\t\t\t\t\taddr += size;\n\t\t\t}\n\t\t}\n\t} while (nbytes);\n\n\ti2c_mm_last_chip = chip;\n\ti2c_mm_last_addr = addr;\n\ti2c_mm_last_alen = alen;\n\n\treturn 0;\n}\n\n/**\n * do_i2c_probe() - Handle the \"i2c probe\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c probe {addr}\n *\n * Returns zero (success) if one or more I2C devices was found\n */\nstatic int do_i2c_probe(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tint j;\n\tint addr = -1;\n\tint found = 0;\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\tint k, skip;\n\tunsigned int bus = GET_BUS_NUM;\n#endif\t/* NOPROBES */\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus, *dev;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn CMD_RET_FAILURE;\n#endif\n\n\tif (argc == 2)\n\t\taddr = simple_strtol(argv[1], 0, 16);\n\n\tputs (\"Valid chip addresses:\");\n\tfor (j = 0; j < 128; j++) {\n\t\tif ((0 <= addr) && (j != addr))\n\t\t\tcontinue;\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\t\tskip = 0;\n\t\tfor (k = 0; k < ARRAY_SIZE(i2c_no_probes); k++) {\n\t\t\tif (COMPARE_BUS(bus, k) && COMPARE_ADDR(j, k)) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip)\n\t\t\tcontinue;\n#endif\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_probe(bus, j, 0, &dev);\n#else\n\t\tret = i2c_probe(j);\n#endif\n\t\tif (ret == 0) {\n\t\t\tprintf(\" %02X\", j);\n\t\t\tfound++;\n\t\t}\n\t}\n\tputc ('\\n');\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\tputs (\"Excluded chip addresses:\");\n\tfor (k = 0; k < ARRAY_SIZE(i2c_no_probes); k++) {\n\t\tif (COMPARE_BUS(bus,k))\n\t\t\tprintf(\" %02X\", NO_PROBE_ADDR(k));\n\t}\n\tputc ('\\n');\n#endif\n\n\treturn (0 == found);\n}\n\n/**\n * do_i2c_loop() - Handle the \"i2c loop\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c loop {i2c_chip} {addr}{.0, .1, .2} [{length}] [{delay}]\n *\t{length} - Number of bytes to read\n *\t{delay}  - A DECIMAL number and defaults to 1000 uSec\n */\nstatic int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\n\t/*\n\t * The delay time (uSec) is optional.\n\t */\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\t/*\n\t * Run the loop...\n\t */\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}\n\n/*\n * The SDRAM command is separately configured because many\n * (most?) embedded boards don't use SDRAM DIMMs.\n *\n * FIXME: Document and probably move elsewhere!\n */\n#if defined(CONFIG_CMD_SDRAM)\nstatic void print_ddr2_tcyc (u_char const b)\n{\n\tprintf (\"%d.\", (b >> 4) & 0x0F);\n\tswitch (b & 0x0F) {\n\tcase 0x0:\n\tcase 0x1:\n\tcase 0x2:\n\tcase 0x3:\n\tcase 0x4:\n\tcase 0x5:\n\tcase 0x6:\n\tcase 0x7:\n\tcase 0x8:\n\tcase 0x9:\n\t\tprintf (\"%d ns\\n\", b & 0x0F);\n\t\tbreak;\n\tcase 0xA:\n\t\tputs (\"25 ns\\n\");\n\t\tbreak;\n\tcase 0xB:\n\t\tputs (\"33 ns\\n\");\n\t\tbreak;\n\tcase 0xC:\n\t\tputs (\"66 ns\\n\");\n\t\tbreak;\n\tcase 0xD:\n\t\tputs (\"75 ns\\n\");\n\t\tbreak;\n\tdefault:\n\t\tputs (\"?? ns\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void decode_bits (u_char const b, char const *str[], int const do_once)\n{\n\tu_char mask;\n\n\tfor (mask = 0x80; mask != 0x00; mask >>= 1, ++str) {\n\t\tif (b & mask) {\n\t\t\tputs (*str);\n\t\t\tif (do_once)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * Syntax:\n *\ti2c sdram {i2c_chip}\n */\nstatic int do_sdram(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t    char *const argv[])\n{\n\tenum { unknown, EDO, SDRAM, DDR, DDR2, DDR3, DDR4 } type;\n\n\tuint\tchip;\n\tu_char\tdata[128];\n\tu_char\tcksum;\n\tint\tj, ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tstatic const char *decode_CAS_DDR2[] = {\n\t\t\" TBD\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" TBD\", \" TBD\"\n\t};\n\n\tstatic const char *decode_CAS_default[] = {\n\t\t\" TBD\", \" 7\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" 1\"\n\t};\n\n\tstatic const char *decode_CS_WE_default[] = {\n\t\t\" TBD\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" 1\", \" 0\"\n\t};\n\n\tstatic const char *decode_byte21_default[] = {\n\t\t\"  TBD (bit 7)\\n\",\n\t\t\"  Redundant row address\\n\",\n\t\t\"  Differential clock input\\n\",\n\t\t\"  Registerd DQMB inputs\\n\",\n\t\t\"  Buffered DQMB inputs\\n\",\n\t\t\"  On-card PLL\\n\",\n\t\t\"  Registered address/control lines\\n\",\n\t\t\"  Buffered address/control lines\\n\"\n\t};\n\n\tstatic const char *decode_byte22_DDR2[] = {\n\t\t\"  TBD (bit 7)\\n\",\n\t\t\"  TBD (bit 6)\\n\",\n\t\t\"  TBD (bit 5)\\n\",\n\t\t\"  TBD (bit 4)\\n\",\n\t\t\"  TBD (bit 3)\\n\",\n\t\t\"  Supports partial array self refresh\\n\",\n\t\t\"  Supports 50 ohm ODT\\n\",\n\t\t\"  Supports weak driver\\n\"\n\t};\n\n\tstatic const char *decode_row_density_DDR2[] = {\n\t\t\"512 MiB\", \"256 MiB\", \"128 MiB\", \"16 GiB\",\n\t\t\"8 GiB\", \"4 GiB\", \"2 GiB\", \"1 GiB\"\n\t};\n\n\tstatic const char *decode_row_density_default[] = {\n\t\t\"512 MiB\", \"256 MiB\", \"128 MiB\", \"64 MiB\",\n\t\t\"32 MiB\", \"16 MiB\", \"8 MiB\", \"4 MiB\"\n\t};\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, 0, data, sizeof(data));\n#else\n\tret = i2c_read(chip, 0, 1, data, sizeof(data));\n#endif\n\tif (ret) {\n\t\tputs (\"No SDRAM Serial Presence Detect found.\\n\");\n\t\treturn 1;\n\t}\n\n\tcksum = 0;\n\tfor (j = 0; j < 63; j++) {\n\t\tcksum += data[j];\n\t}\n\tif (cksum != data[63]) {\n\t\tprintf (\"WARNING: Configuration data checksum failure:\\n\"\n\t\t\t\"  is 0x%02x, calculated 0x%02x\\n\", data[63], cksum);\n\t}\n\tprintf (\"SPD data revision            %d.%d\\n\",\n\t\t(data[62] >> 4) & 0x0F, data[62] & 0x0F);\n\tprintf (\"Bytes used                   0x%02X\\n\", data[0]);\n\tprintf (\"Serial memory size           0x%02X\\n\", 1 << data[1]);\n\n\tputs (\"Memory type                  \");\n\tswitch (data[2]) {\n\tcase 2:\n\t\ttype = EDO;\n\t\tputs (\"EDO\\n\");\n\t\tbreak;\n\tcase 4:\n\t\ttype = SDRAM;\n\t\tputs (\"SDRAM\\n\");\n\t\tbreak;\n\tcase 7:\n\t\ttype = DDR;\n\t\tputs(\"DDR\\n\");\n\t\tbreak;\n\tcase 8:\n\t\ttype = DDR2;\n\t\tputs (\"DDR2\\n\");\n\t\tbreak;\n\tcase 11:\n\t\ttype = DDR3;\n\t\tputs(\"DDR3\\n\");\n\t\tbreak;\n\tcase 12:\n\t\ttype = DDR4;\n\t\tputs(\"DDR4\\n\");\n\t\tbreak;\n\tdefault:\n\t\ttype = unknown;\n\t\tputs (\"unknown\\n\");\n\t\tbreak;\n\t}\n\n\tputs (\"Row address bits             \");\n\tif ((data[3] & 0x00F0) == 0)\n\t\tprintf (\"%d\\n\", data[3] & 0x0F);\n\telse\n\t\tprintf (\"%d/%d\\n\", data[3] & 0x0F, (data[3] >> 4) & 0x0F);\n\n\tputs (\"Column address bits          \");\n\tif ((data[4] & 0x00F0) == 0)\n\t\tprintf (\"%d\\n\", data[4] & 0x0F);\n\telse\n\t\tprintf (\"%d/%d\\n\", data[4] & 0x0F, (data[4] >> 4) & 0x0F);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Number of ranks              %d\\n\",\n\t\t\t(data[5] & 0x07) + 1);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Module rows                  %d\\n\", data[5]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Module data width            %d bits\\n\", data[6]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Module data width            %d bits\\n\",\n\t\t\t(data[7] << 8) | data[6]);\n\t\tbreak;\n\t}\n\n\tputs (\"Interface signal levels      \");\n\tswitch(data[8]) {\n\t\tcase 0:  puts (\"TTL 5.0 V\\n\");\tbreak;\n\t\tcase 1:  puts (\"LVTTL\\n\");\tbreak;\n\t\tcase 2:  puts (\"HSTL 1.5 V\\n\");\tbreak;\n\t\tcase 3:  puts (\"SSTL 3.3 V\\n\");\tbreak;\n\t\tcase 4:  puts (\"SSTL 2.5 V\\n\");\tbreak;\n\t\tcase 5:  puts (\"SSTL 1.8 V\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time             \");\n\t\tprint_ddr2_tcyc (data[9]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time             %d.%d ns\\n\",\n\t\t\t(data[9] >> 4) & 0x0F, data[9] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access time            0.%d%d ns\\n\",\n\t\t\t(data[10] >> 4) & 0x0F, data[10] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access time            %d.%d ns\\n\",\n\t\t\t(data[10] >> 4) & 0x0F, data[10] & 0x0F);\n\t\tbreak;\n\t}\n\n\tputs (\"EDC configuration            \");\n\tswitch (data[11]) {\n\t\tcase 0:  puts (\"None\\n\");\tbreak;\n\t\tcase 1:  puts (\"Parity\\n\");\tbreak;\n\t\tcase 2:  puts (\"ECC\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tif ((data[12] & 0x80) == 0)\n\t\tputs (\"No self refresh, rate        \");\n\telse\n\t\tputs (\"Self refresh, rate           \");\n\n\tswitch(data[12] & 0x7F) {\n\t\tcase 0:  puts (\"15.625 us\\n\");\tbreak;\n\t\tcase 1:  puts (\"3.9 us\\n\");\tbreak;\n\t\tcase 2:  puts (\"7.8 us\\n\");\tbreak;\n\t\tcase 3:  puts (\"31.3 us\\n\");\tbreak;\n\t\tcase 4:  puts (\"62.5 us\\n\");\tbreak;\n\t\tcase 5:  puts (\"125 us\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM width (primary)        %d\\n\", data[13]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM width (primary)        %d\\n\", data[13] & 0x7F);\n\t\tif ((data[13] & 0x80) != 0) {\n\t\t\tprintf (\"  (second bank)              %d\\n\",\n\t\t\t\t2 * (data[13] & 0x7F));\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tif (data[14] != 0)\n\t\t\tprintf (\"EDC width                    %d\\n\", data[14]);\n\t\tbreak;\n\tdefault:\n\t\tif (data[14] != 0) {\n\t\t\tprintf (\"EDC width                    %d\\n\",\n\t\t\t\tdata[14] & 0x7F);\n\n\t\t\tif ((data[14] & 0x80) != 0) {\n\t\t\t\tprintf (\"  (second bank)              %d\\n\",\n\t\t\t\t\t2 * (data[14] & 0x7F));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (DDR2 != type) {\n\t\tprintf (\"Min clock delay, back-to-back random column addresses \"\n\t\t\t\"%d\\n\", data[15]);\n\t}\n\n\tputs (\"Burst length(s)             \");\n\tif (data[16] & 0x80) puts (\" Page\");\n\tif (data[16] & 0x08) puts (\" 8\");\n\tif (data[16] & 0x04) puts (\" 4\");\n\tif (data[16] & 0x02) puts (\" 2\");\n\tif (data[16] & 0x01) puts (\" 1\");\n\tputc ('\\n');\n\tprintf (\"Number of banks              %d\\n\", data[17]);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"CAS latency(s)              \");\n\t\tdecode_bits (data[18], decode_CAS_DDR2, 0);\n\t\tputc ('\\n');\n\t\tbreak;\n\tdefault:\n\t\tputs (\"CAS latency(s)              \");\n\t\tdecode_bits (data[18], decode_CAS_default, 0);\n\t\tputc ('\\n');\n\t\tbreak;\n\t}\n\n\tif (DDR2 != type) {\n\t\tputs (\"CS latency(s)               \");\n\t\tdecode_bits (data[19], decode_CS_WE_default, 0);\n\t\tputc ('\\n');\n\t}\n\n\tif (DDR2 != type) {\n\t\tputs (\"WE latency(s)               \");\n\t\tdecode_bits (data[20], decode_CS_WE_default, 0);\n\t\tputc ('\\n');\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Module attributes:\\n\");\n\t\tif (data[21] & 0x80)\n\t\t\tputs (\"  TBD (bit 7)\\n\");\n\t\tif (data[21] & 0x40)\n\t\t\tputs (\"  Analysis probe installed\\n\");\n\t\tif (data[21] & 0x20)\n\t\t\tputs (\"  TBD (bit 5)\\n\");\n\t\tif (data[21] & 0x10)\n\t\t\tputs (\"  FET switch external enable\\n\");\n\t\tprintf (\"  %d PLLs on DIMM\\n\", (data[21] >> 2) & 0x03);\n\t\tif (data[20] & 0x11) {\n\t\t\tprintf (\"  %d active registers on DIMM\\n\",\n\t\t\t\t(data[21] & 0x03) + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Module attributes:\\n\");\n\t\tif (!data[21])\n\t\t\tputs (\"  (none)\\n\");\n\t\telse\n\t\t\tdecode_bits (data[21], decode_byte21_default, 0);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tdecode_bits (data[22], decode_byte22_DDR2, 0);\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Device attributes:\\n\");\n\t\tif (data[22] & 0x80) puts (\"  TBD (bit 7)\\n\");\n\t\tif (data[22] & 0x40) puts (\"  TBD (bit 6)\\n\");\n\t\tif (data[22] & 0x20) puts (\"  Upper Vcc tolerance 5%\\n\");\n\t\telse                 puts (\"  Upper Vcc tolerance 10%\\n\");\n\t\tif (data[22] & 0x10) puts (\"  Lower Vcc tolerance 5%\\n\");\n\t\telse                 puts (\"  Lower Vcc tolerance 10%\\n\");\n\t\tif (data[22] & 0x08) puts (\"  Supports write1/read burst\\n\");\n\t\tif (data[22] & 0x04) puts (\"  Supports precharge all\\n\");\n\t\tif (data[22] & 0x02) puts (\"  Supports auto precharge\\n\");\n\t\tif (data[22] & 0x01) puts (\"  Supports early RAS# precharge\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time (2nd highest CAS latency)        \");\n\t\tprint_ddr2_tcyc (data[23]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time (2nd highest CAS latency)        %d.\"\n\t\t\t\"%d ns\\n\", (data[23] >> 4) & 0x0F, data[23] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access from clock (2nd highest CAS latency) 0.\"\n\t\t\t\"%d%d ns\\n\", (data[24] >> 4) & 0x0F, data[24] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access from clock (2nd highest CAS latency) %d.\"\n\t\t\t\"%d ns\\n\", (data[24] >> 4) & 0x0F, data[24] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time (3rd highest CAS latency)        \");\n\t\tprint_ddr2_tcyc (data[25]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time (3rd highest CAS latency)        %d.\"\n\t\t\t\"%d ns\\n\", (data[25] >> 4) & 0x0F, data[25] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access from clock (3rd highest CAS latency) 0.\"\n\t\t\t\"%d%d ns\\n\", (data[26] >> 4) & 0x0F, data[26] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access from clock (3rd highest CAS latency) %d.\"\n\t\t\t\"%d ns\\n\", (data[26] >> 4) & 0x0F, data[26] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Minimum row precharge        %d.%02d ns\\n\",\n\t\t\t(data[27] >> 2) & 0x3F, 25 * (data[27] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Minimum row precharge        %d ns\\n\", data[27]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Row active to row active min %d.%02d ns\\n\",\n\t\t\t(data[28] >> 2) & 0x3F, 25 * (data[28] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Row active to row active min %d ns\\n\", data[28]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"RAS to CAS delay min         %d.%02d ns\\n\",\n\t\t\t(data[29] >> 2) & 0x3F, 25 * (data[29] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"RAS to CAS delay min         %d ns\\n\", data[29]);\n\t\tbreak;\n\t}\n\n\tprintf (\"Minimum RAS pulse width      %d ns\\n\", data[30]);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Density of each row          \");\n\t\tdecode_bits (data[31], decode_row_density_DDR2, 1);\n\t\tputc ('\\n');\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Density of each row          \");\n\t\tdecode_bits (data[31], decode_row_density_default, 1);\n\t\tputc ('\\n');\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Command and Address setup    \");\n\t\tif (data[32] >= 0xA0) {\n\t\t\tprintf (\"1.%d%d ns\\n\",\n\t\t\t\t((data[32] >> 4) & 0x0F) - 10, data[32] & 0x0F);\n\t\t} else {\n\t\t\tprintf (\"0.%d%d ns\\n\",\n\t\t\t\t((data[32] >> 4) & 0x0F), data[32] & 0x0F);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Command and Address setup    %c%d.%d ns\\n\",\n\t\t\t(data[32] & 0x80) ? '-' : '+',\n\t\t\t(data[32] >> 4) & 0x07, data[32] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Command and Address hold     \");\n\t\tif (data[33] >= 0xA0) {\n\t\t\tprintf (\"1.%d%d ns\\n\",\n\t\t\t\t((data[33] >> 4) & 0x0F) - 10, data[33] & 0x0F);\n\t\t} else {\n\t\t\tprintf (\"0.%d%d ns\\n\",\n\t\t\t\t((data[33] >> 4) & 0x0F), data[33] & 0x0F);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Command and Address hold     %c%d.%d ns\\n\",\n\t\t\t(data[33] & 0x80) ? '-' : '+',\n\t\t\t(data[33] >> 4) & 0x07, data[33] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Data signal input setup      0.%d%d ns\\n\",\n\t\t\t(data[34] >> 4) & 0x0F, data[34] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Data signal input setup      %c%d.%d ns\\n\",\n\t\t\t(data[34] & 0x80) ? '-' : '+',\n\t\t\t(data[34] >> 4) & 0x07, data[34] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Data signal input hold       0.%d%d ns\\n\",\n\t\t\t(data[35] >> 4) & 0x0F, data[35] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Data signal input hold       %c%d.%d ns\\n\",\n\t\t\t(data[35] & 0x80) ? '-' : '+',\n\t\t\t(data[35] >> 4) & 0x07, data[35] & 0x0F);\n\t\tbreak;\n\t}\n\n\tputs (\"Manufacturer's JEDEC ID      \");\n\tfor (j = 64; j <= 71; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\tprintf (\"Manufacturing Location       %02X\\n\", data[72]);\n\tputs (\"Manufacturer's Part Number   \");\n\tfor (j = 73; j <= 90; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\tprintf (\"Revision Code                %02X %02X\\n\", data[91], data[92]);\n\tprintf (\"Manufacturing Date           %02X %02X\\n\", data[93], data[94]);\n\tputs (\"Assembly Serial Number       \");\n\tfor (j = 95; j <= 98; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\n\tif (DDR2 != type) {\n\t\tprintf (\"Speed rating                 PC%d\\n\",\n\t\t\tdata[126] == 0x66 ? 66 : data[126]);\n\t}\n\treturn 0;\n}\n#endif\n\n/*\n * Syntax:\n *\ti2c edid {i2c_chip}\n */\n#if defined(CONFIG_I2C_EDID)\nint do_edid(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\n\tuint chip;\n\tstruct edid1_info edid;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 2) {\n\t\tcmd_usage(cmdtp);\n\t\treturn 1;\n\t}\n\n\tchip = hextoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, 0, (uchar *)&edid, sizeof(edid));\n#else\n\tret = i2c_read(chip, 0, 1, (uchar *)&edid, sizeof(edid));\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (edid_check_info(&edid)) {\n\t\tputs(\"Content isn't valid EDID.\\n\");\n\t\treturn 1;\n\t}\n\n\tedid_print_info(&edid);\n\treturn 0;\n\n}\n#endif /* CONFIG_I2C_EDID */\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic void show_bus(struct udevice *bus)\n{\n\tstruct udevice *dev;\n\n\tprintf(\"Bus %d:\\t%s\", dev_seq(bus), bus->name);\n\tif (device_active(bus))\n\t\tprintf(\"  (active %d)\", dev_seq(bus));\n\tprintf(\"\\n\");\n\tfor (device_find_first_child(bus, &dev);\n\t     dev;\n\t     device_find_next_child(&dev)) {\n\t\tstruct dm_i2c_chip *chip = dev_get_parent_plat(dev);\n\n\t\tprintf(\"   %02x: %s, offset len %x, flags %x\\n\",\n\t\t       chip->chip_addr, dev->name, chip->offset_len,\n\t\t       chip->flags);\n\t}\n}\n#endif\n\n/**\n * do_i2c_show_bus() - Handle the \"i2c bus\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero always.\n */\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_show_bus(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t   char *const argv[])\n{\n\tif (argc == 1) {\n\t\t/* show all busses */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\t\tstruct uclass *uc;\n\t\tint ret;\n\n\t\tret = uclass_get(UCLASS_I2C, &uc);\n\t\tif (ret)\n\t\t\treturn CMD_RET_FAILURE;\n\t\tuclass_foreach_dev(bus, uc)\n\t\t\tshow_bus(bus);\n#else\n\t\tint i;\n\n\t\tfor (i = 0; i < CONFIG_SYS_NUM_I2C_BUSES; i++) {\n\t\t\tprintf(\"Bus %d:\\t%s\", i, I2C_ADAP_NR(i)->name);\n#ifndef CONFIG_SYS_I2C_DIRECT_BUS\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < CONFIG_SYS_I2C_MAX_HOPS; j++) {\n\t\t\t\tif (i2c_bus[i].next_hop[j].chip == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"->%s@0x%2x:%d\",\n\t\t\t\t       i2c_bus[i].next_hop[j].mux.name,\n\t\t\t\t       i2c_bus[i].next_hop[j].chip,\n\t\t\t\t       i2c_bus[i].next_hop[j].channel);\n\t\t\t}\n#endif\n\t\t\tprintf(\"\\n\");\n\t\t}\n#endif\n\t} else {\n\t\tint i;\n\n\t\t/* show specific bus */\n\t\ti = dectoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\t\tint ret;\n\n\t\tret = uclass_get_device_by_seq(UCLASS_I2C, i, &bus);\n\t\tif (ret) {\n\t\t\tprintf(\"Invalid bus %d: err=%d\\n\", i, ret);\n\t\t\treturn CMD_RET_FAILURE;\n\t\t}\n\t\tshow_bus(bus);\n#else\n\t\tif (i >= CONFIG_SYS_NUM_I2C_BUSES) {\n\t\t\tprintf(\"Invalid bus %d\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\t\tprintf(\"Bus %d:\\t%s\", i, I2C_ADAP_NR(i)->name);\n#ifndef CONFIG_SYS_I2C_DIRECT_BUS\n\t\t\tint j;\n\t\t\tfor (j = 0; j < CONFIG_SYS_I2C_MAX_HOPS; j++) {\n\t\t\t\tif (i2c_bus[i].next_hop[j].chip == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"->%s@0x%2x:%d\",\n\t\t\t\t       i2c_bus[i].next_hop[j].mux.name,\n\t\t\t\t       i2c_bus[i].next_hop[j].chip,\n\t\t\t\t       i2c_bus[i].next_hop[j].channel);\n\t\t\t}\n#endif\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\n\treturn 0;\n}\n#endif\n\n/**\n * do_i2c_bus_num() - Handle the \"i2c dev\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || defined(CONFIG_I2C_MULTI_BUS) || \\\n\t\tCONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_bus_num(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t  char *const argv[])\n{\n\tint\t\tret = 0;\n\tint\tbus_no;\n\n\tif (argc == 1) {\n\t\t/* querying current setting */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\n\t\tif (!i2c_get_cur_bus(&bus))\n\t\t\tbus_no = dev_seq(bus);\n\t\telse\n\t\t\tbus_no = -1;\n#else\n\t\tbus_no = i2c_get_bus_num();\n#endif\n\t\tprintf(\"Current bus is %d\\n\", bus_no);\n\t} else {\n\t\tbus_no = dectoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY)\n\t\tif (bus_no >= CONFIG_SYS_NUM_I2C_BUSES) {\n\t\t\tprintf(\"Invalid bus %d\\n\", bus_no);\n\t\t\treturn -1;\n\t\t}\n#endif\n\t\tprintf(\"Setting bus to %d\\n\", bus_no);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = cmd_i2c_set_bus_num(bus_no);\n#else\n\t\tret = i2c_set_bus_num(bus_no);\n#endif\n\t\tif (ret)\n\t\t\tprintf(\"Failure changing bus number (%d)\\n\", ret);\n\t}\n\n\treturn ret ? CMD_RET_FAILURE : 0;\n}\n#endif  /* CONFIG_IS_ENABLED(SYS_I2C_LEGACY) */\n\n/**\n * do_i2c_bus_speed() - Handle the \"i2c speed\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_bus_speed(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t    char *const argv[])\n{\n\tint speed, ret=0;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn 1;\n#endif\n\tif (argc == 1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tspeed = dm_i2c_get_bus_speed(bus);\n#else\n\t\tspeed = i2c_get_bus_speed();\n#endif\n\t\t/* querying current speed */\n\t\tprintf(\"Current bus speed=%d\\n\", speed);\n\t} else {\n\t\tspeed = dectoul(argv[1], NULL);\n\t\tprintf(\"Setting bus speed to %d Hz\\n\", speed);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_set_bus_speed(bus, speed);\n#else\n\t\tret = i2c_set_bus_speed(speed);\n#endif\n\t\tif (ret)\n\t\t\tprintf(\"Failure changing bus speed (%d)\\n\", ret);\n\t}\n\n\treturn ret ? CMD_RET_FAILURE : 0;\n}\n\n/**\n * do_i2c_mm() - Handle the \"i2c mm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_mm(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\treturn mod_i2c_mem (cmdtp, 1, flag, argc, argv);\n}\n\n/**\n * do_i2c_nm() - Handle the \"i2c nm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_nm(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\treturn mod_i2c_mem (cmdtp, 0, flag, argc, argv);\n}\n\n/**\n * do_i2c_reset() - Handle the \"i2c reset\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero always.\n */\nstatic int do_i2c_reset(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn CMD_RET_FAILURE;\n\tif (i2c_deblock(bus)) {\n\t\tprintf(\"Error: Not supported by the driver\\n\");\n\t\treturn CMD_RET_FAILURE;\n\t}\n#elif CONFIG_IS_ENABLED(SYS_I2C_LEGACY)\n\ti2c_init(I2C_ADAP->speed, I2C_ADAP->slaveaddr);\n#endif\n\treturn 0;\n}\n\nstatic struct cmd_tbl cmd_i2c_sub[] = {\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(bus, 1, 1, do_i2c_show_bus, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(crc32, 3, 1, do_i2c_crc, \"\", \"\"),\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || \\\n\tdefined(CONFIG_I2C_MULTI_BUS) || CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(dev, 1, 1, do_i2c_bus_num, \"\", \"\"),\n#endif  /* CONFIG_I2C_MULTI_BUS */\n#if defined(CONFIG_I2C_EDID)\n\tU_BOOT_CMD_MKENT(edid, 1, 1, do_edid, \"\", \"\"),\n#endif  /* CONFIG_I2C_EDID */\n\tU_BOOT_CMD_MKENT(loop, 3, 1, do_i2c_loop, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(md, 3, 1, do_i2c_md, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(mm, 2, 1, do_i2c_mm, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(mw, 3, 1, do_i2c_mw, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(nm, 2, 1, do_i2c_nm, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(probe, 0, 1, do_i2c_probe, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(read, 5, 1, do_i2c_read, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(write, 6, 0, do_i2c_write, \"\", \"\"),\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(flags, 2, 1, do_i2c_flags, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(olen, 2, 1, do_i2c_olen, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(reset, 0, 1, do_i2c_reset, \"\", \"\"),\n#if defined(CONFIG_CMD_SDRAM)\n\tU_BOOT_CMD_MKENT(sdram, 1, 1, do_sdram, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(speed, 1, 1, do_i2c_bus_speed, \"\", \"\"),\n};\n\nstatic __maybe_unused void i2c_reloc(void)\n{\n\tstatic int relocated;\n\n\tif (!relocated) {\n\t\tfixup_cmdtable(cmd_i2c_sub, ARRAY_SIZE(cmd_i2c_sub));\n\t\trelocated = 1;\n\t};\n}\n\n/**\n * do_i2c() - Handle the \"i2c\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\n\tstruct cmd_tbl *c;\n\n#ifdef CONFIG_NEEDS_MANUAL_RELOC\n\ti2c_reloc();\n#endif\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\t/* Strip off leading 'i2c' command argument */\n\targc--;\n\targv++;\n\n\tc = find_cmd_tbl(argv[0], &cmd_i2c_sub[0], ARRAY_SIZE(cmd_i2c_sub));\n\n\tif (c)\n\t\treturn c->cmd(cmdtp, flag, argc, argv);\n\telse\n\t\treturn CMD_RET_USAGE;\n}\n\n/***************************************************/\n#ifdef CONFIG_SYS_LONGHELP\nstatic char i2c_help_text[] =\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\n\t\"bus [muxtype:muxaddr:muxchannel] - show I2C bus info\\n\"\n\t\"i2c \" /* That's the prefix for the crc32 command below. */\n#endif\n\t\"crc32 chip address[.0, .1, .2] count - compute CRC32 checksum\\n\"\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || \\\n\tdefined(CONFIG_I2C_MULTI_BUS) || CONFIG_IS_ENABLED(DM_I2C)\n\t\"i2c dev [dev] - show or set current I2C bus\\n\"\n#endif  /* CONFIG_I2C_MULTI_BUS */\n#if defined(CONFIG_I2C_EDID)\n\t\"i2c edid chip - print EDID configuration information\\n\"\n#endif  /* CONFIG_I2C_EDID */\n\t\"i2c loop chip address[.0, .1, .2] [# of objects] - looping read of device\\n\"\n\t\"i2c md chip address[.0, .1, .2] [# of objects] - read from I2C device\\n\"\n\t\"i2c mm chip address[.0, .1, .2] - write to I2C device (auto-incrementing)\\n\"\n\t\"i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)\\n\"\n\t\"i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)\\n\"\n\t\"i2c probe [address] - test for and show device(s) on the I2C bus\\n\"\n\t\"i2c read chip address[.0, .1, .2] length memaddress - read to memory\\n\"\n\t\"i2c write memaddress chip address[.0, .1, .2] length [-s] - write memory\\n\"\n\t\"          to I2C; the -s option selects bulk write in a single transaction\\n\"\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\"i2c flags chip [flags] - set or get chip flags\\n\"\n\t\"i2c olen chip [offset_length] - set or get chip offset length\\n\"\n#endif\n\t\"i2c reset - re-init the I2C Controller\\n\"\n#if defined(CONFIG_CMD_SDRAM)\n\t\"i2c sdram chip - print SDRAM configuration information\\n\"\n#endif\n\t\"i2c speed [speed] - show or set I2C bus speed\";\n#endif\n\nU_BOOT_CMD(\n\ti2c, 7, 1, do_i2c,\n\t\"I2C sub-system\",\n\ti2c_help_text\n);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * (C) Copyright 2009\n * Sergey Kubushyn, himself, ksi@koi8.net\n *\n * Changes for unified multibus/multiadapter I2C support.\n *\n * (C) Copyright 2001\n * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.\n */\n\n/*\n * I2C Functions similar to the standard memory functions.\n *\n * There are several parameters in many of the commands that bear further\n * explanations:\n *\n * {i2c_chip} is the I2C chip address (the first byte sent on the bus).\n *   Each I2C chip on the bus has a unique address.  On the I2C data bus,\n *   the address is the upper seven bits and the LSB is the \"read/write\"\n *   bit.  Note that the {i2c_chip} address specified on the command\n *   line is not shifted up: e.g. a typical EEPROM memory chip may have\n *   an I2C address of 0x50, but the data put on the bus will be 0xA0\n *   for write and 0xA1 for read.  This \"non shifted\" address notation\n *   matches at least half of the data sheets :-/.\n *\n * {addr} is the address (or offset) within the chip.  Small memory\n *   chips have 8 bit addresses.  Large memory chips have 16 bit\n *   addresses.  Other memory chips have 9, 10, or 11 bit addresses.\n *   Many non-memory chips have multiple registers and {addr} is used\n *   as the register index.  Some non-memory chips have only one register\n *   and therefore don't need any {addr} parameter.\n *\n *   The default {addr} parameter is one byte (.1) which works well for\n *   memories and registers with 8 bits of address space.\n *\n *   You can specify the length of the {addr} field with the optional .0,\n *   .1, or .2 modifier (similar to the .b, .w, .l modifier).  If you are\n *   manipulating a single register device which doesn't use an address\n *   field, use \"0.0\" for the address and the \".0\" length field will\n *   suppress the address in the I2C data stream.  This also works for\n *   successive reads using the I2C auto-incrementing memory pointer.\n *\n *   If you are manipulating a large memory with 2-byte addresses, use\n *   the .2 address modifier, e.g. 210.2 addresses location 528 (decimal).\n *\n *   Then there are the unfortunate memory chips that spill the most\n *   significant 1, 2, or 3 bits of address into the chip address byte.\n *   This effectively makes one chip (logically) look like 2, 4, or\n *   8 chips.  This is handled (awkwardly) by #defining\n *   CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW and using the .1 modifier on the\n *   {addr} field (since .1 is the default, it doesn't actually have to\n *   be specified).  Examples: given a memory chip at I2C chip address\n *   0x50, the following would happen...\n *     i2c md 50 0 10   display 16 bytes starting at 0x000\n *                      On the bus: <S> A0 00 <E> <S> A1 <rd> ... <rd>\n *     i2c md 50 100 10 display 16 bytes starting at 0x100\n *                      On the bus: <S> A2 00 <E> <S> A3 <rd> ... <rd>\n *     i2c md 50 210 10 display 16 bytes starting at 0x210\n *                      On the bus: <S> A4 10 <E> <S> A5 <rd> ... <rd>\n *   This is awfully ugly.  It would be nice if someone would think up\n *   a better way of handling this.\n *\n * Adapted from cmd_mem.c which is copyright Wolfgang Denk (wd@denx.de).\n */\n\n#include <common.h>\n#include <bootretry.h>\n#include <cli.h>\n#include <command.h>\n#include <console.h>\n#include <dm.h>\n#include <edid.h>\n#include <errno.h>\n#include <i2c.h>\n#include <log.h>\n#include <malloc.h>\n#include <asm/byteorder.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <u-boot/crc.h>\n\n/* Display values from last command.\n * Memory modify remembered values are different from display memory.\n */\nstatic uint\ti2c_dp_last_chip;\nstatic uint\ti2c_dp_last_addr;\nstatic uint\ti2c_dp_last_alen;\nstatic uint\ti2c_dp_last_length = 0x10;\n\nstatic uint\ti2c_mm_last_chip;\nstatic uint\ti2c_mm_last_addr;\nstatic uint\ti2c_mm_last_alen;\n\n/* If only one I2C bus is present, the list of devices to ignore when\n * the probe command is issued is represented by a 1D array of addresses.\n * When multiple buses are present, the list is an array of bus-address\n * pairs.  The following macros take care of this */\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || defined(CONFIG_I2C_MULTI_BUS)\nstatic struct\n{\n\tuchar\tbus;\n\tuchar\taddr;\n} i2c_no_probes[] = CONFIG_SYS_I2C_NOPROBES;\n#define GET_BUS_NUM\ti2c_get_bus_num()\n#define COMPARE_BUS(b,i)\t(i2c_no_probes[(i)].bus == (b))\n#define COMPARE_ADDR(a,i)\t(i2c_no_probes[(i)].addr == (a))\n#define NO_PROBE_ADDR(i)\ti2c_no_probes[(i)].addr\n#else\t\t/* single bus */\nstatic uchar i2c_no_probes[] = CONFIG_SYS_I2C_NOPROBES;\n#define GET_BUS_NUM\t0\n#define COMPARE_BUS(b,i)\t((b) == 0)\t/* Make compiler happy */\n#define COMPARE_ADDR(a,i)\t(i2c_no_probes[(i)] == (a))\n#define NO_PROBE_ADDR(i)\ti2c_no_probes[(i)]\n#endif\t/* CONFIG_IS_ENABLED(SYS_I2C_LEGACY) */\n#endif\n\n#define DISP_LINE_LEN\t16\n\n/*\n * Default for driver model is to use the chip's existing address length.\n * For legacy code, this is not stored, so we need to use a suitable\n * default.\n */\n#if CONFIG_IS_ENABLED(DM_I2C)\n#define DEFAULT_ADDR_LEN\t(-1)\n#else\n#define DEFAULT_ADDR_LEN\t1\n#endif\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic struct udevice *i2c_cur_bus;\n\nstatic int cmd_i2c_set_bus_num(unsigned int busnum)\n{\n\tstruct udevice *bus;\n\tint ret;\n\n\tret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);\n\tif (ret) {\n\t\tdebug(\"%s: No bus %d\\n\", __func__, busnum);\n\t\treturn ret;\n\t}\n\ti2c_cur_bus = bus;\n\n\treturn 0;\n}\n\nstatic int i2c_get_cur_bus(struct udevice **busp)\n{\n#ifdef CONFIG_I2C_SET_DEFAULT_BUS_NUM\n\tif (!i2c_cur_bus) {\n\t\tif (cmd_i2c_set_bus_num(CONFIG_I2C_DEFAULT_BUS_NUMBER)) {\n\t\t\tprintf(\"Default I2C bus %d not found\\n\",\n\t\t\t       CONFIG_I2C_DEFAULT_BUS_NUMBER);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\tif (!i2c_cur_bus) {\n\t\tputs(\"No I2C bus selected\\n\");\n\t\treturn -ENODEV;\n\t}\n\t*busp = i2c_cur_bus;\n\n\treturn 0;\n}\n\nstatic int i2c_get_cur_bus_chip(uint chip_addr, struct udevice **devp)\n{\n\tstruct udevice *bus;\n\tint ret;\n\n\tret = i2c_get_cur_bus(&bus);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i2c_get_chip(bus, chip_addr, 1, devp);\n}\n\n#endif\n\n/**\n * i2c_init_board() - Board-specific I2C bus init\n *\n * This function is the default no-op implementation of I2C bus\n * initialization. This function can be overridden by board-specific\n * implementation if needed.\n */\n__weak\nvoid i2c_init_board(void)\n{\n}\n\n/**\n * get_alen() - Small parser helper function to get address length\n *\n * Returns the address length.\n */\nstatic uint get_alen(char *arg, uint default_len)\n{\n\tuint\tj;\n\tuint\talen;\n\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}\n\nenum i2c_err_op {\n\tI2C_ERR_READ,\n\tI2C_ERR_WRITE,\n};\n\nstatic int i2c_report_err(int ret, enum i2c_err_op op)\n{\n\tprintf(\"Error %s the chip: %d\\n\",\n\t       op == I2C_ERR_READ ? \"reading\" : \"writing\", ret);\n\n\treturn CMD_RET_FAILURE;\n}\n\n/**\n * do_i2c_read() - Handle the \"i2c read\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c read {i2c_chip} {devaddr}{.0, .1, .2} {len} {memaddr}\n */\nstatic int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tuint\talen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = hextoul(argv[3], NULL);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n\nstatic int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tuint\talen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * memaddr is the address where to store things in memory\n\t */\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\n\t/*\n\t * I2C chip address\n\t */\n\tchip = hextoul(argv[2], NULL);\n\n\t/*\n\t * I2C data address within the chip.  This can be 1 or\n\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t */\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\n\t/*\n\t * Length is the number of bytes.\n\t */\n\tlength = hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n\t\t/*\n\t\t * Write all bytes in a single I2C transaction. If the target\n\t\t * device is an EEPROM, it is your responsibility to not cross\n\t\t * a page boundary. No write delay upon completion, take this\n\t\t * into account if linking commands.\n\t\t */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\t/*\n\t\t * Repeated addressing - perform <length> separate\n\t\t * write transactions of one byte each\n\t\t */\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_flags(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tstruct udevice *dev;\n\tuint flags;\n\tint chip;\n\tint ret;\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\tchip = hextoul(argv[1], NULL);\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (argc > 2) {\n\t\tflags = hextoul(argv[2], NULL);\n\t\tret = i2c_set_chip_flags(dev, flags);\n\t} else  {\n\t\tret = i2c_get_chip_flags(dev, &flags);\n\t\tif (!ret)\n\t\t\tprintf(\"%x\\n\", flags);\n\t}\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n\nstatic int do_i2c_olen(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tstruct udevice *dev;\n\tuint olen;\n\tint chip;\n\tint ret;\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\tchip = hextoul(argv[1], NULL);\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (argc > 2) {\n\t\tolen = hextoul(argv[2], NULL);\n\t\tret = i2c_set_chip_offset_len(dev, olen);\n\t} else  {\n\t\tret = i2c_get_chip_offset_len(dev);\n\t\tif (ret >= 0) {\n\t\t\tprintf(\"%x\\n\", ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}\n#endif\n\n/**\n * do_i2c_md() - Handle the \"i2c md\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c md {i2c_chip} {addr}{.0, .1, .2} {len}\n */\nstatic int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tuint\talen;\n\tuint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}\n\n/**\n * do_i2c_mw() - Handle the \"i2c mw\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]\n */\nstatic int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tuint\talen;\n\tuchar\tbyte;\n\tuint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\t/*\n\t * Value to write is always specified.\n\t */\n\tbyte = hextoul(argv[3], NULL);\n\n\t/*\n\t * Optional count\n\t */\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t\t/*\n\t\t * Wait for the write to complete.  The write can take\n\t\t * up to 10mSec (we allow a little more time).\n\t\t */\n/*\n * No write delay with FRAM devices.\n */\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_i2c_crc() - Handle the \"i2c crc32\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Calculate a CRC on memory\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c crc32 {i2c_chip} {addr}{.0, .1, .2} {count}\n */\nstatic int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tuint\talen;\n\tuint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\t/*\n\t * Count is always specified\n\t */\n\tcount = hextoul(argv[3], NULL);\n\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\t/*\n\t * CRC a byte at a time.  This is going to be slooow, but hey, the\n\t * memories are small and slow too so hopefully nobody notices.\n\t */\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\n\treturn 0;\n}\n\n/**\n * mod_i2c_mem() - Handle the \"i2c mm\" and \"i2c nm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Modify memory.\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c mm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}\n *\ti2c nm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}\n */\nstatic int mod_i2c_mem(struct cmd_tbl *cmdtp, int incrflag, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tulong\tdata;\n\tint\tsize = 1;\n\tint\tnbytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 3)\n\t\treturn CMD_RET_USAGE;\n\n\tbootretry_reset_cmd_timeout();\t/* got a good command to get here */\n\t/*\n\t * We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip = i2c_mm_last_chip;\n\taddr = i2c_mm_last_addr;\n\talen = i2c_mm_last_alen;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.  Check for a size specification.\n\t\t * Defaults to byte if no or incorrect specification.\n\t\t */\n\t\tsize = cmd_get_data_size(argv[0], 1);\n\n\t\t/*\n\t\t * Chip is always specified.\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * Address is always specified.\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\t/*\n\t * Print the address, followed by value.  Then accept input for\n\t * the next value.  A non-converted value exits.\n\t */\n\tdo {\n\t\tprintf(\"%08lx:\", addr);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, (uchar *)&data, size);\n#else\n\t\tret = i2c_read(chip, addr, alen, (uchar *)&data, size);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\t\tdata = cpu_to_be32(data);\n\t\tif (size == 1)\n\t\t\tprintf(\" %02lx\", (data >> 24) & 0x000000FF);\n\t\telse if (size == 2)\n\t\t\tprintf(\" %04lx\", (data >> 16) & 0x0000FFFF);\n\t\telse\n\t\t\tprintf(\" %08lx\", data);\n\n\t\tnbytes = cli_readline(\" ? \");\n\t\tif (nbytes == 0) {\n\t\t\t/*\n\t\t\t * <CR> pressed as only input, don't modify current\n\t\t\t * location and move to next.\n\t\t\t */\n\t\t\tif (incrflag)\n\t\t\t\taddr += size;\n\t\t\tnbytes = size;\n\t\t\t/* good enough to not time out */\n\t\t\tbootretry_reset_cmd_timeout();\n\t\t}\n#ifdef CONFIG_BOOT_RETRY_TIME\n\t\telse if (nbytes == -2)\n\t\t\tbreak;\t/* timed out, exit the command\t*/\n#endif\n\t\telse {\n\t\t\tchar *endp;\n\n\t\t\tdata = hextoul(console_buffer, &endp);\n\t\t\tif (size == 1)\n\t\t\t\tdata = data << 24;\n\t\t\telse if (size == 2)\n\t\t\t\tdata = data << 16;\n\t\t\tdata = be32_to_cpu(data);\n\t\t\tnbytes = endp - console_buffer;\n\t\t\tif (nbytes) {\n\t\t\t\t/*\n\t\t\t\t * good enough to not time out\n\t\t\t\t */\n\t\t\t\tbootretry_reset_cmd_timeout();\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\t\tret = dm_i2c_write(dev, addr, (uchar *)&data,\n\t\t\t\t\t\t   size);\n#else\n\t\t\t\tret = i2c_write(chip, addr, alen,\n\t\t\t\t\t\t(uchar *)&data, size);\n#endif\n\t\t\t\tif (ret)\n\t\t\t\t\treturn i2c_report_err(ret,\n\t\t\t\t\t\t\t      I2C_ERR_WRITE);\n#if CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS > 0\n\t\t\t\tudelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);\n#endif\n\t\t\t\tif (incrflag)\n\t\t\t\t\taddr += size;\n\t\t\t}\n\t\t}\n\t} while (nbytes);\n\n\ti2c_mm_last_chip = chip;\n\ti2c_mm_last_addr = addr;\n\ti2c_mm_last_alen = alen;\n\n\treturn 0;\n}\n\n/**\n * do_i2c_probe() - Handle the \"i2c probe\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c probe {addr}\n *\n * Returns zero (success) if one or more I2C devices was found\n */\nstatic int do_i2c_probe(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tint j;\n\tint addr = -1;\n\tint found = 0;\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\tint k, skip;\n\tunsigned int bus = GET_BUS_NUM;\n#endif\t/* NOPROBES */\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus, *dev;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn CMD_RET_FAILURE;\n#endif\n\n\tif (argc == 2)\n\t\taddr = simple_strtol(argv[1], 0, 16);\n\n\tputs (\"Valid chip addresses:\");\n\tfor (j = 0; j < 128; j++) {\n\t\tif ((0 <= addr) && (j != addr))\n\t\t\tcontinue;\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\t\tskip = 0;\n\t\tfor (k = 0; k < ARRAY_SIZE(i2c_no_probes); k++) {\n\t\t\tif (COMPARE_BUS(bus, k) && COMPARE_ADDR(j, k)) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip)\n\t\t\tcontinue;\n#endif\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_probe(bus, j, 0, &dev);\n#else\n\t\tret = i2c_probe(j);\n#endif\n\t\tif (ret == 0) {\n\t\t\tprintf(\" %02X\", j);\n\t\t\tfound++;\n\t\t}\n\t}\n\tputc ('\\n');\n\n#if defined(CONFIG_SYS_I2C_NOPROBES)\n\tputs (\"Excluded chip addresses:\");\n\tfor (k = 0; k < ARRAY_SIZE(i2c_no_probes); k++) {\n\t\tif (COMPARE_BUS(bus,k))\n\t\t\tprintf(\" %02X\", NO_PROBE_ADDR(k));\n\t}\n\tputc ('\\n');\n#endif\n\n\treturn (0 == found);\n}\n\n/**\n * do_i2c_loop() - Handle the \"i2c loop\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n *\n * Syntax:\n *\ti2c loop {i2c_chip} {addr}{.0, .1, .2} [{length}] [{delay}]\n *\t{length} - Number of bytes to read\n *\t{delay}  - A DECIMAL number and defaults to 1000 uSec\n */\nstatic int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\talen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n\t/*\n\t * Address is always specified.\n\t */\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\n\t/*\n\t * Length is the number of objects, not number of bytes.\n\t */\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\n\t/*\n\t * The delay time (uSec) is optional.\n\t */\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\t/*\n\t * Run the loop...\n\t */\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}\n\n/*\n * The SDRAM command is separately configured because many\n * (most?) embedded boards don't use SDRAM DIMMs.\n *\n * FIXME: Document and probably move elsewhere!\n */\n#if defined(CONFIG_CMD_SDRAM)\nstatic void print_ddr2_tcyc (u_char const b)\n{\n\tprintf (\"%d.\", (b >> 4) & 0x0F);\n\tswitch (b & 0x0F) {\n\tcase 0x0:\n\tcase 0x1:\n\tcase 0x2:\n\tcase 0x3:\n\tcase 0x4:\n\tcase 0x5:\n\tcase 0x6:\n\tcase 0x7:\n\tcase 0x8:\n\tcase 0x9:\n\t\tprintf (\"%d ns\\n\", b & 0x0F);\n\t\tbreak;\n\tcase 0xA:\n\t\tputs (\"25 ns\\n\");\n\t\tbreak;\n\tcase 0xB:\n\t\tputs (\"33 ns\\n\");\n\t\tbreak;\n\tcase 0xC:\n\t\tputs (\"66 ns\\n\");\n\t\tbreak;\n\tcase 0xD:\n\t\tputs (\"75 ns\\n\");\n\t\tbreak;\n\tdefault:\n\t\tputs (\"?? ns\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void decode_bits (u_char const b, char const *str[], int const do_once)\n{\n\tu_char mask;\n\n\tfor (mask = 0x80; mask != 0x00; mask >>= 1, ++str) {\n\t\tif (b & mask) {\n\t\t\tputs (*str);\n\t\t\tif (do_once)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * Syntax:\n *\ti2c sdram {i2c_chip}\n */\nstatic int do_sdram(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t    char *const argv[])\n{\n\tenum { unknown, EDO, SDRAM, DDR, DDR2, DDR3, DDR4 } type;\n\n\tuint\tchip;\n\tu_char\tdata[128];\n\tu_char\tcksum;\n\tint\tj, ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tstatic const char *decode_CAS_DDR2[] = {\n\t\t\" TBD\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" TBD\", \" TBD\"\n\t};\n\n\tstatic const char *decode_CAS_default[] = {\n\t\t\" TBD\", \" 7\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" 1\"\n\t};\n\n\tstatic const char *decode_CS_WE_default[] = {\n\t\t\" TBD\", \" 6\", \" 5\", \" 4\", \" 3\", \" 2\", \" 1\", \" 0\"\n\t};\n\n\tstatic const char *decode_byte21_default[] = {\n\t\t\"  TBD (bit 7)\\n\",\n\t\t\"  Redundant row address\\n\",\n\t\t\"  Differential clock input\\n\",\n\t\t\"  Registerd DQMB inputs\\n\",\n\t\t\"  Buffered DQMB inputs\\n\",\n\t\t\"  On-card PLL\\n\",\n\t\t\"  Registered address/control lines\\n\",\n\t\t\"  Buffered address/control lines\\n\"\n\t};\n\n\tstatic const char *decode_byte22_DDR2[] = {\n\t\t\"  TBD (bit 7)\\n\",\n\t\t\"  TBD (bit 6)\\n\",\n\t\t\"  TBD (bit 5)\\n\",\n\t\t\"  TBD (bit 4)\\n\",\n\t\t\"  TBD (bit 3)\\n\",\n\t\t\"  Supports partial array self refresh\\n\",\n\t\t\"  Supports 50 ohm ODT\\n\",\n\t\t\"  Supports weak driver\\n\"\n\t};\n\n\tstatic const char *decode_row_density_DDR2[] = {\n\t\t\"512 MiB\", \"256 MiB\", \"128 MiB\", \"16 GiB\",\n\t\t\"8 GiB\", \"4 GiB\", \"2 GiB\", \"1 GiB\"\n\t};\n\n\tstatic const char *decode_row_density_default[] = {\n\t\t\"512 MiB\", \"256 MiB\", \"128 MiB\", \"64 MiB\",\n\t\t\"32 MiB\", \"16 MiB\", \"8 MiB\", \"4 MiB\"\n\t};\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\t/*\n\t * Chip is always specified.\n\t */\n\tchip = hextoul(argv[1], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, 0, data, sizeof(data));\n#else\n\tret = i2c_read(chip, 0, 1, data, sizeof(data));\n#endif\n\tif (ret) {\n\t\tputs (\"No SDRAM Serial Presence Detect found.\\n\");\n\t\treturn 1;\n\t}\n\n\tcksum = 0;\n\tfor (j = 0; j < 63; j++) {\n\t\tcksum += data[j];\n\t}\n\tif (cksum != data[63]) {\n\t\tprintf (\"WARNING: Configuration data checksum failure:\\n\"\n\t\t\t\"  is 0x%02x, calculated 0x%02x\\n\", data[63], cksum);\n\t}\n\tprintf (\"SPD data revision            %d.%d\\n\",\n\t\t(data[62] >> 4) & 0x0F, data[62] & 0x0F);\n\tprintf (\"Bytes used                   0x%02X\\n\", data[0]);\n\tprintf (\"Serial memory size           0x%02X\\n\", 1 << data[1]);\n\n\tputs (\"Memory type                  \");\n\tswitch (data[2]) {\n\tcase 2:\n\t\ttype = EDO;\n\t\tputs (\"EDO\\n\");\n\t\tbreak;\n\tcase 4:\n\t\ttype = SDRAM;\n\t\tputs (\"SDRAM\\n\");\n\t\tbreak;\n\tcase 7:\n\t\ttype = DDR;\n\t\tputs(\"DDR\\n\");\n\t\tbreak;\n\tcase 8:\n\t\ttype = DDR2;\n\t\tputs (\"DDR2\\n\");\n\t\tbreak;\n\tcase 11:\n\t\ttype = DDR3;\n\t\tputs(\"DDR3\\n\");\n\t\tbreak;\n\tcase 12:\n\t\ttype = DDR4;\n\t\tputs(\"DDR4\\n\");\n\t\tbreak;\n\tdefault:\n\t\ttype = unknown;\n\t\tputs (\"unknown\\n\");\n\t\tbreak;\n\t}\n\n\tputs (\"Row address bits             \");\n\tif ((data[3] & 0x00F0) == 0)\n\t\tprintf (\"%d\\n\", data[3] & 0x0F);\n\telse\n\t\tprintf (\"%d/%d\\n\", data[3] & 0x0F, (data[3] >> 4) & 0x0F);\n\n\tputs (\"Column address bits          \");\n\tif ((data[4] & 0x00F0) == 0)\n\t\tprintf (\"%d\\n\", data[4] & 0x0F);\n\telse\n\t\tprintf (\"%d/%d\\n\", data[4] & 0x0F, (data[4] >> 4) & 0x0F);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Number of ranks              %d\\n\",\n\t\t\t(data[5] & 0x07) + 1);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Module rows                  %d\\n\", data[5]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Module data width            %d bits\\n\", data[6]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Module data width            %d bits\\n\",\n\t\t\t(data[7] << 8) | data[6]);\n\t\tbreak;\n\t}\n\n\tputs (\"Interface signal levels      \");\n\tswitch(data[8]) {\n\t\tcase 0:  puts (\"TTL 5.0 V\\n\");\tbreak;\n\t\tcase 1:  puts (\"LVTTL\\n\");\tbreak;\n\t\tcase 2:  puts (\"HSTL 1.5 V\\n\");\tbreak;\n\t\tcase 3:  puts (\"SSTL 3.3 V\\n\");\tbreak;\n\t\tcase 4:  puts (\"SSTL 2.5 V\\n\");\tbreak;\n\t\tcase 5:  puts (\"SSTL 1.8 V\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time             \");\n\t\tprint_ddr2_tcyc (data[9]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time             %d.%d ns\\n\",\n\t\t\t(data[9] >> 4) & 0x0F, data[9] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access time            0.%d%d ns\\n\",\n\t\t\t(data[10] >> 4) & 0x0F, data[10] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access time            %d.%d ns\\n\",\n\t\t\t(data[10] >> 4) & 0x0F, data[10] & 0x0F);\n\t\tbreak;\n\t}\n\n\tputs (\"EDC configuration            \");\n\tswitch (data[11]) {\n\t\tcase 0:  puts (\"None\\n\");\tbreak;\n\t\tcase 1:  puts (\"Parity\\n\");\tbreak;\n\t\tcase 2:  puts (\"ECC\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tif ((data[12] & 0x80) == 0)\n\t\tputs (\"No self refresh, rate        \");\n\telse\n\t\tputs (\"Self refresh, rate           \");\n\n\tswitch(data[12] & 0x7F) {\n\t\tcase 0:  puts (\"15.625 us\\n\");\tbreak;\n\t\tcase 1:  puts (\"3.9 us\\n\");\tbreak;\n\t\tcase 2:  puts (\"7.8 us\\n\");\tbreak;\n\t\tcase 3:  puts (\"31.3 us\\n\");\tbreak;\n\t\tcase 4:  puts (\"62.5 us\\n\");\tbreak;\n\t\tcase 5:  puts (\"125 us\\n\");\tbreak;\n\t\tdefault: puts (\"unknown\\n\");\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM width (primary)        %d\\n\", data[13]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM width (primary)        %d\\n\", data[13] & 0x7F);\n\t\tif ((data[13] & 0x80) != 0) {\n\t\t\tprintf (\"  (second bank)              %d\\n\",\n\t\t\t\t2 * (data[13] & 0x7F));\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tif (data[14] != 0)\n\t\t\tprintf (\"EDC width                    %d\\n\", data[14]);\n\t\tbreak;\n\tdefault:\n\t\tif (data[14] != 0) {\n\t\t\tprintf (\"EDC width                    %d\\n\",\n\t\t\t\tdata[14] & 0x7F);\n\n\t\t\tif ((data[14] & 0x80) != 0) {\n\t\t\t\tprintf (\"  (second bank)              %d\\n\",\n\t\t\t\t\t2 * (data[14] & 0x7F));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (DDR2 != type) {\n\t\tprintf (\"Min clock delay, back-to-back random column addresses \"\n\t\t\t\"%d\\n\", data[15]);\n\t}\n\n\tputs (\"Burst length(s)             \");\n\tif (data[16] & 0x80) puts (\" Page\");\n\tif (data[16] & 0x08) puts (\" 8\");\n\tif (data[16] & 0x04) puts (\" 4\");\n\tif (data[16] & 0x02) puts (\" 2\");\n\tif (data[16] & 0x01) puts (\" 1\");\n\tputc ('\\n');\n\tprintf (\"Number of banks              %d\\n\", data[17]);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"CAS latency(s)              \");\n\t\tdecode_bits (data[18], decode_CAS_DDR2, 0);\n\t\tputc ('\\n');\n\t\tbreak;\n\tdefault:\n\t\tputs (\"CAS latency(s)              \");\n\t\tdecode_bits (data[18], decode_CAS_default, 0);\n\t\tputc ('\\n');\n\t\tbreak;\n\t}\n\n\tif (DDR2 != type) {\n\t\tputs (\"CS latency(s)               \");\n\t\tdecode_bits (data[19], decode_CS_WE_default, 0);\n\t\tputc ('\\n');\n\t}\n\n\tif (DDR2 != type) {\n\t\tputs (\"WE latency(s)               \");\n\t\tdecode_bits (data[20], decode_CS_WE_default, 0);\n\t\tputc ('\\n');\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Module attributes:\\n\");\n\t\tif (data[21] & 0x80)\n\t\t\tputs (\"  TBD (bit 7)\\n\");\n\t\tif (data[21] & 0x40)\n\t\t\tputs (\"  Analysis probe installed\\n\");\n\t\tif (data[21] & 0x20)\n\t\t\tputs (\"  TBD (bit 5)\\n\");\n\t\tif (data[21] & 0x10)\n\t\t\tputs (\"  FET switch external enable\\n\");\n\t\tprintf (\"  %d PLLs on DIMM\\n\", (data[21] >> 2) & 0x03);\n\t\tif (data[20] & 0x11) {\n\t\t\tprintf (\"  %d active registers on DIMM\\n\",\n\t\t\t\t(data[21] & 0x03) + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Module attributes:\\n\");\n\t\tif (!data[21])\n\t\t\tputs (\"  (none)\\n\");\n\t\telse\n\t\t\tdecode_bits (data[21], decode_byte21_default, 0);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tdecode_bits (data[22], decode_byte22_DDR2, 0);\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Device attributes:\\n\");\n\t\tif (data[22] & 0x80) puts (\"  TBD (bit 7)\\n\");\n\t\tif (data[22] & 0x40) puts (\"  TBD (bit 6)\\n\");\n\t\tif (data[22] & 0x20) puts (\"  Upper Vcc tolerance 5%\\n\");\n\t\telse                 puts (\"  Upper Vcc tolerance 10%\\n\");\n\t\tif (data[22] & 0x10) puts (\"  Lower Vcc tolerance 5%\\n\");\n\t\telse                 puts (\"  Lower Vcc tolerance 10%\\n\");\n\t\tif (data[22] & 0x08) puts (\"  Supports write1/read burst\\n\");\n\t\tif (data[22] & 0x04) puts (\"  Supports precharge all\\n\");\n\t\tif (data[22] & 0x02) puts (\"  Supports auto precharge\\n\");\n\t\tif (data[22] & 0x01) puts (\"  Supports early RAS# precharge\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time (2nd highest CAS latency)        \");\n\t\tprint_ddr2_tcyc (data[23]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time (2nd highest CAS latency)        %d.\"\n\t\t\t\"%d ns\\n\", (data[23] >> 4) & 0x0F, data[23] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access from clock (2nd highest CAS latency) 0.\"\n\t\t\t\"%d%d ns\\n\", (data[24] >> 4) & 0x0F, data[24] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access from clock (2nd highest CAS latency) %d.\"\n\t\t\t\"%d ns\\n\", (data[24] >> 4) & 0x0F, data[24] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM cycle time (3rd highest CAS latency)        \");\n\t\tprint_ddr2_tcyc (data[25]);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM cycle time (3rd highest CAS latency)        %d.\"\n\t\t\t\"%d ns\\n\", (data[25] >> 4) & 0x0F, data[25] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"SDRAM access from clock (3rd highest CAS latency) 0.\"\n\t\t\t\"%d%d ns\\n\", (data[26] >> 4) & 0x0F, data[26] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"SDRAM access from clock (3rd highest CAS latency) %d.\"\n\t\t\t\"%d ns\\n\", (data[26] >> 4) & 0x0F, data[26] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Minimum row precharge        %d.%02d ns\\n\",\n\t\t\t(data[27] >> 2) & 0x3F, 25 * (data[27] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Minimum row precharge        %d ns\\n\", data[27]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Row active to row active min %d.%02d ns\\n\",\n\t\t\t(data[28] >> 2) & 0x3F, 25 * (data[28] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Row active to row active min %d ns\\n\", data[28]);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"RAS to CAS delay min         %d.%02d ns\\n\",\n\t\t\t(data[29] >> 2) & 0x3F, 25 * (data[29] & 0x03));\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"RAS to CAS delay min         %d ns\\n\", data[29]);\n\t\tbreak;\n\t}\n\n\tprintf (\"Minimum RAS pulse width      %d ns\\n\", data[30]);\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Density of each row          \");\n\t\tdecode_bits (data[31], decode_row_density_DDR2, 1);\n\t\tputc ('\\n');\n\t\tbreak;\n\tdefault:\n\t\tputs (\"Density of each row          \");\n\t\tdecode_bits (data[31], decode_row_density_default, 1);\n\t\tputc ('\\n');\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Command and Address setup    \");\n\t\tif (data[32] >= 0xA0) {\n\t\t\tprintf (\"1.%d%d ns\\n\",\n\t\t\t\t((data[32] >> 4) & 0x0F) - 10, data[32] & 0x0F);\n\t\t} else {\n\t\t\tprintf (\"0.%d%d ns\\n\",\n\t\t\t\t((data[32] >> 4) & 0x0F), data[32] & 0x0F);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Command and Address setup    %c%d.%d ns\\n\",\n\t\t\t(data[32] & 0x80) ? '-' : '+',\n\t\t\t(data[32] >> 4) & 0x07, data[32] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tputs (\"Command and Address hold     \");\n\t\tif (data[33] >= 0xA0) {\n\t\t\tprintf (\"1.%d%d ns\\n\",\n\t\t\t\t((data[33] >> 4) & 0x0F) - 10, data[33] & 0x0F);\n\t\t} else {\n\t\t\tprintf (\"0.%d%d ns\\n\",\n\t\t\t\t((data[33] >> 4) & 0x0F), data[33] & 0x0F);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Command and Address hold     %c%d.%d ns\\n\",\n\t\t\t(data[33] & 0x80) ? '-' : '+',\n\t\t\t(data[33] >> 4) & 0x07, data[33] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Data signal input setup      0.%d%d ns\\n\",\n\t\t\t(data[34] >> 4) & 0x0F, data[34] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Data signal input setup      %c%d.%d ns\\n\",\n\t\t\t(data[34] & 0x80) ? '-' : '+',\n\t\t\t(data[34] >> 4) & 0x07, data[34] & 0x0F);\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DDR2:\n\t\tprintf (\"Data signal input hold       0.%d%d ns\\n\",\n\t\t\t(data[35] >> 4) & 0x0F, data[35] & 0x0F);\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Data signal input hold       %c%d.%d ns\\n\",\n\t\t\t(data[35] & 0x80) ? '-' : '+',\n\t\t\t(data[35] >> 4) & 0x07, data[35] & 0x0F);\n\t\tbreak;\n\t}\n\n\tputs (\"Manufacturer's JEDEC ID      \");\n\tfor (j = 64; j <= 71; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\tprintf (\"Manufacturing Location       %02X\\n\", data[72]);\n\tputs (\"Manufacturer's Part Number   \");\n\tfor (j = 73; j <= 90; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\tprintf (\"Revision Code                %02X %02X\\n\", data[91], data[92]);\n\tprintf (\"Manufacturing Date           %02X %02X\\n\", data[93], data[94]);\n\tputs (\"Assembly Serial Number       \");\n\tfor (j = 95; j <= 98; j++)\n\t\tprintf (\"%02X \", data[j]);\n\tputc ('\\n');\n\n\tif (DDR2 != type) {\n\t\tprintf (\"Speed rating                 PC%d\\n\",\n\t\t\tdata[126] == 0x66 ? 66 : data[126]);\n\t}\n\treturn 0;\n}\n#endif\n\n/*\n * Syntax:\n *\ti2c edid {i2c_chip}\n */\n#if defined(CONFIG_I2C_EDID)\nint do_edid(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\n\tuint chip;\n\tstruct edid1_info edid;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc < 2) {\n\t\tcmd_usage(cmdtp);\n\t\treturn 1;\n\t}\n\n\tchip = hextoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, 0, (uchar *)&edid, sizeof(edid));\n#else\n\tret = i2c_read(chip, 0, 1, (uchar *)&edid, sizeof(edid));\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\tif (edid_check_info(&edid)) {\n\t\tputs(\"Content isn't valid EDID.\\n\");\n\t\treturn 1;\n\t}\n\n\tedid_print_info(&edid);\n\treturn 0;\n\n}\n#endif /* CONFIG_I2C_EDID */\n\n#if CONFIG_IS_ENABLED(DM_I2C)\nstatic void show_bus(struct udevice *bus)\n{\n\tstruct udevice *dev;\n\n\tprintf(\"Bus %d:\\t%s\", dev_seq(bus), bus->name);\n\tif (device_active(bus))\n\t\tprintf(\"  (active %d)\", dev_seq(bus));\n\tprintf(\"\\n\");\n\tfor (device_find_first_child(bus, &dev);\n\t     dev;\n\t     device_find_next_child(&dev)) {\n\t\tstruct dm_i2c_chip *chip = dev_get_parent_plat(dev);\n\n\t\tprintf(\"   %02x: %s, offset len %x, flags %x\\n\",\n\t\t       chip->chip_addr, dev->name, chip->offset_len,\n\t\t       chip->flags);\n\t}\n}\n#endif\n\n/**\n * do_i2c_show_bus() - Handle the \"i2c bus\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero always.\n */\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_show_bus(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t   char *const argv[])\n{\n\tif (argc == 1) {\n\t\t/* show all busses */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\t\tstruct uclass *uc;\n\t\tint ret;\n\n\t\tret = uclass_get(UCLASS_I2C, &uc);\n\t\tif (ret)\n\t\t\treturn CMD_RET_FAILURE;\n\t\tuclass_foreach_dev(bus, uc)\n\t\t\tshow_bus(bus);\n#else\n\t\tint i;\n\n\t\tfor (i = 0; i < CONFIG_SYS_NUM_I2C_BUSES; i++) {\n\t\t\tprintf(\"Bus %d:\\t%s\", i, I2C_ADAP_NR(i)->name);\n#ifndef CONFIG_SYS_I2C_DIRECT_BUS\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < CONFIG_SYS_I2C_MAX_HOPS; j++) {\n\t\t\t\tif (i2c_bus[i].next_hop[j].chip == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"->%s@0x%2x:%d\",\n\t\t\t\t       i2c_bus[i].next_hop[j].mux.name,\n\t\t\t\t       i2c_bus[i].next_hop[j].chip,\n\t\t\t\t       i2c_bus[i].next_hop[j].channel);\n\t\t\t}\n#endif\n\t\t\tprintf(\"\\n\");\n\t\t}\n#endif\n\t} else {\n\t\tint i;\n\n\t\t/* show specific bus */\n\t\ti = dectoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\t\tint ret;\n\n\t\tret = uclass_get_device_by_seq(UCLASS_I2C, i, &bus);\n\t\tif (ret) {\n\t\t\tprintf(\"Invalid bus %d: err=%d\\n\", i, ret);\n\t\t\treturn CMD_RET_FAILURE;\n\t\t}\n\t\tshow_bus(bus);\n#else\n\t\tif (i >= CONFIG_SYS_NUM_I2C_BUSES) {\n\t\t\tprintf(\"Invalid bus %d\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\t\tprintf(\"Bus %d:\\t%s\", i, I2C_ADAP_NR(i)->name);\n#ifndef CONFIG_SYS_I2C_DIRECT_BUS\n\t\t\tint j;\n\t\t\tfor (j = 0; j < CONFIG_SYS_I2C_MAX_HOPS; j++) {\n\t\t\t\tif (i2c_bus[i].next_hop[j].chip == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"->%s@0x%2x:%d\",\n\t\t\t\t       i2c_bus[i].next_hop[j].mux.name,\n\t\t\t\t       i2c_bus[i].next_hop[j].chip,\n\t\t\t\t       i2c_bus[i].next_hop[j].channel);\n\t\t\t}\n#endif\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\n\treturn 0;\n}\n#endif\n\n/**\n * do_i2c_bus_num() - Handle the \"i2c dev\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || defined(CONFIG_I2C_MULTI_BUS) || \\\n\t\tCONFIG_IS_ENABLED(DM_I2C)\nstatic int do_i2c_bus_num(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t  char *const argv[])\n{\n\tint\t\tret = 0;\n\tint\tbus_no;\n\n\tif (argc == 1) {\n\t\t/* querying current setting */\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tstruct udevice *bus;\n\n\t\tif (!i2c_get_cur_bus(&bus))\n\t\t\tbus_no = dev_seq(bus);\n\t\telse\n\t\t\tbus_no = -1;\n#else\n\t\tbus_no = i2c_get_bus_num();\n#endif\n\t\tprintf(\"Current bus is %d\\n\", bus_no);\n\t} else {\n\t\tbus_no = dectoul(argv[1], NULL);\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY)\n\t\tif (bus_no >= CONFIG_SYS_NUM_I2C_BUSES) {\n\t\t\tprintf(\"Invalid bus %d\\n\", bus_no);\n\t\t\treturn -1;\n\t\t}\n#endif\n\t\tprintf(\"Setting bus to %d\\n\", bus_no);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = cmd_i2c_set_bus_num(bus_no);\n#else\n\t\tret = i2c_set_bus_num(bus_no);\n#endif\n\t\tif (ret)\n\t\t\tprintf(\"Failure changing bus number (%d)\\n\", ret);\n\t}\n\n\treturn ret ? CMD_RET_FAILURE : 0;\n}\n#endif  /* CONFIG_IS_ENABLED(SYS_I2C_LEGACY) */\n\n/**\n * do_i2c_bus_speed() - Handle the \"i2c speed\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_bus_speed(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\t    char *const argv[])\n{\n\tint speed, ret=0;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn 1;\n#endif\n\tif (argc == 1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tspeed = dm_i2c_get_bus_speed(bus);\n#else\n\t\tspeed = i2c_get_bus_speed();\n#endif\n\t\t/* querying current speed */\n\t\tprintf(\"Current bus speed=%d\\n\", speed);\n\t} else {\n\t\tspeed = dectoul(argv[1], NULL);\n\t\tprintf(\"Setting bus speed to %d Hz\\n\", speed);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_set_bus_speed(bus, speed);\n#else\n\t\tret = i2c_set_bus_speed(speed);\n#endif\n\t\tif (ret)\n\t\t\tprintf(\"Failure changing bus speed (%d)\\n\", ret);\n\t}\n\n\treturn ret ? CMD_RET_FAILURE : 0;\n}\n\n/**\n * do_i2c_mm() - Handle the \"i2c mm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_mm(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\treturn mod_i2c_mem (cmdtp, 1, flag, argc, argv);\n}\n\n/**\n * do_i2c_nm() - Handle the \"i2c nm\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c_nm(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\treturn mod_i2c_mem (cmdtp, 0, flag, argc, argv);\n}\n\n/**\n * do_i2c_reset() - Handle the \"i2c reset\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero always.\n */\nstatic int do_i2c_reset(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *bus;\n\n\tif (i2c_get_cur_bus(&bus))\n\t\treturn CMD_RET_FAILURE;\n\tif (i2c_deblock(bus)) {\n\t\tprintf(\"Error: Not supported by the driver\\n\");\n\t\treturn CMD_RET_FAILURE;\n\t}\n#elif CONFIG_IS_ENABLED(SYS_I2C_LEGACY)\n\ti2c_init(I2C_ADAP->speed, I2C_ADAP->slaveaddr);\n#endif\n\treturn 0;\n}\n\nstatic struct cmd_tbl cmd_i2c_sub[] = {\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(bus, 1, 1, do_i2c_show_bus, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(crc32, 3, 1, do_i2c_crc, \"\", \"\"),\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || \\\n\tdefined(CONFIG_I2C_MULTI_BUS) || CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(dev, 1, 1, do_i2c_bus_num, \"\", \"\"),\n#endif  /* CONFIG_I2C_MULTI_BUS */\n#if defined(CONFIG_I2C_EDID)\n\tU_BOOT_CMD_MKENT(edid, 1, 1, do_edid, \"\", \"\"),\n#endif  /* CONFIG_I2C_EDID */\n\tU_BOOT_CMD_MKENT(loop, 3, 1, do_i2c_loop, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(md, 3, 1, do_i2c_md, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(mm, 2, 1, do_i2c_mm, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(mw, 3, 1, do_i2c_mw, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(nm, 2, 1, do_i2c_nm, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(probe, 0, 1, do_i2c_probe, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(read, 5, 1, do_i2c_read, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(write, 6, 0, do_i2c_write, \"\", \"\"),\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tU_BOOT_CMD_MKENT(flags, 2, 1, do_i2c_flags, \"\", \"\"),\n\tU_BOOT_CMD_MKENT(olen, 2, 1, do_i2c_olen, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(reset, 0, 1, do_i2c_reset, \"\", \"\"),\n#if defined(CONFIG_CMD_SDRAM)\n\tU_BOOT_CMD_MKENT(sdram, 1, 1, do_sdram, \"\", \"\"),\n#endif\n\tU_BOOT_CMD_MKENT(speed, 1, 1, do_i2c_bus_speed, \"\", \"\"),\n};\n\nstatic __maybe_unused void i2c_reloc(void)\n{\n\tstatic int relocated;\n\n\tif (!relocated) {\n\t\tfixup_cmdtable(cmd_i2c_sub, ARRAY_SIZE(cmd_i2c_sub));\n\t\trelocated = 1;\n\t};\n}\n\n/**\n * do_i2c() - Handle the \"i2c\" command-line command\n * @cmdtp:\tCommand data struct pointer\n * @flag:\tCommand flag\n * @argc:\tCommand-line argument count\n * @argv:\tArray of command-line arguments\n *\n * Returns zero on success, CMD_RET_USAGE in case of misuse and negative\n * on error.\n */\nstatic int do_i2c(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\n\tstruct cmd_tbl *c;\n\n#ifdef CONFIG_NEEDS_MANUAL_RELOC\n\ti2c_reloc();\n#endif\n\n\tif (argc < 2)\n\t\treturn CMD_RET_USAGE;\n\n\t/* Strip off leading 'i2c' command argument */\n\targc--;\n\targv++;\n\n\tc = find_cmd_tbl(argv[0], &cmd_i2c_sub[0], ARRAY_SIZE(cmd_i2c_sub));\n\n\tif (c)\n\t\treturn c->cmd(cmdtp, flag, argc, argv);\n\telse\n\t\treturn CMD_RET_USAGE;\n}\n\n/***************************************************/\n#ifdef CONFIG_SYS_LONGHELP\nstatic char i2c_help_text[] =\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || CONFIG_IS_ENABLED(DM_I2C)\n\t\"bus [muxtype:muxaddr:muxchannel] - show I2C bus info\\n\"\n\t\"i2c \" /* That's the prefix for the crc32 command below. */\n#endif\n\t\"crc32 chip address[.0, .1, .2] count - compute CRC32 checksum\\n\"\n#if CONFIG_IS_ENABLED(SYS_I2C_LEGACY) || \\\n\tdefined(CONFIG_I2C_MULTI_BUS) || CONFIG_IS_ENABLED(DM_I2C)\n\t\"i2c dev [dev] - show or set current I2C bus\\n\"\n#endif  /* CONFIG_I2C_MULTI_BUS */\n#if defined(CONFIG_I2C_EDID)\n\t\"i2c edid chip - print EDID configuration information\\n\"\n#endif  /* CONFIG_I2C_EDID */\n\t\"i2c loop chip address[.0, .1, .2] [# of objects] - looping read of device\\n\"\n\t\"i2c md chip address[.0, .1, .2] [# of objects] - read from I2C device\\n\"\n\t\"i2c mm chip address[.0, .1, .2] - write to I2C device (auto-incrementing)\\n\"\n\t\"i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)\\n\"\n\t\"i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)\\n\"\n\t\"i2c probe [address] - test for and show device(s) on the I2C bus\\n\"\n\t\"i2c read chip address[.0, .1, .2] length memaddress - read to memory\\n\"\n\t\"i2c write memaddress chip address[.0, .1, .2] length [-s] - write memory\\n\"\n\t\"          to I2C; the -s option selects bulk write in a single transaction\\n\"\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\"i2c flags chip [flags] - set or get chip flags\\n\"\n\t\"i2c olen chip [offset_length] - set or get chip offset length\\n\"\n#endif\n\t\"i2c reset - re-init the I2C Controller\\n\"\n#if defined(CONFIG_CMD_SDRAM)\n\t\"i2c sdram chip - print SDRAM configuration information\\n\"\n#endif\n\t\"i2c speed [speed] - show or set I2C bus speed\";\n#endif\n\nU_BOOT_CMD(\n\ti2c, 7, 1, do_i2c,\n\t\"I2C sub-system\",\n\ti2c_help_text\n);\n"], "filenames": ["cmd/i2c.c"], "buggy_code_start_loc": [203], "buggy_code_end_loc": [989], "fixing_code_start_loc": [203], "fixing_code_end_loc": [989], "type": "CWE-787", "message": "In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the \"i2c md\" command enables the corruption of the return address pointer of the do_i2c_md function.", "other": {"cve": {"id": "CVE-2022-34835", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-30T00:15:08.023", "lastModified": "2022-07-09T02:28:34.480", "vulnStatus": "Undergoing Analysis", "descriptions": [{"lang": "en", "value": "In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant stack-based buffer overflow in the \"i2c md\" command enables the corruption of the return address pointer of the do_i2c_md function."}, {"lang": "es", "value": "En Das U-Boot versiones hasta 2022.07-rc5, un error de firma de enteros y el desbordamiento de b\u00fafer resultante en la regi\u00f3n stack de la memoria en el comando \"i2c md\" permite una corrupci\u00f3n del puntero de la direcci\u00f3n de retorno de la funci\u00f3n do_i2c_md"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.07", "matchCriteriaId": "4F9D7A74-0BF8-4A69-BB4B-B435AD1A7FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc1:*:*:*:*:*:*", "matchCriteriaId": "D173B461-EBA5-4A85-8002-6A5B557917D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc2:*:*:*:*:*:*", "matchCriteriaId": "3E3EDD31-1721-467F-B6E5-EA357D7DD8AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc3:*:*:*:*:*:*", "matchCriteriaId": "37FD1A01-0D94-4C34-941F-07E8341950A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc4:*:*:*:*:*:*", "matchCriteriaId": "4405929A-C37D-4D07-8639-02E9673419AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc5:*:*:*:*:*:*", "matchCriteriaId": "D2385A75-D2D9-4284-AE1B-3E9902B3D49D"}]}]}], "references": [{"url": "https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.denx.de/pipermail/u-boot/2022-June/486113.html", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://source.denx.de/u-boot/u-boot/-/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409"}}