{"buggy_code": ["#!/usr/bin/env python\n#############################################################\n# ubi_reader/ubifs\n# (c) 2013 Jason Pruitt (jrspruitt@gmail.com)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#############################################################\n\nimport os\nimport struct\n\nfrom ubireader import settings\nfrom ubireader.ubifs.defines import *\nfrom ubireader.ubifs import walk\nfrom ubireader.ubifs.misc import decompress\nfrom ubireader.debug import error, log, verbose_log\n\n\ndef extract_files(ubifs, out_path, perms=False):\n    \"\"\"Extract UBIFS contents to_path/\n\n    Arguments:\n    Obj:ubifs    -- UBIFS object.\n    Str:out_path  -- Path to extract contents to.\n    \"\"\"\n    try:\n        inodes = {}\n        bad_blocks = []\n\n        walk.index(ubifs, ubifs.master_node.root_lnum, ubifs.master_node.root_offs, inodes, bad_blocks)\n\n        if len(inodes) < 2:\n            raise Exception('No inodes found')\n\n        for dent in inodes[1]['dent']:\n            extract_dents(ubifs, inodes, dent, out_path, perms)\n\n        if len(bad_blocks):\n            error(extract_files, 'Warning', 'Data may be missing or corrupted, bad blocks, LEB [%s]' % ','.join(map(str, bad_blocks)))\n\n    except Exception as e:\n        error(extract_files, 'Error', '%s' % e)\n\n\ndef extract_dents(ubifs, inodes, dent_node, path='', perms=False):\n    if dent_node.inum not in inodes:\n        error(extract_dents, 'Error', 'inum: %s not found in inodes' % (dent_node.inum))\n        return\n\n    inode = inodes[dent_node.inum]\n    dent_path = os.path.join(path, dent_node.name)\n        \n    if dent_node.type == UBIFS_ITYPE_DIR:\n        try:\n            if not os.path.exists(dent_path):\n                os.mkdir(dent_path)\n                log(extract_dents, 'Make Dir: %s' % (dent_path))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'DIR Fail: %s' % e)\n\n        if 'dent' in inode:\n            for dnode in inode['dent']:\n                extract_dents(ubifs, inodes, dnode, dent_path, perms)\n\n        _set_file_timestamps(dent_path, inode)\n\n    elif dent_node.type == UBIFS_ITYPE_REG:\n        try:\n            if inode['ino'].nlink > 1:\n                if 'hlink' not in inode:\n                    inode['hlink'] = dent_path\n                    buf = _process_reg_file(ubifs, inode, dent_path)\n                    _write_reg_file(dent_path, buf)\n                else:\n                    os.link(inode['hlink'], dent_path)\n                    log(extract_dents, 'Make Link: %s > %s' % (dent_path, inode['hlink']))\n            else:\n                buf = _process_reg_file(ubifs, inode, dent_path)\n                _write_reg_file(dent_path, buf)\n\n            _set_file_timestamps(dent_path, inode)\n\n            if perms:\n                _set_file_perms(dent_path, inode)\n\n        except Exception as e:\n            error(extract_dents, 'Warn', 'FILE Fail: %s' % e)\n\n    elif dent_node.type == UBIFS_ITYPE_LNK:\n        try:\n            # probably will need to decompress ino data if > UBIFS_MIN_COMPR_LEN\n            os.symlink('%s' % inode['ino'].data.decode('utf-8'), dent_path)\n            log(extract_dents, 'Make Symlink: %s > %s' % (dent_path, inode['ino'].data))\n\n        except Exception as e:\n            error(extract_dents, 'Warn', 'SYMLINK Fail: %s' % e) \n\n    elif dent_node.type in [UBIFS_ITYPE_BLK, UBIFS_ITYPE_CHR]:\n        try:\n            dev = struct.unpack('<II', inode['ino'].data)[0]\n            if not settings.use_dummy_devices:\n                os.mknod(dent_path, inode['ino'].mode, dev)\n                log(extract_dents, 'Make Device Node: %s' % (dent_path))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n            else:\n                log(extract_dents, 'Create dummy device.')\n                _write_reg_file(dent_path, str(dev))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n                \n        except Exception as e:\n            error(extract_dents, 'Warn', 'DEV Fail: %s' % e)\n\n    elif dent_node.type == UBIFS_ITYPE_FIFO:\n        try:\n            os.mkfifo(dent_path, inode['ino'].mode)\n            log(extract_dents, 'Make FIFO: %s' % (path))\n\n            if perms:\n                _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'FIFO Fail: %s : %s' % (dent_path, e))\n\n    elif dent_node.type == UBIFS_ITYPE_SOCK:\n        try:\n            if settings.use_dummy_socket_file:\n                _write_reg_file(dent_path, '')\n                if perms:\n                    _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'SOCK Fail: %s : %s' % (dent_path, e))\n\n\ndef _set_file_perms(path, inode):\n    os.chown(path, inode['ino'].uid, inode['ino'].gid)\n    os.chmod(path, inode['ino'].mode)\n    verbose_log(_set_file_perms, 'perms:%s, owner: %s.%s, path: %s' % (inode['ino'].mode, inode['ino'].uid, inode['ino'].gid, path))\n\ndef _set_file_timestamps(path, inode):\n    os.utime(path, (inode['ino'].atime_sec, inode['ino'].mtime_sec))\n    verbose_log(_set_file_timestamps, 'timestamps: access: %s, modify: %s, path: %s' % (inode['ino'].atime_sec, inode['ino'].mtime_sec, path))\n\ndef _write_reg_file(path, data):\n    with open(path, 'wb') as f:\n        f.write(data)\n    log(_write_reg_file, 'Make File: %s' % (path))\n\n\ndef _process_reg_file(ubifs, inode, path):\n    try:\n        buf = bytearray()\n        start_key = 0x00 | (UBIFS_DATA_KEY << UBIFS_S_KEY_BLOCK_BITS)\n        if 'data' in inode:\n            compr_type = 0\n            sorted_data = sorted(inode['data'], key=lambda x: x.key['khash'])\n            last_khash = start_key - 1 \n\n            for data in sorted_data:\n                # If data nodes are missing in sequence, fill in blanks\n                # with \\x00 * UBIFS_BLOCK_SIZE\n                if data.key['khash'] - last_khash != 1:\n                    while 1 != (data.key['khash'] - last_khash):\n                        buf += b'\\x00'*UBIFS_BLOCK_SIZE\n                        last_khash += 1\n\n                compr_type = data.compr_type\n                ubifs.file.seek(data.offset)\n                d = ubifs.file.read(data.compr_len)\n                buf += decompress(compr_type, data.size, d)\n                last_khash = data.key['khash']\n                verbose_log(_process_reg_file, 'ino num: %s, compression: %s, path: %s' % (inode['ino'].key['ino_num'], compr_type, path))\n\n    except Exception as e:\n        error(_process_reg_file, 'Warn', 'inode num:%s :%s' % (inode['ino'].key['ino_num'], e))\n    \n    # Pad end of file with \\x00 if needed.\n    if inode['ino'].size > len(buf):\n        buf += b'\\x00' * (inode['ino'].size - len(buf))\n        \n    return bytes(buf)\n"], "fixing_code": ["#!/usr/bin/env python\n#############################################################\n# ubi_reader/ubifs\n# (c) 2013 Jason Pruitt (jrspruitt@gmail.com)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#############################################################\n\nimport os\nimport struct\n\nfrom ubireader import settings\nfrom ubireader.ubifs.defines import *\nfrom ubireader.ubifs import walk\nfrom ubireader.ubifs.misc import decompress\nfrom ubireader.debug import error, log, verbose_log\n\ndef is_safe_path(basedir, path):\n    basedir = os.path.realpath(basedir)\n    path = os.path.realpath(os.path.join(basedir, path))\n    return basedir == os.path.commonpath((basedir, path))\n\ndef extract_files(ubifs, out_path, perms=False):\n    \"\"\"Extract UBIFS contents to_path/\n\n    Arguments:\n    Obj:ubifs    -- UBIFS object.\n    Str:out_path  -- Path to extract contents to.\n    \"\"\"\n    try:\n        inodes = {}\n        bad_blocks = []\n\n        walk.index(ubifs, ubifs.master_node.root_lnum, ubifs.master_node.root_offs, inodes, bad_blocks)\n\n        if len(inodes) < 2:\n            raise Exception('No inodes found')\n\n        for dent in inodes[1]['dent']:\n            extract_dents(ubifs, inodes, dent, out_path, perms)\n\n        if len(bad_blocks):\n            error(extract_files, 'Warning', 'Data may be missing or corrupted, bad blocks, LEB [%s]' % ','.join(map(str, bad_blocks)))\n\n    except Exception as e:\n        error(extract_files, 'Error', '%s' % e)\n\n\ndef extract_dents(ubifs, inodes, dent_node, path='', perms=False):\n    if dent_node.inum not in inodes:\n        error(extract_dents, 'Error', 'inum: %s not found in inodes' % (dent_node.inum))\n        return\n\n    inode = inodes[dent_node.inum]\n\n    if not is_safe_path(path, dent_node.name):\n        error(extract_dents, 'Warning', 'Path traversal attempt: %s, discarding' % (dent_node.name))\n        return\n    dent_path = os.path.realpath(os.path.join(path, dent_node.name))\n\n    if dent_node.type == UBIFS_ITYPE_DIR:\n        try:\n            if not os.path.exists(dent_path):\n                os.mkdir(dent_path)\n                log(extract_dents, 'Make Dir: %s' % (dent_path))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'DIR Fail: %s' % e)\n\n        if 'dent' in inode:\n            for dnode in inode['dent']:\n                extract_dents(ubifs, inodes, dnode, dent_path, perms)\n\n        _set_file_timestamps(dent_path, inode)\n\n    elif dent_node.type == UBIFS_ITYPE_REG:\n        try:\n            if inode['ino'].nlink > 1:\n                if 'hlink' not in inode:\n                    inode['hlink'] = dent_path\n                    buf = _process_reg_file(ubifs, inode, dent_path)\n                    _write_reg_file(dent_path, buf)\n                else:\n                    os.link(inode['hlink'], dent_path)\n                    log(extract_dents, 'Make Link: %s > %s' % (dent_path, inode['hlink']))\n            else:\n                buf = _process_reg_file(ubifs, inode, dent_path)\n                _write_reg_file(dent_path, buf)\n\n            _set_file_timestamps(dent_path, inode)\n\n            if perms:\n                _set_file_perms(dent_path, inode)\n\n        except Exception as e:\n            error(extract_dents, 'Warn', 'FILE Fail: %s' % e)\n\n    elif dent_node.type == UBIFS_ITYPE_LNK:\n        try:\n            # probably will need to decompress ino data if > UBIFS_MIN_COMPR_LEN\n            os.symlink('%s' % inode['ino'].data.decode('utf-8'), dent_path)\n            log(extract_dents, 'Make Symlink: %s > %s' % (dent_path, inode['ino'].data))\n\n        except Exception as e:\n            error(extract_dents, 'Warn', 'SYMLINK Fail: %s' % e) \n\n    elif dent_node.type in [UBIFS_ITYPE_BLK, UBIFS_ITYPE_CHR]:\n        try:\n            dev = struct.unpack('<II', inode['ino'].data)[0]\n            if not settings.use_dummy_devices:\n                os.mknod(dent_path, inode['ino'].mode, dev)\n                log(extract_dents, 'Make Device Node: %s' % (dent_path))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n            else:\n                log(extract_dents, 'Create dummy device.')\n                _write_reg_file(dent_path, str(dev))\n\n                if perms:\n                    _set_file_perms(dent_path, inode)\n                \n        except Exception as e:\n            error(extract_dents, 'Warn', 'DEV Fail: %s' % e)\n\n    elif dent_node.type == UBIFS_ITYPE_FIFO:\n        try:\n            os.mkfifo(dent_path, inode['ino'].mode)\n            log(extract_dents, 'Make FIFO: %s' % (path))\n\n            if perms:\n                _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'FIFO Fail: %s : %s' % (dent_path, e))\n\n    elif dent_node.type == UBIFS_ITYPE_SOCK:\n        try:\n            if settings.use_dummy_socket_file:\n                _write_reg_file(dent_path, '')\n                if perms:\n                    _set_file_perms(dent_path, inode)\n        except Exception as e:\n            error(extract_dents, 'Warn', 'SOCK Fail: %s : %s' % (dent_path, e))\n\n\ndef _set_file_perms(path, inode):\n    os.chown(path, inode['ino'].uid, inode['ino'].gid)\n    os.chmod(path, inode['ino'].mode)\n    verbose_log(_set_file_perms, 'perms:%s, owner: %s.%s, path: %s' % (inode['ino'].mode, inode['ino'].uid, inode['ino'].gid, path))\n\ndef _set_file_timestamps(path, inode):\n    os.utime(path, (inode['ino'].atime_sec, inode['ino'].mtime_sec))\n    verbose_log(_set_file_timestamps, 'timestamps: access: %s, modify: %s, path: %s' % (inode['ino'].atime_sec, inode['ino'].mtime_sec, path))\n\ndef _write_reg_file(path, data):\n    with open(path, 'wb') as f:\n        f.write(data)\n    log(_write_reg_file, 'Make File: %s' % (path))\n\n\ndef _process_reg_file(ubifs, inode, path):\n    try:\n        buf = bytearray()\n        start_key = 0x00 | (UBIFS_DATA_KEY << UBIFS_S_KEY_BLOCK_BITS)\n        if 'data' in inode:\n            compr_type = 0\n            sorted_data = sorted(inode['data'], key=lambda x: x.key['khash'])\n            last_khash = start_key - 1 \n\n            for data in sorted_data:\n                # If data nodes are missing in sequence, fill in blanks\n                # with \\x00 * UBIFS_BLOCK_SIZE\n                if data.key['khash'] - last_khash != 1:\n                    while 1 != (data.key['khash'] - last_khash):\n                        buf += b'\\x00'*UBIFS_BLOCK_SIZE\n                        last_khash += 1\n\n                compr_type = data.compr_type\n                ubifs.file.seek(data.offset)\n                d = ubifs.file.read(data.compr_len)\n                buf += decompress(compr_type, data.size, d)\n                last_khash = data.key['khash']\n                verbose_log(_process_reg_file, 'ino num: %s, compression: %s, path: %s' % (inode['ino'].key['ino_num'], compr_type, path))\n\n    except Exception as e:\n        error(_process_reg_file, 'Warn', 'inode num:%s :%s' % (inode['ino'].key['ino_num'], e))\n    \n    # Pad end of file with \\x00 if needed.\n    if inode['ino'].size > len(buf):\n        buf += b'\\x00' * (inode['ino'].size - len(buf))\n        \n    return bytes(buf)\n"], "filenames": ["ubireader/ubifs/output.py"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [64], "fixing_code_start_loc": [29], "fixing_code_end_loc": [72], "type": "CWE-22", "message": "A vulnerability, which was classified as problematic, has been found in UBI Reader up to 0.8.0. Affected by this issue is the function ubireader_extract_files of the file ubireader/ubifs/output.py of the component UBIFS File Handler. The manipulation leads to path traversal. The attack may be launched remotely. Upgrading to version 0.8.5 is able to address this issue. The name of the patch is d5d68e6b1b9f7070c29df5f67fc060f579ae9139. It is recommended to upgrade the affected component. VDB-216146 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4572", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-17T02:15:07.530", "lastModified": "2022-12-22T14:47:17.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, has been found in UBI Reader up to 0.8.0. Affected by this issue is the function ubireader_extract_files of the file ubireader/ubifs/output.py of the component UBIFS File Handler. The manipulation leads to path traversal. The attack may be launched remotely. Upgrading to version 0.8.5 is able to address this issue. The name of the patch is d5d68e6b1b9f7070c29df5f67fc060f579ae9139. It is recommended to upgrade the affected component. VDB-216146 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ubi_reader_project:ubi_reader:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.0", "matchCriteriaId": "CE2F5410-A8C9-4360-A48E-5AEB04B64A4B"}]}]}], "references": [{"url": "https://github.com/jrspruitt/ubi_reader/commit/d5d68e6b1b9f7070c29df5f67fc060f579ae9139", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jrspruitt/ubi_reader/pull/57", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/jrspruitt/ubi_reader/releases/tag/v0.8.5-master", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216146", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jrspruitt/ubi_reader/commit/d5d68e6b1b9f7070c29df5f67fc060f579ae9139"}}