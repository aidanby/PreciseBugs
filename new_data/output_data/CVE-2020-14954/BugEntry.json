{"buggy_code": ["/**\n * @file\n * Low-level socket handling\n *\n * @authors\n * Copyright (C) 1998,2000 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2006,2008 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 1999-2000 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page conn_socket Low-level socket handling\n *\n * Low-level socket handling\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <string.h>\n#include <time.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"socket.h\"\n#include \"conn_globals.h\"\n#include \"connaccount.h\"\n#include \"connection.h\"\n#include \"protos.h\"\n#include \"ssl.h\"\n\n/**\n * socket_preconnect - Execute a command before opening a socket\n * @retval 0  Success\n * @retval >0 An errno, e.g. EPERM\n */\nstatic int socket_preconnect(void)\n{\n  if (!C_Preconnect)\n    return 0;\n\n  mutt_debug(LL_DEBUG2, \"Executing preconnect: %s\\n\", C_Preconnect);\n  const int rc = mutt_system(C_Preconnect);\n  mutt_debug(LL_DEBUG2, \"Preconnect result: %d\\n\", rc);\n  if (rc != 0)\n  {\n    const int save_errno = errno;\n    mutt_perror(_(\"Preconnect command failed\"));\n\n    return save_errno;\n  }\n\n  return 0;\n}\n\n/**\n * mutt_socket_open - Simple wrapper\n * @param conn Connection to a server\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_socket_open(struct Connection *conn)\n{\n  int rc;\n\n  if (socket_preconnect())\n    return -1;\n\n  rc = conn->open(conn);\n\n  mutt_debug(LL_DEBUG2, \"Connected to %s:%d on fd=%d\\n\", conn->account.host,\n             conn->account.port, conn->fd);\n\n  return rc;\n}\n\n/**\n * mutt_socket_close - Close a socket\n * @param conn Connection to a server\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_socket_close(struct Connection *conn)\n{\n  if (!conn)\n    return 0;\n\n  int rc = -1;\n\n  if (conn->fd < 0)\n    mutt_debug(LL_DEBUG1, \"Attempt to close closed connection\\n\");\n  else\n    rc = conn->close(conn);\n\n  conn->fd = -1;\n  conn->ssf = 0;\n  conn->bufpos = 0;\n  conn->available = 0;\n\n  return rc;\n}\n\n/**\n * mutt_socket_read - read from a Connection\n * @param conn Connection a server\n * @param buf Buffer to store read data\n * @param len length of the buffer\n * @retval >0 Success, number of bytes read\n * @retval -1 Error, see errno\n */\nint mutt_socket_read(struct Connection *conn, char *buf, size_t len)\n{\n  return conn->read(conn, buf, len);\n}\n\n/**\n * mutt_socket_write - write to a Connection\n * @param conn Connection to a server\n * @param buf Buffer with data to write\n * @param len Length of data to write\n * @retval >0 Number of bytes written\n * @retval -1 Error\n */\nint mutt_socket_write(struct Connection *conn, const char *buf, size_t len)\n{\n  return conn->write(conn, buf, len);\n}\n\n/**\n * mutt_socket_write_d - Write data to a socket\n * @param conn Connection to a server\n * @param buf Buffer with data to write\n * @param len Length of data to write\n * @param dbg Debug level for logging\n * @retval >0 Number of bytes written\n * @retval -1 Error\n */\nint mutt_socket_write_d(struct Connection *conn, const char *buf, int len, int dbg)\n{\n  int sent = 0;\n\n  mutt_debug(dbg, \"%d> %s\", conn->fd, buf);\n\n  if (conn->fd < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"attempt to write to closed connection\\n\");\n    return -1;\n  }\n\n  while (sent < len)\n  {\n    const int rc = conn->write(conn, buf + sent, len - sent);\n    if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"error writing (%s), closing socket\\n\", strerror(errno));\n      mutt_socket_close(conn);\n\n      return -1;\n    }\n\n    if (rc < len - sent)\n      mutt_debug(LL_DEBUG3, \"short write (%d of %d bytes)\\n\", rc, len - sent);\n\n    sent += rc;\n  }\n\n  return sent;\n}\n\n/**\n * mutt_socket_poll - Checks whether reads would block\n * @param conn Connection to a server\n * @param wait_secs How long to wait for a response\n * @retval >0 There is data to read\n * @retval  0 Read would block\n * @retval -1 Connection doesn't support polling\n */\nint mutt_socket_poll(struct Connection *conn, time_t wait_secs)\n{\n  if (conn->bufpos < conn->available)\n    return conn->available - conn->bufpos;\n\n  if (conn->poll)\n    return conn->poll(conn, wait_secs);\n\n  return -1;\n}\n\n/**\n * mutt_socket_readchar - simple read buffering to speed things up\n * @param[in]  conn Connection to a server\n * @param[out] c    Character that was read\n * @retval  1 Success\n * @retval -1 Error\n */\nint mutt_socket_readchar(struct Connection *conn, char *c)\n{\n  if (conn->bufpos >= conn->available)\n  {\n    if (conn->fd >= 0)\n      conn->available = conn->read(conn, conn->inbuf, sizeof(conn->inbuf));\n    else\n    {\n      mutt_debug(LL_DEBUG1, \"attempt to read from closed connection\\n\");\n      return -1;\n    }\n    conn->bufpos = 0;\n    if (conn->available == 0)\n    {\n      mutt_error(_(\"Connection to %s closed\"), conn->account.host);\n    }\n    if (conn->available <= 0)\n    {\n      mutt_socket_close(conn);\n      return -1;\n    }\n  }\n  *c = conn->inbuf[conn->bufpos];\n  conn->bufpos++;\n  return 1;\n}\n\n/**\n * mutt_socket_readln_d - Read a line from a socket\n * @param buf    Buffer to store the line\n * @param buflen Length of data to write\n * @param conn   Connection to a server\n * @param dbg    Debug level for logging\n * @retval >0 Success, number of bytes read\n * @retval -1 Error\n */\nint mutt_socket_readln_d(char *buf, size_t buflen, struct Connection *conn, int dbg)\n{\n  char ch;\n  int i;\n\n  for (i = 0; i < buflen - 1; i++)\n  {\n    if (mutt_socket_readchar(conn, &ch) != 1)\n    {\n      buf[i] = '\\0';\n      return -1;\n    }\n\n    if (ch == '\\n')\n      break;\n    buf[i] = ch;\n  }\n\n  /* strip \\r from \\r\\n termination */\n  if (i && (buf[i - 1] == '\\r'))\n    i--;\n  buf[i] = '\\0';\n\n  mutt_debug(dbg, \"%d< %s\\n\", conn->fd, buf);\n\n  /* number of bytes read, not strlen */\n  return i + 1;\n}\n\n/**\n * mutt_socket_new - allocate and initialise a new connection\n * @param type Type of the new Connection\n * @retval ptr New Connection\n */\nstruct Connection *mutt_socket_new(enum ConnectionType type)\n{\n  struct Connection *conn = mutt_mem_calloc(1, sizeof(struct Connection));\n  conn->fd = -1;\n\n  if (type == MUTT_CONNECTION_TUNNEL)\n  {\n    mutt_tunnel_socket_setup(conn);\n  }\n  else if (type == MUTT_CONNECTION_SSL)\n  {\n    int rc = mutt_ssl_socket_setup(conn);\n    if (rc < 0)\n      FREE(&conn);\n  }\n  else\n  {\n    conn->read = raw_socket_read;\n    conn->write = raw_socket_write;\n    conn->open = raw_socket_open;\n    conn->close = raw_socket_close;\n    conn->poll = raw_socket_poll;\n  }\n\n  return conn;\n}\n", "/**\n * @file\n * Low-level socket handling\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2005 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_CONN_SOCKET_H\n#define MUTT_CONN_SOCKET_H\n\n#include <time.h>\n\nstruct Connection;\n\n/**\n * enum ConnectionType - Type of connection\n */\nenum ConnectionType\n{\n  MUTT_CONNECTION_SIMPLE, ///< Simple TCP socket connection\n  MUTT_CONNECTION_TUNNEL, ///< Tunnelled connection\n  MUTT_CONNECTION_SSL,    ///< SSL/TLS-encrypted connection\n};\n\nint                mutt_socket_close   (struct Connection *conn);\nstruct Connection *mutt_socket_new     (enum ConnectionType type);\nint                mutt_socket_open    (struct Connection *conn);\nint                mutt_socket_poll    (struct Connection *conn, time_t wait_secs);\nint                mutt_socket_read    (struct Connection *conn, char *buf, size_t len);\nint                mutt_socket_readchar(struct Connection *conn, char *c);\nint                mutt_socket_readln_d(char *buf, size_t buflen, struct Connection *conn, int dbg);\nint                mutt_socket_write   (struct Connection *conn, const char *buf, size_t len);\nint                mutt_socket_write_d (struct Connection *conn, const char *buf, int len, int dbg);\n\n#endif /* MUTT_CONN_SOCKET_H */\n", "/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"globals.h\"\n#include \"init.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n\n/* These Config Variables are only used in imap/command.c */\nbool C_ImapServernoise; ///< Config: (imap) Display server warnings as error messages\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",\n  \"IMAP4rev1\",\n  \"STATUS\",\n  \"ACL\",\n  \"NAMESPACE\",\n  \"AUTH=CRAM-MD5\",\n  \"AUTH=GSSAPI\",\n  \"AUTH=ANONYMOUS\",\n  \"AUTH=OAUTHBEARER\",\n  \"STARTTLS\",\n  \"LOGINDISABLED\",\n  \"IDLE\",\n  \"SASL-IR\",\n  \"ENABLE\",\n  \"CONDSTORE\",\n  \"QRESYNC\",\n  \"LIST-EXTENDED\",\n  \"COMPRESS=DEFLATE\",\n  \"X-GM-EXT-1\",\n  NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param adata Imap Account data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapAccountData *adata)\n{\n  if (((adata->nextcmd + 1) % adata->cmdslots) == adata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param adata Imap Account data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapAccountData *adata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(adata))\n  {\n    mutt_debug(LL_DEBUG3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = adata->cmds + adata->nextcmd;\n  adata->nextcmd = (adata->nextcmd + 1) % adata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"%c%04u\", adata->seqid, adata->seqno++);\n  if (adata->seqno > 9999)\n    adata->seqno = 0;\n\n  cmd->state = IMAP_RES_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param adata Imap Account data\n * @param cmdstr Command string\n * @param flags  Server flags, see #ImapCmdFlags\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  if (cmd_queue_full(adata))\n  {\n    mutt_debug(LL_DEBUG3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(adata, NULL, flags & IMAP_CMD_POLL);\n\n    if (rc == IMAP_EXEC_ERROR)\n      return IMAP_RES_BAD;\n  }\n\n  struct ImapCommand *cmd = cmd_new(adata);\n  if (!cmd)\n    return IMAP_RES_BAD;\n\n  if (mutt_buffer_add_printf(&adata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_RES_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapAccountData is in fatal state, do what we can\n * @param adata Imap Account data\n */\nstatic void cmd_handle_fatal(struct ImapAccountData *adata)\n{\n  adata->status = IMAP_FATAL;\n\n  if (!adata->mailbox)\n    return;\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  if ((adata->state >= IMAP_SELECTED) && (mdata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(adata->mailbox);\n    mutt_socket_close(adata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), adata->conn->account.user,\n               adata->conn->account.host);\n    adata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(adata);\n  if (!adata->recovering)\n  {\n    adata->recovering = true;\n    if (imap_login(adata))\n      mutt_clear_error();\n    adata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param adata Imap Account data\n * @param cmdstr Command string\n * @param flags  Command flags, see #ImapCmdFlags\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nstatic int cmd_start(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(adata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (mutt_buffer_is_empty(&adata->cmdbuf))\n    return IMAP_RES_BAD;\n\n  rc = mutt_socket_send_d(adata->conn, adata->cmdbuf.data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  mutt_buffer_reset(&adata->cmdbuf);\n\n  /* unidle when command queue is flushed */\n  if (adata->state == IMAP_IDLE)\n    adata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_RES_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_startswith(s, \"OK\", CASE_IGNORE))\n    return IMAP_RES_OK;\n  if (mutt_str_startswith(s, \"NO\", CASE_IGNORE))\n    return IMAP_RES_NO;\n\n  return IMAP_RES_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param adata Imap Account data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark adata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapAccountData *adata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Email *e = NULL;\n\n  mutt_debug(LL_DEBUG2, \"Handling EXPUNGE\\n\");\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  if ((mutt_str_atoui(s, &exp_msn) < 0) || (exp_msn < 1) || (exp_msn > mdata->max_msn))\n    return;\n\n  e = mdata->msn_index[exp_msn - 1];\n  if (e)\n  {\n    /* imap_expunge_mailbox() will rewrite e->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    e->index = INT_MAX;\n    imap_edata_get(e)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)\n  {\n    e = mdata->msn_index[cur];\n    if (e)\n      imap_edata_get(e)->msn--;\n    mdata->msn_index[cur - 1] = e;\n  }\n\n  mdata->msn_index[mdata->max_msn - 1] = NULL;\n  mdata->max_msn--;\n\n  mdata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_vanished - Parse vanished command\n * @param adata Imap Account data\n * @param s     String containing MSN of message to expunge\n *\n * Handle VANISHED (RFC7162), which is like expunge, but passes a seqset of UIDs.\n * An optional (EARLIER) argument specifies not to decrement subsequent MSNs.\n */\nstatic void cmd_parse_vanished(struct ImapAccountData *adata, char *s)\n{\n  bool earlier = false;\n  int rc;\n  unsigned int uid = 0;\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  mutt_debug(LL_DEBUG2, \"Handling VANISHED\\n\");\n\n  if (mutt_str_startswith(s, \"(EARLIER)\", CASE_IGNORE))\n  {\n    /* The RFC says we should not decrement msns with the VANISHED EARLIER tag.\n     * My experimentation says that's crap. */\n    earlier = true;\n    s = imap_next_word(s);\n  }\n\n  char *end_of_seqset = s;\n  while (*end_of_seqset)\n  {\n    if (!strchr(\"0123456789:,\", *end_of_seqset))\n      *end_of_seqset = '\\0';\n    else\n      end_of_seqset++;\n  }\n\n  struct SeqsetIterator *iter = mutt_seqset_iterator_new(s);\n  if (!iter)\n  {\n    mutt_debug(LL_DEBUG2, \"VANISHED: empty seqset [%s]?\\n\", s);\n    return;\n  }\n\n  while ((rc = mutt_seqset_iterator_next(iter, &uid)) == 0)\n  {\n    struct Email *e = mutt_hash_int_find(mdata->uid_hash, uid);\n    if (!e)\n      continue;\n\n    unsigned int exp_msn = imap_edata_get(e)->msn;\n\n    /* imap_expunge_mailbox() will rewrite e->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    e->index = INT_MAX;\n    imap_edata_get(e)->msn = 0;\n\n    if ((exp_msn < 1) || (exp_msn > mdata->max_msn))\n    {\n      mutt_debug(LL_DEBUG1, \"VANISHED: msn for UID %u is incorrect\\n\", uid);\n      continue;\n    }\n    if (mdata->msn_index[exp_msn - 1] != e)\n    {\n      mutt_debug(LL_DEBUG1, \"VANISHED: msn_index for UID %u is incorrect\\n\", uid);\n      continue;\n    }\n\n    mdata->msn_index[exp_msn - 1] = NULL;\n\n    if (!earlier)\n    {\n      /* decrement seqno of those above. */\n      for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)\n      {\n        e = mdata->msn_index[cur];\n        if (e)\n          imap_edata_get(e)->msn--;\n        mdata->msn_index[cur - 1] = e;\n      }\n\n      mdata->msn_index[mdata->max_msn - 1] = NULL;\n      mdata->max_msn--;\n    }\n  }\n\n  if (rc < 0)\n    mutt_debug(LL_DEBUG1, \"VANISHED: illegal seqset %s\\n\", s);\n\n  mdata->reopen |= IMAP_EXPUNGE_PENDING;\n\n  mutt_seqset_iterator_free(&iter);\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapAccountData\n * @param adata Imap Account data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapAccountData *adata, char *s)\n{\n  unsigned int msn, uid;\n  struct Email *e = NULL;\n  char *flags = NULL;\n  int uid_checked = 0;\n  bool server_changes = false;\n\n  struct ImapMboxData *mdata = imap_mdata_get(adata->mailbox);\n\n  mutt_debug(LL_DEBUG3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0)\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - illegal MSN\\n\");\n    return;\n  }\n\n  if ((msn < 1) || (msn > mdata->max_msn))\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - MSN %u out of range\\n\", msn);\n    return;\n  }\n\n  e = mdata->msn_index[msn - 1];\n  if (!e || !e->active)\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - MSN %u not in msn_index\\n\", msn);\n    return;\n  }\n\n  mutt_debug(LL_DEBUG2, \"Message UID %u updated\\n\", imap_edata_get(e)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n    size_t plen = mutt_str_startswith(s, \"FLAGS\", CASE_IGNORE);\n    if (plen != 0)\n    {\n      flags = s;\n      if (uid_checked)\n        break;\n\n      s += plen;\n      SKIPWS(s);\n      if (*s != '(')\n      {\n        mutt_debug(LL_DEBUG1, \"bogus FLAGS response: %s\\n\", s);\n        return;\n      }\n      s++;\n      while (*s && (*s != ')'))\n        s++;\n      if (*s == ')')\n        s++;\n      else\n      {\n        mutt_debug(LL_DEBUG1, \"Unterminated FLAGS response: %s\\n\", s);\n        return;\n      }\n    }\n    else if ((plen = mutt_str_startswith(s, \"UID\", CASE_IGNORE)))\n    {\n      s += plen;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(LL_DEBUG1, \"Illegal UID.  Skipping update\\n\");\n        return;\n      }\n      if (uid != imap_edata_get(e)->uid)\n      {\n        mutt_debug(LL_DEBUG1, \"UID vs MSN mismatch.  Skipping update\\n\");\n        return;\n      }\n      uid_checked = 1;\n      if (flags)\n        break;\n      s = imap_next_word(s);\n    }\n    else if ((plen = mutt_str_startswith(s, \"MODSEQ\", CASE_IGNORE)))\n    {\n      s += plen;\n      SKIPWS(s);\n      if (*s != '(')\n      {\n        mutt_debug(LL_DEBUG1, \"bogus MODSEQ response: %s\\n\", s);\n        return;\n      }\n      s++;\n      while (*s && (*s != ')'))\n        s++;\n      if (*s == ')')\n        s++;\n      else\n      {\n        mutt_debug(LL_DEBUG1, \"Unterminated MODSEQ response: %s\\n\", s);\n        return;\n      }\n    }\n    else if (*s == ')')\n      break; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(LL_DEBUG2, \"Only handle FLAGS updates\\n\");\n      break;\n    }\n  }\n\n  if (flags)\n  {\n    imap_set_flags(adata->mailbox, e, flags, &server_changes);\n    if (server_changes)\n    {\n      /* If server flags could conflict with NeoMutt's flags, reopen the mailbox. */\n      if (e->changed)\n        mdata->reopen |= IMAP_EXPUNGE_PENDING;\n      else\n        mdata->check_status |= IMAP_FLAGS_PENDING;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param adata Imap Account data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapAccountData *adata, char *s)\n{\n  mutt_debug(LL_DEBUG3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&adata->capstr);\n  adata->capstr = mutt_str_strdup(s);\n  adata->capabilities = 0;\n\n  while (*s)\n  {\n    for (size_t i = 0; Capabilities[i]; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        adata->capabilities |= (1 << i);\n        mutt_debug(LL_DEBUG3, \" Found capability \\\"%s\\\": %lu\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param adata Imap Account data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapAccountData *adata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb = { 0 };\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (adata->cmdresult)\n    list = adata->cmdresult;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_startswith(s, \"\\\\NoSelect\", CASE_IGNORE))\n      list->noselect = true;\n    else if (mutt_str_startswith(s, \"\\\\NonExistent\", CASE_IGNORE)) /* rfc5258 */\n      list->noselect = true;\n    else if (mutt_str_startswith(s, \"\\\\NoInferiors\", CASE_IGNORE))\n      list->noinferiors = true;\n    else if (mutt_str_startswith(s, \"\\\\HasNoChildren\", CASE_IGNORE)) /* rfc5258*/\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (!mutt_str_startswith(s, \"NIL\", CASE_IGNORE))\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n    {\n      adata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(adata->buf) < litlen)\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing LIST mailbox\\n\");\n      return;\n    }\n\n    list->name = adata->buf;\n    s = list->name + litlen;\n    if (s[0] != '\\0')\n    {\n      s[0] = '\\0';\n      s++;\n      SKIPWS(s);\n    }\n  }\n  else\n  {\n    list->name = s;\n    /* Exclude rfc5258 RECURSIVEMATCH CHILDINFO suffix */\n    s = imap_next_word(s);\n    if (s[0] != '\\0')\n      s[-1] = '\\0';\n    imap_unmunge_mbox_name(adata->unicode, list->name);\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    adata->delim = list->delim;\n    mutt_debug(LL_DEBUG3, \"Root delimiter: %c\\n\", adata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param adata Imap Account data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapAccountData *adata, char *s)\n{\n  char buf[256];\n  char quoted_name[256];\n  struct Buffer err;\n  struct Url url = { 0 };\n  struct ImapList list = { 0 };\n\n  if (adata->cmdresult)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(adata, s);\n    return;\n  }\n\n  if (!C_ImapCheckSubscribed)\n    return;\n\n  adata->cmdresult = &list;\n  cmd_parse_list(adata, s);\n  adata->cmdresult = NULL;\n  /* noselect is for a gmail quirk */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(LL_DEBUG3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&adata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(quoted_name, sizeof(quoted_name), list.name, true);\n  url.path = quoted_name + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, C_ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&err);\n  err.dsize = 256;\n  err.data = mutt_mem_malloc(err.dsize);\n  if (mutt_parse_rc_line(buf, &err))\n    mutt_debug(LL_DEBUG1, \"Error adding subscribed mailbox: %s\\n\", err.data);\n  FREE(&err.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param adata Imap Account data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapAccountData *adata, const char *s)\n{\n  mutt_debug(LL_DEBUG2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  adata->mailbox->rights = 0;\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        adata->mailbox->rights |= MUTT_ACL_ADMIN;\n        break;\n      case 'e':\n        adata->mailbox->rights |= MUTT_ACL_EXPUNGE;\n        break;\n      case 'i':\n        adata->mailbox->rights |= MUTT_ACL_INSERT;\n        break;\n      case 'k':\n        adata->mailbox->rights |= MUTT_ACL_CREATE;\n        break;\n      case 'l':\n        adata->mailbox->rights |= MUTT_ACL_LOOKUP;\n        break;\n      case 'p':\n        adata->mailbox->rights |= MUTT_ACL_POST;\n        break;\n      case 'r':\n        adata->mailbox->rights |= MUTT_ACL_READ;\n        break;\n      case 's':\n        adata->mailbox->rights |= MUTT_ACL_SEEN;\n        break;\n      case 't':\n        adata->mailbox->rights |= MUTT_ACL_DELETE;\n        break;\n      case 'w':\n        adata->mailbox->rights |= MUTT_ACL_WRITE;\n        break;\n      case 'x':\n        adata->mailbox->rights |= MUTT_ACL_DELMX;\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        adata->mailbox->rights |= MUTT_ACL_CREATE | MUTT_ACL_DELMX;\n        break;\n      case 'd':\n        adata->mailbox->rights |= MUTT_ACL_DELETE | MUTT_ACL_EXPUNGE;\n        break;\n      default:\n        mutt_debug(LL_DEBUG1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * find_mailbox - Find a Mailbox by its name\n * @param adata Imap Account data\n * @param name  Mailbox to find\n * @retval ptr Mailbox\n */\nstatic struct Mailbox *find_mailbox(struct ImapAccountData *adata, const char *name)\n{\n  if (!adata || !adata->account || !name)\n    return NULL;\n\n  struct MailboxNode *np = NULL;\n  STAILQ_FOREACH(np, &adata->account->mailboxes, entries)\n  {\n    struct ImapMboxData *mdata = imap_mdata_get(np->mailbox);\n    if (mutt_str_strcmp(name, mdata->name) == 0)\n      return np->mailbox;\n  }\n\n  return NULL;\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param adata Imap Account data\n * @param s     Command string with status info\n *\n * first cut: just do mailbox update. Later we may wish to cache all mailbox\n * information, even that not desired by mailbox\n */\nstatic void cmd_parse_status(struct ImapAccountData *adata, char *s)\n{\n  unsigned int litlen = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n    {\n      adata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(adata->buf) < litlen)\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing STATUS mailbox\\n\");\n      return;\n    }\n\n    mailbox = adata->buf;\n    s = mailbox + litlen;\n    s[0] = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    s[-1] = '\\0';\n    imap_unmunge_mbox_name(adata->unicode, mailbox);\n  }\n\n  struct Mailbox *m = find_mailbox(adata, mailbox);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!mdata)\n  {\n    mutt_debug(LL_DEBUG3, \"Received status for an unexpected mailbox: %s\\n\", mailbox);\n    return;\n  }\n  uint32_t olduv = mdata->uidvalidity;\n  unsigned int oldun = mdata->uid_next;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while ((s[0] != '\\0') && (s[0] != ')'))\n  {\n    char *value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_startswith(s, \"MESSAGES\", CASE_MATCH))\n      mdata->messages = count;\n    else if (mutt_str_startswith(s, \"RECENT\", CASE_MATCH))\n      mdata->recent = count;\n    else if (mutt_str_startswith(s, \"UIDNEXT\", CASE_MATCH))\n      mdata->uid_next = count;\n    else if (mutt_str_startswith(s, \"UIDVALIDITY\", CASE_MATCH))\n      mdata->uidvalidity = count;\n    else if (mutt_str_startswith(s, \"UNSEEN\", CASE_MATCH))\n      mdata->unseen = count;\n\n    s = value;\n    if ((s[0] != '\\0') && (*s != ')'))\n      s = imap_next_word(s);\n  }\n  mutt_debug(LL_DEBUG3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             mdata->name, mdata->uidvalidity, mdata->uid_next, mdata->messages,\n             mdata->recent, mdata->unseen);\n\n  mutt_debug(LL_DEBUG3, \"Running default STATUS handler\\n\");\n\n  mutt_debug(LL_DEBUG3, \"Found %s in mailbox list (OV: %u ON: %u U: %d)\\n\",\n             mailbox, olduv, oldun, mdata->unseen);\n\n  bool new_mail = false;\n  if (C_MailCheckRecent)\n  {\n    if ((olduv != 0) && (olduv == mdata->uidvalidity))\n    {\n      if (oldun < mdata->uid_next)\n        new_mail = (mdata->unseen > 0);\n    }\n    else if ((olduv == 0) && (oldun == 0))\n    {\n      /* first check per session, use recent. might need a flag for this. */\n      new_mail = (mdata->recent > 0);\n    }\n    else\n      new_mail = (mdata->unseen > 0);\n  }\n  else\n    new_mail = (mdata->unseen > 0);\n\n#ifdef USE_SIDEBAR\n  if ((m->has_new != new_mail) || (m->msg_count != mdata->messages) ||\n      (m->msg_unread != mdata->unseen))\n  {\n    mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n  }\n#endif\n\n  m->has_new = new_mail;\n  m->msg_count = mdata->messages;\n  m->msg_unread = mdata->unseen;\n\n  // force back to keep detecting new mail until the mailbox is opened\n  if (m->has_new)\n    mdata->uid_next = oldun;\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param adata Imap Account data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapAccountData *adata, const char *s)\n{\n  mutt_debug(LL_DEBUG2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && (*s != '\\0'))\n  {\n    if (mutt_str_startswith(s, \"UTF8=ACCEPT\", CASE_IGNORE) ||\n        mutt_str_startswith(s, \"UTF8=ONLY\", CASE_IGNORE))\n    {\n      adata->unicode = true;\n    }\n    if (mutt_str_startswith(s, \"QRESYNC\", CASE_IGNORE))\n      adata->qresync = true;\n  }\n}\n/**\n * cmd_parse_exists - Parse EXISTS message from serer\n * @param adata  Imap Account data\n * @param pn     String containing the total number of messages for the selected mailbox\n */\nstatic void cmd_parse_exists(struct ImapAccountData *adata, const char *pn)\n{\n  unsigned int count = 0;\n  mutt_debug(LL_DEBUG2, \"Handling EXISTS\\n\");\n\n  if (mutt_str_atoui(pn, &count) < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"Malformed EXISTS: '%s'\\n\", pn);\n    return;\n  }\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  /* new mail arrived */\n  if (count < mdata->max_msn)\n  {\n    /* Notes 6.0.3 has a tendency to report fewer messages exist than\n     * it should. */\n    mutt_debug(LL_DEBUG1, \"Message count is out of sync\\n\");\n  }\n  /* at least the InterChange server sends EXISTS messages freely,\n   * even when there is no new mail */\n  else if (count == mdata->max_msn)\n    mutt_debug(LL_DEBUG3, \"superfluous EXISTS message\\n\");\n  else\n  {\n    mutt_debug(LL_DEBUG2, \"New mail in %s - %d messages total\\n\", mdata->name, count);\n    mdata->reopen |= IMAP_NEWMAIL_PENDING;\n    mdata->new_mail_count = count;\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapAccountData *adata)\n{\n  char *s = imap_next_word(adata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((adata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    /* pn vs. s: need initial seqno */\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS, EXPUNGE, FETCH are always related to the SELECTED mailbox */\n    if (mutt_str_startswith(s, \"EXISTS\", CASE_IGNORE))\n      cmd_parse_exists(adata, pn);\n    else if (mutt_str_startswith(s, \"EXPUNGE\", CASE_IGNORE))\n      cmd_parse_expunge(adata, pn);\n    else if (mutt_str_startswith(s, \"FETCH\", CASE_IGNORE))\n      cmd_parse_fetch(adata, pn);\n  }\n  else if ((adata->state >= IMAP_SELECTED) && mutt_str_startswith(s, \"VANISHED\", CASE_IGNORE))\n    cmd_parse_vanished(adata, pn);\n  else if (mutt_str_startswith(s, \"CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, s);\n  else if (mutt_str_startswith(s, \"OK [CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, pn);\n  else if (mutt_str_startswith(pn, \"OK [CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, imap_next_word(pn));\n  else if (mutt_str_startswith(s, \"LIST\", CASE_IGNORE))\n    cmd_parse_list(adata, s);\n  else if (mutt_str_startswith(s, \"LSUB\", CASE_IGNORE))\n    cmd_parse_lsub(adata, s);\n  else if (mutt_str_startswith(s, \"MYRIGHTS\", CASE_IGNORE))\n    cmd_parse_myrights(adata, s);\n  else if (mutt_str_startswith(s, \"SEARCH\", CASE_IGNORE))\n    cmd_parse_search(adata, s);\n  else if (mutt_str_startswith(s, \"STATUS\", CASE_IGNORE))\n    cmd_parse_status(adata, s);\n  else if (mutt_str_startswith(s, \"ENABLED\", CASE_IGNORE))\n    cmd_parse_enabled(adata, s);\n  else if (mutt_str_startswith(s, \"BYE\", CASE_IGNORE))\n  {\n    mutt_debug(LL_DEBUG2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (adata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(adata);\n\n    return -1;\n  }\n  else if (C_ImapServernoise && mutt_str_startswith(s, \"NO\", CASE_IGNORE))\n  {\n    mutt_debug(LL_DEBUG2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 2);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param adata Imap Account data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr)\n{\n  return cmd_start(adata, cmdstr, IMAP_CMD_NO_FLAGS);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return -1;\n\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_RES_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == adata->blen)\n    {\n      mutt_mem_realloc(&adata->buf, adata->blen + IMAP_CMD_BUFSIZE);\n      adata->blen = adata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(LL_DEBUG3, \"grew buffer to %lu bytes\\n\", adata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln_d(adata->buf + len, adata->blen - len, adata->conn, MUTT_SOCK_LOG_FULL);\n    if (c <= 0)\n    {\n      mutt_debug(LL_DEBUG1, \"Error reading server response\\n\");\n      cmd_handle_fatal(adata);\n      return IMAP_RES_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == adata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((adata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&adata->buf, IMAP_CMD_BUFSIZE);\n    adata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(LL_DEBUG3, \"shrank buffer to %lu bytes\\n\", adata->blen);\n  }\n\n  adata->lastread = mutt_date_epoch();\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if ((mutt_str_startswith(adata->buf, \"* \", CASE_MATCH) ||\n       mutt_str_startswith(imap_next_word(adata->buf), \"OK [\", CASE_MATCH)) &&\n      cmd_handle_untagged(adata))\n  {\n    return IMAP_RES_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (adata->buf[0] == '+')\n    return IMAP_RES_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an adata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_RES_OK;\n  c = adata->lastcmd;\n  do\n  {\n    cmd = &adata->cmds[c];\n    if (cmd->state == IMAP_RES_NEW)\n    {\n      if (mutt_str_startswith(adata->buf, cmd->seq, CASE_MATCH))\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          adata->lastcmd = (adata->lastcmd + 1) % adata->cmdslots;\n        }\n        cmd->state = cmd_status(adata->buf);\n        rc = cmd->state;\n        if (cmd->state == IMAP_RES_NO || cmd->state == IMAP_RES_BAD)\n        {\n          mutt_message(_(\"IMAP command failed: %s\"), adata->buf);\n        }\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % adata->cmdslots;\n  } while (c != adata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_RES_CONTINUE;\n  else\n  {\n    mutt_debug(LL_DEBUG3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(adata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return cmd_status(s) == IMAP_RES_OK;\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param adata Imap Account data\n * @retval ptr Extra command information (pointer into adata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapAccountData *adata)\n{\n  static const char *notrailer = \"\";\n  const char *s = adata->buf;\n\n  if (!s)\n  {\n    mutt_debug(LL_DEBUG2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || (!mutt_str_startswith(s, \"OK\", CASE_IGNORE) &&\n             !mutt_str_startswith(s, \"NO\", CASE_IGNORE) &&\n             !mutt_str_startswith(s, \"BAD\", CASE_IGNORE)))\n  {\n    mutt_debug(LL_DEBUG2, \"not a command completion: %s\\n\", adata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param adata Imap Account data\n * @param cmdstr Command to execute\n * @param flags  Flags, see #ImapCmdFlags\n * @retval #IMAP_EXEC_SUCCESS Command successful or queued\n * @retval #IMAP_EXEC_ERROR   Command returned an error\n * @retval #IMAP_EXEC_FATAL   Imap connection failure\n *\n * Also, handle untagged responses.\n */\nint imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n\n  return IMAP_EXEC_SUCCESS;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param adata Imap Account data\n *\n * If a reopen is allowed, it attempts to perform cleanup (eg fetch new mail if\n * detected, do expunge). Called automatically by imap_cmd_step(), but may be\n * called at any time.\n *\n * mdata->check_status is set and will be used later by imap_check_mailbox().\n */\nvoid imap_cmd_finish(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    adata->closing = false;\n    cmd_handle_fatal(adata);\n    return;\n  }\n\n  if (!(adata->state >= IMAP_SELECTED) || (adata->mailbox && adata->closing))\n  {\n    adata->closing = false;\n    return;\n  }\n\n  adata->closing = false;\n\n  struct ImapMboxData *mdata = imap_mdata_get(adata->mailbox);\n\n  if (mdata && mdata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    // First remove expunged emails from the msn_index\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(LL_DEBUG2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(adata->mailbox);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if (!(mdata->reopen & IMAP_EXPUNGE_EXPECTED))\n        mdata->check_status |= IMAP_EXPUNGE_PENDING;\n      mdata->reopen &= ~(IMAP_EXPUNGE_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n\n    // Then add new emails to it\n    if (mdata->reopen & IMAP_NEWMAIL_PENDING && (mdata->new_mail_count > mdata->max_msn))\n    {\n      if (!(mdata->reopen & IMAP_EXPUNGE_PENDING))\n        mdata->check_status |= IMAP_NEWMAIL_PENDING;\n\n      mutt_debug(LL_DEBUG2, \"Fetching new mails from %d to %d\\n\",\n                 mdata->max_msn + 1, mdata->new_mail_count);\n      imap_read_headers(adata->mailbox, mdata->max_msn + 1, mdata->new_mail_count, false);\n    }\n\n    // And to finish inform about MUTT_REOPEN if needed\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING && !(mdata->reopen & IMAP_EXPUNGE_EXPECTED))\n      mdata->check_status |= IMAP_EXPUNGE_PENDING;\n\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING)\n      mdata->reopen &= ~(IMAP_EXPUNGE_PENDING | IMAP_EXPUNGE_EXPECTED);\n  }\n\n  adata->status = 0;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nint imap_cmd_idle(struct ImapAccountData *adata)\n{\n  int rc;\n\n  if (cmd_start(adata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  if ((C_ImapPollTimeout > 0) && ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  do\n  {\n    rc = imap_cmd_step(adata);\n  } while (rc == IMAP_RES_CONTINUE);\n\n  if (rc == IMAP_RES_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    adata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_addstr(&adata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_RES_OK;\n  }\n  if (rc != IMAP_RES_OK)\n  {\n    mutt_debug(LL_DEBUG1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n", "/**\n * @file\n * IMAP network mailbox\n *\n * @authors\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_imap IMAP network mailbox\n *\n * Support for IMAP4rev1, with the occasional nod to IMAP 4.\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"lib.h\"\n#include \"auth.h\"\n#include \"commands.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"init.h\"\n#include \"message.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"pattern.h\"\n#include \"progress.h\"\n#include \"sort.h\"\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\nstruct stat;\n\n/* These Config Variables are only used in imap/imap.c */\n#ifdef USE_ZLIB\nbool C_ImapDeflate; ///< Config: (imap) Compress network traffic\n#endif\nbool C_ImapIdle; ///< Config: (imap) Use the IMAP IDLE extension to check for new mail\nbool C_ImapRfc5161; ///< Config: (imap) Use the IMAP ENABLE extension to select capabilities\n\n/**\n * check_capabilities - Make sure we can log in to this server\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int check_capabilities(struct ImapAccountData *adata)\n{\n  if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    imap_error(\"check_capabilities\", adata->buf);\n    return -1;\n  }\n\n  if (!((adata->capabilities & IMAP_CAP_IMAP4) || (adata->capabilities & IMAP_CAP_IMAP4REV1)))\n  {\n    mutt_error(\n        _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * get_flags - Make a simple list out of a FLAGS response\n * @param hflags List to store flags\n * @param s      String containing flags\n * @retval ptr  End of the flags\n * @retval NULL Failure\n *\n * return stream following FLAGS response\n */\nstatic char *get_flags(struct ListHead *hflags, char *s)\n{\n  /* sanity-check string */\n  const size_t plen = mutt_str_startswith(s, \"FLAGS\", CASE_IGNORE);\n  if (plen == 0)\n  {\n    mutt_debug(LL_DEBUG1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += plen;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  /* update caller's flags handle */\n  while (*s && (*s != ')'))\n  {\n    s++;\n    SKIPWS(s);\n    const char *flag_word = s;\n    while (*s && (*s != ')') && !IS_SPACE(*s))\n      s++;\n    const char ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_list_insert_tail(hflags, mutt_str_strdup(flag_word));\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    mutt_debug(LL_DEBUG1, \"Unterminated FLAGS response: %s\\n\", s);\n    mutt_list_free(hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\n/**\n * set_flag - append str to flags if we currently have permission according to aclflag\n * @param[in]  m       Selected Imap Mailbox\n * @param[in]  aclflag Permissions, see #AclFlags\n * @param[in]  flag    Does the email have the flag set?\n * @param[in]  str     Server flag name\n * @param[out] flags   Buffer for server command\n * @param[in]  flsize  Length of buffer\n */\nstatic void set_flag(struct Mailbox *m, AclFlags aclflag, int flag,\n                     const char *str, char *flags, size_t flsize)\n{\n  if (m->rights & aclflag)\n    if (flag && imap_has_flag(&imap_mdata_get(m)->flags, str))\n      mutt_str_strcat(flags, flsize, str);\n}\n\n/**\n * make_msg_set - Make a message set\n * @param[in]  m       Selected Imap Mailbox\n * @param[in]  buf     Buffer to store message set\n * @param[in]  flag    Flags to match, e.g. #MUTT_DELETED\n * @param[in]  changed Matched messages that have been altered\n * @param[in]  invert  Flag matches should be inverted\n * @param[out] pos     Cursor used for multiple calls to this function\n * @retval num Messages in the set\n *\n * @note Headers must be in #SORT_ORDER. See imap_exec_msgset() for args.\n * Pos is an opaque pointer a la strtok(). It should be 0 at first call.\n */\nstatic int make_msg_set(struct Mailbox *m, struct Buffer *buf, int flag,\n                        bool changed, bool invert, int *pos)\n{\n  int count = 0;             /* number of messages in message set */\n  unsigned int setstart = 0; /* start of current message range */\n  int n;\n  bool started = false;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  for (n = *pos; (n < m->msg_count) && (mutt_buffer_len(buf) < IMAP_MAX_CMDLEN); n++)\n  {\n    struct Email *e = m->emails[n];\n    if (!e)\n      break;\n    bool match = false; /* whether current message matches flag condition */\n    /* don't include pending expunged messages.\n     *\n     * TODO: can we unset active in cmd_parse_expunge() and\n     * cmd_parse_vanished() instead of checking for index != INT_MAX. */\n    if (e->active && (e->index != INT_MAX))\n    {\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (e->deleted != imap_edata_get(e)->deleted)\n            match = invert ^ e->deleted;\n          break;\n        case MUTT_FLAG:\n          if (e->flagged != imap_edata_get(e)->flagged)\n            match = invert ^ e->flagged;\n          break;\n        case MUTT_OLD:\n          if (e->old != imap_edata_get(e)->old)\n            match = invert ^ e->old;\n          break;\n        case MUTT_READ:\n          if (e->read != imap_edata_get(e)->read)\n            match = invert ^ e->read;\n          break;\n        case MUTT_REPLIED:\n          if (e->replied != imap_edata_get(e)->replied)\n            match = invert ^ e->replied;\n          break;\n        case MUTT_TAG:\n          if (e->tagged)\n            match = true;\n          break;\n        case MUTT_TRASH:\n          if (e->deleted && !e->purge)\n            match = true;\n          break;\n      }\n    }\n\n    if (match && (!changed || e->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = imap_edata_get(e)->uid;\n        if (started)\n        {\n          mutt_buffer_add_printf(buf, \",%u\", imap_edata_get(e)->uid);\n        }\n        else\n        {\n          mutt_buffer_add_printf(buf, \"%u\", imap_edata_get(e)->uid);\n          started = true;\n        }\n      }\n      /* tie up if the last message also matches */\n      else if (n == (m->msg_count - 1))\n        mutt_buffer_add_printf(buf, \":%u\", imap_edata_get(e)->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (e->active || (n == adata->mailbox->msg_count - 1)))\n    {\n      if (imap_edata_get(m->emails[n - 1])->uid > setstart)\n        mutt_buffer_add_printf(buf, \":%u\", imap_edata_get(m->emails[n - 1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/**\n * compare_flags_for_copy - Compare local flags against the server\n * @param e Email\n * @retval true  Flags have changed\n * @retval false Flags match cached server flags\n *\n * The comparison of flags EXCLUDES the deleted flag.\n */\nstatic bool compare_flags_for_copy(struct Email *e)\n{\n  struct ImapEmailData *edata = e->edata;\n\n  if (e->read != edata->read)\n    return true;\n  if (e->old != edata->old)\n    return true;\n  if (e->flagged != edata->flagged)\n    return true;\n  if (e->replied != edata->replied)\n    return true;\n\n  return false;\n}\n\n/**\n * sync_helper - Sync flag changes to the server\n * @param m     Selected Imap Mailbox\n * @param right ACL, see #AclFlags\n * @param flag  NeoMutt flag, e.g. #MUTT_DELETED\n * @param name  Name of server flag\n * @retval >=0 Success, number of messages\n * @retval  -1 Failure\n */\nstatic int sync_helper(struct Mailbox *m, AclFlags right, int flag, const char *name)\n{\n  int count = 0;\n  int rc;\n  char buf[1024];\n\n  if (!m)\n    return -1;\n\n  if ((m->rights & right) == 0)\n    return 0;\n\n  if ((right == MUTT_ACL_WRITE) && !imap_has_flag(&imap_mdata_get(m)->flags, name))\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  rc = imap_exec_msgset(m, \"UID STORE\", buf, flag, true, false);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  rc = imap_exec_msgset(m, \"UID STORE\", buf, flag, true, true);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/**\n * longest_common_prefix - Find longest prefix common to two strings\n * @param dest  Destination buffer\n * @param src   Source buffer\n * @param start Starting offset into string\n * @param dlen  Destination buffer length\n * @retval num Length of the common string\n *\n * Trim dest to the length of the longest prefix it shares with src.\n */\nstatic size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while ((pos < dlen) && dest[pos] && (dest[pos] == src[pos]))\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/**\n * complete_hosts - Look for completion matches for mailboxes\n * @param buf Partial mailbox name to complete\n * @param buflen  Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * look for IMAP URLs to complete from defined mailboxes. Could be extended to\n * complete over open connections and account/folder hooks too.\n */\nstatic int complete_hosts(char *buf, size_t buflen)\n{\n  // struct Connection *conn = NULL;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_str_strlen(buf);\n  struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n  neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n  struct MailboxNode *np = NULL;\n  STAILQ_FOREACH(np, &ml, entries)\n  {\n    if (!mutt_str_startswith(mailbox_path(np->mailbox), buf, CASE_MATCH))\n      continue;\n\n    if (rc)\n    {\n      mutt_str_strfcpy(buf, mailbox_path(np->mailbox), buflen);\n      rc = 0;\n    }\n    else\n      longest_common_prefix(buf, mailbox_path(np->mailbox), matchlen, buflen);\n  }\n  neomutt_mailboxlist_clear(&ml);\n\n#if 0\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    struct Url url = { 0 };\n    char urlstr[1024];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl(&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_tostring(&url, urlstr, sizeof(urlstr), 0);\n    if (mutt_str_strncmp(buf, urlstr, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, urlstr, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, urlstr, matchlen, buflen);\n    }\n  }\n#endif\n\n  return rc;\n}\n\n/**\n * imap_create_mailbox - Create a new mailbox\n * @param adata Imap Account data\n * @param mailbox Mailbox to create\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_create_mailbox(struct ImapAccountData *adata, char *mailbox)\n{\n  char buf[2048], mbox[1024];\n\n  imap_munge_mbox_name(adata->unicode, mbox, sizeof(mbox), mailbox);\n  snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);\n\n  if (imap_exec(adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(adata));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_access - Check permissions on an IMAP mailbox with a new connection\n * @param path Mailbox path\n * @retval  0 Success\n * @retval <0 Failure\n *\n * TODO: ACL checks. Right now we assume if it exists we can mess with it.\n * TODO: This method should take a Mailbox as parameter to be able to reuse the\n * existing connection.\n */\nint imap_access(const char *path)\n{\n  if (imap_path_status(path, false) >= 0)\n    return 0;\n  return -1;\n}\n\n/**\n * imap_rename_mailbox - Rename a mailbox\n * @param adata Imap Account data\n * @param oldname Existing mailbox\n * @param newname New name for mailbox\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_rename_mailbox(struct ImapAccountData *adata, char *oldname, const char *newname)\n{\n  char oldmbox[1024];\n  char newmbox[1024];\n  int rc = 0;\n\n  imap_munge_mbox_name(adata->unicode, oldmbox, sizeof(oldmbox), oldname);\n  imap_munge_mbox_name(adata->unicode, newmbox, sizeof(newmbox), newname);\n\n  struct Buffer *buf = mutt_buffer_pool_get();\n  mutt_buffer_printf(buf, \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec(adata, mutt_b2s(buf), IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    rc = -1;\n\n  mutt_buffer_pool_release(&buf);\n\n  return rc;\n}\n\n/**\n * imap_delete_mailbox - Delete a mailbox\n * @param m  Mailbox\n * @param path  name of the mailbox to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_delete_mailbox(struct Mailbox *m, char *path)\n{\n  char buf[PATH_MAX + 7];\n  char mbox[PATH_MAX];\n  struct Url *url = url_parse(path);\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  imap_munge_mbox_name(adata->unicode, mbox, sizeof(mbox), url->path);\n  url_free(&url);\n  snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);\n  if (imap_exec(m->account->adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_logout - Gracefully log out of server\n * @param adata Imap Account data\n */\nstatic void imap_logout(struct ImapAccountData *adata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  if (adata->state == IMAP_DISCONNECTED)\n  {\n    return;\n  }\n\n  adata->status = IMAP_BYE;\n  imap_cmd_start(adata, \"LOGOUT\");\n  if ((C_ImapPollTimeout <= 0) || (mutt_socket_poll(adata->conn, C_ImapPollTimeout) != 0))\n  {\n    while (imap_cmd_step(adata) == IMAP_RES_CONTINUE)\n      ; // do nothing\n  }\n  mutt_socket_close(adata->conn);\n  adata->state = IMAP_DISCONNECTED;\n}\n\n/**\n * imap_logout_all - close all open connections\n *\n * Quick and dirty until we can make sure we've got all the context we need.\n */\nvoid imap_logout_all(void)\n{\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    struct ImapAccountData *adata = np->adata;\n    if (!adata)\n      continue;\n\n    struct Connection *conn = adata->conn;\n    if (!conn || (conn->fd < 0))\n      continue;\n\n    mutt_message(_(\"Closing connection to %s...\"), conn->account.host);\n    imap_logout(np->adata);\n    mutt_clear_error();\n  }\n}\n\n/**\n * imap_read_literal - Read bytes bytes from server into file\n * @param fp    File handle for email file\n * @param adata Imap Account data\n * @param bytes Number of bytes to read\n * @param pbar  Progress bar\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Not explicitly buffered, relies on FILE buffering.\n *\n * @note Strips `\\r` from `\\r\\n`.\n *       Apparently even literals use `\\r\\n`-terminated strings ?!\n */\nint imap_read_literal(FILE *fp, struct ImapAccountData *adata,\n                      unsigned long bytes, struct Progress *pbar)\n{\n  char c;\n  bool r = false;\n  struct Buffer buf = { 0 }; // Do not allocate, maybe it won't be used\n\n  if (C_DebugLevel >= IMAP_LOG_LTRL)\n    mutt_buffer_alloc(&buf, bytes + 10);\n\n  mutt_debug(LL_DEBUG2, \"reading %ld bytes\\n\", bytes);\n\n  for (unsigned long pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar(adata->conn, &c) != 1)\n    {\n      mutt_debug(LL_DEBUG1, \"error during read, %ld bytes read\\n\", pos);\n      adata->status = IMAP_FATAL;\n\n      mutt_buffer_dealloc(&buf);\n      return -1;\n    }\n\n    if (r && (c != '\\n'))\n      fputc('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = true;\n      continue;\n    }\n    else\n      r = false;\n\n    fputc(c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update(pbar, pos, -1);\n    if (C_DebugLevel >= IMAP_LOG_LTRL)\n      mutt_buffer_addch(&buf, c);\n  }\n\n  if (C_DebugLevel >= IMAP_LOG_LTRL)\n  {\n    mutt_debug(IMAP_LOG_LTRL, \"\\n%s\", buf.data);\n    mutt_buffer_dealloc(&buf);\n  }\n  return 0;\n}\n\n/**\n * imap_expunge_mailbox - Purge messages from the server\n * @param m Mailbox\n *\n * Purge IMAP portion of expunged messages from the context. Must not be done\n * while something has a handle on any headers (eg inside pager or editor).\n * That is, check #IMAP_REOPEN_ALLOW.\n */\nvoid imap_expunge_mailbox(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return;\n\n  struct Email *e = NULL;\n\n#ifdef USE_HCACHE\n  mdata->hcache = imap_hcache_open(adata, mdata);\n#endif\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->index == INT_MAX)\n    {\n      mutt_debug(LL_DEBUG2, \"Expunging message UID %u\\n\", imap_edata_get(e)->uid);\n\n      e->deleted = true;\n\n      imap_cache_del(m, e);\n#ifdef USE_HCACHE\n      imap_hcache_del(mdata, imap_edata_get(e)->uid);\n#endif\n\n      mutt_hash_int_delete(mdata->uid_hash, imap_edata_get(e)->uid, e);\n\n      imap_edata_free((void **) &e->edata);\n    }\n    else\n    {\n      e->index = i;\n      /* NeoMutt has several places where it turns off e->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The ctx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.  */\n      e->active = true;\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(mdata);\n#endif\n\n  mailbox_changed(m, NT_MAILBOX_UPDATE);\n  mailbox_changed(m, NT_MAILBOX_RESORT);\n}\n\n/**\n * imap_open_connection - Open an IMAP connection\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_str_startswith(adata->buf, \"* OK\", CASE_IGNORE))\n  {\n    if (!mutt_str_startswith(adata->buf, \"* OK [CAPABILITY\", CASE_IGNORE) &&\n        check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && !adata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_startswith(adata->buf, \"* PREAUTH\", CASE_IGNORE))\n  {\n#ifdef USE_SSL\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (adata->conn->ssf == 0)\n    {\n      bool proceed = true;\n      if (C_SslForceTls)\n      {\n        proceed = false;\n      }\n      else if (C_SslStarttls != MUTT_NO)\n      {\n        proceed = mutt_yesorno(_(\"Abort unencrypted PREAUTH connection?\"),\n                               C_SslStarttls) != MUTT_NO;\n      }\n      if (!proceed)\n      {\n        mutt_error(_(\"Encrypted connection unavailable\"));\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}\n\n/**\n * imap_close_connection - Close an IMAP connection\n * @param adata Imap Account data\n */\nvoid imap_close_connection(struct ImapAccountData *adata)\n{\n  if (adata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close(adata->conn);\n    adata->state = IMAP_DISCONNECTED;\n  }\n  adata->seqno = 0;\n  adata->nextcmd = 0;\n  adata->lastcmd = 0;\n  adata->status = 0;\n  memset(adata->cmds, 0, sizeof(struct ImapCommand) * adata->cmdslots);\n}\n\n/**\n * imap_has_flag - Does the flag exist in the list\n * @param flag_list List of server flags\n * @param flag      Flag to find\n * @retval true Flag exists\n *\n * Do a caseless comparison of the flag against a flag list, return true if\n * found or flag list has '\\*'. Note that \"flag\" might contain additional\n * whitespace at the end, so we really need to compare up to the length of each\n * element in \"flag_list\".\n */\nbool imap_has_flag(struct ListHead *flag_list, const char *flag)\n{\n  if (STAILQ_EMPTY(flag_list))\n    return false;\n\n  const size_t flaglen = mutt_str_strlen(flag);\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, flag_list, entries)\n  {\n    const size_t nplen = strlen(np->data);\n    if ((flaglen >= nplen) && ((flag[nplen] == '\\0') || (flag[nplen] == ' ')) &&\n        (mutt_str_strncasecmp(np->data, flag, nplen) == 0))\n    {\n      return true;\n    }\n\n    if (mutt_str_strcmp(np->data, \"\\\\*\") == 0)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * compare_uid - Compare two Emails by UID - Implements ::sort_t\n */\nstatic int compare_uid(const void *a, const void *b)\n{\n  const struct Email *ea = *(struct Email const *const *) a;\n  const struct Email *eb = *(struct Email const *const *) b;\n  return imap_edata_get((struct Email *) ea)->uid -\n         imap_edata_get((struct Email *) eb)->uid;\n}\n\n/**\n * imap_exec_msgset - Prepare commands for all messages matching conditions\n * @param m       Selected Imap Mailbox\n * @param pre     prefix commands\n * @param post    postfix commands\n * @param flag    flag type on which to filter, e.g. #MUTT_REPLIED\n * @param changed include only changed messages in message set\n * @param invert  invert sense of flag, eg #MUTT_READ matches unread messages\n * @retval num Matched messages\n * @retval -1  Failure\n *\n * pre/post: commands are of the form \"%s %s %s %s\", tag, pre, message set, post\n * Prepares commands for all messages matching conditions\n * (must be flushed with imap_exec)\n */\nint imap_exec_msgset(struct Mailbox *m, const char *pre, const char *post,\n                     int flag, bool changed, bool invert)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  struct Email **emails = NULL;\n  short oldsort;\n  int pos;\n  int rc;\n  int count = 0;\n\n  struct Buffer cmd = mutt_buffer_make(0);\n\n  /* We make a copy of the headers just in case resorting doesn't give\n   exactly the original order (duplicate messages?), because other parts of\n   the ctx are tied to the header order. This may be overkill. */\n  oldsort = C_Sort;\n  if (C_Sort != SORT_ORDER)\n  {\n    emails = m->emails;\n    // We overcommit here, just in case new mail arrives whilst we're sync-ing\n    m->emails = mutt_mem_malloc(m->email_max * sizeof(struct Email *));\n    memcpy(m->emails, emails, m->email_max * sizeof(struct Email *));\n\n    C_Sort = SORT_ORDER;\n    qsort(m->emails, m->msg_count, sizeof(struct Email *), compare_uid);\n  }\n\n  pos = 0;\n\n  do\n  {\n    mutt_buffer_reset(&cmd);\n    mutt_buffer_add_printf(&cmd, \"%s \", pre);\n    rc = make_msg_set(m, &cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_add_printf(&cmd, \" %s\", post);\n      if (imap_exec(adata, cmd.data, IMAP_CMD_QUEUE) != IMAP_EXEC_SUCCESS)\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  } while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_dealloc(&cmd);\n  if (oldsort != C_Sort)\n  {\n    C_Sort = oldsort;\n    FREE(&m->emails);\n    m->emails = emails;\n  }\n\n  return rc;\n}\n\n/**\n * imap_sync_message_for_copy - Update server to reflect the flags of a single message\n * @param[in]  m            Mailbox\n * @param[in]  e            Email\n * @param[in]  cmd          Buffer for the command string\n * @param[out] err_continue Did the user force a continue?\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n *\n * @note This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy(struct Mailbox *m, struct Email *e,\n                               struct Buffer *cmd, enum QuadOption *err_continue)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  char flags[1024];\n  char *tags = NULL;\n  char uid[11];\n\n  if (!compare_flags_for_copy(e))\n  {\n    if (e->deleted == imap_edata_get(e)->deleted)\n      e->changed = false;\n    return 0;\n  }\n\n  snprintf(uid, sizeof(uid), \"%u\", imap_edata_get(e)->uid);\n  mutt_buffer_reset(cmd);\n  mutt_buffer_addstr(cmd, \"UID STORE \");\n  mutt_buffer_addstr(cmd, uid);\n\n  flags[0] = '\\0';\n\n  set_flag(m, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_DELETE, imap_edata_get(e)->deleted, \"\\\\Deleted \", flags,\n           sizeof(flags));\n\n  if (m->rights & MUTT_ACL_WRITE)\n  {\n    /* restore system flags */\n    if (imap_edata_get(e)->flags_system)\n      mutt_str_strcat(flags, sizeof(flags), imap_edata_get(e)->flags_system);\n    /* set custom flags */\n    tags = driver_tags_get_with_hidden(&e->tags);\n    if (tags)\n    {\n      mutt_str_strcat(flags, sizeof(flags), tags);\n      FREE(&tags);\n    }\n  }\n\n  mutt_str_remove_trailing_ws(flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (*flags == '\\0')\n  {\n    set_flag(m, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_DELETE, !imap_edata_get(e)->deleted, \"\\\\Deleted \",\n             flags, sizeof(flags));\n\n    /* erase custom flags */\n    if ((m->rights & MUTT_ACL_WRITE) && imap_edata_get(e)->flags_remote)\n      mutt_str_strcat(flags, sizeof(flags), imap_edata_get(e)->flags_remote);\n\n    mutt_str_remove_trailing_ws(flags);\n\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr(cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr(cmd, flags);\n  mutt_buffer_addstr(cmd, \")\");\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec(adata, cmd->data, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS) &&\n      err_continue && (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue(\"imap_sync_message: STORE failed\", adata->buf);\n    if (*err_continue != MUTT_YES)\n      return -1;\n  }\n\n  /* server have now the updated flags */\n  FREE(&imap_edata_get(e)->flags_remote);\n  imap_edata_get(e)->flags_remote = driver_tags_get_with_hidden(&e->tags);\n\n  if (e->deleted == imap_edata_get(e)->deleted)\n    e->changed = false;\n\n  return 0;\n}\n\n/**\n * imap_check_mailbox - use the NOOP or IDLE command to poll for new mail\n * @param m     Mailbox\n * @param force Don't wait\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval 0               no change\n * @retval -1              error\n */\nint imap_check_mailbox(struct Mailbox *m, bool force)\n{\n  if (!m || !m->account)\n    return -1;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  int rc = 0;\n\n  /* try IDLE first, unless force is set */\n  if (!force && C_ImapIdle && (adata->capabilities & IMAP_CAP_IDLE) &&\n      ((adata->state != IMAP_IDLE) || (mutt_date_epoch() >= adata->lastread + C_ImapKeepalive)))\n  {\n    if (imap_cmd_idle(adata) < 0)\n      return -1;\n  }\n  if (adata->state == IMAP_IDLE)\n  {\n    while ((rc = mutt_socket_poll(adata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n      {\n        mutt_debug(LL_DEBUG1, \"Error reading IDLE response\\n\");\n        return -1;\n      }\n    }\n    if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"Poll failed, disabling IDLE\\n\");\n      adata->capabilities &= ~IMAP_CAP_IDLE; // Clear the flag\n    }\n  }\n\n  if ((force || ((adata->state != IMAP_IDLE) &&\n                 (mutt_date_epoch() >= adata->lastread + C_Timeout))) &&\n      (imap_exec(adata, \"NOOP\", IMAP_CMD_POLL) != IMAP_EXEC_SUCCESS))\n  {\n    return -1;\n  }\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish(adata);\n\n  if (mdata->check_status & IMAP_EXPUNGE_PENDING)\n    rc = MUTT_REOPENED;\n  else if (mdata->check_status & IMAP_NEWMAIL_PENDING)\n    rc = MUTT_NEW_MAIL;\n  else if (mdata->check_status & IMAP_FLAGS_PENDING)\n    rc = MUTT_FLAGS;\n\n  mdata->check_status = IMAP_OPEN_NO_FLAGS;\n\n  return rc;\n}\n\n/**\n * imap_status - Refresh the number of total and new messages\n * @param adata  IMAP Account data\n * @param mdata  IMAP Mailbox data\n * @param queue  Queue the STATUS command\n * @retval num   Total number of messages\n */\nstatic int imap_status(struct ImapAccountData *adata, struct ImapMboxData *mdata, bool queue)\n{\n  char *uidvalidity_flag = NULL;\n  char cmd[2048];\n\n  if (!adata || !mdata)\n    return -1;\n\n  /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n   * IDLEd elsewhere.\n   * adata->mailbox may be NULL for connections other than the current\n   * mailbox's. */\n  if (adata->mailbox && (adata->mailbox->mdata == mdata))\n  {\n    adata->mailbox->has_new = false;\n    return mdata->messages;\n  }\n\n  if (adata->capabilities & IMAP_CAP_IMAP4REV1)\n    uidvalidity_flag = \"UIDVALIDITY\";\n  else if (adata->capabilities & IMAP_CAP_STATUS)\n    uidvalidity_flag = \"UID-VALIDITY\";\n  else\n  {\n    mutt_debug(LL_DEBUG2, \"Server doesn't support STATUS\\n\");\n    return -1;\n  }\n\n  snprintf(cmd, sizeof(cmd), \"STATUS %s (UIDNEXT %s UNSEEN RECENT MESSAGES)\",\n           mdata->munge_name, uidvalidity_flag);\n\n  int rc = imap_exec(adata, cmd, queue ? IMAP_CMD_QUEUE : IMAP_CMD_NO_FLAGS | IMAP_CMD_POLL);\n  if (rc < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"Error queueing command\\n\");\n    return rc;\n  }\n  return mdata->messages;\n}\n\n/**\n * imap_mbox_check_stats - Check the Mailbox statistics - Implements MxOps::mbox_check_stats()\n */\nstatic int imap_mbox_check_stats(struct Mailbox *m, int flags)\n{\n  return imap_mailbox_status(m, true);\n}\n\n/**\n * imap_path_status - Refresh the number of total and new messages\n * @param path   Mailbox path\n * @param queue  Queue the STATUS command\n * @retval num   Total number of messages\n */\nint imap_path_status(const char *path, bool queue)\n{\n  struct Mailbox *m = mx_mbox_find2(path);\n  if (m)\n    return imap_mailbox_status(m, queue);\n\n  // FIXME(sileht): Is that case possible ?\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return -1;\n  int rc = imap_status(adata, mdata, queue);\n  imap_mdata_free((void *) &mdata);\n  return rc;\n}\n\n/**\n * imap_mailbox_status - Refresh the number of total and new messages\n * @param m      Mailbox\n * @param queue  Queue the STATUS command\n * @retval num Total number of messages\n * @retval -1  Error\n *\n * @note Prepare the mailbox if we are not connected\n */\nint imap_mailbox_status(struct Mailbox *m, bool queue)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return -1;\n  return imap_status(adata, mdata, queue);\n}\n\n/**\n * imap_subscribe - Subscribe to a mailbox\n * @param path      Mailbox path\n * @param subscribe True: subscribe, false: unsubscribe\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char buf[2048];\n  struct Buffer err;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return -1;\n\n  if (C_ImapCheckSubscribed)\n  {\n    char mbox[1024];\n    mutt_buffer_init(&err);\n    err.dsize = 256;\n    err.data = mutt_mem_malloc(err.dsize);\n    size_t len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");\n    imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n    if (mutt_parse_rc_line(mbox, &err))\n      mutt_debug(LL_DEBUG1, \"Error adding subscribed mailbox: %s\\n\", err.data);\n    FREE(&err.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), mdata->name);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), mdata->name);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mdata->munge_name);\n\n  if (imap_exec(adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    imap_mdata_free((void *) &mdata);\n    return -1;\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mdata->name);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mdata->name);\n  imap_mdata_free((void *) &mdata);\n  return 0;\n}\n\n/**\n * imap_complete - Try to complete an IMAP folder path\n * @param buf Buffer for result\n * @param buflen Length of buffer\n * @param path Partial mailbox name to complete\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given a partial IMAP folder path, return a string which adds as much to the\n * path as is unique\n */\nint imap_complete(char *buf, size_t buflen, const char *path)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char tmp[2048];\n  struct ImapList listresp = { 0 };\n  char completion[1024];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  int rc;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n  {\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* fire off command */\n  snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\",\n           C_ImapListSubscribed ? \"LSUB\" : \"LIST\", mdata->real_name);\n\n  imap_cmd_start(adata, tmp);\n\n  /* and see what the results are */\n  mutt_str_strfcpy(completion, mdata->name, sizeof(completion));\n  imap_mdata_free((void *) &mdata);\n\n  adata->cmdresult = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step(adata);\n\n    if ((rc == IMAP_RES_CONTINUE) && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        mutt_str_strfcpy(completion, listresp.name, sizeof(completion));\n        matchlen = strlen(completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  } while (rc == IMAP_RES_CONTINUE);\n  adata->cmdresult = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path(buf, buflen, &adata->conn->account, completion);\n    mutt_pretty_mailbox(buf, buflen);\n    return 0;\n  }\n\n  return -1;\n}\n\n/**\n * imap_fast_trash - Use server COPY command to copy deleted messages to trash\n * @param m    Mailbox\n * @param dest Mailbox to move to\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_fast_trash(struct Mailbox *m, char *dest)\n{\n  char prompt[1024];\n  int rc = -1;\n  bool triedcreate = false;\n  enum QuadOption err_continue = MUTT_NO;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapAccountData *dest_adata = NULL;\n  struct ImapMboxData *dest_mdata = NULL;\n\n  if (imap_adata_find(dest, &dest_adata, &dest_mdata) < 0)\n    return -1;\n\n  struct Buffer sync_cmd = mutt_buffer_make(0);\n\n  /* check that the save-to folder is in the same account */\n  if (!imap_account_match(&(adata->conn->account), &(dest_adata->conn->account)))\n  {\n    mutt_debug(LL_DEBUG3, \"%s not same server as %s\\n\", dest, mailbox_path(m));\n    goto out;\n  }\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n    if (e->active && e->changed && e->deleted && !e->purge)\n    {\n      rc = imap_sync_message_for_copy(m, e, &sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        mutt_debug(LL_DEBUG1, \"could not sync\\n\");\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset(m, \"UID COPY\", dest_mdata->munge_name, MUTT_TRASH, false, false);\n    if (rc == 0)\n    {\n      mutt_debug(LL_DEBUG1, \"No messages to trash\\n\");\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"could not queue copy\\n\");\n      goto out;\n    }\n    else if (m->verbose)\n    {\n      mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                   rc, dest_mdata->name);\n    }\n\n    /* let's get it on */\n    rc = imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS);\n    if (rc == IMAP_EXEC_ERROR)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(LL_DEBUG1, \"Already tried to create mailbox %s\\n\", dest_mdata->name);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (!mutt_str_startswith(imap_get_qualifier(adata->buf), \"[TRYCREATE]\", CASE_IGNORE))\n        break;\n      mutt_debug(LL_DEBUG3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), dest_mdata->name);\n      if (C_Confirmcreate && (mutt_yesorno(prompt, MUTT_YES) != MUTT_YES))\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(adata, dest_mdata->name) < 0)\n        break;\n      triedcreate = true;\n    }\n  } while (rc == IMAP_EXEC_ERROR);\n\n  if (rc != IMAP_EXEC_SUCCESS)\n  {\n    imap_error(\"imap_fast_trash\", adata->buf);\n    goto out;\n  }\n\n  rc = IMAP_EXEC_SUCCESS;\n\nout:\n  mutt_buffer_dealloc(&sync_cmd);\n  imap_mdata_free((void *) &dest_mdata);\n\n  return ((rc == IMAP_EXEC_SUCCESS) ? 0 : -1);\n}\n\n/**\n * imap_sync_mailbox - Sync all the changes to the server\n * @param m       Mailbox\n * @param expunge if true do expunge\n * @param close   if true we move imap state to CLOSE\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval  0 Success\n * @retval -1 Error\n *\n * @note The flag retvals come from a call to imap_check_mailbox()\n */\nint imap_sync_mailbox(struct Mailbox *m, bool expunge, bool close)\n{\n  if (!m)\n    return -1;\n\n  struct Email **emails = NULL;\n  int oldsort;\n  int rc;\n  int check;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  if (adata->state < IMAP_SELECTED)\n  {\n    mutt_debug(LL_DEBUG2, \"no mailbox selected\\n\");\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen(m);\n\n  check = imap_check_mailbox(m, false);\n  if (check < 0)\n    return check;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && (m->rights & MUTT_ACL_DELETE))\n  {\n    rc = imap_exec_msgset(m, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                          MUTT_DELETED, true, false);\n    if (rc < 0)\n    {\n      mutt_error(_(\"Expunge failed\"));\n      return rc;\n    }\n\n    if (rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (int i = 0; i < m->msg_count; i++)\n      {\n        struct Email *e = m->emails[i];\n        if (!e)\n          break;\n        if (e->deleted && e->changed)\n          e->active = false;\n      }\n      if (m->verbose)\n      {\n        mutt_message(ngettext(\"Marking %d message deleted...\",\n                              \"Marking %d messages deleted...\", rc),\n                     rc);\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  mdata->hcache = imap_hcache_open(adata, mdata);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->deleted)\n    {\n      imap_cache_del(m, e);\n#ifdef USE_HCACHE\n      imap_hcache_del(mdata, imap_edata_get(e)->uid);\n#endif\n    }\n\n    if (e->active && e->changed)\n    {\n#ifdef USE_HCACHE\n      imap_hcache_put(mdata, e);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      /* TODO: why the e->env check? */\n      if ((e->env && e->env->changed) || e->attach_del)\n      {\n        /* L10N: The plural is chosen by the last %d, i.e. the total number */\n        if (m->verbose)\n        {\n          mutt_message(ngettext(\"Saving changed message... [%d/%d]\",\n                                \"Saving changed messages... [%d/%d]\", m->msg_count),\n                       i + 1, m->msg_count);\n        }\n        bool save_append = m->append;\n        m->append = true;\n        mutt_save_message_ctx(e, true, false, false, m);\n        m->append = save_append;\n        /* TODO: why the check for h->env?  Is this possible? */\n        if (e->env)\n          e->env->changed = 0;\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(mdata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset */\n  oldsort = C_Sort;\n  if (C_Sort != SORT_ORDER)\n  {\n    emails = m->emails;\n    m->emails = mutt_mem_malloc(m->msg_count * sizeof(struct Email *));\n    memcpy(m->emails, emails, m->msg_count * sizeof(struct Email *));\n\n    C_Sort = SORT_ORDER;\n    qsort(m->emails, m->msg_count, sizeof(struct Email *), mutt_get_sort_func(SORT_ORDER));\n  }\n\n  rc = sync_helper(m, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if (oldsort != C_Sort)\n  {\n    C_Sort = oldsort;\n    FREE(&m->emails);\n    m->emails = emails;\n  }\n\n  /* Flush the queued flags if any were changed in sync_helper. */\n  if (rc > 0)\n    if (imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (close)\n    {\n      if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), MUTT_NO) == MUTT_YES)\n      {\n        adata->state = IMAP_AUTHENTICATED;\n        return 0;\n      }\n    }\n    else\n      mutt_error(_(\"Error saving flags\"));\n    return -1;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n    struct ImapEmailData *edata = imap_edata_get(e);\n    edata->deleted = e->deleted;\n    edata->flagged = e->flagged;\n    edata->old = e->old;\n    edata->read = e->read;\n    edata->replied = e->replied;\n    e->changed = false;\n  }\n  m->changed = false;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !close && (m->rights & MUTT_ACL_DELETE))\n  {\n    if (m->verbose)\n      mutt_message(_(\"Expunging messages from server...\"));\n    /* Set expunge bit so we don't get spurious reopened messages */\n    mdata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec(adata, \"EXPUNGE\", IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    {\n      mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), adata->buf);\n      return -1;\n    }\n    mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && close)\n  {\n    adata->closing = true;\n    imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);\n    adata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (C_MessageCacheClean)\n    imap_cache_clean(m);\n\n  return check;\n}\n\n/**\n * imap_ac_find - Find an Account that matches a Mailbox path - Implements MxOps::ac_find()\n */\nstatic struct Account *imap_ac_find(struct Account *a, const char *path)\n{\n  if (!a || (a->type != MUTT_IMAP) || !path)\n    return NULL;\n\n  struct Url *url = url_parse(path);\n  if (!url)\n    return NULL;\n\n  struct ImapAccountData *adata = a->adata;\n  struct ConnAccount *cac = &adata->conn->account;\n\n  if (mutt_str_strcasecmp(url->host, cac->host) != 0)\n    a = NULL;\n  else if (url->user && (mutt_str_strcasecmp(url->user, cac->user) != 0))\n    a = NULL;\n\n  url_free(&url);\n  return a;\n}\n\n/**\n * imap_ac_add - Add a Mailbox to an Account - Implements MxOps::ac_add()\n */\nstatic int imap_ac_add(struct Account *a, struct Mailbox *m)\n{\n  if (!a || !m || (m->type != MUTT_IMAP))\n    return -1;\n\n  struct ImapAccountData *adata = a->adata;\n\n  if (!adata)\n  {\n    struct ConnAccount cac = { { 0 } };\n    char mailbox[PATH_MAX];\n\n    if (imap_parse_path(mailbox_path(m), &cac, mailbox, sizeof(mailbox)) < 0)\n      return -1;\n\n    adata = imap_adata_new(a);\n    adata->conn = mutt_conn_new(&cac);\n    if (!adata->conn)\n    {\n      imap_adata_free((void **) &adata);\n      return -1;\n    }\n\n    mutt_account_hook(m->realpath);\n\n    if (imap_login(adata) < 0)\n    {\n      imap_adata_free((void **) &adata);\n      return -1;\n    }\n\n    a->adata = adata;\n    a->adata_free = imap_adata_free;\n  }\n\n  if (!m->mdata)\n  {\n    struct Url *url = url_parse(mailbox_path(m));\n    struct ImapMboxData *mdata = imap_mdata_new(adata, url->path);\n\n    /* fixup path and realpath, mainly to replace / by /INBOX */\n    char buf[1024];\n    imap_qualify_path(buf, sizeof(buf), &adata->conn->account, mdata->name);\n    mutt_buffer_strcpy(&m->pathbuf, buf);\n    mutt_str_replace(&m->realpath, mailbox_path(m));\n\n    m->mdata = mdata;\n    m->mdata_free = imap_mdata_free;\n    url_free(&url);\n  }\n  return 0;\n}\n\n/**\n * imap_mbox_select - Select a Mailbox\n * @param m Mailbox\n */\nstatic void imap_mbox_select(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return;\n\n  const char *condstore = NULL;\n#ifdef USE_HCACHE\n  if ((adata->capabilities & IMAP_CAP_CONDSTORE) && C_ImapCondstore)\n    condstore = \" (CONDSTORE)\";\n  else\n#endif\n    condstore = \"\";\n\n  char buf[PATH_MAX];\n  snprintf(buf, sizeof(buf), \"%s %s%s\", m->readonly ? \"EXAMINE\" : \"SELECT\",\n           mdata->munge_name, condstore);\n\n  adata->state = IMAP_SELECTED;\n\n  imap_cmd_start(adata, buf);\n}\n\n/**\n * imap_login -  Open an IMAP connection\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Ensure ImapAccountData is connected and logged into the imap server.\n */\nint imap_login(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return -1;\n\n  if (adata->state == IMAP_DISCONNECTED)\n  {\n    mutt_buffer_reset(&adata->cmdbuf); // purge outstanding queued commands\n    imap_open_connection(adata);\n  }\n  if (adata->state == IMAP_CONNECTED)\n  {\n    if (imap_authenticate(adata) == IMAP_AUTH_SUCCESS)\n    {\n      adata->state = IMAP_AUTHENTICATED;\n      FREE(&adata->capstr);\n      if (adata->conn->ssf)\n      {\n        mutt_debug(LL_DEBUG2, \"Communication encrypted at %d bits\\n\",\n                   adata->conn->ssf);\n      }\n    }\n    else\n      mutt_account_unsetpass(&adata->conn->account);\n  }\n  if (adata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec(adata, \"CAPABILITY\", IMAP_CMD_PASS);\n\n#ifdef USE_ZLIB\n    /* RFC4978 */\n    if ((adata->capabilities & IMAP_CAP_COMPRESS) && C_ImapDeflate &&\n        (imap_exec(adata, \"COMPRESS DEFLATE\", IMAP_CMD_PASS) == IMAP_EXEC_SUCCESS))\n    {\n      mutt_debug(LL_DEBUG2, \"IMAP compression is enabled on connection to %s\\n\",\n                 adata->conn->account.host);\n      mutt_zstrm_wrap_conn(adata->conn);\n    }\n#endif\n\n    /* enable RFC6855, if the server supports that */\n    if (C_ImapRfc5161 && (adata->capabilities & IMAP_CAP_ENABLE))\n      imap_exec(adata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n\n    /* enable QRESYNC.  Advertising QRESYNC also means CONDSTORE\n     * is supported (even if not advertised), so flip that bit. */\n    if (adata->capabilities & IMAP_CAP_QRESYNC)\n    {\n      adata->capabilities |= IMAP_CAP_CONDSTORE;\n      if (C_ImapRfc5161 && C_ImapQresync)\n        imap_exec(adata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);\n    }\n\n    /* get root delimiter, '/' as default */\n    adata->delim = '/';\n    imap_exec(adata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS);\n\n    /* select the mailbox that used to be open before disconnect */\n    if (adata->mailbox)\n    {\n      imap_mbox_select(adata->mailbox);\n    }\n  }\n\n  if (adata->state < IMAP_AUTHENTICATED)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_open - Open a mailbox - Implements MxOps::mbox_open()\n */\nstatic int imap_mbox_open(struct Mailbox *m)\n{\n  if (!m || !m->account || !m->mdata)\n    return -1;\n\n  char buf[PATH_MAX];\n  int count = 0;\n  int rc;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  mutt_debug(LL_DEBUG3, \"opening %s, saving %s\\n\", m->pathbuf.data,\n             (adata->mailbox ? adata->mailbox->pathbuf.data : \"(none)\"));\n  adata->prev_mailbox = adata->mailbox;\n  adata->mailbox = m;\n\n  /* clear mailbox status */\n  adata->status = 0;\n  m->rights = 0;\n  mdata->new_mail_count = 0;\n\n  if (m->verbose)\n    mutt_message(_(\"Selecting %s...\"), mdata->name);\n\n  /* pipeline ACL test */\n  if (adata->capabilities & IMAP_CAP_ACL)\n  {\n    snprintf(buf, sizeof(buf), \"MYRIGHTS %s\", mdata->munge_name);\n    imap_exec(adata, buf, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    m->rights |= MUTT_ACL_LOOKUP | MUTT_ACL_READ | MUTT_ACL_SEEN | MUTT_ACL_WRITE |\n                 MUTT_ACL_INSERT | MUTT_ACL_POST | MUTT_ACL_CREATE | MUTT_ACL_DELETE;\n  }\n\n  /* pipeline the postponed count if possible */\n  struct Mailbox *m_postponed = mx_mbox_find2(C_Postponed);\n  struct ImapAccountData *postponed_adata = imap_adata_get(m_postponed);\n  if (postponed_adata &&\n      imap_account_match(&postponed_adata->conn->account, &adata->conn->account))\n  {\n    imap_mailbox_status(m_postponed, true);\n  }\n\n  if (C_ImapCheckSubscribed)\n    imap_exec(adata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n\n  imap_mbox_select(m);\n\n  do\n  {\n    char *pc = NULL;\n\n    rc = imap_cmd_step(adata);\n    if (rc != IMAP_RES_CONTINUE)\n      break;\n\n    pc = adata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (mutt_str_startswith(pc, \"FLAGS\", CASE_IGNORE))\n    {\n      /* don't override PERMANENTFLAGS */\n      if (STAILQ_EMPTY(&mdata->flags))\n      {\n        mutt_debug(LL_DEBUG3, \"Getting mailbox FLAGS\\n\");\n        pc = get_flags(&mdata->flags, pc);\n        if (!pc)\n          goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (mutt_str_startswith(pc, \"OK [PERMANENTFLAGS\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox PERMANENTFLAGS\\n\");\n      /* safe to call on NULL */\n      mutt_list_free(&mdata->flags);\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      pc = get_flags(&(mdata->flags), pc);\n      if (!pc)\n        goto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (mutt_str_startswith(pc, \"OK [UIDVALIDITY\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox UIDVALIDITY\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &mdata->uidvalidity) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [UIDNEXT\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox UIDNEXT\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &mdata->uid_next) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [HIGHESTMODSEQ\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox HIGHESTMODSEQ\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoull(pc, &mdata->modseq) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [NOMODSEQ\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Mailbox has NOMODSEQ set\\n\");\n      mdata->modseq = 0;\n    }\n    else\n    {\n      pc = imap_next_word(pc);\n      if (mutt_str_startswith(pc, \"EXISTS\", CASE_IGNORE))\n      {\n        count = mdata->new_mail_count;\n        mdata->new_mail_count = 0;\n      }\n    }\n  } while (rc == IMAP_RES_CONTINUE);\n\n  if (rc == IMAP_RES_NO)\n  {\n    char *s = imap_next_word(adata->buf); /* skip seq */\n    s = imap_next_word(s);                /* Skip response */\n    mutt_error(\"%s\", s);\n    goto fail;\n  }\n\n  if (rc != IMAP_RES_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if (mutt_str_startswith(imap_get_qualifier(adata->buf), \"[READ-ONLY]\", CASE_IGNORE) &&\n      !(adata->capabilities & IMAP_CAP_ACL))\n  {\n    mutt_debug(LL_DEBUG2, \"Mailbox is read-only\\n\");\n    m->readonly = true;\n  }\n\n  /* dump the mailbox flags we've found */\n  if (C_DebugLevel > LL_DEBUG2)\n  {\n    if (STAILQ_EMPTY(&mdata->flags))\n      mutt_debug(LL_DEBUG3, \"No folder flags found\\n\");\n    else\n    {\n      struct ListNode *np = NULL;\n      struct Buffer flag_buffer;\n      mutt_buffer_init(&flag_buffer);\n      mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");\n      STAILQ_FOREACH(np, &mdata->flags, entries)\n      {\n        mutt_buffer_add_printf(&flag_buffer, \"[%s] \", np->data);\n      }\n      mutt_debug(LL_DEBUG3, \"%s\\n\", flag_buffer.data);\n      FREE(&flag_buffer.data);\n    }\n  }\n\n  if (!((m->rights & MUTT_ACL_DELETE) || (m->rights & MUTT_ACL_SEEN) ||\n        (m->rights & MUTT_ACL_WRITE) || (m->rights & MUTT_ACL_INSERT)))\n  {\n    m->readonly = true;\n  }\n\n  while (m->email_max < count)\n    mx_alloc_memory(m);\n\n  m->msg_count = 0;\n  m->msg_unread = 0;\n  m->msg_flagged = 0;\n  m->msg_new = 0;\n  m->msg_deleted = 0;\n  m->size = 0;\n  m->vcount = 0;\n\n  if (count && (imap_read_headers(m, 1, count, true) < 0))\n  {\n    mutt_error(_(\"Error opening mailbox\"));\n    goto fail;\n  }\n\n  mutt_debug(LL_DEBUG2, \"msg_count is %d\\n\", m->msg_count);\n  return 0;\n\nfail:\n  if (adata->state == IMAP_SELECTED)\n    adata->state = IMAP_AUTHENTICATED;\n  return -1;\n}\n\n/**\n * imap_mbox_open_append - Open a Mailbox for appending - Implements MxOps::mbox_open_append()\n */\nstatic int imap_mbox_open_append(struct Mailbox *m, OpenMailboxFlags flags)\n{\n  if (!m || !m->account)\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  int rc = imap_mailbox_status(m, false);\n  if (rc >= 0)\n    return 0;\n  if (rc == -1)\n    return -1;\n\n  char buf[PATH_MAX + 64];\n  snprintf(buf, sizeof(buf), _(\"Create %s?\"), mdata->name);\n  if (C_Confirmcreate && (mutt_yesorno(buf, MUTT_YES) != MUTT_YES))\n    return -1;\n\n  if (imap_create_mailbox(adata, mdata->name) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_check - Check for new mail - Implements MxOps::mbox_check()\n * @param m          Mailbox\n * @param index_hint Remember our place in the index\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nstatic int imap_mbox_check(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  imap_allow_reopen(m);\n  int rc = imap_check_mailbox(m, false);\n  /* NOTE - ctx might have been changed at this point. In particular,\n   * m could be NULL. Beware. */\n  imap_disallow_reopen(m);\n\n  return rc;\n}\n\n/**\n * imap_mbox_close - Close a Mailbox - Implements MxOps::mbox_close()\n */\nstatic int imap_mbox_close(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  /* Check to see if the mailbox is actually open */\n  if (!adata || !mdata)\n    return 0;\n\n  /* imap_mbox_open_append() borrows the struct ImapAccountData temporarily,\n   * just for the connection.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up adata.  Otherwise, we don't want to\n   * touch adata - it's still being used.  */\n  if (m == adata->mailbox)\n  {\n    if ((adata->status != IMAP_FATAL) && (adata->state >= IMAP_SELECTED))\n    {\n      /* mx_mbox_close won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (m->msg_deleted == 0)\n      {\n        adata->closing = true;\n        imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);\n      }\n      adata->state = IMAP_AUTHENTICATED;\n    }\n\n    mutt_debug(LL_DEBUG3, \"closing %s, restoring %s\\n\", m->pathbuf.data,\n               (adata->prev_mailbox ? adata->prev_mailbox->pathbuf.data : \"(none)\"));\n    adata->mailbox = adata->prev_mailbox;\n    imap_mbox_select(adata->prev_mailbox);\n    imap_mdata_cache_reset(m->mdata);\n  }\n\n  return 0;\n}\n\n/**\n * imap_msg_open_new - Open a new message in a Mailbox - Implements MxOps::msg_open_new()\n */\nstatic int imap_msg_open_new(struct Mailbox *m, struct Message *msg, struct Email *e)\n{\n  int rc = -1;\n\n  struct Buffer *tmp = mutt_buffer_pool_get();\n  mutt_buffer_mktemp(tmp);\n\n  msg->fp = mutt_file_fopen(mutt_b2s(tmp), \"w\");\n  if (!msg->fp)\n  {\n    mutt_perror(mutt_b2s(tmp));\n    goto cleanup;\n  }\n\n  msg->path = mutt_buffer_strdup(tmp);\n  rc = 0;\n\ncleanup:\n  mutt_buffer_pool_release(&tmp);\n  return rc;\n}\n\n/**\n * imap_tags_edit - Prompt and validate new messages tags - Implements MxOps::tags_edit()\n */\nstatic int imap_tags_edit(struct Mailbox *m, const char *tags, char *buf, size_t buflen)\n{\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!mdata)\n    return -1;\n\n  char *new_tag = NULL;\n  char *checker = NULL;\n\n  /* Check for \\* flags capability */\n  if (!imap_has_flag(&mdata->flags, NULL))\n  {\n    mutt_error(_(\"IMAP server doesn't support custom flags\"));\n    return -1;\n  }\n\n  *buf = '\\0';\n  if (tags)\n    mutt_str_strfcpy(buf, tags, buflen);\n\n  if (mutt_get_field(\"Tags: \", buf, buflen, MUTT_COMP_NO_FLAGS) != 0)\n    return -1;\n\n  /* each keyword must be atom defined by rfc822 as:\n   *\n   * atom           = 1*<any CHAR except specials, SPACE and CTLs>\n   * CHAR           = ( 0.-127. )\n   * specials       = \"(\" / \")\" / \"<\" / \">\" / \"@\"\n   *                  / \",\" / \";\" / \":\" / \"\\\" / <\">\n   *                  / \".\" / \"[\" / \"]\"\n   * SPACE          = ( 32. )\n   * CTLS           = ( 0.-31., 127.)\n   *\n   * And must be separated by one space.\n   */\n\n  new_tag = buf;\n  checker = buf;\n  SKIPWS(checker);\n  while (*checker != '\\0')\n  {\n    if ((*checker < 32) || (*checker >= 127) || // We allow space because it's the separator\n        (*checker == 40) ||                     // (\n        (*checker == 41) ||                     // )\n        (*checker == 60) ||                     // <\n        (*checker == 62) ||                     // >\n        (*checker == 64) ||                     // @\n        (*checker == 44) ||                     // ,\n        (*checker == 59) ||                     // ;\n        (*checker == 58) ||                     // :\n        (*checker == 92) ||                     // backslash\n        (*checker == 34) ||                     // \"\n        (*checker == 46) ||                     // .\n        (*checker == 91) ||                     // [\n        (*checker == 93))                       // ]\n    {\n      mutt_error(_(\"Invalid IMAP flags\"));\n      return 0;\n    }\n\n    /* Skip duplicate space */\n    while ((checker[0] == ' ') && (checker[1] == ' '))\n      checker++;\n\n    /* copy char to new_tag and go the next one */\n    *new_tag++ = *checker++;\n  }\n  *new_tag = '\\0';\n  new_tag = buf; /* rewind */\n  mutt_str_remove_trailing_ws(new_tag);\n\n  if (mutt_str_strcmp(tags, buf) == 0)\n    return 0;\n  return 1;\n}\n\n/**\n * imap_tags_commit - Save the tags to a message - Implements MxOps::tags_commit()\n *\n * This method update the server flags on the server by\n * removing the last know custom flags of a header\n * and adds the local flags\n *\n * If everything success we push the local flags to the\n * last know custom flags (flags_remote).\n *\n * Also this method check that each flags is support by the server\n * first and remove unsupported one.\n */\nstatic int imap_tags_commit(struct Mailbox *m, struct Email *e, char *buf)\n{\n  if (!m)\n    return -1;\n\n  char uid[11];\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n\n  if (*buf == '\\0')\n    buf = NULL;\n\n  if (!(adata->mailbox->rights & MUTT_ACL_WRITE))\n    return 0;\n\n  snprintf(uid, sizeof(uid), \"%u\", imap_edata_get(e)->uid);\n\n  /* Remove old custom flags */\n  if (imap_edata_get(e)->flags_remote)\n  {\n    struct Buffer cmd = mutt_buffer_make(128); // just a guess\n    mutt_buffer_addstr(&cmd, \"UID STORE \");\n    mutt_buffer_addstr(&cmd, uid);\n    mutt_buffer_addstr(&cmd, \" -FLAGS.SILENT (\");\n    mutt_buffer_addstr(&cmd, imap_edata_get(e)->flags_remote);\n    mutt_buffer_addstr(&cmd, \")\");\n\n    /* Should we return here, or we are fine and we could\n     * continue to add new flags */\n    int rc = imap_exec(adata, cmd.data, IMAP_CMD_NO_FLAGS);\n    mutt_buffer_dealloc(&cmd);\n    if (rc != IMAP_EXEC_SUCCESS)\n    {\n      return -1;\n    }\n  }\n\n  /* Add new custom flags */\n  if (buf)\n  {\n    struct Buffer cmd = mutt_buffer_make(128); // just a guess\n    mutt_buffer_addstr(&cmd, \"UID STORE \");\n    mutt_buffer_addstr(&cmd, uid);\n    mutt_buffer_addstr(&cmd, \" +FLAGS.SILENT (\");\n    mutt_buffer_addstr(&cmd, buf);\n    mutt_buffer_addstr(&cmd, \")\");\n\n    int rc = imap_exec(adata, cmd.data, IMAP_CMD_NO_FLAGS);\n    mutt_buffer_dealloc(&cmd);\n    if (rc != IMAP_EXEC_SUCCESS)\n    {\n      mutt_debug(LL_DEBUG1, \"fail to add new flags\\n\");\n      return -1;\n    }\n  }\n\n  /* We are good sync them */\n  mutt_debug(LL_DEBUG1, \"NEW TAGS: %s\\n\", buf);\n  driver_tags_replace(&e->tags, buf);\n  FREE(&imap_edata_get(e)->flags_remote);\n  imap_edata_get(e)->flags_remote = driver_tags_get_with_hidden(&e->tags);\n  return 0;\n}\n\n/**\n * imap_path_probe - Is this an IMAP Mailbox? - Implements MxOps::path_probe()\n */\nenum MailboxType imap_path_probe(const char *path, const struct stat *st)\n{\n  if (!path)\n    return MUTT_UNKNOWN;\n\n  if (mutt_str_startswith(path, \"imap://\", CASE_IGNORE))\n    return MUTT_IMAP;\n\n  if (mutt_str_startswith(path, \"imaps://\", CASE_IGNORE))\n    return MUTT_IMAP;\n\n  return MUTT_UNKNOWN;\n}\n\n/**\n * imap_path_canon - Canonicalise a Mailbox path - Implements MxOps::path_canon()\n */\nint imap_path_canon(char *buf, size_t buflen)\n{\n  if (!buf)\n    return -1;\n\n  struct Url *url = url_parse(buf);\n  if (!url)\n    return 0;\n\n  char tmp[PATH_MAX];\n  char tmp2[PATH_MAX];\n\n  imap_fix_path('\\0', url->path, tmp, sizeof(tmp));\n  url->path = tmp;\n  url_tostring(url, tmp2, sizeof(tmp2), 0);\n  mutt_str_strfcpy(buf, tmp2, buflen);\n  url_free(&url);\n\n  return 0;\n}\n\n/**\n * imap_expand_path - Buffer wrapper around imap_path_canon()\n * @param buf Path to expand\n * @retval  0 Success\n * @retval -1 Failure\n *\n * @note The path is expanded in place\n */\nint imap_expand_path(struct Buffer *buf)\n{\n  mutt_buffer_alloc(buf, PATH_MAX);\n  return imap_path_canon(buf->data, PATH_MAX);\n}\n\n/**\n * imap_path_pretty - Abbreviate a Mailbox path - Implements MxOps::path_pretty()\n */\nstatic int imap_path_pretty(char *buf, size_t buflen, const char *folder)\n{\n  if (!buf || !folder)\n    return -1;\n\n  imap_pretty_mailbox(buf, buflen, folder);\n  return 0;\n}\n\n/**\n * imap_path_parent - Find the parent of a Mailbox path - Implements MxOps::path_parent()\n */\nstatic int imap_path_parent(char *buf, size_t buflen)\n{\n  char tmp[PATH_MAX] = { 0 };\n\n  imap_get_parent_path(buf, tmp, sizeof(tmp));\n  mutt_str_strfcpy(buf, tmp, buflen);\n  return 0;\n}\n\n// clang-format off\n/**\n * MxImapOps - IMAP Mailbox - Implements ::MxOps\n */\nstruct MxOps MxImapOps = {\n  .type            = MUTT_IMAP,\n  .name             = \"imap\",\n  .is_local         = false,\n  .ac_find          = imap_ac_find,\n  .ac_add           = imap_ac_add,\n  .mbox_open        = imap_mbox_open,\n  .mbox_open_append = imap_mbox_open_append,\n  .mbox_check       = imap_mbox_check,\n  .mbox_check_stats = imap_mbox_check_stats,\n  .mbox_sync        = NULL, /* imap syncing is handled by imap_sync_mailbox */\n  .mbox_close       = imap_mbox_close,\n  .msg_open         = imap_msg_open,\n  .msg_open_new     = imap_msg_open_new,\n  .msg_commit       = imap_msg_commit,\n  .msg_close        = imap_msg_close,\n  .msg_padding_size = NULL,\n  .msg_save_hcache  = imap_msg_save_hcache,\n  .tags_edit        = imap_tags_edit,\n  .tags_commit      = imap_tags_commit,\n  .path_probe       = imap_path_probe,\n  .path_canon       = imap_path_canon,\n  .path_pretty      = imap_path_pretty,\n  .path_parent      = imap_path_parent,\n};\n// clang-format on\n", "/**\n * @file\n * Shared constants/structs that are private to IMAP\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_IMAP_PRIVATE_H\n#define MUTT_IMAP_PRIVATE_H\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <time.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"hcache/lib.h\"\n\nstruct Account;\nstruct ConnAccount;\nstruct Email;\nstruct Mailbox;\nstruct Message;\nstruct Progress;\n\n#define IMAP_PORT     143  ///< Default port for IMAP\n#define IMAP_SSL_PORT 993  ///< Port for IMAP over SSL/TLS\n\n/* logging levels */\n#define IMAP_LOG_CMD  2\n#define IMAP_LOG_LTRL 3\n#define IMAP_LOG_PASS 5\n\n/* IMAP command responses. Used in ImapCommand.state too */\n#define IMAP_RES_NO       -2  ///< `<tag> NO ...`\n#define IMAP_RES_BAD      -1  ///< `<tag> BAD ...`\n#define IMAP_RES_OK        0  ///< `<tag> OK ...`\n#define IMAP_RES_CONTINUE  1  ///< `* ...`\n#define IMAP_RES_RESPOND   2  ///< `+`\n#define IMAP_RES_NEW       3  ///< ImapCommand.state additions\n\n#define SEQ_LEN 16\n#define IMAP_MAX_CMDLEN 1024 ///< Maximum length of command lines before they must be split (for lazy servers)\n\ntypedef uint8_t ImapOpenFlags;         ///< Flags, e.g. #MUTT_THREAD_COLLAPSE\n#define IMAP_OPEN_NO_FLAGS          0  ///< No flags are set\n#define IMAP_REOPEN_ALLOW     (1 << 0) ///< Allow re-opening a folder upon expunge\n#define IMAP_EXPUNGE_EXPECTED (1 << 1) ///< Messages will be expunged from the server\n#define IMAP_EXPUNGE_PENDING  (1 << 2) ///< Messages on the server have been expunged\n#define IMAP_NEWMAIL_PENDING  (1 << 3) ///< New mail is waiting on the server\n#define IMAP_FLAGS_PENDING    (1 << 4) ///< Flags have changed on the server\n\ntypedef uint8_t ImapCmdFlags;          ///< Flags for imap_exec(), e.g. #IMAP_CMD_PASS\n#define IMAP_CMD_NO_FLAGS          0   ///< No flags are set\n#define IMAP_CMD_PASS        (1 << 0)  ///< Command contains a password. Suppress logging\n#define IMAP_CMD_QUEUE       (1 << 1)  ///< Queue a command, do not execute\n#define IMAP_CMD_POLL        (1 << 2)  ///< Poll the tcp connection before running the imap command\n\n/**\n * enum ImapExecResult - imap_exec return code\n */\nenum ImapExecResult\n{\n  IMAP_EXEC_SUCCESS = 0, ///< Imap command executed or queued successfully\n  IMAP_EXEC_ERROR,       ///< Imap command failure\n  IMAP_EXEC_FATAL,       ///< Imap connection failure\n};\n\n/* length of \"DD-MMM-YYYY HH:MM:SS +ZZzz\" (null-terminated) */\n#define IMAP_DATELEN 27\n\n/**\n * enum ImapFlags - IMAP server responses\n */\nenum ImapFlags\n{\n  IMAP_FATAL = 1, ///< Unrecoverable error occurred\n  IMAP_BYE,       ///< Logged out from server\n};\n\n/**\n * enum ImapState - IMAP connection state\n */\nenum ImapState\n{\n  /* States */\n  IMAP_DISCONNECTED = 0, ///< Disconnected from server\n  IMAP_CONNECTED,        ///< Connected to server\n  IMAP_AUTHENTICATED,    ///< Connection is authenticated\n  IMAP_SELECTED,         ///< Mailbox is selected\n\n  /* and pseudo-states */\n  IMAP_IDLE, ///< Connection is idle\n};\n\n/**\n * typedef ImapCapFlags - Capabilities we are interested in\n *\n * @note This must be kept in the same order as Capabilities.\n */\ntypedef uint32_t ImapCapFlags;              ///< Flags, e.g. #IMAP_CAP_IMAP4\n#define IMAP_CAP_NO_FLAGS                0  ///< No flags are set\n#define IMAP_CAP_IMAP4            (1 <<  0) ///< Server supports IMAP4\n#define IMAP_CAP_IMAP4REV1        (1 <<  1) ///< Server supports IMAP4rev1\n#define IMAP_CAP_STATUS           (1 <<  2) ///< Server supports STATUS command\n#define IMAP_CAP_ACL              (1 <<  3) ///< RFC2086: IMAP4 ACL extension\n#define IMAP_CAP_NAMESPACE        (1 <<  4) ///< RFC2342: IMAP4 Namespace\n#define IMAP_CAP_AUTH_CRAM_MD5    (1 <<  5) ///< RFC2195: CRAM-MD5 authentication\n#define IMAP_CAP_AUTH_GSSAPI      (1 <<  6) ///< RFC1731: GSSAPI authentication\n#define IMAP_CAP_AUTH_ANONYMOUS   (1 <<  7) ///< AUTH=ANONYMOUS\n#define IMAP_CAP_AUTH_OAUTHBEARER (1 <<  8) ///< RFC7628: AUTH=OAUTHBEARER\n#define IMAP_CAP_STARTTLS         (1 <<  9) ///< RFC2595: STARTTLS\n#define IMAP_CAP_LOGINDISABLED    (1 << 10) ///< RFC2595: LOGINDISABLED\n#define IMAP_CAP_IDLE             (1 << 11) ///< RFC2177: IDLE\n#define IMAP_CAP_SASL_IR          (1 << 12) ///< SASL initial response draft\n#define IMAP_CAP_ENABLE           (1 << 13) ///< RFC5161\n#define IMAP_CAP_CONDSTORE        (1 << 14) ///< RFC7162\n#define IMAP_CAP_QRESYNC          (1 << 15) ///< RFC7162\n#define IMAP_CAP_LIST_EXTENDED    (1 << 16) ///< RFC5258: IMAP4 LIST Command Extensions\n#define IMAP_CAP_COMPRESS         (1 << 17) ///< RFC4978: COMPRESS=DEFLATE\n#define IMAP_CAP_X_GM_EXT_1       (1 << 18) ///< https://developers.google.com/gmail/imap/imap-extensions\n\n#define IMAP_CAP_ALL             ((1 << 19) - 1)\n\n/**\n * struct ImapList - Items in an IMAP browser\n */\nstruct ImapList\n{\n  char *name;\n  char delim;\n  bool noselect;\n  bool noinferiors;\n};\n\n/**\n * struct ImapCommand - IMAP command structure\n */\nstruct ImapCommand\n{\n  char seq[SEQ_LEN + 1]; ///< Command tag, e.g. 'a0001'\n  int state;            ///< Command state, e.g. #IMAP_RES_NEW\n};\n\n/**\n * struct ImapAccountData - IMAP-specific Account data - @extends Account\n *\n * This data is specific to a Connection to an IMAP server\n */\nstruct ImapAccountData\n{\n  struct Connection *conn;\n  bool recovering;\n  bool closing; ///< If true, we are waiting for CLOSE completion\n  unsigned char state;  ///< ImapState, e.g. #IMAP_AUTHENTICATED\n  unsigned char status; ///< ImapFlags, e.g. #IMAP_FATAL\n  /* let me explain capstr: SASL needs the capability string (not bits).\n   * we have 3 options:\n   *   1. rerun CAPABILITY inside SASL function.\n   *   2. build appropriate CAPABILITY string by reverse-engineering from bits.\n   *   3. keep a copy until after authentication.\n   * I've chosen (3) for now. (2) might not be too bad, but it involves\n   * tracking all possible capabilities. bah. (1) I don't like because\n   * it's just no fun to get the same information twice */\n  char *capstr;\n  ImapCapFlags capabilities;\n  unsigned char seqid; ///< tag sequence prefix\n  unsigned int seqno; ///< tag sequence number, e.g. '{seqid}0001'\n  time_t lastread; ///< last time we read a command for the server\n  char *buf;\n  size_t blen;\n\n  bool unicode; ///< If true, we can send UTF-8, and the server will use UTF8 rather than mUTF7\n  bool qresync; ///< true, if QRESYNC is successfully ENABLE'd\n\n  // if set, the response parser will store results for complicated commands here\n  struct ImapList *cmdresult;\n\n  /* command queue */\n  struct ImapCommand *cmds;\n  int cmdslots;\n  int nextcmd;\n  int lastcmd;\n  struct Buffer cmdbuf;\n\n  char delim;\n  struct Mailbox *mailbox;      ///< Current selected mailbox\n  struct Mailbox *prev_mailbox; ///< Previously selected mailbox\n  struct Account *account;      ///< Parent Account\n};\n\n/**\n * struct ImapMboxData - IMAP-specific Mailbox data - @extends Mailbox\n *\n * This data is specific to a Mailbox of an IMAP server\n */\nstruct ImapMboxData\n{\n  char *name;        ///< Mailbox name\n  char *munge_name;  ///< Munged version of the mailbox name\n  char *real_name;   ///< Original Mailbox name, e.g.: INBOX can be just \\0\n\n  ImapOpenFlags reopen;        ///< Flags, e.g. #IMAP_REOPEN_ALLOW\n  ImapOpenFlags check_status;  ///< Flags, e.g. #IMAP_NEWMAIL_PENDING\n  unsigned int new_mail_count; ///< Set when EXISTS notifies of new mail\n\n  // IMAP STATUS information\n  struct ListHead flags;\n  uint32_t uidvalidity;\n  unsigned int uid_next;\n  unsigned long long modseq;\n  unsigned int messages;\n  unsigned int recent;\n  unsigned int unseen;\n\n  // Cached data used only when the mailbox is opened\n  struct HashTable *uid_hash;\n  struct Email **msn_index;   ///< look up headers by (MSN-1)\n  size_t msn_index_size;       ///< allocation size\n  unsigned int max_msn;        ///< the largest MSN fetched so far\n  struct BodyCache *bcache;\n\n  header_cache_t *hcache;\n};\n\n/**\n * struct SeqsetIterator - UID Sequence Set Iterator\n */\nstruct SeqsetIterator\n{\n  char *full_seqset;\n  char *eostr;\n  int in_range;\n  int down;\n  unsigned int range_cur;\n  unsigned int range_end;\n  char *substr_cur;\n  char *substr_end;\n};\n\n/* -- private IMAP functions -- */\n/* imap.c */\nint imap_create_mailbox(struct ImapAccountData *adata, char *mailbox);\nint imap_rename_mailbox(struct ImapAccountData *adata, char *oldname, const char *newname);\nint imap_exec_msgset(struct Mailbox *m, const char *pre, const char *post,\n                     int flag, bool changed, bool invert);\nint imap_open_connection(struct ImapAccountData *adata);\nvoid imap_close_connection(struct ImapAccountData *adata);\nint imap_read_literal(FILE *fp, struct ImapAccountData *adata, unsigned long bytes, struct Progress *pbar);\nvoid imap_expunge_mailbox(struct Mailbox *m);\nint imap_login(struct ImapAccountData *adata);\nint imap_sync_message_for_copy(struct Mailbox *m, struct Email *e, struct Buffer *cmd, enum QuadOption *err_continue);\nbool imap_has_flag(struct ListHead *flag_list, const char *flag);\nint imap_adata_find(const char *path, struct ImapAccountData **adata, struct ImapMboxData **mdata);\n\n/* auth.c */\nint imap_authenticate(struct ImapAccountData *adata);\n\n/* command.c */\nint imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr);\nint imap_cmd_step(struct ImapAccountData *adata);\nvoid imap_cmd_finish(struct ImapAccountData *adata);\nbool imap_code(const char *s);\nconst char *imap_cmd_trailer(struct ImapAccountData *adata);\nint imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags);\nint imap_cmd_idle(struct ImapAccountData *adata);\n\n/* message.c */\nvoid imap_edata_free(void **ptr);\nstruct ImapEmailData *imap_edata_get(struct Email *e);\nint imap_read_headers(struct Mailbox *m, unsigned int msn_begin, unsigned int msn_end, bool initial_download);\nchar *imap_set_flags(struct Mailbox *m, struct Email *e, char *s, bool *server_changes);\nint imap_cache_del(struct Mailbox *m, struct Email *e);\nint imap_cache_clean(struct Mailbox *m);\nint imap_append_message(struct Mailbox *m, struct Message *msg);\n\nint imap_msg_open(struct Mailbox *m, struct Message *msg, int msgno);\nint imap_msg_close(struct Mailbox *m, struct Message *msg);\nint imap_msg_commit(struct Mailbox *m, struct Message *msg);\nint imap_msg_save_hcache(struct Mailbox *m, struct Email *e);\n\n/* util.c */\nstruct ImapAccountData *imap_adata_get(struct Mailbox *m);\nstruct ImapMboxData *imap_mdata_get(struct Mailbox *m);\n#ifdef USE_HCACHE\nheader_cache_t *imap_hcache_open(struct ImapAccountData *adata, struct ImapMboxData *mdata);\nvoid imap_hcache_close(struct ImapMboxData *mdata);\nstruct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid);\nint imap_hcache_put(struct ImapMboxData *mdata, struct Email *e);\nint imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid);\nint imap_hcache_store_uid_seqset(struct ImapMboxData *mdata);\nint imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata);\nchar *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata);\n#endif\n\nenum QuadOption imap_continue(const char *msg, const char *resp);\nvoid imap_error(const char *where, const char *msg);\nstruct ImapAccountData *imap_adata_new(struct Account *a);\nvoid imap_adata_free(void **ptr);\nstruct ImapMboxData *imap_mdata_new(struct ImapAccountData *adata, const char* name);\nvoid imap_mdata_free(void **ptr);\nvoid imap_mdata_cache_reset(struct ImapMboxData *mdata);\nchar *imap_fix_path(char delim, const char *mailbox, char *path, size_t plen);\nvoid imap_cachepath(char delim, const char *mailbox, struct Buffer *dest);\nint imap_get_literal_count(const char *buf, unsigned int *bytes);\nchar *imap_get_qualifier(char *buf);\nchar *imap_next_word(char *s);\nvoid imap_qualify_path(char *buf, size_t buflen, struct ConnAccount *conn_account, char *path);\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\nvoid imap_unquote_string(char *s);\nvoid imap_munge_mbox_name(bool unicode, char *dest, size_t dlen, const char *src);\nvoid imap_unmunge_mbox_name(bool unicode, char *s);\nstruct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset);\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next);\nvoid mutt_seqset_iterator_free(struct SeqsetIterator **ptr);\nbool imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2);\nvoid imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen);\nbool  mutt_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2);\n\n/* utf7.c */\nvoid imap_utf_encode(bool unicode, char **s);\nvoid imap_utf_decode(bool unicode, char **s);\nvoid imap_allow_reopen(struct Mailbox *m);\nvoid imap_disallow_reopen(struct Mailbox *m);\n\n/* search.c */\nvoid cmd_parse_search(struct ImapAccountData *adata, const char *s);\n\n#endif /* MUTT_IMAP_PRIVATE_H */\n", "/**\n * @file\n * Usenet network mailbox type; talk to an NNTP server\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page nntp_nntp Usenet network mailbox type; talk to an NNTP server\n *\n * Usenet network mailbox type; talk to an NNTP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n#include <unistd.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"lib.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"init.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_parse.h\"\n#include \"mutt_socket.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"progress.h\"\n#include \"sort.h\"\n#include \"bcache/lib.h\"\n#include \"hcache/lib.h\"\n#include \"ncrypt/lib.h\"\n#ifdef USE_HCACHE\n#include \"protos.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#endif\n#if defined(USE_SSL) || defined(USE_HCACHE)\n#include \"mutt.h\"\n#endif\n\nstruct stat;\n\n/* These Config Variables are only used in nntp/nntp.c */\nchar *C_NntpAuthenticators; ///< Config: (nntp) Allowed authentication methods\nshort C_NntpContext; ///< Config: (nntp) Maximum number of articles to list (0 for all articles)\nbool C_NntpListgroup; ///< Config: (nntp) Check all articles when opening a newsgroup\nbool C_NntpLoadDescription; ///< Config: (nntp) Load descriptions for newsgroups when adding to the list\nshort C_NntpPoll; ///< Config: (nntp) Interval between checks for new posts\nbool C_ShowNewNews; ///< Config: (nntp) Check for new newsgroups when entering the browser\n\nstruct NntpAccountData *CurrentNewsSrv;\n\nconst char *OverviewFmt = \"Subject:\\0\"\n                          \"From:\\0\"\n                          \"Date:\\0\"\n                          \"Message-ID:\\0\"\n                          \"References:\\0\"\n                          \"Content-Length:\\0\"\n                          \"Lines:\\0\"\n                          \"\\0\";\n\n/**\n * struct FetchCtx - Keep track when getting data from a server\n */\nstruct FetchCtx\n{\n  struct Mailbox *mailbox;\n  anum_t first;\n  anum_t last;\n  bool restore;\n  unsigned char *messages;\n  struct Progress progress;\n  header_cache_t *hc;\n};\n\n/**\n * struct ChildCtx - Keep track of the children of an article\n */\nstruct ChildCtx\n{\n  struct Mailbox *mailbox;\n  unsigned int num;\n  unsigned int max;\n  anum_t *child;\n};\n\n/**\n * nntp_adata_free - Free data attached to the Mailbox\n * @param[out] ptr NNTP data\n *\n * The NntpAccountData struct stores global NNTP data, such as the connection to\n * the database.  This function will close the database, free the resources and\n * the struct itself.\n */\nstatic void nntp_adata_free(void **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct NntpAccountData *adata = *ptr;\n\n  mutt_file_fclose(&adata->fp_newsrc);\n  FREE(&adata->newsrc_file);\n  FREE(&adata->authenticators);\n  FREE(&adata->overview_fmt);\n  FREE(&adata->conn);\n  FREE(&adata->groups_list);\n  mutt_hash_free(&adata->groups_hash);\n  FREE(ptr);\n}\n\n/**\n * nntp_hashelem_free - Free our hash table data - Implements ::hash_hdata_free_t\n */\nstatic void nntp_hashelem_free(int type, void *obj, intptr_t data)\n{\n  nntp_mdata_free(&obj);\n}\n\n/**\n * nntp_adata_new - Allocate and initialise a new NntpAccountData structure\n * @param conn Network connection\n * @retval ptr New NntpAccountData\n */\nstruct NntpAccountData *nntp_adata_new(struct Connection *conn)\n{\n  struct NntpAccountData *adata = mutt_mem_calloc(1, sizeof(struct NntpAccountData));\n  adata->conn = conn;\n  adata->groups_hash = mutt_hash_new(1009, MUTT_HASH_NO_FLAGS);\n  mutt_hash_set_destructor(adata->groups_hash, nntp_hashelem_free, 0);\n  adata->groups_max = 16;\n  adata->groups_list =\n      mutt_mem_malloc(adata->groups_max * sizeof(struct NntpMboxData *));\n  return adata;\n}\n\n#if 0\n/**\n * nntp_adata_get - Get the Account data for this mailbox\n * @retval ptr Private Account data\n */\nstruct NntpAccountData *nntp_adata_get(struct Mailbox *m)\n{\n  if (!m || (m->type != MUTT_NNTP))\n    return NULL;\n  struct Account *a = m->account;\n  if (!a)\n    return NULL;\n  return a->adata;\n}\n#endif\n\n/**\n * nntp_mdata_free - Free NntpMboxData, used to destroy hash elements\n * @param[out] ptr NNTP data\n */\nvoid nntp_mdata_free(void **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct NntpMboxData *mdata = *ptr;\n\n  nntp_acache_free(mdata);\n  mutt_bcache_close(&mdata->bcache);\n  FREE(&mdata->newsrc_ent);\n  FREE(&mdata->desc);\n  FREE(ptr);\n}\n\n/**\n * nntp_edata_free - Free data attached to an Email\n * @param[out] ptr Email data\n */\nstatic void nntp_edata_free(void **ptr)\n{\n  // struct NntpEmailData *edata = *ptr;\n  FREE(ptr);\n}\n\n/**\n * nntp_edata_new - Create a new NntpEmailData for an Email\n * @retval ptr New NntpEmailData struct\n */\nstatic struct NntpEmailData *nntp_edata_new(void)\n{\n  return mutt_mem_calloc(1, sizeof(struct NntpEmailData));\n}\n\n/**\n * nntp_edata_get - Get the private data for this Email\n * @param e Email\n * @retval ptr Private Email data\n */\nstruct NntpEmailData *nntp_edata_get(struct Email *e)\n{\n  if (!e)\n    return NULL;\n  return e->edata;\n}\n\n/**\n * nntp_connect_error - Signal a failed connection\n * @param adata NNTP server\n * @retval -1 Always\n */\nstatic int nntp_connect_error(struct NntpAccountData *adata)\n{\n  adata->status = NNTP_NONE;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}\n\n/**\n * nntp_capabilities - Get capabilities\n * @param adata NNTP server\n * @retval -1 Error, connection is closed\n * @retval  0 Mode is reader, capabilities set up\n * @retval  1 Need to switch to reader mode\n */\nstatic int nntp_capabilities(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  bool mode_reader = false;\n  char buf[1024];\n  char authinfo[1024] = { 0 };\n\n  adata->hasCAPABILITIES = false;\n  adata->hasSTARTTLS = false;\n  adata->hasDATE = false;\n  adata->hasLIST_NEWSGROUPS = false;\n  adata->hasLISTGROUP = false;\n  adata->hasLISTGROUPrange = false;\n  adata->hasOVER = false;\n  FREE(&adata->authenticators);\n\n  if ((mutt_socket_send(conn, \"CAPABILITIES\\r\\n\") < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n  {\n    return nntp_connect_error(adata);\n  }\n\n  /* no capabilities */\n  if (!mutt_str_startswith(buf, \"101\", CASE_MATCH))\n    return 1;\n  adata->hasCAPABILITIES = true;\n\n  /* parse capabilities */\n  do\n  {\n    size_t plen = 0;\n    if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      return nntp_connect_error(adata);\n    if (mutt_str_strcmp(\"STARTTLS\", buf) == 0)\n      adata->hasSTARTTLS = true;\n    else if (mutt_str_strcmp(\"MODE-READER\", buf) == 0)\n      mode_reader = true;\n    else if (mutt_str_strcmp(\"READER\", buf) == 0)\n    {\n      adata->hasDATE = true;\n      adata->hasLISTGROUP = true;\n      adata->hasLISTGROUPrange = true;\n    }\n    else if ((plen = mutt_str_startswith(buf, \"AUTHINFO \", CASE_MATCH)))\n    {\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n      mutt_str_strfcpy(authinfo, buf + plen - 1, sizeof(authinfo));\n    }\n#ifdef USE_SASL\n    else if ((plen = mutt_str_startswith(buf, \"SASL \", CASE_MATCH)))\n    {\n      char *p = buf + plen;\n      while (*p == ' ')\n        p++;\n      adata->authenticators = mutt_str_strdup(p);\n    }\n#endif\n    else if (mutt_str_strcmp(\"OVER\", buf) == 0)\n      adata->hasOVER = true;\n    else if (mutt_str_startswith(buf, \"LIST \", CASE_MATCH))\n    {\n      char *p = strstr(buf, \" NEWSGROUPS\");\n      if (p)\n      {\n        p += 11;\n        if ((*p == '\\0') || (*p == ' '))\n          adata->hasLIST_NEWSGROUPS = true;\n      }\n    }\n  } while (mutt_str_strcmp(\".\", buf) != 0);\n  *buf = '\\0';\n#ifdef USE_SASL\n  if (adata->authenticators && strcasestr(authinfo, \" SASL \"))\n    mutt_str_strfcpy(buf, adata->authenticators, sizeof(buf));\n#endif\n  if (strcasestr(authinfo, \" USER \"))\n  {\n    if (*buf != '\\0')\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n    mutt_str_strcat(buf, sizeof(buf), \"USER\");\n  }\n  mutt_str_replace(&adata->authenticators, buf);\n\n  /* current mode is reader */\n  if (adata->hasDATE)\n    return 0;\n\n  /* server is mode-switching, need to switch to reader mode */\n  if (mode_reader)\n    return 1;\n\n  mutt_socket_close(conn);\n  adata->status = NNTP_BYE;\n  mutt_error(_(\"Server doesn't support reader mode\"));\n  return -1;\n}\n\n/**\n * nntp_attempt_features - Detect supported commands\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_attempt_features(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[1024];\n\n  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */\n  if (!adata->hasCAPABILITIES)\n  {\n    if ((mutt_socket_send(conn, \"DATE\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasDATE = true;\n\n    if ((mutt_socket_send(conn, \"LISTGROUP\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasLISTGROUP = true;\n\n    if ((mutt_socket_send(conn, \"LIST NEWSGROUPS +\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasLIST_NEWSGROUPS = true;\n    if (mutt_str_startswith(buf, \"215\", CASE_MATCH))\n    {\n      do\n      {\n        if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          return nntp_connect_error(adata);\n      } while (mutt_str_strcmp(\".\", buf) != 0);\n    }\n  }\n\n  /* no LIST NEWSGROUPS, trying XGTITLE */\n  if (!adata->hasLIST_NEWSGROUPS)\n  {\n    if ((mutt_socket_send(conn, \"XGTITLE\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasXGTITLE = true;\n  }\n\n  /* no OVER, trying XOVER */\n  if (!adata->hasOVER)\n  {\n    if ((mutt_socket_send(conn, \"XOVER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasXOVER = true;\n  }\n\n  /* trying LIST OVERVIEW.FMT */\n  if (adata->hasOVER || adata->hasXOVER)\n  {\n    if ((mutt_socket_send(conn, \"LIST OVERVIEW.FMT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"215\", CASE_MATCH))\n      adata->overview_fmt = mutt_str_strdup(OverviewFmt);\n    else\n    {\n      bool cont = false;\n      size_t buflen = 2048, off = 0, b = 0;\n\n      FREE(&adata->overview_fmt);\n      adata->overview_fmt = mutt_mem_malloc(buflen);\n\n      while (true)\n      {\n        if ((buflen - off) < 1024)\n        {\n          buflen *= 2;\n          mutt_mem_realloc(&adata->overview_fmt, buflen);\n        }\n\n        const int chunk = mutt_socket_readln_d(adata->overview_fmt + off,\n                                               buflen - off, conn, MUTT_SOCK_LOG_HDR);\n        if (chunk < 0)\n        {\n          FREE(&adata->overview_fmt);\n          return nntp_connect_error(adata);\n        }\n\n        if (!cont && (mutt_str_strcmp(\".\", adata->overview_fmt + off) == 0))\n          break;\n\n        cont = (chunk >= (buflen - off));\n        off += strlen(adata->overview_fmt + off);\n        if (!cont)\n        {\n          if (adata->overview_fmt[b] == ':')\n          {\n            memmove(adata->overview_fmt + b, adata->overview_fmt + b + 1, off - b - 1);\n            adata->overview_fmt[off - 1] = ':';\n          }\n          char *colon = strchr(adata->overview_fmt + b, ':');\n          if (!colon)\n            adata->overview_fmt[off++] = ':';\n          else if (strcmp(colon + 1, \"full\") != 0)\n            off = colon + 1 - adata->overview_fmt;\n          if (strcasecmp(adata->overview_fmt + b, \"Bytes:\") == 0)\n          {\n            size_t len = strlen(adata->overview_fmt + b);\n            mutt_str_strfcpy(adata->overview_fmt + b, \"Content-Length:\", len + 1);\n            off = b + len;\n          }\n          adata->overview_fmt[off++] = '\\0';\n          b = off;\n        }\n      }\n      adata->overview_fmt[off++] = '\\0';\n      mutt_mem_realloc(&adata->overview_fmt, off);\n    }\n  }\n  return 0;\n}\n\n#ifdef USE_SASL\n/**\n * nntp_memchr - look for a char in a binary buf, conveniently\n * @param haystack [in/out] input: start here, output: store address of hit\n * @param sentinel points just beyond (1 byte after) search area\n * @param needle the character to search for\n * @retval true found and updated haystack\n * @retval false not found\n */\nstatic bool nntp_memchr(char **haystack, char *sentinel, int needle)\n{\n  char *start = *haystack;\n  size_t max_offset = sentinel - start;\n  void *vp = memchr(start, max_offset, needle);\n  if (!vp)\n    return false;\n  *haystack = vp;\n  return true;\n}\n\n/**\n * nntp_log_binbuf - log a buffer possibly containing NUL bytes\n * @param buf source buffer\n * @param len how many bytes from buf\n * @param pfx logging prefix (protocol etc.)\n * @param dbg which loglevel does message belong\n */\nstatic void nntp_log_binbuf(const char *buf, size_t len, const char *pfx, int dbg)\n{\n  char tmp[1024];\n  char *p = tmp;\n  char *sentinel = tmp + len;\n\n  if (C_DebugLevel < dbg)\n    return;\n  memcpy(tmp, buf, len);\n  tmp[len] = '\\0';\n  while (nntp_memchr(&p, sentinel, '\\0'))\n    *p = '.';\n  mutt_debug(dbg, \"%s> %s\\n\", pfx, tmp);\n}\n#endif\n\n/**\n * nntp_auth - Get login, password and authenticate\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_auth(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[1024];\n  char authenticators[1024] = \"USER\";\n  char *method = NULL, *a = NULL, *p = NULL;\n  unsigned char flags = conn->account.flags;\n\n  while (true)\n  {\n    /* get login and password */\n    if ((mutt_account_getuser(&conn->account) < 0) || (conn->account.user[0] == '\\0') ||\n        (mutt_account_getpass(&conn->account) < 0) || (conn->account.pass[0] == '\\0'))\n    {\n      break;\n    }\n\n    /* get list of authenticators */\n    if (C_NntpAuthenticators)\n      mutt_str_strfcpy(authenticators, C_NntpAuthenticators, sizeof(authenticators));\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_str_strfcpy(authenticators, adata->authenticators, sizeof(authenticators));\n      p = authenticators;\n      while (*p)\n      {\n        if (*p == ' ')\n          *p = ':';\n        p++;\n      }\n    }\n    p = authenticators;\n    while (*p)\n    {\n      *p = toupper(*p);\n      p++;\n    }\n\n    mutt_debug(LL_DEBUG1, \"available methods: %s\\n\", adata->authenticators);\n    a = authenticators;\n    while (true)\n    {\n      if (!a)\n      {\n        mutt_error(_(\"No authenticators available\"));\n        break;\n      }\n\n      method = a;\n      a = strchr(a, ':');\n      if (a)\n        *a++ = '\\0';\n\n      /* check authenticator */\n      if (adata->hasCAPABILITIES)\n      {\n        char *m = NULL;\n\n        if (!adata->authenticators)\n          continue;\n        m = strcasestr(adata->authenticators, method);\n        if (!m)\n          continue;\n        if ((m > adata->authenticators) && (*(m - 1) != ' '))\n          continue;\n        m += strlen(method);\n        if ((*m != '\\0') && (*m != ' '))\n          continue;\n      }\n      mutt_debug(LL_DEBUG1, \"trying method %s\\n\", method);\n\n      /* AUTHINFO USER authentication */\n      if (strcmp(method, \"USER\") == 0)\n      {\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO USER %s\\r\\n\", conn->account.user);\n        if ((mutt_socket_send(conn, buf) < 0) ||\n            (mutt_socket_readln_d(buf, sizeof(buf), conn, MUTT_SOCK_LOG_FULL) < 0))\n        {\n          break;\n        }\n\n        /* authenticated, password is not required */\n        if (mutt_str_startswith(buf, \"281\", CASE_MATCH))\n          return 0;\n\n        /* username accepted, sending password */\n        if (mutt_str_startswith(buf, \"381\", CASE_MATCH))\n        {\n          mutt_debug(MUTT_SOCK_LOG_FULL, \"%d> AUTHINFO PASS *\\n\", conn->fd);\n          snprintf(buf, sizeof(buf), \"AUTHINFO PASS %s\\r\\n\", conn->account.pass);\n          if ((mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0) ||\n              (mutt_socket_readln_d(buf, sizeof(buf), conn, MUTT_SOCK_LOG_FULL) < 0))\n          {\n            break;\n          }\n\n          /* authenticated */\n          if (mutt_str_startswith(buf, \"281\", CASE_MATCH))\n            return 0;\n        }\n\n        /* server doesn't support AUTHINFO USER, trying next method */\n        if (*buf == '5')\n          continue;\n      }\n      else\n      {\n#ifdef USE_SASL\n        sasl_conn_t *saslconn = NULL;\n        sasl_interact_t *interaction = NULL;\n        int rc;\n        char inbuf[1024] = { 0 };\n        const char *mech = NULL;\n        const char *client_out = NULL;\n        unsigned int client_len, len;\n\n        if (mutt_sasl_client_new(conn, &saslconn) < 0)\n        {\n          mutt_debug(LL_DEBUG1, \"error allocating SASL connection\\n\");\n          continue;\n        }\n\n        while (true)\n        {\n          rc = sasl_client_start(saslconn, method, &interaction, &client_out,\n                                 &client_len, &mech);\n          if (rc != SASL_INTERACT)\n            break;\n          mutt_sasl_interact(interaction);\n        }\n        if ((rc != SASL_OK) && (rc != SASL_CONTINUE))\n        {\n          sasl_dispose(&saslconn);\n          mutt_debug(LL_DEBUG1,\n                     \"error starting SASL authentication exchange\\n\");\n          continue;\n        }\n\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO SASL %s\", method);\n\n        /* looping protocol */\n        while ((rc == SASL_CONTINUE) || ((rc == SASL_OK) && client_len))\n        {\n          /* send out client response */\n          if (client_len)\n          {\n            nntp_log_binbuf(client_out, client_len, \"SASL\", MUTT_SOCK_LOG_FULL);\n            if (*buf != '\\0')\n              mutt_str_strcat(buf, sizeof(buf), \" \");\n            len = strlen(buf);\n            if (sasl_encode64(client_out, client_len, buf + len,\n                              sizeof(buf) - len, &len) != SASL_OK)\n            {\n              mutt_debug(LL_DEBUG1, \"error base64-encoding client response\\n\");\n              break;\n            }\n          }\n\n          mutt_str_strcat(buf, sizeof(buf), \"\\r\\n\");\n          if (strchr(buf, ' '))\n          {\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO SASL %s%s\\n\", conn->fd,\n                       method, client_len ? \" sasl_data\" : \"\");\n          }\n          else\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> sasl_data\\n\", conn->fd);\n          client_len = 0;\n          if ((mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0) ||\n              (mutt_socket_readln_d(inbuf, sizeof(inbuf), conn, MUTT_SOCK_LOG_FULL) < 0))\n          {\n            break;\n          }\n          if (!mutt_str_startswith(inbuf, \"283 \", CASE_MATCH) &&\n              !mutt_str_startswith(inbuf, \"383 \", CASE_MATCH))\n          {\n            mutt_debug(MUTT_SOCK_LOG_FULL, \"%d< %s\\n\", conn->fd, inbuf);\n            break;\n          }\n          inbuf[3] = '\\0';\n          mutt_debug(MUTT_SOCK_LOG_FULL, \"%d< %s sasl_data\\n\", conn->fd, inbuf);\n\n          if (strcmp(\"=\", inbuf + 4) == 0)\n            len = 0;\n          else if (sasl_decode64(inbuf + 4, strlen(inbuf + 4), buf,\n                                 sizeof(buf) - 1, &len) != SASL_OK)\n          {\n            mutt_debug(LL_DEBUG1, \"error base64-decoding server response\\n\");\n            break;\n          }\n          else\n            nntp_log_binbuf(buf, len, \"SASL\", MUTT_SOCK_LOG_FULL);\n\n          while (true)\n          {\n            rc = sasl_client_step(saslconn, buf, len, &interaction, &client_out, &client_len);\n            if (rc != SASL_INTERACT)\n              break;\n            mutt_sasl_interact(interaction);\n          }\n          if (*inbuf != '3')\n            break;\n\n          *buf = '\\0';\n        } /* looping protocol */\n\n        if ((rc == SASL_OK) && (client_len == 0) && (*inbuf == '2'))\n        {\n          mutt_sasl_setup_conn(conn, saslconn);\n          return 0;\n        }\n\n        /* terminate SASL session */\n        sasl_dispose(&saslconn);\n        if (conn->fd < 0)\n          break;\n        if (mutt_str_startswith(inbuf, \"383 \", CASE_MATCH))\n        {\n          if ((mutt_socket_send(conn, \"*\\r\\n\") < 0) ||\n              (mutt_socket_readln(inbuf, sizeof(inbuf), conn) < 0))\n          {\n            break;\n          }\n        }\n\n        /* server doesn't support AUTHINFO SASL, trying next method */\n        if (*inbuf == '5')\n          continue;\n#else\n        continue;\n#endif /* USE_SASL */\n      }\n\n      mutt_error(_(\"%s authentication failed\"), method);\n      break;\n    }\n    break;\n  }\n\n  /* error */\n  adata->status = NNTP_BYE;\n  conn->account.flags = flags;\n  if (conn->fd < 0)\n  {\n    mutt_error(_(\"Server closed connection\"));\n  }\n  else\n    mutt_socket_close(conn);\n  return -1;\n}\n\n/**\n * nntp_query - Send data from buffer and receive answer to same buffer\n * @param mdata NNTP Mailbox data\n * @param line      Buffer containing data\n * @param linelen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_query(struct NntpMboxData *mdata, char *line, size_t linelen)\n{\n  struct NntpAccountData *adata = mdata->adata;\n  char buf[1024] = { 0 };\n\n  if (adata->status == NNTP_BYE)\n    return -1;\n\n  while (true)\n  {\n    if (adata->status == NNTP_OK)\n    {\n      int rc = 0;\n\n      if (*line)\n        rc = mutt_socket_send(adata->conn, line);\n      else if (mdata->group)\n      {\n        snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", mdata->group);\n        rc = mutt_socket_send(adata->conn, buf);\n      }\n      if (rc >= 0)\n        rc = mutt_socket_readln(buf, sizeof(buf), adata->conn);\n      if (rc >= 0)\n        break;\n    }\n\n    /* reconnect */\n    while (true)\n    {\n      adata->status = NNTP_NONE;\n      if (nntp_open_connection(adata) == 0)\n        break;\n\n      snprintf(buf, sizeof(buf), _(\"Connection to %s lost. Reconnect?\"),\n               adata->conn->account.host);\n      if (mutt_yesorno(buf, MUTT_YES) != MUTT_YES)\n      {\n        adata->status = NNTP_BYE;\n        return -1;\n      }\n    }\n\n    /* select newsgroup after reconnection */\n    if (mdata->group)\n    {\n      snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", mdata->group);\n      if ((mutt_socket_send(adata->conn, buf) < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), adata->conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n    }\n    if (*line == '\\0')\n      break;\n  }\n\n  mutt_str_strfcpy(line, buf, linelen);\n  return 0;\n}\n\n/**\n * nntp_fetch_lines - Read lines, calling a callback function for each\n * @param mdata NNTP Mailbox data\n * @param query     Query to match\n * @param qlen      Length of query\n * @param msg       Progress message (OPTIONAL)\n * @param func      Callback function\n * @param data      Data for callback function\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error in func(*line, *data)\n *\n * This function calls func(*line, *data) for each received line,\n * func(NULL, *data) if rewind(*data) needs, exits when fail or done:\n */\nstatic int nntp_fetch_lines(struct NntpMboxData *mdata, char *query, size_t qlen,\n                            const char *msg, int (*func)(char *, void *), void *data)\n{\n  bool done = false;\n  int rc;\n\n  while (!done)\n  {\n    char buf[1024];\n    char *line = NULL;\n    unsigned int lines = 0;\n    size_t off = 0;\n    struct Progress progress;\n\n    if (msg)\n      mutt_progress_init(&progress, msg, MUTT_PROGRESS_READ, 0);\n\n    mutt_str_strfcpy(buf, query, sizeof(buf));\n    if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n      return -1;\n    if (buf[0] != '2')\n    {\n      mutt_str_strfcpy(query, buf, qlen);\n      return 1;\n    }\n\n    line = mutt_mem_malloc(sizeof(buf));\n    rc = 0;\n\n    while (true)\n    {\n      char *p = NULL;\n      int chunk = mutt_socket_readln_d(buf, sizeof(buf), mdata->adata->conn, MUTT_SOCK_LOG_FULL);\n      if (chunk < 0)\n      {\n        mdata->adata->status = NNTP_NONE;\n        break;\n      }\n\n      p = buf;\n      if (!off && (buf[0] == '.'))\n      {\n        if (buf[1] == '\\0')\n        {\n          done = true;\n          break;\n        }\n        if (buf[1] == '.')\n          p++;\n      }\n\n      mutt_str_strfcpy(line + off, p, sizeof(buf));\n\n      if (chunk >= sizeof(buf))\n        off += strlen(p);\n      else\n      {\n        if (msg)\n          mutt_progress_update(&progress, ++lines, -1);\n\n        if ((rc == 0) && (func(line, data) < 0))\n          rc = -2;\n        off = 0;\n      }\n\n      mutt_mem_realloc(&line, off + sizeof(buf));\n    }\n    FREE(&line);\n    func(NULL, data);\n  }\n  return rc;\n}\n\n/**\n * fetch_description - Parse newsgroup description\n * @param line String to parse\n * @param data NNTP Server\n * @retval 0 Always\n */\nstatic int fetch_description(char *line, void *data)\n{\n  if (!line)\n    return 0;\n\n  struct NntpAccountData *adata = data;\n\n  char *desc = strpbrk(line, \" \\t\");\n  if (desc)\n  {\n    *desc++ = '\\0';\n    desc += strspn(desc, \" \\t\");\n  }\n  else\n    desc = strchr(line, '\\0');\n\n  struct NntpMboxData *mdata = mutt_hash_find(adata->groups_hash, line);\n  if (mdata && (mutt_str_strcmp(desc, mdata->desc) != 0))\n  {\n    mutt_str_replace(&mdata->desc, desc);\n    mutt_debug(LL_DEBUG2, \"group: %s, desc: %s\\n\", line, desc);\n  }\n  return 0;\n}\n\n/**\n * get_description - Fetch newsgroups descriptions\n * @param mdata NNTP Mailbox data\n * @param wildmat   String to match\n * @param msg       Progress message\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error\n */\nstatic int get_description(struct NntpMboxData *mdata, const char *wildmat, const char *msg)\n{\n  char buf[256];\n  const char *cmd = NULL;\n\n  /* get newsgroup description, if possible */\n  struct NntpAccountData *adata = mdata->adata;\n  if (!wildmat)\n    wildmat = mdata->group;\n  if (adata->hasLIST_NEWSGROUPS)\n    cmd = \"LIST NEWSGROUPS\";\n  else if (adata->hasXGTITLE)\n    cmd = \"XGTITLE\";\n  else\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", cmd, wildmat);\n  int rc = nntp_fetch_lines(mdata, buf, sizeof(buf), msg, fetch_description, adata);\n  if (rc > 0)\n  {\n    mutt_error(\"%s: %s\", cmd, buf);\n  }\n  return rc;\n}\n\n/**\n * nntp_parse_xref - Parse cross-reference\n * @param m Mailbox\n * @param e Email\n *\n * Update read flag and set article number if empty\n */\nstatic void nntp_parse_xref(struct Mailbox *m, struct Email *e)\n{\n  struct NntpMboxData *mdata = m->mdata;\n\n  char *buf = mutt_str_strdup(e->env->xref);\n  char *p = buf;\n  while (p)\n  {\n    anum_t anum;\n\n    /* skip to next word */\n    p += strspn(p, \" \\t\");\n    char *grp = p;\n\n    /* skip to end of word */\n    p = strpbrk(p, \" \\t\");\n    if (p)\n      *p++ = '\\0';\n\n    /* find colon */\n    char *colon = strchr(grp, ':');\n    if (!colon)\n      continue;\n    *colon++ = '\\0';\n    if (sscanf(colon, ANUM, &anum) != 1)\n      continue;\n\n    nntp_article_status(m, e, grp, anum);\n    if (!nntp_edata_get(e)->article_num && (mutt_str_strcmp(mdata->group, grp) == 0))\n      nntp_edata_get(e)->article_num = anum;\n  }\n  FREE(&buf);\n}\n\n/**\n * fetch_tempfile - Write line to temporary file\n * @param line Text to write\n * @param data FILE pointer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_tempfile(char *line, void *data)\n{\n  FILE *fp = data;\n\n  if (!line)\n    rewind(fp);\n  else if ((fputs(line, fp) == EOF) || (fputc('\\n', fp) == EOF))\n    return -1;\n  return 0;\n}\n\n/**\n * fetch_numbers - Parse article number\n * @param line Article number\n * @param data FetchCtx\n * @retval 0 Always\n */\nstatic int fetch_numbers(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  if ((anum < fc->first) || (anum > fc->last))\n    return 0;\n  fc->messages[anum - fc->first] = 1;\n  return 0;\n}\n\n/**\n * parse_overview_line - Parse overview line\n * @param line String to parse\n * @param data FetchCtx\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int parse_overview_line(char *line, void *data)\n{\n  if (!line || !data)\n    return 0;\n\n  struct FetchCtx *fc = data;\n  struct Mailbox *m = fc->mailbox;\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct Email *e = NULL;\n  char *header = NULL, *field = NULL;\n  bool save = true;\n  anum_t anum;\n\n  /* parse article number */\n  field = strchr(line, '\\t');\n  if (field)\n    *field++ = '\\0';\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  mutt_debug(LL_DEBUG2, \"\" ANUM \"\\n\", anum);\n\n  /* out of bounds */\n  if ((anum < fc->first) || (anum > fc->last))\n    return 0;\n\n  /* not in LISTGROUP */\n  if (!fc->messages[anum - fc->first])\n  {\n    /* progress */\n    if (m->verbose)\n      mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n    return 0;\n  }\n\n  /* convert overview line to header */\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n    return -1;\n\n  header = mdata->adata->overview_fmt;\n  while (field)\n  {\n    char *b = field;\n\n    if (*header)\n    {\n      if (!strstr(header, \":full\") && (fputs(header, fp) == EOF))\n      {\n        mutt_file_fclose(&fp);\n        return -1;\n      }\n      header = strchr(header, '\\0') + 1;\n    }\n\n    field = strchr(field, '\\t');\n    if (field)\n      *field++ = '\\0';\n    if ((fputs(b, fp) == EOF) || (fputc('\\n', fp) == EOF))\n    {\n      mutt_file_fclose(&fp);\n      return -1;\n    }\n  }\n  rewind(fp);\n\n  /* allocate memory for headers */\n  if (m->msg_count >= m->email_max)\n    mx_alloc_memory(m);\n\n  /* parse header */\n  m->emails[m->msg_count] = email_new();\n  e = m->emails[m->msg_count];\n  e->env = mutt_rfc822_read_header(fp, e, false, false);\n  e->env->newsgroups = mutt_str_strdup(mdata->group);\n  e->received = e->date_sent;\n  mutt_file_fclose(&fp);\n\n#ifdef USE_HCACHE\n  if (fc->hc)\n  {\n    char buf[16];\n\n    /* try to replace with header from cache */\n    snprintf(buf, sizeof(buf), \"%u\", anum);\n    struct HCacheEntry hce = mutt_hcache_fetch(fc->hc, buf, strlen(buf), 0);\n    if (hce.email)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_fetch %s\\n\", buf);\n      email_free(&e);\n      e = hce.email;\n      m->emails[m->msg_count] = e;\n      e->edata = NULL;\n      e->read = false;\n      e->old = false;\n\n      /* skip header marked as deleted in cache */\n      if (e->deleted && !fc->restore)\n      {\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        save = false;\n      }\n    }\n\n    /* not cached yet, store header */\n    else\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(fc->hc, buf, strlen(buf), e, 0);\n    }\n  }\n#endif\n\n  if (save)\n  {\n    e->index = m->msg_count++;\n    e->read = false;\n    e->old = false;\n    e->deleted = false;\n    e->edata = nntp_edata_new();\n    e->edata_free = nntp_edata_free;\n    nntp_edata_get(e)->article_num = anum;\n    if (fc->restore)\n      e->changed = true;\n    else\n    {\n      nntp_article_status(m, e, NULL, anum);\n      if (!e->read)\n        nntp_parse_xref(m, e);\n    }\n    if (anum > mdata->last_loaded)\n      mdata->last_loaded = anum;\n  }\n  else\n    email_free(&e);\n\n  /* progress */\n  if (m->verbose)\n    mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n  return 0;\n}\n\n/**\n * nntp_fetch_headers - Fetch headers\n * @param m       Mailbox\n * @param hc      Header cache\n * @param first   Number of first header to fetch\n * @param last    Number of last header to fetch\n * @param restore Restore message listed as deleted\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_fetch_headers(struct Mailbox *m, void *hc, anum_t first, anum_t last, bool restore)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct FetchCtx fc;\n  struct Email *e = NULL;\n  char buf[8192];\n  int rc = 0;\n  anum_t current;\n  anum_t first_over = first;\n\n  /* if empty group or nothing to do */\n  if (!last || (first > last))\n    return 0;\n\n  /* init fetch context */\n  fc.mailbox = m;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (!fc.messages)\n    return -1;\n  fc.hc = hc;\n\n  /* fetch list of articles */\n  if (C_NntpListgroup && mdata->adata->hasLISTGROUP && !mdata->deleted)\n  {\n    if (m->verbose)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (mdata->adata->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", mdata->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", mdata->group);\n    rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(LL_DEBUG2, \"mutt_hcache_delete_header %s\\n\", buf);\n          mutt_hcache_delete_header(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (m->verbose)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_READ, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (m->verbose)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (m->msg_count >= m->email_max)\n      mx_alloc_memory(m);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    struct HCacheEntry hce = mutt_hcache_fetch(fc.hc, buf, strlen(buf), 0);\n    if (hce.email)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_fetch %s\\n\", buf);\n      e = hce.email;\n      m->emails[m->msg_count] = e;\n      e->edata = NULL;\n\n      /* skip header marked as deleted in cache */\n      if (e->deleted && !restore)\n      {\n        email_free(&e);\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        continue;\n      }\n\n      e->read = false;\n      e->old = false;\n    }\n    else\n#endif\n        if (mdata->deleted)\n    {\n      /* don't try to fetch header from removed newsgroup */\n      continue;\n    }\n\n    /* fallback to fetch overview */\n    else if (mdata->adata->hasOVER || mdata->adata->hasXOVER)\n    {\n      if (C_NntpListgroup && mdata->adata->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(_(\"Can't create temporary file\"));\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (!mutt_str_startswith(buf, \"423\", CASE_MATCH))\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (mdata->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(LL_DEBUG2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      m->emails[m->msg_count] = email_new();\n      e = m->emails[m->msg_count];\n      e->env = mutt_rfc822_read_header(fp, e, false, false);\n      e->received = e->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    e->index = m->msg_count++;\n    e->read = false;\n    e->old = false;\n    e->deleted = false;\n    e->edata = nntp_edata_new();\n    e->edata_free = nntp_edata_free;\n    nntp_edata_get(e)->article_num = current;\n    if (restore)\n      e->changed = true;\n    else\n    {\n      nntp_article_status(m, e, NULL, nntp_edata_get(e)->article_num);\n      if (!e->read)\n        nntp_parse_xref(m, e);\n    }\n    if (current > mdata->last_loaded)\n      mdata->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!C_NntpListgroup || !mdata->adata->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if ((current <= last) && (rc == 0) && !mdata->deleted)\n  {\n    char *cmd = mdata->adata->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_group_poll - Check newsgroup for new articles\n * @param mdata NNTP Mailbox data\n * @param update_stat Update the stats?\n * @retval  1 New articles found\n * @retval  0 No change\n * @retval -1 Lost connection\n */\nstatic int nntp_group_poll(struct NntpMboxData *mdata, bool update_stat)\n{\n  char buf[1024] = { 0 };\n  anum_t count, first, last;\n\n  /* use GROUP command to poll newsgroup */\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n    return -1;\n  if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    return 0;\n  if ((first == mdata->first_message) && (last == mdata->last_message))\n    return 0;\n\n  /* articles have been renumbered */\n  if (last < mdata->last_message)\n  {\n    mdata->last_cached = 0;\n    if (mdata->newsrc_len)\n    {\n      mutt_mem_realloc(&mdata->newsrc_ent, sizeof(struct NewsrcEntry));\n      mdata->newsrc_len = 1;\n      mdata->newsrc_ent[0].first = 1;\n      mdata->newsrc_ent[0].last = 0;\n    }\n  }\n  mdata->first_message = first;\n  mdata->last_message = last;\n  if (!update_stat)\n    return 1;\n\n  /* update counters */\n  else if (!last || (!mdata->newsrc_ent && !mdata->last_cached))\n    mdata->unread = count;\n  else\n    nntp_group_unread_stat(mdata);\n  return 1;\n}\n\n/**\n * check_mailbox - Check current newsgroup for new articles\n * @param m Mailbox\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n *\n * Leave newsrc locked\n */\nstatic int check_mailbox(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct NntpAccountData *adata = mdata->adata;\n  time_t now = mutt_date_epoch();\n  int rc = 0;\n  void *hc = NULL;\n\n  if (adata->check_time + C_NntpPoll > now)\n    return 0;\n\n  mutt_message(_(\"Checking for new messages...\"));\n  if (nntp_newsrc_parse(adata) < 0)\n    return -1;\n\n  adata->check_time = now;\n  int rc2 = nntp_group_poll(mdata, false);\n  if (rc2 < 0)\n  {\n    nntp_newsrc_close(adata);\n    return -1;\n  }\n  if (rc2 != 0)\n    nntp_active_save_cache(adata);\n\n  /* articles have been renumbered, remove all headers */\n  if (mdata->last_message < mdata->last_loaded)\n  {\n    for (int i = 0; i < m->msg_count; i++)\n      email_free(&m->emails[i]);\n    m->msg_count = 0;\n    m->msg_tagged = 0;\n\n    if (mdata->last_message < mdata->last_loaded)\n    {\n      mdata->last_loaded = mdata->first_message - 1;\n      if (C_NntpContext && (mdata->last_message - mdata->last_loaded > C_NntpContext))\n        mdata->last_loaded = mdata->last_message - C_NntpContext;\n    }\n    rc = MUTT_REOPENED;\n  }\n\n  /* .newsrc has been externally modified */\n  if (adata->newsrc_modified)\n  {\n#ifdef USE_HCACHE\n    unsigned char *messages = NULL;\n    char buf[16];\n    struct Email *e = NULL;\n    anum_t first = mdata->first_message;\n\n    if (C_NntpContext && (mdata->last_message - first + 1 > C_NntpContext))\n      first = mdata->last_message - C_NntpContext + 1;\n    messages = mutt_mem_calloc(mdata->last_loaded - first + 1, sizeof(unsigned char));\n    hc = nntp_hcache_open(mdata);\n    nntp_hcache_update(mdata, hc);\n#endif\n\n    /* update flags according to .newsrc */\n    int j = 0;\n    for (int i = 0; i < m->msg_count; i++)\n    {\n      if (!m->emails[i])\n        continue;\n      bool flagged = false;\n      anum_t anum = nntp_edata_get(m->emails[i])->article_num;\n\n#ifdef USE_HCACHE\n      /* check hcache for flagged and deleted flags */\n      if (hc)\n      {\n        if ((anum >= first) && (anum <= mdata->last_loaded))\n          messages[anum - first] = 1;\n\n        snprintf(buf, sizeof(buf), \"%u\", anum);\n        struct HCacheEntry hce = mutt_hcache_fetch(hc, buf, strlen(buf), 0);\n        if (hce.email)\n        {\n          bool deleted;\n\n          mutt_debug(LL_DEBUG2, \"#1 mutt_hcache_fetch %s\\n\", buf);\n          e = hce.email;\n          e->edata = NULL;\n          deleted = e->deleted;\n          flagged = e->flagged;\n          email_free(&e);\n\n          /* header marked as deleted, removing from context */\n          if (deleted)\n          {\n            mutt_set_flag(m, m->emails[i], MUTT_TAG, false);\n            email_free(&m->emails[i]);\n            continue;\n          }\n        }\n      }\n#endif\n\n      if (!m->emails[i]->changed)\n      {\n        m->emails[i]->flagged = flagged;\n        m->emails[i]->read = false;\n        m->emails[i]->old = false;\n        nntp_article_status(m, m->emails[i], NULL, anum);\n        if (!m->emails[i]->read)\n          nntp_parse_xref(m, m->emails[i]);\n      }\n      m->emails[j++] = m->emails[i];\n    }\n\n#ifdef USE_HCACHE\n    m->msg_count = j;\n\n    /* restore headers without \"deleted\" flag */\n    for (anum_t anum = first; anum <= mdata->last_loaded; anum++)\n    {\n      if (messages[anum - first])\n        continue;\n\n      snprintf(buf, sizeof(buf), \"%u\", anum);\n      struct HCacheEntry hce = mutt_hcache_fetch(hc, buf, strlen(buf), 0);\n      if (hce.email)\n      {\n        mutt_debug(LL_DEBUG2, \"#2 mutt_hcache_fetch %s\\n\", buf);\n        if (m->msg_count >= m->email_max)\n          mx_alloc_memory(m);\n\n        e = hce.email;\n        m->emails[m->msg_count] = e;\n        e->edata = NULL;\n        if (e->deleted)\n        {\n          email_free(&e);\n          if (mdata->bcache)\n          {\n            mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n            mutt_bcache_del(mdata->bcache, buf);\n          }\n          continue;\n        }\n\n        m->msg_count++;\n        e->read = false;\n        e->old = false;\n        e->edata = nntp_edata_new();\n        e->edata_free = nntp_edata_free;\n        nntp_edata_get(e)->article_num = anum;\n        nntp_article_status(m, e, NULL, anum);\n        if (!e->read)\n          nntp_parse_xref(m, e);\n      }\n    }\n    FREE(&messages);\n#endif\n\n    adata->newsrc_modified = false;\n    rc = MUTT_REOPENED;\n  }\n\n  /* some headers were removed, context must be updated */\n  if (rc == MUTT_REOPENED)\n    mailbox_changed(m, NT_MAILBOX_INVALID);\n\n  /* fetch headers of new articles */\n  if (mdata->last_message > mdata->last_loaded)\n  {\n    int oldmsgcount = m->msg_count;\n    bool verbose = m->verbose;\n    m->verbose = false;\n#ifdef USE_HCACHE\n    if (!hc)\n    {\n      hc = nntp_hcache_open(mdata);\n      nntp_hcache_update(mdata, hc);\n    }\n#endif\n    int old_msg_count = m->msg_count;\n    rc2 = nntp_fetch_headers(m, hc, mdata->last_loaded + 1, mdata->last_message, false);\n    m->verbose = verbose;\n    if (rc2 == 0)\n    {\n      if (m->msg_count > old_msg_count)\n        mailbox_changed(m, NT_MAILBOX_INVALID);\n      mdata->last_loaded = mdata->last_message;\n    }\n    if ((rc == 0) && (m->msg_count > oldmsgcount))\n      rc = MUTT_NEW_MAIL;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc)\n    nntp_newsrc_close(adata);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_date - Get date and time from server\n * @param adata NNTP server\n * @param now   Server time\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_date(struct NntpAccountData *adata, time_t *now)\n{\n  if (adata->hasDATE)\n  {\n    struct NntpMboxData mdata = { 0 };\n    char buf[1024];\n    struct tm tm = { 0 };\n\n    mdata.adata = adata;\n    mdata.group = NULL;\n    mutt_str_strfcpy(buf, \"DATE\\r\\n\", sizeof(buf));\n    if (nntp_query(&mdata, buf, sizeof(buf)) < 0)\n      return -1;\n\n    if (sscanf(buf, \"111 %4d%2d%2d%2d%2d%2d%*s\", &tm.tm_year, &tm.tm_mon,\n               &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)\n    {\n      tm.tm_year -= 1900;\n      tm.tm_mon--;\n      *now = timegm(&tm);\n      if (*now >= 0)\n      {\n        mutt_debug(LL_DEBUG1, \"server time is %lu\\n\", *now);\n        return 0;\n      }\n    }\n  }\n  *now = mutt_date_epoch();\n  return 0;\n}\n\n/**\n * fetch_children - Parse XPAT line\n * @param line String to parse\n * @param data ChildCtx\n * @retval 0 Always\n */\nstatic int fetch_children(char *line, void *data)\n{\n  struct ChildCtx *cc = data;\n  anum_t anum;\n\n  if (!line || (sscanf(line, ANUM, &anum) != 1))\n    return 0;\n  for (unsigned int i = 0; i < cc->mailbox->msg_count; i++)\n  {\n    struct Email *e = cc->mailbox->emails[i];\n    if (!e)\n      break;\n    if (nntp_edata_get(e)->article_num == anum)\n      return 0;\n  }\n  if (cc->num >= cc->max)\n  {\n    cc->max *= 2;\n    mutt_mem_realloc(&cc->child, sizeof(anum_t) * cc->max);\n  }\n  cc->child[cc->num++] = anum;\n  return 0;\n}\n\n/**\n * nntp_open_connection - Connect to server, authenticate and get capabilities\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_open_connection(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[256];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (adata->status == NNTP_OK)\n    return 0;\n  if (adata->status == NNTP_BYE)\n    return -1;\n  adata->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(adata);\n\n  if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n    posting = true;\n  else if (!mutt_str_startswith(buf, \"201\", CASE_MATCH))\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(adata);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if ((mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n\n    if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n      posting = true;\n    else if (mutt_str_startswith(buf, \"201\", CASE_MATCH))\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (adata->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(adata);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))\n  {\n    if (adata->use_tls == 0)\n    {\n      adata->use_tls =\n          C_SslForceTls || query_quadoption(C_SslStarttls,\n                                            _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (adata->use_tls == 2)\n    {\n      if ((mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n      if (!mutt_str_startswith(buf, \"382\", CASE_MATCH))\n      {\n        adata->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        adata->use_tls = 0;\n        adata->status = NNTP_NONE;\n        mutt_socket_close(adata->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(adata);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if ((mutt_socket_send(conn, \"STAT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"480\", CASE_MATCH))\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && (nntp_auth(adata) < 0))\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (adata->hasCAPABILITIES && (auth || (cap > 0)))\n  {\n    cap = nntp_capabilities(adata);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(adata) < 0)\n    return -1;\n\n  adata->status = NNTP_OK;\n  return 0;\n}\n\n/**\n * nntp_post - Post article\n * @param m   Mailbox\n * @param msg Message to post\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_post(struct Mailbox *m, const char *msg)\n{\n  struct NntpMboxData *mdata = NULL;\n  struct NntpMboxData tmp_mdata = { 0 };\n  char buf[1024];\n\n  if (m && (m->type == MUTT_NNTP))\n    mdata = m->mdata;\n  else\n  {\n    CurrentNewsSrv = nntp_select_server(m, C_NewsServer, false);\n    if (!CurrentNewsSrv)\n      return -1;\n\n    mdata = &tmp_mdata;\n    mdata->adata = CurrentNewsSrv;\n    mdata->group = NULL;\n  }\n\n  FILE *fp = mutt_file_fopen(msg, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg);\n    return -1;\n  }\n\n  mutt_str_strfcpy(buf, \"POST\\r\\n\", sizeof(buf));\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  if (buf[0] != '3')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n\n  buf[0] = '.';\n  buf[1] = '\\0';\n  while (fgets(buf + 1, sizeof(buf) - 2, fp))\n  {\n    size_t len = strlen(buf);\n    if (buf[len - 1] == '\\n')\n    {\n      buf[len - 1] = '\\r';\n      buf[len] = '\\n';\n      len++;\n      buf[len] = '\\0';\n    }\n    if (mutt_socket_send_d(mdata->adata->conn, (buf[1] == '.') ? buf : buf + 1,\n                           MUTT_SOCK_LOG_FULL) < 0)\n    {\n      mutt_file_fclose(&fp);\n      return nntp_connect_error(mdata->adata);\n    }\n  }\n  mutt_file_fclose(&fp);\n\n  if (((buf[strlen(buf) - 1] != '\\n') &&\n       (mutt_socket_send_d(mdata->adata->conn, \"\\r\\n\", MUTT_SOCK_LOG_FULL) < 0)) ||\n      (mutt_socket_send_d(mdata->adata->conn, \".\\r\\n\", MUTT_SOCK_LOG_FULL) < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), mdata->adata->conn) < 0))\n  {\n    return nntp_connect_error(mdata->adata);\n  }\n  if (buf[0] != '2')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * nntp_active_fetch - Fetch list of all newsgroups from server\n * @param adata    NNTP server\n * @param mark_new Mark the groups as new\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_fetch(struct NntpAccountData *adata, bool mark_new)\n{\n  struct NntpMboxData tmp_mdata = { 0 };\n  char msg[256];\n  char buf[1024];\n  unsigned int i;\n  int rc;\n\n  snprintf(msg, sizeof(msg), _(\"Loading list of groups from server %s...\"),\n           adata->conn->account.host);\n  mutt_message(msg);\n  if (nntp_date(adata, &adata->newgroups_time) < 0)\n    return -1;\n\n  tmp_mdata.adata = adata;\n  tmp_mdata.group = NULL;\n  i = adata->groups_num;\n  mutt_str_strfcpy(buf, \"LIST\\r\\n\", sizeof(buf));\n  rc = nntp_fetch_lines(&tmp_mdata, buf, sizeof(buf), msg, nntp_add_group, adata);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"LIST: %s\", buf);\n    }\n    return -1;\n  }\n\n  if (mark_new)\n  {\n    for (; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n      mdata->has_new_mail = true;\n    }\n  }\n\n  for (i = 0; i < adata->groups_num; i++)\n  {\n    struct NntpMboxData *mdata = adata->groups_list[i];\n\n    if (mdata && mdata->deleted && !mdata->newsrc_ent)\n    {\n      nntp_delete_group_cache(mdata);\n      mutt_hash_delete(adata->groups_hash, mdata->group, NULL);\n      adata->groups_list[i] = NULL;\n    }\n  }\n\n  if (C_NntpLoadDescription)\n    rc = get_description(&tmp_mdata, \"*\", _(\"Loading descriptions...\"));\n\n  nntp_active_save_cache(adata);\n  if (rc < 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_check_new_groups - Check for new groups/articles in subscribed groups\n * @param m     Mailbox\n * @param adata NNTP server\n * @retval  1 New groups found\n * @retval  0 No new groups\n * @retval -1 Error\n */\nint nntp_check_new_groups(struct Mailbox *m, struct NntpAccountData *adata)\n{\n  struct NntpMboxData tmp_mdata = { 0 };\n  time_t now;\n  char buf[1024];\n  char *msg = _(\"Checking for new newsgroups...\");\n  unsigned int i;\n  int rc, update_active = false;\n\n  if (!adata || !adata->newgroups_time)\n    return -1;\n\n  /* check subscribed newsgroups for new articles */\n  if (C_ShowNewNews)\n  {\n    mutt_message(_(\"Checking for new messages...\"));\n    for (i = 0; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n\n      if (mdata && mdata->subscribed)\n      {\n        rc = nntp_group_poll(mdata, true);\n        if (rc < 0)\n          return -1;\n        if (rc > 0)\n          update_active = true;\n      }\n    }\n  }\n  else if (adata->newgroups_time)\n    return 0;\n\n  /* get list of new groups */\n  mutt_message(msg);\n  if (nntp_date(adata, &now) < 0)\n    return -1;\n  tmp_mdata.adata = adata;\n  if (m && m->mdata)\n    tmp_mdata.group = ((struct NntpMboxData *) m->mdata)->group;\n  else\n    tmp_mdata.group = NULL;\n  i = adata->groups_num;\n  struct tm tm = mutt_date_gmtime(adata->newgroups_time);\n  snprintf(buf, sizeof(buf), \"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\\r\\n\",\n           tm.tm_year % 100, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n  rc = nntp_fetch_lines(&tmp_mdata, buf, sizeof(buf), msg, nntp_add_group, adata);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"NEWGROUPS: %s\", buf);\n    }\n    return -1;\n  }\n\n  /* new groups found */\n  rc = 0;\n  if (adata->groups_num != i)\n  {\n    int groups_num = i;\n\n    adata->newgroups_time = now;\n    for (; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n      mdata->has_new_mail = true;\n    }\n\n    /* loading descriptions */\n    if (C_NntpLoadDescription)\n    {\n      unsigned int count = 0;\n      struct Progress progress;\n\n      mutt_progress_init(&progress, _(\"Loading descriptions...\"),\n                         MUTT_PROGRESS_READ, adata->groups_num - i);\n      for (i = groups_num; i < adata->groups_num; i++)\n      {\n        struct NntpMboxData *mdata = adata->groups_list[i];\n\n        if (get_description(mdata, NULL, NULL) < 0)\n          return -1;\n        mutt_progress_update(&progress, ++count, -1);\n      }\n    }\n    update_active = true;\n    rc = 1;\n  }\n  if (update_active)\n    nntp_active_save_cache(adata);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_check_msgid - Fetch article by Message-ID\n * @param m     Mailbox\n * @param msgid Message ID\n * @retval  0 Success\n * @retval  1 No such article\n * @retval -1 Error\n */\nint nntp_check_msgid(struct Mailbox *m, const char *msgid)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  char buf[1024];\n\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n  {\n    mutt_perror(_(\"Can't create temporary file\"));\n    return -1;\n  }\n\n  snprintf(buf, sizeof(buf), \"HEAD %s\\r\\n\", msgid);\n  int rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n  if (rc)\n  {\n    mutt_file_fclose(&fp);\n    if (rc < 0)\n      return -1;\n    if (mutt_str_startswith(buf, \"430\", CASE_MATCH))\n      return 1;\n    mutt_error(\"HEAD: %s\", buf);\n    return -1;\n  }\n\n  /* parse header */\n  if (m->msg_count == m->email_max)\n    mx_alloc_memory(m);\n  m->emails[m->msg_count] = email_new();\n  struct Email *e = m->emails[m->msg_count];\n  e->edata = nntp_edata_new();\n  e->edata_free = nntp_edata_free;\n  e->env = mutt_rfc822_read_header(fp, e, false, false);\n  mutt_file_fclose(&fp);\n\n  /* get article number */\n  if (e->env->xref)\n    nntp_parse_xref(m, e);\n  else\n  {\n    snprintf(buf, sizeof(buf), \"STAT %s\\r\\n\", msgid);\n    if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n    {\n      email_free(&e);\n      return -1;\n    }\n    sscanf(buf + 4, ANUM, &nntp_edata_get(e)->article_num);\n  }\n\n  /* reset flags */\n  e->read = false;\n  e->old = false;\n  e->deleted = false;\n  e->changed = true;\n  e->received = e->date_sent;\n  e->index = m->msg_count++;\n  mailbox_changed(m, NT_MAILBOX_INVALID);\n  return 0;\n}\n\n/**\n * nntp_check_children - Fetch children of article with the Message-ID\n * @param m     Mailbox\n * @param msgid Message ID to find\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_check_children(struct Mailbox *m, const char *msgid)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct ChildCtx cc;\n  char buf[256];\n  int rc;\n  void *hc = NULL;\n\n  if (!mdata || !mdata->adata)\n    return -1;\n  if (mdata->first_message > mdata->last_loaded)\n    return 0;\n\n  /* init context */\n  cc.mailbox = m;\n  cc.num = 0;\n  cc.max = 10;\n  cc.child = mutt_mem_malloc(sizeof(anum_t) * cc.max);\n\n  /* fetch numbers of child messages */\n  snprintf(buf, sizeof(buf), \"XPAT References %u-%u *%s*\\r\\n\",\n           mdata->first_message, mdata->last_loaded, msgid);\n  rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_children, &cc);\n  if (rc)\n  {\n    FREE(&cc.child);\n    if (rc > 0)\n    {\n      if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n        mutt_error(\"XPAT: %s\", buf);\n      else\n      {\n        mutt_error(_(\"Unable to find child articles because server does not \"\n                     \"support XPAT command\"));\n      }\n    }\n    return -1;\n  }\n\n  /* fetch all found messages */\n  bool verbose = m->verbose;\n  m->verbose = false;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(mdata);\n#endif\n  int old_msg_count = m->msg_count;\n  for (int i = 0; i < cc.num; i++)\n  {\n    rc = nntp_fetch_headers(m, hc, cc.child[i], cc.child[i], true);\n    if (rc < 0)\n      break;\n  }\n  if (m->msg_count > old_msg_count)\n    mailbox_changed(m, NT_MAILBOX_INVALID);\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  m->verbose = verbose;\n  FREE(&cc.child);\n  return (rc < 0) ? -1 : 0;\n}\n\n/**\n * nntp_compare_order - Sort to mailbox order - Implements ::sort_t\n */\nint nntp_compare_order(const void *a, const void *b)\n{\n  const struct Email *ea = *(struct Email const *const *) a;\n  const struct Email *eb = *(struct Email const *const *) b;\n\n  anum_t na = nntp_edata_get((struct Email *) ea)->article_num;\n  anum_t nb = nntp_edata_get((struct Email *) eb)->article_num;\n  int result = (na == nb) ? 0 : (na > nb) ? 1 : -1;\n  result = perform_auxsort(result, a, b);\n  return SORT_CODE(result);\n}\n\n/**\n * nntp_ac_find - Find an Account that matches a Mailbox path - Implements MxOps::ac_find()\n */\nstatic struct Account *nntp_ac_find(struct Account *a, const char *path)\n{\n#if 0\n  if (!a || (a->type != MUTT_NNTP) || !path)\n    return NULL;\n\n  struct Url url = { 0 };\n  char tmp[PATH_MAX];\n  mutt_str_strfcpy(tmp, path, sizeof(tmp));\n  url_parse(&url, tmp);\n\n  struct ImapAccountData *adata = a->data;\n  struct ConnAccount *cac = &adata->conn_account;\n\n  if (mutt_str_strcasecmp(url.host, cac->host) != 0)\n    return NULL;\n\n  if (mutt_str_strcasecmp(url.user, cac->user) != 0)\n    return NULL;\n\n  // if (mutt_str_strcmp(path, a->mailbox->realpath) == 0)\n  //   return a;\n#endif\n  return a;\n}\n\n/**\n * nntp_ac_add - Add a Mailbox to an Account - Implements MxOps::ac_add()\n */\nstatic int nntp_ac_add(struct Account *a, struct Mailbox *m)\n{\n  if (!a || !m || (m->type != MUTT_NNTP))\n    return -1;\n  return 0;\n}\n\n/**\n * nntp_mbox_open - Open a Mailbox - Implements MxOps::mbox_open()\n */\nstatic int nntp_mbox_open(struct Mailbox *m)\n{\n  if (!m || !m->account)\n    return -1;\n\n  char buf[8192];\n  char server[1024];\n  char *group = NULL;\n  int rc;\n  void *hc = NULL;\n  anum_t first, last, count = 0;\n\n  struct Url *url = url_parse(mailbox_path(m));\n  if (!url || !url->host || !url->path ||\n      !((url->scheme == U_NNTP) || (url->scheme == U_NNTPS)))\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid newsgroup specification\"), mailbox_path(m));\n    return -1;\n  }\n\n  group = url->path;\n  if (group[0] == '/') /* Skip a leading '/' */\n    group++;\n\n  url->path = strchr(url->path, '\\0');\n  url_tostring(url, server, sizeof(server), 0);\n\n  mutt_account_hook(m->realpath);\n  struct NntpAccountData *adata = m->account->adata;\n  if (!adata)\n  {\n    adata = nntp_select_server(m, server, true);\n    m->account->adata = adata;\n    m->account->adata_free = nntp_adata_free;\n  }\n\n  if (!adata)\n  {\n    url_free(&url);\n    return -1;\n  }\n  CurrentNewsSrv = adata;\n\n  m->msg_count = 0;\n  m->msg_unread = 0;\n  m->vcount = 0;\n\n  if (group[0] == '/')\n    group++;\n\n  /* find news group data structure */\n  struct NntpMboxData *mdata = mutt_hash_find(adata->groups_hash, group);\n  if (!mdata)\n  {\n    nntp_newsrc_close(adata);\n    mutt_error(_(\"Newsgroup %s not found on the server\"), group);\n    url_free(&url);\n    return -1;\n  }\n\n  m->rights &= ~MUTT_ACL_INSERT; // Clear the flag\n  if (!mdata->newsrc_ent && !mdata->subscribed && !C_SaveUnsubscribed)\n    m->readonly = true;\n\n  /* select newsgroup */\n  mutt_message(_(\"Selecting %s...\"), group);\n  url_free(&url);\n  buf[0] = '\\0';\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n  {\n    nntp_newsrc_close(adata);\n    return -1;\n  }\n\n  /* newsgroup not found, remove it */\n  if (mutt_str_startswith(buf, \"411\", CASE_MATCH))\n  {\n    mutt_error(_(\"Newsgroup %s has been removed from the server\"), mdata->group);\n    if (!mdata->deleted)\n    {\n      mdata->deleted = true;\n      nntp_active_save_cache(adata);\n    }\n    if (mdata->newsrc_ent && !mdata->subscribed && !C_SaveUnsubscribed)\n    {\n      FREE(&mdata->newsrc_ent);\n      mdata->newsrc_len = 0;\n      nntp_delete_group_cache(mdata);\n      nntp_newsrc_update(adata);\n    }\n  }\n\n  /* parse newsgroup info */\n  else\n  {\n    if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    {\n      nntp_newsrc_close(adata);\n      mutt_error(\"GROUP: %s\", buf);\n      return -1;\n    }\n    mdata->first_message = first;\n    mdata->last_message = last;\n    mdata->deleted = false;\n\n    /* get description if empty */\n    if (C_NntpLoadDescription && !mdata->desc)\n    {\n      if (get_description(mdata, NULL, NULL) < 0)\n      {\n        nntp_newsrc_close(adata);\n        return -1;\n      }\n      if (mdata->desc)\n        nntp_active_save_cache(adata);\n    }\n  }\n\n  adata->check_time = mutt_date_epoch();\n  m->mdata = mdata;\n  // Every known newsgroup has an mdata which is stored in adata->groups_list.\n  // Currently we don't let the Mailbox free the mdata.\n  // m->mdata_free = nntp_mdata_free;\n  if (!mdata->bcache && (mdata->newsrc_ent || mdata->subscribed || C_SaveUnsubscribed))\n    mdata->bcache = mutt_bcache_open(&adata->conn->account, mdata->group);\n\n  /* strip off extra articles if adding context is greater than $nntp_context */\n  first = mdata->first_message;\n  if (C_NntpContext && (mdata->last_message - first + 1 > C_NntpContext))\n    first = mdata->last_message - C_NntpContext + 1;\n  mdata->last_loaded = first ? first - 1 : 0;\n  count = mdata->first_message;\n  mdata->first_message = first;\n  nntp_bcache_update(mdata);\n  mdata->first_message = count;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(mdata);\n  nntp_hcache_update(mdata, hc);\n#endif\n  if (!hc)\n    m->rights &= ~(MUTT_ACL_WRITE | MUTT_ACL_DELETE); // Clear the flags\n\n  nntp_newsrc_close(adata);\n  rc = nntp_fetch_headers(m, hc, first, mdata->last_message, false);\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc < 0)\n    return -1;\n  mdata->last_loaded = mdata->last_message;\n  adata->newsrc_modified = false;\n  return 0;\n}\n\n/**\n * nntp_mbox_check - Check for new mail - Implements MxOps::mbox_check()\n * @param m          Mailbox\n * @param index_hint Current message (UNUSED)\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n */\nstatic int nntp_mbox_check(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  int rc = check_mailbox(m);\n  if (rc == 0)\n  {\n    struct NntpMboxData *mdata = m->mdata;\n    struct NntpAccountData *adata = mdata->adata;\n    nntp_newsrc_close(adata);\n  }\n  return rc;\n}\n\n/**\n * nntp_mbox_sync - Save changes to the Mailbox - Implements MxOps::mbox_sync()\n *\n * @note May also return values from check_mailbox()\n */\nstatic int nntp_mbox_sync(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  int rc;\n\n  /* check for new articles */\n  mdata->adata->check_time = 0;\n  rc = check_mailbox(m);\n  if (rc)\n    return rc;\n\n#ifdef USE_HCACHE\n  mdata->last_cached = 0;\n  header_cache_t *hc = nntp_hcache_open(mdata);\n#endif\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), ANUM, nntp_edata_get(e)->article_num);\n    if (mdata->bcache && e->deleted)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n      mutt_bcache_del(mdata->bcache, buf);\n    }\n\n#ifdef USE_HCACHE\n    if (hc && (e->changed || e->deleted))\n    {\n      if (e->deleted && !e->read)\n        mdata->unread--;\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(hc, buf, strlen(buf), e, 0);\n    }\n#endif\n  }\n\n#ifdef USE_HCACHE\n  if (hc)\n  {\n    mutt_hcache_close(hc);\n    mdata->last_cached = mdata->last_loaded;\n  }\n#endif\n\n  /* save .newsrc entries */\n  nntp_newsrc_gen_entries(m);\n  nntp_newsrc_update(mdata->adata);\n  nntp_newsrc_close(mdata->adata);\n  return 0;\n}\n\n/**\n * nntp_mbox_close - Close a Mailbox - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int nntp_mbox_close(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct NntpMboxData *tmp_mdata = NULL;\n  if (!mdata)\n    return 0;\n\n  mdata->unread = m->msg_unread;\n\n  nntp_acache_free(mdata);\n  if (!mdata->adata || !mdata->adata->groups_hash || !mdata->group)\n    return 0;\n\n  tmp_mdata = mutt_hash_find(mdata->adata->groups_hash, mdata->group);\n  if (!tmp_mdata || (tmp_mdata != mdata))\n    nntp_mdata_free((void **) &mdata);\n  return 0;\n}\n\n/**\n * nntp_msg_open - Open an email message in a Mailbox - Implements MxOps::msg_open()\n */\nstatic int nntp_msg_open(struct Mailbox *m, struct Message *msg, int msgno)\n{\n  if (!m || !m->emails || (msgno >= m->msg_count) || !msg)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct Email *e = m->emails[msgno];\n  if (!e)\n    return -1;\n\n  char article[16];\n\n  /* try to get article from cache */\n  struct NntpAcache *acache = &mdata->acache[e->index % NNTP_ACACHE_LEN];\n  if (acache->path)\n  {\n    if (acache->index == e->index)\n    {\n      msg->fp = mutt_file_fopen(acache->path, \"r\");\n      if (msg->fp)\n        return 0;\n    }\n    /* clear previous entry */\n    else\n    {\n      unlink(acache->path);\n      FREE(&acache->path);\n    }\n  }\n  snprintf(article, sizeof(article), ANUM, nntp_edata_get(e)->article_num);\n  msg->fp = mutt_bcache_get(mdata->bcache, article);\n  if (msg->fp)\n  {\n    if (nntp_edata_get(e)->parsed)\n      return 0;\n  }\n  else\n  {\n    char buf[PATH_MAX];\n    /* don't try to fetch article from removed newsgroup */\n    if (mdata->deleted)\n      return -1;\n\n    /* create new cache file */\n    const char *fetch_msg = _(\"Fetching message...\");\n    mutt_message(fetch_msg);\n    msg->fp = mutt_bcache_put(mdata->bcache, article);\n    if (!msg->fp)\n    {\n      mutt_mktemp(buf, sizeof(buf));\n      acache->path = mutt_str_strdup(buf);\n      acache->index = e->index;\n      msg->fp = mutt_file_fopen(acache->path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(acache->path);\n        unlink(acache->path);\n        FREE(&acache->path);\n        return -1;\n      }\n    }\n\n    /* fetch message to cache file */\n    snprintf(buf, sizeof(buf), \"ARTICLE %s\\r\\n\",\n             nntp_edata_get(e)->article_num ? article : e->env->message_id);\n    const int rc =\n        nntp_fetch_lines(mdata, buf, sizeof(buf), fetch_msg, fetch_tempfile, msg->fp);\n    if (rc)\n    {\n      mutt_file_fclose(&msg->fp);\n      if (acache->path)\n      {\n        unlink(acache->path);\n        FREE(&acache->path);\n      }\n      if (rc > 0)\n      {\n        if (mutt_str_startswith(buf, nntp_edata_get(e)->article_num ? \"423\" : \"430\", CASE_MATCH))\n        {\n          mutt_error(_(\"Article %s not found on the server\"),\n                     nntp_edata_get(e)->article_num ? article : e->env->message_id);\n        }\n        else\n          mutt_error(\"ARTICLE: %s\", buf);\n      }\n      return -1;\n    }\n\n    if (!acache->path)\n      mutt_bcache_commit(mdata->bcache, article);\n  }\n\n  /* replace envelope with new one\n   * hash elements must be updated because pointers will be changed */\n  if (m->id_hash && e->env->message_id)\n    mutt_hash_delete(m->id_hash, e->env->message_id, e);\n  if (m->subj_hash && e->env->real_subj)\n    mutt_hash_delete(m->subj_hash, e->env->real_subj, e);\n\n  mutt_env_free(&e->env);\n  e->env = mutt_rfc822_read_header(msg->fp, e, false, false);\n\n  if (m->id_hash && e->env->message_id)\n    mutt_hash_insert(m->id_hash, e->env->message_id, e);\n  if (m->subj_hash && e->env->real_subj)\n    mutt_hash_insert(m->subj_hash, e->env->real_subj, e);\n\n  /* fix content length */\n  fseek(msg->fp, 0, SEEK_END);\n  e->content->length = ftell(msg->fp) - e->content->offset;\n\n  /* this is called in neomutt before the open which fetches the message,\n   * which is probably wrong, but we just call it again here to handle\n   * the problem instead of fixing it */\n  nntp_edata_get(e)->parsed = true;\n  mutt_parse_mime_message(m, e);\n\n  /* these would normally be updated in ctx_update(), but the\n   * full headers aren't parsed with overview, so the information wasn't\n   * available then */\n  if (WithCrypto)\n    e->security = crypt_query(e->content);\n\n  rewind(msg->fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_msg_close - Close an email - Implements MxOps::msg_close()\n *\n * @note May also return EOF Failure, see errno\n */\nstatic int nntp_msg_close(struct Mailbox *m, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * nntp_path_probe - Is this an NNTP Mailbox? - Implements MxOps::path_probe()\n */\nenum MailboxType nntp_path_probe(const char *path, const struct stat *st)\n{\n  if (!path)\n    return MUTT_UNKNOWN;\n\n  if (mutt_str_startswith(path, \"news://\", CASE_IGNORE))\n    return MUTT_NNTP;\n\n  if (mutt_str_startswith(path, \"snews://\", CASE_IGNORE))\n    return MUTT_NNTP;\n\n  return MUTT_UNKNOWN;\n}\n\n/**\n * nntp_path_canon - Canonicalise a Mailbox path - Implements MxOps::path_canon()\n */\nstatic int nntp_path_canon(char *buf, size_t buflen)\n{\n  if (!buf)\n    return -1;\n\n  return 0;\n}\n\n/**\n * nntp_path_pretty - Abbreviate a Mailbox path - Implements MxOps::path_pretty()\n */\nstatic int nntp_path_pretty(char *buf, size_t buflen, const char *folder)\n{\n  /* Succeed, but don't do anything, for now */\n  return 0;\n}\n\n/**\n * nntp_path_parent - Find the parent of a Mailbox path - Implements MxOps::path_parent()\n */\nstatic int nntp_path_parent(char *buf, size_t buflen)\n{\n  /* Succeed, but don't do anything, for now */\n  return 0;\n}\n\n// clang-format off\n/**\n * MxNntpOps - NNTP Mailbox - Implements ::MxOps\n */\nstruct MxOps MxNntpOps = {\n  .type            = MUTT_NNTP,\n  .name             = \"nntp\",\n  .is_local         = false,\n  .ac_find          = nntp_ac_find,\n  .ac_add           = nntp_ac_add,\n  .mbox_open        = nntp_mbox_open,\n  .mbox_open_append = NULL,\n  .mbox_check       = nntp_mbox_check,\n  .mbox_check_stats = NULL,\n  .mbox_sync        = nntp_mbox_sync,\n  .mbox_close       = nntp_mbox_close,\n  .msg_open         = nntp_msg_open,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = nntp_msg_close,\n  .msg_padding_size = NULL,\n  .msg_save_hcache  = NULL,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n  .path_probe       = nntp_path_probe,\n  .path_canon       = nntp_path_canon,\n  .path_pretty      = nntp_path_pretty,\n  .path_parent      = nntp_path_parent,\n};\n// clang-format on\n", "/**\n * @file\n * POP helper routines\n *\n * @authors\n * Copyright (C) 2000-2003 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop_lib POP helper routines\n *\n * POP helper routines\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"init.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"progress.h\"\n#ifdef USE_SSL\n#include \"globals.h\"\n#endif\n\n/* These Config Variables are only used in pop/pop_lib.c */\nchar *C_PopOauthRefreshCommand; ///< Config: (pop) External command to generate OAUTH refresh token\nchar *C_PopPass; ///< Config: (pop) Password of the POP server\nunsigned char C_PopReconnect; ///< Config: (pop) Reconnect to the server is the connection is lost\nchar *C_PopUser; ///< Config: (pop) Username of the POP server\n\n/**\n * pop_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nconst char *pop_get_field(enum ConnAccountField field)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n    case MUTT_CA_USER:\n      return C_PopUser;\n    case MUTT_CA_PASS:\n      return C_PopPass;\n    case MUTT_CA_OAUTH_CMD:\n      return C_PopOauthRefreshCommand;\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n/**\n * pop_parse_path - Parse a POP mailbox name\n * @param path Path to parse\n * @param cac  Account to store details\n * @retval 0 success\n * @retval -1 error\n *\n * Split a POP path into host, port, username and password\n */\nint pop_parse_path(const char *path, struct ConnAccount *cac)\n{\n  /* Defaults */\n  cac->flags = 0;\n  cac->type = MUTT_ACCT_TYPE_POP;\n  cac->port = 0;\n  cac->service = \"pop\";\n  cac->get_field = pop_get_field;\n\n  struct Url *url = url_parse(path);\n\n  if (!url || ((url->scheme != U_POP) && (url->scheme != U_POPS)) ||\n      !url->host || (mutt_account_fromurl(cac, url) < 0))\n  {\n    url_free(&url);\n    mutt_error(_(\"Invalid POP URL: %s\"), path);\n    return -1;\n  }\n\n  if (url->scheme == U_POPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  struct servent *service =\n      getservbyname((url->scheme == U_POP) ? \"pop3\" : \"pop3s\", \"tcp\");\n  if (cac->port == 0)\n  {\n    if (service)\n      cac->port = ntohs(service->s_port);\n    else\n      cac->port = (url->scheme == U_POP) ? POP_PORT : POP_SSL_PORT;\n  }\n\n  url_free(&url);\n  return 0;\n}\n\n/**\n * pop_error - Copy error message to err_msg buffer\n * @param adata POP Account data\n * @param msg   Error message to save\n */\nstatic void pop_error(struct PopAccountData *adata, char *msg)\n{\n  char *t = strchr(adata->err_msg, '\\0');\n  char *c = msg;\n\n  size_t plen = mutt_str_startswith(msg, \"-ERR \", CASE_MATCH);\n  if (plen != 0)\n  {\n    char *c2 = mutt_str_skip_email_wsp(msg + plen);\n\n    if (*c2)\n      c = c2;\n  }\n\n  mutt_str_strfcpy(t, c, sizeof(adata->err_msg) - strlen(adata->err_msg));\n  mutt_str_remove_trailing_ws(adata->err_msg);\n}\n\n/**\n * fetch_capa - Parse CAPA output - Implements ::pop_fetch_t\n * @param line List of capabilities\n * @param data POP data\n * @retval 0 (always)\n */\nstatic int fetch_capa(const char *line, void *data)\n{\n  struct PopAccountData *adata = data;\n\n  if (mutt_str_startswith(line, \"SASL\", CASE_IGNORE))\n  {\n    const char *c = mutt_str_skip_email_wsp(line + 4);\n    mutt_buffer_strcpy(&adata->auth_list, c);\n  }\n  else if (mutt_str_startswith(line, \"STLS\", CASE_IGNORE))\n    adata->cmd_stls = true;\n  else if (mutt_str_startswith(line, \"USER\", CASE_IGNORE))\n    adata->cmd_user = 1;\n  else if (mutt_str_startswith(line, \"UIDL\", CASE_IGNORE))\n    adata->cmd_uidl = 1;\n  else if (mutt_str_startswith(line, \"TOP\", CASE_IGNORE))\n    adata->cmd_top = 1;\n\n  return 0;\n}\n\n/**\n * fetch_auth - Fetch list of the authentication mechanisms - Implements ::pop_fetch_t\n * @param line List of authentication methods\n * @param data POP data\n * @retval 0 (always)\n */\nstatic int fetch_auth(const char *line, void *data)\n{\n  struct PopAccountData *adata = data;\n\n  if (!mutt_buffer_is_empty(&adata->auth_list))\n  {\n    mutt_buffer_addstr(&adata->auth_list, \" \");\n  }\n  mutt_buffer_addstr(&adata->auth_list, line);\n\n  return 0;\n}\n\n/**\n * pop_capabilities - Get capabilities from a POP server\n * @param adata POP Account data\n * @param mode  Initial capabilities\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Execution error\n */\nstatic int pop_capabilities(struct PopAccountData *adata, int mode)\n{\n  char buf[1024];\n\n  /* don't check capabilities on reconnect */\n  if (adata->capabilities)\n    return 0;\n\n  /* init capabilities */\n  if (mode == 0)\n  {\n    adata->cmd_capa = false;\n    adata->cmd_stls = false;\n    adata->cmd_user = 0;\n    adata->cmd_uidl = 0;\n    adata->cmd_top = 0;\n    adata->resp_codes = false;\n    adata->expire = true;\n    adata->login_delay = 0;\n    mutt_buffer_init(&adata->auth_list);\n  }\n\n  /* Execute CAPA command */\n  if ((mode == 0) || adata->cmd_capa)\n  {\n    mutt_str_strfcpy(buf, \"CAPA\\r\\n\", sizeof(buf));\n    switch (pop_fetch_data(adata, buf, NULL, fetch_capa, adata))\n    {\n      case 0:\n      {\n        adata->cmd_capa = true;\n        break;\n      }\n      case -1:\n        return -1;\n    }\n  }\n\n  /* CAPA not supported, use defaults */\n  if ((mode == 0) && !adata->cmd_capa)\n  {\n    adata->cmd_user = 2;\n    adata->cmd_uidl = 2;\n    adata->cmd_top = 2;\n\n    mutt_str_strfcpy(buf, \"AUTH\\r\\n\", sizeof(buf));\n    if (pop_fetch_data(adata, buf, NULL, fetch_auth, adata) == -1)\n      return -1;\n  }\n\n  /* Check capabilities */\n  if (mode == 2)\n  {\n    char *msg = NULL;\n\n    if (!adata->expire)\n      msg = _(\"Unable to leave messages on server\");\n    if (adata->cmd_top == 0)\n      msg = _(\"Command TOP is not supported by server\");\n    if (adata->cmd_uidl == 0)\n      msg = _(\"Command UIDL is not supported by server\");\n    if (msg && adata->cmd_capa)\n    {\n      mutt_error(msg);\n      return -2;\n    }\n    adata->capabilities = true;\n  }\n\n  return 0;\n}\n\n/**\n * pop_edata_get - Get the private data for this Email\n * @param e Email\n * @retval ptr Private Email data\n */\nstruct PopEmailData *pop_edata_get(struct Email *e)\n{\n  if (!e)\n    return NULL;\n  return e->edata;\n}\n\n/**\n * pop_connect - Open connection\n * @param adata POP Account data\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid response\n */\nint pop_connect(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  adata->status = POP_NONE;\n  if ((mutt_socket_open(adata->conn) < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), adata->conn) < 0))\n  {\n    mutt_error(_(\"Error connecting to server: %s\"), adata->conn->account.host);\n    return -1;\n  }\n\n  adata->status = POP_CONNECTED;\n\n  if (!mutt_str_startswith(buf, \"+OK\", CASE_MATCH))\n  {\n    *adata->err_msg = '\\0';\n    pop_error(adata, buf);\n    mutt_error(\"%s\", adata->err_msg);\n    return -2;\n  }\n\n  pop_apop_timestamp(adata, buf);\n\n  return 0;\n}\n\n/**\n * pop_open_connection - Open connection and authenticate\n * @param adata POP Account data\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Authentication cancelled\n */\nint pop_open_connection(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  int rc = pop_connect(adata);\n  if (rc < 0)\n    return rc;\n\n  rc = pop_capabilities(adata, 0);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n#ifdef USE_SSL\n  /* Attempt STLS if available and desired. */\n  if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))\n  {\n    if (C_SslForceTls)\n      adata->use_stls = 2;\n    if (adata->use_stls == 0)\n    {\n      enum QuadOption ans =\n          query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\"));\n      if (ans == MUTT_ABORT)\n        return -2;\n      adata->use_stls = 1;\n      if (ans == MUTT_YES)\n        adata->use_stls = 2;\n    }\n    if (adata->use_stls == 2)\n    {\n      mutt_str_strfcpy(buf, \"STLS\\r\\n\", sizeof(buf));\n      rc = pop_query(adata, buf, sizeof(buf));\n      if (rc == -1)\n        goto err_conn;\n      if (rc != 0)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n      else if (mutt_ssl_starttls(adata->conn))\n      {\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -2;\n      }\n      else\n      {\n        /* recheck capabilities after STLS completes */\n        rc = pop_capabilities(adata, 1);\n        if (rc == -1)\n          goto err_conn;\n        if (rc == -2)\n          return -2;\n      }\n    }\n  }\n\n  if (C_SslForceTls && !adata->conn->ssf)\n  {\n    mutt_error(_(\"Encrypted connection unavailable\"));\n    return -2;\n  }\n#endif\n\n  rc = pop_authenticate(adata);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -3)\n    mutt_clear_error();\n  if (rc != 0)\n    return rc;\n\n  /* recheck capabilities after authentication */\n  rc = pop_capabilities(adata, 2);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n  /* get total size of mailbox */\n  mutt_str_strfcpy(buf, \"STAT\\r\\n\", sizeof(buf));\n  rc = pop_query(adata, buf, sizeof(buf));\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n  {\n    mutt_error(\"%s\", adata->err_msg);\n    return rc;\n  }\n\n  unsigned int n = 0, size = 0;\n  sscanf(buf, \"+OK %u %u\", &n, &size);\n  adata->size = size;\n  return 0;\n\nerr_conn:\n  adata->status = POP_DISCONNECTED;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}\n\n/**\n * pop_logout - logout from a POP server\n * @param m Mailbox\n */\nvoid pop_logout(struct Mailbox *m)\n{\n  struct PopAccountData *adata = pop_adata_get(m);\n\n  if (adata->status == POP_CONNECTED)\n  {\n    int ret = 0;\n    char buf[1024];\n    mutt_message(_(\"Closing connection to POP server...\"));\n\n    if (m->readonly)\n    {\n      mutt_str_strfcpy(buf, \"RSET\\r\\n\", sizeof(buf));\n      ret = pop_query(adata, buf, sizeof(buf));\n    }\n\n    if (ret != -1)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(adata, buf, sizeof(buf));\n    }\n\n    if (ret < 0)\n      mutt_debug(LL_DEBUG1, \"Error closing POP connection\\n\");\n\n    mutt_clear_error();\n  }\n\n  adata->status = POP_DISCONNECTED;\n}\n\n/**\n * pop_query_d - Send data from buffer and receive answer to the same buffer\n * @param adata  POP Account data\n * @param buf    Buffer to send/store data\n * @param buflen Buffer length\n * @param msg    Progress message\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n */\nint pop_query_d(struct PopAccountData *adata, char *buf, size_t buflen, char *msg)\n{\n  if (adata->status != POP_CONNECTED)\n    return -1;\n\n  /* print msg instead of real command */\n  if (msg)\n  {\n    mutt_debug(MUTT_SOCK_LOG_CMD, \"> %s\", msg);\n  }\n\n  mutt_socket_send_d(adata->conn, buf, MUTT_SOCK_LOG_FULL);\n\n  char *c = strpbrk(buf, \" \\r\\n\");\n  if (c)\n    *c = '\\0';\n  snprintf(adata->err_msg, sizeof(adata->err_msg), \"%s: \", buf);\n\n  if (mutt_socket_readln_d(buf, buflen, adata->conn, MUTT_SOCK_LOG_FULL) < 0)\n  {\n    adata->status = POP_DISCONNECTED;\n    return -1;\n  }\n  if (mutt_str_startswith(buf, \"+OK\", CASE_MATCH))\n    return 0;\n\n  pop_error(adata, buf);\n  return -2;\n}\n\n/**\n * pop_fetch_data - Read Headers with callback function\n * @param adata    POP Account data\n * @param query    POP query to send to server\n * @param progress Progress bar\n * @param callback Function called for each header read\n * @param data     Data to pass to the callback\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error in callback(*line, *data)\n *\n * This function calls  callback(*line, *data)  for each received line,\n * callback(NULL, *data)  if  rewind(*data)  needs, exits when fail or done.\n */\nint pop_fetch_data(struct PopAccountData *adata, const char *query,\n                   struct Progress *progress, pop_fetch_t callback, void *data)\n{\n  char buf[1024];\n  long pos = 0;\n  size_t lenbuf = 0;\n\n  mutt_str_strfcpy(buf, query, sizeof(buf));\n  int rc = pop_query(adata, buf, sizeof(buf));\n  if (rc < 0)\n    return rc;\n\n  char *inbuf = mutt_mem_malloc(sizeof(buf));\n\n  while (true)\n  {\n    const int chunk =\n        mutt_socket_readln_d(buf, sizeof(buf), adata->conn, MUTT_SOCK_LOG_FULL);\n    if (chunk < 0)\n    {\n      adata->status = POP_DISCONNECTED;\n      rc = -1;\n      break;\n    }\n\n    char *p = buf;\n    if (!lenbuf && (buf[0] == '.'))\n    {\n      if (buf[1] != '.')\n        break;\n      p++;\n    }\n\n    mutt_str_strfcpy(inbuf + lenbuf, p, sizeof(buf));\n    pos += chunk;\n\n    /* cast is safe since we break out of the loop when chunk<=0 */\n    if ((size_t) chunk >= sizeof(buf))\n    {\n      lenbuf += strlen(p);\n    }\n    else\n    {\n      if (progress)\n        mutt_progress_update(progress, pos, -1);\n      if ((rc == 0) && (callback(inbuf, data) < 0))\n        rc = -3;\n      lenbuf = 0;\n    }\n\n    mutt_mem_realloc(&inbuf, lenbuf + sizeof(buf));\n  }\n\n  FREE(&inbuf);\n  return rc;\n}\n\n/**\n * check_uidl - find message with this UIDL and set refno - Implements ::pop_fetch_t\n * @param line String containing UIDL\n * @param data POP data\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int check_uidl(const char *line, void *data)\n{\n  if (!line || !data)\n    return -1;\n\n  char *endp = NULL;\n\n  errno = 0;\n  unsigned int index = strtoul(line, &endp, 10);\n  if (errno != 0)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n\n  struct Mailbox *m = data;\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct PopEmailData *edata = pop_edata_get(m->emails[i]);\n    if (mutt_str_strcmp(edata->uid, endp) == 0)\n    {\n      edata->refno = index;\n      break;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * pop_reconnect - reconnect and verify indexes if connection was lost\n * @param m Mailbox\n * @retval  0 Success\n * @retval -1 Error\n */\nint pop_reconnect(struct Mailbox *m)\n{\n  struct PopAccountData *adata = pop_adata_get(m);\n\n  if (adata->status == POP_CONNECTED)\n    return 0;\n\n  while (true)\n  {\n    mutt_socket_close(adata->conn);\n\n    int ret = pop_open_connection(adata);\n    if (ret == 0)\n    {\n      struct Progress progress;\n      mutt_progress_init(&progress, _(\"Verifying message indexes...\"), MUTT_PROGRESS_NET, 0);\n\n      for (int i = 0; i < m->msg_count; i++)\n      {\n        struct PopEmailData *edata = pop_edata_get(m->emails[i]);\n        edata->refno = -1;\n      }\n\n      ret = pop_fetch_data(adata, \"UIDL\\r\\n\", &progress, check_uidl, m);\n      if (ret == -2)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n    }\n    if (ret == 0)\n      return 0;\n\n    pop_logout(m);\n\n    if (ret < -1)\n      return -1;\n\n    if (query_quadoption(C_PopReconnect,\n                         _(\"Connection lost. Reconnect to POP server?\")) != MUTT_YES)\n    {\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_adata_get - Get the Account data for this mailbox\n * @param m Mailbox\n * @retval ptr PopAccountData\n */\nstruct PopAccountData *pop_adata_get(struct Mailbox *m)\n{\n  if (!m || (m->type != MUTT_POP))\n    return NULL;\n  struct Account *a = m->account;\n  if (!a)\n    return NULL;\n  return a->adata;\n}\n", "/**\n * @file\n * Send email to an SMTP server\n *\n * @authors\n * Copyright (C) 2002 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2005-2009 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2019 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page smtp Send email to an SMTP server\n *\n * Send email to an SMTP server\n */\n\n/* This file contains code for direct SMTP delivery of email messages. */\n\n#include \"config.h\"\n#include <netdb.h>\n#include <netinet/in.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"email/lib.h\"\n#include \"conn/lib.h\"\n#include \"smtp.h\"\n#include \"globals.h\"\n#include \"init.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"progress.h\"\n#include \"sendlib.h\"\n#ifdef USE_SSL\n#include \"config/lib.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#include \"options.h\"\n#endif\n\n/* These Config Variables are only used in smtp.c */\nstruct Slist *C_SmtpAuthenticators; ///< Config: (smtp) List of allowed authentication methods\nchar *C_SmtpOauthRefreshCommand; ///< Config: (smtp) External command to generate OAUTH refresh token\nchar *C_SmtpPass; ///< Config: (smtp) Password for the SMTP server\nchar *C_SmtpUser; ///< Config: (smtp) Username for the SMTP server\n\n#define smtp_success(x) ((x) / 100 == 2)\n#define SMTP_READY 334\n#define SMTP_CONTINUE 354\n\n#define SMTP_ERR_READ -2\n#define SMTP_ERR_WRITE -3\n#define SMTP_ERR_CODE -4\n\n#define SMTP_PORT 25\n#define SMTPS_PORT 465\n\n#define SMTP_AUTH_SUCCESS 0\n#define SMTP_AUTH_UNAVAIL 1\n#define SMTP_AUTH_FAIL -1\n\n// clang-format off\n/**\n * typedef SmtpCapFlags - SMTP server capabilities\n */\ntypedef uint8_t SmtpCapFlags;           ///< Flags, e.g. #SMTP_CAP_STARTTLS\n#define SMTP_CAP_NO_FLAGS            0  ///< No flags are set\n#define SMTP_CAP_STARTTLS     (1 << 0) ///< Server supports STARTTLS command\n#define SMTP_CAP_AUTH         (1 << 1) ///< Server supports AUTH command\n#define SMTP_CAP_DSN          (1 << 2) ///< Server supports Delivery Status Notification\n#define SMTP_CAP_EIGHTBITMIME (1 << 3) ///< Server supports 8-bit MIME content\n#define SMTP_CAP_SMTPUTF8     (1 << 4) ///< Server accepts UTF-8 strings\n\n#define SMTP_CAP_ALL         ((1 << 5) - 1)\n// clang-format on\n\nstatic char *AuthMechs = NULL;\nstatic SmtpCapFlags Capabilities;\n\n/**\n * valid_smtp_code - Is the is a valid SMTP return code?\n * @param[in]  buf String to check\n * @param[in]  buflen Length of string\n * @param[out] n   Numeric value of code\n * @retval true Valid number\n */\nstatic bool valid_smtp_code(char *buf, size_t buflen, int *n)\n{\n  char code[4];\n\n  if (buflen < 4)\n    return false;\n  code[0] = buf[0];\n  code[1] = buf[1];\n  code[2] = buf[2];\n  code[3] = '\\0';\n  if (mutt_str_atoi(code, n) < 0)\n    return false;\n  return true;\n}\n\n/**\n * smtp_get_resp - Read a command response from the SMTP server\n * @param conn SMTP connection\n * @retval  0 Success (2xx code) or continue (354 code)\n * @retval -1 Write error, or any other response code\n */\nstatic int smtp_get_resp(struct Connection *conn)\n{\n  int n;\n  char buf[1024];\n\n  do\n  {\n    n = mutt_socket_readln(buf, sizeof(buf), conn);\n    if (n < 4)\n    {\n      /* read error, or no response code */\n      return SMTP_ERR_READ;\n    }\n    const char *s = buf + 4; /* Skip the response code and the space/dash */\n    size_t plen;\n\n    if (mutt_str_startswith(s, \"8BITMIME\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_EIGHTBITMIME;\n    else if ((plen = mutt_str_startswith(s, \"AUTH \", CASE_IGNORE)))\n    {\n      Capabilities |= SMTP_CAP_AUTH;\n      FREE(&AuthMechs);\n      AuthMechs = mutt_str_strdup(s + plen);\n    }\n    else if (mutt_str_startswith(s, \"DSN\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_DSN;\n    else if (mutt_str_startswith(s, \"STARTTLS\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_STARTTLS;\n    else if (mutt_str_startswith(s, \"SMTPUTF8\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_SMTPUTF8;\n\n    if (!valid_smtp_code(buf, n, &n))\n      return SMTP_ERR_CODE;\n\n  } while (buf[3] == '-');\n\n  if (smtp_success(n) || (n == SMTP_CONTINUE))\n    return 0;\n\n  mutt_error(_(\"SMTP session failed: %s\"), buf);\n  return -1;\n}\n\n/**\n * smtp_rcpt_to - Set the recipient to an Address\n * @param conn Server Connection\n * @param al   AddressList to use\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_rcpt_to(struct Connection *conn, const struct AddressList *al)\n{\n  if (!al)\n    return 0;\n\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    /* weed out group mailboxes, since those are for display only */\n    if (!a->mailbox || a->group)\n    {\n      continue;\n    }\n    char buf[1024];\n    if ((Capabilities & SMTP_CAP_DSN) && C_DsnNotify)\n      snprintf(buf, sizeof(buf), \"RCPT TO:<%s> NOTIFY=%s\\r\\n\", a->mailbox, C_DsnNotify);\n    else\n      snprintf(buf, sizeof(buf), \"RCPT TO:<%s>\\r\\n\", a->mailbox);\n    if (mutt_socket_send(conn, buf) == -1)\n      return SMTP_ERR_WRITE;\n    int rc = smtp_get_resp(conn);\n    if (rc != 0)\n      return rc;\n  }\n\n  return 0;\n}\n\n/**\n * smtp_data - Send data to an SMTP server\n * @param conn    SMTP Connection\n * @param msgfile Filename containing data\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_data(struct Connection *conn, const char *msgfile)\n{\n  char buf[1024];\n  struct Progress progress;\n  struct stat st;\n  int rc, term = 0;\n  size_t buflen = 0;\n\n  FILE *fp = fopen(msgfile, \"r\");\n  if (!fp)\n  {\n    mutt_error(_(\"SMTP session failed: unable to open %s\"), msgfile);\n    return -1;\n  }\n  stat(msgfile, &st);\n  unlink(msgfile);\n  mutt_progress_init(&progress, _(\"Sending message...\"), MUTT_PROGRESS_NET, st.st_size);\n\n  snprintf(buf, sizeof(buf), \"DATA\\r\\n\");\n  if (mutt_socket_send(conn, buf) == -1)\n  {\n    mutt_file_fclose(&fp);\n    return SMTP_ERR_WRITE;\n  }\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n  {\n    mutt_file_fclose(&fp);\n    return rc;\n  }\n\n  while (fgets(buf, sizeof(buf) - 1, fp))\n  {\n    buflen = mutt_str_strlen(buf);\n    term = buflen && buf[buflen - 1] == '\\n';\n    if (term && ((buflen == 1) || (buf[buflen - 2] != '\\r')))\n      snprintf(buf + buflen - 1, sizeof(buf) - buflen + 1, \"\\r\\n\");\n    if (buf[0] == '.')\n    {\n      if (mutt_socket_send_d(conn, \".\", MUTT_SOCK_LOG_FULL) == -1)\n      {\n        mutt_file_fclose(&fp);\n        return SMTP_ERR_WRITE;\n      }\n    }\n    if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) == -1)\n    {\n      mutt_file_fclose(&fp);\n      return SMTP_ERR_WRITE;\n    }\n    mutt_progress_update(&progress, ftell(fp), -1);\n  }\n  if (!term && buflen && (mutt_socket_send_d(conn, \"\\r\\n\", MUTT_SOCK_LOG_FULL) == -1))\n  {\n    mutt_file_fclose(&fp);\n    return SMTP_ERR_WRITE;\n  }\n  mutt_file_fclose(&fp);\n\n  /* terminate the message body */\n  if (mutt_socket_send(conn, \".\\r\\n\") == -1)\n    return SMTP_ERR_WRITE;\n\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  return 0;\n}\n\n/**\n * address_uses_unicode - Do any addresses use Unicode\n * @param a Address list to check\n * @retval true if any of the string of addresses use 8-bit characters\n */\nstatic bool address_uses_unicode(const char *a)\n{\n  if (!a)\n    return false;\n\n  while (*a)\n  {\n    if ((unsigned char) *a & (1 << 7))\n      return true;\n    a++;\n  }\n\n  return false;\n}\n\n/**\n * addresses_use_unicode - Do any of a list of addresses use Unicode\n * @param al Address list to check\n * @retval true if any use 8-bit characters\n */\nstatic bool addresses_use_unicode(const struct AddressList *al)\n{\n  if (!al)\n  {\n    return false;\n  }\n\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    if (a->mailbox && !a->group && address_uses_unicode(a->mailbox))\n      return true;\n  }\n  return false;\n}\n\n/**\n * smtp_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nstatic const char *smtp_get_field(enum ConnAccountField field)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n    case MUTT_CA_USER:\n      return C_SmtpUser;\n    case MUTT_CA_PASS:\n      return C_SmtpPass;\n    case MUTT_CA_OAUTH_CMD:\n      return C_SmtpOauthRefreshCommand;\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n/**\n * smtp_fill_account - Create ConnAccount object from SMTP Url\n * @param cac ConnAccount to populate\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int smtp_fill_account(struct ConnAccount *cac)\n{\n  cac->flags = 0;\n  cac->port = 0;\n  cac->type = MUTT_ACCT_TYPE_SMTP;\n  cac->service = \"smtp\";\n  cac->get_field = smtp_get_field;\n\n  struct Url *url = url_parse(C_SmtpUrl);\n  if (!url || ((url->scheme != U_SMTP) && (url->scheme != U_SMTPS)) ||\n      !url->host || (mutt_account_fromurl(cac, url) < 0))\n  {\n    url_free(&url);\n    mutt_error(_(\"Invalid SMTP URL: %s\"), C_SmtpUrl);\n    return -1;\n  }\n\n  if (url->scheme == U_SMTPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  if (cac->port == 0)\n  {\n    if (cac->flags & MUTT_ACCT_SSL)\n      cac->port = SMTPS_PORT;\n    else\n    {\n      static unsigned short SmtpPort = 0;\n      if (SmtpPort == 0)\n      {\n        struct servent *service = getservbyname(\"smtp\", \"tcp\");\n        if (service)\n          SmtpPort = ntohs(service->s_port);\n        else\n          SmtpPort = SMTP_PORT;\n        mutt_debug(LL_DEBUG3, \"Using default SMTP port %d\\n\", SmtpPort);\n      }\n      cac->port = SmtpPort;\n    }\n  }\n\n  url_free(&url);\n  return 0;\n}\n\n/**\n * smtp_helo - Say hello to an SMTP Server\n * @param conn  SMTP Connection\n * @param esmtp If true, use ESMTP\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_helo(struct Connection *conn, bool esmtp)\n{\n  Capabilities = 0;\n\n  if (!esmtp)\n  {\n    /* if TLS or AUTH are requested, use EHLO */\n    if (conn->account.flags & MUTT_ACCT_USER)\n      esmtp = true;\n#ifdef USE_SSL\n    if (C_SslForceTls || (C_SslStarttls != MUTT_NO))\n      esmtp = true;\n#endif\n  }\n\n  const char *fqdn = mutt_fqdn(false);\n  if (!fqdn)\n    fqdn = NONULL(ShortHostname);\n\n  char buf[1024];\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", esmtp ? \"EHLO\" : \"HELO\", fqdn);\n  /* XXX there should probably be a wrapper in mutt_socket.c that\n   * repeatedly calls conn->write until all data is sent.  This\n   * currently doesn't check for a short write.  */\n  if (mutt_socket_send(conn, buf) == -1)\n    return SMTP_ERR_WRITE;\n  return smtp_get_resp(conn);\n}\n\n#ifdef USE_SASL\n/**\n * smtp_auth_sasl - Authenticate using SASL\n * @param conn     SMTP Connection\n * @param mechlist List of mechanisms to use\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth_sasl(struct Connection *conn, const char *mechlist)\n{\n  sasl_conn_t *saslconn = NULL;\n  sasl_interact_t *interaction = NULL;\n  const char *mech = NULL;\n  const char *data = NULL;\n  unsigned int len;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  int rc, saslrc;\n\n  if (mutt_sasl_client_new(conn, &saslconn) < 0)\n    return SMTP_AUTH_FAIL;\n\n  do\n  {\n    rc = sasl_client_start(saslconn, mechlist, &interaction, &data, &len, &mech);\n    if (rc == SASL_INTERACT)\n      mutt_sasl_interact(interaction);\n  } while (rc == SASL_INTERACT);\n\n  if ((rc != SASL_OK) && (rc != SASL_CONTINUE))\n  {\n    mutt_debug(LL_DEBUG2, \"%s unavailable\\n\", mech);\n    sasl_dispose(&saslconn);\n    return SMTP_AUTH_UNAVAIL;\n  }\n\n  if (!OptNoCurses)\n    mutt_message(_(\"Authenticating (%s)...\"), mech);\n\n  bufsize = MAX((len * 2), 1024);\n  buf = mutt_mem_malloc(bufsize);\n\n  snprintf(buf, bufsize, \"AUTH %s\", mech);\n  if (len)\n  {\n    mutt_str_strcat(buf, bufsize, \" \");\n    if (sasl_encode64(data, len, buf + mutt_str_strlen(buf),\n                      bufsize - mutt_str_strlen(buf), &len) != SASL_OK)\n    {\n      mutt_debug(LL_DEBUG1, \"#1 error base64-encoding client response\\n\");\n      goto fail;\n    }\n  }\n  mutt_str_strcat(buf, bufsize, \"\\r\\n\");\n\n  do\n  {\n    if (mutt_socket_send(conn, buf) < 0)\n      goto fail;\n    rc = mutt_socket_readln_d(buf, bufsize, conn, MUTT_SOCK_LOG_FULL);\n    if (rc < 0)\n      goto fail;\n    if (!valid_smtp_code(buf, rc, &rc))\n      goto fail;\n\n    if (rc != SMTP_READY)\n      break;\n\n    if (sasl_decode64(buf + 4, strlen(buf + 4), buf, bufsize - 1, &len) != SASL_OK)\n    {\n      mutt_debug(LL_DEBUG1, \"error base64-decoding server response\\n\");\n      goto fail;\n    }\n\n    do\n    {\n      saslrc = sasl_client_step(saslconn, buf, len, &interaction, &data, &len);\n      if (saslrc == SASL_INTERACT)\n        mutt_sasl_interact(interaction);\n    } while (saslrc == SASL_INTERACT);\n\n    if (len)\n    {\n      if ((len * 2) > bufsize)\n      {\n        bufsize = len * 2;\n        mutt_mem_realloc(&buf, bufsize);\n      }\n      if (sasl_encode64(data, len, buf, bufsize, &len) != SASL_OK)\n      {\n        mutt_debug(LL_DEBUG1, \"#2 error base64-encoding client response\\n\");\n        goto fail;\n      }\n    }\n    mutt_str_strfcpy(buf + len, \"\\r\\n\", bufsize - len);\n  } while (rc == SMTP_READY && saslrc != SASL_FAIL);\n\n  if (smtp_success(rc))\n  {\n    mutt_sasl_setup_conn(conn, saslconn);\n    FREE(&buf);\n    return SMTP_AUTH_SUCCESS;\n  }\n\nfail:\n  sasl_dispose(&saslconn);\n  FREE(&buf);\n  return SMTP_AUTH_FAIL;\n}\n#endif\n\n/**\n * smtp_auth_oauth - Authenticate an SMTP connection using OAUTHBEARER\n * @param conn Connection info\n * @retval num Result, e.g. #SMTP_AUTH_SUCCESS\n */\nstatic int smtp_auth_oauth(struct Connection *conn)\n{\n  mutt_message(_(\"Authenticating (OAUTHBEARER)...\"));\n\n  /* We get the access token from the smtp_oauth_refresh_command */\n  char *oauthbearer = mutt_account_getoauthbearer(&conn->account);\n  if (!oauthbearer)\n    return SMTP_AUTH_FAIL;\n\n  size_t ilen = strlen(oauthbearer) + 30;\n  char *ibuf = mutt_mem_malloc(ilen);\n  snprintf(ibuf, ilen, \"AUTH OAUTHBEARER %s\\r\\n\", oauthbearer);\n\n  int rc = mutt_socket_send(conn, ibuf);\n  FREE(&oauthbearer);\n  FREE(&ibuf);\n\n  if (rc == -1)\n    return SMTP_AUTH_FAIL;\n  if (smtp_get_resp(conn) != 0)\n    return SMTP_AUTH_FAIL;\n\n  return SMTP_AUTH_SUCCESS;\n}\n\n/**\n * smtp_auth_plain - Authenticate using plain text\n * @param conn SMTP Connection\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth_plain(struct Connection *conn)\n{\n  char buf[1024];\n\n  /* Get username and password. Bail out of any can't be retrieved. */\n  if ((mutt_account_getuser(&conn->account) < 0) ||\n      (mutt_account_getpass(&conn->account) < 0))\n  {\n    goto error;\n  }\n\n  /* Build the initial client response. */\n  size_t len = mutt_sasl_plain_msg(buf, sizeof(buf), \"AUTH PLAIN\", conn->account.user,\n                                   conn->account.user, conn->account.pass);\n\n  /* Terminate as per SMTP protocol. Bail out if there's no room left. */\n  if (snprintf(buf + len, sizeof(buf) - len, \"\\r\\n\") != 2)\n  {\n    goto error;\n  }\n\n  /* Send request, receive response (with a check for OK code). */\n  if ((mutt_socket_send(conn, buf) < 0) || smtp_get_resp(conn))\n  {\n    goto error;\n  }\n\n  /* If we got here, auth was successful. */\n  return 0;\n\nerror:\n  mutt_error(_(\"SASL authentication failed\"));\n  return -1;\n}\n\n/**\n * smtp_auth - Authenticate to an SMTP server\n * @param conn SMTP Connection\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth(struct Connection *conn)\n{\n  int r = SMTP_AUTH_UNAVAIL;\n\n  if (C_SmtpAuthenticators)\n  {\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &C_SmtpAuthenticators->head, entries)\n    {\n      mutt_debug(LL_DEBUG2, \"Trying method %s\\n\", np->data);\n\n      if (strcmp(np->data, \"oauthbearer\") == 0)\n      {\n        r = smtp_auth_oauth(conn);\n      }\n      else if (strcmp(np->data, \"plain\") == 0)\n      {\n        r = smtp_auth_plain(conn);\n      }\n      else\n      {\n#ifdef USE_SASL\n        r = smtp_auth_sasl(conn, np->data);\n#else\n        mutt_error(_(\"SMTP authentication method %s requires SASL\"), np->data);\n        continue;\n#endif\n      }\n\n      if ((r == SMTP_AUTH_FAIL) && (C_SmtpAuthenticators->count > 1))\n      {\n        mutt_error(_(\"%s authentication failed, trying next method\"), np->data);\n      }\n      else if (r != SMTP_AUTH_UNAVAIL)\n        break;\n    }\n  }\n  else\n  {\n#ifdef USE_SASL\n    r = smtp_auth_sasl(conn, AuthMechs);\n#else\n    mutt_error(_(\"SMTP authentication requires SASL\"));\n    r = SMTP_AUTH_UNAVAIL;\n#endif\n  }\n\n  if (r != SMTP_AUTH_SUCCESS)\n    mutt_account_unsetpass(&conn->account);\n\n  if (r == SMTP_AUTH_FAIL)\n  {\n    mutt_error(_(\"SASL authentication failed\"));\n  }\n  else if (r == SMTP_AUTH_UNAVAIL)\n  {\n    mutt_error(_(\"No authenticators available\"));\n  }\n\n  return (r == SMTP_AUTH_SUCCESS) ? 0 : -1;\n}\n\n/**\n * smtp_open - Open an SMTP Connection\n * @param conn  SMTP Connection\n * @param esmtp If true, use ESMTP\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n\n  if (mutt_socket_open(conn))\n    return -1;\n\n  /* get greeting string */\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    if (rc != 0)\n      return rc;\n\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n\n    /* re-EHLO to get authentication mechanisms */\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n\n    return smtp_auth(conn);\n  }\n\n  return 0;\n}\n\n/**\n * mutt_smtp_send - Send a message using SMTP\n * @param from     From Address\n * @param to       To Address\n * @param cc       Cc Address\n * @param bcc      Bcc Address\n * @param msgfile  Message to send to the server\n * @param eightbit If true, try for an 8-bit friendly connection\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_smtp_send(const struct AddressList *from, const struct AddressList *to,\n                   const struct AddressList *cc, const struct AddressList *bcc,\n                   const char *msgfile, bool eightbit)\n{\n  struct Connection *conn = NULL;\n  struct ConnAccount cac = { { 0 } };\n  const char *envfrom = NULL;\n  char buf[1024];\n  int rc = -1;\n\n  /* it might be better to synthesize an envelope from from user and host\n   * but this condition is most likely arrived at accidentally */\n  if (C_EnvelopeFromAddress)\n    envfrom = C_EnvelopeFromAddress->mailbox;\n  else if (from && !TAILQ_EMPTY(from))\n    envfrom = TAILQ_FIRST(from)->mailbox;\n  else\n  {\n    mutt_error(_(\"No from address given\"));\n    return -1;\n  }\n\n  if (smtp_fill_account(&cac) < 0)\n    return rc;\n\n  conn = mutt_conn_find(&cac);\n  if (!conn)\n    return -1;\n\n  do\n  {\n    /* send our greeting */\n    rc = smtp_open(conn, eightbit);\n    if (rc != 0)\n      break;\n    FREE(&AuthMechs);\n\n    /* send the sender's address */\n    int len = snprintf(buf, sizeof(buf), \"MAIL FROM:<%s>\", envfrom);\n    if (eightbit && (Capabilities & SMTP_CAP_EIGHTBITMIME))\n    {\n      mutt_str_strncat(buf, sizeof(buf), \" BODY=8BITMIME\", 15);\n      len += 14;\n    }\n    if (C_DsnReturn && (Capabilities & SMTP_CAP_DSN))\n      len += snprintf(buf + len, sizeof(buf) - len, \" RET=%s\", C_DsnReturn);\n    if ((Capabilities & SMTP_CAP_SMTPUTF8) &&\n        (address_uses_unicode(envfrom) || addresses_use_unicode(to) ||\n         addresses_use_unicode(cc) || addresses_use_unicode(bcc)))\n    {\n      snprintf(buf + len, sizeof(buf) - len, \" SMTPUTF8\");\n    }\n    mutt_str_strncat(buf, sizeof(buf), \"\\r\\n\", 3);\n    if (mutt_socket_send(conn, buf) == -1)\n    {\n      rc = SMTP_ERR_WRITE;\n      break;\n    }\n    rc = smtp_get_resp(conn);\n    if (rc != 0)\n      break;\n\n    /* send the recipient list */\n    if ((rc = smtp_rcpt_to(conn, to)) || (rc = smtp_rcpt_to(conn, cc)) ||\n        (rc = smtp_rcpt_to(conn, bcc)))\n    {\n      break;\n    }\n\n    /* send the message data */\n    rc = smtp_data(conn, msgfile);\n    if (rc != 0)\n      break;\n\n    mutt_socket_send(conn, \"QUIT\\r\\n\");\n\n    rc = 0;\n  } while (false);\n\n  mutt_socket_close(conn);\n  FREE(&conn);\n\n  if (rc == SMTP_ERR_READ)\n    mutt_error(_(\"SMTP session failed: read error\"));\n  else if (rc == SMTP_ERR_WRITE)\n    mutt_error(_(\"SMTP session failed: write error\"));\n  else if (rc == SMTP_ERR_CODE)\n    mutt_error(_(\"Invalid server response\"));\n\n  return rc;\n}\n"], "fixing_code": ["/**\n * @file\n * Low-level socket handling\n *\n * @authors\n * Copyright (C) 1998,2000 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1999-2006,2008 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 1999-2000 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page conn_socket Low-level socket handling\n *\n * Low-level socket handling\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <string.h>\n#include <time.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"socket.h\"\n#include \"conn_globals.h\"\n#include \"connaccount.h\"\n#include \"connection.h\"\n#include \"protos.h\"\n#include \"ssl.h\"\n\n/**\n * socket_preconnect - Execute a command before opening a socket\n * @retval 0  Success\n * @retval >0 An errno, e.g. EPERM\n */\nstatic int socket_preconnect(void)\n{\n  if (!C_Preconnect)\n    return 0;\n\n  mutt_debug(LL_DEBUG2, \"Executing preconnect: %s\\n\", C_Preconnect);\n  const int rc = mutt_system(C_Preconnect);\n  mutt_debug(LL_DEBUG2, \"Preconnect result: %d\\n\", rc);\n  if (rc != 0)\n  {\n    const int save_errno = errno;\n    mutt_perror(_(\"Preconnect command failed\"));\n\n    return save_errno;\n  }\n\n  return 0;\n}\n\n/**\n * mutt_socket_open - Simple wrapper\n * @param conn Connection to a server\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_socket_open(struct Connection *conn)\n{\n  int rc;\n\n  if (socket_preconnect())\n    return -1;\n\n  rc = conn->open(conn);\n\n  mutt_debug(LL_DEBUG2, \"Connected to %s:%d on fd=%d\\n\", conn->account.host,\n             conn->account.port, conn->fd);\n\n  return rc;\n}\n\n/**\n * mutt_socket_close - Close a socket\n * @param conn Connection to a server\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_socket_close(struct Connection *conn)\n{\n  if (!conn)\n    return 0;\n\n  int rc = -1;\n\n  if (conn->fd < 0)\n    mutt_debug(LL_DEBUG1, \"Attempt to close closed connection\\n\");\n  else\n    rc = conn->close(conn);\n\n  conn->fd = -1;\n  conn->ssf = 0;\n  conn->bufpos = 0;\n  conn->available = 0;\n\n  return rc;\n}\n\n/**\n * mutt_socket_read - read from a Connection\n * @param conn Connection a server\n * @param buf Buffer to store read data\n * @param len length of the buffer\n * @retval >0 Success, number of bytes read\n * @retval -1 Error, see errno\n */\nint mutt_socket_read(struct Connection *conn, char *buf, size_t len)\n{\n  return conn->read(conn, buf, len);\n}\n\n/**\n * mutt_socket_write - write to a Connection\n * @param conn Connection to a server\n * @param buf Buffer with data to write\n * @param len Length of data to write\n * @retval >0 Number of bytes written\n * @retval -1 Error\n */\nint mutt_socket_write(struct Connection *conn, const char *buf, size_t len)\n{\n  return conn->write(conn, buf, len);\n}\n\n/**\n * mutt_socket_write_d - Write data to a socket\n * @param conn Connection to a server\n * @param buf Buffer with data to write\n * @param len Length of data to write\n * @param dbg Debug level for logging\n * @retval >0 Number of bytes written\n * @retval -1 Error\n */\nint mutt_socket_write_d(struct Connection *conn, const char *buf, int len, int dbg)\n{\n  int sent = 0;\n\n  mutt_debug(dbg, \"%d> %s\", conn->fd, buf);\n\n  if (conn->fd < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"attempt to write to closed connection\\n\");\n    return -1;\n  }\n\n  while (sent < len)\n  {\n    const int rc = conn->write(conn, buf + sent, len - sent);\n    if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"error writing (%s), closing socket\\n\", strerror(errno));\n      mutt_socket_close(conn);\n\n      return -1;\n    }\n\n    if (rc < len - sent)\n      mutt_debug(LL_DEBUG3, \"short write (%d of %d bytes)\\n\", rc, len - sent);\n\n    sent += rc;\n  }\n\n  return sent;\n}\n\n/**\n * mutt_socket_poll - Checks whether reads would block\n * @param conn Connection to a server\n * @param wait_secs How long to wait for a response\n * @retval >0 There is data to read\n * @retval  0 Read would block\n * @retval -1 Connection doesn't support polling\n */\nint mutt_socket_poll(struct Connection *conn, time_t wait_secs)\n{\n  if (conn->bufpos < conn->available)\n    return conn->available - conn->bufpos;\n\n  if (conn->poll)\n    return conn->poll(conn, wait_secs);\n\n  return -1;\n}\n\n/**\n * mutt_socket_readchar - simple read buffering to speed things up\n * @param[in]  conn Connection to a server\n * @param[out] c    Character that was read\n * @retval  1 Success\n * @retval -1 Error\n */\nint mutt_socket_readchar(struct Connection *conn, char *c)\n{\n  if (conn->bufpos >= conn->available)\n  {\n    if (conn->fd >= 0)\n      conn->available = conn->read(conn, conn->inbuf, sizeof(conn->inbuf));\n    else\n    {\n      mutt_debug(LL_DEBUG1, \"attempt to read from closed connection\\n\");\n      return -1;\n    }\n    conn->bufpos = 0;\n    if (conn->available == 0)\n    {\n      mutt_error(_(\"Connection to %s closed\"), conn->account.host);\n    }\n    if (conn->available <= 0)\n    {\n      mutt_socket_close(conn);\n      return -1;\n    }\n  }\n  *c = conn->inbuf[conn->bufpos];\n  conn->bufpos++;\n  return 1;\n}\n\n/**\n * mutt_socket_readln_d - Read a line from a socket\n * @param buf    Buffer to store the line\n * @param buflen Length of data to write\n * @param conn   Connection to a server\n * @param dbg    Debug level for logging\n * @retval >0 Success, number of bytes read\n * @retval -1 Error\n */\nint mutt_socket_readln_d(char *buf, size_t buflen, struct Connection *conn, int dbg)\n{\n  char ch;\n  int i;\n\n  for (i = 0; i < buflen - 1; i++)\n  {\n    if (mutt_socket_readchar(conn, &ch) != 1)\n    {\n      buf[i] = '\\0';\n      return -1;\n    }\n\n    if (ch == '\\n')\n      break;\n    buf[i] = ch;\n  }\n\n  /* strip \\r from \\r\\n termination */\n  if (i && (buf[i - 1] == '\\r'))\n    i--;\n  buf[i] = '\\0';\n\n  mutt_debug(dbg, \"%d< %s\\n\", conn->fd, buf);\n\n  /* number of bytes read, not strlen */\n  return i + 1;\n}\n\n/**\n * mutt_socket_new - allocate and initialise a new connection\n * @param type Type of the new Connection\n * @retval ptr New Connection\n */\nstruct Connection *mutt_socket_new(enum ConnectionType type)\n{\n  struct Connection *conn = mutt_mem_calloc(1, sizeof(struct Connection));\n  conn->fd = -1;\n\n  if (type == MUTT_CONNECTION_TUNNEL)\n  {\n    mutt_tunnel_socket_setup(conn);\n  }\n  else if (type == MUTT_CONNECTION_SSL)\n  {\n    int rc = mutt_ssl_socket_setup(conn);\n    if (rc < 0)\n      FREE(&conn);\n  }\n  else\n  {\n    conn->read = raw_socket_read;\n    conn->write = raw_socket_write;\n    conn->open = raw_socket_open;\n    conn->close = raw_socket_close;\n    conn->poll = raw_socket_poll;\n  }\n\n  return conn;\n}\n\n/**\n * mutt_socket_empty - Clear out any queued data\n *\n * The internal buffer is emptied and any data that has already arrived at this\n * machine (in kernel buffers) is read and dropped.\n */\nvoid mutt_socket_empty(struct Connection *conn)\n{\n  if (!conn)\n    return;\n\n  char buf[1024];\n  int bytes;\n\n  while ((bytes = mutt_socket_poll(conn, 0)) > 0)\n  {\n    mutt_socket_read(conn, buf, MIN(bytes, sizeof(buf)));\n  }\n}\n", "/**\n * @file\n * Low-level socket handling\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2005 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_CONN_SOCKET_H\n#define MUTT_CONN_SOCKET_H\n\n#include <time.h>\n\nstruct Connection;\n\n/**\n * enum ConnectionType - Type of connection\n */\nenum ConnectionType\n{\n  MUTT_CONNECTION_SIMPLE, ///< Simple TCP socket connection\n  MUTT_CONNECTION_TUNNEL, ///< Tunnelled connection\n  MUTT_CONNECTION_SSL,    ///< SSL/TLS-encrypted connection\n};\n\nint                mutt_socket_close   (struct Connection *conn);\nvoid               mutt_socket_empty   (struct Connection *conn);\nstruct Connection *mutt_socket_new     (enum ConnectionType type);\nint                mutt_socket_open    (struct Connection *conn);\nint                mutt_socket_poll    (struct Connection *conn, time_t wait_secs);\nint                mutt_socket_read    (struct Connection *conn, char *buf, size_t len);\nint                mutt_socket_readchar(struct Connection *conn, char *c);\nint                mutt_socket_readln_d(char *buf, size_t buflen, struct Connection *conn, int dbg);\nint                mutt_socket_write   (struct Connection *conn, const char *buf, size_t len);\nint                mutt_socket_write_d (struct Connection *conn, const char *buf, int len, int dbg);\n\n#endif /* MUTT_CONN_SOCKET_H */\n", "/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"globals.h\"\n#include \"init.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n\n/* These Config Variables are only used in imap/command.c */\nbool C_ImapServernoise; ///< Config: (imap) Display server warnings as error messages\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",\n  \"IMAP4rev1\",\n  \"STATUS\",\n  \"ACL\",\n  \"NAMESPACE\",\n  \"AUTH=CRAM-MD5\",\n  \"AUTH=GSSAPI\",\n  \"AUTH=ANONYMOUS\",\n  \"AUTH=OAUTHBEARER\",\n  \"STARTTLS\",\n  \"LOGINDISABLED\",\n  \"IDLE\",\n  \"SASL-IR\",\n  \"ENABLE\",\n  \"CONDSTORE\",\n  \"QRESYNC\",\n  \"LIST-EXTENDED\",\n  \"COMPRESS=DEFLATE\",\n  \"X-GM-EXT-1\",\n  NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param adata Imap Account data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapAccountData *adata)\n{\n  if (((adata->nextcmd + 1) % adata->cmdslots) == adata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param adata Imap Account data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapAccountData *adata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(adata))\n  {\n    mutt_debug(LL_DEBUG3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = adata->cmds + adata->nextcmd;\n  adata->nextcmd = (adata->nextcmd + 1) % adata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"%c%04u\", adata->seqid, adata->seqno++);\n  if (adata->seqno > 9999)\n    adata->seqno = 0;\n\n  cmd->state = IMAP_RES_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param adata Imap Account data\n * @param cmdstr Command string\n * @param flags  Server flags, see #ImapCmdFlags\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  if (cmd_queue_full(adata))\n  {\n    mutt_debug(LL_DEBUG3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(adata, NULL, flags & IMAP_CMD_POLL);\n\n    if (rc == IMAP_EXEC_ERROR)\n      return IMAP_RES_BAD;\n  }\n\n  struct ImapCommand *cmd = cmd_new(adata);\n  if (!cmd)\n    return IMAP_RES_BAD;\n\n  if (mutt_buffer_add_printf(&adata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_RES_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapAccountData is in fatal state, do what we can\n * @param adata Imap Account data\n */\nstatic void cmd_handle_fatal(struct ImapAccountData *adata)\n{\n  adata->status = IMAP_FATAL;\n\n  if (!adata->mailbox)\n    return;\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  if ((adata->state >= IMAP_SELECTED) && (mdata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(adata->mailbox);\n    mutt_socket_close(adata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), adata->conn->account.user,\n               adata->conn->account.host);\n    adata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(adata);\n  if (!adata->recovering)\n  {\n    adata->recovering = true;\n    if (imap_login(adata))\n      mutt_clear_error();\n    adata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param adata Imap Account data\n * @param cmdstr Command string\n * @param flags  Command flags, see #ImapCmdFlags\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nstatic int cmd_start(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(adata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (mutt_buffer_is_empty(&adata->cmdbuf))\n    return IMAP_RES_BAD;\n\n  rc = mutt_socket_send_d(adata->conn, adata->cmdbuf.data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  mutt_buffer_reset(&adata->cmdbuf);\n\n  /* unidle when command queue is flushed */\n  if (adata->state == IMAP_IDLE)\n    adata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_RES_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_startswith(s, \"OK\", CASE_IGNORE))\n    return IMAP_RES_OK;\n  if (mutt_str_startswith(s, \"NO\", CASE_IGNORE))\n    return IMAP_RES_NO;\n\n  return IMAP_RES_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param adata Imap Account data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark adata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapAccountData *adata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Email *e = NULL;\n\n  mutt_debug(LL_DEBUG2, \"Handling EXPUNGE\\n\");\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  if ((mutt_str_atoui(s, &exp_msn) < 0) || (exp_msn < 1) || (exp_msn > mdata->max_msn))\n    return;\n\n  e = mdata->msn_index[exp_msn - 1];\n  if (e)\n  {\n    /* imap_expunge_mailbox() will rewrite e->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    e->index = INT_MAX;\n    imap_edata_get(e)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)\n  {\n    e = mdata->msn_index[cur];\n    if (e)\n      imap_edata_get(e)->msn--;\n    mdata->msn_index[cur - 1] = e;\n  }\n\n  mdata->msn_index[mdata->max_msn - 1] = NULL;\n  mdata->max_msn--;\n\n  mdata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_vanished - Parse vanished command\n * @param adata Imap Account data\n * @param s     String containing MSN of message to expunge\n *\n * Handle VANISHED (RFC7162), which is like expunge, but passes a seqset of UIDs.\n * An optional (EARLIER) argument specifies not to decrement subsequent MSNs.\n */\nstatic void cmd_parse_vanished(struct ImapAccountData *adata, char *s)\n{\n  bool earlier = false;\n  int rc;\n  unsigned int uid = 0;\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  mutt_debug(LL_DEBUG2, \"Handling VANISHED\\n\");\n\n  if (mutt_str_startswith(s, \"(EARLIER)\", CASE_IGNORE))\n  {\n    /* The RFC says we should not decrement msns with the VANISHED EARLIER tag.\n     * My experimentation says that's crap. */\n    earlier = true;\n    s = imap_next_word(s);\n  }\n\n  char *end_of_seqset = s;\n  while (*end_of_seqset)\n  {\n    if (!strchr(\"0123456789:,\", *end_of_seqset))\n      *end_of_seqset = '\\0';\n    else\n      end_of_seqset++;\n  }\n\n  struct SeqsetIterator *iter = mutt_seqset_iterator_new(s);\n  if (!iter)\n  {\n    mutt_debug(LL_DEBUG2, \"VANISHED: empty seqset [%s]?\\n\", s);\n    return;\n  }\n\n  while ((rc = mutt_seqset_iterator_next(iter, &uid)) == 0)\n  {\n    struct Email *e = mutt_hash_int_find(mdata->uid_hash, uid);\n    if (!e)\n      continue;\n\n    unsigned int exp_msn = imap_edata_get(e)->msn;\n\n    /* imap_expunge_mailbox() will rewrite e->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    e->index = INT_MAX;\n    imap_edata_get(e)->msn = 0;\n\n    if ((exp_msn < 1) || (exp_msn > mdata->max_msn))\n    {\n      mutt_debug(LL_DEBUG1, \"VANISHED: msn for UID %u is incorrect\\n\", uid);\n      continue;\n    }\n    if (mdata->msn_index[exp_msn - 1] != e)\n    {\n      mutt_debug(LL_DEBUG1, \"VANISHED: msn_index for UID %u is incorrect\\n\", uid);\n      continue;\n    }\n\n    mdata->msn_index[exp_msn - 1] = NULL;\n\n    if (!earlier)\n    {\n      /* decrement seqno of those above. */\n      for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)\n      {\n        e = mdata->msn_index[cur];\n        if (e)\n          imap_edata_get(e)->msn--;\n        mdata->msn_index[cur - 1] = e;\n      }\n\n      mdata->msn_index[mdata->max_msn - 1] = NULL;\n      mdata->max_msn--;\n    }\n  }\n\n  if (rc < 0)\n    mutt_debug(LL_DEBUG1, \"VANISHED: illegal seqset %s\\n\", s);\n\n  mdata->reopen |= IMAP_EXPUNGE_PENDING;\n\n  mutt_seqset_iterator_free(&iter);\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapAccountData\n * @param adata Imap Account data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapAccountData *adata, char *s)\n{\n  unsigned int msn, uid;\n  struct Email *e = NULL;\n  char *flags = NULL;\n  int uid_checked = 0;\n  bool server_changes = false;\n\n  struct ImapMboxData *mdata = imap_mdata_get(adata->mailbox);\n\n  mutt_debug(LL_DEBUG3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0)\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - illegal MSN\\n\");\n    return;\n  }\n\n  if ((msn < 1) || (msn > mdata->max_msn))\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - MSN %u out of range\\n\", msn);\n    return;\n  }\n\n  e = mdata->msn_index[msn - 1];\n  if (!e || !e->active)\n  {\n    mutt_debug(LL_DEBUG3, \"Skipping FETCH response - MSN %u not in msn_index\\n\", msn);\n    return;\n  }\n\n  mutt_debug(LL_DEBUG2, \"Message UID %u updated\\n\", imap_edata_get(e)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n    size_t plen = mutt_str_startswith(s, \"FLAGS\", CASE_IGNORE);\n    if (plen != 0)\n    {\n      flags = s;\n      if (uid_checked)\n        break;\n\n      s += plen;\n      SKIPWS(s);\n      if (*s != '(')\n      {\n        mutt_debug(LL_DEBUG1, \"bogus FLAGS response: %s\\n\", s);\n        return;\n      }\n      s++;\n      while (*s && (*s != ')'))\n        s++;\n      if (*s == ')')\n        s++;\n      else\n      {\n        mutt_debug(LL_DEBUG1, \"Unterminated FLAGS response: %s\\n\", s);\n        return;\n      }\n    }\n    else if ((plen = mutt_str_startswith(s, \"UID\", CASE_IGNORE)))\n    {\n      s += plen;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(LL_DEBUG1, \"Illegal UID.  Skipping update\\n\");\n        return;\n      }\n      if (uid != imap_edata_get(e)->uid)\n      {\n        mutt_debug(LL_DEBUG1, \"UID vs MSN mismatch.  Skipping update\\n\");\n        return;\n      }\n      uid_checked = 1;\n      if (flags)\n        break;\n      s = imap_next_word(s);\n    }\n    else if ((plen = mutt_str_startswith(s, \"MODSEQ\", CASE_IGNORE)))\n    {\n      s += plen;\n      SKIPWS(s);\n      if (*s != '(')\n      {\n        mutt_debug(LL_DEBUG1, \"bogus MODSEQ response: %s\\n\", s);\n        return;\n      }\n      s++;\n      while (*s && (*s != ')'))\n        s++;\n      if (*s == ')')\n        s++;\n      else\n      {\n        mutt_debug(LL_DEBUG1, \"Unterminated MODSEQ response: %s\\n\", s);\n        return;\n      }\n    }\n    else if (*s == ')')\n      break; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(LL_DEBUG2, \"Only handle FLAGS updates\\n\");\n      break;\n    }\n  }\n\n  if (flags)\n  {\n    imap_set_flags(adata->mailbox, e, flags, &server_changes);\n    if (server_changes)\n    {\n      /* If server flags could conflict with NeoMutt's flags, reopen the mailbox. */\n      if (e->changed)\n        mdata->reopen |= IMAP_EXPUNGE_PENDING;\n      else\n        mdata->check_status |= IMAP_FLAGS_PENDING;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param adata Imap Account data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapAccountData *adata, char *s)\n{\n  mutt_debug(LL_DEBUG3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&adata->capstr);\n  adata->capstr = mutt_str_strdup(s);\n  adata->capabilities = 0;\n\n  while (*s)\n  {\n    for (size_t i = 0; Capabilities[i]; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        adata->capabilities |= (1 << i);\n        mutt_debug(LL_DEBUG3, \" Found capability \\\"%s\\\": %lu\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param adata Imap Account data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapAccountData *adata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb = { 0 };\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (adata->cmdresult)\n    list = adata->cmdresult;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_startswith(s, \"\\\\NoSelect\", CASE_IGNORE))\n      list->noselect = true;\n    else if (mutt_str_startswith(s, \"\\\\NonExistent\", CASE_IGNORE)) /* rfc5258 */\n      list->noselect = true;\n    else if (mutt_str_startswith(s, \"\\\\NoInferiors\", CASE_IGNORE))\n      list->noinferiors = true;\n    else if (mutt_str_startswith(s, \"\\\\HasNoChildren\", CASE_IGNORE)) /* rfc5258*/\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (!mutt_str_startswith(s, \"NIL\", CASE_IGNORE))\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n    {\n      adata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(adata->buf) < litlen)\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing LIST mailbox\\n\");\n      return;\n    }\n\n    list->name = adata->buf;\n    s = list->name + litlen;\n    if (s[0] != '\\0')\n    {\n      s[0] = '\\0';\n      s++;\n      SKIPWS(s);\n    }\n  }\n  else\n  {\n    list->name = s;\n    /* Exclude rfc5258 RECURSIVEMATCH CHILDINFO suffix */\n    s = imap_next_word(s);\n    if (s[0] != '\\0')\n      s[-1] = '\\0';\n    imap_unmunge_mbox_name(adata->unicode, list->name);\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    adata->delim = list->delim;\n    mutt_debug(LL_DEBUG3, \"Root delimiter: %c\\n\", adata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param adata Imap Account data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapAccountData *adata, char *s)\n{\n  char buf[256];\n  char quoted_name[256];\n  struct Buffer err;\n  struct Url url = { 0 };\n  struct ImapList list = { 0 };\n\n  if (adata->cmdresult)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(adata, s);\n    return;\n  }\n\n  if (!C_ImapCheckSubscribed)\n    return;\n\n  adata->cmdresult = &list;\n  cmd_parse_list(adata, s);\n  adata->cmdresult = NULL;\n  /* noselect is for a gmail quirk */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(LL_DEBUG3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&adata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(quoted_name, sizeof(quoted_name), list.name, true);\n  url.path = quoted_name + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, C_ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&err);\n  err.dsize = 256;\n  err.data = mutt_mem_malloc(err.dsize);\n  if (mutt_parse_rc_line(buf, &err))\n    mutt_debug(LL_DEBUG1, \"Error adding subscribed mailbox: %s\\n\", err.data);\n  FREE(&err.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param adata Imap Account data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapAccountData *adata, const char *s)\n{\n  mutt_debug(LL_DEBUG2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  adata->mailbox->rights = 0;\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        adata->mailbox->rights |= MUTT_ACL_ADMIN;\n        break;\n      case 'e':\n        adata->mailbox->rights |= MUTT_ACL_EXPUNGE;\n        break;\n      case 'i':\n        adata->mailbox->rights |= MUTT_ACL_INSERT;\n        break;\n      case 'k':\n        adata->mailbox->rights |= MUTT_ACL_CREATE;\n        break;\n      case 'l':\n        adata->mailbox->rights |= MUTT_ACL_LOOKUP;\n        break;\n      case 'p':\n        adata->mailbox->rights |= MUTT_ACL_POST;\n        break;\n      case 'r':\n        adata->mailbox->rights |= MUTT_ACL_READ;\n        break;\n      case 's':\n        adata->mailbox->rights |= MUTT_ACL_SEEN;\n        break;\n      case 't':\n        adata->mailbox->rights |= MUTT_ACL_DELETE;\n        break;\n      case 'w':\n        adata->mailbox->rights |= MUTT_ACL_WRITE;\n        break;\n      case 'x':\n        adata->mailbox->rights |= MUTT_ACL_DELMX;\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        adata->mailbox->rights |= MUTT_ACL_CREATE | MUTT_ACL_DELMX;\n        break;\n      case 'd':\n        adata->mailbox->rights |= MUTT_ACL_DELETE | MUTT_ACL_EXPUNGE;\n        break;\n      default:\n        mutt_debug(LL_DEBUG1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * find_mailbox - Find a Mailbox by its name\n * @param adata Imap Account data\n * @param name  Mailbox to find\n * @retval ptr Mailbox\n */\nstatic struct Mailbox *find_mailbox(struct ImapAccountData *adata, const char *name)\n{\n  if (!adata || !adata->account || !name)\n    return NULL;\n\n  struct MailboxNode *np = NULL;\n  STAILQ_FOREACH(np, &adata->account->mailboxes, entries)\n  {\n    struct ImapMboxData *mdata = imap_mdata_get(np->mailbox);\n    if (mutt_str_strcmp(name, mdata->name) == 0)\n      return np->mailbox;\n  }\n\n  return NULL;\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param adata Imap Account data\n * @param s     Command string with status info\n *\n * first cut: just do mailbox update. Later we may wish to cache all mailbox\n * information, even that not desired by mailbox\n */\nstatic void cmd_parse_status(struct ImapAccountData *adata, char *s)\n{\n  unsigned int litlen = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n    {\n      adata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(adata->buf) < litlen)\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing STATUS mailbox\\n\");\n      return;\n    }\n\n    mailbox = adata->buf;\n    s = mailbox + litlen;\n    s[0] = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    s[-1] = '\\0';\n    imap_unmunge_mbox_name(adata->unicode, mailbox);\n  }\n\n  struct Mailbox *m = find_mailbox(adata, mailbox);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!mdata)\n  {\n    mutt_debug(LL_DEBUG3, \"Received status for an unexpected mailbox: %s\\n\", mailbox);\n    return;\n  }\n  uint32_t olduv = mdata->uidvalidity;\n  unsigned int oldun = mdata->uid_next;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while ((s[0] != '\\0') && (s[0] != ')'))\n  {\n    char *value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(LL_DEBUG1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_startswith(s, \"MESSAGES\", CASE_MATCH))\n      mdata->messages = count;\n    else if (mutt_str_startswith(s, \"RECENT\", CASE_MATCH))\n      mdata->recent = count;\n    else if (mutt_str_startswith(s, \"UIDNEXT\", CASE_MATCH))\n      mdata->uid_next = count;\n    else if (mutt_str_startswith(s, \"UIDVALIDITY\", CASE_MATCH))\n      mdata->uidvalidity = count;\n    else if (mutt_str_startswith(s, \"UNSEEN\", CASE_MATCH))\n      mdata->unseen = count;\n\n    s = value;\n    if ((s[0] != '\\0') && (*s != ')'))\n      s = imap_next_word(s);\n  }\n  mutt_debug(LL_DEBUG3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             mdata->name, mdata->uidvalidity, mdata->uid_next, mdata->messages,\n             mdata->recent, mdata->unseen);\n\n  mutt_debug(LL_DEBUG3, \"Running default STATUS handler\\n\");\n\n  mutt_debug(LL_DEBUG3, \"Found %s in mailbox list (OV: %u ON: %u U: %d)\\n\",\n             mailbox, olduv, oldun, mdata->unseen);\n\n  bool new_mail = false;\n  if (C_MailCheckRecent)\n  {\n    if ((olduv != 0) && (olduv == mdata->uidvalidity))\n    {\n      if (oldun < mdata->uid_next)\n        new_mail = (mdata->unseen > 0);\n    }\n    else if ((olduv == 0) && (oldun == 0))\n    {\n      /* first check per session, use recent. might need a flag for this. */\n      new_mail = (mdata->recent > 0);\n    }\n    else\n      new_mail = (mdata->unseen > 0);\n  }\n  else\n    new_mail = (mdata->unseen > 0);\n\n#ifdef USE_SIDEBAR\n  if ((m->has_new != new_mail) || (m->msg_count != mdata->messages) ||\n      (m->msg_unread != mdata->unseen))\n  {\n    mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n  }\n#endif\n\n  m->has_new = new_mail;\n  m->msg_count = mdata->messages;\n  m->msg_unread = mdata->unseen;\n\n  // force back to keep detecting new mail until the mailbox is opened\n  if (m->has_new)\n    mdata->uid_next = oldun;\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param adata Imap Account data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapAccountData *adata, const char *s)\n{\n  mutt_debug(LL_DEBUG2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && (*s != '\\0'))\n  {\n    if (mutt_str_startswith(s, \"UTF8=ACCEPT\", CASE_IGNORE) ||\n        mutt_str_startswith(s, \"UTF8=ONLY\", CASE_IGNORE))\n    {\n      adata->unicode = true;\n    }\n    if (mutt_str_startswith(s, \"QRESYNC\", CASE_IGNORE))\n      adata->qresync = true;\n  }\n}\n/**\n * cmd_parse_exists - Parse EXISTS message from serer\n * @param adata  Imap Account data\n * @param pn     String containing the total number of messages for the selected mailbox\n */\nstatic void cmd_parse_exists(struct ImapAccountData *adata, const char *pn)\n{\n  unsigned int count = 0;\n  mutt_debug(LL_DEBUG2, \"Handling EXISTS\\n\");\n\n  if (mutt_str_atoui(pn, &count) < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"Malformed EXISTS: '%s'\\n\", pn);\n    return;\n  }\n\n  struct ImapMboxData *mdata = adata->mailbox->mdata;\n\n  /* new mail arrived */\n  if (count < mdata->max_msn)\n  {\n    /* Notes 6.0.3 has a tendency to report fewer messages exist than\n     * it should. */\n    mutt_debug(LL_DEBUG1, \"Message count is out of sync\\n\");\n  }\n  /* at least the InterChange server sends EXISTS messages freely,\n   * even when there is no new mail */\n  else if (count == mdata->max_msn)\n    mutt_debug(LL_DEBUG3, \"superfluous EXISTS message\\n\");\n  else\n  {\n    mutt_debug(LL_DEBUG2, \"New mail in %s - %d messages total\\n\", mdata->name, count);\n    mdata->reopen |= IMAP_NEWMAIL_PENDING;\n    mdata->new_mail_count = count;\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapAccountData *adata)\n{\n  char *s = imap_next_word(adata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((adata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    /* pn vs. s: need initial seqno */\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS, EXPUNGE, FETCH are always related to the SELECTED mailbox */\n    if (mutt_str_startswith(s, \"EXISTS\", CASE_IGNORE))\n      cmd_parse_exists(adata, pn);\n    else if (mutt_str_startswith(s, \"EXPUNGE\", CASE_IGNORE))\n      cmd_parse_expunge(adata, pn);\n    else if (mutt_str_startswith(s, \"FETCH\", CASE_IGNORE))\n      cmd_parse_fetch(adata, pn);\n  }\n  else if ((adata->state >= IMAP_SELECTED) && mutt_str_startswith(s, \"VANISHED\", CASE_IGNORE))\n    cmd_parse_vanished(adata, pn);\n  else if (mutt_str_startswith(s, \"CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, s);\n  else if (mutt_str_startswith(s, \"OK [CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, pn);\n  else if (mutt_str_startswith(pn, \"OK [CAPABILITY\", CASE_IGNORE))\n    cmd_parse_capability(adata, imap_next_word(pn));\n  else if (mutt_str_startswith(s, \"LIST\", CASE_IGNORE))\n    cmd_parse_list(adata, s);\n  else if (mutt_str_startswith(s, \"LSUB\", CASE_IGNORE))\n    cmd_parse_lsub(adata, s);\n  else if (mutt_str_startswith(s, \"MYRIGHTS\", CASE_IGNORE))\n    cmd_parse_myrights(adata, s);\n  else if (mutt_str_startswith(s, \"SEARCH\", CASE_IGNORE))\n    cmd_parse_search(adata, s);\n  else if (mutt_str_startswith(s, \"STATUS\", CASE_IGNORE))\n    cmd_parse_status(adata, s);\n  else if (mutt_str_startswith(s, \"ENABLED\", CASE_IGNORE))\n    cmd_parse_enabled(adata, s);\n  else if (mutt_str_startswith(s, \"BYE\", CASE_IGNORE))\n  {\n    mutt_debug(LL_DEBUG2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (adata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(adata);\n\n    return -1;\n  }\n  else if (C_ImapServernoise && mutt_str_startswith(s, \"NO\", CASE_IGNORE))\n  {\n    mutt_debug(LL_DEBUG2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 2);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param adata Imap Account data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr)\n{\n  return cmd_start(adata, cmdstr, IMAP_CMD_NO_FLAGS);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return -1;\n\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_RES_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == adata->blen)\n    {\n      mutt_mem_realloc(&adata->buf, adata->blen + IMAP_CMD_BUFSIZE);\n      adata->blen = adata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(LL_DEBUG3, \"grew buffer to %lu bytes\\n\", adata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln_d(adata->buf + len, adata->blen - len, adata->conn, MUTT_SOCK_LOG_FULL);\n    if (c <= 0)\n    {\n      mutt_debug(LL_DEBUG1, \"Error reading server response\\n\");\n      cmd_handle_fatal(adata);\n      return IMAP_RES_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == adata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((adata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&adata->buf, IMAP_CMD_BUFSIZE);\n    adata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(LL_DEBUG3, \"shrank buffer to %lu bytes\\n\", adata->blen);\n  }\n\n  adata->lastread = mutt_date_epoch();\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if ((mutt_str_startswith(adata->buf, \"* \", CASE_MATCH) ||\n       mutt_str_startswith(imap_next_word(adata->buf), \"OK [\", CASE_MATCH)) &&\n      cmd_handle_untagged(adata))\n  {\n    return IMAP_RES_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (adata->buf[0] == '+')\n    return IMAP_RES_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an adata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_RES_OK;\n  c = adata->lastcmd;\n  do\n  {\n    cmd = &adata->cmds[c];\n    if (cmd->state == IMAP_RES_NEW)\n    {\n      if (mutt_str_startswith(adata->buf, cmd->seq, CASE_MATCH))\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          adata->lastcmd = (adata->lastcmd + 1) % adata->cmdslots;\n        }\n        cmd->state = cmd_status(adata->buf);\n        rc = cmd->state;\n        if (cmd->state == IMAP_RES_NO || cmd->state == IMAP_RES_BAD)\n        {\n          mutt_message(_(\"IMAP command failed: %s\"), adata->buf);\n        }\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % adata->cmdslots;\n  } while (c != adata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_RES_CONTINUE;\n  else\n  {\n    mutt_debug(LL_DEBUG3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(adata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return cmd_status(s) == IMAP_RES_OK;\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param adata Imap Account data\n * @retval ptr Extra command information (pointer into adata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapAccountData *adata)\n{\n  static const char *notrailer = \"\";\n  const char *s = adata->buf;\n\n  if (!s)\n  {\n    mutt_debug(LL_DEBUG2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || (!mutt_str_startswith(s, \"OK\", CASE_IGNORE) &&\n             !mutt_str_startswith(s, \"NO\", CASE_IGNORE) &&\n             !mutt_str_startswith(s, \"BAD\", CASE_IGNORE)))\n  {\n    mutt_debug(LL_DEBUG2, \"not a command completion: %s\\n\", adata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param adata Imap Account data\n * @param cmdstr Command to execute\n * @param flags  Flags, see #ImapCmdFlags\n * @retval #IMAP_EXEC_SUCCESS Command successful or queued\n * @retval #IMAP_EXEC_ERROR   Command returned an error\n * @retval #IMAP_EXEC_FATAL   Imap connection failure\n *\n * Also, handle untagged responses.\n */\nint imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    // Process any existing commands\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    // The queue is empty, so the single command has been processed\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n\n  return IMAP_EXEC_SUCCESS;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param adata Imap Account data\n *\n * If a reopen is allowed, it attempts to perform cleanup (eg fetch new mail if\n * detected, do expunge). Called automatically by imap_cmd_step(), but may be\n * called at any time.\n *\n * mdata->check_status is set and will be used later by imap_check_mailbox().\n */\nvoid imap_cmd_finish(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return;\n\n  if (adata->status == IMAP_FATAL)\n  {\n    adata->closing = false;\n    cmd_handle_fatal(adata);\n    return;\n  }\n\n  if (!(adata->state >= IMAP_SELECTED) || (adata->mailbox && adata->closing))\n  {\n    adata->closing = false;\n    return;\n  }\n\n  adata->closing = false;\n\n  struct ImapMboxData *mdata = imap_mdata_get(adata->mailbox);\n\n  if (mdata && mdata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    // First remove expunged emails from the msn_index\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(LL_DEBUG2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(adata->mailbox);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if (!(mdata->reopen & IMAP_EXPUNGE_EXPECTED))\n        mdata->check_status |= IMAP_EXPUNGE_PENDING;\n      mdata->reopen &= ~(IMAP_EXPUNGE_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n\n    // Then add new emails to it\n    if (mdata->reopen & IMAP_NEWMAIL_PENDING && (mdata->new_mail_count > mdata->max_msn))\n    {\n      if (!(mdata->reopen & IMAP_EXPUNGE_PENDING))\n        mdata->check_status |= IMAP_NEWMAIL_PENDING;\n\n      mutt_debug(LL_DEBUG2, \"Fetching new mails from %d to %d\\n\",\n                 mdata->max_msn + 1, mdata->new_mail_count);\n      imap_read_headers(adata->mailbox, mdata->max_msn + 1, mdata->new_mail_count, false);\n    }\n\n    // And to finish inform about MUTT_REOPEN if needed\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING && !(mdata->reopen & IMAP_EXPUNGE_EXPECTED))\n      mdata->check_status |= IMAP_EXPUNGE_PENDING;\n\n    if (mdata->reopen & IMAP_EXPUNGE_PENDING)\n      mdata->reopen &= ~(IMAP_EXPUNGE_PENDING | IMAP_EXPUNGE_EXPECTED);\n  }\n\n  adata->status = 0;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_RES_BAD\n */\nint imap_cmd_idle(struct ImapAccountData *adata)\n{\n  int rc;\n\n  if (cmd_start(adata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  if ((C_ImapPollTimeout > 0) && ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return -1;\n  }\n\n  do\n  {\n    rc = imap_cmd_step(adata);\n  } while (rc == IMAP_RES_CONTINUE);\n\n  if (rc == IMAP_RES_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    adata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_addstr(&adata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_RES_OK;\n  }\n  if (rc != IMAP_RES_OK)\n  {\n    mutt_debug(LL_DEBUG1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n", "/**\n * @file\n * IMAP network mailbox\n *\n * @authors\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_imap IMAP network mailbox\n *\n * Support for IMAP4rev1, with the occasional nod to IMAP 4.\n */\n\n#include \"config.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"mutt.h\"\n#include \"lib.h\"\n#include \"auth.h\"\n#include \"commands.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"init.h\"\n#include \"message.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"pattern.h\"\n#include \"progress.h\"\n#include \"sort.h\"\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#endif\n\nstruct stat;\n\n/* These Config Variables are only used in imap/imap.c */\n#ifdef USE_ZLIB\nbool C_ImapDeflate; ///< Config: (imap) Compress network traffic\n#endif\nbool C_ImapIdle; ///< Config: (imap) Use the IMAP IDLE extension to check for new mail\nbool C_ImapRfc5161; ///< Config: (imap) Use the IMAP ENABLE extension to select capabilities\n\n/**\n * check_capabilities - Make sure we can log in to this server\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int check_capabilities(struct ImapAccountData *adata)\n{\n  if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    imap_error(\"check_capabilities\", adata->buf);\n    return -1;\n  }\n\n  if (!((adata->capabilities & IMAP_CAP_IMAP4) || (adata->capabilities & IMAP_CAP_IMAP4REV1)))\n  {\n    mutt_error(\n        _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * get_flags - Make a simple list out of a FLAGS response\n * @param hflags List to store flags\n * @param s      String containing flags\n * @retval ptr  End of the flags\n * @retval NULL Failure\n *\n * return stream following FLAGS response\n */\nstatic char *get_flags(struct ListHead *hflags, char *s)\n{\n  /* sanity-check string */\n  const size_t plen = mutt_str_startswith(s, \"FLAGS\", CASE_IGNORE);\n  if (plen == 0)\n  {\n    mutt_debug(LL_DEBUG1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += plen;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(LL_DEBUG1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  /* update caller's flags handle */\n  while (*s && (*s != ')'))\n  {\n    s++;\n    SKIPWS(s);\n    const char *flag_word = s;\n    while (*s && (*s != ')') && !IS_SPACE(*s))\n      s++;\n    const char ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_list_insert_tail(hflags, mutt_str_strdup(flag_word));\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    mutt_debug(LL_DEBUG1, \"Unterminated FLAGS response: %s\\n\", s);\n    mutt_list_free(hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\n/**\n * set_flag - append str to flags if we currently have permission according to aclflag\n * @param[in]  m       Selected Imap Mailbox\n * @param[in]  aclflag Permissions, see #AclFlags\n * @param[in]  flag    Does the email have the flag set?\n * @param[in]  str     Server flag name\n * @param[out] flags   Buffer for server command\n * @param[in]  flsize  Length of buffer\n */\nstatic void set_flag(struct Mailbox *m, AclFlags aclflag, int flag,\n                     const char *str, char *flags, size_t flsize)\n{\n  if (m->rights & aclflag)\n    if (flag && imap_has_flag(&imap_mdata_get(m)->flags, str))\n      mutt_str_strcat(flags, flsize, str);\n}\n\n/**\n * make_msg_set - Make a message set\n * @param[in]  m       Selected Imap Mailbox\n * @param[in]  buf     Buffer to store message set\n * @param[in]  flag    Flags to match, e.g. #MUTT_DELETED\n * @param[in]  changed Matched messages that have been altered\n * @param[in]  invert  Flag matches should be inverted\n * @param[out] pos     Cursor used for multiple calls to this function\n * @retval num Messages in the set\n *\n * @note Headers must be in #SORT_ORDER. See imap_exec_msgset() for args.\n * Pos is an opaque pointer a la strtok(). It should be 0 at first call.\n */\nstatic int make_msg_set(struct Mailbox *m, struct Buffer *buf, int flag,\n                        bool changed, bool invert, int *pos)\n{\n  int count = 0;             /* number of messages in message set */\n  unsigned int setstart = 0; /* start of current message range */\n  int n;\n  bool started = false;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  for (n = *pos; (n < m->msg_count) && (mutt_buffer_len(buf) < IMAP_MAX_CMDLEN); n++)\n  {\n    struct Email *e = m->emails[n];\n    if (!e)\n      break;\n    bool match = false; /* whether current message matches flag condition */\n    /* don't include pending expunged messages.\n     *\n     * TODO: can we unset active in cmd_parse_expunge() and\n     * cmd_parse_vanished() instead of checking for index != INT_MAX. */\n    if (e->active && (e->index != INT_MAX))\n    {\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (e->deleted != imap_edata_get(e)->deleted)\n            match = invert ^ e->deleted;\n          break;\n        case MUTT_FLAG:\n          if (e->flagged != imap_edata_get(e)->flagged)\n            match = invert ^ e->flagged;\n          break;\n        case MUTT_OLD:\n          if (e->old != imap_edata_get(e)->old)\n            match = invert ^ e->old;\n          break;\n        case MUTT_READ:\n          if (e->read != imap_edata_get(e)->read)\n            match = invert ^ e->read;\n          break;\n        case MUTT_REPLIED:\n          if (e->replied != imap_edata_get(e)->replied)\n            match = invert ^ e->replied;\n          break;\n        case MUTT_TAG:\n          if (e->tagged)\n            match = true;\n          break;\n        case MUTT_TRASH:\n          if (e->deleted && !e->purge)\n            match = true;\n          break;\n      }\n    }\n\n    if (match && (!changed || e->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = imap_edata_get(e)->uid;\n        if (started)\n        {\n          mutt_buffer_add_printf(buf, \",%u\", imap_edata_get(e)->uid);\n        }\n        else\n        {\n          mutt_buffer_add_printf(buf, \"%u\", imap_edata_get(e)->uid);\n          started = true;\n        }\n      }\n      /* tie up if the last message also matches */\n      else if (n == (m->msg_count - 1))\n        mutt_buffer_add_printf(buf, \":%u\", imap_edata_get(e)->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (e->active || (n == adata->mailbox->msg_count - 1)))\n    {\n      if (imap_edata_get(m->emails[n - 1])->uid > setstart)\n        mutt_buffer_add_printf(buf, \":%u\", imap_edata_get(m->emails[n - 1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/**\n * compare_flags_for_copy - Compare local flags against the server\n * @param e Email\n * @retval true  Flags have changed\n * @retval false Flags match cached server flags\n *\n * The comparison of flags EXCLUDES the deleted flag.\n */\nstatic bool compare_flags_for_copy(struct Email *e)\n{\n  struct ImapEmailData *edata = e->edata;\n\n  if (e->read != edata->read)\n    return true;\n  if (e->old != edata->old)\n    return true;\n  if (e->flagged != edata->flagged)\n    return true;\n  if (e->replied != edata->replied)\n    return true;\n\n  return false;\n}\n\n/**\n * sync_helper - Sync flag changes to the server\n * @param m     Selected Imap Mailbox\n * @param right ACL, see #AclFlags\n * @param flag  NeoMutt flag, e.g. #MUTT_DELETED\n * @param name  Name of server flag\n * @retval >=0 Success, number of messages\n * @retval  -1 Failure\n */\nstatic int sync_helper(struct Mailbox *m, AclFlags right, int flag, const char *name)\n{\n  int count = 0;\n  int rc;\n  char buf[1024];\n\n  if (!m)\n    return -1;\n\n  if ((m->rights & right) == 0)\n    return 0;\n\n  if ((right == MUTT_ACL_WRITE) && !imap_has_flag(&imap_mdata_get(m)->flags, name))\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  rc = imap_exec_msgset(m, \"UID STORE\", buf, flag, true, false);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  rc = imap_exec_msgset(m, \"UID STORE\", buf, flag, true, true);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/**\n * longest_common_prefix - Find longest prefix common to two strings\n * @param dest  Destination buffer\n * @param src   Source buffer\n * @param start Starting offset into string\n * @param dlen  Destination buffer length\n * @retval num Length of the common string\n *\n * Trim dest to the length of the longest prefix it shares with src.\n */\nstatic size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while ((pos < dlen) && dest[pos] && (dest[pos] == src[pos]))\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/**\n * complete_hosts - Look for completion matches for mailboxes\n * @param buf Partial mailbox name to complete\n * @param buflen  Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * look for IMAP URLs to complete from defined mailboxes. Could be extended to\n * complete over open connections and account/folder hooks too.\n */\nstatic int complete_hosts(char *buf, size_t buflen)\n{\n  // struct Connection *conn = NULL;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_str_strlen(buf);\n  struct MailboxList ml = STAILQ_HEAD_INITIALIZER(ml);\n  neomutt_mailboxlist_get_all(&ml, NeoMutt, MUTT_MAILBOX_ANY);\n  struct MailboxNode *np = NULL;\n  STAILQ_FOREACH(np, &ml, entries)\n  {\n    if (!mutt_str_startswith(mailbox_path(np->mailbox), buf, CASE_MATCH))\n      continue;\n\n    if (rc)\n    {\n      mutt_str_strfcpy(buf, mailbox_path(np->mailbox), buflen);\n      rc = 0;\n    }\n    else\n      longest_common_prefix(buf, mailbox_path(np->mailbox), matchlen, buflen);\n  }\n  neomutt_mailboxlist_clear(&ml);\n\n#if 0\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    struct Url url = { 0 };\n    char urlstr[1024];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl(&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_tostring(&url, urlstr, sizeof(urlstr), 0);\n    if (mutt_str_strncmp(buf, urlstr, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, urlstr, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, urlstr, matchlen, buflen);\n    }\n  }\n#endif\n\n  return rc;\n}\n\n/**\n * imap_create_mailbox - Create a new mailbox\n * @param adata Imap Account data\n * @param mailbox Mailbox to create\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_create_mailbox(struct ImapAccountData *adata, char *mailbox)\n{\n  char buf[2048], mbox[1024];\n\n  imap_munge_mbox_name(adata->unicode, mbox, sizeof(mbox), mailbox);\n  snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);\n\n  if (imap_exec(adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(adata));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_access - Check permissions on an IMAP mailbox with a new connection\n * @param path Mailbox path\n * @retval  0 Success\n * @retval <0 Failure\n *\n * TODO: ACL checks. Right now we assume if it exists we can mess with it.\n * TODO: This method should take a Mailbox as parameter to be able to reuse the\n * existing connection.\n */\nint imap_access(const char *path)\n{\n  if (imap_path_status(path, false) >= 0)\n    return 0;\n  return -1;\n}\n\n/**\n * imap_rename_mailbox - Rename a mailbox\n * @param adata Imap Account data\n * @param oldname Existing mailbox\n * @param newname New name for mailbox\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_rename_mailbox(struct ImapAccountData *adata, char *oldname, const char *newname)\n{\n  char oldmbox[1024];\n  char newmbox[1024];\n  int rc = 0;\n\n  imap_munge_mbox_name(adata->unicode, oldmbox, sizeof(oldmbox), oldname);\n  imap_munge_mbox_name(adata->unicode, newmbox, sizeof(newmbox), newname);\n\n  struct Buffer *buf = mutt_buffer_pool_get();\n  mutt_buffer_printf(buf, \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec(adata, mutt_b2s(buf), IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    rc = -1;\n\n  mutt_buffer_pool_release(&buf);\n\n  return rc;\n}\n\n/**\n * imap_delete_mailbox - Delete a mailbox\n * @param m  Mailbox\n * @param path  name of the mailbox to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_delete_mailbox(struct Mailbox *m, char *path)\n{\n  char buf[PATH_MAX + 7];\n  char mbox[PATH_MAX];\n  struct Url *url = url_parse(path);\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  imap_munge_mbox_name(adata->unicode, mbox, sizeof(mbox), url->path);\n  url_free(&url);\n  snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);\n  if (imap_exec(m->account->adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_logout - Gracefully log out of server\n * @param adata Imap Account data\n */\nstatic void imap_logout(struct ImapAccountData *adata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  if (adata->state == IMAP_DISCONNECTED)\n  {\n    return;\n  }\n\n  adata->status = IMAP_BYE;\n  imap_cmd_start(adata, \"LOGOUT\");\n  if ((C_ImapPollTimeout <= 0) || (mutt_socket_poll(adata->conn, C_ImapPollTimeout) != 0))\n  {\n    while (imap_cmd_step(adata) == IMAP_RES_CONTINUE)\n      ; // do nothing\n  }\n  mutt_socket_close(adata->conn);\n  adata->state = IMAP_DISCONNECTED;\n}\n\n/**\n * imap_logout_all - close all open connections\n *\n * Quick and dirty until we can make sure we've got all the context we need.\n */\nvoid imap_logout_all(void)\n{\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    struct ImapAccountData *adata = np->adata;\n    if (!adata)\n      continue;\n\n    struct Connection *conn = adata->conn;\n    if (!conn || (conn->fd < 0))\n      continue;\n\n    mutt_message(_(\"Closing connection to %s...\"), conn->account.host);\n    imap_logout(np->adata);\n    mutt_clear_error();\n  }\n}\n\n/**\n * imap_read_literal - Read bytes bytes from server into file\n * @param fp    File handle for email file\n * @param adata Imap Account data\n * @param bytes Number of bytes to read\n * @param pbar  Progress bar\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Not explicitly buffered, relies on FILE buffering.\n *\n * @note Strips `\\r` from `\\r\\n`.\n *       Apparently even literals use `\\r\\n`-terminated strings ?!\n */\nint imap_read_literal(FILE *fp, struct ImapAccountData *adata,\n                      unsigned long bytes, struct Progress *pbar)\n{\n  char c;\n  bool r = false;\n  struct Buffer buf = { 0 }; // Do not allocate, maybe it won't be used\n\n  if (C_DebugLevel >= IMAP_LOG_LTRL)\n    mutt_buffer_alloc(&buf, bytes + 10);\n\n  mutt_debug(LL_DEBUG2, \"reading %ld bytes\\n\", bytes);\n\n  for (unsigned long pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar(adata->conn, &c) != 1)\n    {\n      mutt_debug(LL_DEBUG1, \"error during read, %ld bytes read\\n\", pos);\n      adata->status = IMAP_FATAL;\n\n      mutt_buffer_dealloc(&buf);\n      return -1;\n    }\n\n    if (r && (c != '\\n'))\n      fputc('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = true;\n      continue;\n    }\n    else\n      r = false;\n\n    fputc(c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update(pbar, pos, -1);\n    if (C_DebugLevel >= IMAP_LOG_LTRL)\n      mutt_buffer_addch(&buf, c);\n  }\n\n  if (C_DebugLevel >= IMAP_LOG_LTRL)\n  {\n    mutt_debug(IMAP_LOG_LTRL, \"\\n%s\", buf.data);\n    mutt_buffer_dealloc(&buf);\n  }\n  return 0;\n}\n\n/**\n * imap_expunge_mailbox - Purge messages from the server\n * @param m Mailbox\n *\n * Purge IMAP portion of expunged messages from the context. Must not be done\n * while something has a handle on any headers (eg inside pager or editor).\n * That is, check #IMAP_REOPEN_ALLOW.\n */\nvoid imap_expunge_mailbox(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return;\n\n  struct Email *e = NULL;\n\n#ifdef USE_HCACHE\n  mdata->hcache = imap_hcache_open(adata, mdata);\n#endif\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->index == INT_MAX)\n    {\n      mutt_debug(LL_DEBUG2, \"Expunging message UID %u\\n\", imap_edata_get(e)->uid);\n\n      e->deleted = true;\n\n      imap_cache_del(m, e);\n#ifdef USE_HCACHE\n      imap_hcache_del(mdata, imap_edata_get(e)->uid);\n#endif\n\n      mutt_hash_int_delete(mdata->uid_hash, imap_edata_get(e)->uid, e);\n\n      imap_edata_free((void **) &e->edata);\n    }\n    else\n    {\n      e->index = i;\n      /* NeoMutt has several places where it turns off e->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The ctx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.  */\n      e->active = true;\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(mdata);\n#endif\n\n  mailbox_changed(m, NT_MAILBOX_UPDATE);\n  mailbox_changed(m, NT_MAILBOX_RESORT);\n}\n\n/**\n * imap_open_connection - Open an IMAP connection\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_str_startswith(adata->buf, \"* OK\", CASE_IGNORE))\n  {\n    if (!mutt_str_startswith(adata->buf, \"* OK [CAPABILITY\", CASE_IGNORE) &&\n        check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && !adata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_startswith(adata->buf, \"* PREAUTH\", CASE_IGNORE))\n  {\n#ifdef USE_SSL\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (adata->conn->ssf == 0)\n    {\n      bool proceed = true;\n      if (C_SslForceTls)\n      {\n        proceed = false;\n      }\n      else if (C_SslStarttls != MUTT_NO)\n      {\n        proceed = mutt_yesorno(_(\"Abort unencrypted PREAUTH connection?\"),\n                               C_SslStarttls) != MUTT_NO;\n      }\n      if (!proceed)\n      {\n        mutt_error(_(\"Encrypted connection unavailable\"));\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}\n\n/**\n * imap_close_connection - Close an IMAP connection\n * @param adata Imap Account data\n */\nvoid imap_close_connection(struct ImapAccountData *adata)\n{\n  if (adata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close(adata->conn);\n    adata->state = IMAP_DISCONNECTED;\n  }\n  adata->seqno = 0;\n  adata->nextcmd = 0;\n  adata->lastcmd = 0;\n  adata->status = 0;\n  memset(adata->cmds, 0, sizeof(struct ImapCommand) * adata->cmdslots);\n}\n\n/**\n * imap_has_flag - Does the flag exist in the list\n * @param flag_list List of server flags\n * @param flag      Flag to find\n * @retval true Flag exists\n *\n * Do a caseless comparison of the flag against a flag list, return true if\n * found or flag list has '\\*'. Note that \"flag\" might contain additional\n * whitespace at the end, so we really need to compare up to the length of each\n * element in \"flag_list\".\n */\nbool imap_has_flag(struct ListHead *flag_list, const char *flag)\n{\n  if (STAILQ_EMPTY(flag_list))\n    return false;\n\n  const size_t flaglen = mutt_str_strlen(flag);\n  struct ListNode *np = NULL;\n  STAILQ_FOREACH(np, flag_list, entries)\n  {\n    const size_t nplen = strlen(np->data);\n    if ((flaglen >= nplen) && ((flag[nplen] == '\\0') || (flag[nplen] == ' ')) &&\n        (mutt_str_strncasecmp(np->data, flag, nplen) == 0))\n    {\n      return true;\n    }\n\n    if (mutt_str_strcmp(np->data, \"\\\\*\") == 0)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * compare_uid - Compare two Emails by UID - Implements ::sort_t\n */\nstatic int compare_uid(const void *a, const void *b)\n{\n  const struct Email *ea = *(struct Email const *const *) a;\n  const struct Email *eb = *(struct Email const *const *) b;\n  return imap_edata_get((struct Email *) ea)->uid -\n         imap_edata_get((struct Email *) eb)->uid;\n}\n\n/**\n * imap_exec_msgset - Prepare commands for all messages matching conditions\n * @param m       Selected Imap Mailbox\n * @param pre     prefix commands\n * @param post    postfix commands\n * @param flag    flag type on which to filter, e.g. #MUTT_REPLIED\n * @param changed include only changed messages in message set\n * @param invert  invert sense of flag, eg #MUTT_READ matches unread messages\n * @retval num Matched messages\n * @retval -1  Failure\n *\n * pre/post: commands are of the form \"%s %s %s %s\", tag, pre, message set, post\n * Prepares commands for all messages matching conditions\n * (must be flushed with imap_exec)\n */\nint imap_exec_msgset(struct Mailbox *m, const char *pre, const char *post,\n                     int flag, bool changed, bool invert)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  struct Email **emails = NULL;\n  short oldsort;\n  int pos;\n  int rc;\n  int count = 0;\n\n  struct Buffer cmd = mutt_buffer_make(0);\n\n  /* We make a copy of the headers just in case resorting doesn't give\n   exactly the original order (duplicate messages?), because other parts of\n   the ctx are tied to the header order. This may be overkill. */\n  oldsort = C_Sort;\n  if (C_Sort != SORT_ORDER)\n  {\n    emails = m->emails;\n    // We overcommit here, just in case new mail arrives whilst we're sync-ing\n    m->emails = mutt_mem_malloc(m->email_max * sizeof(struct Email *));\n    memcpy(m->emails, emails, m->email_max * sizeof(struct Email *));\n\n    C_Sort = SORT_ORDER;\n    qsort(m->emails, m->msg_count, sizeof(struct Email *), compare_uid);\n  }\n\n  pos = 0;\n\n  do\n  {\n    mutt_buffer_reset(&cmd);\n    mutt_buffer_add_printf(&cmd, \"%s \", pre);\n    rc = make_msg_set(m, &cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_add_printf(&cmd, \" %s\", post);\n      if (imap_exec(adata, cmd.data, IMAP_CMD_QUEUE) != IMAP_EXEC_SUCCESS)\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  } while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_dealloc(&cmd);\n  if (oldsort != C_Sort)\n  {\n    C_Sort = oldsort;\n    FREE(&m->emails);\n    m->emails = emails;\n  }\n\n  return rc;\n}\n\n/**\n * imap_sync_message_for_copy - Update server to reflect the flags of a single message\n * @param[in]  m            Mailbox\n * @param[in]  e            Email\n * @param[in]  cmd          Buffer for the command string\n * @param[out] err_continue Did the user force a continue?\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n *\n * @note This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy(struct Mailbox *m, struct Email *e,\n                               struct Buffer *cmd, enum QuadOption *err_continue)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  if (!adata || (adata->mailbox != m))\n    return -1;\n\n  char flags[1024];\n  char *tags = NULL;\n  char uid[11];\n\n  if (!compare_flags_for_copy(e))\n  {\n    if (e->deleted == imap_edata_get(e)->deleted)\n      e->changed = false;\n    return 0;\n  }\n\n  snprintf(uid, sizeof(uid), \"%u\", imap_edata_get(e)->uid);\n  mutt_buffer_reset(cmd);\n  mutt_buffer_addstr(cmd, \"UID STORE \");\n  mutt_buffer_addstr(cmd, uid);\n\n  flags[0] = '\\0';\n\n  set_flag(m, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));\n  set_flag(m, MUTT_ACL_DELETE, imap_edata_get(e)->deleted, \"\\\\Deleted \", flags,\n           sizeof(flags));\n\n  if (m->rights & MUTT_ACL_WRITE)\n  {\n    /* restore system flags */\n    if (imap_edata_get(e)->flags_system)\n      mutt_str_strcat(flags, sizeof(flags), imap_edata_get(e)->flags_system);\n    /* set custom flags */\n    tags = driver_tags_get_with_hidden(&e->tags);\n    if (tags)\n    {\n      mutt_str_strcat(flags, sizeof(flags), tags);\n      FREE(&tags);\n    }\n  }\n\n  mutt_str_remove_trailing_ws(flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (*flags == '\\0')\n  {\n    set_flag(m, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));\n    set_flag(m, MUTT_ACL_DELETE, !imap_edata_get(e)->deleted, \"\\\\Deleted \",\n             flags, sizeof(flags));\n\n    /* erase custom flags */\n    if ((m->rights & MUTT_ACL_WRITE) && imap_edata_get(e)->flags_remote)\n      mutt_str_strcat(flags, sizeof(flags), imap_edata_get(e)->flags_remote);\n\n    mutt_str_remove_trailing_ws(flags);\n\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr(cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr(cmd, flags);\n  mutt_buffer_addstr(cmd, \")\");\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec(adata, cmd->data, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS) &&\n      err_continue && (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue(\"imap_sync_message: STORE failed\", adata->buf);\n    if (*err_continue != MUTT_YES)\n      return -1;\n  }\n\n  /* server have now the updated flags */\n  FREE(&imap_edata_get(e)->flags_remote);\n  imap_edata_get(e)->flags_remote = driver_tags_get_with_hidden(&e->tags);\n\n  if (e->deleted == imap_edata_get(e)->deleted)\n    e->changed = false;\n\n  return 0;\n}\n\n/**\n * imap_check_mailbox - use the NOOP or IDLE command to poll for new mail\n * @param m     Mailbox\n * @param force Don't wait\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval 0               no change\n * @retval -1              error\n */\nint imap_check_mailbox(struct Mailbox *m, bool force)\n{\n  if (!m || !m->account)\n    return -1;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  int rc = 0;\n\n  /* try IDLE first, unless force is set */\n  if (!force && C_ImapIdle && (adata->capabilities & IMAP_CAP_IDLE) &&\n      ((adata->state != IMAP_IDLE) || (mutt_date_epoch() >= adata->lastread + C_ImapKeepalive)))\n  {\n    if (imap_cmd_idle(adata) < 0)\n      return -1;\n  }\n  if (adata->state == IMAP_IDLE)\n  {\n    while ((rc = mutt_socket_poll(adata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)\n      {\n        mutt_debug(LL_DEBUG1, \"Error reading IDLE response\\n\");\n        return -1;\n      }\n    }\n    if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"Poll failed, disabling IDLE\\n\");\n      adata->capabilities &= ~IMAP_CAP_IDLE; // Clear the flag\n    }\n  }\n\n  if ((force || ((adata->state != IMAP_IDLE) &&\n                 (mutt_date_epoch() >= adata->lastread + C_Timeout))) &&\n      (imap_exec(adata, \"NOOP\", IMAP_CMD_POLL) != IMAP_EXEC_SUCCESS))\n  {\n    return -1;\n  }\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish(adata);\n\n  if (mdata->check_status & IMAP_EXPUNGE_PENDING)\n    rc = MUTT_REOPENED;\n  else if (mdata->check_status & IMAP_NEWMAIL_PENDING)\n    rc = MUTT_NEW_MAIL;\n  else if (mdata->check_status & IMAP_FLAGS_PENDING)\n    rc = MUTT_FLAGS;\n\n  mdata->check_status = IMAP_OPEN_NO_FLAGS;\n\n  return rc;\n}\n\n/**\n * imap_status - Refresh the number of total and new messages\n * @param adata  IMAP Account data\n * @param mdata  IMAP Mailbox data\n * @param queue  Queue the STATUS command\n * @retval num   Total number of messages\n */\nstatic int imap_status(struct ImapAccountData *adata, struct ImapMboxData *mdata, bool queue)\n{\n  char *uidvalidity_flag = NULL;\n  char cmd[2048];\n\n  if (!adata || !mdata)\n    return -1;\n\n  /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n   * IDLEd elsewhere.\n   * adata->mailbox may be NULL for connections other than the current\n   * mailbox's. */\n  if (adata->mailbox && (adata->mailbox->mdata == mdata))\n  {\n    adata->mailbox->has_new = false;\n    return mdata->messages;\n  }\n\n  if (adata->capabilities & IMAP_CAP_IMAP4REV1)\n    uidvalidity_flag = \"UIDVALIDITY\";\n  else if (adata->capabilities & IMAP_CAP_STATUS)\n    uidvalidity_flag = \"UID-VALIDITY\";\n  else\n  {\n    mutt_debug(LL_DEBUG2, \"Server doesn't support STATUS\\n\");\n    return -1;\n  }\n\n  snprintf(cmd, sizeof(cmd), \"STATUS %s (UIDNEXT %s UNSEEN RECENT MESSAGES)\",\n           mdata->munge_name, uidvalidity_flag);\n\n  int rc = imap_exec(adata, cmd, queue ? IMAP_CMD_QUEUE : IMAP_CMD_NO_FLAGS | IMAP_CMD_POLL);\n  if (rc < 0)\n  {\n    mutt_debug(LL_DEBUG1, \"Error queueing command\\n\");\n    return rc;\n  }\n  return mdata->messages;\n}\n\n/**\n * imap_mbox_check_stats - Check the Mailbox statistics - Implements MxOps::mbox_check_stats()\n */\nstatic int imap_mbox_check_stats(struct Mailbox *m, int flags)\n{\n  return imap_mailbox_status(m, true);\n}\n\n/**\n * imap_path_status - Refresh the number of total and new messages\n * @param path   Mailbox path\n * @param queue  Queue the STATUS command\n * @retval num   Total number of messages\n */\nint imap_path_status(const char *path, bool queue)\n{\n  struct Mailbox *m = mx_mbox_find2(path);\n  if (m)\n    return imap_mailbox_status(m, queue);\n\n  // FIXME(sileht): Is that case possible ?\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return -1;\n  int rc = imap_status(adata, mdata, queue);\n  imap_mdata_free((void *) &mdata);\n  return rc;\n}\n\n/**\n * imap_mailbox_status - Refresh the number of total and new messages\n * @param m      Mailbox\n * @param queue  Queue the STATUS command\n * @retval num Total number of messages\n * @retval -1  Error\n *\n * @note Prepare the mailbox if we are not connected\n */\nint imap_mailbox_status(struct Mailbox *m, bool queue)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return -1;\n  return imap_status(adata, mdata, queue);\n}\n\n/**\n * imap_subscribe - Subscribe to a mailbox\n * @param path      Mailbox path\n * @param subscribe True: subscribe, false: unsubscribe\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char buf[2048];\n  struct Buffer err;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return -1;\n\n  if (C_ImapCheckSubscribed)\n  {\n    char mbox[1024];\n    mutt_buffer_init(&err);\n    err.dsize = 256;\n    err.data = mutt_mem_malloc(err.dsize);\n    size_t len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");\n    imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n    if (mutt_parse_rc_line(mbox, &err))\n      mutt_debug(LL_DEBUG1, \"Error adding subscribed mailbox: %s\\n\", err.data);\n    FREE(&err.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), mdata->name);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), mdata->name);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mdata->munge_name);\n\n  if (imap_exec(adata, buf, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n  {\n    imap_mdata_free((void *) &mdata);\n    return -1;\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mdata->name);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mdata->name);\n  imap_mdata_free((void *) &mdata);\n  return 0;\n}\n\n/**\n * imap_complete - Try to complete an IMAP folder path\n * @param buf Buffer for result\n * @param buflen Length of buffer\n * @param path Partial mailbox name to complete\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given a partial IMAP folder path, return a string which adds as much to the\n * path as is unique\n */\nint imap_complete(char *buf, size_t buflen, const char *path)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char tmp[2048];\n  struct ImapList listresp = { 0 };\n  char completion[1024];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  int rc;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n  {\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* fire off command */\n  snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\",\n           C_ImapListSubscribed ? \"LSUB\" : \"LIST\", mdata->real_name);\n\n  imap_cmd_start(adata, tmp);\n\n  /* and see what the results are */\n  mutt_str_strfcpy(completion, mdata->name, sizeof(completion));\n  imap_mdata_free((void *) &mdata);\n\n  adata->cmdresult = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step(adata);\n\n    if ((rc == IMAP_RES_CONTINUE) && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        mutt_str_strfcpy(completion, listresp.name, sizeof(completion));\n        matchlen = strlen(completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  } while (rc == IMAP_RES_CONTINUE);\n  adata->cmdresult = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path(buf, buflen, &adata->conn->account, completion);\n    mutt_pretty_mailbox(buf, buflen);\n    return 0;\n  }\n\n  return -1;\n}\n\n/**\n * imap_fast_trash - Use server COPY command to copy deleted messages to trash\n * @param m    Mailbox\n * @param dest Mailbox to move to\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_fast_trash(struct Mailbox *m, char *dest)\n{\n  char prompt[1024];\n  int rc = -1;\n  bool triedcreate = false;\n  enum QuadOption err_continue = MUTT_NO;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapAccountData *dest_adata = NULL;\n  struct ImapMboxData *dest_mdata = NULL;\n\n  if (imap_adata_find(dest, &dest_adata, &dest_mdata) < 0)\n    return -1;\n\n  struct Buffer sync_cmd = mutt_buffer_make(0);\n\n  /* check that the save-to folder is in the same account */\n  if (!imap_account_match(&(adata->conn->account), &(dest_adata->conn->account)))\n  {\n    mutt_debug(LL_DEBUG3, \"%s not same server as %s\\n\", dest, mailbox_path(m));\n    goto out;\n  }\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n    if (e->active && e->changed && e->deleted && !e->purge)\n    {\n      rc = imap_sync_message_for_copy(m, e, &sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        mutt_debug(LL_DEBUG1, \"could not sync\\n\");\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset(m, \"UID COPY\", dest_mdata->munge_name, MUTT_TRASH, false, false);\n    if (rc == 0)\n    {\n      mutt_debug(LL_DEBUG1, \"No messages to trash\\n\");\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      mutt_debug(LL_DEBUG1, \"could not queue copy\\n\");\n      goto out;\n    }\n    else if (m->verbose)\n    {\n      mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                   rc, dest_mdata->name);\n    }\n\n    /* let's get it on */\n    rc = imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS);\n    if (rc == IMAP_EXEC_ERROR)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(LL_DEBUG1, \"Already tried to create mailbox %s\\n\", dest_mdata->name);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (!mutt_str_startswith(imap_get_qualifier(adata->buf), \"[TRYCREATE]\", CASE_IGNORE))\n        break;\n      mutt_debug(LL_DEBUG3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), dest_mdata->name);\n      if (C_Confirmcreate && (mutt_yesorno(prompt, MUTT_YES) != MUTT_YES))\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(adata, dest_mdata->name) < 0)\n        break;\n      triedcreate = true;\n    }\n  } while (rc == IMAP_EXEC_ERROR);\n\n  if (rc != IMAP_EXEC_SUCCESS)\n  {\n    imap_error(\"imap_fast_trash\", adata->buf);\n    goto out;\n  }\n\n  rc = IMAP_EXEC_SUCCESS;\n\nout:\n  mutt_buffer_dealloc(&sync_cmd);\n  imap_mdata_free((void *) &dest_mdata);\n\n  return ((rc == IMAP_EXEC_SUCCESS) ? 0 : -1);\n}\n\n/**\n * imap_sync_mailbox - Sync all the changes to the server\n * @param m       Mailbox\n * @param expunge if true do expunge\n * @param close   if true we move imap state to CLOSE\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval  0 Success\n * @retval -1 Error\n *\n * @note The flag retvals come from a call to imap_check_mailbox()\n */\nint imap_sync_mailbox(struct Mailbox *m, bool expunge, bool close)\n{\n  if (!m)\n    return -1;\n\n  struct Email **emails = NULL;\n  int oldsort;\n  int rc;\n  int check;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  if (adata->state < IMAP_SELECTED)\n  {\n    mutt_debug(LL_DEBUG2, \"no mailbox selected\\n\");\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen(m);\n\n  check = imap_check_mailbox(m, false);\n  if (check < 0)\n    return check;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && (m->rights & MUTT_ACL_DELETE))\n  {\n    rc = imap_exec_msgset(m, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                          MUTT_DELETED, true, false);\n    if (rc < 0)\n    {\n      mutt_error(_(\"Expunge failed\"));\n      return rc;\n    }\n\n    if (rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (int i = 0; i < m->msg_count; i++)\n      {\n        struct Email *e = m->emails[i];\n        if (!e)\n          break;\n        if (e->deleted && e->changed)\n          e->active = false;\n      }\n      if (m->verbose)\n      {\n        mutt_message(ngettext(\"Marking %d message deleted...\",\n                              \"Marking %d messages deleted...\", rc),\n                     rc);\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  mdata->hcache = imap_hcache_open(adata, mdata);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    if (e->deleted)\n    {\n      imap_cache_del(m, e);\n#ifdef USE_HCACHE\n      imap_hcache_del(mdata, imap_edata_get(e)->uid);\n#endif\n    }\n\n    if (e->active && e->changed)\n    {\n#ifdef USE_HCACHE\n      imap_hcache_put(mdata, e);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      /* TODO: why the e->env check? */\n      if ((e->env && e->env->changed) || e->attach_del)\n      {\n        /* L10N: The plural is chosen by the last %d, i.e. the total number */\n        if (m->verbose)\n        {\n          mutt_message(ngettext(\"Saving changed message... [%d/%d]\",\n                                \"Saving changed messages... [%d/%d]\", m->msg_count),\n                       i + 1, m->msg_count);\n        }\n        bool save_append = m->append;\n        m->append = true;\n        mutt_save_message_ctx(e, true, false, false, m);\n        m->append = save_append;\n        /* TODO: why the check for h->env?  Is this possible? */\n        if (e->env)\n          e->env->changed = 0;\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(mdata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset */\n  oldsort = C_Sort;\n  if (C_Sort != SORT_ORDER)\n  {\n    emails = m->emails;\n    m->emails = mutt_mem_malloc(m->msg_count * sizeof(struct Email *));\n    memcpy(m->emails, emails, m->msg_count * sizeof(struct Email *));\n\n    C_Sort = SORT_ORDER;\n    qsort(m->emails, m->msg_count, sizeof(struct Email *), mutt_get_sort_func(SORT_ORDER));\n  }\n\n  rc = sync_helper(m, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper(m, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if (oldsort != C_Sort)\n  {\n    C_Sort = oldsort;\n    FREE(&m->emails);\n    m->emails = emails;\n  }\n\n  /* Flush the queued flags if any were changed in sync_helper. */\n  if (rc > 0)\n    if (imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (close)\n    {\n      if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), MUTT_NO) == MUTT_YES)\n      {\n        adata->state = IMAP_AUTHENTICATED;\n        return 0;\n      }\n    }\n    else\n      mutt_error(_(\"Error saving flags\"));\n    return -1;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n    struct ImapEmailData *edata = imap_edata_get(e);\n    edata->deleted = e->deleted;\n    edata->flagged = e->flagged;\n    edata->old = e->old;\n    edata->read = e->read;\n    edata->replied = e->replied;\n    e->changed = false;\n  }\n  m->changed = false;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !close && (m->rights & MUTT_ACL_DELETE))\n  {\n    if (m->verbose)\n      mutt_message(_(\"Expunging messages from server...\"));\n    /* Set expunge bit so we don't get spurious reopened messages */\n    mdata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec(adata, \"EXPUNGE\", IMAP_CMD_NO_FLAGS) != IMAP_EXEC_SUCCESS)\n    {\n      mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), adata->buf);\n      return -1;\n    }\n    mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && close)\n  {\n    adata->closing = true;\n    imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);\n    adata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (C_MessageCacheClean)\n    imap_cache_clean(m);\n\n  return check;\n}\n\n/**\n * imap_ac_find - Find an Account that matches a Mailbox path - Implements MxOps::ac_find()\n */\nstatic struct Account *imap_ac_find(struct Account *a, const char *path)\n{\n  if (!a || (a->type != MUTT_IMAP) || !path)\n    return NULL;\n\n  struct Url *url = url_parse(path);\n  if (!url)\n    return NULL;\n\n  struct ImapAccountData *adata = a->adata;\n  struct ConnAccount *cac = &adata->conn->account;\n\n  if (mutt_str_strcasecmp(url->host, cac->host) != 0)\n    a = NULL;\n  else if (url->user && (mutt_str_strcasecmp(url->user, cac->user) != 0))\n    a = NULL;\n\n  url_free(&url);\n  return a;\n}\n\n/**\n * imap_ac_add - Add a Mailbox to an Account - Implements MxOps::ac_add()\n */\nstatic int imap_ac_add(struct Account *a, struct Mailbox *m)\n{\n  if (!a || !m || (m->type != MUTT_IMAP))\n    return -1;\n\n  struct ImapAccountData *adata = a->adata;\n\n  if (!adata)\n  {\n    struct ConnAccount cac = { { 0 } };\n    char mailbox[PATH_MAX];\n\n    if (imap_parse_path(mailbox_path(m), &cac, mailbox, sizeof(mailbox)) < 0)\n      return -1;\n\n    adata = imap_adata_new(a);\n    adata->conn = mutt_conn_new(&cac);\n    if (!adata->conn)\n    {\n      imap_adata_free((void **) &adata);\n      return -1;\n    }\n\n    mutt_account_hook(m->realpath);\n\n    if (imap_login(adata) < 0)\n    {\n      imap_adata_free((void **) &adata);\n      return -1;\n    }\n\n    a->adata = adata;\n    a->adata_free = imap_adata_free;\n  }\n\n  if (!m->mdata)\n  {\n    struct Url *url = url_parse(mailbox_path(m));\n    struct ImapMboxData *mdata = imap_mdata_new(adata, url->path);\n\n    /* fixup path and realpath, mainly to replace / by /INBOX */\n    char buf[1024];\n    imap_qualify_path(buf, sizeof(buf), &adata->conn->account, mdata->name);\n    mutt_buffer_strcpy(&m->pathbuf, buf);\n    mutt_str_replace(&m->realpath, mailbox_path(m));\n\n    m->mdata = mdata;\n    m->mdata_free = imap_mdata_free;\n    url_free(&url);\n  }\n  return 0;\n}\n\n/**\n * imap_mbox_select - Select a Mailbox\n * @param m Mailbox\n */\nstatic void imap_mbox_select(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !mdata)\n    return;\n\n  const char *condstore = NULL;\n#ifdef USE_HCACHE\n  if ((adata->capabilities & IMAP_CAP_CONDSTORE) && C_ImapCondstore)\n    condstore = \" (CONDSTORE)\";\n  else\n#endif\n    condstore = \"\";\n\n  char buf[PATH_MAX];\n  snprintf(buf, sizeof(buf), \"%s %s%s\", m->readonly ? \"EXAMINE\" : \"SELECT\",\n           mdata->munge_name, condstore);\n\n  adata->state = IMAP_SELECTED;\n\n  imap_cmd_start(adata, buf);\n}\n\n/**\n * imap_login -  Open an IMAP connection\n * @param adata Imap Account data\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Ensure ImapAccountData is connected and logged into the imap server.\n */\nint imap_login(struct ImapAccountData *adata)\n{\n  if (!adata)\n    return -1;\n\n  if (adata->state == IMAP_DISCONNECTED)\n  {\n    mutt_buffer_reset(&adata->cmdbuf); // purge outstanding queued commands\n    imap_open_connection(adata);\n  }\n  if (adata->state == IMAP_CONNECTED)\n  {\n    if (imap_authenticate(adata) == IMAP_AUTH_SUCCESS)\n    {\n      adata->state = IMAP_AUTHENTICATED;\n      FREE(&adata->capstr);\n      if (adata->conn->ssf)\n      {\n        mutt_debug(LL_DEBUG2, \"Communication encrypted at %d bits\\n\",\n                   adata->conn->ssf);\n      }\n    }\n    else\n      mutt_account_unsetpass(&adata->conn->account);\n  }\n  if (adata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec(adata, \"CAPABILITY\", IMAP_CMD_PASS);\n\n#ifdef USE_ZLIB\n    /* RFC4978 */\n    if ((adata->capabilities & IMAP_CAP_COMPRESS) && C_ImapDeflate &&\n        (imap_exec(adata, \"COMPRESS DEFLATE\", IMAP_CMD_PASS) == IMAP_EXEC_SUCCESS))\n    {\n      mutt_debug(LL_DEBUG2, \"IMAP compression is enabled on connection to %s\\n\",\n                 adata->conn->account.host);\n      mutt_zstrm_wrap_conn(adata->conn);\n    }\n#endif\n\n    /* enable RFC6855, if the server supports that */\n    if (C_ImapRfc5161 && (adata->capabilities & IMAP_CAP_ENABLE))\n      imap_exec(adata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n\n    /* enable QRESYNC.  Advertising QRESYNC also means CONDSTORE\n     * is supported (even if not advertised), so flip that bit. */\n    if (adata->capabilities & IMAP_CAP_QRESYNC)\n    {\n      adata->capabilities |= IMAP_CAP_CONDSTORE;\n      if (C_ImapRfc5161 && C_ImapQresync)\n        imap_exec(adata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);\n    }\n\n    /* get root delimiter, '/' as default */\n    adata->delim = '/';\n    imap_exec(adata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec(adata, NULL, IMAP_CMD_NO_FLAGS);\n\n    /* select the mailbox that used to be open before disconnect */\n    if (adata->mailbox)\n    {\n      imap_mbox_select(adata->mailbox);\n    }\n  }\n\n  if (adata->state < IMAP_AUTHENTICATED)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_open - Open a mailbox - Implements MxOps::mbox_open()\n */\nstatic int imap_mbox_open(struct Mailbox *m)\n{\n  if (!m || !m->account || !m->mdata)\n    return -1;\n\n  char buf[PATH_MAX];\n  int count = 0;\n  int rc;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  mutt_debug(LL_DEBUG3, \"opening %s, saving %s\\n\", m->pathbuf.data,\n             (adata->mailbox ? adata->mailbox->pathbuf.data : \"(none)\"));\n  adata->prev_mailbox = adata->mailbox;\n  adata->mailbox = m;\n\n  /* clear mailbox status */\n  adata->status = 0;\n  m->rights = 0;\n  mdata->new_mail_count = 0;\n\n  if (m->verbose)\n    mutt_message(_(\"Selecting %s...\"), mdata->name);\n\n  /* pipeline ACL test */\n  if (adata->capabilities & IMAP_CAP_ACL)\n  {\n    snprintf(buf, sizeof(buf), \"MYRIGHTS %s\", mdata->munge_name);\n    imap_exec(adata, buf, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    m->rights |= MUTT_ACL_LOOKUP | MUTT_ACL_READ | MUTT_ACL_SEEN | MUTT_ACL_WRITE |\n                 MUTT_ACL_INSERT | MUTT_ACL_POST | MUTT_ACL_CREATE | MUTT_ACL_DELETE;\n  }\n\n  /* pipeline the postponed count if possible */\n  struct Mailbox *m_postponed = mx_mbox_find2(C_Postponed);\n  struct ImapAccountData *postponed_adata = imap_adata_get(m_postponed);\n  if (postponed_adata &&\n      imap_account_match(&postponed_adata->conn->account, &adata->conn->account))\n  {\n    imap_mailbox_status(m_postponed, true);\n  }\n\n  if (C_ImapCheckSubscribed)\n    imap_exec(adata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n\n  imap_mbox_select(m);\n\n  do\n  {\n    char *pc = NULL;\n\n    rc = imap_cmd_step(adata);\n    if (rc != IMAP_RES_CONTINUE)\n      break;\n\n    pc = adata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (mutt_str_startswith(pc, \"FLAGS\", CASE_IGNORE))\n    {\n      /* don't override PERMANENTFLAGS */\n      if (STAILQ_EMPTY(&mdata->flags))\n      {\n        mutt_debug(LL_DEBUG3, \"Getting mailbox FLAGS\\n\");\n        pc = get_flags(&mdata->flags, pc);\n        if (!pc)\n          goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (mutt_str_startswith(pc, \"OK [PERMANENTFLAGS\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox PERMANENTFLAGS\\n\");\n      /* safe to call on NULL */\n      mutt_list_free(&mdata->flags);\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      pc = get_flags(&(mdata->flags), pc);\n      if (!pc)\n        goto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (mutt_str_startswith(pc, \"OK [UIDVALIDITY\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox UIDVALIDITY\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &mdata->uidvalidity) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [UIDNEXT\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox UIDNEXT\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &mdata->uid_next) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [HIGHESTMODSEQ\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Getting mailbox HIGHESTMODSEQ\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoull(pc, &mdata->modseq) < 0)\n        goto fail;\n    }\n    else if (mutt_str_startswith(pc, \"OK [NOMODSEQ\", CASE_IGNORE))\n    {\n      mutt_debug(LL_DEBUG3, \"Mailbox has NOMODSEQ set\\n\");\n      mdata->modseq = 0;\n    }\n    else\n    {\n      pc = imap_next_word(pc);\n      if (mutt_str_startswith(pc, \"EXISTS\", CASE_IGNORE))\n      {\n        count = mdata->new_mail_count;\n        mdata->new_mail_count = 0;\n      }\n    }\n  } while (rc == IMAP_RES_CONTINUE);\n\n  if (rc == IMAP_RES_NO)\n  {\n    char *s = imap_next_word(adata->buf); /* skip seq */\n    s = imap_next_word(s);                /* Skip response */\n    mutt_error(\"%s\", s);\n    goto fail;\n  }\n\n  if (rc != IMAP_RES_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if (mutt_str_startswith(imap_get_qualifier(adata->buf), \"[READ-ONLY]\", CASE_IGNORE) &&\n      !(adata->capabilities & IMAP_CAP_ACL))\n  {\n    mutt_debug(LL_DEBUG2, \"Mailbox is read-only\\n\");\n    m->readonly = true;\n  }\n\n  /* dump the mailbox flags we've found */\n  if (C_DebugLevel > LL_DEBUG2)\n  {\n    if (STAILQ_EMPTY(&mdata->flags))\n      mutt_debug(LL_DEBUG3, \"No folder flags found\\n\");\n    else\n    {\n      struct ListNode *np = NULL;\n      struct Buffer flag_buffer;\n      mutt_buffer_init(&flag_buffer);\n      mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");\n      STAILQ_FOREACH(np, &mdata->flags, entries)\n      {\n        mutt_buffer_add_printf(&flag_buffer, \"[%s] \", np->data);\n      }\n      mutt_debug(LL_DEBUG3, \"%s\\n\", flag_buffer.data);\n      FREE(&flag_buffer.data);\n    }\n  }\n\n  if (!((m->rights & MUTT_ACL_DELETE) || (m->rights & MUTT_ACL_SEEN) ||\n        (m->rights & MUTT_ACL_WRITE) || (m->rights & MUTT_ACL_INSERT)))\n  {\n    m->readonly = true;\n  }\n\n  while (m->email_max < count)\n    mx_alloc_memory(m);\n\n  m->msg_count = 0;\n  m->msg_unread = 0;\n  m->msg_flagged = 0;\n  m->msg_new = 0;\n  m->msg_deleted = 0;\n  m->size = 0;\n  m->vcount = 0;\n\n  if (count && (imap_read_headers(m, 1, count, true) < 0))\n  {\n    mutt_error(_(\"Error opening mailbox\"));\n    goto fail;\n  }\n\n  mutt_debug(LL_DEBUG2, \"msg_count is %d\\n\", m->msg_count);\n  return 0;\n\nfail:\n  if (adata->state == IMAP_SELECTED)\n    adata->state = IMAP_AUTHENTICATED;\n  return -1;\n}\n\n/**\n * imap_mbox_open_append - Open a Mailbox for appending - Implements MxOps::mbox_open_append()\n */\nstatic int imap_mbox_open_append(struct Mailbox *m, OpenMailboxFlags flags)\n{\n  if (!m || !m->account)\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  int rc = imap_mailbox_status(m, false);\n  if (rc >= 0)\n    return 0;\n  if (rc == -1)\n    return -1;\n\n  char buf[PATH_MAX + 64];\n  snprintf(buf, sizeof(buf), _(\"Create %s?\"), mdata->name);\n  if (C_Confirmcreate && (mutt_yesorno(buf, MUTT_YES) != MUTT_YES))\n    return -1;\n\n  if (imap_create_mailbox(adata, mdata->name) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_check - Check for new mail - Implements MxOps::mbox_check()\n * @param m          Mailbox\n * @param index_hint Remember our place in the index\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nstatic int imap_mbox_check(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  imap_allow_reopen(m);\n  int rc = imap_check_mailbox(m, false);\n  /* NOTE - ctx might have been changed at this point. In particular,\n   * m could be NULL. Beware. */\n  imap_disallow_reopen(m);\n\n  return rc;\n}\n\n/**\n * imap_mbox_close - Close a Mailbox - Implements MxOps::mbox_close()\n */\nstatic int imap_mbox_close(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n\n  /* Check to see if the mailbox is actually open */\n  if (!adata || !mdata)\n    return 0;\n\n  /* imap_mbox_open_append() borrows the struct ImapAccountData temporarily,\n   * just for the connection.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up adata.  Otherwise, we don't want to\n   * touch adata - it's still being used.  */\n  if (m == adata->mailbox)\n  {\n    if ((adata->status != IMAP_FATAL) && (adata->state >= IMAP_SELECTED))\n    {\n      /* mx_mbox_close won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (m->msg_deleted == 0)\n      {\n        adata->closing = true;\n        imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);\n      }\n      adata->state = IMAP_AUTHENTICATED;\n    }\n\n    mutt_debug(LL_DEBUG3, \"closing %s, restoring %s\\n\", m->pathbuf.data,\n               (adata->prev_mailbox ? adata->prev_mailbox->pathbuf.data : \"(none)\"));\n    adata->mailbox = adata->prev_mailbox;\n    imap_mbox_select(adata->prev_mailbox);\n    imap_mdata_cache_reset(m->mdata);\n  }\n\n  return 0;\n}\n\n/**\n * imap_msg_open_new - Open a new message in a Mailbox - Implements MxOps::msg_open_new()\n */\nstatic int imap_msg_open_new(struct Mailbox *m, struct Message *msg, struct Email *e)\n{\n  int rc = -1;\n\n  struct Buffer *tmp = mutt_buffer_pool_get();\n  mutt_buffer_mktemp(tmp);\n\n  msg->fp = mutt_file_fopen(mutt_b2s(tmp), \"w\");\n  if (!msg->fp)\n  {\n    mutt_perror(mutt_b2s(tmp));\n    goto cleanup;\n  }\n\n  msg->path = mutt_buffer_strdup(tmp);\n  rc = 0;\n\ncleanup:\n  mutt_buffer_pool_release(&tmp);\n  return rc;\n}\n\n/**\n * imap_tags_edit - Prompt and validate new messages tags - Implements MxOps::tags_edit()\n */\nstatic int imap_tags_edit(struct Mailbox *m, const char *tags, char *buf, size_t buflen)\n{\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!mdata)\n    return -1;\n\n  char *new_tag = NULL;\n  char *checker = NULL;\n\n  /* Check for \\* flags capability */\n  if (!imap_has_flag(&mdata->flags, NULL))\n  {\n    mutt_error(_(\"IMAP server doesn't support custom flags\"));\n    return -1;\n  }\n\n  *buf = '\\0';\n  if (tags)\n    mutt_str_strfcpy(buf, tags, buflen);\n\n  if (mutt_get_field(\"Tags: \", buf, buflen, MUTT_COMP_NO_FLAGS) != 0)\n    return -1;\n\n  /* each keyword must be atom defined by rfc822 as:\n   *\n   * atom           = 1*<any CHAR except specials, SPACE and CTLs>\n   * CHAR           = ( 0.-127. )\n   * specials       = \"(\" / \")\" / \"<\" / \">\" / \"@\"\n   *                  / \",\" / \";\" / \":\" / \"\\\" / <\">\n   *                  / \".\" / \"[\" / \"]\"\n   * SPACE          = ( 32. )\n   * CTLS           = ( 0.-31., 127.)\n   *\n   * And must be separated by one space.\n   */\n\n  new_tag = buf;\n  checker = buf;\n  SKIPWS(checker);\n  while (*checker != '\\0')\n  {\n    if ((*checker < 32) || (*checker >= 127) || // We allow space because it's the separator\n        (*checker == 40) ||                     // (\n        (*checker == 41) ||                     // )\n        (*checker == 60) ||                     // <\n        (*checker == 62) ||                     // >\n        (*checker == 64) ||                     // @\n        (*checker == 44) ||                     // ,\n        (*checker == 59) ||                     // ;\n        (*checker == 58) ||                     // :\n        (*checker == 92) ||                     // backslash\n        (*checker == 34) ||                     // \"\n        (*checker == 46) ||                     // .\n        (*checker == 91) ||                     // [\n        (*checker == 93))                       // ]\n    {\n      mutt_error(_(\"Invalid IMAP flags\"));\n      return 0;\n    }\n\n    /* Skip duplicate space */\n    while ((checker[0] == ' ') && (checker[1] == ' '))\n      checker++;\n\n    /* copy char to new_tag and go the next one */\n    *new_tag++ = *checker++;\n  }\n  *new_tag = '\\0';\n  new_tag = buf; /* rewind */\n  mutt_str_remove_trailing_ws(new_tag);\n\n  if (mutt_str_strcmp(tags, buf) == 0)\n    return 0;\n  return 1;\n}\n\n/**\n * imap_tags_commit - Save the tags to a message - Implements MxOps::tags_commit()\n *\n * This method update the server flags on the server by\n * removing the last know custom flags of a header\n * and adds the local flags\n *\n * If everything success we push the local flags to the\n * last know custom flags (flags_remote).\n *\n * Also this method check that each flags is support by the server\n * first and remove unsupported one.\n */\nstatic int imap_tags_commit(struct Mailbox *m, struct Email *e, char *buf)\n{\n  if (!m)\n    return -1;\n\n  char uid[11];\n\n  struct ImapAccountData *adata = imap_adata_get(m);\n\n  if (*buf == '\\0')\n    buf = NULL;\n\n  if (!(adata->mailbox->rights & MUTT_ACL_WRITE))\n    return 0;\n\n  snprintf(uid, sizeof(uid), \"%u\", imap_edata_get(e)->uid);\n\n  /* Remove old custom flags */\n  if (imap_edata_get(e)->flags_remote)\n  {\n    struct Buffer cmd = mutt_buffer_make(128); // just a guess\n    mutt_buffer_addstr(&cmd, \"UID STORE \");\n    mutt_buffer_addstr(&cmd, uid);\n    mutt_buffer_addstr(&cmd, \" -FLAGS.SILENT (\");\n    mutt_buffer_addstr(&cmd, imap_edata_get(e)->flags_remote);\n    mutt_buffer_addstr(&cmd, \")\");\n\n    /* Should we return here, or we are fine and we could\n     * continue to add new flags */\n    int rc = imap_exec(adata, cmd.data, IMAP_CMD_NO_FLAGS);\n    mutt_buffer_dealloc(&cmd);\n    if (rc != IMAP_EXEC_SUCCESS)\n    {\n      return -1;\n    }\n  }\n\n  /* Add new custom flags */\n  if (buf)\n  {\n    struct Buffer cmd = mutt_buffer_make(128); // just a guess\n    mutt_buffer_addstr(&cmd, \"UID STORE \");\n    mutt_buffer_addstr(&cmd, uid);\n    mutt_buffer_addstr(&cmd, \" +FLAGS.SILENT (\");\n    mutt_buffer_addstr(&cmd, buf);\n    mutt_buffer_addstr(&cmd, \")\");\n\n    int rc = imap_exec(adata, cmd.data, IMAP_CMD_NO_FLAGS);\n    mutt_buffer_dealloc(&cmd);\n    if (rc != IMAP_EXEC_SUCCESS)\n    {\n      mutt_debug(LL_DEBUG1, \"fail to add new flags\\n\");\n      return -1;\n    }\n  }\n\n  /* We are good sync them */\n  mutt_debug(LL_DEBUG1, \"NEW TAGS: %s\\n\", buf);\n  driver_tags_replace(&e->tags, buf);\n  FREE(&imap_edata_get(e)->flags_remote);\n  imap_edata_get(e)->flags_remote = driver_tags_get_with_hidden(&e->tags);\n  return 0;\n}\n\n/**\n * imap_path_probe - Is this an IMAP Mailbox? - Implements MxOps::path_probe()\n */\nenum MailboxType imap_path_probe(const char *path, const struct stat *st)\n{\n  if (!path)\n    return MUTT_UNKNOWN;\n\n  if (mutt_str_startswith(path, \"imap://\", CASE_IGNORE))\n    return MUTT_IMAP;\n\n  if (mutt_str_startswith(path, \"imaps://\", CASE_IGNORE))\n    return MUTT_IMAP;\n\n  return MUTT_UNKNOWN;\n}\n\n/**\n * imap_path_canon - Canonicalise a Mailbox path - Implements MxOps::path_canon()\n */\nint imap_path_canon(char *buf, size_t buflen)\n{\n  if (!buf)\n    return -1;\n\n  struct Url *url = url_parse(buf);\n  if (!url)\n    return 0;\n\n  char tmp[PATH_MAX];\n  char tmp2[PATH_MAX];\n\n  imap_fix_path('\\0', url->path, tmp, sizeof(tmp));\n  url->path = tmp;\n  url_tostring(url, tmp2, sizeof(tmp2), 0);\n  mutt_str_strfcpy(buf, tmp2, buflen);\n  url_free(&url);\n\n  return 0;\n}\n\n/**\n * imap_expand_path - Buffer wrapper around imap_path_canon()\n * @param buf Path to expand\n * @retval  0 Success\n * @retval -1 Failure\n *\n * @note The path is expanded in place\n */\nint imap_expand_path(struct Buffer *buf)\n{\n  mutt_buffer_alloc(buf, PATH_MAX);\n  return imap_path_canon(buf->data, PATH_MAX);\n}\n\n/**\n * imap_path_pretty - Abbreviate a Mailbox path - Implements MxOps::path_pretty()\n */\nstatic int imap_path_pretty(char *buf, size_t buflen, const char *folder)\n{\n  if (!buf || !folder)\n    return -1;\n\n  imap_pretty_mailbox(buf, buflen, folder);\n  return 0;\n}\n\n/**\n * imap_path_parent - Find the parent of a Mailbox path - Implements MxOps::path_parent()\n */\nstatic int imap_path_parent(char *buf, size_t buflen)\n{\n  char tmp[PATH_MAX] = { 0 };\n\n  imap_get_parent_path(buf, tmp, sizeof(tmp));\n  mutt_str_strfcpy(buf, tmp, buflen);\n  return 0;\n}\n\n// clang-format off\n/**\n * MxImapOps - IMAP Mailbox - Implements ::MxOps\n */\nstruct MxOps MxImapOps = {\n  .type            = MUTT_IMAP,\n  .name             = \"imap\",\n  .is_local         = false,\n  .ac_find          = imap_ac_find,\n  .ac_add           = imap_ac_add,\n  .mbox_open        = imap_mbox_open,\n  .mbox_open_append = imap_mbox_open_append,\n  .mbox_check       = imap_mbox_check,\n  .mbox_check_stats = imap_mbox_check_stats,\n  .mbox_sync        = NULL, /* imap syncing is handled by imap_sync_mailbox */\n  .mbox_close       = imap_mbox_close,\n  .msg_open         = imap_msg_open,\n  .msg_open_new     = imap_msg_open_new,\n  .msg_commit       = imap_msg_commit,\n  .msg_close        = imap_msg_close,\n  .msg_padding_size = NULL,\n  .msg_save_hcache  = imap_msg_save_hcache,\n  .tags_edit        = imap_tags_edit,\n  .tags_commit      = imap_tags_commit,\n  .path_probe       = imap_path_probe,\n  .path_canon       = imap_path_canon,\n  .path_pretty      = imap_path_pretty,\n  .path_parent      = imap_path_parent,\n};\n// clang-format on\n", "/**\n * @file\n * Shared constants/structs that are private to IMAP\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef MUTT_IMAP_PRIVATE_H\n#define MUTT_IMAP_PRIVATE_H\n\n#include \"config.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <time.h>\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"hcache/lib.h\"\n\nstruct Account;\nstruct ConnAccount;\nstruct Email;\nstruct Mailbox;\nstruct Message;\nstruct Progress;\n\n#define IMAP_PORT     143  ///< Default port for IMAP\n#define IMAP_SSL_PORT 993  ///< Port for IMAP over SSL/TLS\n\n/* logging levels */\n#define IMAP_LOG_CMD  2\n#define IMAP_LOG_LTRL 3\n#define IMAP_LOG_PASS 5\n\n/* IMAP command responses. Used in ImapCommand.state too */\n#define IMAP_RES_NO       -2  ///< `<tag> NO ...`\n#define IMAP_RES_BAD      -1  ///< `<tag> BAD ...`\n#define IMAP_RES_OK        0  ///< `<tag> OK ...`\n#define IMAP_RES_CONTINUE  1  ///< `* ...`\n#define IMAP_RES_RESPOND   2  ///< `+`\n#define IMAP_RES_NEW       3  ///< ImapCommand.state additions\n\n#define SEQ_LEN 16\n#define IMAP_MAX_CMDLEN 1024 ///< Maximum length of command lines before they must be split (for lazy servers)\n\ntypedef uint8_t ImapOpenFlags;         ///< Flags, e.g. #MUTT_THREAD_COLLAPSE\n#define IMAP_OPEN_NO_FLAGS          0  ///< No flags are set\n#define IMAP_REOPEN_ALLOW     (1 << 0) ///< Allow re-opening a folder upon expunge\n#define IMAP_EXPUNGE_EXPECTED (1 << 1) ///< Messages will be expunged from the server\n#define IMAP_EXPUNGE_PENDING  (1 << 2) ///< Messages on the server have been expunged\n#define IMAP_NEWMAIL_PENDING  (1 << 3) ///< New mail is waiting on the server\n#define IMAP_FLAGS_PENDING    (1 << 4) ///< Flags have changed on the server\n\ntypedef uint8_t ImapCmdFlags;          ///< Flags for imap_exec(), e.g. #IMAP_CMD_PASS\n#define IMAP_CMD_NO_FLAGS          0   ///< No flags are set\n#define IMAP_CMD_PASS        (1 << 0)  ///< Command contains a password. Suppress logging\n#define IMAP_CMD_QUEUE       (1 << 1)  ///< Queue a command, do not execute\n#define IMAP_CMD_POLL        (1 << 2)  ///< Poll the tcp connection before running the imap command\n#define IMAP_CMD_SINGLE      (1 << 3)  ///< Run a single command\n\n/**\n * enum ImapExecResult - imap_exec return code\n */\nenum ImapExecResult\n{\n  IMAP_EXEC_SUCCESS = 0, ///< Imap command executed or queued successfully\n  IMAP_EXEC_ERROR,       ///< Imap command failure\n  IMAP_EXEC_FATAL,       ///< Imap connection failure\n};\n\n/* length of \"DD-MMM-YYYY HH:MM:SS +ZZzz\" (null-terminated) */\n#define IMAP_DATELEN 27\n\n/**\n * enum ImapFlags - IMAP server responses\n */\nenum ImapFlags\n{\n  IMAP_FATAL = 1, ///< Unrecoverable error occurred\n  IMAP_BYE,       ///< Logged out from server\n};\n\n/**\n * enum ImapState - IMAP connection state\n */\nenum ImapState\n{\n  /* States */\n  IMAP_DISCONNECTED = 0, ///< Disconnected from server\n  IMAP_CONNECTED,        ///< Connected to server\n  IMAP_AUTHENTICATED,    ///< Connection is authenticated\n  IMAP_SELECTED,         ///< Mailbox is selected\n\n  /* and pseudo-states */\n  IMAP_IDLE, ///< Connection is idle\n};\n\n/**\n * typedef ImapCapFlags - Capabilities we are interested in\n *\n * @note This must be kept in the same order as Capabilities.\n */\ntypedef uint32_t ImapCapFlags;              ///< Flags, e.g. #IMAP_CAP_IMAP4\n#define IMAP_CAP_NO_FLAGS                0  ///< No flags are set\n#define IMAP_CAP_IMAP4            (1 <<  0) ///< Server supports IMAP4\n#define IMAP_CAP_IMAP4REV1        (1 <<  1) ///< Server supports IMAP4rev1\n#define IMAP_CAP_STATUS           (1 <<  2) ///< Server supports STATUS command\n#define IMAP_CAP_ACL              (1 <<  3) ///< RFC2086: IMAP4 ACL extension\n#define IMAP_CAP_NAMESPACE        (1 <<  4) ///< RFC2342: IMAP4 Namespace\n#define IMAP_CAP_AUTH_CRAM_MD5    (1 <<  5) ///< RFC2195: CRAM-MD5 authentication\n#define IMAP_CAP_AUTH_GSSAPI      (1 <<  6) ///< RFC1731: GSSAPI authentication\n#define IMAP_CAP_AUTH_ANONYMOUS   (1 <<  7) ///< AUTH=ANONYMOUS\n#define IMAP_CAP_AUTH_OAUTHBEARER (1 <<  8) ///< RFC7628: AUTH=OAUTHBEARER\n#define IMAP_CAP_STARTTLS         (1 <<  9) ///< RFC2595: STARTTLS\n#define IMAP_CAP_LOGINDISABLED    (1 << 10) ///< RFC2595: LOGINDISABLED\n#define IMAP_CAP_IDLE             (1 << 11) ///< RFC2177: IDLE\n#define IMAP_CAP_SASL_IR          (1 << 12) ///< SASL initial response draft\n#define IMAP_CAP_ENABLE           (1 << 13) ///< RFC5161\n#define IMAP_CAP_CONDSTORE        (1 << 14) ///< RFC7162\n#define IMAP_CAP_QRESYNC          (1 << 15) ///< RFC7162\n#define IMAP_CAP_LIST_EXTENDED    (1 << 16) ///< RFC5258: IMAP4 LIST Command Extensions\n#define IMAP_CAP_COMPRESS         (1 << 17) ///< RFC4978: COMPRESS=DEFLATE\n#define IMAP_CAP_X_GM_EXT_1       (1 << 18) ///< https://developers.google.com/gmail/imap/imap-extensions\n\n#define IMAP_CAP_ALL             ((1 << 19) - 1)\n\n/**\n * struct ImapList - Items in an IMAP browser\n */\nstruct ImapList\n{\n  char *name;\n  char delim;\n  bool noselect;\n  bool noinferiors;\n};\n\n/**\n * struct ImapCommand - IMAP command structure\n */\nstruct ImapCommand\n{\n  char seq[SEQ_LEN + 1]; ///< Command tag, e.g. 'a0001'\n  int state;            ///< Command state, e.g. #IMAP_RES_NEW\n};\n\n/**\n * struct ImapAccountData - IMAP-specific Account data - @extends Account\n *\n * This data is specific to a Connection to an IMAP server\n */\nstruct ImapAccountData\n{\n  struct Connection *conn;\n  bool recovering;\n  bool closing; ///< If true, we are waiting for CLOSE completion\n  unsigned char state;  ///< ImapState, e.g. #IMAP_AUTHENTICATED\n  unsigned char status; ///< ImapFlags, e.g. #IMAP_FATAL\n  /* let me explain capstr: SASL needs the capability string (not bits).\n   * we have 3 options:\n   *   1. rerun CAPABILITY inside SASL function.\n   *   2. build appropriate CAPABILITY string by reverse-engineering from bits.\n   *   3. keep a copy until after authentication.\n   * I've chosen (3) for now. (2) might not be too bad, but it involves\n   * tracking all possible capabilities. bah. (1) I don't like because\n   * it's just no fun to get the same information twice */\n  char *capstr;\n  ImapCapFlags capabilities;\n  unsigned char seqid; ///< tag sequence prefix\n  unsigned int seqno; ///< tag sequence number, e.g. '{seqid}0001'\n  time_t lastread; ///< last time we read a command for the server\n  char *buf;\n  size_t blen;\n\n  bool unicode; ///< If true, we can send UTF-8, and the server will use UTF8 rather than mUTF7\n  bool qresync; ///< true, if QRESYNC is successfully ENABLE'd\n\n  // if set, the response parser will store results for complicated commands here\n  struct ImapList *cmdresult;\n\n  /* command queue */\n  struct ImapCommand *cmds;\n  int cmdslots;\n  int nextcmd;\n  int lastcmd;\n  struct Buffer cmdbuf;\n\n  char delim;\n  struct Mailbox *mailbox;      ///< Current selected mailbox\n  struct Mailbox *prev_mailbox; ///< Previously selected mailbox\n  struct Account *account;      ///< Parent Account\n};\n\n/**\n * struct ImapMboxData - IMAP-specific Mailbox data - @extends Mailbox\n *\n * This data is specific to a Mailbox of an IMAP server\n */\nstruct ImapMboxData\n{\n  char *name;        ///< Mailbox name\n  char *munge_name;  ///< Munged version of the mailbox name\n  char *real_name;   ///< Original Mailbox name, e.g.: INBOX can be just \\0\n\n  ImapOpenFlags reopen;        ///< Flags, e.g. #IMAP_REOPEN_ALLOW\n  ImapOpenFlags check_status;  ///< Flags, e.g. #IMAP_NEWMAIL_PENDING\n  unsigned int new_mail_count; ///< Set when EXISTS notifies of new mail\n\n  // IMAP STATUS information\n  struct ListHead flags;\n  uint32_t uidvalidity;\n  unsigned int uid_next;\n  unsigned long long modseq;\n  unsigned int messages;\n  unsigned int recent;\n  unsigned int unseen;\n\n  // Cached data used only when the mailbox is opened\n  struct HashTable *uid_hash;\n  struct Email **msn_index;   ///< look up headers by (MSN-1)\n  size_t msn_index_size;       ///< allocation size\n  unsigned int max_msn;        ///< the largest MSN fetched so far\n  struct BodyCache *bcache;\n\n  header_cache_t *hcache;\n};\n\n/**\n * struct SeqsetIterator - UID Sequence Set Iterator\n */\nstruct SeqsetIterator\n{\n  char *full_seqset;\n  char *eostr;\n  int in_range;\n  int down;\n  unsigned int range_cur;\n  unsigned int range_end;\n  char *substr_cur;\n  char *substr_end;\n};\n\n/* -- private IMAP functions -- */\n/* imap.c */\nint imap_create_mailbox(struct ImapAccountData *adata, char *mailbox);\nint imap_rename_mailbox(struct ImapAccountData *adata, char *oldname, const char *newname);\nint imap_exec_msgset(struct Mailbox *m, const char *pre, const char *post,\n                     int flag, bool changed, bool invert);\nint imap_open_connection(struct ImapAccountData *adata);\nvoid imap_close_connection(struct ImapAccountData *adata);\nint imap_read_literal(FILE *fp, struct ImapAccountData *adata, unsigned long bytes, struct Progress *pbar);\nvoid imap_expunge_mailbox(struct Mailbox *m);\nint imap_login(struct ImapAccountData *adata);\nint imap_sync_message_for_copy(struct Mailbox *m, struct Email *e, struct Buffer *cmd, enum QuadOption *err_continue);\nbool imap_has_flag(struct ListHead *flag_list, const char *flag);\nint imap_adata_find(const char *path, struct ImapAccountData **adata, struct ImapMboxData **mdata);\n\n/* auth.c */\nint imap_authenticate(struct ImapAccountData *adata);\n\n/* command.c */\nint imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr);\nint imap_cmd_step(struct ImapAccountData *adata);\nvoid imap_cmd_finish(struct ImapAccountData *adata);\nbool imap_code(const char *s);\nconst char *imap_cmd_trailer(struct ImapAccountData *adata);\nint imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags);\nint imap_cmd_idle(struct ImapAccountData *adata);\n\n/* message.c */\nvoid imap_edata_free(void **ptr);\nstruct ImapEmailData *imap_edata_get(struct Email *e);\nint imap_read_headers(struct Mailbox *m, unsigned int msn_begin, unsigned int msn_end, bool initial_download);\nchar *imap_set_flags(struct Mailbox *m, struct Email *e, char *s, bool *server_changes);\nint imap_cache_del(struct Mailbox *m, struct Email *e);\nint imap_cache_clean(struct Mailbox *m);\nint imap_append_message(struct Mailbox *m, struct Message *msg);\n\nint imap_msg_open(struct Mailbox *m, struct Message *msg, int msgno);\nint imap_msg_close(struct Mailbox *m, struct Message *msg);\nint imap_msg_commit(struct Mailbox *m, struct Message *msg);\nint imap_msg_save_hcache(struct Mailbox *m, struct Email *e);\n\n/* util.c */\nstruct ImapAccountData *imap_adata_get(struct Mailbox *m);\nstruct ImapMboxData *imap_mdata_get(struct Mailbox *m);\n#ifdef USE_HCACHE\nheader_cache_t *imap_hcache_open(struct ImapAccountData *adata, struct ImapMboxData *mdata);\nvoid imap_hcache_close(struct ImapMboxData *mdata);\nstruct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid);\nint imap_hcache_put(struct ImapMboxData *mdata, struct Email *e);\nint imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid);\nint imap_hcache_store_uid_seqset(struct ImapMboxData *mdata);\nint imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata);\nchar *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata);\n#endif\n\nenum QuadOption imap_continue(const char *msg, const char *resp);\nvoid imap_error(const char *where, const char *msg);\nstruct ImapAccountData *imap_adata_new(struct Account *a);\nvoid imap_adata_free(void **ptr);\nstruct ImapMboxData *imap_mdata_new(struct ImapAccountData *adata, const char* name);\nvoid imap_mdata_free(void **ptr);\nvoid imap_mdata_cache_reset(struct ImapMboxData *mdata);\nchar *imap_fix_path(char delim, const char *mailbox, char *path, size_t plen);\nvoid imap_cachepath(char delim, const char *mailbox, struct Buffer *dest);\nint imap_get_literal_count(const char *buf, unsigned int *bytes);\nchar *imap_get_qualifier(char *buf);\nchar *imap_next_word(char *s);\nvoid imap_qualify_path(char *buf, size_t buflen, struct ConnAccount *conn_account, char *path);\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\nvoid imap_unquote_string(char *s);\nvoid imap_munge_mbox_name(bool unicode, char *dest, size_t dlen, const char *src);\nvoid imap_unmunge_mbox_name(bool unicode, char *s);\nstruct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset);\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next);\nvoid mutt_seqset_iterator_free(struct SeqsetIterator **ptr);\nbool imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2);\nvoid imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen);\nbool  mutt_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2);\n\n/* utf7.c */\nvoid imap_utf_encode(bool unicode, char **s);\nvoid imap_utf_decode(bool unicode, char **s);\nvoid imap_allow_reopen(struct Mailbox *m);\nvoid imap_disallow_reopen(struct Mailbox *m);\n\n/* search.c */\nvoid cmd_parse_search(struct ImapAccountData *adata, const char *s);\n\n#endif /* MUTT_IMAP_PRIVATE_H */\n", "/**\n * @file\n * Usenet network mailbox type; talk to an NNTP server\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page nntp_nntp Usenet network mailbox type; talk to an NNTP server\n *\n * Usenet network mailbox type; talk to an NNTP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n#include <unistd.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"lib.h\"\n#include \"globals.h\"\n#include \"hook.h\"\n#include \"init.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_parse.h\"\n#include \"mutt_socket.h\"\n#include \"muttlib.h\"\n#include \"mx.h\"\n#include \"progress.h\"\n#include \"sort.h\"\n#include \"bcache/lib.h\"\n#include \"hcache/lib.h\"\n#include \"ncrypt/lib.h\"\n#ifdef USE_HCACHE\n#include \"protos.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#endif\n#if defined(USE_SSL) || defined(USE_HCACHE)\n#include \"mutt.h\"\n#endif\n\nstruct stat;\n\n/* These Config Variables are only used in nntp/nntp.c */\nchar *C_NntpAuthenticators; ///< Config: (nntp) Allowed authentication methods\nshort C_NntpContext; ///< Config: (nntp) Maximum number of articles to list (0 for all articles)\nbool C_NntpListgroup; ///< Config: (nntp) Check all articles when opening a newsgroup\nbool C_NntpLoadDescription; ///< Config: (nntp) Load descriptions for newsgroups when adding to the list\nshort C_NntpPoll; ///< Config: (nntp) Interval between checks for new posts\nbool C_ShowNewNews; ///< Config: (nntp) Check for new newsgroups when entering the browser\n\nstruct NntpAccountData *CurrentNewsSrv;\n\nconst char *OverviewFmt = \"Subject:\\0\"\n                          \"From:\\0\"\n                          \"Date:\\0\"\n                          \"Message-ID:\\0\"\n                          \"References:\\0\"\n                          \"Content-Length:\\0\"\n                          \"Lines:\\0\"\n                          \"\\0\";\n\n/**\n * struct FetchCtx - Keep track when getting data from a server\n */\nstruct FetchCtx\n{\n  struct Mailbox *mailbox;\n  anum_t first;\n  anum_t last;\n  bool restore;\n  unsigned char *messages;\n  struct Progress progress;\n  header_cache_t *hc;\n};\n\n/**\n * struct ChildCtx - Keep track of the children of an article\n */\nstruct ChildCtx\n{\n  struct Mailbox *mailbox;\n  unsigned int num;\n  unsigned int max;\n  anum_t *child;\n};\n\n/**\n * nntp_adata_free - Free data attached to the Mailbox\n * @param[out] ptr NNTP data\n *\n * The NntpAccountData struct stores global NNTP data, such as the connection to\n * the database.  This function will close the database, free the resources and\n * the struct itself.\n */\nstatic void nntp_adata_free(void **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct NntpAccountData *adata = *ptr;\n\n  mutt_file_fclose(&adata->fp_newsrc);\n  FREE(&adata->newsrc_file);\n  FREE(&adata->authenticators);\n  FREE(&adata->overview_fmt);\n  FREE(&adata->conn);\n  FREE(&adata->groups_list);\n  mutt_hash_free(&adata->groups_hash);\n  FREE(ptr);\n}\n\n/**\n * nntp_hashelem_free - Free our hash table data - Implements ::hash_hdata_free_t\n */\nstatic void nntp_hashelem_free(int type, void *obj, intptr_t data)\n{\n  nntp_mdata_free(&obj);\n}\n\n/**\n * nntp_adata_new - Allocate and initialise a new NntpAccountData structure\n * @param conn Network connection\n * @retval ptr New NntpAccountData\n */\nstruct NntpAccountData *nntp_adata_new(struct Connection *conn)\n{\n  struct NntpAccountData *adata = mutt_mem_calloc(1, sizeof(struct NntpAccountData));\n  adata->conn = conn;\n  adata->groups_hash = mutt_hash_new(1009, MUTT_HASH_NO_FLAGS);\n  mutt_hash_set_destructor(adata->groups_hash, nntp_hashelem_free, 0);\n  adata->groups_max = 16;\n  adata->groups_list =\n      mutt_mem_malloc(adata->groups_max * sizeof(struct NntpMboxData *));\n  return adata;\n}\n\n#if 0\n/**\n * nntp_adata_get - Get the Account data for this mailbox\n * @retval ptr Private Account data\n */\nstruct NntpAccountData *nntp_adata_get(struct Mailbox *m)\n{\n  if (!m || (m->type != MUTT_NNTP))\n    return NULL;\n  struct Account *a = m->account;\n  if (!a)\n    return NULL;\n  return a->adata;\n}\n#endif\n\n/**\n * nntp_mdata_free - Free NntpMboxData, used to destroy hash elements\n * @param[out] ptr NNTP data\n */\nvoid nntp_mdata_free(void **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct NntpMboxData *mdata = *ptr;\n\n  nntp_acache_free(mdata);\n  mutt_bcache_close(&mdata->bcache);\n  FREE(&mdata->newsrc_ent);\n  FREE(&mdata->desc);\n  FREE(ptr);\n}\n\n/**\n * nntp_edata_free - Free data attached to an Email\n * @param[out] ptr Email data\n */\nstatic void nntp_edata_free(void **ptr)\n{\n  // struct NntpEmailData *edata = *ptr;\n  FREE(ptr);\n}\n\n/**\n * nntp_edata_new - Create a new NntpEmailData for an Email\n * @retval ptr New NntpEmailData struct\n */\nstatic struct NntpEmailData *nntp_edata_new(void)\n{\n  return mutt_mem_calloc(1, sizeof(struct NntpEmailData));\n}\n\n/**\n * nntp_edata_get - Get the private data for this Email\n * @param e Email\n * @retval ptr Private Email data\n */\nstruct NntpEmailData *nntp_edata_get(struct Email *e)\n{\n  if (!e)\n    return NULL;\n  return e->edata;\n}\n\n/**\n * nntp_connect_error - Signal a failed connection\n * @param adata NNTP server\n * @retval -1 Always\n */\nstatic int nntp_connect_error(struct NntpAccountData *adata)\n{\n  adata->status = NNTP_NONE;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}\n\n/**\n * nntp_capabilities - Get capabilities\n * @param adata NNTP server\n * @retval -1 Error, connection is closed\n * @retval  0 Mode is reader, capabilities set up\n * @retval  1 Need to switch to reader mode\n */\nstatic int nntp_capabilities(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  bool mode_reader = false;\n  char buf[1024];\n  char authinfo[1024] = { 0 };\n\n  adata->hasCAPABILITIES = false;\n  adata->hasSTARTTLS = false;\n  adata->hasDATE = false;\n  adata->hasLIST_NEWSGROUPS = false;\n  adata->hasLISTGROUP = false;\n  adata->hasLISTGROUPrange = false;\n  adata->hasOVER = false;\n  FREE(&adata->authenticators);\n\n  if ((mutt_socket_send(conn, \"CAPABILITIES\\r\\n\") < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n  {\n    return nntp_connect_error(adata);\n  }\n\n  /* no capabilities */\n  if (!mutt_str_startswith(buf, \"101\", CASE_MATCH))\n    return 1;\n  adata->hasCAPABILITIES = true;\n\n  /* parse capabilities */\n  do\n  {\n    size_t plen = 0;\n    if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n      return nntp_connect_error(adata);\n    if (mutt_str_strcmp(\"STARTTLS\", buf) == 0)\n      adata->hasSTARTTLS = true;\n    else if (mutt_str_strcmp(\"MODE-READER\", buf) == 0)\n      mode_reader = true;\n    else if (mutt_str_strcmp(\"READER\", buf) == 0)\n    {\n      adata->hasDATE = true;\n      adata->hasLISTGROUP = true;\n      adata->hasLISTGROUPrange = true;\n    }\n    else if ((plen = mutt_str_startswith(buf, \"AUTHINFO \", CASE_MATCH)))\n    {\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n      mutt_str_strfcpy(authinfo, buf + plen - 1, sizeof(authinfo));\n    }\n#ifdef USE_SASL\n    else if ((plen = mutt_str_startswith(buf, \"SASL \", CASE_MATCH)))\n    {\n      char *p = buf + plen;\n      while (*p == ' ')\n        p++;\n      adata->authenticators = mutt_str_strdup(p);\n    }\n#endif\n    else if (mutt_str_strcmp(\"OVER\", buf) == 0)\n      adata->hasOVER = true;\n    else if (mutt_str_startswith(buf, \"LIST \", CASE_MATCH))\n    {\n      char *p = strstr(buf, \" NEWSGROUPS\");\n      if (p)\n      {\n        p += 11;\n        if ((*p == '\\0') || (*p == ' '))\n          adata->hasLIST_NEWSGROUPS = true;\n      }\n    }\n  } while (mutt_str_strcmp(\".\", buf) != 0);\n  *buf = '\\0';\n#ifdef USE_SASL\n  if (adata->authenticators && strcasestr(authinfo, \" SASL \"))\n    mutt_str_strfcpy(buf, adata->authenticators, sizeof(buf));\n#endif\n  if (strcasestr(authinfo, \" USER \"))\n  {\n    if (*buf != '\\0')\n      mutt_str_strcat(buf, sizeof(buf), \" \");\n    mutt_str_strcat(buf, sizeof(buf), \"USER\");\n  }\n  mutt_str_replace(&adata->authenticators, buf);\n\n  /* current mode is reader */\n  if (adata->hasDATE)\n    return 0;\n\n  /* server is mode-switching, need to switch to reader mode */\n  if (mode_reader)\n    return 1;\n\n  mutt_socket_close(conn);\n  adata->status = NNTP_BYE;\n  mutt_error(_(\"Server doesn't support reader mode\"));\n  return -1;\n}\n\n/**\n * nntp_attempt_features - Detect supported commands\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_attempt_features(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[1024];\n\n  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */\n  if (!adata->hasCAPABILITIES)\n  {\n    if ((mutt_socket_send(conn, \"DATE\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasDATE = true;\n\n    if ((mutt_socket_send(conn, \"LISTGROUP\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasLISTGROUP = true;\n\n    if ((mutt_socket_send(conn, \"LIST NEWSGROUPS +\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasLIST_NEWSGROUPS = true;\n    if (mutt_str_startswith(buf, \"215\", CASE_MATCH))\n    {\n      do\n      {\n        if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n          return nntp_connect_error(adata);\n      } while (mutt_str_strcmp(\".\", buf) != 0);\n    }\n  }\n\n  /* no LIST NEWSGROUPS, trying XGTITLE */\n  if (!adata->hasLIST_NEWSGROUPS)\n  {\n    if ((mutt_socket_send(conn, \"XGTITLE\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasXGTITLE = true;\n  }\n\n  /* no OVER, trying XOVER */\n  if (!adata->hasOVER)\n  {\n    if ((mutt_socket_send(conn, \"XOVER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n      adata->hasXOVER = true;\n  }\n\n  /* trying LIST OVERVIEW.FMT */\n  if (adata->hasOVER || adata->hasXOVER)\n  {\n    if ((mutt_socket_send(conn, \"LIST OVERVIEW.FMT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"215\", CASE_MATCH))\n      adata->overview_fmt = mutt_str_strdup(OverviewFmt);\n    else\n    {\n      bool cont = false;\n      size_t buflen = 2048, off = 0, b = 0;\n\n      FREE(&adata->overview_fmt);\n      adata->overview_fmt = mutt_mem_malloc(buflen);\n\n      while (true)\n      {\n        if ((buflen - off) < 1024)\n        {\n          buflen *= 2;\n          mutt_mem_realloc(&adata->overview_fmt, buflen);\n        }\n\n        const int chunk = mutt_socket_readln_d(adata->overview_fmt + off,\n                                               buflen - off, conn, MUTT_SOCK_LOG_HDR);\n        if (chunk < 0)\n        {\n          FREE(&adata->overview_fmt);\n          return nntp_connect_error(adata);\n        }\n\n        if (!cont && (mutt_str_strcmp(\".\", adata->overview_fmt + off) == 0))\n          break;\n\n        cont = (chunk >= (buflen - off));\n        off += strlen(adata->overview_fmt + off);\n        if (!cont)\n        {\n          if (adata->overview_fmt[b] == ':')\n          {\n            memmove(adata->overview_fmt + b, adata->overview_fmt + b + 1, off - b - 1);\n            adata->overview_fmt[off - 1] = ':';\n          }\n          char *colon = strchr(adata->overview_fmt + b, ':');\n          if (!colon)\n            adata->overview_fmt[off++] = ':';\n          else if (strcmp(colon + 1, \"full\") != 0)\n            off = colon + 1 - adata->overview_fmt;\n          if (strcasecmp(adata->overview_fmt + b, \"Bytes:\") == 0)\n          {\n            size_t len = strlen(adata->overview_fmt + b);\n            mutt_str_strfcpy(adata->overview_fmt + b, \"Content-Length:\", len + 1);\n            off = b + len;\n          }\n          adata->overview_fmt[off++] = '\\0';\n          b = off;\n        }\n      }\n      adata->overview_fmt[off++] = '\\0';\n      mutt_mem_realloc(&adata->overview_fmt, off);\n    }\n  }\n  return 0;\n}\n\n#ifdef USE_SASL\n/**\n * nntp_memchr - look for a char in a binary buf, conveniently\n * @param haystack [in/out] input: start here, output: store address of hit\n * @param sentinel points just beyond (1 byte after) search area\n * @param needle the character to search for\n * @retval true found and updated haystack\n * @retval false not found\n */\nstatic bool nntp_memchr(char **haystack, char *sentinel, int needle)\n{\n  char *start = *haystack;\n  size_t max_offset = sentinel - start;\n  void *vp = memchr(start, max_offset, needle);\n  if (!vp)\n    return false;\n  *haystack = vp;\n  return true;\n}\n\n/**\n * nntp_log_binbuf - log a buffer possibly containing NUL bytes\n * @param buf source buffer\n * @param len how many bytes from buf\n * @param pfx logging prefix (protocol etc.)\n * @param dbg which loglevel does message belong\n */\nstatic void nntp_log_binbuf(const char *buf, size_t len, const char *pfx, int dbg)\n{\n  char tmp[1024];\n  char *p = tmp;\n  char *sentinel = tmp + len;\n\n  if (C_DebugLevel < dbg)\n    return;\n  memcpy(tmp, buf, len);\n  tmp[len] = '\\0';\n  while (nntp_memchr(&p, sentinel, '\\0'))\n    *p = '.';\n  mutt_debug(dbg, \"%s> %s\\n\", pfx, tmp);\n}\n#endif\n\n/**\n * nntp_auth - Get login, password and authenticate\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_auth(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[1024];\n  char authenticators[1024] = \"USER\";\n  char *method = NULL, *a = NULL, *p = NULL;\n  unsigned char flags = conn->account.flags;\n\n  while (true)\n  {\n    /* get login and password */\n    if ((mutt_account_getuser(&conn->account) < 0) || (conn->account.user[0] == '\\0') ||\n        (mutt_account_getpass(&conn->account) < 0) || (conn->account.pass[0] == '\\0'))\n    {\n      break;\n    }\n\n    /* get list of authenticators */\n    if (C_NntpAuthenticators)\n      mutt_str_strfcpy(authenticators, C_NntpAuthenticators, sizeof(authenticators));\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_str_strfcpy(authenticators, adata->authenticators, sizeof(authenticators));\n      p = authenticators;\n      while (*p)\n      {\n        if (*p == ' ')\n          *p = ':';\n        p++;\n      }\n    }\n    p = authenticators;\n    while (*p)\n    {\n      *p = toupper(*p);\n      p++;\n    }\n\n    mutt_debug(LL_DEBUG1, \"available methods: %s\\n\", adata->authenticators);\n    a = authenticators;\n    while (true)\n    {\n      if (!a)\n      {\n        mutt_error(_(\"No authenticators available\"));\n        break;\n      }\n\n      method = a;\n      a = strchr(a, ':');\n      if (a)\n        *a++ = '\\0';\n\n      /* check authenticator */\n      if (adata->hasCAPABILITIES)\n      {\n        char *m = NULL;\n\n        if (!adata->authenticators)\n          continue;\n        m = strcasestr(adata->authenticators, method);\n        if (!m)\n          continue;\n        if ((m > adata->authenticators) && (*(m - 1) != ' '))\n          continue;\n        m += strlen(method);\n        if ((*m != '\\0') && (*m != ' '))\n          continue;\n      }\n      mutt_debug(LL_DEBUG1, \"trying method %s\\n\", method);\n\n      /* AUTHINFO USER authentication */\n      if (strcmp(method, \"USER\") == 0)\n      {\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO USER %s\\r\\n\", conn->account.user);\n        if ((mutt_socket_send(conn, buf) < 0) ||\n            (mutt_socket_readln_d(buf, sizeof(buf), conn, MUTT_SOCK_LOG_FULL) < 0))\n        {\n          break;\n        }\n\n        /* authenticated, password is not required */\n        if (mutt_str_startswith(buf, \"281\", CASE_MATCH))\n          return 0;\n\n        /* username accepted, sending password */\n        if (mutt_str_startswith(buf, \"381\", CASE_MATCH))\n        {\n          mutt_debug(MUTT_SOCK_LOG_FULL, \"%d> AUTHINFO PASS *\\n\", conn->fd);\n          snprintf(buf, sizeof(buf), \"AUTHINFO PASS %s\\r\\n\", conn->account.pass);\n          if ((mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0) ||\n              (mutt_socket_readln_d(buf, sizeof(buf), conn, MUTT_SOCK_LOG_FULL) < 0))\n          {\n            break;\n          }\n\n          /* authenticated */\n          if (mutt_str_startswith(buf, \"281\", CASE_MATCH))\n            return 0;\n        }\n\n        /* server doesn't support AUTHINFO USER, trying next method */\n        if (*buf == '5')\n          continue;\n      }\n      else\n      {\n#ifdef USE_SASL\n        sasl_conn_t *saslconn = NULL;\n        sasl_interact_t *interaction = NULL;\n        int rc;\n        char inbuf[1024] = { 0 };\n        const char *mech = NULL;\n        const char *client_out = NULL;\n        unsigned int client_len, len;\n\n        if (mutt_sasl_client_new(conn, &saslconn) < 0)\n        {\n          mutt_debug(LL_DEBUG1, \"error allocating SASL connection\\n\");\n          continue;\n        }\n\n        while (true)\n        {\n          rc = sasl_client_start(saslconn, method, &interaction, &client_out,\n                                 &client_len, &mech);\n          if (rc != SASL_INTERACT)\n            break;\n          mutt_sasl_interact(interaction);\n        }\n        if ((rc != SASL_OK) && (rc != SASL_CONTINUE))\n        {\n          sasl_dispose(&saslconn);\n          mutt_debug(LL_DEBUG1,\n                     \"error starting SASL authentication exchange\\n\");\n          continue;\n        }\n\n        mutt_message(_(\"Authenticating (%s)...\"), method);\n        snprintf(buf, sizeof(buf), \"AUTHINFO SASL %s\", method);\n\n        /* looping protocol */\n        while ((rc == SASL_CONTINUE) || ((rc == SASL_OK) && client_len))\n        {\n          /* send out client response */\n          if (client_len)\n          {\n            nntp_log_binbuf(client_out, client_len, \"SASL\", MUTT_SOCK_LOG_FULL);\n            if (*buf != '\\0')\n              mutt_str_strcat(buf, sizeof(buf), \" \");\n            len = strlen(buf);\n            if (sasl_encode64(client_out, client_len, buf + len,\n                              sizeof(buf) - len, &len) != SASL_OK)\n            {\n              mutt_debug(LL_DEBUG1, \"error base64-encoding client response\\n\");\n              break;\n            }\n          }\n\n          mutt_str_strcat(buf, sizeof(buf), \"\\r\\n\");\n          if (strchr(buf, ' '))\n          {\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> AUTHINFO SASL %s%s\\n\", conn->fd,\n                       method, client_len ? \" sasl_data\" : \"\");\n          }\n          else\n            mutt_debug(MUTT_SOCK_LOG_CMD, \"%d> sasl_data\\n\", conn->fd);\n          client_len = 0;\n          if ((mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) < 0) ||\n              (mutt_socket_readln_d(inbuf, sizeof(inbuf), conn, MUTT_SOCK_LOG_FULL) < 0))\n          {\n            break;\n          }\n          if (!mutt_str_startswith(inbuf, \"283 \", CASE_MATCH) &&\n              !mutt_str_startswith(inbuf, \"383 \", CASE_MATCH))\n          {\n            mutt_debug(MUTT_SOCK_LOG_FULL, \"%d< %s\\n\", conn->fd, inbuf);\n            break;\n          }\n          inbuf[3] = '\\0';\n          mutt_debug(MUTT_SOCK_LOG_FULL, \"%d< %s sasl_data\\n\", conn->fd, inbuf);\n\n          if (strcmp(\"=\", inbuf + 4) == 0)\n            len = 0;\n          else if (sasl_decode64(inbuf + 4, strlen(inbuf + 4), buf,\n                                 sizeof(buf) - 1, &len) != SASL_OK)\n          {\n            mutt_debug(LL_DEBUG1, \"error base64-decoding server response\\n\");\n            break;\n          }\n          else\n            nntp_log_binbuf(buf, len, \"SASL\", MUTT_SOCK_LOG_FULL);\n\n          while (true)\n          {\n            rc = sasl_client_step(saslconn, buf, len, &interaction, &client_out, &client_len);\n            if (rc != SASL_INTERACT)\n              break;\n            mutt_sasl_interact(interaction);\n          }\n          if (*inbuf != '3')\n            break;\n\n          *buf = '\\0';\n        } /* looping protocol */\n\n        if ((rc == SASL_OK) && (client_len == 0) && (*inbuf == '2'))\n        {\n          mutt_sasl_setup_conn(conn, saslconn);\n          return 0;\n        }\n\n        /* terminate SASL session */\n        sasl_dispose(&saslconn);\n        if (conn->fd < 0)\n          break;\n        if (mutt_str_startswith(inbuf, \"383 \", CASE_MATCH))\n        {\n          if ((mutt_socket_send(conn, \"*\\r\\n\") < 0) ||\n              (mutt_socket_readln(inbuf, sizeof(inbuf), conn) < 0))\n          {\n            break;\n          }\n        }\n\n        /* server doesn't support AUTHINFO SASL, trying next method */\n        if (*inbuf == '5')\n          continue;\n#else\n        continue;\n#endif /* USE_SASL */\n      }\n\n      mutt_error(_(\"%s authentication failed\"), method);\n      break;\n    }\n    break;\n  }\n\n  /* error */\n  adata->status = NNTP_BYE;\n  conn->account.flags = flags;\n  if (conn->fd < 0)\n  {\n    mutt_error(_(\"Server closed connection\"));\n  }\n  else\n    mutt_socket_close(conn);\n  return -1;\n}\n\n/**\n * nntp_query - Send data from buffer and receive answer to same buffer\n * @param mdata NNTP Mailbox data\n * @param line      Buffer containing data\n * @param linelen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_query(struct NntpMboxData *mdata, char *line, size_t linelen)\n{\n  struct NntpAccountData *adata = mdata->adata;\n  char buf[1024] = { 0 };\n\n  if (adata->status == NNTP_BYE)\n    return -1;\n\n  while (true)\n  {\n    if (adata->status == NNTP_OK)\n    {\n      int rc = 0;\n\n      if (*line)\n        rc = mutt_socket_send(adata->conn, line);\n      else if (mdata->group)\n      {\n        snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", mdata->group);\n        rc = mutt_socket_send(adata->conn, buf);\n      }\n      if (rc >= 0)\n        rc = mutt_socket_readln(buf, sizeof(buf), adata->conn);\n      if (rc >= 0)\n        break;\n    }\n\n    /* reconnect */\n    while (true)\n    {\n      adata->status = NNTP_NONE;\n      if (nntp_open_connection(adata) == 0)\n        break;\n\n      snprintf(buf, sizeof(buf), _(\"Connection to %s lost. Reconnect?\"),\n               adata->conn->account.host);\n      if (mutt_yesorno(buf, MUTT_YES) != MUTT_YES)\n      {\n        adata->status = NNTP_BYE;\n        return -1;\n      }\n    }\n\n    /* select newsgroup after reconnection */\n    if (mdata->group)\n    {\n      snprintf(buf, sizeof(buf), \"GROUP %s\\r\\n\", mdata->group);\n      if ((mutt_socket_send(adata->conn, buf) < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), adata->conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n    }\n    if (*line == '\\0')\n      break;\n  }\n\n  mutt_str_strfcpy(line, buf, linelen);\n  return 0;\n}\n\n/**\n * nntp_fetch_lines - Read lines, calling a callback function for each\n * @param mdata NNTP Mailbox data\n * @param query     Query to match\n * @param qlen      Length of query\n * @param msg       Progress message (OPTIONAL)\n * @param func      Callback function\n * @param data      Data for callback function\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error in func(*line, *data)\n *\n * This function calls func(*line, *data) for each received line,\n * func(NULL, *data) if rewind(*data) needs, exits when fail or done:\n */\nstatic int nntp_fetch_lines(struct NntpMboxData *mdata, char *query, size_t qlen,\n                            const char *msg, int (*func)(char *, void *), void *data)\n{\n  bool done = false;\n  int rc;\n\n  while (!done)\n  {\n    char buf[1024];\n    char *line = NULL;\n    unsigned int lines = 0;\n    size_t off = 0;\n    struct Progress progress;\n\n    if (msg)\n      mutt_progress_init(&progress, msg, MUTT_PROGRESS_READ, 0);\n\n    mutt_str_strfcpy(buf, query, sizeof(buf));\n    if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n      return -1;\n    if (buf[0] != '2')\n    {\n      mutt_str_strfcpy(query, buf, qlen);\n      return 1;\n    }\n\n    line = mutt_mem_malloc(sizeof(buf));\n    rc = 0;\n\n    while (true)\n    {\n      char *p = NULL;\n      int chunk = mutt_socket_readln_d(buf, sizeof(buf), mdata->adata->conn, MUTT_SOCK_LOG_FULL);\n      if (chunk < 0)\n      {\n        mdata->adata->status = NNTP_NONE;\n        break;\n      }\n\n      p = buf;\n      if (!off && (buf[0] == '.'))\n      {\n        if (buf[1] == '\\0')\n        {\n          done = true;\n          break;\n        }\n        if (buf[1] == '.')\n          p++;\n      }\n\n      mutt_str_strfcpy(line + off, p, sizeof(buf));\n\n      if (chunk >= sizeof(buf))\n        off += strlen(p);\n      else\n      {\n        if (msg)\n          mutt_progress_update(&progress, ++lines, -1);\n\n        if ((rc == 0) && (func(line, data) < 0))\n          rc = -2;\n        off = 0;\n      }\n\n      mutt_mem_realloc(&line, off + sizeof(buf));\n    }\n    FREE(&line);\n    func(NULL, data);\n  }\n  return rc;\n}\n\n/**\n * fetch_description - Parse newsgroup description\n * @param line String to parse\n * @param data NNTP Server\n * @retval 0 Always\n */\nstatic int fetch_description(char *line, void *data)\n{\n  if (!line)\n    return 0;\n\n  struct NntpAccountData *adata = data;\n\n  char *desc = strpbrk(line, \" \\t\");\n  if (desc)\n  {\n    *desc++ = '\\0';\n    desc += strspn(desc, \" \\t\");\n  }\n  else\n    desc = strchr(line, '\\0');\n\n  struct NntpMboxData *mdata = mutt_hash_find(adata->groups_hash, line);\n  if (mdata && (mutt_str_strcmp(desc, mdata->desc) != 0))\n  {\n    mutt_str_replace(&mdata->desc, desc);\n    mutt_debug(LL_DEBUG2, \"group: %s, desc: %s\\n\", line, desc);\n  }\n  return 0;\n}\n\n/**\n * get_description - Fetch newsgroups descriptions\n * @param mdata NNTP Mailbox data\n * @param wildmat   String to match\n * @param msg       Progress message\n * @retval  0 Success\n * @retval  1 Bad response (answer in query buffer)\n * @retval -1 Connection lost\n * @retval -2 Error\n */\nstatic int get_description(struct NntpMboxData *mdata, const char *wildmat, const char *msg)\n{\n  char buf[256];\n  const char *cmd = NULL;\n\n  /* get newsgroup description, if possible */\n  struct NntpAccountData *adata = mdata->adata;\n  if (!wildmat)\n    wildmat = mdata->group;\n  if (adata->hasLIST_NEWSGROUPS)\n    cmd = \"LIST NEWSGROUPS\";\n  else if (adata->hasXGTITLE)\n    cmd = \"XGTITLE\";\n  else\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", cmd, wildmat);\n  int rc = nntp_fetch_lines(mdata, buf, sizeof(buf), msg, fetch_description, adata);\n  if (rc > 0)\n  {\n    mutt_error(\"%s: %s\", cmd, buf);\n  }\n  return rc;\n}\n\n/**\n * nntp_parse_xref - Parse cross-reference\n * @param m Mailbox\n * @param e Email\n *\n * Update read flag and set article number if empty\n */\nstatic void nntp_parse_xref(struct Mailbox *m, struct Email *e)\n{\n  struct NntpMboxData *mdata = m->mdata;\n\n  char *buf = mutt_str_strdup(e->env->xref);\n  char *p = buf;\n  while (p)\n  {\n    anum_t anum;\n\n    /* skip to next word */\n    p += strspn(p, \" \\t\");\n    char *grp = p;\n\n    /* skip to end of word */\n    p = strpbrk(p, \" \\t\");\n    if (p)\n      *p++ = '\\0';\n\n    /* find colon */\n    char *colon = strchr(grp, ':');\n    if (!colon)\n      continue;\n    *colon++ = '\\0';\n    if (sscanf(colon, ANUM, &anum) != 1)\n      continue;\n\n    nntp_article_status(m, e, grp, anum);\n    if (!nntp_edata_get(e)->article_num && (mutt_str_strcmp(mdata->group, grp) == 0))\n      nntp_edata_get(e)->article_num = anum;\n  }\n  FREE(&buf);\n}\n\n/**\n * fetch_tempfile - Write line to temporary file\n * @param line Text to write\n * @param data FILE pointer\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_tempfile(char *line, void *data)\n{\n  FILE *fp = data;\n\n  if (!line)\n    rewind(fp);\n  else if ((fputs(line, fp) == EOF) || (fputc('\\n', fp) == EOF))\n    return -1;\n  return 0;\n}\n\n/**\n * fetch_numbers - Parse article number\n * @param line Article number\n * @param data FetchCtx\n * @retval 0 Always\n */\nstatic int fetch_numbers(char *line, void *data)\n{\n  struct FetchCtx *fc = data;\n  anum_t anum;\n\n  if (!line)\n    return 0;\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  if ((anum < fc->first) || (anum > fc->last))\n    return 0;\n  fc->messages[anum - fc->first] = 1;\n  return 0;\n}\n\n/**\n * parse_overview_line - Parse overview line\n * @param line String to parse\n * @param data FetchCtx\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int parse_overview_line(char *line, void *data)\n{\n  if (!line || !data)\n    return 0;\n\n  struct FetchCtx *fc = data;\n  struct Mailbox *m = fc->mailbox;\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct Email *e = NULL;\n  char *header = NULL, *field = NULL;\n  bool save = true;\n  anum_t anum;\n\n  /* parse article number */\n  field = strchr(line, '\\t');\n  if (field)\n    *field++ = '\\0';\n  if (sscanf(line, ANUM, &anum) != 1)\n    return 0;\n  mutt_debug(LL_DEBUG2, \"\" ANUM \"\\n\", anum);\n\n  /* out of bounds */\n  if ((anum < fc->first) || (anum > fc->last))\n    return 0;\n\n  /* not in LISTGROUP */\n  if (!fc->messages[anum - fc->first])\n  {\n    /* progress */\n    if (m->verbose)\n      mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n    return 0;\n  }\n\n  /* convert overview line to header */\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n    return -1;\n\n  header = mdata->adata->overview_fmt;\n  while (field)\n  {\n    char *b = field;\n\n    if (*header)\n    {\n      if (!strstr(header, \":full\") && (fputs(header, fp) == EOF))\n      {\n        mutt_file_fclose(&fp);\n        return -1;\n      }\n      header = strchr(header, '\\0') + 1;\n    }\n\n    field = strchr(field, '\\t');\n    if (field)\n      *field++ = '\\0';\n    if ((fputs(b, fp) == EOF) || (fputc('\\n', fp) == EOF))\n    {\n      mutt_file_fclose(&fp);\n      return -1;\n    }\n  }\n  rewind(fp);\n\n  /* allocate memory for headers */\n  if (m->msg_count >= m->email_max)\n    mx_alloc_memory(m);\n\n  /* parse header */\n  m->emails[m->msg_count] = email_new();\n  e = m->emails[m->msg_count];\n  e->env = mutt_rfc822_read_header(fp, e, false, false);\n  e->env->newsgroups = mutt_str_strdup(mdata->group);\n  e->received = e->date_sent;\n  mutt_file_fclose(&fp);\n\n#ifdef USE_HCACHE\n  if (fc->hc)\n  {\n    char buf[16];\n\n    /* try to replace with header from cache */\n    snprintf(buf, sizeof(buf), \"%u\", anum);\n    struct HCacheEntry hce = mutt_hcache_fetch(fc->hc, buf, strlen(buf), 0);\n    if (hce.email)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_fetch %s\\n\", buf);\n      email_free(&e);\n      e = hce.email;\n      m->emails[m->msg_count] = e;\n      e->edata = NULL;\n      e->read = false;\n      e->old = false;\n\n      /* skip header marked as deleted in cache */\n      if (e->deleted && !fc->restore)\n      {\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        save = false;\n      }\n    }\n\n    /* not cached yet, store header */\n    else\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(fc->hc, buf, strlen(buf), e, 0);\n    }\n  }\n#endif\n\n  if (save)\n  {\n    e->index = m->msg_count++;\n    e->read = false;\n    e->old = false;\n    e->deleted = false;\n    e->edata = nntp_edata_new();\n    e->edata_free = nntp_edata_free;\n    nntp_edata_get(e)->article_num = anum;\n    if (fc->restore)\n      e->changed = true;\n    else\n    {\n      nntp_article_status(m, e, NULL, anum);\n      if (!e->read)\n        nntp_parse_xref(m, e);\n    }\n    if (anum > mdata->last_loaded)\n      mdata->last_loaded = anum;\n  }\n  else\n    email_free(&e);\n\n  /* progress */\n  if (m->verbose)\n    mutt_progress_update(&fc->progress, anum - fc->first + 1, -1);\n  return 0;\n}\n\n/**\n * nntp_fetch_headers - Fetch headers\n * @param m       Mailbox\n * @param hc      Header cache\n * @param first   Number of first header to fetch\n * @param last    Number of last header to fetch\n * @param restore Restore message listed as deleted\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_fetch_headers(struct Mailbox *m, void *hc, anum_t first, anum_t last, bool restore)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct FetchCtx fc;\n  struct Email *e = NULL;\n  char buf[8192];\n  int rc = 0;\n  anum_t current;\n  anum_t first_over = first;\n\n  /* if empty group or nothing to do */\n  if (!last || (first > last))\n    return 0;\n\n  /* init fetch context */\n  fc.mailbox = m;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (!fc.messages)\n    return -1;\n  fc.hc = hc;\n\n  /* fetch list of articles */\n  if (C_NntpListgroup && mdata->adata->hasLISTGROUP && !mdata->deleted)\n  {\n    if (m->verbose)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (mdata->adata->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", mdata->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", mdata->group);\n    rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(LL_DEBUG2, \"mutt_hcache_delete_header %s\\n\", buf);\n          mutt_hcache_delete_header(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (m->verbose)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_READ, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (m->verbose)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (m->msg_count >= m->email_max)\n      mx_alloc_memory(m);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    struct HCacheEntry hce = mutt_hcache_fetch(fc.hc, buf, strlen(buf), 0);\n    if (hce.email)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_fetch %s\\n\", buf);\n      e = hce.email;\n      m->emails[m->msg_count] = e;\n      e->edata = NULL;\n\n      /* skip header marked as deleted in cache */\n      if (e->deleted && !restore)\n      {\n        email_free(&e);\n        if (mdata->bcache)\n        {\n          mutt_debug(LL_DEBUG2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        continue;\n      }\n\n      e->read = false;\n      e->old = false;\n    }\n    else\n#endif\n        if (mdata->deleted)\n    {\n      /* don't try to fetch header from removed newsgroup */\n      continue;\n    }\n\n    /* fallback to fetch overview */\n    else if (mdata->adata->hasOVER || mdata->adata->hasXOVER)\n    {\n      if (C_NntpListgroup && mdata->adata->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(_(\"Can't create temporary file\"));\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (!mutt_str_startswith(buf, \"423\", CASE_MATCH))\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (mdata->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(LL_DEBUG2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(mdata->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      m->emails[m->msg_count] = email_new();\n      e = m->emails[m->msg_count];\n      e->env = mutt_rfc822_read_header(fp, e, false, false);\n      e->received = e->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    e->index = m->msg_count++;\n    e->read = false;\n    e->old = false;\n    e->deleted = false;\n    e->edata = nntp_edata_new();\n    e->edata_free = nntp_edata_free;\n    nntp_edata_get(e)->article_num = current;\n    if (restore)\n      e->changed = true;\n    else\n    {\n      nntp_article_status(m, e, NULL, nntp_edata_get(e)->article_num);\n      if (!e->read)\n        nntp_parse_xref(m, e);\n    }\n    if (current > mdata->last_loaded)\n      mdata->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!C_NntpListgroup || !mdata->adata->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if ((current <= last) && (rc == 0) && !mdata->deleted)\n  {\n    char *cmd = mdata->adata->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_group_poll - Check newsgroup for new articles\n * @param mdata NNTP Mailbox data\n * @param update_stat Update the stats?\n * @retval  1 New articles found\n * @retval  0 No change\n * @retval -1 Lost connection\n */\nstatic int nntp_group_poll(struct NntpMboxData *mdata, bool update_stat)\n{\n  char buf[1024] = { 0 };\n  anum_t count, first, last;\n\n  /* use GROUP command to poll newsgroup */\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n    return -1;\n  if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    return 0;\n  if ((first == mdata->first_message) && (last == mdata->last_message))\n    return 0;\n\n  /* articles have been renumbered */\n  if (last < mdata->last_message)\n  {\n    mdata->last_cached = 0;\n    if (mdata->newsrc_len)\n    {\n      mutt_mem_realloc(&mdata->newsrc_ent, sizeof(struct NewsrcEntry));\n      mdata->newsrc_len = 1;\n      mdata->newsrc_ent[0].first = 1;\n      mdata->newsrc_ent[0].last = 0;\n    }\n  }\n  mdata->first_message = first;\n  mdata->last_message = last;\n  if (!update_stat)\n    return 1;\n\n  /* update counters */\n  else if (!last || (!mdata->newsrc_ent && !mdata->last_cached))\n    mdata->unread = count;\n  else\n    nntp_group_unread_stat(mdata);\n  return 1;\n}\n\n/**\n * check_mailbox - Check current newsgroup for new articles\n * @param m Mailbox\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n *\n * Leave newsrc locked\n */\nstatic int check_mailbox(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct NntpAccountData *adata = mdata->adata;\n  time_t now = mutt_date_epoch();\n  int rc = 0;\n  void *hc = NULL;\n\n  if (adata->check_time + C_NntpPoll > now)\n    return 0;\n\n  mutt_message(_(\"Checking for new messages...\"));\n  if (nntp_newsrc_parse(adata) < 0)\n    return -1;\n\n  adata->check_time = now;\n  int rc2 = nntp_group_poll(mdata, false);\n  if (rc2 < 0)\n  {\n    nntp_newsrc_close(adata);\n    return -1;\n  }\n  if (rc2 != 0)\n    nntp_active_save_cache(adata);\n\n  /* articles have been renumbered, remove all headers */\n  if (mdata->last_message < mdata->last_loaded)\n  {\n    for (int i = 0; i < m->msg_count; i++)\n      email_free(&m->emails[i]);\n    m->msg_count = 0;\n    m->msg_tagged = 0;\n\n    if (mdata->last_message < mdata->last_loaded)\n    {\n      mdata->last_loaded = mdata->first_message - 1;\n      if (C_NntpContext && (mdata->last_message - mdata->last_loaded > C_NntpContext))\n        mdata->last_loaded = mdata->last_message - C_NntpContext;\n    }\n    rc = MUTT_REOPENED;\n  }\n\n  /* .newsrc has been externally modified */\n  if (adata->newsrc_modified)\n  {\n#ifdef USE_HCACHE\n    unsigned char *messages = NULL;\n    char buf[16];\n    struct Email *e = NULL;\n    anum_t first = mdata->first_message;\n\n    if (C_NntpContext && (mdata->last_message - first + 1 > C_NntpContext))\n      first = mdata->last_message - C_NntpContext + 1;\n    messages = mutt_mem_calloc(mdata->last_loaded - first + 1, sizeof(unsigned char));\n    hc = nntp_hcache_open(mdata);\n    nntp_hcache_update(mdata, hc);\n#endif\n\n    /* update flags according to .newsrc */\n    int j = 0;\n    for (int i = 0; i < m->msg_count; i++)\n    {\n      if (!m->emails[i])\n        continue;\n      bool flagged = false;\n      anum_t anum = nntp_edata_get(m->emails[i])->article_num;\n\n#ifdef USE_HCACHE\n      /* check hcache for flagged and deleted flags */\n      if (hc)\n      {\n        if ((anum >= first) && (anum <= mdata->last_loaded))\n          messages[anum - first] = 1;\n\n        snprintf(buf, sizeof(buf), \"%u\", anum);\n        struct HCacheEntry hce = mutt_hcache_fetch(hc, buf, strlen(buf), 0);\n        if (hce.email)\n        {\n          bool deleted;\n\n          mutt_debug(LL_DEBUG2, \"#1 mutt_hcache_fetch %s\\n\", buf);\n          e = hce.email;\n          e->edata = NULL;\n          deleted = e->deleted;\n          flagged = e->flagged;\n          email_free(&e);\n\n          /* header marked as deleted, removing from context */\n          if (deleted)\n          {\n            mutt_set_flag(m, m->emails[i], MUTT_TAG, false);\n            email_free(&m->emails[i]);\n            continue;\n          }\n        }\n      }\n#endif\n\n      if (!m->emails[i]->changed)\n      {\n        m->emails[i]->flagged = flagged;\n        m->emails[i]->read = false;\n        m->emails[i]->old = false;\n        nntp_article_status(m, m->emails[i], NULL, anum);\n        if (!m->emails[i]->read)\n          nntp_parse_xref(m, m->emails[i]);\n      }\n      m->emails[j++] = m->emails[i];\n    }\n\n#ifdef USE_HCACHE\n    m->msg_count = j;\n\n    /* restore headers without \"deleted\" flag */\n    for (anum_t anum = first; anum <= mdata->last_loaded; anum++)\n    {\n      if (messages[anum - first])\n        continue;\n\n      snprintf(buf, sizeof(buf), \"%u\", anum);\n      struct HCacheEntry hce = mutt_hcache_fetch(hc, buf, strlen(buf), 0);\n      if (hce.email)\n      {\n        mutt_debug(LL_DEBUG2, \"#2 mutt_hcache_fetch %s\\n\", buf);\n        if (m->msg_count >= m->email_max)\n          mx_alloc_memory(m);\n\n        e = hce.email;\n        m->emails[m->msg_count] = e;\n        e->edata = NULL;\n        if (e->deleted)\n        {\n          email_free(&e);\n          if (mdata->bcache)\n          {\n            mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n            mutt_bcache_del(mdata->bcache, buf);\n          }\n          continue;\n        }\n\n        m->msg_count++;\n        e->read = false;\n        e->old = false;\n        e->edata = nntp_edata_new();\n        e->edata_free = nntp_edata_free;\n        nntp_edata_get(e)->article_num = anum;\n        nntp_article_status(m, e, NULL, anum);\n        if (!e->read)\n          nntp_parse_xref(m, e);\n      }\n    }\n    FREE(&messages);\n#endif\n\n    adata->newsrc_modified = false;\n    rc = MUTT_REOPENED;\n  }\n\n  /* some headers were removed, context must be updated */\n  if (rc == MUTT_REOPENED)\n    mailbox_changed(m, NT_MAILBOX_INVALID);\n\n  /* fetch headers of new articles */\n  if (mdata->last_message > mdata->last_loaded)\n  {\n    int oldmsgcount = m->msg_count;\n    bool verbose = m->verbose;\n    m->verbose = false;\n#ifdef USE_HCACHE\n    if (!hc)\n    {\n      hc = nntp_hcache_open(mdata);\n      nntp_hcache_update(mdata, hc);\n    }\n#endif\n    int old_msg_count = m->msg_count;\n    rc2 = nntp_fetch_headers(m, hc, mdata->last_loaded + 1, mdata->last_message, false);\n    m->verbose = verbose;\n    if (rc2 == 0)\n    {\n      if (m->msg_count > old_msg_count)\n        mailbox_changed(m, NT_MAILBOX_INVALID);\n      mdata->last_loaded = mdata->last_message;\n    }\n    if ((rc == 0) && (m->msg_count > oldmsgcount))\n      rc = MUTT_NEW_MAIL;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc)\n    nntp_newsrc_close(adata);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_date - Get date and time from server\n * @param adata NNTP server\n * @param now   Server time\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int nntp_date(struct NntpAccountData *adata, time_t *now)\n{\n  if (adata->hasDATE)\n  {\n    struct NntpMboxData mdata = { 0 };\n    char buf[1024];\n    struct tm tm = { 0 };\n\n    mdata.adata = adata;\n    mdata.group = NULL;\n    mutt_str_strfcpy(buf, \"DATE\\r\\n\", sizeof(buf));\n    if (nntp_query(&mdata, buf, sizeof(buf)) < 0)\n      return -1;\n\n    if (sscanf(buf, \"111 %4d%2d%2d%2d%2d%2d%*s\", &tm.tm_year, &tm.tm_mon,\n               &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)\n    {\n      tm.tm_year -= 1900;\n      tm.tm_mon--;\n      *now = timegm(&tm);\n      if (*now >= 0)\n      {\n        mutt_debug(LL_DEBUG1, \"server time is %lu\\n\", *now);\n        return 0;\n      }\n    }\n  }\n  *now = mutt_date_epoch();\n  return 0;\n}\n\n/**\n * fetch_children - Parse XPAT line\n * @param line String to parse\n * @param data ChildCtx\n * @retval 0 Always\n */\nstatic int fetch_children(char *line, void *data)\n{\n  struct ChildCtx *cc = data;\n  anum_t anum;\n\n  if (!line || (sscanf(line, ANUM, &anum) != 1))\n    return 0;\n  for (unsigned int i = 0; i < cc->mailbox->msg_count; i++)\n  {\n    struct Email *e = cc->mailbox->emails[i];\n    if (!e)\n      break;\n    if (nntp_edata_get(e)->article_num == anum)\n      return 0;\n  }\n  if (cc->num >= cc->max)\n  {\n    cc->max *= 2;\n    mutt_mem_realloc(&cc->child, sizeof(anum_t) * cc->max);\n  }\n  cc->child[cc->num++] = anum;\n  return 0;\n}\n\n/**\n * nntp_open_connection - Connect to server, authenticate and get capabilities\n * @param adata NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_open_connection(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[256];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (adata->status == NNTP_OK)\n    return 0;\n  if (adata->status == NNTP_BYE)\n    return -1;\n  adata->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(adata);\n\n  if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n    posting = true;\n  else if (!mutt_str_startswith(buf, \"201\", CASE_MATCH))\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(adata);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if ((mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n\n    if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n      posting = true;\n    else if (mutt_str_startswith(buf, \"201\", CASE_MATCH))\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (adata->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(adata);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))\n  {\n    if (adata->use_tls == 0)\n    {\n      adata->use_tls =\n          C_SslForceTls || query_quadoption(C_SslStarttls,\n                                            _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (adata->use_tls == 2)\n    {\n      if ((mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n      // Clear any data after the STARTTLS acknowledgement\n      mutt_socket_empty(conn);\n      if (!mutt_str_startswith(buf, \"382\", CASE_MATCH))\n      {\n        adata->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        adata->use_tls = 0;\n        adata->status = NNTP_NONE;\n        mutt_socket_close(adata->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(adata);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if ((mutt_socket_send(conn, \"STAT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"480\", CASE_MATCH))\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && (nntp_auth(adata) < 0))\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (adata->hasCAPABILITIES && (auth || (cap > 0)))\n  {\n    cap = nntp_capabilities(adata);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(adata) < 0)\n    return -1;\n\n  adata->status = NNTP_OK;\n  return 0;\n}\n\n/**\n * nntp_post - Post article\n * @param m   Mailbox\n * @param msg Message to post\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_post(struct Mailbox *m, const char *msg)\n{\n  struct NntpMboxData *mdata = NULL;\n  struct NntpMboxData tmp_mdata = { 0 };\n  char buf[1024];\n\n  if (m && (m->type == MUTT_NNTP))\n    mdata = m->mdata;\n  else\n  {\n    CurrentNewsSrv = nntp_select_server(m, C_NewsServer, false);\n    if (!CurrentNewsSrv)\n      return -1;\n\n    mdata = &tmp_mdata;\n    mdata->adata = CurrentNewsSrv;\n    mdata->group = NULL;\n  }\n\n  FILE *fp = mutt_file_fopen(msg, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg);\n    return -1;\n  }\n\n  mutt_str_strfcpy(buf, \"POST\\r\\n\", sizeof(buf));\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  if (buf[0] != '3')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n\n  buf[0] = '.';\n  buf[1] = '\\0';\n  while (fgets(buf + 1, sizeof(buf) - 2, fp))\n  {\n    size_t len = strlen(buf);\n    if (buf[len - 1] == '\\n')\n    {\n      buf[len - 1] = '\\r';\n      buf[len] = '\\n';\n      len++;\n      buf[len] = '\\0';\n    }\n    if (mutt_socket_send_d(mdata->adata->conn, (buf[1] == '.') ? buf : buf + 1,\n                           MUTT_SOCK_LOG_FULL) < 0)\n    {\n      mutt_file_fclose(&fp);\n      return nntp_connect_error(mdata->adata);\n    }\n  }\n  mutt_file_fclose(&fp);\n\n  if (((buf[strlen(buf) - 1] != '\\n') &&\n       (mutt_socket_send_d(mdata->adata->conn, \"\\r\\n\", MUTT_SOCK_LOG_FULL) < 0)) ||\n      (mutt_socket_send_d(mdata->adata->conn, \".\\r\\n\", MUTT_SOCK_LOG_FULL) < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), mdata->adata->conn) < 0))\n  {\n    return nntp_connect_error(mdata->adata);\n  }\n  if (buf[0] != '2')\n  {\n    mutt_error(_(\"Can't post article: %s\"), buf);\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * nntp_active_fetch - Fetch list of all newsgroups from server\n * @param adata    NNTP server\n * @param mark_new Mark the groups as new\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_fetch(struct NntpAccountData *adata, bool mark_new)\n{\n  struct NntpMboxData tmp_mdata = { 0 };\n  char msg[256];\n  char buf[1024];\n  unsigned int i;\n  int rc;\n\n  snprintf(msg, sizeof(msg), _(\"Loading list of groups from server %s...\"),\n           adata->conn->account.host);\n  mutt_message(msg);\n  if (nntp_date(adata, &adata->newgroups_time) < 0)\n    return -1;\n\n  tmp_mdata.adata = adata;\n  tmp_mdata.group = NULL;\n  i = adata->groups_num;\n  mutt_str_strfcpy(buf, \"LIST\\r\\n\", sizeof(buf));\n  rc = nntp_fetch_lines(&tmp_mdata, buf, sizeof(buf), msg, nntp_add_group, adata);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"LIST: %s\", buf);\n    }\n    return -1;\n  }\n\n  if (mark_new)\n  {\n    for (; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n      mdata->has_new_mail = true;\n    }\n  }\n\n  for (i = 0; i < adata->groups_num; i++)\n  {\n    struct NntpMboxData *mdata = adata->groups_list[i];\n\n    if (mdata && mdata->deleted && !mdata->newsrc_ent)\n    {\n      nntp_delete_group_cache(mdata);\n      mutt_hash_delete(adata->groups_hash, mdata->group, NULL);\n      adata->groups_list[i] = NULL;\n    }\n  }\n\n  if (C_NntpLoadDescription)\n    rc = get_description(&tmp_mdata, \"*\", _(\"Loading descriptions...\"));\n\n  nntp_active_save_cache(adata);\n  if (rc < 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_check_new_groups - Check for new groups/articles in subscribed groups\n * @param m     Mailbox\n * @param adata NNTP server\n * @retval  1 New groups found\n * @retval  0 No new groups\n * @retval -1 Error\n */\nint nntp_check_new_groups(struct Mailbox *m, struct NntpAccountData *adata)\n{\n  struct NntpMboxData tmp_mdata = { 0 };\n  time_t now;\n  char buf[1024];\n  char *msg = _(\"Checking for new newsgroups...\");\n  unsigned int i;\n  int rc, update_active = false;\n\n  if (!adata || !adata->newgroups_time)\n    return -1;\n\n  /* check subscribed newsgroups for new articles */\n  if (C_ShowNewNews)\n  {\n    mutt_message(_(\"Checking for new messages...\"));\n    for (i = 0; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n\n      if (mdata && mdata->subscribed)\n      {\n        rc = nntp_group_poll(mdata, true);\n        if (rc < 0)\n          return -1;\n        if (rc > 0)\n          update_active = true;\n      }\n    }\n  }\n  else if (adata->newgroups_time)\n    return 0;\n\n  /* get list of new groups */\n  mutt_message(msg);\n  if (nntp_date(adata, &now) < 0)\n    return -1;\n  tmp_mdata.adata = adata;\n  if (m && m->mdata)\n    tmp_mdata.group = ((struct NntpMboxData *) m->mdata)->group;\n  else\n    tmp_mdata.group = NULL;\n  i = adata->groups_num;\n  struct tm tm = mutt_date_gmtime(adata->newgroups_time);\n  snprintf(buf, sizeof(buf), \"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\\r\\n\",\n           tm.tm_year % 100, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n  rc = nntp_fetch_lines(&tmp_mdata, buf, sizeof(buf), msg, nntp_add_group, adata);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"NEWGROUPS: %s\", buf);\n    }\n    return -1;\n  }\n\n  /* new groups found */\n  rc = 0;\n  if (adata->groups_num != i)\n  {\n    int groups_num = i;\n\n    adata->newgroups_time = now;\n    for (; i < adata->groups_num; i++)\n    {\n      struct NntpMboxData *mdata = adata->groups_list[i];\n      mdata->has_new_mail = true;\n    }\n\n    /* loading descriptions */\n    if (C_NntpLoadDescription)\n    {\n      unsigned int count = 0;\n      struct Progress progress;\n\n      mutt_progress_init(&progress, _(\"Loading descriptions...\"),\n                         MUTT_PROGRESS_READ, adata->groups_num - i);\n      for (i = groups_num; i < adata->groups_num; i++)\n      {\n        struct NntpMboxData *mdata = adata->groups_list[i];\n\n        if (get_description(mdata, NULL, NULL) < 0)\n          return -1;\n        mutt_progress_update(&progress, ++count, -1);\n      }\n    }\n    update_active = true;\n    rc = 1;\n  }\n  if (update_active)\n    nntp_active_save_cache(adata);\n  mutt_clear_error();\n  return rc;\n}\n\n/**\n * nntp_check_msgid - Fetch article by Message-ID\n * @param m     Mailbox\n * @param msgid Message ID\n * @retval  0 Success\n * @retval  1 No such article\n * @retval -1 Error\n */\nint nntp_check_msgid(struct Mailbox *m, const char *msgid)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  char buf[1024];\n\n  FILE *fp = mutt_file_mkstemp();\n  if (!fp)\n  {\n    mutt_perror(_(\"Can't create temporary file\"));\n    return -1;\n  }\n\n  snprintf(buf, sizeof(buf), \"HEAD %s\\r\\n\", msgid);\n  int rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n  if (rc)\n  {\n    mutt_file_fclose(&fp);\n    if (rc < 0)\n      return -1;\n    if (mutt_str_startswith(buf, \"430\", CASE_MATCH))\n      return 1;\n    mutt_error(\"HEAD: %s\", buf);\n    return -1;\n  }\n\n  /* parse header */\n  if (m->msg_count == m->email_max)\n    mx_alloc_memory(m);\n  m->emails[m->msg_count] = email_new();\n  struct Email *e = m->emails[m->msg_count];\n  e->edata = nntp_edata_new();\n  e->edata_free = nntp_edata_free;\n  e->env = mutt_rfc822_read_header(fp, e, false, false);\n  mutt_file_fclose(&fp);\n\n  /* get article number */\n  if (e->env->xref)\n    nntp_parse_xref(m, e);\n  else\n  {\n    snprintf(buf, sizeof(buf), \"STAT %s\\r\\n\", msgid);\n    if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n    {\n      email_free(&e);\n      return -1;\n    }\n    sscanf(buf + 4, ANUM, &nntp_edata_get(e)->article_num);\n  }\n\n  /* reset flags */\n  e->read = false;\n  e->old = false;\n  e->deleted = false;\n  e->changed = true;\n  e->received = e->date_sent;\n  e->index = m->msg_count++;\n  mailbox_changed(m, NT_MAILBOX_INVALID);\n  return 0;\n}\n\n/**\n * nntp_check_children - Fetch children of article with the Message-ID\n * @param m     Mailbox\n * @param msgid Message ID to find\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_check_children(struct Mailbox *m, const char *msgid)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct ChildCtx cc;\n  char buf[256];\n  int rc;\n  void *hc = NULL;\n\n  if (!mdata || !mdata->adata)\n    return -1;\n  if (mdata->first_message > mdata->last_loaded)\n    return 0;\n\n  /* init context */\n  cc.mailbox = m;\n  cc.num = 0;\n  cc.max = 10;\n  cc.child = mutt_mem_malloc(sizeof(anum_t) * cc.max);\n\n  /* fetch numbers of child messages */\n  snprintf(buf, sizeof(buf), \"XPAT References %u-%u *%s*\\r\\n\",\n           mdata->first_message, mdata->last_loaded, msgid);\n  rc = nntp_fetch_lines(mdata, buf, sizeof(buf), NULL, fetch_children, &cc);\n  if (rc)\n  {\n    FREE(&cc.child);\n    if (rc > 0)\n    {\n      if (!mutt_str_startswith(buf, \"500\", CASE_MATCH))\n        mutt_error(\"XPAT: %s\", buf);\n      else\n      {\n        mutt_error(_(\"Unable to find child articles because server does not \"\n                     \"support XPAT command\"));\n      }\n    }\n    return -1;\n  }\n\n  /* fetch all found messages */\n  bool verbose = m->verbose;\n  m->verbose = false;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(mdata);\n#endif\n  int old_msg_count = m->msg_count;\n  for (int i = 0; i < cc.num; i++)\n  {\n    rc = nntp_fetch_headers(m, hc, cc.child[i], cc.child[i], true);\n    if (rc < 0)\n      break;\n  }\n  if (m->msg_count > old_msg_count)\n    mailbox_changed(m, NT_MAILBOX_INVALID);\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  m->verbose = verbose;\n  FREE(&cc.child);\n  return (rc < 0) ? -1 : 0;\n}\n\n/**\n * nntp_compare_order - Sort to mailbox order - Implements ::sort_t\n */\nint nntp_compare_order(const void *a, const void *b)\n{\n  const struct Email *ea = *(struct Email const *const *) a;\n  const struct Email *eb = *(struct Email const *const *) b;\n\n  anum_t na = nntp_edata_get((struct Email *) ea)->article_num;\n  anum_t nb = nntp_edata_get((struct Email *) eb)->article_num;\n  int result = (na == nb) ? 0 : (na > nb) ? 1 : -1;\n  result = perform_auxsort(result, a, b);\n  return SORT_CODE(result);\n}\n\n/**\n * nntp_ac_find - Find an Account that matches a Mailbox path - Implements MxOps::ac_find()\n */\nstatic struct Account *nntp_ac_find(struct Account *a, const char *path)\n{\n#if 0\n  if (!a || (a->type != MUTT_NNTP) || !path)\n    return NULL;\n\n  struct Url url = { 0 };\n  char tmp[PATH_MAX];\n  mutt_str_strfcpy(tmp, path, sizeof(tmp));\n  url_parse(&url, tmp);\n\n  struct ImapAccountData *adata = a->data;\n  struct ConnAccount *cac = &adata->conn_account;\n\n  if (mutt_str_strcasecmp(url.host, cac->host) != 0)\n    return NULL;\n\n  if (mutt_str_strcasecmp(url.user, cac->user) != 0)\n    return NULL;\n\n  // if (mutt_str_strcmp(path, a->mailbox->realpath) == 0)\n  //   return a;\n#endif\n  return a;\n}\n\n/**\n * nntp_ac_add - Add a Mailbox to an Account - Implements MxOps::ac_add()\n */\nstatic int nntp_ac_add(struct Account *a, struct Mailbox *m)\n{\n  if (!a || !m || (m->type != MUTT_NNTP))\n    return -1;\n  return 0;\n}\n\n/**\n * nntp_mbox_open - Open a Mailbox - Implements MxOps::mbox_open()\n */\nstatic int nntp_mbox_open(struct Mailbox *m)\n{\n  if (!m || !m->account)\n    return -1;\n\n  char buf[8192];\n  char server[1024];\n  char *group = NULL;\n  int rc;\n  void *hc = NULL;\n  anum_t first, last, count = 0;\n\n  struct Url *url = url_parse(mailbox_path(m));\n  if (!url || !url->host || !url->path ||\n      !((url->scheme == U_NNTP) || (url->scheme == U_NNTPS)))\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid newsgroup specification\"), mailbox_path(m));\n    return -1;\n  }\n\n  group = url->path;\n  if (group[0] == '/') /* Skip a leading '/' */\n    group++;\n\n  url->path = strchr(url->path, '\\0');\n  url_tostring(url, server, sizeof(server), 0);\n\n  mutt_account_hook(m->realpath);\n  struct NntpAccountData *adata = m->account->adata;\n  if (!adata)\n  {\n    adata = nntp_select_server(m, server, true);\n    m->account->adata = adata;\n    m->account->adata_free = nntp_adata_free;\n  }\n\n  if (!adata)\n  {\n    url_free(&url);\n    return -1;\n  }\n  CurrentNewsSrv = adata;\n\n  m->msg_count = 0;\n  m->msg_unread = 0;\n  m->vcount = 0;\n\n  if (group[0] == '/')\n    group++;\n\n  /* find news group data structure */\n  struct NntpMboxData *mdata = mutt_hash_find(adata->groups_hash, group);\n  if (!mdata)\n  {\n    nntp_newsrc_close(adata);\n    mutt_error(_(\"Newsgroup %s not found on the server\"), group);\n    url_free(&url);\n    return -1;\n  }\n\n  m->rights &= ~MUTT_ACL_INSERT; // Clear the flag\n  if (!mdata->newsrc_ent && !mdata->subscribed && !C_SaveUnsubscribed)\n    m->readonly = true;\n\n  /* select newsgroup */\n  mutt_message(_(\"Selecting %s...\"), group);\n  url_free(&url);\n  buf[0] = '\\0';\n  if (nntp_query(mdata, buf, sizeof(buf)) < 0)\n  {\n    nntp_newsrc_close(adata);\n    return -1;\n  }\n\n  /* newsgroup not found, remove it */\n  if (mutt_str_startswith(buf, \"411\", CASE_MATCH))\n  {\n    mutt_error(_(\"Newsgroup %s has been removed from the server\"), mdata->group);\n    if (!mdata->deleted)\n    {\n      mdata->deleted = true;\n      nntp_active_save_cache(adata);\n    }\n    if (mdata->newsrc_ent && !mdata->subscribed && !C_SaveUnsubscribed)\n    {\n      FREE(&mdata->newsrc_ent);\n      mdata->newsrc_len = 0;\n      nntp_delete_group_cache(mdata);\n      nntp_newsrc_update(adata);\n    }\n  }\n\n  /* parse newsgroup info */\n  else\n  {\n    if (sscanf(buf, \"211 \" ANUM \" \" ANUM \" \" ANUM, &count, &first, &last) != 3)\n    {\n      nntp_newsrc_close(adata);\n      mutt_error(\"GROUP: %s\", buf);\n      return -1;\n    }\n    mdata->first_message = first;\n    mdata->last_message = last;\n    mdata->deleted = false;\n\n    /* get description if empty */\n    if (C_NntpLoadDescription && !mdata->desc)\n    {\n      if (get_description(mdata, NULL, NULL) < 0)\n      {\n        nntp_newsrc_close(adata);\n        return -1;\n      }\n      if (mdata->desc)\n        nntp_active_save_cache(adata);\n    }\n  }\n\n  adata->check_time = mutt_date_epoch();\n  m->mdata = mdata;\n  // Every known newsgroup has an mdata which is stored in adata->groups_list.\n  // Currently we don't let the Mailbox free the mdata.\n  // m->mdata_free = nntp_mdata_free;\n  if (!mdata->bcache && (mdata->newsrc_ent || mdata->subscribed || C_SaveUnsubscribed))\n    mdata->bcache = mutt_bcache_open(&adata->conn->account, mdata->group);\n\n  /* strip off extra articles if adding context is greater than $nntp_context */\n  first = mdata->first_message;\n  if (C_NntpContext && (mdata->last_message - first + 1 > C_NntpContext))\n    first = mdata->last_message - C_NntpContext + 1;\n  mdata->last_loaded = first ? first - 1 : 0;\n  count = mdata->first_message;\n  mdata->first_message = first;\n  nntp_bcache_update(mdata);\n  mdata->first_message = count;\n#ifdef USE_HCACHE\n  hc = nntp_hcache_open(mdata);\n  nntp_hcache_update(mdata, hc);\n#endif\n  if (!hc)\n    m->rights &= ~(MUTT_ACL_WRITE | MUTT_ACL_DELETE); // Clear the flags\n\n  nntp_newsrc_close(adata);\n  rc = nntp_fetch_headers(m, hc, first, mdata->last_message, false);\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (rc < 0)\n    return -1;\n  mdata->last_loaded = mdata->last_message;\n  adata->newsrc_modified = false;\n  return 0;\n}\n\n/**\n * nntp_mbox_check - Check for new mail - Implements MxOps::mbox_check()\n * @param m          Mailbox\n * @param index_hint Current message (UNUSED)\n * @retval #MUTT_REOPENED Articles have been renumbered or removed from server\n * @retval #MUTT_NEW_MAIL New articles found\n * @retval  0             No change\n * @retval -1             Lost connection\n */\nstatic int nntp_mbox_check(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  int rc = check_mailbox(m);\n  if (rc == 0)\n  {\n    struct NntpMboxData *mdata = m->mdata;\n    struct NntpAccountData *adata = mdata->adata;\n    nntp_newsrc_close(adata);\n  }\n  return rc;\n}\n\n/**\n * nntp_mbox_sync - Save changes to the Mailbox - Implements MxOps::mbox_sync()\n *\n * @note May also return values from check_mailbox()\n */\nstatic int nntp_mbox_sync(struct Mailbox *m, int *index_hint)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  int rc;\n\n  /* check for new articles */\n  mdata->adata->check_time = 0;\n  rc = check_mailbox(m);\n  if (rc)\n    return rc;\n\n#ifdef USE_HCACHE\n  mdata->last_cached = 0;\n  header_cache_t *hc = nntp_hcache_open(mdata);\n#endif\n\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct Email *e = m->emails[i];\n    if (!e)\n      break;\n\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), ANUM, nntp_edata_get(e)->article_num);\n    if (mdata->bcache && e->deleted)\n    {\n      mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);\n      mutt_bcache_del(mdata->bcache, buf);\n    }\n\n#ifdef USE_HCACHE\n    if (hc && (e->changed || e->deleted))\n    {\n      if (e->deleted && !e->read)\n        mdata->unread--;\n      mutt_debug(LL_DEBUG2, \"mutt_hcache_store %s\\n\", buf);\n      mutt_hcache_store(hc, buf, strlen(buf), e, 0);\n    }\n#endif\n  }\n\n#ifdef USE_HCACHE\n  if (hc)\n  {\n    mutt_hcache_close(hc);\n    mdata->last_cached = mdata->last_loaded;\n  }\n#endif\n\n  /* save .newsrc entries */\n  nntp_newsrc_gen_entries(m);\n  nntp_newsrc_update(mdata->adata);\n  nntp_newsrc_close(mdata->adata);\n  return 0;\n}\n\n/**\n * nntp_mbox_close - Close a Mailbox - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int nntp_mbox_close(struct Mailbox *m)\n{\n  if (!m)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct NntpMboxData *tmp_mdata = NULL;\n  if (!mdata)\n    return 0;\n\n  mdata->unread = m->msg_unread;\n\n  nntp_acache_free(mdata);\n  if (!mdata->adata || !mdata->adata->groups_hash || !mdata->group)\n    return 0;\n\n  tmp_mdata = mutt_hash_find(mdata->adata->groups_hash, mdata->group);\n  if (!tmp_mdata || (tmp_mdata != mdata))\n    nntp_mdata_free((void **) &mdata);\n  return 0;\n}\n\n/**\n * nntp_msg_open - Open an email message in a Mailbox - Implements MxOps::msg_open()\n */\nstatic int nntp_msg_open(struct Mailbox *m, struct Message *msg, int msgno)\n{\n  if (!m || !m->emails || (msgno >= m->msg_count) || !msg)\n    return -1;\n\n  struct NntpMboxData *mdata = m->mdata;\n  struct Email *e = m->emails[msgno];\n  if (!e)\n    return -1;\n\n  char article[16];\n\n  /* try to get article from cache */\n  struct NntpAcache *acache = &mdata->acache[e->index % NNTP_ACACHE_LEN];\n  if (acache->path)\n  {\n    if (acache->index == e->index)\n    {\n      msg->fp = mutt_file_fopen(acache->path, \"r\");\n      if (msg->fp)\n        return 0;\n    }\n    /* clear previous entry */\n    else\n    {\n      unlink(acache->path);\n      FREE(&acache->path);\n    }\n  }\n  snprintf(article, sizeof(article), ANUM, nntp_edata_get(e)->article_num);\n  msg->fp = mutt_bcache_get(mdata->bcache, article);\n  if (msg->fp)\n  {\n    if (nntp_edata_get(e)->parsed)\n      return 0;\n  }\n  else\n  {\n    char buf[PATH_MAX];\n    /* don't try to fetch article from removed newsgroup */\n    if (mdata->deleted)\n      return -1;\n\n    /* create new cache file */\n    const char *fetch_msg = _(\"Fetching message...\");\n    mutt_message(fetch_msg);\n    msg->fp = mutt_bcache_put(mdata->bcache, article);\n    if (!msg->fp)\n    {\n      mutt_mktemp(buf, sizeof(buf));\n      acache->path = mutt_str_strdup(buf);\n      acache->index = e->index;\n      msg->fp = mutt_file_fopen(acache->path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(acache->path);\n        unlink(acache->path);\n        FREE(&acache->path);\n        return -1;\n      }\n    }\n\n    /* fetch message to cache file */\n    snprintf(buf, sizeof(buf), \"ARTICLE %s\\r\\n\",\n             nntp_edata_get(e)->article_num ? article : e->env->message_id);\n    const int rc =\n        nntp_fetch_lines(mdata, buf, sizeof(buf), fetch_msg, fetch_tempfile, msg->fp);\n    if (rc)\n    {\n      mutt_file_fclose(&msg->fp);\n      if (acache->path)\n      {\n        unlink(acache->path);\n        FREE(&acache->path);\n      }\n      if (rc > 0)\n      {\n        if (mutt_str_startswith(buf, nntp_edata_get(e)->article_num ? \"423\" : \"430\", CASE_MATCH))\n        {\n          mutt_error(_(\"Article %s not found on the server\"),\n                     nntp_edata_get(e)->article_num ? article : e->env->message_id);\n        }\n        else\n          mutt_error(\"ARTICLE: %s\", buf);\n      }\n      return -1;\n    }\n\n    if (!acache->path)\n      mutt_bcache_commit(mdata->bcache, article);\n  }\n\n  /* replace envelope with new one\n   * hash elements must be updated because pointers will be changed */\n  if (m->id_hash && e->env->message_id)\n    mutt_hash_delete(m->id_hash, e->env->message_id, e);\n  if (m->subj_hash && e->env->real_subj)\n    mutt_hash_delete(m->subj_hash, e->env->real_subj, e);\n\n  mutt_env_free(&e->env);\n  e->env = mutt_rfc822_read_header(msg->fp, e, false, false);\n\n  if (m->id_hash && e->env->message_id)\n    mutt_hash_insert(m->id_hash, e->env->message_id, e);\n  if (m->subj_hash && e->env->real_subj)\n    mutt_hash_insert(m->subj_hash, e->env->real_subj, e);\n\n  /* fix content length */\n  fseek(msg->fp, 0, SEEK_END);\n  e->content->length = ftell(msg->fp) - e->content->offset;\n\n  /* this is called in neomutt before the open which fetches the message,\n   * which is probably wrong, but we just call it again here to handle\n   * the problem instead of fixing it */\n  nntp_edata_get(e)->parsed = true;\n  mutt_parse_mime_message(m, e);\n\n  /* these would normally be updated in ctx_update(), but the\n   * full headers aren't parsed with overview, so the information wasn't\n   * available then */\n  if (WithCrypto)\n    e->security = crypt_query(e->content);\n\n  rewind(msg->fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_msg_close - Close an email - Implements MxOps::msg_close()\n *\n * @note May also return EOF Failure, see errno\n */\nstatic int nntp_msg_close(struct Mailbox *m, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * nntp_path_probe - Is this an NNTP Mailbox? - Implements MxOps::path_probe()\n */\nenum MailboxType nntp_path_probe(const char *path, const struct stat *st)\n{\n  if (!path)\n    return MUTT_UNKNOWN;\n\n  if (mutt_str_startswith(path, \"news://\", CASE_IGNORE))\n    return MUTT_NNTP;\n\n  if (mutt_str_startswith(path, \"snews://\", CASE_IGNORE))\n    return MUTT_NNTP;\n\n  return MUTT_UNKNOWN;\n}\n\n/**\n * nntp_path_canon - Canonicalise a Mailbox path - Implements MxOps::path_canon()\n */\nstatic int nntp_path_canon(char *buf, size_t buflen)\n{\n  if (!buf)\n    return -1;\n\n  return 0;\n}\n\n/**\n * nntp_path_pretty - Abbreviate a Mailbox path - Implements MxOps::path_pretty()\n */\nstatic int nntp_path_pretty(char *buf, size_t buflen, const char *folder)\n{\n  /* Succeed, but don't do anything, for now */\n  return 0;\n}\n\n/**\n * nntp_path_parent - Find the parent of a Mailbox path - Implements MxOps::path_parent()\n */\nstatic int nntp_path_parent(char *buf, size_t buflen)\n{\n  /* Succeed, but don't do anything, for now */\n  return 0;\n}\n\n// clang-format off\n/**\n * MxNntpOps - NNTP Mailbox - Implements ::MxOps\n */\nstruct MxOps MxNntpOps = {\n  .type            = MUTT_NNTP,\n  .name             = \"nntp\",\n  .is_local         = false,\n  .ac_find          = nntp_ac_find,\n  .ac_add           = nntp_ac_add,\n  .mbox_open        = nntp_mbox_open,\n  .mbox_open_append = NULL,\n  .mbox_check       = nntp_mbox_check,\n  .mbox_check_stats = NULL,\n  .mbox_sync        = nntp_mbox_sync,\n  .mbox_close       = nntp_mbox_close,\n  .msg_open         = nntp_msg_open,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = nntp_msg_close,\n  .msg_padding_size = NULL,\n  .msg_save_hcache  = NULL,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n  .path_probe       = nntp_path_probe,\n  .path_canon       = nntp_path_canon,\n  .path_pretty      = nntp_path_pretty,\n  .path_parent      = nntp_path_parent,\n};\n// clang-format on\n", "/**\n * @file\n * POP helper routines\n *\n * @authors\n * Copyright (C) 2000-2003 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop_lib POP helper routines\n *\n * POP helper routines\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"init.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"progress.h\"\n#ifdef USE_SSL\n#include \"globals.h\"\n#endif\n\n/* These Config Variables are only used in pop/pop_lib.c */\nchar *C_PopOauthRefreshCommand; ///< Config: (pop) External command to generate OAUTH refresh token\nchar *C_PopPass; ///< Config: (pop) Password of the POP server\nunsigned char C_PopReconnect; ///< Config: (pop) Reconnect to the server is the connection is lost\nchar *C_PopUser; ///< Config: (pop) Username of the POP server\n\n/**\n * pop_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nconst char *pop_get_field(enum ConnAccountField field)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n    case MUTT_CA_USER:\n      return C_PopUser;\n    case MUTT_CA_PASS:\n      return C_PopPass;\n    case MUTT_CA_OAUTH_CMD:\n      return C_PopOauthRefreshCommand;\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n/**\n * pop_parse_path - Parse a POP mailbox name\n * @param path Path to parse\n * @param cac  Account to store details\n * @retval 0 success\n * @retval -1 error\n *\n * Split a POP path into host, port, username and password\n */\nint pop_parse_path(const char *path, struct ConnAccount *cac)\n{\n  /* Defaults */\n  cac->flags = 0;\n  cac->type = MUTT_ACCT_TYPE_POP;\n  cac->port = 0;\n  cac->service = \"pop\";\n  cac->get_field = pop_get_field;\n\n  struct Url *url = url_parse(path);\n\n  if (!url || ((url->scheme != U_POP) && (url->scheme != U_POPS)) ||\n      !url->host || (mutt_account_fromurl(cac, url) < 0))\n  {\n    url_free(&url);\n    mutt_error(_(\"Invalid POP URL: %s\"), path);\n    return -1;\n  }\n\n  if (url->scheme == U_POPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  struct servent *service =\n      getservbyname((url->scheme == U_POP) ? \"pop3\" : \"pop3s\", \"tcp\");\n  if (cac->port == 0)\n  {\n    if (service)\n      cac->port = ntohs(service->s_port);\n    else\n      cac->port = (url->scheme == U_POP) ? POP_PORT : POP_SSL_PORT;\n  }\n\n  url_free(&url);\n  return 0;\n}\n\n/**\n * pop_error - Copy error message to err_msg buffer\n * @param adata POP Account data\n * @param msg   Error message to save\n */\nstatic void pop_error(struct PopAccountData *adata, char *msg)\n{\n  char *t = strchr(adata->err_msg, '\\0');\n  char *c = msg;\n\n  size_t plen = mutt_str_startswith(msg, \"-ERR \", CASE_MATCH);\n  if (plen != 0)\n  {\n    char *c2 = mutt_str_skip_email_wsp(msg + plen);\n\n    if (*c2)\n      c = c2;\n  }\n\n  mutt_str_strfcpy(t, c, sizeof(adata->err_msg) - strlen(adata->err_msg));\n  mutt_str_remove_trailing_ws(adata->err_msg);\n}\n\n/**\n * fetch_capa - Parse CAPA output - Implements ::pop_fetch_t\n * @param line List of capabilities\n * @param data POP data\n * @retval 0 (always)\n */\nstatic int fetch_capa(const char *line, void *data)\n{\n  struct PopAccountData *adata = data;\n\n  if (mutt_str_startswith(line, \"SASL\", CASE_IGNORE))\n  {\n    const char *c = mutt_str_skip_email_wsp(line + 4);\n    mutt_buffer_strcpy(&adata->auth_list, c);\n  }\n  else if (mutt_str_startswith(line, \"STLS\", CASE_IGNORE))\n    adata->cmd_stls = true;\n  else if (mutt_str_startswith(line, \"USER\", CASE_IGNORE))\n    adata->cmd_user = 1;\n  else if (mutt_str_startswith(line, \"UIDL\", CASE_IGNORE))\n    adata->cmd_uidl = 1;\n  else if (mutt_str_startswith(line, \"TOP\", CASE_IGNORE))\n    adata->cmd_top = 1;\n\n  return 0;\n}\n\n/**\n * fetch_auth - Fetch list of the authentication mechanisms - Implements ::pop_fetch_t\n * @param line List of authentication methods\n * @param data POP data\n * @retval 0 (always)\n */\nstatic int fetch_auth(const char *line, void *data)\n{\n  struct PopAccountData *adata = data;\n\n  if (!mutt_buffer_is_empty(&adata->auth_list))\n  {\n    mutt_buffer_addstr(&adata->auth_list, \" \");\n  }\n  mutt_buffer_addstr(&adata->auth_list, line);\n\n  return 0;\n}\n\n/**\n * pop_capabilities - Get capabilities from a POP server\n * @param adata POP Account data\n * @param mode  Initial capabilities\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Execution error\n */\nstatic int pop_capabilities(struct PopAccountData *adata, int mode)\n{\n  char buf[1024];\n\n  /* don't check capabilities on reconnect */\n  if (adata->capabilities)\n    return 0;\n\n  /* init capabilities */\n  if (mode == 0)\n  {\n    adata->cmd_capa = false;\n    adata->cmd_stls = false;\n    adata->cmd_user = 0;\n    adata->cmd_uidl = 0;\n    adata->cmd_top = 0;\n    adata->resp_codes = false;\n    adata->expire = true;\n    adata->login_delay = 0;\n    mutt_buffer_init(&adata->auth_list);\n  }\n\n  /* Execute CAPA command */\n  if ((mode == 0) || adata->cmd_capa)\n  {\n    mutt_str_strfcpy(buf, \"CAPA\\r\\n\", sizeof(buf));\n    switch (pop_fetch_data(adata, buf, NULL, fetch_capa, adata))\n    {\n      case 0:\n      {\n        adata->cmd_capa = true;\n        break;\n      }\n      case -1:\n        return -1;\n    }\n  }\n\n  /* CAPA not supported, use defaults */\n  if ((mode == 0) && !adata->cmd_capa)\n  {\n    adata->cmd_user = 2;\n    adata->cmd_uidl = 2;\n    adata->cmd_top = 2;\n\n    mutt_str_strfcpy(buf, \"AUTH\\r\\n\", sizeof(buf));\n    if (pop_fetch_data(adata, buf, NULL, fetch_auth, adata) == -1)\n      return -1;\n  }\n\n  /* Check capabilities */\n  if (mode == 2)\n  {\n    char *msg = NULL;\n\n    if (!adata->expire)\n      msg = _(\"Unable to leave messages on server\");\n    if (adata->cmd_top == 0)\n      msg = _(\"Command TOP is not supported by server\");\n    if (adata->cmd_uidl == 0)\n      msg = _(\"Command UIDL is not supported by server\");\n    if (msg && adata->cmd_capa)\n    {\n      mutt_error(msg);\n      return -2;\n    }\n    adata->capabilities = true;\n  }\n\n  return 0;\n}\n\n/**\n * pop_edata_get - Get the private data for this Email\n * @param e Email\n * @retval ptr Private Email data\n */\nstruct PopEmailData *pop_edata_get(struct Email *e)\n{\n  if (!e)\n    return NULL;\n  return e->edata;\n}\n\n/**\n * pop_connect - Open connection\n * @param adata POP Account data\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid response\n */\nint pop_connect(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  adata->status = POP_NONE;\n  if ((mutt_socket_open(adata->conn) < 0) ||\n      (mutt_socket_readln(buf, sizeof(buf), adata->conn) < 0))\n  {\n    mutt_error(_(\"Error connecting to server: %s\"), adata->conn->account.host);\n    return -1;\n  }\n\n  adata->status = POP_CONNECTED;\n\n  if (!mutt_str_startswith(buf, \"+OK\", CASE_MATCH))\n  {\n    *adata->err_msg = '\\0';\n    pop_error(adata, buf);\n    mutt_error(\"%s\", adata->err_msg);\n    return -2;\n  }\n\n  pop_apop_timestamp(adata, buf);\n\n  return 0;\n}\n\n/**\n * pop_open_connection - Open connection and authenticate\n * @param adata POP Account data\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Authentication cancelled\n */\nint pop_open_connection(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  int rc = pop_connect(adata);\n  if (rc < 0)\n    return rc;\n\n  rc = pop_capabilities(adata, 0);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n#ifdef USE_SSL\n  /* Attempt STLS if available and desired. */\n  if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))\n  {\n    if (C_SslForceTls)\n      adata->use_stls = 2;\n    if (adata->use_stls == 0)\n    {\n      enum QuadOption ans =\n          query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\"));\n      if (ans == MUTT_ABORT)\n        return -2;\n      adata->use_stls = 1;\n      if (ans == MUTT_YES)\n        adata->use_stls = 2;\n    }\n    if (adata->use_stls == 2)\n    {\n      mutt_str_strfcpy(buf, \"STLS\\r\\n\", sizeof(buf));\n      rc = pop_query(adata, buf, sizeof(buf));\n      // Clear any data after the STLS acknowledgement\n      mutt_socket_empty(adata->conn);\n      if (rc == -1)\n        goto err_conn;\n      if (rc != 0)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n      else if (mutt_ssl_starttls(adata->conn))\n      {\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -2;\n      }\n      else\n      {\n        /* recheck capabilities after STLS completes */\n        rc = pop_capabilities(adata, 1);\n        if (rc == -1)\n          goto err_conn;\n        if (rc == -2)\n          return -2;\n      }\n    }\n  }\n\n  if (C_SslForceTls && !adata->conn->ssf)\n  {\n    mutt_error(_(\"Encrypted connection unavailable\"));\n    return -2;\n  }\n#endif\n\n  rc = pop_authenticate(adata);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -3)\n    mutt_clear_error();\n  if (rc != 0)\n    return rc;\n\n  /* recheck capabilities after authentication */\n  rc = pop_capabilities(adata, 2);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n  /* get total size of mailbox */\n  mutt_str_strfcpy(buf, \"STAT\\r\\n\", sizeof(buf));\n  rc = pop_query(adata, buf, sizeof(buf));\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n  {\n    mutt_error(\"%s\", adata->err_msg);\n    return rc;\n  }\n\n  unsigned int n = 0, size = 0;\n  sscanf(buf, \"+OK %u %u\", &n, &size);\n  adata->size = size;\n  return 0;\n\nerr_conn:\n  adata->status = POP_DISCONNECTED;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}\n\n/**\n * pop_logout - logout from a POP server\n * @param m Mailbox\n */\nvoid pop_logout(struct Mailbox *m)\n{\n  struct PopAccountData *adata = pop_adata_get(m);\n\n  if (adata->status == POP_CONNECTED)\n  {\n    int ret = 0;\n    char buf[1024];\n    mutt_message(_(\"Closing connection to POP server...\"));\n\n    if (m->readonly)\n    {\n      mutt_str_strfcpy(buf, \"RSET\\r\\n\", sizeof(buf));\n      ret = pop_query(adata, buf, sizeof(buf));\n    }\n\n    if (ret != -1)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(adata, buf, sizeof(buf));\n    }\n\n    if (ret < 0)\n      mutt_debug(LL_DEBUG1, \"Error closing POP connection\\n\");\n\n    mutt_clear_error();\n  }\n\n  adata->status = POP_DISCONNECTED;\n}\n\n/**\n * pop_query_d - Send data from buffer and receive answer to the same buffer\n * @param adata  POP Account data\n * @param buf    Buffer to send/store data\n * @param buflen Buffer length\n * @param msg    Progress message\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n */\nint pop_query_d(struct PopAccountData *adata, char *buf, size_t buflen, char *msg)\n{\n  if (adata->status != POP_CONNECTED)\n    return -1;\n\n  /* print msg instead of real command */\n  if (msg)\n  {\n    mutt_debug(MUTT_SOCK_LOG_CMD, \"> %s\", msg);\n  }\n\n  mutt_socket_send_d(adata->conn, buf, MUTT_SOCK_LOG_FULL);\n\n  char *c = strpbrk(buf, \" \\r\\n\");\n  if (c)\n    *c = '\\0';\n  snprintf(adata->err_msg, sizeof(adata->err_msg), \"%s: \", buf);\n\n  if (mutt_socket_readln_d(buf, buflen, adata->conn, MUTT_SOCK_LOG_FULL) < 0)\n  {\n    adata->status = POP_DISCONNECTED;\n    return -1;\n  }\n  if (mutt_str_startswith(buf, \"+OK\", CASE_MATCH))\n    return 0;\n\n  pop_error(adata, buf);\n  return -2;\n}\n\n/**\n * pop_fetch_data - Read Headers with callback function\n * @param adata    POP Account data\n * @param query    POP query to send to server\n * @param progress Progress bar\n * @param callback Function called for each header read\n * @param data     Data to pass to the callback\n * @retval  0 Successful\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error in callback(*line, *data)\n *\n * This function calls  callback(*line, *data)  for each received line,\n * callback(NULL, *data)  if  rewind(*data)  needs, exits when fail or done.\n */\nint pop_fetch_data(struct PopAccountData *adata, const char *query,\n                   struct Progress *progress, pop_fetch_t callback, void *data)\n{\n  char buf[1024];\n  long pos = 0;\n  size_t lenbuf = 0;\n\n  mutt_str_strfcpy(buf, query, sizeof(buf));\n  int rc = pop_query(adata, buf, sizeof(buf));\n  if (rc < 0)\n    return rc;\n\n  char *inbuf = mutt_mem_malloc(sizeof(buf));\n\n  while (true)\n  {\n    const int chunk =\n        mutt_socket_readln_d(buf, sizeof(buf), adata->conn, MUTT_SOCK_LOG_FULL);\n    if (chunk < 0)\n    {\n      adata->status = POP_DISCONNECTED;\n      rc = -1;\n      break;\n    }\n\n    char *p = buf;\n    if (!lenbuf && (buf[0] == '.'))\n    {\n      if (buf[1] != '.')\n        break;\n      p++;\n    }\n\n    mutt_str_strfcpy(inbuf + lenbuf, p, sizeof(buf));\n    pos += chunk;\n\n    /* cast is safe since we break out of the loop when chunk<=0 */\n    if ((size_t) chunk >= sizeof(buf))\n    {\n      lenbuf += strlen(p);\n    }\n    else\n    {\n      if (progress)\n        mutt_progress_update(progress, pos, -1);\n      if ((rc == 0) && (callback(inbuf, data) < 0))\n        rc = -3;\n      lenbuf = 0;\n    }\n\n    mutt_mem_realloc(&inbuf, lenbuf + sizeof(buf));\n  }\n\n  FREE(&inbuf);\n  return rc;\n}\n\n/**\n * check_uidl - find message with this UIDL and set refno - Implements ::pop_fetch_t\n * @param line String containing UIDL\n * @param data POP data\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int check_uidl(const char *line, void *data)\n{\n  if (!line || !data)\n    return -1;\n\n  char *endp = NULL;\n\n  errno = 0;\n  unsigned int index = strtoul(line, &endp, 10);\n  if (errno != 0)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n\n  struct Mailbox *m = data;\n  for (int i = 0; i < m->msg_count; i++)\n  {\n    struct PopEmailData *edata = pop_edata_get(m->emails[i]);\n    if (mutt_str_strcmp(edata->uid, endp) == 0)\n    {\n      edata->refno = index;\n      break;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * pop_reconnect - reconnect and verify indexes if connection was lost\n * @param m Mailbox\n * @retval  0 Success\n * @retval -1 Error\n */\nint pop_reconnect(struct Mailbox *m)\n{\n  struct PopAccountData *adata = pop_adata_get(m);\n\n  if (adata->status == POP_CONNECTED)\n    return 0;\n\n  while (true)\n  {\n    mutt_socket_close(adata->conn);\n\n    int ret = pop_open_connection(adata);\n    if (ret == 0)\n    {\n      struct Progress progress;\n      mutt_progress_init(&progress, _(\"Verifying message indexes...\"), MUTT_PROGRESS_NET, 0);\n\n      for (int i = 0; i < m->msg_count; i++)\n      {\n        struct PopEmailData *edata = pop_edata_get(m->emails[i]);\n        edata->refno = -1;\n      }\n\n      ret = pop_fetch_data(adata, \"UIDL\\r\\n\", &progress, check_uidl, m);\n      if (ret == -2)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n    }\n    if (ret == 0)\n      return 0;\n\n    pop_logout(m);\n\n    if (ret < -1)\n      return -1;\n\n    if (query_quadoption(C_PopReconnect,\n                         _(\"Connection lost. Reconnect to POP server?\")) != MUTT_YES)\n    {\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_adata_get - Get the Account data for this mailbox\n * @param m Mailbox\n * @retval ptr PopAccountData\n */\nstruct PopAccountData *pop_adata_get(struct Mailbox *m)\n{\n  if (!m || (m->type != MUTT_POP))\n    return NULL;\n  struct Account *a = m->account;\n  if (!a)\n    return NULL;\n  return a->adata;\n}\n", "/**\n * @file\n * Send email to an SMTP server\n *\n * @authors\n * Copyright (C) 2002 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2005-2009 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2019 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page smtp Send email to an SMTP server\n *\n * Send email to an SMTP server\n */\n\n/* This file contains code for direct SMTP delivery of email messages. */\n\n#include \"config.h\"\n#include <netdb.h>\n#include <netinet/in.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"mutt/lib.h\"\n#include \"address/lib.h\"\n#include \"email/lib.h\"\n#include \"conn/lib.h\"\n#include \"smtp.h\"\n#include \"globals.h\"\n#include \"init.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"progress.h\"\n#include \"sendlib.h\"\n#ifdef USE_SSL\n#include \"config/lib.h\"\n#endif\n#ifdef USE_SASL\n#include <sasl/sasl.h>\n#include <sasl/saslutil.h>\n#include \"options.h\"\n#endif\n\n/* These Config Variables are only used in smtp.c */\nstruct Slist *C_SmtpAuthenticators; ///< Config: (smtp) List of allowed authentication methods\nchar *C_SmtpOauthRefreshCommand; ///< Config: (smtp) External command to generate OAUTH refresh token\nchar *C_SmtpPass; ///< Config: (smtp) Password for the SMTP server\nchar *C_SmtpUser; ///< Config: (smtp) Username for the SMTP server\n\n#define smtp_success(x) ((x) / 100 == 2)\n#define SMTP_READY 334\n#define SMTP_CONTINUE 354\n\n#define SMTP_ERR_READ -2\n#define SMTP_ERR_WRITE -3\n#define SMTP_ERR_CODE -4\n\n#define SMTP_PORT 25\n#define SMTPS_PORT 465\n\n#define SMTP_AUTH_SUCCESS 0\n#define SMTP_AUTH_UNAVAIL 1\n#define SMTP_AUTH_FAIL -1\n\n// clang-format off\n/**\n * typedef SmtpCapFlags - SMTP server capabilities\n */\ntypedef uint8_t SmtpCapFlags;           ///< Flags, e.g. #SMTP_CAP_STARTTLS\n#define SMTP_CAP_NO_FLAGS            0  ///< No flags are set\n#define SMTP_CAP_STARTTLS     (1 << 0) ///< Server supports STARTTLS command\n#define SMTP_CAP_AUTH         (1 << 1) ///< Server supports AUTH command\n#define SMTP_CAP_DSN          (1 << 2) ///< Server supports Delivery Status Notification\n#define SMTP_CAP_EIGHTBITMIME (1 << 3) ///< Server supports 8-bit MIME content\n#define SMTP_CAP_SMTPUTF8     (1 << 4) ///< Server accepts UTF-8 strings\n\n#define SMTP_CAP_ALL         ((1 << 5) - 1)\n// clang-format on\n\nstatic char *AuthMechs = NULL;\nstatic SmtpCapFlags Capabilities;\n\n/**\n * valid_smtp_code - Is the is a valid SMTP return code?\n * @param[in]  buf String to check\n * @param[in]  buflen Length of string\n * @param[out] n   Numeric value of code\n * @retval true Valid number\n */\nstatic bool valid_smtp_code(char *buf, size_t buflen, int *n)\n{\n  char code[4];\n\n  if (buflen < 4)\n    return false;\n  code[0] = buf[0];\n  code[1] = buf[1];\n  code[2] = buf[2];\n  code[3] = '\\0';\n  if (mutt_str_atoi(code, n) < 0)\n    return false;\n  return true;\n}\n\n/**\n * smtp_get_resp - Read a command response from the SMTP server\n * @param conn SMTP connection\n * @retval  0 Success (2xx code) or continue (354 code)\n * @retval -1 Write error, or any other response code\n */\nstatic int smtp_get_resp(struct Connection *conn)\n{\n  int n;\n  char buf[1024];\n\n  do\n  {\n    n = mutt_socket_readln(buf, sizeof(buf), conn);\n    if (n < 4)\n    {\n      /* read error, or no response code */\n      return SMTP_ERR_READ;\n    }\n    const char *s = buf + 4; /* Skip the response code and the space/dash */\n    size_t plen;\n\n    if (mutt_str_startswith(s, \"8BITMIME\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_EIGHTBITMIME;\n    else if ((plen = mutt_str_startswith(s, \"AUTH \", CASE_IGNORE)))\n    {\n      Capabilities |= SMTP_CAP_AUTH;\n      FREE(&AuthMechs);\n      AuthMechs = mutt_str_strdup(s + plen);\n    }\n    else if (mutt_str_startswith(s, \"DSN\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_DSN;\n    else if (mutt_str_startswith(s, \"STARTTLS\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_STARTTLS;\n    else if (mutt_str_startswith(s, \"SMTPUTF8\", CASE_IGNORE))\n      Capabilities |= SMTP_CAP_SMTPUTF8;\n\n    if (!valid_smtp_code(buf, n, &n))\n      return SMTP_ERR_CODE;\n\n  } while (buf[3] == '-');\n\n  if (smtp_success(n) || (n == SMTP_CONTINUE))\n    return 0;\n\n  mutt_error(_(\"SMTP session failed: %s\"), buf);\n  return -1;\n}\n\n/**\n * smtp_rcpt_to - Set the recipient to an Address\n * @param conn Server Connection\n * @param al   AddressList to use\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_rcpt_to(struct Connection *conn, const struct AddressList *al)\n{\n  if (!al)\n    return 0;\n\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    /* weed out group mailboxes, since those are for display only */\n    if (!a->mailbox || a->group)\n    {\n      continue;\n    }\n    char buf[1024];\n    if ((Capabilities & SMTP_CAP_DSN) && C_DsnNotify)\n      snprintf(buf, sizeof(buf), \"RCPT TO:<%s> NOTIFY=%s\\r\\n\", a->mailbox, C_DsnNotify);\n    else\n      snprintf(buf, sizeof(buf), \"RCPT TO:<%s>\\r\\n\", a->mailbox);\n    if (mutt_socket_send(conn, buf) == -1)\n      return SMTP_ERR_WRITE;\n    int rc = smtp_get_resp(conn);\n    if (rc != 0)\n      return rc;\n  }\n\n  return 0;\n}\n\n/**\n * smtp_data - Send data to an SMTP server\n * @param conn    SMTP Connection\n * @param msgfile Filename containing data\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_data(struct Connection *conn, const char *msgfile)\n{\n  char buf[1024];\n  struct Progress progress;\n  struct stat st;\n  int rc, term = 0;\n  size_t buflen = 0;\n\n  FILE *fp = fopen(msgfile, \"r\");\n  if (!fp)\n  {\n    mutt_error(_(\"SMTP session failed: unable to open %s\"), msgfile);\n    return -1;\n  }\n  stat(msgfile, &st);\n  unlink(msgfile);\n  mutt_progress_init(&progress, _(\"Sending message...\"), MUTT_PROGRESS_NET, st.st_size);\n\n  snprintf(buf, sizeof(buf), \"DATA\\r\\n\");\n  if (mutt_socket_send(conn, buf) == -1)\n  {\n    mutt_file_fclose(&fp);\n    return SMTP_ERR_WRITE;\n  }\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n  {\n    mutt_file_fclose(&fp);\n    return rc;\n  }\n\n  while (fgets(buf, sizeof(buf) - 1, fp))\n  {\n    buflen = mutt_str_strlen(buf);\n    term = buflen && buf[buflen - 1] == '\\n';\n    if (term && ((buflen == 1) || (buf[buflen - 2] != '\\r')))\n      snprintf(buf + buflen - 1, sizeof(buf) - buflen + 1, \"\\r\\n\");\n    if (buf[0] == '.')\n    {\n      if (mutt_socket_send_d(conn, \".\", MUTT_SOCK_LOG_FULL) == -1)\n      {\n        mutt_file_fclose(&fp);\n        return SMTP_ERR_WRITE;\n      }\n    }\n    if (mutt_socket_send_d(conn, buf, MUTT_SOCK_LOG_FULL) == -1)\n    {\n      mutt_file_fclose(&fp);\n      return SMTP_ERR_WRITE;\n    }\n    mutt_progress_update(&progress, ftell(fp), -1);\n  }\n  if (!term && buflen && (mutt_socket_send_d(conn, \"\\r\\n\", MUTT_SOCK_LOG_FULL) == -1))\n  {\n    mutt_file_fclose(&fp);\n    return SMTP_ERR_WRITE;\n  }\n  mutt_file_fclose(&fp);\n\n  /* terminate the message body */\n  if (mutt_socket_send(conn, \".\\r\\n\") == -1)\n    return SMTP_ERR_WRITE;\n\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  return 0;\n}\n\n/**\n * address_uses_unicode - Do any addresses use Unicode\n * @param a Address list to check\n * @retval true if any of the string of addresses use 8-bit characters\n */\nstatic bool address_uses_unicode(const char *a)\n{\n  if (!a)\n    return false;\n\n  while (*a)\n  {\n    if ((unsigned char) *a & (1 << 7))\n      return true;\n    a++;\n  }\n\n  return false;\n}\n\n/**\n * addresses_use_unicode - Do any of a list of addresses use Unicode\n * @param al Address list to check\n * @retval true if any use 8-bit characters\n */\nstatic bool addresses_use_unicode(const struct AddressList *al)\n{\n  if (!al)\n  {\n    return false;\n  }\n\n  struct Address *a = NULL;\n  TAILQ_FOREACH(a, al, entries)\n  {\n    if (a->mailbox && !a->group && address_uses_unicode(a->mailbox))\n      return true;\n  }\n  return false;\n}\n\n/**\n * smtp_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nstatic const char *smtp_get_field(enum ConnAccountField field)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n    case MUTT_CA_USER:\n      return C_SmtpUser;\n    case MUTT_CA_PASS:\n      return C_SmtpPass;\n    case MUTT_CA_OAUTH_CMD:\n      return C_SmtpOauthRefreshCommand;\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n/**\n * smtp_fill_account - Create ConnAccount object from SMTP Url\n * @param cac ConnAccount to populate\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int smtp_fill_account(struct ConnAccount *cac)\n{\n  cac->flags = 0;\n  cac->port = 0;\n  cac->type = MUTT_ACCT_TYPE_SMTP;\n  cac->service = \"smtp\";\n  cac->get_field = smtp_get_field;\n\n  struct Url *url = url_parse(C_SmtpUrl);\n  if (!url || ((url->scheme != U_SMTP) && (url->scheme != U_SMTPS)) ||\n      !url->host || (mutt_account_fromurl(cac, url) < 0))\n  {\n    url_free(&url);\n    mutt_error(_(\"Invalid SMTP URL: %s\"), C_SmtpUrl);\n    return -1;\n  }\n\n  if (url->scheme == U_SMTPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  if (cac->port == 0)\n  {\n    if (cac->flags & MUTT_ACCT_SSL)\n      cac->port = SMTPS_PORT;\n    else\n    {\n      static unsigned short SmtpPort = 0;\n      if (SmtpPort == 0)\n      {\n        struct servent *service = getservbyname(\"smtp\", \"tcp\");\n        if (service)\n          SmtpPort = ntohs(service->s_port);\n        else\n          SmtpPort = SMTP_PORT;\n        mutt_debug(LL_DEBUG3, \"Using default SMTP port %d\\n\", SmtpPort);\n      }\n      cac->port = SmtpPort;\n    }\n  }\n\n  url_free(&url);\n  return 0;\n}\n\n/**\n * smtp_helo - Say hello to an SMTP Server\n * @param conn  SMTP Connection\n * @param esmtp If true, use ESMTP\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_ERR_WRITE\n */\nstatic int smtp_helo(struct Connection *conn, bool esmtp)\n{\n  Capabilities = 0;\n\n  if (!esmtp)\n  {\n    /* if TLS or AUTH are requested, use EHLO */\n    if (conn->account.flags & MUTT_ACCT_USER)\n      esmtp = true;\n#ifdef USE_SSL\n    if (C_SslForceTls || (C_SslStarttls != MUTT_NO))\n      esmtp = true;\n#endif\n  }\n\n  const char *fqdn = mutt_fqdn(false);\n  if (!fqdn)\n    fqdn = NONULL(ShortHostname);\n\n  char buf[1024];\n  snprintf(buf, sizeof(buf), \"%s %s\\r\\n\", esmtp ? \"EHLO\" : \"HELO\", fqdn);\n  /* XXX there should probably be a wrapper in mutt_socket.c that\n   * repeatedly calls conn->write until all data is sent.  This\n   * currently doesn't check for a short write.  */\n  if (mutt_socket_send(conn, buf) == -1)\n    return SMTP_ERR_WRITE;\n  return smtp_get_resp(conn);\n}\n\n#ifdef USE_SASL\n/**\n * smtp_auth_sasl - Authenticate using SASL\n * @param conn     SMTP Connection\n * @param mechlist List of mechanisms to use\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth_sasl(struct Connection *conn, const char *mechlist)\n{\n  sasl_conn_t *saslconn = NULL;\n  sasl_interact_t *interaction = NULL;\n  const char *mech = NULL;\n  const char *data = NULL;\n  unsigned int len;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  int rc, saslrc;\n\n  if (mutt_sasl_client_new(conn, &saslconn) < 0)\n    return SMTP_AUTH_FAIL;\n\n  do\n  {\n    rc = sasl_client_start(saslconn, mechlist, &interaction, &data, &len, &mech);\n    if (rc == SASL_INTERACT)\n      mutt_sasl_interact(interaction);\n  } while (rc == SASL_INTERACT);\n\n  if ((rc != SASL_OK) && (rc != SASL_CONTINUE))\n  {\n    mutt_debug(LL_DEBUG2, \"%s unavailable\\n\", mech);\n    sasl_dispose(&saslconn);\n    return SMTP_AUTH_UNAVAIL;\n  }\n\n  if (!OptNoCurses)\n    mutt_message(_(\"Authenticating (%s)...\"), mech);\n\n  bufsize = MAX((len * 2), 1024);\n  buf = mutt_mem_malloc(bufsize);\n\n  snprintf(buf, bufsize, \"AUTH %s\", mech);\n  if (len)\n  {\n    mutt_str_strcat(buf, bufsize, \" \");\n    if (sasl_encode64(data, len, buf + mutt_str_strlen(buf),\n                      bufsize - mutt_str_strlen(buf), &len) != SASL_OK)\n    {\n      mutt_debug(LL_DEBUG1, \"#1 error base64-encoding client response\\n\");\n      goto fail;\n    }\n  }\n  mutt_str_strcat(buf, bufsize, \"\\r\\n\");\n\n  do\n  {\n    if (mutt_socket_send(conn, buf) < 0)\n      goto fail;\n    rc = mutt_socket_readln_d(buf, bufsize, conn, MUTT_SOCK_LOG_FULL);\n    if (rc < 0)\n      goto fail;\n    if (!valid_smtp_code(buf, rc, &rc))\n      goto fail;\n\n    if (rc != SMTP_READY)\n      break;\n\n    if (sasl_decode64(buf + 4, strlen(buf + 4), buf, bufsize - 1, &len) != SASL_OK)\n    {\n      mutt_debug(LL_DEBUG1, \"error base64-decoding server response\\n\");\n      goto fail;\n    }\n\n    do\n    {\n      saslrc = sasl_client_step(saslconn, buf, len, &interaction, &data, &len);\n      if (saslrc == SASL_INTERACT)\n        mutt_sasl_interact(interaction);\n    } while (saslrc == SASL_INTERACT);\n\n    if (len)\n    {\n      if ((len * 2) > bufsize)\n      {\n        bufsize = len * 2;\n        mutt_mem_realloc(&buf, bufsize);\n      }\n      if (sasl_encode64(data, len, buf, bufsize, &len) != SASL_OK)\n      {\n        mutt_debug(LL_DEBUG1, \"#2 error base64-encoding client response\\n\");\n        goto fail;\n      }\n    }\n    mutt_str_strfcpy(buf + len, \"\\r\\n\", bufsize - len);\n  } while (rc == SMTP_READY && saslrc != SASL_FAIL);\n\n  if (smtp_success(rc))\n  {\n    mutt_sasl_setup_conn(conn, saslconn);\n    FREE(&buf);\n    return SMTP_AUTH_SUCCESS;\n  }\n\nfail:\n  sasl_dispose(&saslconn);\n  FREE(&buf);\n  return SMTP_AUTH_FAIL;\n}\n#endif\n\n/**\n * smtp_auth_oauth - Authenticate an SMTP connection using OAUTHBEARER\n * @param conn Connection info\n * @retval num Result, e.g. #SMTP_AUTH_SUCCESS\n */\nstatic int smtp_auth_oauth(struct Connection *conn)\n{\n  mutt_message(_(\"Authenticating (OAUTHBEARER)...\"));\n\n  /* We get the access token from the smtp_oauth_refresh_command */\n  char *oauthbearer = mutt_account_getoauthbearer(&conn->account);\n  if (!oauthbearer)\n    return SMTP_AUTH_FAIL;\n\n  size_t ilen = strlen(oauthbearer) + 30;\n  char *ibuf = mutt_mem_malloc(ilen);\n  snprintf(ibuf, ilen, \"AUTH OAUTHBEARER %s\\r\\n\", oauthbearer);\n\n  int rc = mutt_socket_send(conn, ibuf);\n  FREE(&oauthbearer);\n  FREE(&ibuf);\n\n  if (rc == -1)\n    return SMTP_AUTH_FAIL;\n  if (smtp_get_resp(conn) != 0)\n    return SMTP_AUTH_FAIL;\n\n  return SMTP_AUTH_SUCCESS;\n}\n\n/**\n * smtp_auth_plain - Authenticate using plain text\n * @param conn SMTP Connection\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth_plain(struct Connection *conn)\n{\n  char buf[1024];\n\n  /* Get username and password. Bail out of any can't be retrieved. */\n  if ((mutt_account_getuser(&conn->account) < 0) ||\n      (mutt_account_getpass(&conn->account) < 0))\n  {\n    goto error;\n  }\n\n  /* Build the initial client response. */\n  size_t len = mutt_sasl_plain_msg(buf, sizeof(buf), \"AUTH PLAIN\", conn->account.user,\n                                   conn->account.user, conn->account.pass);\n\n  /* Terminate as per SMTP protocol. Bail out if there's no room left. */\n  if (snprintf(buf + len, sizeof(buf) - len, \"\\r\\n\") != 2)\n  {\n    goto error;\n  }\n\n  /* Send request, receive response (with a check for OK code). */\n  if ((mutt_socket_send(conn, buf) < 0) || smtp_get_resp(conn))\n  {\n    goto error;\n  }\n\n  /* If we got here, auth was successful. */\n  return 0;\n\nerror:\n  mutt_error(_(\"SASL authentication failed\"));\n  return -1;\n}\n\n/**\n * smtp_auth - Authenticate to an SMTP server\n * @param conn SMTP Connection\n * @retval  0 Success\n * @retval <0 Error, e.g. #SMTP_AUTH_FAIL\n */\nstatic int smtp_auth(struct Connection *conn)\n{\n  int r = SMTP_AUTH_UNAVAIL;\n\n  if (C_SmtpAuthenticators)\n  {\n    struct ListNode *np = NULL;\n    STAILQ_FOREACH(np, &C_SmtpAuthenticators->head, entries)\n    {\n      mutt_debug(LL_DEBUG2, \"Trying method %s\\n\", np->data);\n\n      if (strcmp(np->data, \"oauthbearer\") == 0)\n      {\n        r = smtp_auth_oauth(conn);\n      }\n      else if (strcmp(np->data, \"plain\") == 0)\n      {\n        r = smtp_auth_plain(conn);\n      }\n      else\n      {\n#ifdef USE_SASL\n        r = smtp_auth_sasl(conn, np->data);\n#else\n        mutt_error(_(\"SMTP authentication method %s requires SASL\"), np->data);\n        continue;\n#endif\n      }\n\n      if ((r == SMTP_AUTH_FAIL) && (C_SmtpAuthenticators->count > 1))\n      {\n        mutt_error(_(\"%s authentication failed, trying next method\"), np->data);\n      }\n      else if (r != SMTP_AUTH_UNAVAIL)\n        break;\n    }\n  }\n  else\n  {\n#ifdef USE_SASL\n    r = smtp_auth_sasl(conn, AuthMechs);\n#else\n    mutt_error(_(\"SMTP authentication requires SASL\"));\n    r = SMTP_AUTH_UNAVAIL;\n#endif\n  }\n\n  if (r != SMTP_AUTH_SUCCESS)\n    mutt_account_unsetpass(&conn->account);\n\n  if (r == SMTP_AUTH_FAIL)\n  {\n    mutt_error(_(\"SASL authentication failed\"));\n  }\n  else if (r == SMTP_AUTH_UNAVAIL)\n  {\n    mutt_error(_(\"No authenticators available\"));\n  }\n\n  return (r == SMTP_AUTH_SUCCESS) ? 0 : -1;\n}\n\n/**\n * smtp_open - Open an SMTP Connection\n * @param conn  SMTP Connection\n * @param esmtp If true, use ESMTP\n * @retval  0 Success\n * @retval -1 Error\n */\nstatic int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n\n  if (mutt_socket_open(conn))\n    return -1;\n\n  /* get greeting string */\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    // Clear any data after the STARTTLS acknowledgement\n    mutt_socket_empty(conn);\n    if (rc != 0)\n      return rc;\n\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n\n    /* re-EHLO to get authentication mechanisms */\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n\n    return smtp_auth(conn);\n  }\n\n  return 0;\n}\n\n/**\n * mutt_smtp_send - Send a message using SMTP\n * @param from     From Address\n * @param to       To Address\n * @param cc       Cc Address\n * @param bcc      Bcc Address\n * @param msgfile  Message to send to the server\n * @param eightbit If true, try for an 8-bit friendly connection\n * @retval  0 Success\n * @retval -1 Error\n */\nint mutt_smtp_send(const struct AddressList *from, const struct AddressList *to,\n                   const struct AddressList *cc, const struct AddressList *bcc,\n                   const char *msgfile, bool eightbit)\n{\n  struct Connection *conn = NULL;\n  struct ConnAccount cac = { { 0 } };\n  const char *envfrom = NULL;\n  char buf[1024];\n  int rc = -1;\n\n  /* it might be better to synthesize an envelope from from user and host\n   * but this condition is most likely arrived at accidentally */\n  if (C_EnvelopeFromAddress)\n    envfrom = C_EnvelopeFromAddress->mailbox;\n  else if (from && !TAILQ_EMPTY(from))\n    envfrom = TAILQ_FIRST(from)->mailbox;\n  else\n  {\n    mutt_error(_(\"No from address given\"));\n    return -1;\n  }\n\n  if (smtp_fill_account(&cac) < 0)\n    return rc;\n\n  conn = mutt_conn_find(&cac);\n  if (!conn)\n    return -1;\n\n  do\n  {\n    /* send our greeting */\n    rc = smtp_open(conn, eightbit);\n    if (rc != 0)\n      break;\n    FREE(&AuthMechs);\n\n    /* send the sender's address */\n    int len = snprintf(buf, sizeof(buf), \"MAIL FROM:<%s>\", envfrom);\n    if (eightbit && (Capabilities & SMTP_CAP_EIGHTBITMIME))\n    {\n      mutt_str_strncat(buf, sizeof(buf), \" BODY=8BITMIME\", 15);\n      len += 14;\n    }\n    if (C_DsnReturn && (Capabilities & SMTP_CAP_DSN))\n      len += snprintf(buf + len, sizeof(buf) - len, \" RET=%s\", C_DsnReturn);\n    if ((Capabilities & SMTP_CAP_SMTPUTF8) &&\n        (address_uses_unicode(envfrom) || addresses_use_unicode(to) ||\n         addresses_use_unicode(cc) || addresses_use_unicode(bcc)))\n    {\n      snprintf(buf + len, sizeof(buf) - len, \" SMTPUTF8\");\n    }\n    mutt_str_strncat(buf, sizeof(buf), \"\\r\\n\", 3);\n    if (mutt_socket_send(conn, buf) == -1)\n    {\n      rc = SMTP_ERR_WRITE;\n      break;\n    }\n    rc = smtp_get_resp(conn);\n    if (rc != 0)\n      break;\n\n    /* send the recipient list */\n    if ((rc = smtp_rcpt_to(conn, to)) || (rc = smtp_rcpt_to(conn, cc)) ||\n        (rc = smtp_rcpt_to(conn, bcc)))\n    {\n      break;\n    }\n\n    /* send the message data */\n    rc = smtp_data(conn, msgfile);\n    if (rc != 0)\n      break;\n\n    mutt_socket_send(conn, \"QUIT\\r\\n\");\n\n    rc = 0;\n  } while (false);\n\n  mutt_socket_close(conn);\n  FREE(&conn);\n\n  if (rc == SMTP_ERR_READ)\n    mutt_error(_(\"SMTP session failed: read error\"));\n  else if (rc == SMTP_ERR_WRITE)\n    mutt_error(_(\"SMTP session failed: write error\"));\n  else if (rc == SMTP_ERR_CODE)\n    mutt_error(_(\"Invalid server response\"));\n\n  return rc;\n}\n"], "filenames": ["conn/socket.c", "conn/socket.h", "imap/command.c", "imap/imap.c", "imap/private.h", "nntp/nntp.c", "pop/pop_lib.c", "smtp.c"], "buggy_code_start_loc": [303, 41, 1252, 742, 75, 1901, 360, 721], "buggy_code_end_loc": [303, 41, 1275, 743, 75, 1901, 360, 721], "fixing_code_start_loc": [304, 42, 1253, 742, 76, 1902, 361, 722], "fixing_code_end_loc": [324, 43, 1286, 746, 77, 1904, 363, 724], "type": "CWE-74", "message": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"", "other": {"cve": {"id": "CVE-2020-14954", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-21T17:15:09.603", "lastModified": "2023-02-27T18:09:29.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\""}, {"lang": "es", "value": "Mutt versiones anteriores a 1.14.4 y NeoMutt antes del 19-06-2020, presentan un problema de almacenamiento de STARTTLS que afecta a IMAP, SMTP y POP3. Cuando un servidor env\u00eda una respuesta \"begin TLS\", el cliente lee datos adicionales (por ejemplo, a partir de un atacante man-in-the-middle) y los eval\u00faa en un contexto TLS, tambi\u00e9n se conoce como \"response injection\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.4", "matchCriteriaId": "263DD684-7B89-4B05-B004-5284A7F73C1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20200619", "matchCriteriaId": "04723628-944D-441C-9666-A7715E9FC189"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.mutt.org/pipermail/mutt-announce/Week-of-Mon-20200615/000023.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00064.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00070.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mutt.org/", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/neomutt/neomutt/releases/tag/20200619", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://gitlab.com/muttmua/mutt/-/commit/c547433cdf2e79191b15c6932c57f1472bfb5ff4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://gitlab.com/muttmua/mutt/-/issues/248", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EFMEILCBKMZRRZDMUGWLVN4PQQ4VTAZE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/K3LXFVPTLK4PNHL6MPKJNJQJ25CH7GLQ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-57", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4403-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4707", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4708", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc"}}