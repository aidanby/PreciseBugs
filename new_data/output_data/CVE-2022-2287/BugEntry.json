{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellfile.c: code for reading and writing spell files.\n *\n * See spell.c for information about spell checking.\n */\n\n/*\n * Vim spell file format: <HEADER>\n *\t\t\t  <SECTIONS>\n *\t\t\t  <LWORDTREE>\n *\t\t\t  <KWORDTREE>\n *\t\t\t  <PREFIXTREE>\n *\n * <HEADER>: <fileID> <versionnr>\n *\n * <fileID>     8 bytes    \"VIMspell\"\n * <versionnr>  1 byte\t    VIMSPELLVERSION\n *\n *\n * Sections make it possible to add information to the .spl file without\n * making it incompatible with previous versions.  There are two kinds of\n * sections:\n * 1. Not essential for correct spell checking.  E.g. for making suggestions.\n *    These are skipped when not supported.\n * 2. Optional information, but essential for spell checking when present.\n *    E.g. conditions for affixes.  When this section is present but not\n *    supported an error message is given.\n *\n * <SECTIONS>: <section> ... <sectionend>\n *\n * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n *\n * <sectionID>\t  1 byte    number from 0 to 254 identifying the section\n *\n * <sectionflags> 1 byte    SNF_REQUIRED: this section is required for correct\n *\t\t\t\t\t    spell checking\n *\n * <sectionlen>   4 bytes   length of section contents, MSB first\n *\n * <sectionend>\t  1 byte    SN_END\n *\n *\n * sectionID == SN_INFO: <infotext>\n * <infotext>\t N bytes    free format text with spell file info (version,\n *\t\t\t    website, etc)\n *\n * sectionID == SN_REGION: <regionname> ...\n * <regionname>\t 2 bytes    Up to MAXREGIONS region names: ca, au, etc.  Lower\n *\t\t\t    case.  First <regionname> is region 1.\n *\n * sectionID == SN_CHARFLAGS: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * <charflagslen> 1 byte    Number of bytes in <charflags> (should be 128).\n * <charflags>  N bytes     List of flags (first one is for character 128):\n *\t\t\t    0x01  word character\tCF_WORD\n *\t\t\t    0x02  upper-case character\tCF_UPPER\n * <folcharslen>  2 bytes   Number of bytes in <folchars>.\n * <folchars>     N bytes   Folded characters, first one is for character 128.\n *\n * sectionID == SN_MIDWORD: <midword>\n * <midword>     N bytes    Characters that are word characters only when used\n *\t\t\t    in the middle of a word.\n *\n * sectionID == SN_PREFCOND: <prefcondcnt> <prefcond> ...\n * <prefcondcnt> 2 bytes    Number of <prefcond> items following.\n * <prefcond> : <condlen> <condstr>\n * <condlen>\t1 byte\t    Length of <condstr>.\n * <condstr>\tN bytes\t    Condition for the prefix.\n *\n * sectionID == SN_REP: <repcount> <rep> ...\n * <repcount>\t 2 bytes    number of <rep> items, MSB first.\n * <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n * <repfromlen>\t 1 byte\t    length of <repfrom>\n * <repfrom>\t N bytes    \"from\" part of replacement\n * <reptolen>\t 1 byte\t    length of <repto>\n * <repto>\t N bytes    \"to\" part of replacement\n *\n * sectionID == SN_REPSAL: <repcount> <rep> ...\n *   just like SN_REP but for soundfolded words\n *\n * sectionID == SN_SAL: <salflags> <salcount> <sal> ...\n * <salflags>\t 1 byte\t    flags for soundsalike conversion:\n *\t\t\t    SAL_F0LLOWUP\n *\t\t\t    SAL_COLLAPSE\n *\t\t\t    SAL_REM_ACCENTS\n * <salcount>    2 bytes    number of <sal> items following\n * <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n * <salfromlen>\t 1 byte\t    length of <salfrom>\n * <salfrom>\t N bytes    \"from\" part of soundsalike\n * <saltolen>\t 1 byte\t    length of <salto>\n * <salto>\t N bytes    \"to\" part of soundsalike\n *\n * sectionID == SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * <sofofromlen> 2 bytes    length of <sofofrom>\n * <sofofrom>\t N bytes    \"from\" part of soundfold\n * <sofotolen>\t 2 bytes    length of <sofoto>\n * <sofoto>\t N bytes    \"to\" part of soundfold\n *\n * sectionID == SN_SUGFILE: <timestamp>\n * <timestamp>   8 bytes    time in seconds that must match with .sug file\n *\n * sectionID == SN_NOSPLITSUGS: nothing\n\t *\n * sectionID == SN_NOCOMPOUNDSUGS: nothing\n *\n * sectionID == SN_WORDS: <word> ...\n * <word>\t N bytes    NUL terminated common word\n *\n * sectionID == SN_MAP: <mapstr>\n * <mapstr>\t N bytes    String with sequences of similar characters,\n *\t\t\t    separated by slashes.\n *\n * sectionID == SN_COMPOUND: <compmax> <compminlen> <compsylmax> <compoptions>\n *\t\t\t\t<comppatcount> <comppattern> ... <compflags>\n * <compmax>     1 byte\t    Maximum nr of words in compound word.\n * <compminlen>  1 byte\t    Minimal word length for compounding.\n * <compsylmax>  1 byte\t    Maximum nr of syllables in compound word.\n * <compoptions> 2 bytes    COMP_ flags.\n * <comppatcount> 2 bytes   number of <comppattern> following\n * <compflags>   N bytes    Flags from COMPOUNDRULE items, separated by\n *\t\t\t    slashes.\n *\n * <comppattern>: <comppatlen> <comppattext>\n * <comppatlen>\t 1 byte\t    length of <comppattext>\n * <comppattext> N bytes    end or begin chars from CHECKCOMPOUNDPATTERN\n *\n * sectionID == SN_NOBREAK: (empty, its presence is what matters)\n *\n * sectionID == SN_SYLLABLE: <syllable>\n * <syllable>    N bytes    String from SYLLABLE item.\n *\n * <LWORDTREE>: <wordtree>\n *\n * <KWORDTREE>: <wordtree>\n *\n * <PREFIXTREE>: <wordtree>\n *\n *\n * <wordtree>: <nodecount> <nodedata> ...\n *\n * <nodecount>\t4 bytes\t    Number of nodes following.  MSB first.\n *\n * <nodedata>: <siblingcount> <sibling> ...\n *\n * <siblingcount> 1 byte    Number of siblings in this node.  The siblings\n *\t\t\t    follow in sorted order.\n *\n * <sibling>: <byte> [ <nodeidx> <xbyte>\n *\t\t      | <flags> [<flags2>] [<region>] [<affixID>]\n *\t\t      | [<pflags>] <affixID> <prefcondnr> ]\n *\n * <byte>\t1 byte\t    Byte value of the sibling.  Special cases:\n *\t\t\t    BY_NOFLAGS: End of word without flags and for all\n *\t\t\t\t\tregions.\n *\t\t\t\t\tFor PREFIXTREE <affixID> and\n *\t\t\t\t\t<prefcondnr> follow.\n *\t\t\t    BY_FLAGS:   End of word, <flags> follow.\n *\t\t\t\t\tFor PREFIXTREE <pflags>, <affixID>\n *\t\t\t\t\tand <prefcondnr> follow.\n *\t\t\t    BY_FLAGS2:  End of word, <flags> and <flags2>\n *\t\t\t\t\tfollow.  Not used in PREFIXTREE.\n *\t\t\t    BY_INDEX:   Child of sibling is shared, <nodeidx>\n *\t\t\t\t\tand <xbyte> follow.\n *\n * <nodeidx>\t3 bytes\t    Index of child for this sibling, MSB first.\n *\n * <xbyte>\t1 byte\t    byte value of the sibling.\n *\n * <flags>\t1 byte\t    bitmask of:\n *\t\t\t    WF_ALLCAP\tword must have only capitals\n *\t\t\t    WF_ONECAP   first char of word must be capital\n *\t\t\t    WF_KEEPCAP\tkeep-case word\n *\t\t\t    WF_FIXCAP   keep-case word, all caps not allowed\n *\t\t\t    WF_RARE\trare word\n *\t\t\t    WF_BANNED\tbad word\n *\t\t\t    WF_REGION\t<region> follows\n *\t\t\t    WF_AFX\t<affixID> follows\n *\n * <flags2>\t1 byte\t    Bitmask of:\n *\t\t\t    WF_HAS_AFF >> 8   word includes affix\n *\t\t\t    WF_NEEDCOMP >> 8  word only valid in compound\n *\t\t\t    WF_NOSUGGEST >> 8  word not used for suggestions\n *\t\t\t    WF_COMPROOT >> 8  word already a compound\n *\t\t\t    WF_NOCOMPBEF >> 8 no compounding before this word\n *\t\t\t    WF_NOCOMPAFT >> 8 no compounding after this word\n *\n * <pflags>\t1 byte\t    bitmask of:\n *\t\t\t    WFP_RARE\trare prefix\n *\t\t\t    WFP_NC\tnon-combining prefix\n *\t\t\t    WFP_UP\tletter after prefix made upper case\n *\n * <region>\t1 byte\t    Bitmask for regions in which word is valid.  When\n *\t\t\t    omitted it's valid in all regions.\n *\t\t\t    Lowest bit is for region 1.\n *\n * <affixID>\t1 byte\t    ID of affix that can be used with this word.  In\n *\t\t\t    PREFIXTREE used for the required prefix ID.\n *\n * <prefcondnr>\t2 bytes\t    Prefix condition number, index in <prefcond> list\n *\t\t\t    from HEADER.\n *\n * All text characters are in 'encoding', but stored as single bytes.\n */\n\n/*\n * Vim .sug file format:  <SUGHEADER>\n *\t\t\t  <SUGWORDTREE>\n *\t\t\t  <SUGTABLE>\n *\n * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n *\n * <fileID>     6 bytes     \"VIMsug\"\n * <versionnr>  1 byte      VIMSUGVERSION\n * <timestamp>  8 bytes     timestamp that must match with .spl file\n *\n *\n * <SUGWORDTREE>: <wordtree>  (see above, no flags or region used)\n *\n *\n * <SUGTABLE>: <sugwcount> <sugline> ...\n *\n * <sugwcount>\t4 bytes\t    number of <sugline> following\n *\n * <sugline>: <sugnr> ... NUL\n *\n * <sugnr>:     X bytes     word number that results in this soundfolded word,\n *\t\t\t    stored as an offset to the previous number in as\n *\t\t\t    few bytes as possible, see offset2bytes())\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n// Special byte values for <byte>.  Some are only used in the tree for\n// postponed prefixes, some only in the other trees.  This is a bit messy...\n#define BY_NOFLAGS\t0\t// end of word without flags or region; for\n\t\t\t\t// postponed prefix: no <pflags>\n#define BY_INDEX\t1\t// child is shared, index follows\n#define BY_FLAGS\t2\t// end of word, <flags> byte follows; for\n\t\t\t\t// postponed prefix: <pflags> follows\n#define BY_FLAGS2\t3\t// end of word, <flags> and <flags2> bytes\n\t\t\t\t// follow; never used in prefix tree\n#define BY_SPECIAL  BY_FLAGS2\t// highest special byte value\n\n#define ZERO_FLAG\t65009\t// used when flag is zero: \"0\"\n\n// Flags used in .spl file for soundsalike flags.\n#define SAL_F0LLOWUP\t\t1\n#define SAL_COLLAPSE\t\t2\n#define SAL_REM_ACCENTS\t\t4\n\n#define VIMSPELLMAGIC \"VIMspell\"  // string at start of Vim spell file\n#define VIMSPELLMAGICL 8\n#define VIMSPELLVERSION 50\n\n// Section IDs.  Only renumber them when VIMSPELLVERSION changes!\n#define SN_REGION\t0\t// <regionname> section\n#define SN_CHARFLAGS\t1\t// charflags section\n#define SN_MIDWORD\t2\t// <midword> section\n#define SN_PREFCOND\t3\t// <prefcond> section\n#define SN_REP\t\t4\t// REP items section\n#define SN_SAL\t\t5\t// SAL items section\n#define SN_SOFO\t\t6\t// soundfolding section\n#define SN_MAP\t\t7\t// MAP items section\n#define SN_COMPOUND\t8\t// compound words section\n#define SN_SYLLABLE\t9\t// syllable section\n#define SN_NOBREAK\t10\t// NOBREAK section\n#define SN_SUGFILE\t11\t// timestamp for .sug file\n#define SN_REPSAL\t12\t// REPSAL items section\n#define SN_WORDS\t13\t// common words\n#define SN_NOSPLITSUGS\t14\t// don't split word for suggestions\n#define SN_INFO\t\t15\t// info section\n#define SN_NOCOMPOUNDSUGS 16\t// don't compound for suggestions\n#define SN_END\t\t255\t// end of sections\n\n#define SNF_REQUIRED\t1\t// <sectionflags>: required section\n\n#define CF_WORD\t\t0x01\n#define CF_UPPER\t0x02\n\n/*\n * Loop through all the siblings of a node (including the node)\n */\n#define FOR_ALL_NODE_SIBLINGS(node, np) \\\n    for ((np) = (node); (np) != NULL; (np) = (np)->wn_sibling)\n\nstatic int set_spell_finish(spelltab_T\t*new_st);\nstatic int write_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv);\nstatic int read_region_section(FILE *fd, slang_T *slang, int len);\nstatic int read_charflags_section(FILE *fd);\nstatic int read_prefcond_section(FILE *fd, slang_T *lp);\nstatic int read_rep_section(FILE *fd, garray_T *gap, short *first);\nstatic int read_sal_section(FILE *fd, slang_T *slang);\nstatic int read_words_section(FILE *fd, slang_T *lp, int len);\nstatic int read_sofo_section(FILE *fd, slang_T *slang);\nstatic int read_compound(FILE *fd, slang_T *slang, int len);\nstatic int set_sofo(slang_T *lp, char_u *from, char_u *to);\nstatic void set_sal_first(slang_T *lp);\nstatic int *mb_str2wide(char_u *s);\nstatic int spell_read_tree(FILE *fd, char_u **bytsp, long *bytsp_len, idx_T **idxsp, int prefixtree, int prefixcnt);\nstatic idx_T read_tree_node(FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr);\nstatic void set_spell_charflags(char_u *flags, int cnt, char_u *upp);\nstatic int set_spell_chartab(char_u *fol, char_u *low, char_u *upp);\nstatic void set_map_str(slang_T *lp, char_u *map);\n\n\nstatic char *e_afftrailing = N_(\"Trailing text in %s line %d: %s\");\nstatic char *e_affname = N_(\"Affix name too long in %s line %d: %s\");\nstatic char *msg_compressing = N_(\"Compressing word tree...\");\n\n/*\n * Load one spell file and store the info into a slang_T.\n *\n * This is invoked in three ways:\n * - From spell_load_cb() to load a spell file for the first time.  \"lang\" is\n *   the language name, \"old_lp\" is NULL.  Will allocate an slang_T.\n * - To reload a spell file that was changed.  \"lang\" is NULL and \"old_lp\"\n *   points to the existing slang_T.\n * - Just after writing a .spl file; it's read back to produce the .sug file.\n *   \"old_lp\" is NULL and \"lang\" is NULL.  Will allocate an slang_T.\n *\n * Returns the slang_T the spell file was loaded into.  NULL for error.\n */\n    slang_T *\nspell_load_file(\n    char_u\t*fname,\n    char_u\t*lang,\n    slang_T\t*old_lp,\n    int\t\tsilent)\t\t// no error if file doesn't exist\n{\n    FILE\t*fd;\n    char_u\tbuf[VIMSPELLMAGICL];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tn;\n    int\t\tlen;\n    slang_T\t*lp = NULL;\n    int\t\tc = 0;\n    int\t\tres;\n    int\t\tdid_estack_push = FALSE;\n    ESTACK_CHECK_DECLARATION\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tif (!silent)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse if (p_verbose > 2)\n\t{\n\t    verbose_enter();\n\t    smsg((const char *)e_cant_open_file_str, fname);\n\t    verbose_leave();\n\t}\n\tgoto endFAIL;\n    }\n    if (p_verbose > 2)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading spell file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    if (old_lp == NULL)\n    {\n\tlp = slang_alloc(lang);\n\tif (lp == NULL)\n\t    goto endFAIL;\n\n\t// Remember the file name, used to reload the file when it's updated.\n\tlp->sl_fname = vim_strsave(fname);\n\tif (lp->sl_fname == NULL)\n\t    goto endFAIL;\n\n\t// Check for .add.spl (_add.spl for VMS).\n\tlp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;\n    }\n    else\n\tlp = old_lp;\n\n    // Set sourcing_name, so that error messages mention the file name.\n    estack_push(ETYPE_SPELL, fname, 0);\n    ESTACK_CHECK_SETUP\n    did_estack_push = TRUE;\n\n    /*\n     * <HEADER>: <fileID>\n     */\n    for (i = 0; i < VIMSPELLMAGICL; ++i)\n\tbuf[i] = getc(fd);\t\t\t\t// <fileID>\n    if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)\n    {\n\temsg(_(e_this_does_not_look_like_spell_file));\n\tgoto endFAIL;\n    }\n    c = getc(fd);\t\t\t\t\t// <versionnr>\n    if (c < VIMSPELLVERSION)\n    {\n\temsg(_(e_old_spell_file_needs_to_be_updated));\n\tgoto endFAIL;\n    }\n    else if (c > VIMSPELLVERSION)\n    {\n\temsg(_(e_spell_file_is_for_newer_version_of_vim));\n\tgoto endFAIL;\n    }\n\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n     */\n    for (;;)\n    {\n\tn = getc(fd);\t\t\t    // <sectionID> or <sectionend>\n\tif (n == SN_END)\n\t    break;\n\tc = getc(fd);\t\t\t\t\t// <sectionflags>\n\tlen = get4c(fd);\t\t\t\t// <sectionlen>\n\tif (len < 0)\n\t    goto truncerr;\n\n\tres = 0;\n\tswitch (n)\n\t{\n\t    case SN_INFO:\n\t\tlp->sl_info = read_string(fd, len);\t// <infotext>\n\t\tif (lp->sl_info == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_REGION:\n\t\tres = read_region_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_CHARFLAGS:\n\t\tres = read_charflags_section(fd);\n\t\tbreak;\n\n\t    case SN_MIDWORD:\n\t\tlp->sl_midword = read_string(fd, len);\t// <midword>\n\t\tif (lp->sl_midword == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_PREFCOND:\n\t\tres = read_prefcond_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_REP:\n\t\tres = read_rep_section(fd, &lp->sl_rep, lp->sl_rep_first);\n\t\tbreak;\n\n\t    case SN_REPSAL:\n\t\tres = read_rep_section(fd, &lp->sl_repsal, lp->sl_repsal_first);\n\t\tbreak;\n\n\t    case SN_SAL:\n\t\tres = read_sal_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_SOFO:\n\t\tres = read_sofo_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_MAP:\n\t\tp = read_string(fd, len);\t\t// <mapstr>\n\t\tif (p == NULL)\n\t\t    goto endFAIL;\n\t\tset_map_str(lp, p);\n\t\tvim_free(p);\n\t\tbreak;\n\n\t    case SN_WORDS:\n\t\tres = read_words_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_SUGFILE:\n\t\tlp->sl_sugtime = get8ctime(fd);\t\t// <timestamp>\n\t\tbreak;\n\n\t    case SN_NOSPLITSUGS:\n\t\tlp->sl_nosplitsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_NOCOMPOUNDSUGS:\n\t\tlp->sl_nocompoundsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_COMPOUND:\n\t\tres = read_compound(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_NOBREAK:\n\t\tlp->sl_nobreak = TRUE;\n\t\tbreak;\n\n\t    case SN_SYLLABLE:\n\t\tlp->sl_syllable = read_string(fd, len);\t// <syllable>\n\t\tif (lp->sl_syllable == NULL)\n\t\t    goto endFAIL;\n\t\tif (init_syl_tab(lp) != OK)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    default:\n\t\t// Unsupported section.  When it's required give an error\n\t\t// message.  When it's not required skip the contents.\n\t\tif (c & SNF_REQUIRED)\n\t\t{\n\t\t    emsg(_(e_unsupported_section_in_spell_file));\n\t\t    goto endFAIL;\n\t\t}\n\t\twhile (--len >= 0)\n\t\t    if (getc(fd) < 0)\n\t\t\tgoto truncerr;\n\t\tbreak;\n\t}\nsomeerror:\n\tif (res == SP_FORMERROR)\n\t{\n\t    emsg(_(e_format_error_in_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_TRUNCERROR)\n\t{\ntruncerr:\n\t    emsg(_(e_truncated_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_OTHERERROR)\n\t    goto endFAIL;\n    }\n\n    // <LWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_fbyts, &lp->sl_fbyts_len,\n\t\t\t\t\t\t      &lp->sl_fidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <KWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_kbyts, NULL, &lp->sl_kidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <PREFIXTREE>\n    res = spell_read_tree(fd, &lp->sl_pbyts, NULL, &lp->sl_pidxs, TRUE,\n\t\t\t\t\t\t\t    lp->sl_prefixcnt);\n    if (res != 0)\n\tgoto someerror;\n\n    // For a new file link it in the list of spell files.\n    if (old_lp == NULL && lang != NULL)\n    {\n\tlp->sl_next = first_lang;\n\tfirst_lang = lp;\n    }\n\n    goto endOK;\n\nendFAIL:\n    if (lang != NULL)\n\t// truncating the name signals the error to spell_load_lang()\n\t*lang = NUL;\n    if (lp != NULL && old_lp == NULL)\n\tslang_free(lp);\n    lp = NULL;\n\nendOK:\n    if (fd != NULL)\n\tfclose(fd);\n    if (did_estack_push)\n    {\n\tESTACK_CHECK_NOW\n\testack_pop();\n    }\n\n    return lp;\n}\n\n/*\n * Fill in the wordcount fields for a trie.\n * Returns the total number of words.\n */\n    static void\ntree_count_words(char_u *byts, idx_T *idxs)\n{\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    int\t\twordcount[MAXWLEN];\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    fast_breakcheck();\n\t}\n\telse\n\t{\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// End of word, count it.\n\t\t++wordcount[depth];\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).\n\t\twhile (byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper to count the words.\n\t\t++depth;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Load the .sug files for languages that have one and weren't loaded yet.\n */\n    void\nsuggest_load_files(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    char_u\t*dotp;\n    FILE\t*fd;\n    char_u\tbuf[MAXWLEN];\n    int\t\ti;\n    time_t\ttimestamp;\n    int\t\twcount;\n    int\t\twordnr;\n    garray_T\tga;\n    int\t\tc;\n\n    // Do this for all languages that support sound folding.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sugtime != 0 && !slang->sl_sugloaded)\n\t{\n\t    // Change \".spl\" to \".sug\" and open the file.  When the file isn't\n\t    // found silently skip it.  Do set \"sl_sugloaded\" so that we\n\t    // don't try again and again.\n\t    slang->sl_sugloaded = TRUE;\n\n\t    dotp = vim_strrchr(slang->sl_fname, '.');\n\t    if (dotp == NULL || fnamecmp(dotp, \".spl\") != 0)\n\t\tcontinue;\n\t    STRCPY(dotp, \".sug\");\n\t    fd = mch_fopen((char *)slang->sl_fname, \"r\");\n\t    if (fd == NULL)\n\t\tgoto nextone;\n\n\t    /*\n\t     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n\t     */\n\t    for (i = 0; i < VIMSUGMAGICL; ++i)\n\t\tbuf[i] = getc(fd);\t\t\t// <fileID>\n\t    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)\n\t    {\n\t\tsemsg(_(e_this_does_not_look_like_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    c = getc(fd);\t\t\t\t// <versionnr>\n\t    if (c < VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_old_sug_file_needs_to_be_updated_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    else if (c > VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_sug_file_is_for_newer_version_of_vim_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    // Check the timestamp, it must be exactly the same as the one in\n\t    // the .spl file.  Otherwise the word numbers won't match.\n\t    timestamp = get8ctime(fd);\t\t\t// <timestamp>\n\t    if (timestamp != slang->sl_sugtime)\n\t    {\n\t\tsemsg(_(e_sug_file_doesnt_match_spl_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGWORDTREE>: <wordtree>\n\t     * Read the trie with the soundfolded words.\n\t     */\n\t    if (spell_read_tree(fd, &slang->sl_sbyts, NULL, &slang->sl_sidxs,\n\t\t\t\t\t\t\t       FALSE, 0) != 0)\n\t    {\nsomeerror:\n\t\tsemsg(_(e_error_while_reading_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tslang_clear_sug(slang);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGTABLE>: <sugwcount> <sugline> ...\n\t     *\n\t     * Read the table with word numbers.  We use a file buffer for\n\t     * this, because it's so much like a file with lines.  Makes it\n\t     * possible to swap the info and save on memory use.\n\t     */\n\t    slang->sl_sugbuf = open_spellbuf();\n\t    if (slang->sl_sugbuf == NULL)\n\t\tgoto someerror;\n\t\t\t\t\t\t\t    // <sugwcount>\n\t    wcount = get4c(fd);\n\t    if (wcount < 0)\n\t\tgoto someerror;\n\n\t    // Read all the wordnr lists into the buffer, one NUL terminated\n\t    // list per line.\n\t    ga_init2(&ga, 1, 100);\n\t    for (wordnr = 0; wordnr < wcount; ++wordnr)\n\t    {\n\t\tga.ga_len = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    c = getc(fd);\t\t\t    // <sugline>\n\t\t    if (c < 0 || ga_grow(&ga, 1) == FAIL)\n\t\t\tgoto someerror;\n\t\t    ((char_u *)ga.ga_data)[ga.ga_len++] = c;\n\t\t    if (c == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,\n\t\t\t\t\t ga.ga_data, ga.ga_len, TRUE) == FAIL)\n\t\t    goto someerror;\n\t    }\n\t    ga_clear(&ga);\n\n\t    /*\n\t     * Need to put word counts in the word tries, so that we can find\n\t     * a word by its number.\n\t     */\n\t    tree_count_words(slang->sl_fbyts, slang->sl_fidxs);\n\t    tree_count_words(slang->sl_sbyts, slang->sl_sidxs);\n\nnextone:\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    STRCPY(dotp, \".spl\");\n\t}\n    }\n}\n\n\n/*\n * Read a length field from \"fd\" in \"cnt_bytes\" bytes.\n * Allocate memory, read the string into it and add a NUL at the end.\n * Returns NULL when the count is zero.\n * Sets \"*cntp\" to SP_*ERROR when there is an error, length of the result\n * otherwise.\n */\n    static char_u *\nread_cnt_string(FILE *fd, int cnt_bytes, int *cntp)\n{\n    int\t\tcnt = 0;\n    int\t\ti;\n    char_u\t*str;\n\n    // read the length bytes, MSB first\n    for (i = 0; i < cnt_bytes; ++i)\n    {\n\tint c = getc(fd);\n\n\tif (c == EOF)\n\t{\n\t    *cntp = SP_TRUNCERROR;\n\t    return NULL;\n\t}\n\tcnt = (cnt << 8) + (unsigned)c;\n    }\n    *cntp = cnt;\n    if (cnt == 0)\n\treturn NULL;\t    // nothing to read, return NULL\n\n    str = read_string(fd, cnt);\n    if (str == NULL)\n\t*cntp = SP_OTHERERROR;\n    return str;\n}\n\n/*\n * Read SN_REGION: <regionname> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_region_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\ti;\n\n    if (len > MAXREGIONS * 2)\n\treturn SP_FORMERROR;\n    for (i = 0; i < len; ++i)\n\tlp->sl_regions[i] = getc(fd);\t\t\t// <regionname>\n    lp->sl_regions[len] = NUL;\n    return 0;\n}\n\n/*\n * Read SN_CHARFLAGS section: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * Return SP_*ERROR flags.\n */\n    static int\nread_charflags_section(FILE *fd)\n{\n    char_u\t*flags;\n    char_u\t*fol;\n    int\t\tflagslen, follen;\n\n    // <charflagslen> <charflags>\n    flags = read_cnt_string(fd, 1, &flagslen);\n    if (flagslen < 0)\n\treturn flagslen;\n\n    // <folcharslen> <folchars>\n    fol = read_cnt_string(fd, 2, &follen);\n    if (follen < 0)\n    {\n\tvim_free(flags);\n\treturn follen;\n    }\n\n    // Set the word-char flags and fill SPELL_ISUPPER() table.\n    if (flags != NULL && fol != NULL)\n\tset_spell_charflags(flags, flagslen, fol);\n\n    vim_free(flags);\n    vim_free(fol);\n\n    // When <charflagslen> is zero then <fcharlen> must also be zero.\n    if ((flags == NULL) != (fol == NULL))\n\treturn SP_FORMERROR;\n    return 0;\n}\n\n/*\n * Read SN_PREFCOND section.\n * Return SP_*ERROR flags.\n */\n    static int\nread_prefcond_section(FILE *fd, slang_T *lp)\n{\n    int\t\tcnt;\n    int\t\ti;\n    int\t\tn;\n    char_u\t*p;\n    char_u\tbuf[MAXWLEN + 1];\n\n    // <prefcondcnt> <prefcond> ...\n    cnt = get2c(fd);\t\t\t\t\t// <prefcondcnt>\n    if (cnt <= 0)\n\treturn SP_FORMERROR;\n\n    lp->sl_prefprog = ALLOC_CLEAR_MULT(regprog_T *, cnt);\n    if (lp->sl_prefprog == NULL)\n\treturn SP_OTHERERROR;\n    lp->sl_prefixcnt = cnt;\n\n    for (i = 0; i < cnt; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tn = getc(fd);\t\t\t\t\t// <condlen>\n\tif (n < 0 || n >= MAXWLEN)\n\t    return SP_FORMERROR;\n\n\t// When <condlen> is zero we have an empty condition.  Otherwise\n\t// compile the regexp program used to check for the condition.\n\tif (n > 0)\n\t{\n\t    buf[0] = '^';\t    // always match at one position only\n\t    p = buf + 1;\n\t    while (n-- > 0)\n\t\t*p++ = getc(fd);\t\t\t// <condstr>\n\t    *p = NUL;\n\t    lp->sl_prefprog[i] = vim_regcomp(buf, RE_MAGIC + RE_STRING);\n\t}\n    }\n    return 0;\n}\n\n/*\n * Read REP or REPSAL items section from \"fd\": <repcount> <rep> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_rep_section(FILE *fd, garray_T *gap, short *first)\n{\n    int\t\tcnt;\n    fromto_T\t*ftp;\n    int\t\ti;\n\n    cnt = get2c(fd);\t\t\t\t\t// <repcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    if (ga_grow(gap, cnt) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[gap->ga_len];\n\tftp->ft_from = read_cnt_string(fd, 1, &i);\n\tif (i < 0)\n\t    return i;\n\tif (i == 0)\n\t    return SP_FORMERROR;\n\tftp->ft_to = read_cnt_string(fd, 1, &i);\n\tif (i <= 0)\n\t{\n\t    vim_free(ftp->ft_from);\n\t    if (i < 0)\n\t\treturn i;\n\t    return SP_FORMERROR;\n\t}\n    }\n\n    // Fill the first-index table.\n    for (i = 0; i < 256; ++i)\n\tfirst[i] = -1;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[i];\n\tif (first[*ftp->ft_from] == -1)\n\t    first[*ftp->ft_from] = i;\n    }\n    return 0;\n}\n\n/*\n * Read SN_SAL section: <salflags> <salcount> <sal> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_sal_section(FILE *fd, slang_T *slang)\n{\n    int\t\ti;\n    int\t\tcnt;\n    garray_T\t*gap;\n    salitem_T\t*smp;\n    int\t\tccnt;\n    char_u\t*p;\n\n    slang->sl_sofo = FALSE;\n\n    i = getc(fd);\t\t\t\t// <salflags>\n    if (i & SAL_F0LLOWUP)\n\tslang->sl_followup = TRUE;\n    if (i & SAL_COLLAPSE)\n\tslang->sl_collapse = TRUE;\n    if (i & SAL_REM_ACCENTS)\n\tslang->sl_rem_accents = TRUE;\n\n    cnt = get2c(fd);\t\t\t\t// <salcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    gap = &slang->sl_sal;\n    ga_init2(gap, sizeof(salitem_T), 10);\n    if (ga_grow(gap, cnt + 1) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tint\tc = NUL;\n\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tccnt = getc(fd);\t\t\t// <salfromlen>\n\tif (ccnt < 0)\n\t    return SP_TRUNCERROR;\n\tif ((p = alloc(ccnt + 2)) == NULL)\n\t    return SP_OTHERERROR;\n\tsmp->sm_lead = p;\n\n\t// Read up to the first special char into sm_lead.\n\tfor (i = 0; i < ccnt; ++i)\n\t{\n\t    c = getc(fd);\t\t\t// <salfrom>\n\t    if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)\n\t\tbreak;\n\t    *p++ = c;\n\t}\n\tsmp->sm_leadlen = (int)(p - smp->sm_lead);\n\t*p++ = NUL;\n\n\t// Put (abc) chars in sm_oneof, if any.\n\tif (c == '(')\n\t{\n\t    smp->sm_oneof = p;\n\t    for (++i; i < ccnt; ++i)\n\t    {\n\t\tc = getc(fd);\t\t\t// <salfrom>\n\t\tif (c == ')')\n\t\t    break;\n\t\t*p++ = c;\n\t    }\n\t    *p++ = NUL;\n\t    if (++i < ccnt)\n\t\tc = getc(fd);\n\t}\n\telse\n\t    smp->sm_oneof = NULL;\n\n\t// Any following chars go in sm_rules.\n\tsmp->sm_rules = p;\n\tif (i < ccnt)\n\t    // store the char we got while checking for end of sm_lead\n\t    *p++ = c;\n\tfor (++i; i < ccnt; ++i)\n\t    *p++ = getc(fd);\t\t\t// <salfrom>\n\t*p++ = NUL;\n\n\t// <saltolen> <salto>\n\tsmp->sm_to = read_cnt_string(fd, 1, &ccnt);\n\tif (ccnt < 0)\n\t{\n\t    vim_free(smp->sm_lead);\n\t    return ccnt;\n\t}\n\n\tif (has_mbyte)\n\t{\n\t    // convert the multi-byte strings to wide char strings\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = mb_charlen(smp->sm_lead);\n\t    if (smp->sm_oneof == NULL)\n\t\tsmp->sm_oneof_w = NULL;\n\t    else\n\t\tsmp->sm_oneof_w = mb_str2wide(smp->sm_oneof);\n\t    if (smp->sm_to == NULL)\n\t\tsmp->sm_to_w = NULL;\n\t    else\n\t\tsmp->sm_to_w = mb_str2wide(smp->sm_to);\n\t    if (smp->sm_lead_w == NULL\n\t\t    || (smp->sm_oneof_w == NULL && smp->sm_oneof != NULL)\n\t\t    || (smp->sm_to_w == NULL && smp->sm_to != NULL))\n\t    {\n\t\tvim_free(smp->sm_lead);\n\t\tvim_free(smp->sm_to);\n\t\tvim_free(smp->sm_lead_w);\n\t\tvim_free(smp->sm_oneof_w);\n\t\tvim_free(smp->sm_to_w);\n\t\treturn SP_OTHERERROR;\n\t    }\n\t}\n    }\n\n    if (gap->ga_len > 0)\n    {\n\t// Add one extra entry to mark the end with an empty sm_lead.  Avoids\n\t// that we need to check the index every time.\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tif ((p = alloc(1)) == NULL)\n\t    return SP_OTHERERROR;\n\tp[0] = NUL;\n\tsmp->sm_lead = p;\n\tsmp->sm_leadlen = 0;\n\tsmp->sm_oneof = NULL;\n\tsmp->sm_rules = p;\n\tsmp->sm_to = NULL;\n\tif (has_mbyte)\n\t{\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = 0;\n\t    smp->sm_oneof_w = NULL;\n\t    smp->sm_to_w = NULL;\n\t}\n\t++gap->ga_len;\n    }\n\n    // Fill the first-index table.\n    set_sal_first(slang);\n\n    return 0;\n}\n\n/*\n * Read SN_WORDS: <word> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_words_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\tdone = 0;\n    int\t\ti;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    while (done < len)\n    {\n\t// Read one word at a time.\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t\treturn SP_TRUNCERROR;\n\t    word[i] = c;\n\t    if (word[i] == NUL)\n\t\tbreak;\n\t    if (i == MAXWLEN - 1)\n\t\treturn SP_FORMERROR;\n\t}\n\n\t// Init the count to 10.\n\tcount_common_word(lp, word, -1, 10);\n\tdone += i + 1;\n    }\n    return 0;\n}\n\n/*\n * SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * Return SP_*ERROR flags.\n */\n    static int\nread_sofo_section(FILE *fd, slang_T *slang)\n{\n    int\t\tcnt;\n    char_u\t*from, *to;\n    int\t\tres;\n\n    slang->sl_sofo = TRUE;\n\n    // <sofofromlen> <sofofrom>\n    from = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n\treturn cnt;\n\n    // <sofotolen> <sofoto>\n    to = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n    {\n\tvim_free(from);\n\treturn cnt;\n    }\n\n    // Store the info in slang->sl_sal and/or slang->sl_sal_first.\n    if (from != NULL && to != NULL)\n\tres = set_sofo(slang, from, to);\n    else if (from != NULL || to != NULL)\n\tres = SP_FORMERROR;    // only one of two strings is an error\n    else\n\tres = 0;\n\n    vim_free(from);\n    vim_free(to);\n    return res;\n}\n\n/*\n * Read the compound section from the .spl file:\n *\t<compmax> <compminlen> <compsylmax> <compoptions> <compflags>\n * Returns SP_*ERROR flags.\n */\n    static int\nread_compound(FILE *fd, slang_T *slang, int len)\n{\n    int\t\ttodo = len;\n    int\t\tc;\n    int\t\tatstart;\n    char_u\t*pat;\n    char_u\t*pp;\n    char_u\t*cp;\n    char_u\t*ap;\n    char_u\t*crp;\n    int\t\tcnt;\n    garray_T\t*gap;\n\n    if (todo < 2)\n\treturn SP_FORMERROR;\t// need at least two bytes\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compmax>\n    if (c < 2)\n\tc = MAXWLEN;\n    slang->sl_compmax = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compminlen>\n    if (c < 1)\n\tc = 0;\n    slang->sl_compminlen = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compsylmax>\n    if (c < 1)\n\tc = MAXWLEN;\n    slang->sl_compsylmax = c;\n\n    c = getc(fd);\t\t\t\t\t// <compoptions>\n    if (c != 0)\n\tungetc(c, fd);\t    // be backwards compatible with Vim 7.0b\n    else\n    {\n\t--todo;\n\tc = getc(fd);\t    // only use the lower byte for now\n\t--todo;\n\tslang->sl_compoptions = c;\n\n\tgap = &slang->sl_comppat;\n\tc = get2c(fd);\t\t\t\t\t// <comppatcount>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\ttodo -= 2;\n\tga_init2(gap, sizeof(char_u *), c);\n\tif (ga_grow(gap, c) == OK)\n\t    while (--c >= 0)\n\t    {\n\t\t((char_u **)(gap->ga_data))[gap->ga_len++] =\n\t\t\t\t\t\t  read_cnt_string(fd, 1, &cnt);\n\t\t\t\t\t    // <comppatlen> <comppattext>\n\t\tif (cnt < 0)\n\t\t    return cnt;\n\t\ttodo -= cnt + 1;\n\t    }\n    }\n    if (todo < 0)\n\treturn SP_FORMERROR;\n\n    // Turn the COMPOUNDRULE items into a regexp pattern:\n    // \"a[bc]/a*b+\" -> \"^\\(a[bc]\\|a*b\\+\\)$\".\n    // Inserting backslashes may double the length, \"^\\(\\)$<Nul>\" is 7 bytes.\n    // Conversion to utf-8 may double the size.\n    c = todo * 2 + 7;\n    if (enc_utf8)\n\tc += todo * 2;\n    pat = alloc(c);\n    if (pat == NULL)\n\treturn SP_OTHERERROR;\n\n    // We also need a list of all flags that can appear at the start and one\n    // for all flags.\n    cp = alloc(todo + 1);\n    if (cp == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compstartflags = cp;\n    *cp = NUL;\n\n    ap = alloc(todo + 1);\n    if (ap == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compallflags = ap;\n    *ap = NUL;\n\n    // And a list of all patterns in their original form, for checking whether\n    // compounding may work in match_compoundrule().  This is freed when we\n    // encounter a wildcard, the check doesn't work then.\n    crp = alloc(todo + 1);\n    slang->sl_comprules = crp;\n\n    pp = pat;\n    *pp++ = '^';\n    *pp++ = '\\\\';\n    *pp++ = '(';\n\n    atstart = 1;\n    while (todo-- > 0)\n    {\n\tc = getc(fd);\t\t\t\t\t// <compflags>\n\tif (c == EOF)\n\t{\n\t    vim_free(pat);\n\t    return SP_TRUNCERROR;\n\t}\n\n\t// Add all flags to \"sl_compallflags\".\n\tif (vim_strchr((char_u *)\"?*+[]/\", c) == NULL\n\t\t&& !byte_in_str(slang->sl_compallflags, c))\n\t{\n\t    *ap++ = c;\n\t    *ap = NUL;\n\t}\n\n\tif (atstart != 0)\n\t{\n\t    // At start of item: copy flags to \"sl_compstartflags\".  For a\n\t    // [abc] item set \"atstart\" to 2 and copy up to the ']'.\n\t    if (c == '[')\n\t\tatstart = 2;\n\t    else if (c == ']')\n\t\tatstart = 0;\n\t    else\n\t    {\n\t\tif (!byte_in_str(slang->sl_compstartflags, c))\n\t\t{\n\t\t    *cp++ = c;\n\t\t    *cp = NUL;\n\t\t}\n\t\tif (atstart == 1)\n\t\t    atstart = 0;\n\t    }\n\t}\n\n\t// Copy flag to \"sl_comprules\", unless we run into a wildcard.\n\tif (crp != NULL)\n\t{\n\t    if (c == '?' || c == '+' || c == '*')\n\t    {\n\t\tVIM_CLEAR(slang->sl_comprules);\n\t\tcrp = NULL;\n\t    }\n\t    else\n\t\t*crp++ = c;\n\t}\n\n\tif (c == '/')\t    // slash separates two items\n\t{\n\t    *pp++ = '\\\\';\n\t    *pp++ = '|';\n\t    atstart = 1;\n\t}\n\telse\t\t    // normal char, \"[abc]\" and '*' are copied as-is\n\t{\n\t    if (c == '?' || c == '+' || c == '~')\n\t\t*pp++ = '\\\\';\t    // \"a?\" becomes \"a\\?\", \"a+\" becomes \"a\\+\"\n\t    if (enc_utf8)\n\t\tpp += mb_char2bytes(c, pp);\n\t    else\n\t\t*pp++ = c;\n\t}\n    }\n\n    *pp++ = '\\\\';\n    *pp++ = ')';\n    *pp++ = '$';\n    *pp = NUL;\n\n    if (crp != NULL)\n\t*crp = NUL;\n\n    slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);\n    vim_free(pat);\n    if (slang->sl_compprog == NULL)\n\treturn SP_FORMERROR;\n\n    return 0;\n}\n\n/*\n * Set the SOFOFROM and SOFOTO items in language \"lp\".\n * Returns SP_*ERROR flags when there is something wrong.\n */\n    static int\nset_sofo(slang_T *lp, char_u *from, char_u *to)\n{\n    int\t\ti;\n\n    garray_T\t*gap;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tc;\n    int\t\t*inp;\n\n    if (has_mbyte)\n    {\n\t// Use \"sl_sal\" as an array with 256 pointers to a list of wide\n\t// characters.  The index is the low byte of the character.\n\t// The list contains from-to pairs with a terminating NUL.\n\t// sl_sal_first[] is used for latin1 \"from\" characters.\n\tgap = &lp->sl_sal;\n\tga_init2(gap, sizeof(int *), 1);\n\tif (ga_grow(gap, 256) == FAIL)\n\t    return SP_OTHERERROR;\n\tvim_memset(gap->ga_data, 0, sizeof(int *) * 256);\n\tgap->ga_len = 256;\n\n\t// First count the number of items for each list.  Temporarily use\n\t// sl_sal_first[] for this.\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    MB_CPTR_ADV(s);\n\t    if (c >= 256)\n\t\t++lp->sl_sal_first[c & 0xff];\n\t}\n\tif (*p != NUL || *s != NUL)\t    // lengths differ\n\t    return SP_FORMERROR;\n\n\t// Allocate the lists.\n\tfor (i = 0; i < 256; ++i)\n\t    if (lp->sl_sal_first[i] > 0)\n\t    {\n\t\tp = alloc(sizeof(int) * (lp->sl_sal_first[i] * 2 + 1));\n\t\tif (p == NULL)\n\t\t    return SP_OTHERERROR;\n\t\t((int **)gap->ga_data)[i] = (int *)p;\n\t\t*(int *)p = 0;\n\t    }\n\n\t// Put the characters up to 255 in sl_sal_first[] the rest in a sl_sal\n\t// list.\n\tvim_memset(lp->sl_sal_first, 0, sizeof(salfirst_T) * 256);\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    i = mb_cptr2char_adv(&s);\n\t    if (c >= 256)\n\t    {\n\t\t// Append the from-to chars at the end of the list with\n\t\t// the low byte.\n\t\tinp = ((int **)gap->ga_data)[c & 0xff];\n\t\twhile (*inp != 0)\n\t\t    ++inp;\n\t\t*inp++ = c;\t\t// from char\n\t\t*inp++ = i;\t\t// to char\n\t\t*inp++ = NUL;\t\t// NUL at the end\n\t    }\n\t    else\n\t\t// mapping byte to char is done in sl_sal_first[]\n\t\tlp->sl_sal_first[c] = i;\n\t}\n    }\n    else\n    {\n\t// mapping bytes to bytes is done in sl_sal_first[]\n\tif (STRLEN(from) != STRLEN(to))\n\t    return SP_FORMERROR;\n\n\tfor (i = 0; to[i] != NUL; ++i)\n\t    lp->sl_sal_first[from[i]] = to[i];\n\tlp->sl_sal.ga_len = 1;\t\t// indicates we have soundfolding\n    }\n\n    return 0;\n}\n\n/*\n * Fill the first-index table for \"lp\".\n */\n    static void\nset_sal_first(slang_T *lp)\n{\n    salfirst_T\t*sfirst;\n    int\t\ti;\n    salitem_T\t*smp;\n    int\t\tc;\n    garray_T\t*gap = &lp->sl_sal;\n\n    sfirst = lp->sl_sal_first;\n    for (i = 0; i < 256; ++i)\n\tsfirst[i] = -1;\n    smp = (salitem_T *)gap->ga_data;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tif (has_mbyte)\n\t    // Use the lowest byte of the first character.  For latin1 it's\n\t    // the character, for other encodings it should differ for most\n\t    // characters.\n\t    c = *smp[i].sm_lead_w & 0xff;\n\telse\n\t    c = *smp[i].sm_lead;\n\tif (sfirst[c] == -1)\n\t{\n\t    sfirst[c] = i;\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\tn;\n\n\t\t// Make sure all entries with this byte are following each\n\t\t// other.  Move the ones that are in the wrong position.  Do\n\t\t// keep the same ordering!\n\t\twhile (i + 1 < gap->ga_len\n\t\t\t\t       && (*smp[i + 1].sm_lead_w & 0xff) == c)\n\t\t    // Skip over entry with same index byte.\n\t\t    ++i;\n\n\t\tfor (n = 1; i + n < gap->ga_len; ++n)\n\t\t    if ((*smp[i + n].sm_lead_w & 0xff) == c)\n\t\t    {\n\t\t\tsalitem_T  tsal;\n\n\t\t\t// Move entry with same index byte after the entries\n\t\t\t// we already found.\n\t\t\t++i;\n\t\t\t--n;\n\t\t\ttsal = smp[i + n];\n\t\t\tmch_memmove(smp + i + 1, smp + i,\n\t\t\t\t\t\t       sizeof(salitem_T) * n);\n\t\t\tsmp[i] = tsal;\n\t\t    }\n\t    }\n\t}\n    }\n}\n\n/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */\n    static int *\nmb_str2wide(char_u *s)\n{\n    int\t\t*res;\n    char_u\t*p;\n    int\t\ti = 0;\n\n    res = ALLOC_MULT(int, mb_charlen(s) + 1);\n    if (res != NULL)\n    {\n\tfor (p = s; *p != NUL; )\n\t    res[i++] = mb_ptr2char_adv(&p);\n\tres[i] = NUL;\n    }\n    return res;\n}\n\n/*\n * Read a tree from the .spl or .sug file.\n * Allocates the memory and stores pointers in \"bytsp\" and \"idxsp\".\n * This is skipped when the tree has zero length.\n * Returns zero when OK, SP_ value for an error.\n */\n    static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    long\t*bytsp_len,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t// TRUE for the prefix tree\n    int\t\tprefixcnt)\t// when \"prefixtree\" is TRUE: prefix count\n{\n    long\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    // The tree size was computed when writing the file, so that we can\n    // allocate it as one long block. <nodecount>\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= LONG_MAX / (long)sizeof(int))\n\t// Invalid length, multiply with sizeof(int) would overflow.\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t// Allocate the byte array.\n\tbp = alloc(len);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tif (bytsp_len != NULL)\n\t    *bytsp_len = len;\n\n\t// Allocate the index array.\n\tip = lalloc_clear(len * sizeof(int), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t// Recursively read the tree and store it in the array.\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}\n\n/*\n * Read one row of siblings from the spell file and store it in the byte array\n * \"byts\" and index array \"idxs\".  Recursively read the children.\n *\n * NOTE: The code here must match put_node()!\n *\n * Returns the index (>= 0) following the siblings.\n * Returns SP_TRUNCERROR if the file is shorter than expected.\n * Returns SP_FORMERROR if there is a format error.\n */\n    static idx_T\nread_tree_node(\n    FILE\t*fd,\n    char_u\t*byts,\n    idx_T\t*idxs,\n    int\t\tmaxidx,\t\t    // size of arrays\n    idx_T\tstartidx,\t    // current index in \"byts\" and \"idxs\"\n    int\t\tprefixtree,\t    // TRUE for reading PREFIXTREE\n    int\t\tmaxprefcondnr)\t    // maximum for <prefcondnr>\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tn;\n    idx_T\tidx = startidx;\n    int\t\tc;\n    int\t\tc2;\n#define SHARED_MASK\t0x8000000\n\n    len = getc(fd);\t\t\t\t\t// <siblingcount>\n    if (len <= 0)\n\treturn SP_TRUNCERROR;\n\n    if (startidx + len >= maxidx)\n\treturn SP_FORMERROR;\n    byts[idx++] = len;\n\n    // Read the byte values, flag/region bytes and shared indexes.\n    for (i = 1; i <= len; ++i)\n    {\n\tc = getc(fd);\t\t\t\t\t// <byte>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\tif (c <= BY_SPECIAL)\n\t{\n\t    if (c == BY_NOFLAGS && !prefixtree)\n\t    {\n\t\t// No flags, all regions.\n\t\tidxs[idx] = 0;\n\t\tc = 0;\n\t    }\n\t    else if (c != BY_INDEX)\n\t    {\n\t\tif (prefixtree)\n\t\t{\n\t\t    // Read the optional pflags byte, the prefix ID and the\n\t\t    // condition nr.  In idxs[] store the prefix ID in the low\n\t\t    // byte, the condition index shifted up 8 bits, the flags\n\t\t    // shifted up 24 bits.\n\t\t    if (c == BY_FLAGS)\n\t\t\tc = getc(fd) << 24;\t\t// <pflags>\n\t\t    else\n\t\t\tc = 0;\n\n\t\t    c |= getc(fd);\t\t\t// <affixID>\n\n\t\t    n = get2c(fd);\t\t\t// <prefcondnr>\n\t\t    if (n >= maxprefcondnr)\n\t\t\treturn SP_FORMERROR;\n\t\t    c |= (n << 8);\n\t\t}\n\t\telse // c must be BY_FLAGS or BY_FLAGS2\n\t\t{\n\t\t    // Read flags and optional region and prefix ID.  In\n\t\t    // idxs[] the flags go in the low two bytes, region above\n\t\t    // that and prefix ID above the region.\n\t\t    c2 = c;\n\t\t    c = getc(fd);\t\t\t// <flags>\n\t\t    if (c2 == BY_FLAGS2)\n\t\t\tc = (getc(fd) << 8) + c;\t// <flags2>\n\t\t    if (c & WF_REGION)\n\t\t\tc = (getc(fd) << 16) + c;\t// <region>\n\t\t    if (c & WF_AFX)\n\t\t\tc = (getc(fd) << 24) + c;\t// <affixID>\n\t\t}\n\n\t\tidxs[idx] = c;\n\t\tc = 0;\n\t    }\n\t    else // c == BY_INDEX\n\t    {\n\t\t\t\t\t\t\t// <nodeidx>\n\t\tn = get3c(fd);\n\t\tif (n < 0 || n >= maxidx)\n\t\t    return SP_FORMERROR;\n\t\tidxs[idx] = n + SHARED_MASK;\n\t\tc = getc(fd);\t\t\t\t// <xbyte>\n\t    }\n\t}\n\tbyts[idx++] = c;\n    }\n\n    // Recursively read the children for non-shared siblings.\n    // Skip the end-of-word ones (zero byte value) and the shared ones (and\n    // remove SHARED_MASK)\n    for (i = 1; i <= len; ++i)\n\tif (byts[startidx + i] != 0)\n\t{\n\t    if (idxs[startidx + i] & SHARED_MASK)\n\t\tidxs[startidx + i] &= ~SHARED_MASK;\n\t    else\n\t    {\n\t\tidxs[startidx + i] = idx;\n\t\tidx = read_tree_node(fd, byts, idxs, maxidx, idx,\n\t\t\t\t\t\t     prefixtree, maxprefcondnr);\n\t\tif (idx < 0)\n\t\t    break;\n\t    }\n\t}\n\n    return idx;\n}\n\n/*\n * Reload the spell file \"fname\" if it's loaded.\n */\n    static void\nspell_reload_one(\n    char_u\t*fname,\n    int\t\tadded_word)\t// invoked through \"zg\"\n{\n    slang_T\t*slang;\n    int\t\tdidit = FALSE;\n\n    FOR_ALL_SPELL_LANGS(slang)\n    {\n\tif (fullpathcmp(fname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t{\n\t    slang_clear(slang);\n\t    if (spell_load_file(fname, NULL, slang, FALSE) == NULL)\n\t\t// reloading failed, clear the language\n\t\tslang_clear(slang);\n\t    redraw_all_later(SOME_VALID);\n\t    didit = TRUE;\n\t}\n    }\n\n    // When \"zg\" was used and the file wasn't loaded yet, should redo\n    // 'spelllang' to load it now.\n    if (added_word && !didit)\n\tdid_set_spelllang(curwin);\n}\n\n\n/*\n * Functions for \":mkspell\".\n */\n\n#define MAXLINELEN  500\t\t// Maximum length in bytes of a line in a .aff\n\t\t\t\t// and .dic file.\n/*\n * Main structure to store the contents of a \".aff\" file.\n */\ntypedef struct afffile_S\n{\n    char_u\t*af_enc;\t// \"SET\", normalized, alloc'ed string or NULL\n    int\t\taf_flagtype;\t// AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG\n    unsigned\taf_rare;\t// RARE ID for rare word\n    unsigned\taf_keepcase;\t// KEEPCASE ID for keep-case word\n    unsigned\taf_bad;\t\t// BAD ID for banned word\n    unsigned\taf_needaffix;\t// NEEDAFFIX ID\n    unsigned\taf_circumfix;\t// CIRCUMFIX ID\n    unsigned\taf_needcomp;\t// NEEDCOMPOUND ID\n    unsigned\taf_comproot;\t// COMPOUNDROOT ID\n    unsigned\taf_compforbid;\t// COMPOUNDFORBIDFLAG ID\n    unsigned\taf_comppermit;\t// COMPOUNDPERMITFLAG ID\n    unsigned\taf_nosuggest;\t// NOSUGGEST ID\n    int\t\taf_pfxpostpone;\t// postpone prefixes without chop string and\n\t\t\t\t// without flags\n    int\t\taf_ignoreextra;\t// IGNOREEXTRA present\n    hashtab_T\taf_pref;\t// hashtable for prefixes, affheader_T\n    hashtab_T\taf_suff;\t// hashtable for suffixes, affheader_T\n    hashtab_T\taf_comp;\t// hashtable for compound flags, compitem_T\n} afffile_T;\n\n#define AFT_CHAR\t0\t// flags are one character\n#define AFT_LONG\t1\t// flags are two characters\n#define AFT_CAPLONG\t2\t// flags are one or two characters\n#define AFT_NUM\t\t3\t// flags are numbers, comma separated\n\ntypedef struct affentry_S affentry_T;\n// Affix entry from \".aff\" file.  Used for prefixes and suffixes.\nstruct affentry_S\n{\n    affentry_T\t*ae_next;\t// next affix with same name/number\n    char_u\t*ae_chop;\t// text to chop off basic word (can be NULL)\n    char_u\t*ae_add;\t// text to add to basic word (can be NULL)\n    char_u\t*ae_flags;\t// flags on the affix (can be NULL)\n    char_u\t*ae_cond;\t// condition (NULL for \".\")\n    regprog_T\t*ae_prog;\t// regexp program for ae_cond or NULL\n    char\tae_compforbid;\t// COMPOUNDFORBIDFLAG found\n    char\tae_comppermit;\t// COMPOUNDPERMITFLAG found\n};\n\n#define AH_KEY_LEN 17\t\t// 2 x 8 bytes + NUL\n\n// Affix header from \".aff\" file.  Used for af_pref and af_suff.\ntypedef struct affheader_S\n{\n    char_u\tah_key[AH_KEY_LEN]; // key for hashtab == name of affix\n    unsigned\tah_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tah_newID;\t// prefix ID after renumbering; 0 if not used\n    int\t\tah_combine;\t// suffix may combine with prefix\n    int\t\tah_follows;\t// another affix block should be following\n    affentry_T\t*ah_first;\t// first affix entry\n} affheader_T;\n\n#define HI2AH(hi)   ((affheader_T *)(hi)->hi_key)\n\n// Flag used in compound items.\ntypedef struct compitem_S\n{\n    char_u\tci_key[AH_KEY_LEN]; // key for hashtab == name of compound\n    unsigned\tci_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tci_newID;\t// affix ID after renumbering.\n} compitem_T;\n\n#define HI2CI(hi)   ((compitem_T *)(hi)->hi_key)\n\n/*\n * Structure that is used to store the items in the word tree.  This avoids\n * the need to keep track of each allocated thing, everything is freed all at\n * once after \":mkspell\" is done.\n * Note: \"sb_next\" must be just before \"sb_data\" to make sure the alignment of\n * \"sb_data\" is correct for systems where pointers must be aligned on\n * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).\n */\n#define  SBLOCKSIZE 16000\t// size of sb_data\ntypedef struct sblock_S sblock_T;\nstruct sblock_S\n{\n    int\t\tsb_used;\t// nr of bytes already in use\n    sblock_T\t*sb_next;\t// next block in list\n    char_u\tsb_data[1];\t// data, actually longer\n};\n\n/*\n * A node in the tree.\n */\ntypedef struct wordnode_S wordnode_T;\nstruct wordnode_S\n{\n    union   // shared to save space\n    {\n\tchar_u\thashkey[6];\t// the hash key, only used while compressing\n\tint\tindex;\t\t// index in written nodes (valid after first\n\t\t\t\t// round)\n    } wn_u1;\n    union   // shared to save space\n    {\n\twordnode_T *next;\t// next node with same hash key\n\twordnode_T *wnode;\t// parent node that will write this node\n    } wn_u2;\n    wordnode_T\t*wn_child;\t// child (next byte in word)\n    wordnode_T  *wn_sibling;\t// next sibling (alternate byte in word,\n\t\t\t\t// always sorted)\n    int\t\twn_refs;\t// Nr. of references to this node.  Only\n\t\t\t\t// relevant for first node in a list of\n\t\t\t\t// siblings, in following siblings it is\n\t\t\t\t// always one.\n    char_u\twn_byte;\t// Byte for this node. NUL for word end\n\n    // Info for when \"wn_byte\" is NUL.\n    // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n    // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n    // \"wn_region\" the LSW of the wordnr.\n    char_u\twn_affixID;\t// supported/required prefix ID or 0\n    short_u\twn_flags;\t// WF_ flags\n    short\twn_region;\t// region mask\n\n#ifdef SPELL_PRINTTREE\n    int\t\twn_nr;\t\t// sequence nr for printing\n#endif\n};\n\n#define WN_MASK\t 0xffff\t\t// mask relevant bits of \"wn_flags\"\n\n#define HI2WN(hi)    (wordnode_T *)((hi)->hi_key)\n\n/*\n * Info used while reading the spell files.\n */\ntypedef struct spellinfo_S\n{\n    wordnode_T\t*si_foldroot;\t// tree with case-folded words\n    long\tsi_foldwcount;\t// nr of words in si_foldroot\n\n    wordnode_T\t*si_keeproot;\t// tree with keep-case words\n    long\tsi_keepwcount;\t// nr of words in si_keeproot\n\n    wordnode_T\t*si_prefroot;\t// tree with postponed prefixes\n\n    long\tsi_sugtree;\t// creating the soundfolding trie\n\n    sblock_T\t*si_blocks;\t// memory blocks used\n    long\tsi_blocks_cnt;\t// memory blocks allocated\n    int\t\tsi_did_emsg;\t// TRUE when ran out of memory\n\n    long\tsi_compress_cnt;    // words to add before lowering\n\t\t\t\t    // compression limit\n    wordnode_T\t*si_first_free; // List of nodes that have been freed during\n\t\t\t\t// compression, linked by \"wn_child\" field.\n    long\tsi_free_count;\t// number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n    int\t\tsi_wordnode_nr;\t// sequence nr for nodes\n#endif\n    buf_T\t*si_spellbuf;\t// buffer used to store soundfold word table\n\n    int\t\tsi_ascii;\t// handling only ASCII words\n    int\t\tsi_add;\t\t// addition file\n    int\t\tsi_clear_chartab;   // when TRUE clear char tables\n    int\t\tsi_region;\t// region mask\n    vimconv_T\tsi_conv;\t// for conversion to 'encoding'\n    int\t\tsi_memtot;\t// runtime memory used\n    int\t\tsi_verbose;\t// verbose messages\n    int\t\tsi_msg_count;\t// number of words added since last message\n    char_u\t*si_info;\t// info text chars or NULL\n    int\t\tsi_region_count; // number of regions supported (1 when there\n\t\t\t\t // are no regions)\n    char_u\tsi_region_name[MAXREGIONS * 2 + 1];\n\t\t\t\t// region names; used only if\n\t\t\t\t// si_region_count > 1)\n\n    garray_T\tsi_rep;\t\t// list of fromto_T entries from REP lines\n    garray_T\tsi_repsal;\t// list of fromto_T entries from REPSAL lines\n    garray_T\tsi_sal;\t\t// list of fromto_T entries from SAL lines\n    char_u\t*si_sofofr;\t// SOFOFROM text\n    char_u\t*si_sofoto;\t// SOFOTO text\n    int\t\tsi_nosugfile;\t// NOSUGFILE item found\n    int\t\tsi_nosplitsugs;\t// NOSPLITSUGS item found\n    int\t\tsi_nocompoundsugs; // NOCOMPOUNDSUGS item found\n    int\t\tsi_followup;\t// soundsalike: ?\n    int\t\tsi_collapse;\t// soundsalike: ?\n    hashtab_T\tsi_commonwords;\t// hashtable for common words\n    time_t\tsi_sugtime;\t// timestamp for .sug file\n    int\t\tsi_rem_accents;\t// soundsalike: remove accents\n    garray_T\tsi_map;\t\t// MAP info concatenated\n    char_u\t*si_midword;\t// MIDWORD chars or NULL\n    int\t\tsi_compmax;\t// max nr of words for compounding\n    int\t\tsi_compminlen;\t// minimal length for compounding\n    int\t\tsi_compsylmax;\t// max nr of syllables for compounding\n    int\t\tsi_compoptions;\t// COMP_ flags\n    garray_T\tsi_comppat;\t// CHECKCOMPOUNDPATTERN items, each stored as\n\t\t\t\t// a string\n    char_u\t*si_compflags;\t// flags used for compounding\n    char_u\tsi_nobreak;\t// NOBREAK\n    char_u\t*si_syllable;\t// syllable string\n    garray_T\tsi_prefcond;\t// table with conditions for postponed\n\t\t\t\t// prefixes, each stored as a string\n    int\t\tsi_newprefID;\t// current value for ah_newID\n    int\t\tsi_newcompID;\t// current value for compound ID\n} spellinfo_T;\n\nstatic int is_aff_rule(char_u **items, int itemcnt, char *rulename, int\t mincount);\nstatic void aff_process_flags(afffile_T *affile, affentry_T *entry);\nstatic int spell_info_item(char_u *s);\nstatic unsigned affitem2flag(int flagtype, char_u *item, char_u\t*fname, int lnum);\nstatic unsigned get_affitem(int flagtype, char_u **pp);\nstatic void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags);\nstatic void check_renumber(spellinfo_T *spin);\nstatic void aff_check_number(int spinval, int affval, char *name);\nstatic void aff_check_string(char_u *spinval, char_u *affval, char *name);\nstatic int str_equal(char_u *s1, char_u\t*s2);\nstatic void add_fromto(spellinfo_T *spin, garray_T *gap, char_u\t*from, char_u *to);\nstatic int sal_to_bool(char_u *s);\nstatic int get_affix_flags(afffile_T *affile, char_u *afflist);\nstatic int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic int store_aff_word(spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen);\nstatic void *getroom(spellinfo_T *spin, size_t len, int align);\nstatic char_u *getroom_save(spellinfo_T *spin, char_u *s);\nstatic int store_word(spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix);\nstatic int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID);\nstatic wordnode_T *get_wordnode(spellinfo_T *spin);\nstatic void free_wordnode(spellinfo_T *spin, wordnode_T *n);\nstatic void wordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name);\nstatic long node_compress(spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, long *tot);\nstatic int node_equal(wordnode_T *n1, wordnode_T *n2);\nstatic void clear_node(wordnode_T *node);\nstatic int put_node(FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree);\nstatic int sug_filltree(spellinfo_T *spin, slang_T *slang);\nstatic int sug_maketable(spellinfo_T *spin);\nstatic int sug_filltable(spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap);\nstatic int offset2bytes(int nr, char_u *buf);\nstatic void sug_write(spellinfo_T *spin, char_u *fname);\nstatic void spell_message(spellinfo_T *spin, char_u *str);\nstatic void init_spellfile(void);\n\n// In the postponed prefixes tree wn_flags is used to store the WFP_ flags,\n// but it must be negative to indicate the prefix tree to tree_add_word().\n// Use a negative number with the lower 8 bits zero.\n#define PFX_FLAGS\t(-256)\n\n// flags for \"condit\" argument of store_aff_word()\n#define CONDIT_COMB\t1\t// affix must combine\n#define CONDIT_CFIX\t2\t// affix must have CIRCUMFIX flag\n#define CONDIT_SUF\t4\t// add a suffix for matching flags\n#define CONDIT_AFF\t8\t// word already has an affix\n\n/*\n * Tunable parameters for when the tree is compressed.  Filled from the\n * 'mkspellmem' option.\n */\nstatic long compress_start = 30000;\t// memory / SBLOCKSIZE\nstatic long compress_inc = 100;\t\t// memory / SBLOCKSIZE\nstatic long compress_added = 500000;\t// word count\n\n/*\n * Check the 'mkspellmem' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\".\n */\n    int\nspell_check_msm(void)\n{\n    char_u\t*p = p_msm;\n    long\tstart = 0;\n    long\tincr = 0;\n    long\tadded = 0;\n\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    // block count = (value * 1024) / SBLOCKSIZE (but avoid overflow)\n    start = (getdigits(&p) * 10) / (SBLOCKSIZE / 102);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    added = getdigits(&p) * 1024;\n    if (*p != NUL)\n\treturn FAIL;\n\n    if (start == 0 || incr == 0 || added == 0 || incr > start)\n\treturn FAIL;\n\n    compress_start = start;\n    compress_inc = incr;\n    compress_added = added;\n    return OK;\n}\n\n#ifdef SPELL_PRINTTREE\n/*\n * For debugging the tree code: print the current tree in a (more or less)\n * readable format, so that we can see what happens when adding a word and/or\n * compressing the tree.\n * Based on code from Olaf Seibert.\n */\n#define PRINTLINESIZE\t1000\n#define PRINTWIDTH\t6\n\n#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\\n\t    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)\n\nstatic char line1[PRINTLINESIZE];\nstatic char line2[PRINTLINESIZE];\nstatic char line3[PRINTLINESIZE];\n\n    static void\nspell_clear_flags(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tnp->wn_u1.index = FALSE;\n\tspell_clear_flags(np->wn_child);\n    }\n}\n\n    static void\nspell_print_node(wordnode_T *node, int depth)\n{\n    if (node->wn_u1.index)\n    {\n\t// Done this node before, print the reference.\n\tPRINTSOME(line1, depth, \"(%d)\", node->wn_nr, 0);\n\tPRINTSOME(line2, depth, \"    \", 0, 0);\n\tPRINTSOME(line3, depth, \"    \", 0, 0);\n\tmsg(line1);\n\tmsg(line2);\n\tmsg(line3);\n    }\n    else\n    {\n\tnode->wn_u1.index = TRUE;\n\n\tif (node->wn_byte != NUL)\n\t{\n\t    if (node->wn_child != NULL)\n\t\tPRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);\n\t    else\n\t\t// Cannot happen?\n\t\tPRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);\n\t}\n\telse\n\t    PRINTSOME(line1, depth, \" $    \", 0, 0);\n\n\tPRINTSOME(line2, depth, \"%d/%d    \", node->wn_nr, node->wn_refs);\n\n\tif (node->wn_sibling != NULL)\n\t    PRINTSOME(line3, depth, \" |    \", 0, 0);\n\telse\n\t    PRINTSOME(line3, depth, \"      \", 0, 0);\n\n\tif (node->wn_byte == NUL)\n\t{\n\t    msg(line1);\n\t    msg(line2);\n\t    msg(line3);\n\t}\n\n\t// do the children\n\tif (node->wn_byte != NUL && node->wn_child != NULL)\n\t    spell_print_node(node->wn_child, depth + 1);\n\n\t// do the siblings\n\tif (node->wn_sibling != NULL)\n\t{\n\t    // get rid of all parent details except |\n\t    STRCPY(line1, line3);\n\t    STRCPY(line2, line3);\n\t    spell_print_node(node->wn_sibling, depth);\n\t}\n    }\n}\n\n    static void\nspell_print_tree(wordnode_T *root)\n{\n    if (root != NULL)\n    {\n\t// Clear the \"wn_u1.index\" fields, used to remember what has been\n\t// done.\n\tspell_clear_flags(root);\n\n\t// Recursively print the tree.\n\tspell_print_node(root, 0);\n    }\n}\n#endif // SPELL_PRINTTREE\n\n/*\n * Read the affix file \"fname\".\n * Returns an afffile_T, NULL for complete failure.\n */\n    static afffile_T *\nspell_read_aff(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    afffile_T\t*aff;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n#define MAXITEMCNT  30\n    char_u\t*(items[MAXITEMCNT]);\n    int\t\titemcnt;\n    char_u\t*p;\n    int\t\tlnum = 0;\n    affheader_T\t*cur_aff = NULL;\n    int\t\tdid_postpone_prefix = FALSE;\n    int\t\taff_todo = 0;\n    hashtab_T\t*tp;\n    char_u\t*low = NULL;\n    char_u\t*fol = NULL;\n    char_u\t*upp = NULL;\n    int\t\tdo_rep;\n    int\t\tdo_repsal;\n    int\t\tdo_sal;\n    int\t\tdo_mapline;\n    int\t\tfound_map = FALSE;\n    hashitem_T\t*hi;\n    int\t\tl;\n    int\t\tcompminlen = 0;\t\t// COMPOUNDMIN value\n    int\t\tcompsylmax = 0;\t\t// COMPOUNDSYLMAX value\n    int\t\tcompoptions = 0;\t// COMP_ flags\n    int\t\tcompmax = 0;\t\t// COMPOUNDWORDMAX value\n    char_u\t*compflags = NULL;\t// COMPOUNDFLAG and COMPOUNDRULE\n\t\t\t\t\t// concatenated\n    char_u\t*midword = NULL;\t// MIDWORD value\n    char_u\t*syllable = NULL;\t// SYLLABLE value\n    char_u\t*sofofrom = NULL;\t// SOFOFROM value\n    char_u\t*sofoto = NULL;\t\t// SOFOTO value\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn NULL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading affix file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // Only do REP lines when not done in another .aff file already.\n    do_rep = spin->si_rep.ga_len == 0;\n\n    // Only do REPSAL lines when not done in another .aff file already.\n    do_repsal = spin->si_repsal.ga_len == 0;\n\n    // Only do SAL lines when not done in another .aff file already.\n    do_sal = spin->si_sal.ga_len == 0;\n\n    // Only do MAP lines when not done in another .aff file already.\n    do_mapline = spin->si_map.ga_len == 0;\n\n    /*\n     * Allocate and init the afffile_T structure.\n     */\n    aff = (afffile_T *)getroom(spin, sizeof(afffile_T), TRUE);\n    if (aff == NULL)\n    {\n\tfclose(fd);\n\treturn NULL;\n    }\n    hash_init(&aff->af_pref);\n    hash_init(&aff->af_suff);\n    hash_init(&aff->af_comp);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\t// Split the line up in white separated items.  Put a NUL after each\n\t// item.\n\titemcnt = 0;\n\tfor (p = line; ; )\n\t{\n\t    while (*p != NUL && *p <= ' ')  // skip white space and CR/NL\n\t\t++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    if (itemcnt == MAXITEMCNT)\t    // too many items\n\t\tbreak;\n\t    items[itemcnt++] = p;\n\t    // A few items have arbitrary text argument, don't split them.\n\t    if (itemcnt == 2 && spell_info_item(items[0]))\n\t\twhile (*p >= ' ' || *p == TAB)    // skip until CR/NL\n\t\t    ++p;\n\t    else\n\t\twhile (*p > ' ')    // skip until white space or CR/NL\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *p++ = NUL;\n\t}\n\n\t// Handle non-empty lines.\n\tif (itemcnt > 0)\n\t{\n\t    if (is_aff_rule(items, itemcnt, \"SET\", 2) && aff->af_enc == NULL)\n\t    {\n\t\t// Setup for conversion from \"ENC\" to 'encoding'.\n\t\taff->af_enc = enc_canonize(items[1]);\n\t\tif (aff->af_enc != NULL && !spin->si_ascii\n\t\t\t&& convert_setup(&spin->si_conv, aff->af_enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t    smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t       fname, aff->af_enc, p_enc);\n\t\tspin->si_conv.vc_fail = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FLAG\", 2)\n\t\t\t\t\t      && aff->af_flagtype == AFT_CHAR)\n\t    {\n\t\tif (STRCMP(items[1], \"long\") == 0)\n\t\t    aff->af_flagtype = AFT_LONG;\n\t\telse if (STRCMP(items[1], \"num\") == 0)\n\t\t    aff->af_flagtype = AFT_NUM;\n\t\telse if (STRCMP(items[1], \"caplong\") == 0)\n\t\t    aff->af_flagtype = AFT_CAPLONG;\n\t\telse\n\t\t    smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t\tif (aff->af_rare != 0\n\t\t\t|| aff->af_keepcase != 0\n\t\t\t|| aff->af_bad != 0\n\t\t\t|| aff->af_needaffix != 0\n\t\t\t|| aff->af_circumfix != 0\n\t\t\t|| aff->af_needcomp != 0\n\t\t\t|| aff->af_comproot != 0\n\t\t\t|| aff->af_nosuggest != 0\n\t\t\t|| compflags != NULL\n\t\t\t|| aff->af_suff.ht_used > 0\n\t\t\t|| aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"FLAG after using flags in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t    }\n\t    else if (spell_info_item(items[0]))\n\t    {\n\t\t    p = (char_u *)getroom(spin,\n\t\t\t    (spin->si_info == NULL ? 0 : STRLEN(spin->si_info))\n\t\t\t    + STRLEN(items[0])\n\t\t\t    + STRLEN(items[1]) + 3, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (spin->si_info != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, spin->si_info);\n\t\t\t    STRCAT(p, \"\\n\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[0]);\n\t\t\tSTRCAT(p, \" \");\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tspin->si_info = p;\n\t\t    }\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MIDWORD\", 2)\n\t\t\t\t\t\t\t   && midword == NULL)\n\t    {\n\t\tmidword = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"TRY\", 2))\n\t    {\n\t\t// ignored, we look in the tree for what chars may appear\n\t    }\n\t    // TODO: remove \"RAR\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"RARE\", 2))\n\t\t\t\t\t\t\t && aff->af_rare == 0)\n\t    {\n\t\taff->af_rare = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    // TODO: remove \"KEP\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))\n\t\t\t\t\t\t     && aff->af_keepcase == 0)\n\t    {\n\t\taff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"FORBIDDENWORD\", 2))\n\t\t\t\t\t\t\t  && aff->af_bad == 0)\n\t    {\n\t\taff->af_bad = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)\n\t\t\t\t\t\t    && aff->af_needaffix == 0)\n\t    {\n\t\taff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)\n\t\t\t\t\t\t    && aff->af_circumfix == 0)\n\t    {\n\t\taff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)\n\t\t\t\t\t\t    && aff->af_nosuggest == 0)\n\t    {\n\t\taff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"ONLYINCOMPOUND\", 2))\n\t\t\t\t\t\t     && aff->af_needcomp == 0)\n\t    {\n\t\taff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)\n\t\t\t\t\t\t     && aff->af_comproot == 0)\n\t    {\n\t\taff->af_comproot = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_compforbid == 0)\n\t    {\n\t\taff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDPERMITFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_comppermit == 0)\n\t    {\n\t\taff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFLAG\", 2)\n\t\t\t\t\t\t\t && compflags == NULL)\n\t    {\n\t\t// Turn flag \"c\" into COMPOUNDRULE compatible string \"c+\",\n\t\t// \"Na\" into \"Na+\", \"1234\" into \"1234+\".\n\t\tp = getroom(spin, STRLEN(items[1]) + 2, FALSE);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCPY(p, items[1]);\n\t\t    STRCAT(p, \"+\");\n\t\t    compflags = p;\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULES\", 2))\n\t    {\n\t\t// We don't use the count, but do check that it's a number and\n\t\t// not COMPOUNDRULE mistyped.\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULE\", 2))\n\t    {\n\t\t// Don't use the first rule if it is a number.\n\t\tif (compflags != NULL || *skipdigits(items[1]) != NUL)\n\t\t{\n\t\t    // Concatenate this string to previously defined ones,\n\t\t    // using a slash to separate them.\n\t\t    l = (int)STRLEN(items[1]) + 1;\n\t\t    if (compflags != NULL)\n\t\t\tl += (int)STRLEN(compflags) + 1;\n\t\t    p = getroom(spin, l, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (compflags != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, compflags);\n\t\t\t    STRCAT(p, \"/\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tcompflags = p;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDWORDMAX\", 2)\n\t\t\t\t\t\t\t      && compmax == 0)\n\t    {\n\t\tcompmax = atoi((char *)items[1]);\n\t\tif (compmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDMIN\", 2)\n\t\t\t\t\t\t\t   && compminlen == 0)\n\t    {\n\t\tcompminlen = atoi((char *)items[1]);\n\t\tif (compminlen == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDSYLMAX\", 2)\n\t\t\t\t\t\t\t   && compsylmax == 0)\n\t    {\n\t\tcompsylmax = atoi((char *)items[1]);\n\t\tif (compsylmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDDUP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKDUP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDREP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKREP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDCASE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKCASE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDTRIPLE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKTRIPLE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))\n\t    {\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 3))\n\t    {\n\t\tgarray_T    *gap = &spin->si_comppat;\n\t\tint\t    i;\n\n\t\t// Only add the couple if it isn't already there.\n\t\tfor (i = 0; i < gap->ga_len - 1; i += 2)\n\t\t    if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0\n\t\t\t    && STRCMP(((char_u **)(gap->ga_data))[i + 1],\n\t\t\t\t\t\t\t       items[2]) == 0)\n\t\t\tbreak;\n\t\tif (i >= gap->ga_len && ga_grow(gap, 2) == OK)\n\t\t{\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[1]);\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SYLLABLE\", 2)\n\t\t\t\t\t\t\t  && syllable == NULL)\n\t    {\n\t\tsyllable = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOBREAK\", 1))\n\t    {\n\t\tspin->si_nobreak = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSPLITSUGS\", 1))\n\t    {\n\t\tspin->si_nosplitsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOCOMPOUNDSUGS\", 1))\n\t    {\n\t\tspin->si_nocompoundsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGFILE\", 1))\n\t    {\n\t\tspin->si_nosugfile = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"PFXPOSTPONE\", 1))\n\t    {\n\t\taff->af_pfxpostpone = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"IGNOREEXTRA\", 1))\n\t    {\n\t\taff->af_ignoreextra = TRUE;\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo == 0\n\t\t    && itemcnt >= 4)\n\t    {\n\t\tint\tlasti = 4;\n\t\tchar_u\tkey[AH_KEY_LEN];\n\n\t\tif (*items[0] == 'P')\n\t\t    tp = &aff->af_pref;\n\t\telse\n\t\t    tp = &aff->af_suff;\n\n\t\t// Myspell allows the same affix name to be used multiple\n\t\t// times.  The affix files that do this have an undocumented\n\t\t// \"S\" flag on all but the last block, thus we check for that\n\t\t// and store it in ah_follows.\n\t\tvim_strncpy(key, items[1], AH_KEY_LEN - 1);\n\t\thi = hash_find(tp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    cur_aff = HI2AH(hi);\n\t\t    if (cur_aff->ah_combine != (*items[2] == 'Y'))\n\t\t\tsmsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),\n\t\t\t\t\t\t   fname, lnum, items[1]);\n\t\t    if (!cur_aff->ah_follows)\n\t\t\tsmsg(_(\"Duplicate affix in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // New affix letter.\n\t\t    cur_aff = (affheader_T *)getroom(spin,\n\t\t\t\t\t\t   sizeof(affheader_T), TRUE);\n\t\t    if (cur_aff == NULL)\n\t\t\tbreak;\n\t\t    cur_aff->ah_flag = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    if (cur_aff->ah_flag == 0 || STRLEN(items[1]) >= AH_KEY_LEN)\n\t\t\tbreak;\n\t\t    if (cur_aff->ah_flag == aff->af_bad\n\t\t\t    || cur_aff->ah_flag == aff->af_rare\n\t\t\t    || cur_aff->ah_flag == aff->af_keepcase\n\t\t\t    || cur_aff->ah_flag == aff->af_needaffix\n\t\t\t    || cur_aff->ah_flag == aff->af_circumfix\n\t\t\t    || cur_aff->ah_flag == aff->af_nosuggest\n\t\t\t    || cur_aff->ah_flag == aff->af_needcomp\n\t\t\t    || cur_aff->ah_flag == aff->af_comproot)\n\t\t\tsmsg(_(\"Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t    STRCPY(cur_aff->ah_key, items[1]);\n\t\t    hash_add(tp, cur_aff->ah_key);\n\n\t\t    cur_aff->ah_combine = (*items[2] == 'Y');\n\t\t}\n\n\t\t// Check for the \"S\" flag, which apparently means that another\n\t\t// block with the same affix name is following.\n\t\tif (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0)\n\t\t{\n\t\t    ++lasti;\n\t\t    cur_aff->ah_follows = TRUE;\n\t\t}\n\t\telse\n\t\t    cur_aff->ah_follows = FALSE;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter.\n\t\tif (itemcnt > lasti && *items[lasti] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\tif (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)\n\t\t    smsg(_(\"Expected Y or N in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[2]);\n\n\t\tif (*items[0] == 'P' && aff->af_pfxpostpone)\n\t\t{\n\t\t    if (cur_aff->ah_newID == 0)\n\t\t    {\n\t\t\t// Use a new number in the .spl file later, to be able\n\t\t\t// to handle multiple .aff files.\n\t\t\tcheck_renumber(spin);\n\t\t\tcur_aff->ah_newID = ++spin->si_newprefID;\n\n\t\t\t// We only really use ah_newID if the prefix is\n\t\t\t// postponed.  We know that only after handling all\n\t\t\t// the items.\n\t\t\tdid_postpone_prefix = FALSE;\n\t\t    }\n\t\t    else\n\t\t\t// Did use the ID in a previous block.\n\t\t\tdid_postpone_prefix = TRUE;\n\t\t}\n\n\t\taff_todo = atoi((char *)items[3]);\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo > 0\n\t\t    && STRCMP(cur_aff->ah_key, items[1]) == 0\n\t\t    && itemcnt >= 5)\n\t    {\n\t\taffentry_T\t*aff_entry;\n\t\tint\t\tupper = FALSE;\n\t\tint\t\tlasti = 5;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter,\n\t\t// unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.\n\t\tif (itemcnt > lasti\n\t\t\t&& !aff->af_ignoreextra\n\t\t\t&& *items[lasti] != '#'\n\t\t\t&& (STRCMP(items[lasti], \"-\") != 0\n\t\t\t\t\t\t     || itemcnt != lasti + 1))\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\t// New item for an affix letter.\n\t\t--aff_todo;\n\t\taff_entry = (affentry_T *)getroom(spin,\n\t\t\t\t\t\t    sizeof(affentry_T), TRUE);\n\t\tif (aff_entry == NULL)\n\t\t    break;\n\n\t\tif (STRCMP(items[2], \"0\") != 0)\n\t\t    aff_entry->ae_chop = getroom_save(spin, items[2]);\n\t\tif (STRCMP(items[3], \"0\") != 0)\n\t\t{\n\t\t    aff_entry->ae_add = getroom_save(spin, items[3]);\n\n\t\t    // Recognize flags on the affix: abcd/XYZ\n\t\t    aff_entry->ae_flags = vim_strchr(aff_entry->ae_add, '/');\n\t\t    if (aff_entry->ae_flags != NULL)\n\t\t    {\n\t\t\t*aff_entry->ae_flags++ = NUL;\n\t\t\taff_process_flags(aff, aff_entry);\n\t\t    }\n\t\t}\n\n\t\t// Don't use an affix entry with non-ASCII characters when\n\t\t// \"spin->si_ascii\" is TRUE.\n\t\tif (!spin->si_ascii || !(has_non_ascii(aff_entry->ae_chop)\n\t\t\t\t\t  || has_non_ascii(aff_entry->ae_add)))\n\t\t{\n\t\t    aff_entry->ae_next = cur_aff->ah_first;\n\t\t    cur_aff->ah_first = aff_entry;\n\n\t\t    if (STRCMP(items[4], \".\") != 0)\n\t\t    {\n\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\taff_entry->ae_cond = getroom_save(spin, items[4]);\n\t\t\tif (*items[0] == 'P')\n\t\t\t    sprintf((char *)buf, \"^%s\", items[4]);\n\t\t\telse\n\t\t\t    sprintf((char *)buf, \"%s$\", items[4]);\n\t\t\taff_entry->ae_prog = vim_regcomp(buf,\n\t\t\t\t\t    RE_MAGIC + RE_STRING + RE_STRICT);\n\t\t\tif (aff_entry->ae_prog == NULL)\n\t\t\t    smsg(_(\"Broken condition in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[4]);\n\t\t    }\n\n\t\t    // For postponed prefixes we need an entry in si_prefcond\n\t\t    // for the condition.  Use an existing one if possible.\n\t\t    // Can't be done for an affix with flags, ignoring\n\t\t    // COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG.\n\t\t    if (*items[0] == 'P' && aff->af_pfxpostpone\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t    {\n\t\t\t// When the chop string is one lower-case letter and\n\t\t\t// the add string ends in the upper-case letter we set\n\t\t\t// the \"upper\" flag, clear \"ae_chop\" and remove the\n\t\t\t// letters from \"ae_add\".  The condition must either\n\t\t\t// be empty or start with the same letter.\n\t\t\tif (aff_entry->ae_chop != NULL\n\t\t\t\t&& aff_entry->ae_add != NULL\n\t\t\t\t&& aff_entry->ae_chop[(*mb_ptr2len)(\n\t\t\t\t\t\t   aff_entry->ae_chop)] == NUL)\n\t\t\t{\n\t\t\t    int\t\tc, c_up;\n\n\t\t\t    c = PTR2CHAR(aff_entry->ae_chop);\n\t\t\t    c_up = SPELL_TOUPPER(c);\n\t\t\t    if (c_up != c\n\t\t\t\t    && (aff_entry->ae_cond == NULL\n\t\t\t\t\t|| PTR2CHAR(aff_entry->ae_cond) == c))\n\t\t\t    {\n\t\t\t\tp = aff_entry->ae_add\n\t\t\t\t\t\t  + STRLEN(aff_entry->ae_add);\n\t\t\t\tMB_PTR_BACK(aff_entry->ae_add, p);\n\t\t\t\tif (PTR2CHAR(p) == c_up)\n\t\t\t\t{\n\t\t\t\t    upper = TRUE;\n\t\t\t\t    aff_entry->ae_chop = NULL;\n\t\t\t\t    *p = NUL;\n\n\t\t\t\t    // The condition is matched with the\n\t\t\t\t    // actual word, thus must check for the\n\t\t\t\t    // upper-case letter.\n\t\t\t\t    if (aff_entry->ae_cond != NULL)\n\t\t\t\t    {\n\t\t\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\t\t\tif (has_mbyte)\n\t\t\t\t\t{\n\t\t\t\t\t    onecap_copy(items[4], buf, TRUE);\n\t\t\t\t\t    aff_entry->ae_cond = getroom_save(\n\t\t\t\t\t\t\t\t   spin, buf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t    *aff_entry->ae_cond = c_up;\n\t\t\t\t\tif (aff_entry->ae_cond != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    sprintf((char *)buf, \"^%s\",\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t\t\t    vim_regfree(aff_entry->ae_prog);\n\t\t\t\t\t    aff_entry->ae_prog = vim_regcomp(\n\t\t\t\t\t\t    buf, RE_MAGIC + RE_STRING);\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (aff_entry->ae_chop == NULL\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t\t{\n\t\t\t    int\t\tidx;\n\t\t\t    char_u\t**pp;\n\t\t\t    int\t\tn;\n\n\t\t\t    // Find a previously used condition.\n\t\t\t    for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;\n\t\t\t\t\t\t\t\t\t--idx)\n\t\t\t    {\n\t\t\t\tp = ((char_u **)spin->si_prefcond.ga_data)[idx];\n\t\t\t\tif (str_equal(p, aff_entry->ae_cond))\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (idx < 0 && ga_grow(&spin->si_prefcond, 1) == OK)\n\t\t\t    {\n\t\t\t\t// Not found, add a new condition.\n\t\t\t\tidx = spin->si_prefcond.ga_len++;\n\t\t\t\tpp = ((char_u **)spin->si_prefcond.ga_data)\n\t\t\t\t\t\t\t\t\t+ idx;\n\t\t\t\tif (aff_entry->ae_cond == NULL)\n\t\t\t\t    *pp = NULL;\n\t\t\t\telse\n\t\t\t\t    *pp = getroom_save(spin,\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t    }\n\n\t\t\t    // Add the prefix to the prefix tree.\n\t\t\t    if (aff_entry->ae_add == NULL)\n\t\t\t\tp = (char_u *)\"\";\n\t\t\t    else\n\t\t\t\tp = aff_entry->ae_add;\n\n\t\t\t    // PFX_FLAGS is a negative number, so that\n\t\t\t    // tree_add_word() knows this is the prefix tree.\n\t\t\t    n = PFX_FLAGS;\n\t\t\t    if (!cur_aff->ah_combine)\n\t\t\t\tn |= WFP_NC;\n\t\t\t    if (upper)\n\t\t\t\tn |= WFP_UP;\n\t\t\t    if (aff_entry->ae_comppermit)\n\t\t\t\tn |= WFP_COMPPERMIT;\n\t\t\t    if (aff_entry->ae_compforbid)\n\t\t\t\tn |= WFP_COMPFORBID;\n\t\t\t    tree_add_word(spin, p, spin->si_prefroot, n,\n\t\t\t\t\t\t      idx, cur_aff->ah_newID);\n\t\t\t    did_postpone_prefix = TRUE;\n\t\t\t}\n\n\t\t\t// Didn't actually use ah_newID, backup si_newprefID.\n\t\t\tif (aff_todo == 0 && !did_postpone_prefix)\n\t\t\t{\n\t\t\t    --spin->si_newprefID;\n\t\t\t    cur_aff->ah_newID = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FOL\", 2) && fol == NULL)\n\t    {\n\t\tfol = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"LOW\", 2) && low == NULL)\n\t    {\n\t\tlow = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"UPP\", 2) && upp == NULL)\n\t    {\n\t\tupp = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"REP\", 2)\n\t\t     || is_aff_rule(items, itemcnt, \"REPSAL\", 2))\n\t    {\n\t\t// Ignore REP/REPSAL count\n\t\tif (!isdigit(*items[1]))\n\t\t    smsg(_(\"Expected REP(SAL) count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((STRCMP(items[0], \"REP\") == 0\n\t\t\t|| STRCMP(items[0], \"REPSAL\") == 0)\n\t\t    && itemcnt >= 3)\n\t    {\n\t\t// REP/REPSAL item\n\t\t// Myspell ignores extra arguments, we require it starts with\n\t\t// # to detect mistakes.\n\t\tif (itemcnt > 3 && items[3][0] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[3]);\n\t\tif (items[0][3] == 'S' ? do_repsal : do_rep)\n\t\t{\n\t\t    // Replace underscore with space (can't include a space\n\t\t    // directly).\n\t\t    for (p = items[1]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    for (p = items[2]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    add_fromto(spin, items[0][3] == 'S'\n\t\t\t\t\t ? &spin->si_repsal\n\t\t\t\t\t : &spin->si_rep, items[1], items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MAP\", 2))\n\t    {\n\t\t// MAP item or count\n\t\tif (!found_map)\n\t\t{\n\t\t    // First line contains the count.\n\t\t    found_map = TRUE;\n\t\t    if (!isdigit(*items[1]))\n\t\t\tsmsg(_(\"Expected MAP count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t}\n\t\telse if (do_mapline)\n\t\t{\n\t\t    int\t\tc;\n\n\t\t    // Check that every character appears only once.\n\t\t    for (p = items[1]; *p != NUL; )\n\t\t    {\n\t\t\tc = mb_ptr2char_adv(&p);\n\t\t\tif ((spin->si_map.ga_len > 0\n\t\t\t\t    && vim_strchr(spin->si_map.ga_data, c)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t\t|| vim_strchr(p, c) != NULL)\n\t\t\t    smsg(_(\"Duplicate character in MAP in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    }\n\n\t\t    // We simply concatenate all the MAP strings, separated by\n\t\t    // slashes.\n\t\t    ga_concat(&spin->si_map, items[1]);\n\t\t    ga_append(&spin->si_map, '/');\n\t\t}\n\t    }\n\t    // Accept \"SAL from to\" and \"SAL from to  #comment\".\n\t    else if (is_aff_rule(items, itemcnt, \"SAL\", 3))\n\t    {\n\t\tif (do_sal)\n\t\t{\n\t\t    // SAL item (sounds-a-like)\n\t\t    // Either one of the known keys or a from-to pair.\n\t\t    if (STRCMP(items[1], \"followup\") == 0)\n\t\t\tspin->si_followup = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"collapse_result\") == 0)\n\t\t\tspin->si_collapse = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"remove_accents\") == 0)\n\t\t\tspin->si_rem_accents = sal_to_bool(items[2]);\n\t\t    else\n\t\t\t// when \"to\" is \"_\" it means empty\n\t\t\tadd_fromto(spin, &spin->si_sal, items[1],\n\t\t\t\t     STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"\n\t\t\t\t\t\t\t\t: items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOFROM\", 2)\n\t\t\t\t\t\t\t  && sofofrom == NULL)\n\t    {\n\t\tsofofrom = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOTO\", 2)\n\t\t\t\t\t\t\t    && sofoto == NULL)\n\t    {\n\t\tsofoto = getroom_save(spin, items[1]);\n\t    }\n\t    else if (STRCMP(items[0], \"COMMON\") == 0)\n\t    {\n\t\tint\ti;\n\n\t\tfor (i = 1; i < itemcnt; ++i)\n\t\t{\n\t\t    if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,\n\t\t\t\t\t\t\t\t   items[i])))\n\t\t    {\n\t\t\tp = vim_strsave(items[i]);\n\t\t\tif (p == NULL)\n\t\t\t    break;\n\t\t\thash_add(&spin->si_commonwords, p);\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tsmsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[0]);\n\t}\n    }\n\n    if (fol != NULL || low != NULL || upp != NULL)\n    {\n\tif (spin->si_clear_chartab)\n\t{\n\t    // Clear the char type tables, don't want to use any of the\n\t    // currently used spell properties.\n\t    init_spell_chartab();\n\t    spin->si_clear_chartab = FALSE;\n\t}\n\n\t/*\n\t * Don't write a word table for an ASCII file, so that we don't check\n\t * for conflicts with a word table that matches 'encoding'.\n\t * Don't write one for utf-8 either, we use utf_*() and\n\t * mb_get_class(), the list of chars in the file will be incomplete.\n\t */\n\tif (!spin->si_ascii && !enc_utf8)\n\t{\n\t    if (fol == NULL || low == NULL || upp == NULL)\n\t\tsmsg(_(\"Missing FOL/LOW/UPP line in %s\"), fname);\n\t    else\n\t\t(void)set_spell_chartab(fol, low, upp);\n\t}\n\n\tvim_free(fol);\n\tvim_free(low);\n\tvim_free(upp);\n    }\n\n    // Use compound specifications of the .aff file for the spell info.\n    if (compmax != 0)\n    {\n\taff_check_number(spin->si_compmax, compmax, \"COMPOUNDWORDMAX\");\n\tspin->si_compmax = compmax;\n    }\n\n    if (compminlen != 0)\n    {\n\taff_check_number(spin->si_compminlen, compminlen, \"COMPOUNDMIN\");\n\tspin->si_compminlen = compminlen;\n    }\n\n    if (compsylmax != 0)\n    {\n\tif (syllable == NULL)\n\t    smsg(_(\"COMPOUNDSYLMAX used without SYLLABLE\"));\n\taff_check_number(spin->si_compsylmax, compsylmax, \"COMPOUNDSYLMAX\");\n\tspin->si_compsylmax = compsylmax;\n    }\n\n    if (compoptions != 0)\n    {\n\taff_check_number(spin->si_compoptions, compoptions, \"COMPOUND options\");\n\tspin->si_compoptions |= compoptions;\n    }\n\n    if (compflags != NULL)\n\tprocess_compflags(spin, aff, compflags);\n\n    // Check that we didn't use too many renumbered flags.\n    if (spin->si_newcompID < spin->si_newprefID)\n    {\n\tif (spin->si_newcompID == 127 || spin->si_newcompID == 255)\n\t    msg(_(\"Too many postponed prefixes\"));\n\telse if (spin->si_newprefID == 0 || spin->si_newprefID == 127)\n\t    msg(_(\"Too many compound flags\"));\n\telse\n\t    msg(_(\"Too many postponed prefixes and/or compound flags\"));\n    }\n\n    if (syllable != NULL)\n    {\n\taff_check_string(spin->si_syllable, syllable, \"SYLLABLE\");\n\tspin->si_syllable = syllable;\n    }\n\n    if (sofofrom != NULL || sofoto != NULL)\n    {\n\tif (sofofrom == NULL || sofoto == NULL)\n\t    smsg(_(\"Missing SOFO%s line in %s\"),\n\t\t\t\t     sofofrom == NULL ? \"FROM\" : \"TO\", fname);\n\telse if (spin->si_sal.ga_len > 0)\n\t    smsg(_(\"Both SAL and SOFO lines in %s\"), fname);\n\telse\n\t{\n\t    aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");\n\t    aff_check_string(spin->si_sofoto, sofoto, \"SOFOTO\");\n\t    spin->si_sofofr = sofofrom;\n\t    spin->si_sofoto = sofoto;\n\t}\n    }\n\n    if (midword != NULL)\n    {\n\taff_check_string(spin->si_midword, midword, \"MIDWORD\");\n\tspin->si_midword = midword;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n    return aff;\n}\n\n/*\n * Return TRUE when items[0] equals \"rulename\", there are \"mincount\" items or\n * a comment is following after item \"mincount\".\n */\n    static int\nis_aff_rule(\n    char_u\t**items,\n    int\t\titemcnt,\n    char\t*rulename,\n    int\t\tmincount)\n{\n    return (STRCMP(items[0], rulename) == 0\n\t    && (itemcnt == mincount\n\t\t|| (itemcnt > mincount && items[mincount][0] == '#')));\n}\n\n/*\n * For affix \"entry\" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from\n * ae_flags to ae_comppermit and ae_compforbid.\n */\n    static void\naff_process_flags(afffile_T *affile, affentry_T *entry)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n\n    if (entry->ae_flags != NULL\n\t\t&& (affile->af_compforbid != 0 || affile->af_comppermit != 0))\n    {\n\tfor (p = entry->ae_flags; *p != NUL; )\n\t{\n\t    prevp = p;\n\t    flag = get_affitem(affile->af_flagtype, &p);\n\t    if (flag == affile->af_comppermit || flag == affile->af_compforbid)\n\t    {\n\t\tSTRMOVE(prevp, p);\n\t\tp = prevp;\n\t\tif (flag == affile->af_comppermit)\n\t\t    entry->ae_comppermit = TRUE;\n\t\telse\n\t\t    entry->ae_compforbid = TRUE;\n\t    }\n\t    if (affile->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n\tif (*entry->ae_flags == NUL)\n\t    entry->ae_flags = NULL;\t// nothing left\n    }\n}\n\n/*\n * Return TRUE if \"s\" is the name of an info item in the affix file.\n */\n    static int\nspell_info_item(char_u *s)\n{\n    return STRCMP(s, \"NAME\") == 0\n\t|| STRCMP(s, \"HOME\") == 0\n\t|| STRCMP(s, \"VERSION\") == 0\n\t|| STRCMP(s, \"AUTHOR\") == 0\n\t|| STRCMP(s, \"EMAIL\") == 0\n\t|| STRCMP(s, \"COPYRIGHT\") == 0;\n}\n\n/*\n * Turn an affix flag name into a number, according to the FLAG type.\n * returns zero for failure.\n */\n    static unsigned\naffitem2flag(\n    int\t\tflagtype,\n    char_u\t*item,\n    char_u\t*fname,\n    int\t\tlnum)\n{\n    unsigned\tres;\n    char_u\t*p = item;\n\n    res = get_affitem(flagtype, &p);\n    if (res == 0)\n    {\n\tif (flagtype == AFT_NUM)\n\t    smsg(_(\"Flag is not a number in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n\telse\n\t    smsg(_(\"Illegal flag in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n    }\n    if (*p != NUL)\n    {\n\tsmsg(_(e_affname), fname, lnum, item);\n\treturn 0;\n    }\n\n    return res;\n}\n\n/*\n * Get one affix name from \"*pp\" and advance the pointer.\n * Returns ZERO_FLAG for \"0\".\n * Returns zero for an error, still advances the pointer then.\n */\n    static unsigned\nget_affitem(int flagtype, char_u **pp)\n{\n    int\t\tres;\n\n    if (flagtype == AFT_NUM)\n    {\n\tif (!VIM_ISDIGIT(**pp))\n\t{\n\t    ++*pp;\t// always advance, avoid getting stuck\n\t    return 0;\n\t}\n\tres = getdigits(pp);\n\tif (res == 0)\n\t    res = ZERO_FLAG;\n    }\n    else\n    {\n\tres = mb_ptr2char_adv(pp);\n\tif (flagtype == AFT_LONG || (flagtype == AFT_CAPLONG\n\t\t\t\t\t\t && res >= 'A' && res <= 'Z'))\n\t{\n\t    if (**pp == NUL)\n\t\treturn 0;\n\t    res = mb_ptr2char_adv(pp) + (res << 16);\n\t}\n    }\n    return res;\n}\n\n/*\n * Process the \"compflags\" string used in an affix file and append it to\n * spin->si_compflags.\n * The processing involves changing the affix names to ID numbers, so that\n * they fit in one byte.\n */\n    static void\nprocess_compflags(\n    spellinfo_T\t*spin,\n    afffile_T\t*aff,\n    char_u\t*compflags)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n    compitem_T\t*ci;\n    int\t\tid;\n    int\t\tlen;\n    char_u\t*tp;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    // Make room for the old and the new compflags, concatenated with a / in\n    // between.  Processing it makes it shorter, but we don't know by how\n    // much, thus allocate the maximum.\n    len = (int)STRLEN(compflags) + 1;\n    if (spin->si_compflags != NULL)\n\tlen += (int)STRLEN(spin->si_compflags) + 1;\n    p = getroom(spin, len, FALSE);\n    if (p == NULL)\n\treturn;\n    if (spin->si_compflags != NULL)\n    {\n\tSTRCPY(p, spin->si_compflags);\n\tSTRCAT(p, \"/\");\n    }\n    spin->si_compflags = p;\n    tp = p + STRLEN(p);\n\n    for (p = compflags; *p != NUL; )\n    {\n\tif (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)\n\t    // Copy non-flag characters directly.\n\t    *tp++ = *p++;\n\telse\n\t{\n\t    // First get the flag number, also checks validity.\n\t    prevp = p;\n\t    flag = get_affitem(aff->af_flagtype, &p);\n\t    if (flag != 0)\n\t    {\n\t\t// Find the flag in the hashtable.  If it was used before, use\n\t\t// the existing ID.  Otherwise add a new entry.\n\t\tvim_strncpy(key, prevp, p - prevp);\n\t\thi = hash_find(&aff->af_comp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    id = HI2CI(hi)->ci_newID;\n\t\telse\n\t\t{\n\t\t    ci = (compitem_T *)getroom(spin, sizeof(compitem_T), TRUE);\n\t\t    if (ci == NULL)\n\t\t\tbreak;\n\t\t    STRCPY(ci->ci_key, key);\n\t\t    ci->ci_flag = flag;\n\t\t    // Avoid using a flag ID that has a special meaning in a\n\t\t    // regexp (also inside []).\n\t\t    do\n\t\t    {\n\t\t\tcheck_renumber(spin);\n\t\t\tid = spin->si_newcompID--;\n\t\t    } while (vim_strchr((char_u *)\"/?*+[]\\\\-^\", id) != NULL);\n\t\t    ci->ci_newID = id;\n\t\t    hash_add(&aff->af_comp, ci->ci_key);\n\t\t}\n\t\t*tp++ = id;\n\t    }\n\t    if (aff->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n    }\n\n    *tp = NUL;\n}\n\n/*\n * Check that the new IDs for postponed affixes and compounding don't overrun\n * each other.  We have almost 255 available, but start at 0-127 to avoid\n * using two bytes for utf-8.  When the 0-127 range is used up go to 128-255.\n * When that is used up an error message is given.\n */\n    static void\ncheck_renumber(spellinfo_T *spin)\n{\n    if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)\n    {\n\tspin->si_newprefID = 127;\n\tspin->si_newcompID = 255;\n    }\n}\n\n/*\n * Return TRUE if flag \"flag\" appears in affix list \"afflist\".\n */\n    static int\nflag_in_afflist(int flagtype, char_u *afflist, unsigned flag)\n{\n    char_u\t*p;\n    unsigned\tn;\n\n    switch (flagtype)\n    {\n\tcase AFT_CHAR:\n\t    return vim_strchr(afflist, flag) != NULL;\n\n\tcase AFT_CAPLONG:\n\tcase AFT_LONG:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = mb_ptr2char_adv(&p);\n\t\tif ((flagtype == AFT_LONG || (n >= 'A' && n <= 'Z'))\n\t\t\t\t\t\t\t\t && *p != NUL)\n\t\t    n = mb_ptr2char_adv(&p) + (n << 16);\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t    }\n\t    break;\n\n\tcase AFT_NUM:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = getdigits(&p);\n\t\tif (n == 0)\n\t\t    n = ZERO_FLAG;\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t\tif (*p != NUL)\t// skip over comma\n\t\t    ++p;\n\t    }\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" numbers are set and not the same.\n */\n    static void\naff_check_number(int spinval, int affval, char *name)\n{\n    if (spinval != 0 && spinval != affval)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" strings are set and not the same.\n */\n    static void\naff_check_string(char_u *spinval, char_u *affval, char *name)\n{\n    if (spinval != NULL && STRCMP(spinval, affval) != 0)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Return TRUE if strings \"s1\" and \"s2\" are equal.  Also consider both being\n * NULL as equal.\n */\n    static int\nstr_equal(char_u *s1, char_u *s2)\n{\n    if (s1 == NULL || s2 == NULL)\n\treturn s1 == s2;\n    return STRCMP(s1, s2) == 0;\n}\n\n/*\n * Add a from-to item to \"gap\".  Used for REP and SAL items.\n * They are stored case-folded.\n */\n    static void\nadd_fromto(\n    spellinfo_T\t*spin,\n    garray_T\t*gap,\n    char_u\t*from,\n    char_u\t*to)\n{\n    fromto_T\t*ftp;\n    char_u\tword[MAXWLEN];\n\n    if (ga_grow(gap, 1) == OK)\n    {\n\tftp = ((fromto_T *)gap->ga_data) + gap->ga_len;\n\t(void)spell_casefold(curwin, from, (int)STRLEN(from), word, MAXWLEN);\n\tftp->ft_from = getroom_save(spin, word);\n\t(void)spell_casefold(curwin, to, (int)STRLEN(to), word, MAXWLEN);\n\tftp->ft_to = getroom_save(spin, word);\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Convert a boolean argument in a SAL line to TRUE or FALSE;\n */\n    static int\nsal_to_bool(char_u *s)\n{\n    return STRCMP(s, \"1\") == 0 || STRCMP(s, \"true\") == 0;\n}\n\n/*\n * Free the structure filled by spell_read_aff().\n */\n    static void\nspell_free_aff(afffile_T *aff)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n\n    vim_free(aff->af_enc);\n\n    // All this trouble to free the \"ae_prog\" items...\n    for (ht = &aff->af_pref; ; ht = &aff->af_suff)\n    {\n\ttodo = (int)ht->ht_used;\n\tfor (hi = ht->ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tah = HI2AH(hi);\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t    vim_regfree(ae->ae_prog);\n\t    }\n\t}\n\tif (ht == &aff->af_suff)\n\t    break;\n    }\n\n    hash_clear(&aff->af_pref);\n    hash_clear(&aff->af_suff);\n    hash_clear(&aff->af_comp);\n}\n\n/*\n * Read dictionary file \"fname\".\n * Returns OK or FAIL;\n */\n    static int\nspell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)\n{\n    hashtab_T\tht;\n    char_u\tline[MAXLINELEN];\n    char_u\t*p;\n    char_u\t*afflist;\n    char_u\tstore_afflist[MAXWLEN];\n    int\t\tpfxlen;\n    int\t\tneed_affix;\n    char_u\t*dw;\n    char_u\t*pc;\n    char_u\t*w;\n    int\t\tl;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    FILE\t*fd;\n    int\t\tlnum = 1;\n    int\t\tnon_ascii = 0;\n    int\t\tretval = OK;\n    char_u\tmessage[MAXLINELEN + MAXWLEN];\n    int\t\tflags;\n    int\t\tduplicate = 0;\n    time_T\tlast_msg_time = 0;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // The hashtable is only used to detect duplicated words.\n    hash_init(&ht);\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Reading dictionary file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // start with a message for the first line\n    spin->si_msg_count = 999999;\n\n    // Read and ignore the first line: word count.\n    if (vim_fgets(line, MAXLINELEN, fd) || !vim_isdigit(*skipwhite(line)))\n\tsemsg(_(e_no_word_count_in_str), fname);\n\n    /*\n     * Read all the lines in the file one by one.\n     * The words are converted to 'encoding' here, before being added to\n     * the hashtable.\n     */\n    while (!vim_fgets(line, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\tif (line[0] == '#' || line[0] == '/')\n\t    continue;\t// comment line\n\n\t// Remove CR, LF and white space from the end.  White space halfway\n\t// the word is kept to allow e.g., \"et al.\".\n\tl = (int)STRLEN(line);\n\twhile (l > 0 && line[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty line\n\tline[l] = NUL;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, line, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\tcontinue;\n\t    }\n\t    w = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    w = line;\n\t}\n\n\t// Truncate the word at the \"/\", set \"afflist\" to what follows.\n\t// Replace \"\\/\" by \"/\" and \"\\\\\" by \"\\\".\n\tafflist = NULL;\n\tfor (p = w; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (*p == '\\\\' && (p[1] == '\\\\' || p[1] == '/'))\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '/')\n\t    {\n\t\t*p = NUL;\n\t\tafflist = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(w))\n\t{\n\t    ++non_ascii;\n\t    vim_free(pc);\n\t    continue;\n\t}\n\n\t// This takes time, print a message every 10000 words, but not more\n\t// often than once per second.\n\tif (spin->si_verbose && spin->si_msg_count > 10000)\n\t{\n\t    spin->si_msg_count = 0;\n\t    if (vim_time() > last_msg_time)\n\t    {\n\t\tlast_msg_time = vim_time();\n\t\tvim_snprintf((char *)message, sizeof(message),\n\t\t\t_(\"line %6d, word %6ld - %s\"),\n\t\t\t   lnum, spin->si_foldwcount + spin->si_keepwcount, w);\n\t\tmsg_start();\n\t\tmsg_outtrans_long_attr(message, 0);\n\t\tmsg_clr_eos();\n\t\tmsg_didout = FALSE;\n\t\tmsg_col = 0;\n\t\tout_flush();\n\t    }\n\t}\n\n\t// Store the word in the hashtable to be able to find duplicates.\n\tdw = getroom_save(spin, w);\n\tif (dw == NULL)\n\t{\n\t    retval = FAIL;\n\t    vim_free(pc);\n\t    break;\n\t}\n\n\thash = hash_hash(dw);\n\thi = hash_lookup(&ht, dw, hash);\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    if (p_verbose > 0)\n\t\tsmsg(_(\"Duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    else if (duplicate == 0)\n\t\tsmsg(_(\"First duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    ++duplicate;\n\t}\n\telse\n\t    hash_add_item(&ht, hi, dw, hash);\n\n\tflags = 0;\n\tstore_afflist[0] = NUL;\n\tpfxlen = 0;\n\tneed_affix = FALSE;\n\tif (afflist != NULL)\n\t{\n\t    // Extract flags from the affix list.\n\t    flags |= get_affix_flags(affile, afflist);\n\n\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_needaffix))\n\t\tneed_affix = TRUE;\n\n\t    if (affile->af_pfxpostpone)\n\t\t// Need to store the list of prefix IDs with the word.\n\t\tpfxlen = get_pfxlist(affile, afflist, store_afflist);\n\n\t    if (spin->si_compflags != NULL)\n\t\t// Need to store the list of compound flags with the word.\n\t\t// Concatenate them to the list of prefix IDs.\n\t\tget_compflags(affile, afflist, store_afflist + pfxlen);\n\t}\n\n\t// Add the word to the word tree(s).\n\tif (store_word(spin, dw, flags, spin->si_region,\n\t\t\t\t\t   store_afflist, need_affix) == FAIL)\n\t    retval = FAIL;\n\n\tif (afflist != NULL)\n\t{\n\t    // Find all matching suffixes and add the resulting words.\n\t    // Additionally do matching prefixes that combine.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t   &affile->af_suff, &affile->af_pref,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\n\t    // Find all matching prefixes and add the resulting words.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t  &affile->af_pref, NULL,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\t}\n\n\tvim_free(pc);\n    }\n\n    if (duplicate > 0)\n\tsmsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);\n    if (spin->si_ascii && non_ascii > 0)\n\tsmsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),\n\t\t\t\t\t\t\t    non_ascii, fname);\n    hash_clear(&ht);\n\n    fclose(fd);\n    return retval;\n}\n\n/*\n * Check for affix flags in \"afflist\" that are turned into word flags.\n * Return WF_ flags.\n */\n    static int\nget_affix_flags(afffile_T *affile, char_u *afflist)\n{\n    int\t\tflags = 0;\n\n    if (affile->af_keepcase != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_keepcase))\n\tflags |= WF_KEEPCAP | WF_FIXCAP;\n    if (affile->af_rare != 0 && flag_in_afflist(\n\t\t\t       affile->af_flagtype, afflist, affile->af_rare))\n\tflags |= WF_RARE;\n    if (affile->af_bad != 0 && flag_in_afflist(\n\t\t\t\taffile->af_flagtype, afflist, affile->af_bad))\n\tflags |= WF_BANNED;\n    if (affile->af_needcomp != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_needcomp))\n\tflags |= WF_NEEDCOMP;\n    if (affile->af_comproot != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_comproot))\n\tflags |= WF_COMPROOT;\n    if (affile->af_nosuggest != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_nosuggest))\n\tflags |= WF_NOSUGGEST;\n    return flags;\n}\n\n/*\n * Get the list of prefix IDs from the affix list \"afflist\".\n * Used for PFXPOSTPONE.\n * Put the resulting flags in \"store_afflist[MAXWLEN]\" with a terminating NUL\n * and return the number of affixes.\n */\n    static int\nget_pfxlist(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    int\t\tid;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a postponed prefix flag if it appears in \"af_pref\"\n\t    // and its ID is not zero.\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_pref, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tid = HI2AH(hi)->ah_newID;\n\t\tif (id != 0)\n\t\t    store_afflist[cnt++] = id;\n\t    }\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n    return cnt;\n}\n\n/*\n * Get the list of compound IDs from the affix list \"afflist\" that are used\n * for compound words.\n * Puts the flags in \"store_afflist[]\".\n */\n    static void\nget_compflags(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a compound flag if it appears in \"af_comp\".\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_comp, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\tstore_afflist[cnt++] = HI2CI(hi)->ci_newID;\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n}\n\n/*\n * Apply affixes to a word and store the resulting words.\n * \"ht\" is the hashtable with affentry_T that need to be applied, either\n * prefixes or suffixes.\n * \"xht\", when not NULL, is the prefix hashtable, to be used additionally on\n * the resulting words for combining affixes.\n *\n * Returns FAIL when out of memory.\n */\n    static int\nstore_aff_word(\n    spellinfo_T\t*spin,\t\t// spell info\n    char_u\t*word,\t\t// basic word start\n    char_u\t*afflist,\t// list of names of supported affixes\n    afffile_T\t*affile,\n    hashtab_T\t*ht,\n    hashtab_T\t*xht,\n    int\t\tcondit,\t\t// CONDIT_SUF et al.\n    int\t\tflags,\t\t// flags for the word\n    char_u\t*pfxlist,\t// list of prefix IDs\n    int\t\tpfxlen)\t\t// nr of flags in \"pfxlist\" for prefixes, rest\n\t\t\t\t// is compound flags\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n    char_u\tnewword[MAXWLEN];\n    int\t\tretval = OK;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tuse_flags;\n    char_u\t*use_pfxlist;\n    int\t\tuse_pfxlen;\n    int\t\tneed_affix;\n    char_u\tstore_afflist[MAXWLEN];\n    char_u\tpfx_pfxlist[MAXWLEN];\n    size_t\twordlen = STRLEN(word);\n    int\t\tuse_condit;\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ah = HI2AH(hi);\n\n\t    // Check that the affix combines, if required, and that the word\n\t    // supports this affix.\n\t    if (((condit & CONDIT_COMB) == 0 || ah->ah_combine)\n\t\t    && flag_in_afflist(affile->af_flagtype, afflist,\n\t\t\t\t\t\t\t\t ah->ah_flag))\n\t    {\n\t\t// Loop over all affix entries with this name.\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t{\n\t\t    // Check the condition.  It's not logical to match case\n\t\t    // here, but it is required for compatibility with\n\t\t    // Myspell.\n\t\t    // Another requirement from Myspell is that the chop\n\t\t    // string is shorter than the word itself.\n\t\t    // For prefixes, when \"PFXPOSTPONE\" was used, only do\n\t\t    // prefixes with a chop string and/or flags.\n\t\t    // When a previously added affix had CIRCUMFIX this one\n\t\t    // must have it too, if it had not then this one must not\n\t\t    // have one either.\n\t\t    if ((xht != NULL || !affile->af_pfxpostpone\n\t\t\t\t|| ae->ae_chop != NULL\n\t\t\t\t|| ae->ae_flags != NULL)\n\t\t\t    && (ae->ae_chop == NULL\n\t\t\t\t|| STRLEN(ae->ae_chop) < wordlen)\n\t\t\t    && (ae->ae_prog == NULL\n\t\t\t\t|| vim_regexec_prog(&ae->ae_prog, FALSE,\n\t\t\t\t\t\t\t    word, (colnr_T)0))\n\t\t\t    && (((condit & CONDIT_CFIX) == 0)\n\t\t\t\t== ((condit & CONDIT_AFF) == 0\n\t\t\t\t    || ae->ae_flags == NULL\n\t\t\t\t    || !flag_in_afflist(affile->af_flagtype,\n\t\t\t\t\tae->ae_flags, affile->af_circumfix))))\n\t\t    {\n\t\t\t// Match.  Remove the chop and add the affix.\n\t\t\tif (xht == NULL)\n\t\t\t{\n\t\t\t    // prefix: chop/add at the start of the word\n\t\t\t    if (ae->ae_add == NULL)\n\t\t\t\t*newword = NUL;\n\t\t\t    else\n\t\t\t\tvim_strncpy(newword, ae->ae_add, MAXWLEN - 1);\n\t\t\t    p = word;\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Skip chop string.\n\t\t\t\tif (has_mbyte)\n\t\t\t\t{\n\t\t\t\t    i = mb_charlen(ae->ae_chop);\n\t\t\t\t    for ( ; i > 0; --i)\n\t\t\t\t\tMB_PTR_ADV(p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    p += STRLEN(ae->ae_chop);\n\t\t\t    }\n\t\t\t    STRCAT(newword, p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // suffix: chop/add at the end of the word\n\t\t\t    vim_strncpy(newword, word, MAXWLEN - 1);\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Remove chop string.\n\t\t\t\tp = newword + STRLEN(newword);\n\t\t\t\ti = (int)MB_CHARLEN(ae->ae_chop);\n\t\t\t\tfor ( ; i > 0; --i)\n\t\t\t\t    MB_PTR_BACK(newword, p);\n\t\t\t\t*p = NUL;\n\t\t\t    }\n\t\t\t    if (ae->ae_add != NULL)\n\t\t\t\tSTRCAT(newword, ae->ae_add);\n\t\t\t}\n\n\t\t\tuse_flags = flags;\n\t\t\tuse_pfxlist = pfxlist;\n\t\t\tuse_pfxlen = pfxlen;\n\t\t\tneed_affix = FALSE;\n\t\t\tuse_condit = condit | CONDIT_COMB | CONDIT_AFF;\n\t\t\tif (ae->ae_flags != NULL)\n\t\t\t{\n\t\t\t    // Extract flags from the affix list.\n\t\t\t    use_flags |= get_affix_flags(affile, ae->ae_flags);\n\n\t\t\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_needaffix))\n\t\t\t\tneed_affix = TRUE;\n\n\t\t\t    // When there is a CIRCUMFIX flag the other affix\n\t\t\t    // must also have it and we don't add the word\n\t\t\t    // with one affix.\n\t\t\t    if (affile->af_circumfix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_circumfix))\n\t\t\t    {\n\t\t\t\tuse_condit |= CONDIT_CFIX;\n\t\t\t\tif ((condit & CONDIT_CFIX) == 0)\n\t\t\t\t    need_affix = TRUE;\n\t\t\t    }\n\n\t\t\t    if (affile->af_pfxpostpone\n\t\t\t\t\t\t|| spin->si_compflags != NULL)\n\t\t\t    {\n\t\t\t\tif (affile->af_pfxpostpone)\n\t\t\t\t    // Get prefix IDS from the affix list.\n\t\t\t\t    use_pfxlen = get_pfxlist(affile,\n\t\t\t\t\t\t ae->ae_flags, store_afflist);\n\t\t\t\telse\n\t\t\t\t    use_pfxlen = 0;\n\t\t\t\tuse_pfxlist = store_afflist;\n\n\t\t\t\t// Combine the prefix IDs. Avoid adding the\n\t\t\t\t// same ID twice.\n\t\t\t\tfor (i = 0; i < pfxlen; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = 0; j < use_pfxlen; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j == use_pfxlen)\n\t\t\t\t\tuse_pfxlist[use_pfxlen++] = pfxlist[i];\n\t\t\t\t}\n\n\t\t\t\tif (spin->si_compflags != NULL)\n\t\t\t\t    // Get compound IDS from the affix list.\n\t\t\t\t    get_compflags(affile, ae->ae_flags,\n\t\t\t\t\t\t  use_pfxlist + use_pfxlen);\n\n\t\t\t\t// Combine the list of compound flags.\n\t\t\t\t// Concatenate them to the prefix IDs list.\n\t\t\t\t// Avoid adding the same ID twice.\n\t\t\t\tfor (i = pfxlen; pfxlist[i] != NUL; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = use_pfxlen;\n\t\t\t\t\t\t   use_pfxlist[j] != NUL; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (use_pfxlist[j] == NUL)\n\t\t\t\t    {\n\t\t\t\t\tuse_pfxlist[j++] = pfxlist[i];\n\t\t\t\t\tuse_pfxlist[j] = NUL;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// Obey a \"COMPOUNDFORBIDFLAG\" of the affix: don't\n\t\t\t// use the compound flags.\n\t\t\tif (use_pfxlist != NULL && ae->ae_compforbid)\n\t\t\t{\n\t\t\t    vim_strncpy(pfx_pfxlist, use_pfxlist, use_pfxlen);\n\t\t\t    use_pfxlist = pfx_pfxlist;\n\t\t\t}\n\n\t\t\t// When there are postponed prefixes...\n\t\t\tif (spin->si_prefroot != NULL\n\t\t\t\t&& spin->si_prefroot->wn_sibling != NULL)\n\t\t\t{\n\t\t\t    // ... add a flag to indicate an affix was used.\n\t\t\t    use_flags |= WF_HAS_AFF;\n\n\t\t\t    // ... don't use a prefix list if combining\n\t\t\t    // affixes is not allowed.  But do use the\n\t\t\t    // compound flags after them.\n\t\t\t    if (!ah->ah_combine && use_pfxlist != NULL)\n\t\t\t\tuse_pfxlist += use_pfxlen;\n\t\t\t}\n\n\t\t\t// When compounding is supported and there is no\n\t\t\t// \"COMPOUNDPERMITFLAG\" then forbid compounding on the\n\t\t\t// side where the affix is applied.\n\t\t\tif (spin->si_compflags != NULL && !ae->ae_comppermit)\n\t\t\t{\n\t\t\t    if (xht != NULL)\n\t\t\t\tuse_flags |= WF_NOCOMPAFT;\n\t\t\t    else\n\t\t\t\tuse_flags |= WF_NOCOMPBEF;\n\t\t\t}\n\n\t\t\t// Store the modified word.\n\t\t\tif (store_word(spin, newword, use_flags,\n\t\t\t\t\t\t spin->si_region, use_pfxlist,\n\t\t\t\t\t\t\t  need_affix) == FAIL)\n\t\t\t    retval = FAIL;\n\n\t\t\t// When added a prefix or a first suffix and the affix\n\t\t\t// has flags may add a(nother) suffix.  RECURSIVE!\n\t\t\tif ((condit & CONDIT_SUF) && ae->ae_flags != NULL)\n\t\t\t    if (store_aff_word(spin, newword, ae->ae_flags,\n\t\t\t\t\taffile, &affile->af_suff, xht,\n\t\t\t\t\t   use_condit & (xht == NULL\n\t\t\t\t\t\t\t? ~0 :  ~CONDIT_SUF),\n\t\t\t\t      use_flags, use_pfxlist, pfxlen) == FAIL)\n\t\t\t\tretval = FAIL;\n\n\t\t\t// When added a suffix and combining is allowed also\n\t\t\t// try adding a prefix additionally.  Both for the\n\t\t\t// word flags and for the affix flags.  RECURSIVE!\n\t\t\tif (xht != NULL && ah->ah_combine)\n\t\t\t{\n\t\t\t    if (store_aff_word(spin, newword,\n\t\t\t\t\tafflist, affile,\n\t\t\t\t\txht, NULL, use_condit,\n\t\t\t\t\tuse_flags, use_pfxlist,\n\t\t\t\t\tpfxlen) == FAIL\n\t\t\t\t    || (ae->ae_flags != NULL\n\t\t\t\t\t&& store_aff_word(spin, newword,\n\t\t\t\t\t    ae->ae_flags, affile,\n\t\t\t\t\t    xht, NULL, use_condit,\n\t\t\t\t\t    use_flags, use_pfxlist,\n\t\t\t\t\t    pfxlen) == FAIL))\n\t\t\t\tretval = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a file with a list of words.\n */\n    static int\nspell_read_wordfile(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    long\tlnum = 0;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tretval = OK;\n    int\t\tdid_word = FALSE;\n    int\t\tnon_ascii = 0;\n    int\t\tflags;\n    int\t\tregionmask;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading word file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Remove CR, LF and white space from the end.\n\tl = (int)STRLEN(rline);\n\twhile (l > 0 && rline[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty or blank line\n\trline[l] = NUL;\n\n\t// Convert from \"/encoding={encoding}\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %ld: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\tif (*line == '/')\n\t{\n\t    ++line;\n\t    if (STRNCMP(line, \"encoding=\", 9) == 0)\n\t    {\n\t\tif (spin->si_conv.vc_type != CONV_NONE)\n\t\t    smsg(_(\"Duplicate /encoding= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse if (did_word)\n\t\t    smsg(_(\"/encoding= line after word ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse\n\t\t{\n\t\t    char_u\t*enc;\n\n\t\t    // Setup for conversion to 'encoding'.\n\t\t    line += 9;\n\t\t    enc = enc_canonize(line);\n\t\t    if (enc != NULL && !spin->si_ascii\n\t\t\t    && convert_setup(&spin->si_conv, enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t\tsmsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t\t\t  fname, line, p_enc);\n\t\t    vim_free(enc);\n\t\t    spin->si_conv.vc_fail = TRUE;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (STRNCMP(line, \"regions=\", 8) == 0)\n\t    {\n\t\tif (spin->si_region_count > 1)\n\t\t    smsg(_(\"Duplicate /regions= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\telse\n\t\t{\n\t\t    line += 8;\n\t\t    if (STRLEN(line) > MAXREGIONS * 2)\n\t\t\tsmsg(_(\"Too many regions in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\t    else\n\t\t    {\n\t\t\tspin->si_region_count = (int)STRLEN(line) / 2;\n\t\t\tSTRCPY(spin->si_region_name, line);\n\n\t\t\t// Adjust the mask for a word valid in all regions.\n\t\t\tspin->si_region = (1 << spin->si_region_count) - 1;\n\t\t    }\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    smsg(_(\"/ line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t    continue;\n\t}\n\n\tflags = 0;\n\tregionmask = spin->si_region;\n\n\t// Check for flags and region after a slash.\n\tp = vim_strchr(line, '/');\n\tif (p != NULL)\n\t{\n\t    *p++ = NUL;\n\t    while (*p != NUL)\n\t    {\n\t\tif (*p == '=')\t\t// keep-case word\n\t\t    flags |= WF_KEEPCAP | WF_FIXCAP;\n\t\telse if (*p == '!')\t// Bad, bad, wicked word.\n\t\t    flags |= WF_BANNED;\n\t\telse if (*p == '?')\t// Rare word.\n\t\t    flags |= WF_RARE;\n\t\telse if (VIM_ISDIGIT(*p)) // region number(s)\n\t\t{\n\t\t    if ((flags & WF_REGION) == 0)   // first one\n\t\t\tregionmask = 0;\n\t\t    flags |= WF_REGION;\n\n\t\t    l = *p - '0';\n\t\t    if (l == 0 || l > spin->si_region_count)\n\t\t    {\n\t\t\tsmsg(_(\"Invalid region nr in %s line %ld: %s\"),\n\t\t\t\t\t\t\t  fname, lnum, p);\n\t\t\tbreak;\n\t\t    }\n\t\t    regionmask |= 1 << (l - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    smsg(_(\"Unrecognized flags in %s line %ld: %s\"),\n\t\t\t\t\t\t\t      fname, lnum, p);\n\t\t    break;\n\t\t}\n\t\t++p;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(line))\n\t{\n\t    ++non_ascii;\n\t    continue;\n\t}\n\n\t// Normal word: store it.\n\tif (store_word(spin, line, flags, regionmask, NULL, FALSE) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    break;\n\t}\n\tdid_word = TRUE;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n\n    if (spin->si_ascii && non_ascii > 0)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t  _(\"Ignored %d words with non-ASCII characters\"), non_ascii);\n\tspell_message(spin, IObuff);\n    }\n\n    return retval;\n}\n\n/*\n * Get part of an sblock_T, \"len\" bytes long.\n * This avoids calling free() for every little struct we use (and keeping\n * track of them).\n * The memory is cleared to all zeros.\n * Returns NULL when out of memory.\n */\n    static void *\ngetroom(\n    spellinfo_T *spin,\n    size_t\tlen,\t\t// length needed\n    int\t\talign)\t\t// align for pointer\n{\n    char_u\t*p;\n    sblock_T\t*bl = spin->si_blocks;\n\n    if (align && bl != NULL)\n\t// Round size up for alignment.  On some systems structures need to be\n\t// aligned to the size of a pointer (e.g., SPARC).\n\tbl->sb_used = (bl->sb_used + sizeof(char *) - 1)\n\t\t\t\t\t\t      & ~(sizeof(char *) - 1);\n\n    if (bl == NULL || bl->sb_used + len > SBLOCKSIZE)\n    {\n\tif (len >= SBLOCKSIZE)\n\t    bl = NULL;\n\telse\n\t    // Allocate a block of memory. It is not freed until much later.\n\t    bl = alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);\n\tif (bl == NULL)\n\t{\n\t    if (!spin->si_did_emsg)\n\t    {\n\t\temsg(_(e_insufficient_memory_word_list_will_be_incomplete));\n\t\tspin->si_did_emsg = TRUE;\n\t    }\n\t    return NULL;\n\t}\n\tbl->sb_next = spin->si_blocks;\n\tspin->si_blocks = bl;\n\tbl->sb_used = 0;\n\t++spin->si_blocks_cnt;\n    }\n\n    p = bl->sb_data + bl->sb_used;\n    bl->sb_used += (int)len;\n\n    return p;\n}\n\n/*\n * Make a copy of a string into memory allocated with getroom().\n * Returns NULL when out of memory.\n */\n    static char_u *\ngetroom_save(spellinfo_T *spin, char_u *s)\n{\n    char_u\t*sc;\n\n    sc = (char_u *)getroom(spin, STRLEN(s) + 1, FALSE);\n    if (sc != NULL)\n\tSTRCPY(sc, s);\n    return sc;\n}\n\n\n/*\n * Free the list of allocated sblock_T.\n */\n    static void\nfree_blocks(sblock_T *bl)\n{\n    sblock_T\t*next;\n\n    while (bl != NULL)\n    {\n\tnext = bl->sb_next;\n\tvim_free(bl);\n\tbl = next;\n    }\n}\n\n/*\n * Allocate the root of a word tree.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nwordtree_alloc(spellinfo_T *spin)\n{\n    return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n}\n\n/*\n * Store a word in the tree(s).\n * Always store it in the case-folded tree.  For a keep-case word this is\n * useful when the word can also be used with all caps (no WF_FIXCAP flag) and\n * used to find suggestions.\n * For a keep-case word also store it in the keep-case tree.\n * When \"pfxlist\" is not NULL store the word for each postponed prefix ID and\n * compound flag.\n */\n    static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    // Avoid adding illegal bytes to the word tree.\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n\treturn FAIL;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}\n\n/*\n * Add word \"word\" to a word tree at \"root\".\n * When \"flags\" < 0 we are adding to the prefix tree where \"flags\" is used for\n * \"rare\" and \"region\" is the condition nr.\n * Returns FAIL when out of memory.\n */\n    static int\ntree_add_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    wordnode_T\t*root,\n    int\t\tflags,\n    int\t\tregion,\n    int\t\taffixID)\n{\n    wordnode_T\t*node = root;\n    wordnode_T\t*np;\n    wordnode_T\t*copyp, **copyprev;\n    wordnode_T\t**prev = NULL;\n    int\t\ti;\n\n    // Add each byte of the word to the tree, including the NUL at the end.\n    for (i = 0; ; ++i)\n    {\n\t// When there is more than one reference to this node we need to make\n\t// a copy, so that we can modify it.  Copy the whole list of siblings\n\t// (we don't optimize for a partly shared list of siblings).\n\tif (node != NULL && node->wn_refs > 1)\n\t{\n\t    --node->wn_refs;\n\t    copyprev = prev;\n\t    FOR_ALL_NODE_SIBLINGS(node, copyp)\n\t    {\n\t\t// Allocate a new node and copy the info.\n\t\tnp = get_wordnode(spin);\n\t\tif (np == NULL)\n\t\t    return FAIL;\n\t\tnp->wn_child = copyp->wn_child;\n\t\tif (np->wn_child != NULL)\n\t\t    ++np->wn_child->wn_refs;\t// child gets extra ref\n\t\tnp->wn_byte = copyp->wn_byte;\n\t\tif (np->wn_byte == NUL)\n\t\t{\n\t\t    np->wn_flags = copyp->wn_flags;\n\t\t    np->wn_region = copyp->wn_region;\n\t\t    np->wn_affixID = copyp->wn_affixID;\n\t\t}\n\n\t\t// Link the new node in the list, there will be one ref.\n\t\tnp->wn_refs = 1;\n\t\tif (copyprev != NULL)\n\t\t    *copyprev = np;\n\t\tcopyprev = &np->wn_sibling;\n\n\t\t// Let \"node\" point to the head of the copied list.\n\t\tif (copyp == node)\n\t\t    node = np;\n\t    }\n\t}\n\n\t// Look for the sibling that has the same character.  They are sorted\n\t// on byte value, thus stop searching when a sibling is found with a\n\t// higher byte value.  For zero bytes (end of word) the sorting is\n\t// done on flags and then on affixID.\n\twhile (node != NULL\n\t\t&& (node->wn_byte < word[i]\n\t\t    || (node->wn_byte == NUL\n\t\t\t&& (flags < 0\n\t\t\t    ? node->wn_affixID < (unsigned)affixID\n\t\t\t    : (node->wn_flags < (unsigned)(flags & WN_MASK)\n\t\t\t\t|| (node->wn_flags == (flags & WN_MASK)\n\t\t\t\t    && (spin->si_sugtree\n\t\t\t\t\t? (node->wn_region & 0xffff) < region\n\t\t\t\t\t: node->wn_affixID\n\t\t\t\t\t\t    < (unsigned)affixID)))))))\n\t{\n\t    prev = &node->wn_sibling;\n\t    node = *prev;\n\t}\n\tif (node == NULL\n\t\t|| node->wn_byte != word[i]\n\t\t|| (word[i] == NUL\n\t\t    && (flags < 0\n\t\t\t|| spin->si_sugtree\n\t\t\t|| node->wn_flags != (flags & WN_MASK)\n\t\t\t|| node->wn_affixID != affixID)))\n\t{\n\t    // Allocate a new node.\n\t    np = get_wordnode(spin);\n\t    if (np == NULL)\n\t\treturn FAIL;\n\t    np->wn_byte = word[i];\n\n\t    // If \"node\" is NULL this is a new child or the end of the sibling\n\t    // list: ref count is one.  Otherwise use ref count of sibling and\n\t    // make ref count of sibling one (matters when inserting in front\n\t    // of the list of siblings).\n\t    if (node == NULL)\n\t\tnp->wn_refs = 1;\n\t    else\n\t    {\n\t\tnp->wn_refs = node->wn_refs;\n\t\tnode->wn_refs = 1;\n\t    }\n\t    if (prev != NULL)\n\t\t*prev = np;\n\t    np->wn_sibling = node;\n\t    node = np;\n\t}\n\n\tif (word[i] == NUL)\n\t{\n\t    node->wn_flags = flags;\n\t    node->wn_region |= region;\n\t    node->wn_affixID = affixID;\n\t    break;\n\t}\n\tprev = &node->wn_child;\n\tnode = *prev;\n    }\n#ifdef SPELL_PRINTTREE\n    smsg(\"Added \\\"%s\\\"\", word);\n    spell_print_tree(root->wn_sibling);\n#endif\n\n    // count nr of words added since last message\n    ++spin->si_msg_count;\n\n    if (spin->si_compress_cnt > 1)\n    {\n\tif (--spin->si_compress_cnt == 1)\n\t    // Did enough words to lower the block count limit.\n\t    spin->si_blocks_cnt += compress_inc;\n    }\n\n    /*\n     * When we have allocated lots of memory we need to compress the word tree\n     * to free up some room.  But compression is slow, and we might actually\n     * need that room, thus only compress in the following situations:\n     * 1. When not compressed before (si_compress_cnt == 0): when using\n     *    \"compress_start\" blocks.\n     * 2. When compressed before and used \"compress_inc\" blocks before\n     *    adding \"compress_added\" words (si_compress_cnt > 1).\n     * 3. When compressed before, added \"compress_added\" words\n     *    (si_compress_cnt == 1) and the number of free nodes drops below the\n     *    maximum word length.\n     */\n#ifndef SPELL_COMPRESS_ALLWAYS\n    if (spin->si_compress_cnt == 1\n\t    ? spin->si_free_count < MAXWLEN\n\t    : spin->si_blocks_cnt >= compress_start)\n#endif\n    {\n\t// Decrement the block counter.  The effect is that we compress again\n\t// when the freed up room has been used and another \"compress_inc\"\n\t// blocks have been allocated.  Unless \"compress_added\" words have\n\t// been added, then the limit is put back again.\n\tspin->si_blocks_cnt -= compress_inc;\n\tspin->si_compress_cnt = compress_added;\n\n\tif (spin->si_verbose)\n\t{\n\t    msg_start();\n\t    msg_puts(_(msg_compressing));\n\t    msg_clr_eos();\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    out_flush();\n\t}\n\n\t// Compress both trees.  Either they both have many nodes, which makes\n\t// compression useful, or one of them is small, which means\n\t// compression goes fast.  But when filling the soundfold word tree\n\t// there is no keep-case tree.\n\twordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\tif (affixID >= 0)\n\t    wordtree_compress(spin, spin->si_keeproot, \"keep-case\");\n    }\n\n    return OK;\n}\n\n/*\n * Get a wordnode_T, either from the list of previously freed nodes or\n * allocate a new one.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nget_wordnode(spellinfo_T *spin)\n{\n    wordnode_T *n;\n\n    if (spin->si_first_free == NULL)\n\tn = (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n    else\n    {\n\tn = spin->si_first_free;\n\tspin->si_first_free = n->wn_child;\n\tCLEAR_POINTER(n);\n\t--spin->si_free_count;\n    }\n#ifdef SPELL_PRINTTREE\n    if (n != NULL)\n\tn->wn_nr = ++spin->si_wordnode_nr;\n#endif\n    return n;\n}\n\n/*\n * Decrement the reference count on a node (which is the head of a list of\n * siblings).  If the reference count becomes zero free the node and its\n * siblings.\n * Returns the number of nodes actually freed.\n */\n    static int\nderef_wordnode(spellinfo_T *spin, wordnode_T *node)\n{\n    wordnode_T\t*np;\n    int\t\tcnt = 0;\n\n    if (--node->wn_refs == 0)\n    {\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    if (np->wn_child != NULL)\n\t\tcnt += deref_wordnode(spin, np->wn_child);\n\t    free_wordnode(spin, np);\n\t    ++cnt;\n\t}\n\t++cnt;\t    // length field\n    }\n    return cnt;\n}\n\n/*\n * Free a wordnode_T for re-use later.\n * Only the \"wn_child\" field becomes invalid.\n */\n    static void\nfree_wordnode(spellinfo_T *spin, wordnode_T *n)\n{\n    n->wn_child = spin->si_first_free;\n    spin->si_first_free = n;\n    ++spin->si_free_count;\n}\n\n/*\n * Compress a tree: find tails that are identical and can be shared.\n */\n    static void\nwordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name)\n{\n    hashtab_T\t    ht;\n    long\t    n;\n    long\t    tot = 0;\n    long\t    perc;\n\n    // Skip the root itself, it's not actually used.  The first sibling is the\n    // start of the tree.\n    if (root->wn_sibling != NULL)\n    {\n\thash_init(&ht);\n\tn = node_compress(spin, root->wn_sibling, &ht, &tot);\n\n#ifndef SPELL_PRINTTREE\n\tif (spin->si_verbose || p_verbose > 2)\n#endif\n\t{\n\t    if (tot > 1000000)\n\t\tperc = (tot - n) / (tot / 100);\n\t    else if (tot == 0)\n\t\tperc = 0;\n\t    else\n\t\tperc = (tot - n) * 100 / tot;\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t       _(\"Compressed %s: %ld of %ld nodes; %ld (%ld%%) remaining\"),\n\t\t\t\t\t\t       name, n, tot, tot - n, perc);\n\t    spell_message(spin, IObuff);\n\t}\n#ifdef SPELL_PRINTTREE\n\tspell_print_tree(root->wn_sibling);\n#endif\n\thash_clear(&ht);\n    }\n}\n\n/*\n * Compress a node, its siblings and its children, depth first.\n * Returns the number of compressed nodes.\n */\n    static long\nnode_compress(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    hashtab_T\t*ht,\n    long\t*tot)\t    // total count of nodes before compressing,\n\t\t\t    // incremented while going through the tree\n{\n    wordnode_T\t*np;\n    wordnode_T\t*tp;\n    wordnode_T\t*child;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    long\tlen = 0;\n    unsigned\tnr, n;\n    long\tcompressed = 0;\n\n    /*\n     * Go through the list of siblings.  Compress each child and then try\n     * finding an identical child to replace it.\n     * Note that with \"child\" we mean not just the node that is pointed to,\n     * but the whole list of siblings of which the child node is the first.\n     */\n    for (np = node; np != NULL && !got_int; np = np->wn_sibling)\n    {\n\t++len;\n\tif ((child = np->wn_child) != NULL)\n\t{\n\t    // Compress the child first.  This fills hashkey.\n\t    compressed += node_compress(spin, child, ht, tot);\n\n\t    // Try to find an identical child.\n\t    hash = hash_hash(child->wn_u1.hashkey);\n\t    hi = hash_lookup(ht, child->wn_u1.hashkey, hash);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// There are children we encountered before with a hash value\n\t\t// identical to the current child.  Now check if there is one\n\t\t// that is really identical.\n\t\tfor (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)\n\t\t    if (node_equal(child, tp))\n\t\t    {\n\t\t\t// Found one!  Now use that child in place of the\n\t\t\t// current one.  This means the current child and all\n\t\t\t// its siblings is unlinked from the tree.\n\t\t\t++tp->wn_refs;\n\t\t\tcompressed += deref_wordnode(spin, child);\n\t\t\tnp->wn_child = tp;\n\t\t\tbreak;\n\t\t    }\n\t\tif (tp == NULL)\n\t\t{\n\t\t    // No other child with this hash value equals the child of\n\t\t    // the node, add it to the linked list after the first\n\t\t    // item.\n\t\t    tp = HI2WN(hi);\n\t\t    child->wn_u2.next = tp->wn_u2.next;\n\t\t    tp->wn_u2.next = child;\n\t\t}\n\t    }\n\t    else\n\t\t// No other child has this hash value, add it to the\n\t\t// hashtable.\n\t\thash_add_item(ht, hi, child->wn_u1.hashkey, hash);\n\t}\n    }\n    *tot += len + 1;\t// add one for the node that stores the length\n\n    /*\n     * Make a hash key for the node and its siblings, so that we can quickly\n     * find a lookalike node.  This must be done after compressing the sibling\n     * list, otherwise the hash key would become invalid by the compression.\n     */\n    node->wn_u1.hashkey[0] = len;\n    nr = 0;\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == NUL)\n\t    // end node: use wn_flags, wn_region and wn_affixID\n\t    n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);\n\telse\n\t    // byte node: use the byte value and the child pointer\n\t    n = (unsigned)(np->wn_byte + ((long_u)np->wn_child << 8));\n\tnr = nr * 101 + n;\n    }\n\n    // Avoid NUL bytes, it terminates the hash key.\n    n = nr & 0xff;\n    node->wn_u1.hashkey[1] = n == 0 ? 1 : n;\n    n = (nr >> 8) & 0xff;\n    node->wn_u1.hashkey[2] = n == 0 ? 1 : n;\n    n = (nr >> 16) & 0xff;\n    node->wn_u1.hashkey[3] = n == 0 ? 1 : n;\n    n = (nr >> 24) & 0xff;\n    node->wn_u1.hashkey[4] = n == 0 ? 1 : n;\n    node->wn_u1.hashkey[5] = NUL;\n\n    // Check for CTRL-C pressed now and then.\n    veryfast_breakcheck();\n\n    return compressed;\n}\n\n/*\n * Return TRUE when two nodes have identical siblings and children.\n */\n    static int\nnode_equal(wordnode_T *n1, wordnode_T *n2)\n{\n    wordnode_T\t*p1;\n    wordnode_T\t*p2;\n\n    for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;\n\t\t\t\t     p1 = p1->wn_sibling, p2 = p2->wn_sibling)\n\tif (p1->wn_byte != p2->wn_byte\n\t\t|| (p1->wn_byte == NUL\n\t\t    ? (p1->wn_flags != p2->wn_flags\n\t\t\t|| p1->wn_region != p2->wn_region\n\t\t\t|| p1->wn_affixID != p2->wn_affixID)\n\t\t    : (p1->wn_child != p2->wn_child)))\n\t    break;\n\n    return p1 == NULL && p2 == NULL;\n}\n\nstatic int rep_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the REP items on \"from\" string.\n */\n    static int\nrep_compare(const void *s1, const void *s2)\n{\n    fromto_T\t*p1 = (fromto_T *)s1;\n    fromto_T\t*p2 = (fromto_T *)s2;\n\n    return STRCMP(p1->ft_from, p2->ft_from);\n}\n\n/*\n * Write the Vim .spl file \"fname\".\n * Return FAIL or OK;\n */\n    static int\nwrite_vim_spell(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    int\t\tregionmask;\n    int\t\tround;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\ti;\n    int\t\tl;\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    char_u\t*p;\n    int\t\trr;\n    int\t\tretval = OK;\n    size_t\tfwv = 1;  // collect return value of fwrite() to avoid\n\t\t\t  // warnings from picky compiler\n\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // <HEADER>: <fileID> <versionnr>\n\t\t\t\t\t\t\t    // <fileID>\n    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);\n    if (fwv != (size_t)1)\n\t// Catch first write error, don't try writing more.\n\tgoto theend;\n\n    putc(VIMSPELLVERSION, fd);\t\t\t\t    // <versionnr>\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     */\n\n    // SN_INFO: <infotext>\n    if (spin->si_info != NULL)\n    {\n\tputc(SN_INFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_info);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); // <infotext>\n    }\n\n    // SN_REGION: <regionname> ...\n    // Write the region names only if there is more than one.\n    if (spin->si_region_count > 1)\n    {\n\tputc(SN_REGION, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\tl = spin->si_region_count * 2;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <regionname> ...\n\tregionmask = (1 << spin->si_region_count) - 1;\n    }\n    else\n\tregionmask = 0;\n\n    // SN_CHARFLAGS: <charflagslen> <charflags> <folcharslen> <folchars>\n    //\n    // The table with character flags and the table for case folding.\n    // This makes sure the same characters are recognized as word characters\n    // when generating and when using a spell file.\n    // Skip this for ASCII, the table may conflict with the one used for\n    // 'encoding'.\n    // Also skip this for an .add.spl file, the main spell file must contain\n    // the table (avoids that it conflicts).  File is shorter too.\n    if (!spin->si_ascii && !spin->si_add)\n    {\n\tchar_u\tfolchars[128 * 8];\n\tint\tflags;\n\n\tputc(SN_CHARFLAGS, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\t// Form the <folchars> string first, we need to know its length.\n\tl = 0;\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tl += mb_char2bytes(spelltab.st_fold[i], folchars + l);\n\t    else\n\t\tfolchars[l++] = spelltab.st_fold[i];\n\t}\n\tput_bytes(fd, (long_u)(1 + 128 + 2 + l), 4);\t// <sectionlen>\n\n\tfputc(128, fd);\t\t\t\t\t// <charflagslen>\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    flags = 0;\n\t    if (spelltab.st_isw[i])\n\t\tflags |= CF_WORD;\n\t    if (spelltab.st_isu[i])\n\t\tflags |= CF_UPPER;\n\t    fputc(flags, fd);\t\t\t\t// <charflags>\n\t}\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <folcharslen>\n\tfwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); // <folchars>\n    }\n\n    // SN_MIDWORD: <midword>\n    if (spin->si_midword != NULL)\n    {\n\tputc(SN_MIDWORD, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_midword);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);\n\t\t\t\t\t\t\t// <midword>\n    }\n\n    // SN_PREFCOND: <prefcondcnt> <prefcond> ...\n    if (spin->si_prefcond.ga_len > 0)\n    {\n\tputc(SN_PREFCOND, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\tl = write_spell_prefcond(NULL, &spin->si_prefcond, &fwv);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\twrite_spell_prefcond(fd, &spin->si_prefcond, &fwv);\n    }\n\n    // SN_REP: <repcount> <rep> ...\n    // SN_SAL: <salflags> <salcount> <sal> ...\n    // SN_REPSAL: <repcount> <rep> ...\n\n    // round 1: SN_REP section\n    // round 2: SN_SAL section (unless SN_SOFO is used)\n    // round 3: SN_REPSAL section\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    gap = &spin->si_rep;\n\telse if (round == 2)\n\t{\n\t    // Don't write SN_SAL when using a SN_SOFO section\n\t    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n\t\tcontinue;\n\t    gap = &spin->si_sal;\n\t}\n\telse\n\t    gap = &spin->si_repsal;\n\n\t// Don't write the section if there are no items.\n\tif (gap->ga_len == 0)\n\t    continue;\n\n\t// Sort the REP/REPSAL items.\n\tif (round != 2)\n\t    qsort(gap->ga_data, (size_t)gap->ga_len,\n\t\t\t\t\t       sizeof(fromto_T), rep_compare);\n\n\ti = round == 1 ? SN_REP : (round == 2 ? SN_SAL : SN_REPSAL);\n\tputc(i, fd);\t\t\t\t\t// <sectionID>\n\n\t// This is for making suggestions, section is not required.\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// Compute the length of what follows.\n\tl = 2;\t    // count <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    l += 1 + (int)STRLEN(ftp->ft_from);  // count <*fromlen> and <*from>\n\t    l += 1 + (int)STRLEN(ftp->ft_to);    // count <*tolen> and <*to>\n\t}\n\tif (round == 2)\n\t    ++l;\t// count <salflags>\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\tif (round == 2)\n\t{\n\t    i = 0;\n\t    if (spin->si_followup)\n\t\ti |= SAL_F0LLOWUP;\n\t    if (spin->si_collapse)\n\t\ti |= SAL_COLLAPSE;\n\t    if (spin->si_rem_accents)\n\t\ti |= SAL_REM_ACCENTS;\n\t    putc(i, fd);\t\t\t// <salflags>\n\t}\n\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t// <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n\t    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    for (rr = 1; rr <= 2; ++rr)\n\t    {\n\t\tp = rr == 1 ? ftp->ft_from : ftp->ft_to;\n\t\tl = (int)STRLEN(p);\n\t\tputc(l, fd);\n\t\tif (l > 0)\n\t\t    fwv &= fwrite(p, l, (size_t)1, fd);\n\t    }\n\t}\n\n    }\n\n    // SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n    // This is for making suggestions, section is not required.\n    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n    {\n\tputc(SN_SOFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_sofofr);\n\tput_bytes(fd, (long_u)(l + STRLEN(spin->si_sofoto) + 4), 4);\n\t\t\t\t\t\t\t// <sectionlen>\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofofromlen>\n\tfwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); // <sofofrom>\n\n\tl = (int)STRLEN(spin->si_sofoto);\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofotolen>\n\tfwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); // <sofoto>\n    }\n\n    // SN_WORDS: <word> ...\n    // This is for making suggestions, section is not required.\n    if (spin->si_commonwords.ht_used > 0)\n    {\n\tputc(SN_WORDS, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// round 1: count the bytes\n\t// round 2: write the bytes\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    int\t\ttodo;\n\t    int\t\tlen = 0;\n\t    hashitem_T\t*hi;\n\n\t    todo = (int)spin->si_commonwords.ht_used;\n\t    for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    l = (int)STRLEN(hi->hi_key) + 1;\n\t\t    len += l;\n\t\t    if (round == 2)\t\t\t// <word>\n\t\t\tfwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);\n\t\t    --todo;\n\t\t}\n\t    if (round == 1)\n\t\tput_bytes(fd, (long_u)len, 4);\t\t// <sectionlen>\n\t}\n    }\n\n    // SN_MAP: <mapstr>\n    // This is for making suggestions, section is not required.\n    if (spin->si_map.ga_len > 0)\n    {\n\tputc(SN_MAP, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tl = spin->si_map.ga_len;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <mapstr>\n    }\n\n    // SN_SUGFILE: <timestamp>\n    // This is used to notify that a .sug file may be available and at the\n    // same time allows for checking that a .sug file that is found matches\n    // with this .spl file.  That's because the word numbers must be exactly\n    // right.\n    if (!spin->si_nosugfile\n\t    && (spin->si_sal.ga_len > 0\n\t\t     || (spin->si_sofofr != NULL && spin->si_sofoto != NULL)))\n    {\n\tputc(SN_SUGFILE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)8, 4);\t\t\t// <sectionlen>\n\n\t// Set si_sugtime and write it to the file.\n\tspin->si_sugtime = time(NULL);\n\tput_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n    }\n\n    // SN_NOSPLITSUGS: nothing\n    // This is used to notify that no suggestions with word splits are to be\n    // made.\n    if (spin->si_nosplitsugs)\n    {\n\tputc(SN_NOSPLITSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_NOCOMPUNDSUGS: nothing\n    // This is used to notify that no suggestions with compounds are to be\n    // made.\n    if (spin->si_nocompoundsugs)\n    {\n\tputc(SN_NOCOMPOUNDSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_COMPOUND: compound info.\n    // We don't mark it required, when not supported all compound words will\n    // be bad words.\n    if (spin->si_compflags != NULL)\n    {\n\tputc(SN_COMPOUND, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_compflags);\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t    l += (int)STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;\n\tput_bytes(fd, (long_u)(l + 7), 4);\t\t// <sectionlen>\n\n\tputc(spin->si_compmax, fd);\t\t\t// <compmax>\n\tputc(spin->si_compminlen, fd);\t\t\t// <compminlen>\n\tputc(spin->si_compsylmax, fd);\t\t\t// <compsylmax>\n\tputc(0, fd);\t\t// for Vim 7.0b compatibility\n\tputc(spin->si_compoptions, fd);\t\t\t// <compoptions>\n\tput_bytes(fd, (long_u)spin->si_comppat.ga_len, 2);\n\t\t\t\t\t\t\t// <comppatcount>\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t{\n\t    p = ((char_u **)(spin->si_comppat.ga_data))[i];\n\t    putc((int)STRLEN(p), fd);\t\t\t// <comppatlen>\n\t    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);\n\t\t\t\t\t\t\t// <comppattext>\n\t}\n\t\t\t\t\t\t\t// <compflags>\n\tfwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),\n\t\t\t\t\t\t\t       (size_t)1, fd);\n    }\n\n    // SN_NOBREAK: NOBREAK flag\n    if (spin->si_nobreak)\n    {\n\tputc(SN_NOBREAK, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// It's empty, the presence of the section flags the feature.\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_SYLLABLE: syllable info.\n    // We don't mark it required, when not supported syllables will not be\n    // counted.\n    if (spin->si_syllable != NULL)\n    {\n\tputc(SN_SYLLABLE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_syllable);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <syllable>\n    }\n\n    // end of <SECTIONS>\n    putc(SN_END, fd);\t\t\t\t\t// <sectionend>\n\n\n    /*\n     * <LWORDTREE>  <KWORDTREE>  <PREFIXTREE>\n     */\n    spin->si_memtot = 0;\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    tree = spin->si_foldroot->wn_sibling;\n\telse if (round == 2)\n\t    tree = spin->si_keeproot->wn_sibling;\n\telse\n\t    tree = spin->si_prefroot->wn_sibling;\n\n\t// Clear the index and wnode fields in the tree.\n\tclear_node(tree);\n\n\t// Count the number of nodes.  Needed to be able to allocate the\n\t// memory when reading the nodes.  Also fills in index for shared\n\t// nodes.\n\tnodecount = put_node(NULL, tree, 0, regionmask, round == 3);\n\n\t// number of nodes in 4 bytes\n\tput_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n\tspin->si_memtot += nodecount + nodecount * sizeof(int);\n\n\t// Write the nodes.\n\t(void)put_node(fd, tree, 0, regionmask, round == 3);\n    }\n\n    // Write another byte to check for errors (file system full).\n    if (putc(0, fd) == EOF)\n\tretval = FAIL;\ntheend:\n    if (fclose(fd) == EOF)\n\tretval = FAIL;\n\n    if (fwv != (size_t)1)\n\tretval = FAIL;\n    if (retval == FAIL)\n\temsg(_(e_error_while_writing));\n\n    return retval;\n}\n\n/*\n * Clear the index and wnode fields of \"node\", it siblings and its\n * children.  This is needed because they are a union with other items to save\n * space.\n */\n    static void\nclear_node(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    if (node != NULL)\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    np->wn_u1.index = 0;\n\t    np->wn_u2.wnode = NULL;\n\n\t    if (np->wn_byte != NUL)\n\t\tclear_node(np->wn_child);\n\t}\n}\n\n\n/*\n * Dump a word tree at node \"node\".\n *\n * This first writes the list of possible bytes (siblings).  Then for each\n * byte recursively write the children.\n *\n * NOTE: The code here must match the code in read_tree_node(), since\n * assumptions are made about the indexes (so that we don't have to write them\n * in the file).\n *\n * Returns the number of nodes used.\n */\n    static int\nput_node(\n    FILE\t*fd,\t\t// NULL when only counting\n    wordnode_T\t*node,\n    int\t\tidx,\n    int\t\tregionmask,\n    int\t\tprefixtree)\t// TRUE for PREFIXTREE\n{\n    int\t\tnewindex = idx;\n    int\t\tsiblingcount = 0;\n    wordnode_T\t*np;\n    int\t\tflags;\n\n    // If \"node\" is zero the tree is empty.\n    if (node == NULL)\n\treturn 0;\n\n    // Store the index where this node is written.\n    node->wn_u1.index = idx;\n\n    // Count the number of siblings.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\t++siblingcount;\n\n    // Write the sibling count.\n    if (fd != NULL)\n\tputc(siblingcount, fd);\t\t\t\t// <siblingcount>\n\n    // Write each sibling byte and optionally extra info.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == 0)\n\t{\n\t    if (fd != NULL)\n\t    {\n\t\t// For a NUL byte (end of word) write the flags etc.\n\t\tif (prefixtree)\n\t\t{\n\t\t    // In PREFIXTREE write the required affixID and the\n\t\t    // associated condition nr (stored in wn_region).  The\n\t\t    // byte value is misused to store the \"rare\" and \"not\n\t\t    // combining\" flags\n\t\t    if (np->wn_flags == (short_u)PFX_FLAGS)\n\t\t\tputc(BY_NOFLAGS, fd);\t\t// <byte>\n\t\t    else\n\t\t    {\n\t\t\tputc(BY_FLAGS, fd);\t\t// <byte>\n\t\t\tputc(np->wn_flags, fd);\t\t// <pflags>\n\t\t    }\n\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    put_bytes(fd, (long_u)np->wn_region, 2); // <prefcondnr>\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For word trees we write the flag/region items.\n\t\t    flags = np->wn_flags;\n\t\t    if (regionmask != 0 && np->wn_region != regionmask)\n\t\t\tflags |= WF_REGION;\n\t\t    if (np->wn_affixID != 0)\n\t\t\tflags |= WF_AFX;\n\t\t    if (flags == 0)\n\t\t    {\n\t\t\t// word without flags or region\n\t\t\tputc(BY_NOFLAGS, fd);\t\t\t// <byte>\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (np->wn_flags >= 0x100)\n\t\t\t{\n\t\t\t    putc(BY_FLAGS2, fd);\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t    putc((unsigned)flags >> 8, fd);\t// <flags2>\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    putc(BY_FLAGS, fd);\t\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t}\n\t\t\tif (flags & WF_REGION)\n\t\t\t    putc(np->wn_region, fd);\t\t// <region>\n\t\t\tif (flags & WF_AFX)\n\t\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if (np->wn_child->wn_u1.index != 0\n\t\t\t\t\t && np->wn_child->wn_u2.wnode != node)\n\t    {\n\t\t// The child is written elsewhere, write the reference.\n\t\tif (fd != NULL)\n\t\t{\n\t\t    putc(BY_INDEX, fd);\t\t\t// <byte>\n\t\t\t\t\t\t\t// <nodeidx>\n\t\t    put_bytes(fd, (long_u)np->wn_child->wn_u1.index, 3);\n\t\t}\n\t    }\n\t    else if (np->wn_child->wn_u2.wnode == NULL)\n\t\t// We will write the child below and give it an index.\n\t\tnp->wn_child->wn_u2.wnode = node;\n\n\t    if (fd != NULL)\n\t\tif (putc(np->wn_byte, fd) == EOF) // <byte> or <xbyte>\n\t\t{\n\t\t    emsg(_(e_error_while_writing));\n\t\t    return 0;\n\t\t}\n\t}\n    }\n\n    // Space used in the array when reading: one for each sibling and one for\n    // the count.\n    newindex += siblingcount + 1;\n\n    // Recursively dump the children of each sibling.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\tif (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)\n\t    newindex = put_node(fd, np->wn_child, newindex, regionmask,\n\t\t\t\t\t\t\t\t  prefixtree);\n\n    return newindex;\n}\n\n\n/*\n * \":mkspell [-ascii] outfile  infile ...\"\n * \":mkspell [-ascii] addfile\"\n */\n    void\nex_mkspell(exarg_T *eap)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    char_u\t*arg = eap->arg;\n    int\t\tascii = FALSE;\n\n    if (STRNCMP(arg, \"-ascii\", 6) == 0)\n    {\n\tascii = TRUE;\n\targ = skipwhite(arg + 6);\n    }\n\n    // Expand all the remaining arguments (e.g., $VIMRUNTIME).\n    if (get_arglist_exp(arg, &fcount, &fnames, FALSE) == OK)\n    {\n\tmkspell(fcount, fnames, ascii, eap->forceit, FALSE);\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Create the .sug file.\n * Uses the soundfold info in \"spin\".\n * Writes the file with the name \"wfname\", with \".spl\" changed to \".sug\".\n */\n    static void\nspell_make_sugfile(spellinfo_T *spin, char_u *wfname)\n{\n    char_u\t*fname = NULL;\n    int\t\tlen;\n    slang_T\t*slang;\n    int\t\tfree_slang = FALSE;\n\n    /*\n     * Read back the .spl file that was written.  This fills the required\n     * info for soundfolding.  This also uses less memory than the\n     * pointer-linked version of the trie.  And it avoids having two versions\n     * of the code for the soundfolding stuff.\n     * It might have been done already by spell_reload_one().\n     */\n    FOR_ALL_SPELL_LANGS(slang)\n\tif (fullpathcmp(wfname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t    break;\n    if (slang == NULL)\n    {\n\tspell_message(spin, (char_u *)_(\"Reading back spell file...\"));\n\tslang = spell_load_file(wfname, NULL, NULL, FALSE);\n\tif (slang == NULL)\n\t    return;\n\tfree_slang = TRUE;\n    }\n\n    /*\n     * Clear the info in \"spin\" that is used.\n     */\n    spin->si_blocks = NULL;\n    spin->si_blocks_cnt = 0;\n    spin->si_compress_cnt = 0;\t    // will stay at 0 all the time\n    spin->si_free_count = 0;\n    spin->si_first_free = NULL;\n    spin->si_foldwcount = 0;\n\n    /*\n     * Go through the trie of good words, soundfold each word and add it to\n     * the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));\n    if (sug_filltree(spin, slang) == FAIL)\n\tgoto theend;\n\n    /*\n     * Create the table which links each soundfold word with a list of the\n     * good words it may come from.  Creates buffer \"spin->si_spellbuf\".\n     * This also removes the wordnr from the NUL byte entries to make\n     * compression possible.\n     */\n    if (sug_maketable(spin) == FAIL)\n\tgoto theend;\n\n    smsg(_(\"Number of words after soundfolding: %ld\"),\n\t\t\t\t (long)spin->si_spellbuf->b_ml.ml_line_count);\n\n    /*\n     * Compress the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(msg_compressing));\n    wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\n    /*\n     * Write the .sug file.\n     * Make the file name by changing \".spl\" to \".sug\".\n     */\n    fname = alloc(MAXPATHL);\n    if (fname == NULL)\n\tgoto theend;\n    vim_strncpy(fname, wfname, MAXPATHL - 1);\n    len = (int)STRLEN(fname);\n    fname[len - 2] = 'u';\n    fname[len - 1] = 'g';\n    sug_write(spin, fname);\n\ntheend:\n    vim_free(fname);\n    if (free_slang)\n\tslang_free(slang);\n    free_blocks(spin->si_blocks);\n    close_spellbuf(spin->si_spellbuf);\n}\n\n/*\n * Build the soundfold trie for language \"slang\".\n */\n    static int\nsug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}\n\n/*\n * Make the table that links each word in the soundfold trie to the words it\n * can be produced from.\n * This is not unlike lines in a file, thus use a memfile to be able to access\n * the table efficiently.\n * Returns FAIL when out of memory.\n */\n    static int\nsug_maketable(spellinfo_T *spin)\n{\n    garray_T\tga;\n    int\t\tres = OK;\n\n    // Allocate a buffer, open a memline for it and create the swap file\n    // (uses a temp file, not a .swp file).\n    spin->si_spellbuf = open_spellbuf();\n    if (spin->si_spellbuf == NULL)\n\treturn FAIL;\n\n    // Use a buffer to store the line info, avoids allocating many small\n    // pieces of memory.\n    ga_init2(&ga, 1, 100);\n\n    // recursively go through the tree\n    if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)\n\tres = FAIL;\n\n    ga_clear(&ga);\n    return res;\n}\n\n/*\n * Fill the table for one node and its children.\n * Returns the wordnr at the start of the node.\n * Returns -1 when out of memory.\n */\n    static int\nsug_filltable(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    int\t\tstartwordnr,\n    garray_T\t*gap)\t    // place to store line of numbers\n{\n    wordnode_T\t*p, *np;\n    int\t\twordnr = startwordnr;\n    int\t\tnr;\n    int\t\tprev_nr;\n\n    FOR_ALL_NODE_SIBLINGS(node, p)\n    {\n\tif (p->wn_byte == NUL)\n\t{\n\t    gap->ga_len = 0;\n\t    prev_nr = 0;\n\t    for (np = p; np != NULL && np->wn_byte == NUL; np = np->wn_sibling)\n\t    {\n\t\tif (ga_grow(gap, 10) == FAIL)\n\t\t    return -1;\n\n\t\tnr = (np->wn_flags << 16) + (np->wn_region & 0xffff);\n\t\t// Compute the offset from the previous nr and store the\n\t\t// offset in a way that it takes a minimum number of bytes.\n\t\t// It's a bit like utf-8, but without the need to mark\n\t\t// following bytes.\n\t\tnr -= prev_nr;\n\t\tprev_nr += nr;\n\t\tgap->ga_len += offset2bytes(nr,\n\t\t\t\t\t (char_u *)gap->ga_data + gap->ga_len);\n\t    }\n\n\t    // add the NUL byte\n\t    ((char_u *)gap->ga_data)[gap->ga_len++] = NUL;\n\n\t    if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,\n\t\t\t\t     gap->ga_data, gap->ga_len, TRUE) == FAIL)\n\t\treturn -1;\n\t    ++wordnr;\n\n\t    // Remove extra NUL entries, we no longer need them. We don't\n\t    // bother freeing the nodes, they won't be reused anyway.\n\t    while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)\n\t\tp->wn_sibling = p->wn_sibling->wn_sibling;\n\n\t    // Clear the flags on the remaining NUL node, so that compression\n\t    // works a lot better.\n\t    p->wn_flags = 0;\n\t    p->wn_region = 0;\n\t}\n\telse\n\t{\n\t    wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);\n\t    if (wordnr == -1)\n\t\treturn -1;\n\t}\n    }\n    return wordnr;\n}\n\n/*\n * Convert an offset into a minimal number of bytes.\n * Similar to utf_char2byters, but use 8 bits in followup bytes and avoid NUL\n * bytes.\n */\n    static int\noffset2bytes(int nr, char_u *buf)\n{\n    int\t    rem;\n    int\t    b1, b2, b3, b4;\n\n    // Split the number in parts of base 255.  We need to avoid NUL bytes.\n    b1 = nr % 255 + 1;\n    rem = nr / 255;\n    b2 = rem % 255 + 1;\n    rem = rem / 255;\n    b3 = rem % 255 + 1;\n    b4 = rem / 255 + 1;\n\n    if (b4 > 1 || b3 > 0x1f)\t// 4 bytes\n    {\n\tbuf[0] = 0xe0 + b4;\n\tbuf[1] = b3;\n\tbuf[2] = b2;\n\tbuf[3] = b1;\n\treturn 4;\n    }\n    if (b3 > 1 || b2 > 0x3f )\t// 3 bytes\n    {\n\tbuf[0] = 0xc0 + b3;\n\tbuf[1] = b2;\n\tbuf[2] = b1;\n\treturn 3;\n    }\n    if (b2 > 1 || b1 > 0x7f )\t// 2 bytes\n    {\n\tbuf[0] = 0x80 + b2;\n\tbuf[1] = b1;\n\treturn 2;\n    }\n\t\t\t\t// 1 byte\n    buf[0] = b1;\n    return 1;\n}\n\n/*\n * Write the .sug file in \"fname\".\n */\n    static void\nsug_write(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\twcount;\n    char_u\t*line;\n    linenr_T\tlnum;\n    int\t\tlen;\n\n    // Create the file.  Note that an existing file is silently overwritten!\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Writing suggestion file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n     */\n    if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) // <fileID>\n    {\n\temsg(_(e_error_while_writing));\n\tgoto theend;\n    }\n    putc(VIMSUGVERSION, fd);\t\t\t\t// <versionnr>\n\n    // Write si_sugtime to the file.\n    put_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n\n    /*\n     * <SUGWORDTREE>\n     */\n    spin->si_memtot = 0;\n    tree = spin->si_foldroot->wn_sibling;\n\n    // Clear the index and wnode fields in the tree.\n    clear_node(tree);\n\n    // Count the number of nodes.  Needed to be able to allocate the\n    // memory when reading the nodes.  Also fills in index for shared\n    // nodes.\n    nodecount = put_node(NULL, tree, 0, 0, FALSE);\n\n    // number of nodes in 4 bytes\n    put_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n    spin->si_memtot += nodecount + nodecount * sizeof(int);\n\n    // Write the nodes.\n    (void)put_node(fd, tree, 0, 0, FALSE);\n\n    /*\n     * <SUGTABLE>: <sugwcount> <sugline> ...\n     */\n    wcount = spin->si_spellbuf->b_ml.ml_line_count;\n    put_bytes(fd, (long_u)wcount, 4);\t// <sugwcount>\n\n    for (lnum = 1; lnum <= (linenr_T)wcount; ++lnum)\n    {\n\t// <sugline>: <sugnr> ... NUL\n\tline = ml_get_buf(spin->si_spellbuf, lnum, FALSE);\n\tlen = (int)STRLEN(line) + 1;\n\tif (fwrite(line, (size_t)len, (size_t)1, fd) == 0)\n\t{\n\t    emsg(_(e_error_while_writing));\n\t    goto theend;\n\t}\n\tspin->si_memtot += len;\n    }\n\n    // Write another byte to check for errors.\n    if (putc(0, fd) == EOF)\n\temsg(_(e_error_while_writing));\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);\n    spell_message(spin, IObuff);\n\ntheend:\n    // close the file\n    fclose(fd);\n}\n\n\n/*\n * Create a Vim spell file from one or more word lists.\n * \"fnames[0]\" is the output file name.\n * \"fnames[fcount - 1]\" is the last input file name.\n * Exception: when \"fnames[0]\" ends in \".add\" it's used as the input file name\n * and \".spl\" is appended to make the output file name.\n */\n    void\nmkspell(\n    int\t\tfcount,\n    char_u\t**fnames,\n    int\t\tascii,\t\t    // -ascii argument given\n    int\t\tover_write,\t    // overwrite existing output file\n    int\t\tadded_word)\t    // invoked through \"zg\"\n{\n    char_u\t*fname = NULL;\n    char_u\t*wfname;\n    char_u\t**innames;\n    int\t\tincount;\n    afffile_T\t*(afile[MAXREGIONS]);\n    int\t\ti;\n    int\t\tlen;\n    stat_T\tst;\n    int\t\terror = FALSE;\n    spellinfo_T spin;\n\n    CLEAR_FIELD(spin);\n    spin.si_verbose = !added_word;\n    spin.si_ascii = ascii;\n    spin.si_followup = TRUE;\n    spin.si_rem_accents = TRUE;\n    ga_init2(&spin.si_rep, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_repsal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_sal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_map, sizeof(char_u), 100);\n    ga_init2(&spin.si_comppat, sizeof(char_u *), 20);\n    ga_init2(&spin.si_prefcond, sizeof(char_u *), 50);\n    hash_init(&spin.si_commonwords);\n    spin.si_newcompID = 127;\t// start compound ID at first maximum\n\n    // default: fnames[0] is output file, following are input files\n    // When \"fcount\" is 1 there is only one file.\n    innames = &fnames[fcount == 1 ? 0 : 1];\n    incount = fcount - 1;\n\n    wfname = alloc(MAXPATHL);\n    if (wfname == NULL)\n\treturn;\n\n    if (fcount >= 1)\n    {\n\tlen = (int)STRLEN(fnames[0]);\n\tif (fcount == 1 && len > 4 && STRCMP(fnames[0] + len - 4, \".add\") == 0)\n\t{\n\t    // For \":mkspell path/en.latin1.add\" output file is\n\t    // \"path/en.latin1.add.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, \"%s.spl\", fnames[0]);\n\t}\n\telse if (fcount == 1)\n\t{\n\t    // For \":mkspell path/vim\" output file is \"path/vim.latin1.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\t}\n\telse if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)\n\t{\n\t    // Name ends in \".spl\", use as the file name.\n\t    vim_strncpy(wfname, fnames[0], MAXPATHL - 1);\n\t}\n\telse\n\t    // Name should be language, make the file name from it.\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\n\t// Check for .ascii.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)\n\t    spin.si_ascii = TRUE;\n\n\t// Check for .add.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)\n\t    spin.si_add = TRUE;\n    }\n\n    if (incount <= 0)\n\temsg(_(e_invalid_argument));\t// need at least output and input names\n    else if (vim_strchr(gettail(wfname), '_') != NULL)\n\temsg(_(e_output_file_name_must_not_have_region_name));\n    else if (incount > MAXREGIONS)\n\tsemsg(_(e_only_up_to_nr_regions_supported), MAXREGIONS);\n    else\n    {\n\t// Check for overwriting before doing things that may take a lot of\n\t// time.\n\tif (!over_write && mch_stat((char *)wfname, &st) >= 0)\n\t{\n\t    emsg(_(e_file_exists));\n\t    goto theend;\n\t}\n\tif (mch_isdir(wfname))\n\t{\n\t    semsg(_(e_str_is_directory), wfname);\n\t    goto theend;\n\t}\n\n\tfname = alloc(MAXPATHL);\n\tif (fname == NULL)\n\t    goto theend;\n\n\t/*\n\t * Init the aff and dic pointers.\n\t * Get the region names if there are more than 2 arguments.\n\t */\n\tfor (i = 0; i < incount; ++i)\n\t{\n\t    afile[i] = NULL;\n\n\t    if (incount > 1)\n\t    {\n\t\tlen = (int)STRLEN(innames[i]);\n\t\tif (STRLEN(gettail(innames[i])) < 5\n\t\t\t\t\t\t|| innames[i][len - 3] != '_')\n\t\t{\n\t\t    semsg(_(e_invalid_region_in_str), innames[i]);\n\t\t    goto theend;\n\t\t}\n\t\tspin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);\n\t\tspin.si_region_name[i * 2 + 1] =\n\t\t\t\t\t     TOLOWER_ASC(innames[i][len - 1]);\n\t    }\n\t}\n\tspin.si_region_count = incount;\n\n\tspin.si_foldroot = wordtree_alloc(&spin);\n\tspin.si_keeproot = wordtree_alloc(&spin);\n\tspin.si_prefroot = wordtree_alloc(&spin);\n\tif (spin.si_foldroot == NULL\n\t\t|| spin.si_keeproot == NULL\n\t\t|| spin.si_prefroot == NULL)\n\t{\n\t    free_blocks(spin.si_blocks);\n\t    goto theend;\n\t}\n\n\t// When not producing a .add.spl file clear the character table when\n\t// we encounter one in the .aff file.  This means we dump the current\n\t// one in the .spl file if the .aff file doesn't define one.  That's\n\t// better than guessing the contents, the table will match a\n\t// previously loaded spell file.\n\tif (!spin.si_add)\n\t    spin.si_clear_chartab = TRUE;\n\n\t/*\n\t * Read all the .aff and .dic files.\n\t * Text is converted to 'encoding'.\n\t * Words are stored in the case-folded and keep-case trees.\n\t */\n\tfor (i = 0; i < incount && !error; ++i)\n\t{\n\t    spin.si_conv.vc_type = CONV_NONE;\n\t    spin.si_region = 1 << i;\n\n\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.aff\", innames[i]);\n\t    if (mch_stat((char *)fname, &st) >= 0)\n\t    {\n\t\t// Read the .aff file.  Will init \"spin->si_conv\" based on the\n\t\t// \"SET\" line.\n\t\tafile[i] = spell_read_aff(&spin, fname);\n\t\tif (afile[i] == NULL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // Read the .dic file and store the words in the trees.\n\t\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",\n\t\t\t\t\t\t\t\t  innames[i]);\n\t\t    if (spell_read_dic(&spin, fname, afile[i]) == FAIL)\n\t\t\terror = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// No .aff file, try reading the file as a word list.  Store\n\t\t// the words in the trees.\n\t\tif (spell_read_wordfile(&spin, innames[i]) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\n\t    // Free any conversion stuff.\n\t    convert_setup(&spin.si_conv, NULL, NULL);\n\t}\n\n\tif (spin.si_compflags != NULL && spin.si_nobreak)\n\t    msg(_(\"Warning: both compounding and NOBREAK specified\"));\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Combine tails in the tree.\n\t     */\n\t    spell_message(&spin, (char_u *)_(msg_compressing));\n\t    wordtree_compress(&spin, spin.si_foldroot, \"case-folded\");\n\t    wordtree_compress(&spin, spin.si_keeproot, \"keep-case\");\n\t    wordtree_compress(&spin, spin.si_prefroot, \"prefixes\");\n\t}\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Write the info in the spell file.\n\t     */\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t      _(\"Writing spell file %s...\"), wfname);\n\t    spell_message(&spin, IObuff);\n\n\t    error = write_vim_spell(&spin, wfname) == FAIL;\n\n\t    spell_message(&spin, (char_u *)_(\"Done!\"));\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);\n\t    spell_message(&spin, IObuff);\n\n\t    /*\n\t     * If the file is loaded need to reload it.\n\t     */\n\t    if (!error)\n\t\tspell_reload_one(wfname, added_word);\n\t}\n\n\t// Free the allocated memory.\n\tga_clear(&spin.si_rep);\n\tga_clear(&spin.si_repsal);\n\tga_clear(&spin.si_sal);\n\tga_clear(&spin.si_map);\n\tga_clear(&spin.si_comppat);\n\tga_clear(&spin.si_prefcond);\n\thash_clear_all(&spin.si_commonwords, 0);\n\n\t// Free the .aff file structures.\n\tfor (i = 0; i < incount; ++i)\n\t    if (afile[i] != NULL)\n\t\tspell_free_aff(afile[i]);\n\n\t// Free all the bits and pieces at once.\n\tfree_blocks(spin.si_blocks);\n\n\t/*\n\t * If there is soundfolding info and no NOSUGFILE item create the\n\t * .sug file with the soundfolded word trie.\n\t */\n\tif (spin.si_sugtime != 0 && !error && !got_int)\n\t    spell_make_sugfile(&spin, wfname);\n\n    }\n\ntheend:\n    vim_free(fname);\n    vim_free(wfname);\n}\n\n/*\n * Display a message for spell file processing when 'verbose' is set or using\n * \":mkspell\".  \"str\" can be IObuff.\n */\n    static void\nspell_message(spellinfo_T *spin, char_u *str)\n{\n    if (spin->si_verbose || p_verbose > 2)\n    {\n\tif (!spin->si_verbose)\n\t    verbose_enter();\n\tmsg((char *)str);\n\tout_flush();\n\tif (!spin->si_verbose)\n\t    verbose_leave();\n    }\n}\n\n/*\n * \":[count]spellgood  {word}\"\n * \":[count]spellwrong {word}\"\n * \":[count]spellundo  {word}\"\n * \":[count]spellrare  {word}\"\n */\n    void\nex_spell(exarg_T *eap)\n{\n    spell_add_word(eap->arg, (int)STRLEN(eap->arg),\n\t\teap->cmdidx == CMD_spellwrong ? SPELL_ADD_BAD :\n\t\teap->cmdidx == CMD_spellrare ? SPELL_ADD_RARE : SPELL_ADD_GOOD,\n\t\t\t\t   eap->forceit ? 0 : (int)eap->line2,\n\t\t\t\t   eap->cmdidx == CMD_spellundo);\n}\n\n/*\n * Add \"word[len]\" to 'spellfile' as a good, rare or bad word.\n */\n    void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n    {\n\temsg(_(e_illegal_character_in_word));\n\treturn;\n    }\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}\n\n/*\n * Initialize 'spellfile' for the current buffer.\n */\n    static void\ninit_spellfile(void)\n{\n    char_u\t*buf;\n    int\t\tl;\n    char_u\t*fname;\n    char_u\t*rtp;\n    char_u\t*lend;\n    int\t\taspath = FALSE;\n    char_u\t*lstart = curbuf->b_s.b_p_spl;\n\n    if (*curwin->w_s->b_p_spl != NUL && curwin->w_s->b_langp.ga_len > 0)\n    {\n\tbuf = alloc(MAXPATHL);\n\tif (buf == NULL)\n\t    return;\n\n\t// Find the end of the language name.  Exclude the region.  If there\n\t// is a path separator remember the start of the tail.\n\tfor (lend = curwin->w_s->b_p_spl; *lend != NUL\n\t\t\t&& vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)\n\t    if (vim_ispathsep(*lend))\n\t    {\n\t\taspath = TRUE;\n\t\tlstart = lend + 1;\n\t    }\n\n\t// Loop over all entries in 'runtimepath'.  Use the first one where we\n\t// are allowed to write.\n\trtp = p_rtp;\n\twhile (*rtp != NUL)\n\t{\n\t    if (aspath)\n\t\t// Use directory of an entry with path, e.g., for\n\t\t// \"/dir/lg.utf-8.spl\" use \"/dir\".\n\t\tvim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t    lstart - curbuf->b_s.b_p_spl - 1);\n\t    else\n\t\t// Copy the path from 'runtimepath' to buf[].\n\t\tcopy_option_part(&rtp, buf, MAXPATHL, \",\");\n\t    if (filewritable(buf) == 2)\n\t    {\n\t\t// Use the first language name from 'spelllang' and the\n\t\t// encoding used in the first loaded .spl file.\n\t\tif (aspath)\n\t\t    vim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t\t  lend - curbuf->b_s.b_p_spl);\n\t\telse\n\t\t{\n\t\t    // Create the \"spell\" directory if it doesn't exist yet.\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l, \"/spell\");\n\t\t    if (filewritable(buf) != 2)\n\t\t\tvim_mkdir(buf, 0755);\n\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l,\n\t\t\t\t \"/%.*s\", (int)(lend - lstart), lstart);\n\t\t}\n\t\tl = (int)STRLEN(buf);\n\t\tfname = LANGP_ENTRY(curwin->w_s->b_langp, 0)\n\t\t\t\t\t\t\t ->lp_slang->sl_fname;\n\t\tvim_snprintf((char *)buf + l, MAXPATHL - l, \".%s.add\",\n\t\t\tfname != NULL\n\t\t\t  && strstr((char *)gettail(fname), \".ascii.\") != NULL\n\t\t\t\t       ? (char_u *)\"ascii\" : spell_enc());\n\t\tset_option_value_give_err((char_u *)\"spellfile\",\n\t\t\t\t\t\t\t   0L, buf, OPT_LOCAL);\n\t\tbreak;\n\t    }\n\t    aspath = FALSE;\n\t}\n\n\tvim_free(buf);\n    }\n}\n\n\n\n/*\n * Set the spell character tables from strings in the affix file.\n */\n    static int\nset_spell_chartab(char_u *fol, char_u *low, char_u *upp)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    char_u\t*pf = fol, *pl = low, *pu = upp;\n    int\t\tf, l, u;\n\n    clear_spell_chartab(&new_st);\n\n    while (*pf != NUL)\n    {\n\tif (*pl == NUL || *pu == NUL)\n\t{\n\t    emsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\t    return FAIL;\n\t}\n\tf = mb_ptr2char_adv(&pf);\n\tl = mb_ptr2char_adv(&pl);\n\tu = mb_ptr2char_adv(&pu);\n\n\t// Every character that appears is a word character.\n\tif (f < 256)\n\t    new_st.st_isw[f] = TRUE;\n\tif (l < 256)\n\t    new_st.st_isw[l] = TRUE;\n\tif (u < 256)\n\t    new_st.st_isw[u] = TRUE;\n\n\t// if \"LOW\" and \"FOL\" are not the same the \"LOW\" char needs\n\t// case-folding\n\tif (l < 256 && l != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[l] = f;\n\t}\n\n\t// if \"UPP\" and \"FOL\" are not the same the \"UPP\" char needs\n\t// case-folding, it's upper case and the \"UPP\" is the upper case of\n\t// \"FOL\" .\n\tif (u < 256 && u != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[u] = f;\n\t    new_st.st_isu[u] = TRUE;\n\t    new_st.st_upper[f] = u;\n\t}\n    }\n\n    if (*pl != NUL || *pu != NUL)\n    {\n\temsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\treturn FAIL;\n    }\n\n    return set_spell_finish(&new_st);\n}\n\n/*\n * Set the spell character tables from strings in the .spl file.\n */\n    static void\nset_spell_charflags(\n    char_u\t*flags,\n    int\t\tcnt,\t    // length of \"flags\"\n    char_u\t*fol)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    int\t\ti;\n    char_u\t*p = fol;\n    int\t\tc;\n\n    clear_spell_chartab(&new_st);\n\n    for (i = 0; i < 128; ++i)\n    {\n\tif (i < cnt)\n\t{\n\t    new_st.st_isw[i + 128] = (flags[i] & CF_WORD) != 0;\n\t    new_st.st_isu[i + 128] = (flags[i] & CF_UPPER) != 0;\n\t}\n\n\tif (*p != NUL)\n\t{\n\t    c = mb_ptr2char_adv(&p);\n\t    new_st.st_fold[i + 128] = c;\n\t    if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)\n\t\tnew_st.st_upper[c] = i + 128;\n\t}\n    }\n\n    (void)set_spell_finish(&new_st);\n}\n\n    static int\nset_spell_finish(spelltab_T *new_st)\n{\n    int\t\ti;\n\n    if (did_set_spelltab)\n    {\n\t// check that it's the same table\n\tfor (i = 0; i < 256; ++i)\n\t{\n\t    if (spelltab.st_isw[i] != new_st->st_isw[i]\n\t\t    || spelltab.st_isu[i] != new_st->st_isu[i]\n\t\t    || spelltab.st_fold[i] != new_st->st_fold[i]\n\t\t    || spelltab.st_upper[i] != new_st->st_upper[i])\n\t    {\n\t\temsg(_(e_word_characters_differ_between_spell_files));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// copy the new spelltab into the one being used\n\tspelltab = *new_st;\n\tdid_set_spelltab = TRUE;\n    }\n\n    return OK;\n}\n\n/*\n * Write the table with prefix conditions to the .spl file.\n * When \"fd\" is NULL only count the length of what is written and return it.\n */\n    static int\nwrite_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv)\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ttotlen;\n\n    if (fd != NULL)\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t    // <prefcondcnt>\n\n    totlen = 2 + gap->ga_len; // length of <prefcondcnt> and <condlen> bytes\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tp = ((char_u **)gap->ga_data)[i];\n\tif (p != NULL)\n\t{\n\t    len = (int)STRLEN(p);\n\t    if (fd != NULL)\n\t    {\n\t\tfputc(len, fd);\n\t\t*fwv &= fwrite(p, (size_t)len, (size_t)1, fd);\n\t    }\n\t    totlen += len;\n\t}\n\telse if (fd != NULL)\n\t    fputc(0, fd);\n    }\n\n    return totlen;\n}\n\n/*\n * Use map string \"map\" for languages \"lp\".\n */\n    static void\nset_map_str(slang_T *lp, char_u *map)\n{\n    char_u\t*p;\n    int\t\theadc = 0;\n    int\t\tc;\n    int\t\ti;\n\n    if (*map == NUL)\n    {\n\tlp->sl_has_map = FALSE;\n\treturn;\n    }\n    lp->sl_has_map = TRUE;\n\n    // Init the array and hash tables empty.\n    for (i = 0; i < 256; ++i)\n\tlp->sl_map_array[i] = 0;\n    hash_init(&lp->sl_map_hash);\n\n    /*\n     * The similar characters are stored separated with slashes:\n     * \"aaa/bbb/ccc/\".  Fill sl_map_array[c] with the character before c and\n     * before the same slash.  For characters above 255 sl_map_hash is used.\n     */\n    for (p = map; *p != NUL; )\n    {\n\tc = mb_cptr2char_adv(&p);\n\tif (c == '/')\n\t    headc = 0;\n\telse\n\t{\n\t    if (headc == 0)\n\t\t headc = c;\n\n\t    // Characters above 255 don't fit in sl_map_array[], put them in\n\t    // the hash table.  Each entry is the char, a NUL the headchar and\n\t    // a NUL.\n\t    if (c >= 256)\n\t    {\n\t\tint\t    cl = mb_char2len(c);\n\t\tint\t    headcl = mb_char2len(headc);\n\t\tchar_u\t    *b;\n\t\thash_T\t    hash;\n\t\thashitem_T  *hi;\n\n\t\tb = alloc(cl + headcl + 2);\n\t\tif (b == NULL)\n\t\t    return;\n\t\tmb_char2bytes(c, b);\n\t\tb[cl] = NUL;\n\t\tmb_char2bytes(headc, b + cl + 1);\n\t\tb[cl + 1 + headcl] = NUL;\n\t\thash = hash_hash(b);\n\t\thi = hash_lookup(&lp->sl_map_hash, b, hash);\n\t\tif (HASHITEM_EMPTY(hi))\n\t\t    hash_add_item(&lp->sl_map_hash, hi, b, hash);\n\t\telse\n\t\t{\n\t\t    // This should have been checked when generating the .spl\n\t\t    // file.\n\t\t    emsg(_(e_duplicate_char_in_map_entry));\n\t\t    vim_free(b);\n\t\t}\n\t    }\n\t    else\n\t\tlp->sl_map_array[c] = headc;\n\t}\n    }\n}\n\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E797:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestSpell')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellfile.c: code for reading and writing spell files.\n *\n * See spell.c for information about spell checking.\n */\n\n/*\n * Vim spell file format: <HEADER>\n *\t\t\t  <SECTIONS>\n *\t\t\t  <LWORDTREE>\n *\t\t\t  <KWORDTREE>\n *\t\t\t  <PREFIXTREE>\n *\n * <HEADER>: <fileID> <versionnr>\n *\n * <fileID>     8 bytes    \"VIMspell\"\n * <versionnr>  1 byte\t    VIMSPELLVERSION\n *\n *\n * Sections make it possible to add information to the .spl file without\n * making it incompatible with previous versions.  There are two kinds of\n * sections:\n * 1. Not essential for correct spell checking.  E.g. for making suggestions.\n *    These are skipped when not supported.\n * 2. Optional information, but essential for spell checking when present.\n *    E.g. conditions for affixes.  When this section is present but not\n *    supported an error message is given.\n *\n * <SECTIONS>: <section> ... <sectionend>\n *\n * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n *\n * <sectionID>\t  1 byte    number from 0 to 254 identifying the section\n *\n * <sectionflags> 1 byte    SNF_REQUIRED: this section is required for correct\n *\t\t\t\t\t    spell checking\n *\n * <sectionlen>   4 bytes   length of section contents, MSB first\n *\n * <sectionend>\t  1 byte    SN_END\n *\n *\n * sectionID == SN_INFO: <infotext>\n * <infotext>\t N bytes    free format text with spell file info (version,\n *\t\t\t    website, etc)\n *\n * sectionID == SN_REGION: <regionname> ...\n * <regionname>\t 2 bytes    Up to MAXREGIONS region names: ca, au, etc.  Lower\n *\t\t\t    case.  First <regionname> is region 1.\n *\n * sectionID == SN_CHARFLAGS: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * <charflagslen> 1 byte    Number of bytes in <charflags> (should be 128).\n * <charflags>  N bytes     List of flags (first one is for character 128):\n *\t\t\t    0x01  word character\tCF_WORD\n *\t\t\t    0x02  upper-case character\tCF_UPPER\n * <folcharslen>  2 bytes   Number of bytes in <folchars>.\n * <folchars>     N bytes   Folded characters, first one is for character 128.\n *\n * sectionID == SN_MIDWORD: <midword>\n * <midword>     N bytes    Characters that are word characters only when used\n *\t\t\t    in the middle of a word.\n *\n * sectionID == SN_PREFCOND: <prefcondcnt> <prefcond> ...\n * <prefcondcnt> 2 bytes    Number of <prefcond> items following.\n * <prefcond> : <condlen> <condstr>\n * <condlen>\t1 byte\t    Length of <condstr>.\n * <condstr>\tN bytes\t    Condition for the prefix.\n *\n * sectionID == SN_REP: <repcount> <rep> ...\n * <repcount>\t 2 bytes    number of <rep> items, MSB first.\n * <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n * <repfromlen>\t 1 byte\t    length of <repfrom>\n * <repfrom>\t N bytes    \"from\" part of replacement\n * <reptolen>\t 1 byte\t    length of <repto>\n * <repto>\t N bytes    \"to\" part of replacement\n *\n * sectionID == SN_REPSAL: <repcount> <rep> ...\n *   just like SN_REP but for soundfolded words\n *\n * sectionID == SN_SAL: <salflags> <salcount> <sal> ...\n * <salflags>\t 1 byte\t    flags for soundsalike conversion:\n *\t\t\t    SAL_F0LLOWUP\n *\t\t\t    SAL_COLLAPSE\n *\t\t\t    SAL_REM_ACCENTS\n * <salcount>    2 bytes    number of <sal> items following\n * <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n * <salfromlen>\t 1 byte\t    length of <salfrom>\n * <salfrom>\t N bytes    \"from\" part of soundsalike\n * <saltolen>\t 1 byte\t    length of <salto>\n * <salto>\t N bytes    \"to\" part of soundsalike\n *\n * sectionID == SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * <sofofromlen> 2 bytes    length of <sofofrom>\n * <sofofrom>\t N bytes    \"from\" part of soundfold\n * <sofotolen>\t 2 bytes    length of <sofoto>\n * <sofoto>\t N bytes    \"to\" part of soundfold\n *\n * sectionID == SN_SUGFILE: <timestamp>\n * <timestamp>   8 bytes    time in seconds that must match with .sug file\n *\n * sectionID == SN_NOSPLITSUGS: nothing\n\t *\n * sectionID == SN_NOCOMPOUNDSUGS: nothing\n *\n * sectionID == SN_WORDS: <word> ...\n * <word>\t N bytes    NUL terminated common word\n *\n * sectionID == SN_MAP: <mapstr>\n * <mapstr>\t N bytes    String with sequences of similar characters,\n *\t\t\t    separated by slashes.\n *\n * sectionID == SN_COMPOUND: <compmax> <compminlen> <compsylmax> <compoptions>\n *\t\t\t\t<comppatcount> <comppattern> ... <compflags>\n * <compmax>     1 byte\t    Maximum nr of words in compound word.\n * <compminlen>  1 byte\t    Minimal word length for compounding.\n * <compsylmax>  1 byte\t    Maximum nr of syllables in compound word.\n * <compoptions> 2 bytes    COMP_ flags.\n * <comppatcount> 2 bytes   number of <comppattern> following\n * <compflags>   N bytes    Flags from COMPOUNDRULE items, separated by\n *\t\t\t    slashes.\n *\n * <comppattern>: <comppatlen> <comppattext>\n * <comppatlen>\t 1 byte\t    length of <comppattext>\n * <comppattext> N bytes    end or begin chars from CHECKCOMPOUNDPATTERN\n *\n * sectionID == SN_NOBREAK: (empty, its presence is what matters)\n *\n * sectionID == SN_SYLLABLE: <syllable>\n * <syllable>    N bytes    String from SYLLABLE item.\n *\n * <LWORDTREE>: <wordtree>\n *\n * <KWORDTREE>: <wordtree>\n *\n * <PREFIXTREE>: <wordtree>\n *\n *\n * <wordtree>: <nodecount> <nodedata> ...\n *\n * <nodecount>\t4 bytes\t    Number of nodes following.  MSB first.\n *\n * <nodedata>: <siblingcount> <sibling> ...\n *\n * <siblingcount> 1 byte    Number of siblings in this node.  The siblings\n *\t\t\t    follow in sorted order.\n *\n * <sibling>: <byte> [ <nodeidx> <xbyte>\n *\t\t      | <flags> [<flags2>] [<region>] [<affixID>]\n *\t\t      | [<pflags>] <affixID> <prefcondnr> ]\n *\n * <byte>\t1 byte\t    Byte value of the sibling.  Special cases:\n *\t\t\t    BY_NOFLAGS: End of word without flags and for all\n *\t\t\t\t\tregions.\n *\t\t\t\t\tFor PREFIXTREE <affixID> and\n *\t\t\t\t\t<prefcondnr> follow.\n *\t\t\t    BY_FLAGS:   End of word, <flags> follow.\n *\t\t\t\t\tFor PREFIXTREE <pflags>, <affixID>\n *\t\t\t\t\tand <prefcondnr> follow.\n *\t\t\t    BY_FLAGS2:  End of word, <flags> and <flags2>\n *\t\t\t\t\tfollow.  Not used in PREFIXTREE.\n *\t\t\t    BY_INDEX:   Child of sibling is shared, <nodeidx>\n *\t\t\t\t\tand <xbyte> follow.\n *\n * <nodeidx>\t3 bytes\t    Index of child for this sibling, MSB first.\n *\n * <xbyte>\t1 byte\t    byte value of the sibling.\n *\n * <flags>\t1 byte\t    bitmask of:\n *\t\t\t    WF_ALLCAP\tword must have only capitals\n *\t\t\t    WF_ONECAP   first char of word must be capital\n *\t\t\t    WF_KEEPCAP\tkeep-case word\n *\t\t\t    WF_FIXCAP   keep-case word, all caps not allowed\n *\t\t\t    WF_RARE\trare word\n *\t\t\t    WF_BANNED\tbad word\n *\t\t\t    WF_REGION\t<region> follows\n *\t\t\t    WF_AFX\t<affixID> follows\n *\n * <flags2>\t1 byte\t    Bitmask of:\n *\t\t\t    WF_HAS_AFF >> 8   word includes affix\n *\t\t\t    WF_NEEDCOMP >> 8  word only valid in compound\n *\t\t\t    WF_NOSUGGEST >> 8  word not used for suggestions\n *\t\t\t    WF_COMPROOT >> 8  word already a compound\n *\t\t\t    WF_NOCOMPBEF >> 8 no compounding before this word\n *\t\t\t    WF_NOCOMPAFT >> 8 no compounding after this word\n *\n * <pflags>\t1 byte\t    bitmask of:\n *\t\t\t    WFP_RARE\trare prefix\n *\t\t\t    WFP_NC\tnon-combining prefix\n *\t\t\t    WFP_UP\tletter after prefix made upper case\n *\n * <region>\t1 byte\t    Bitmask for regions in which word is valid.  When\n *\t\t\t    omitted it's valid in all regions.\n *\t\t\t    Lowest bit is for region 1.\n *\n * <affixID>\t1 byte\t    ID of affix that can be used with this word.  In\n *\t\t\t    PREFIXTREE used for the required prefix ID.\n *\n * <prefcondnr>\t2 bytes\t    Prefix condition number, index in <prefcond> list\n *\t\t\t    from HEADER.\n *\n * All text characters are in 'encoding', but stored as single bytes.\n */\n\n/*\n * Vim .sug file format:  <SUGHEADER>\n *\t\t\t  <SUGWORDTREE>\n *\t\t\t  <SUGTABLE>\n *\n * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n *\n * <fileID>     6 bytes     \"VIMsug\"\n * <versionnr>  1 byte      VIMSUGVERSION\n * <timestamp>  8 bytes     timestamp that must match with .spl file\n *\n *\n * <SUGWORDTREE>: <wordtree>  (see above, no flags or region used)\n *\n *\n * <SUGTABLE>: <sugwcount> <sugline> ...\n *\n * <sugwcount>\t4 bytes\t    number of <sugline> following\n *\n * <sugline>: <sugnr> ... NUL\n *\n * <sugnr>:     X bytes     word number that results in this soundfolded word,\n *\t\t\t    stored as an offset to the previous number in as\n *\t\t\t    few bytes as possible, see offset2bytes())\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n// Special byte values for <byte>.  Some are only used in the tree for\n// postponed prefixes, some only in the other trees.  This is a bit messy...\n#define BY_NOFLAGS\t0\t// end of word without flags or region; for\n\t\t\t\t// postponed prefix: no <pflags>\n#define BY_INDEX\t1\t// child is shared, index follows\n#define BY_FLAGS\t2\t// end of word, <flags> byte follows; for\n\t\t\t\t// postponed prefix: <pflags> follows\n#define BY_FLAGS2\t3\t// end of word, <flags> and <flags2> bytes\n\t\t\t\t// follow; never used in prefix tree\n#define BY_SPECIAL  BY_FLAGS2\t// highest special byte value\n\n#define ZERO_FLAG\t65009\t// used when flag is zero: \"0\"\n\n// Flags used in .spl file for soundsalike flags.\n#define SAL_F0LLOWUP\t\t1\n#define SAL_COLLAPSE\t\t2\n#define SAL_REM_ACCENTS\t\t4\n\n#define VIMSPELLMAGIC \"VIMspell\"  // string at start of Vim spell file\n#define VIMSPELLMAGICL 8\n#define VIMSPELLVERSION 50\n\n// Section IDs.  Only renumber them when VIMSPELLVERSION changes!\n#define SN_REGION\t0\t// <regionname> section\n#define SN_CHARFLAGS\t1\t// charflags section\n#define SN_MIDWORD\t2\t// <midword> section\n#define SN_PREFCOND\t3\t// <prefcond> section\n#define SN_REP\t\t4\t// REP items section\n#define SN_SAL\t\t5\t// SAL items section\n#define SN_SOFO\t\t6\t// soundfolding section\n#define SN_MAP\t\t7\t// MAP items section\n#define SN_COMPOUND\t8\t// compound words section\n#define SN_SYLLABLE\t9\t// syllable section\n#define SN_NOBREAK\t10\t// NOBREAK section\n#define SN_SUGFILE\t11\t// timestamp for .sug file\n#define SN_REPSAL\t12\t// REPSAL items section\n#define SN_WORDS\t13\t// common words\n#define SN_NOSPLITSUGS\t14\t// don't split word for suggestions\n#define SN_INFO\t\t15\t// info section\n#define SN_NOCOMPOUNDSUGS 16\t// don't compound for suggestions\n#define SN_END\t\t255\t// end of sections\n\n#define SNF_REQUIRED\t1\t// <sectionflags>: required section\n\n#define CF_WORD\t\t0x01\n#define CF_UPPER\t0x02\n\n/*\n * Loop through all the siblings of a node (including the node)\n */\n#define FOR_ALL_NODE_SIBLINGS(node, np) \\\n    for ((np) = (node); (np) != NULL; (np) = (np)->wn_sibling)\n\nstatic int set_spell_finish(spelltab_T\t*new_st);\nstatic int write_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv);\nstatic int read_region_section(FILE *fd, slang_T *slang, int len);\nstatic int read_charflags_section(FILE *fd);\nstatic int read_prefcond_section(FILE *fd, slang_T *lp);\nstatic int read_rep_section(FILE *fd, garray_T *gap, short *first);\nstatic int read_sal_section(FILE *fd, slang_T *slang);\nstatic int read_words_section(FILE *fd, slang_T *lp, int len);\nstatic int read_sofo_section(FILE *fd, slang_T *slang);\nstatic int read_compound(FILE *fd, slang_T *slang, int len);\nstatic int set_sofo(slang_T *lp, char_u *from, char_u *to);\nstatic void set_sal_first(slang_T *lp);\nstatic int *mb_str2wide(char_u *s);\nstatic int spell_read_tree(FILE *fd, char_u **bytsp, long *bytsp_len, idx_T **idxsp, int prefixtree, int prefixcnt);\nstatic idx_T read_tree_node(FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr);\nstatic void set_spell_charflags(char_u *flags, int cnt, char_u *upp);\nstatic int set_spell_chartab(char_u *fol, char_u *low, char_u *upp);\nstatic void set_map_str(slang_T *lp, char_u *map);\n\n\nstatic char *e_afftrailing = N_(\"Trailing text in %s line %d: %s\");\nstatic char *e_affname = N_(\"Affix name too long in %s line %d: %s\");\nstatic char *msg_compressing = N_(\"Compressing word tree...\");\n\n/*\n * Load one spell file and store the info into a slang_T.\n *\n * This is invoked in three ways:\n * - From spell_load_cb() to load a spell file for the first time.  \"lang\" is\n *   the language name, \"old_lp\" is NULL.  Will allocate an slang_T.\n * - To reload a spell file that was changed.  \"lang\" is NULL and \"old_lp\"\n *   points to the existing slang_T.\n * - Just after writing a .spl file; it's read back to produce the .sug file.\n *   \"old_lp\" is NULL and \"lang\" is NULL.  Will allocate an slang_T.\n *\n * Returns the slang_T the spell file was loaded into.  NULL for error.\n */\n    slang_T *\nspell_load_file(\n    char_u\t*fname,\n    char_u\t*lang,\n    slang_T\t*old_lp,\n    int\t\tsilent)\t\t// no error if file doesn't exist\n{\n    FILE\t*fd;\n    char_u\tbuf[VIMSPELLMAGICL];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tn;\n    int\t\tlen;\n    slang_T\t*lp = NULL;\n    int\t\tc = 0;\n    int\t\tres;\n    int\t\tdid_estack_push = FALSE;\n    ESTACK_CHECK_DECLARATION\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tif (!silent)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse if (p_verbose > 2)\n\t{\n\t    verbose_enter();\n\t    smsg((const char *)e_cant_open_file_str, fname);\n\t    verbose_leave();\n\t}\n\tgoto endFAIL;\n    }\n    if (p_verbose > 2)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading spell file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    if (old_lp == NULL)\n    {\n\tlp = slang_alloc(lang);\n\tif (lp == NULL)\n\t    goto endFAIL;\n\n\t// Remember the file name, used to reload the file when it's updated.\n\tlp->sl_fname = vim_strsave(fname);\n\tif (lp->sl_fname == NULL)\n\t    goto endFAIL;\n\n\t// Check for .add.spl (_add.spl for VMS).\n\tlp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;\n    }\n    else\n\tlp = old_lp;\n\n    // Set sourcing_name, so that error messages mention the file name.\n    estack_push(ETYPE_SPELL, fname, 0);\n    ESTACK_CHECK_SETUP\n    did_estack_push = TRUE;\n\n    /*\n     * <HEADER>: <fileID>\n     */\n    for (i = 0; i < VIMSPELLMAGICL; ++i)\n\tbuf[i] = getc(fd);\t\t\t\t// <fileID>\n    if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)\n    {\n\temsg(_(e_this_does_not_look_like_spell_file));\n\tgoto endFAIL;\n    }\n    c = getc(fd);\t\t\t\t\t// <versionnr>\n    if (c < VIMSPELLVERSION)\n    {\n\temsg(_(e_old_spell_file_needs_to_be_updated));\n\tgoto endFAIL;\n    }\n    else if (c > VIMSPELLVERSION)\n    {\n\temsg(_(e_spell_file_is_for_newer_version_of_vim));\n\tgoto endFAIL;\n    }\n\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     * <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n     */\n    for (;;)\n    {\n\tn = getc(fd);\t\t\t    // <sectionID> or <sectionend>\n\tif (n == SN_END)\n\t    break;\n\tc = getc(fd);\t\t\t\t\t// <sectionflags>\n\tlen = get4c(fd);\t\t\t\t// <sectionlen>\n\tif (len < 0)\n\t    goto truncerr;\n\n\tres = 0;\n\tswitch (n)\n\t{\n\t    case SN_INFO:\n\t\tlp->sl_info = read_string(fd, len);\t// <infotext>\n\t\tif (lp->sl_info == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_REGION:\n\t\tres = read_region_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_CHARFLAGS:\n\t\tres = read_charflags_section(fd);\n\t\tbreak;\n\n\t    case SN_MIDWORD:\n\t\tlp->sl_midword = read_string(fd, len);\t// <midword>\n\t\tif (lp->sl_midword == NULL)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    case SN_PREFCOND:\n\t\tres = read_prefcond_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_REP:\n\t\tres = read_rep_section(fd, &lp->sl_rep, lp->sl_rep_first);\n\t\tbreak;\n\n\t    case SN_REPSAL:\n\t\tres = read_rep_section(fd, &lp->sl_repsal, lp->sl_repsal_first);\n\t\tbreak;\n\n\t    case SN_SAL:\n\t\tres = read_sal_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_SOFO:\n\t\tres = read_sofo_section(fd, lp);\n\t\tbreak;\n\n\t    case SN_MAP:\n\t\tp = read_string(fd, len);\t\t// <mapstr>\n\t\tif (p == NULL)\n\t\t    goto endFAIL;\n\t\tset_map_str(lp, p);\n\t\tvim_free(p);\n\t\tbreak;\n\n\t    case SN_WORDS:\n\t\tres = read_words_section(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_SUGFILE:\n\t\tlp->sl_sugtime = get8ctime(fd);\t\t// <timestamp>\n\t\tbreak;\n\n\t    case SN_NOSPLITSUGS:\n\t\tlp->sl_nosplitsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_NOCOMPOUNDSUGS:\n\t\tlp->sl_nocompoundsugs = TRUE;\n\t\tbreak;\n\n\t    case SN_COMPOUND:\n\t\tres = read_compound(fd, lp, len);\n\t\tbreak;\n\n\t    case SN_NOBREAK:\n\t\tlp->sl_nobreak = TRUE;\n\t\tbreak;\n\n\t    case SN_SYLLABLE:\n\t\tlp->sl_syllable = read_string(fd, len);\t// <syllable>\n\t\tif (lp->sl_syllable == NULL)\n\t\t    goto endFAIL;\n\t\tif (init_syl_tab(lp) != OK)\n\t\t    goto endFAIL;\n\t\tbreak;\n\n\t    default:\n\t\t// Unsupported section.  When it's required give an error\n\t\t// message.  When it's not required skip the contents.\n\t\tif (c & SNF_REQUIRED)\n\t\t{\n\t\t    emsg(_(e_unsupported_section_in_spell_file));\n\t\t    goto endFAIL;\n\t\t}\n\t\twhile (--len >= 0)\n\t\t    if (getc(fd) < 0)\n\t\t\tgoto truncerr;\n\t\tbreak;\n\t}\nsomeerror:\n\tif (res == SP_FORMERROR)\n\t{\n\t    emsg(_(e_format_error_in_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_TRUNCERROR)\n\t{\ntruncerr:\n\t    emsg(_(e_truncated_spell_file));\n\t    goto endFAIL;\n\t}\n\tif (res == SP_OTHERERROR)\n\t    goto endFAIL;\n    }\n\n    // <LWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_fbyts, &lp->sl_fbyts_len,\n\t\t\t\t\t\t      &lp->sl_fidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <KWORDTREE>\n    res = spell_read_tree(fd, &lp->sl_kbyts, NULL, &lp->sl_kidxs, FALSE, 0);\n    if (res != 0)\n\tgoto someerror;\n\n    // <PREFIXTREE>\n    res = spell_read_tree(fd, &lp->sl_pbyts, NULL, &lp->sl_pidxs, TRUE,\n\t\t\t\t\t\t\t    lp->sl_prefixcnt);\n    if (res != 0)\n\tgoto someerror;\n\n    // For a new file link it in the list of spell files.\n    if (old_lp == NULL && lang != NULL)\n    {\n\tlp->sl_next = first_lang;\n\tfirst_lang = lp;\n    }\n\n    goto endOK;\n\nendFAIL:\n    if (lang != NULL)\n\t// truncating the name signals the error to spell_load_lang()\n\t*lang = NUL;\n    if (lp != NULL && old_lp == NULL)\n\tslang_free(lp);\n    lp = NULL;\n\nendOK:\n    if (fd != NULL)\n\tfclose(fd);\n    if (did_estack_push)\n    {\n\tESTACK_CHECK_NOW\n\testack_pop();\n    }\n\n    return lp;\n}\n\n/*\n * Fill in the wordcount fields for a trie.\n * Returns the total number of words.\n */\n    static void\ntree_count_words(char_u *byts, idx_T *idxs)\n{\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    int\t\twordcount[MAXWLEN];\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    fast_breakcheck();\n\t}\n\telse\n\t{\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// End of word, count it.\n\t\t++wordcount[depth];\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).\n\t\twhile (byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper to count the words.\n\t\t++depth;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Load the .sug files for languages that have one and weren't loaded yet.\n */\n    void\nsuggest_load_files(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    char_u\t*dotp;\n    FILE\t*fd;\n    char_u\tbuf[MAXWLEN];\n    int\t\ti;\n    time_t\ttimestamp;\n    int\t\twcount;\n    int\t\twordnr;\n    garray_T\tga;\n    int\t\tc;\n\n    // Do this for all languages that support sound folding.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sugtime != 0 && !slang->sl_sugloaded)\n\t{\n\t    // Change \".spl\" to \".sug\" and open the file.  When the file isn't\n\t    // found silently skip it.  Do set \"sl_sugloaded\" so that we\n\t    // don't try again and again.\n\t    slang->sl_sugloaded = TRUE;\n\n\t    dotp = vim_strrchr(slang->sl_fname, '.');\n\t    if (dotp == NULL || fnamecmp(dotp, \".spl\") != 0)\n\t\tcontinue;\n\t    STRCPY(dotp, \".sug\");\n\t    fd = mch_fopen((char *)slang->sl_fname, \"r\");\n\t    if (fd == NULL)\n\t\tgoto nextone;\n\n\t    /*\n\t     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n\t     */\n\t    for (i = 0; i < VIMSUGMAGICL; ++i)\n\t\tbuf[i] = getc(fd);\t\t\t// <fileID>\n\t    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)\n\t    {\n\t\tsemsg(_(e_this_does_not_look_like_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    c = getc(fd);\t\t\t\t// <versionnr>\n\t    if (c < VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_old_sug_file_needs_to_be_updated_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\t    else if (c > VIMSUGVERSION)\n\t    {\n\t\tsemsg(_(e_sug_file_is_for_newer_version_of_vim_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    // Check the timestamp, it must be exactly the same as the one in\n\t    // the .spl file.  Otherwise the word numbers won't match.\n\t    timestamp = get8ctime(fd);\t\t\t// <timestamp>\n\t    if (timestamp != slang->sl_sugtime)\n\t    {\n\t\tsemsg(_(e_sug_file_doesnt_match_spl_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGWORDTREE>: <wordtree>\n\t     * Read the trie with the soundfolded words.\n\t     */\n\t    if (spell_read_tree(fd, &slang->sl_sbyts, NULL, &slang->sl_sidxs,\n\t\t\t\t\t\t\t       FALSE, 0) != 0)\n\t    {\nsomeerror:\n\t\tsemsg(_(e_error_while_reading_sug_file_str),\n\t\t\t\t\t\t\t     slang->sl_fname);\n\t\tslang_clear_sug(slang);\n\t\tgoto nextone;\n\t    }\n\n\t    /*\n\t     * <SUGTABLE>: <sugwcount> <sugline> ...\n\t     *\n\t     * Read the table with word numbers.  We use a file buffer for\n\t     * this, because it's so much like a file with lines.  Makes it\n\t     * possible to swap the info and save on memory use.\n\t     */\n\t    slang->sl_sugbuf = open_spellbuf();\n\t    if (slang->sl_sugbuf == NULL)\n\t\tgoto someerror;\n\t\t\t\t\t\t\t    // <sugwcount>\n\t    wcount = get4c(fd);\n\t    if (wcount < 0)\n\t\tgoto someerror;\n\n\t    // Read all the wordnr lists into the buffer, one NUL terminated\n\t    // list per line.\n\t    ga_init2(&ga, 1, 100);\n\t    for (wordnr = 0; wordnr < wcount; ++wordnr)\n\t    {\n\t\tga.ga_len = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    c = getc(fd);\t\t\t    // <sugline>\n\t\t    if (c < 0 || ga_grow(&ga, 1) == FAIL)\n\t\t\tgoto someerror;\n\t\t    ((char_u *)ga.ga_data)[ga.ga_len++] = c;\n\t\t    if (c == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,\n\t\t\t\t\t ga.ga_data, ga.ga_len, TRUE) == FAIL)\n\t\t    goto someerror;\n\t    }\n\t    ga_clear(&ga);\n\n\t    /*\n\t     * Need to put word counts in the word tries, so that we can find\n\t     * a word by its number.\n\t     */\n\t    tree_count_words(slang->sl_fbyts, slang->sl_fidxs);\n\t    tree_count_words(slang->sl_sbyts, slang->sl_sidxs);\n\nnextone:\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    STRCPY(dotp, \".spl\");\n\t}\n    }\n}\n\n\n/*\n * Read a length field from \"fd\" in \"cnt_bytes\" bytes.\n * Allocate memory, read the string into it and add a NUL at the end.\n * Returns NULL when the count is zero.\n * Sets \"*cntp\" to SP_*ERROR when there is an error, length of the result\n * otherwise.\n */\n    static char_u *\nread_cnt_string(FILE *fd, int cnt_bytes, int *cntp)\n{\n    int\t\tcnt = 0;\n    int\t\ti;\n    char_u\t*str;\n\n    // read the length bytes, MSB first\n    for (i = 0; i < cnt_bytes; ++i)\n    {\n\tint c = getc(fd);\n\n\tif (c == EOF)\n\t{\n\t    *cntp = SP_TRUNCERROR;\n\t    return NULL;\n\t}\n\tcnt = (cnt << 8) + (unsigned)c;\n    }\n    *cntp = cnt;\n    if (cnt == 0)\n\treturn NULL;\t    // nothing to read, return NULL\n\n    str = read_string(fd, cnt);\n    if (str == NULL)\n\t*cntp = SP_OTHERERROR;\n    return str;\n}\n\n/*\n * Read SN_REGION: <regionname> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_region_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\ti;\n\n    if (len > MAXREGIONS * 2)\n\treturn SP_FORMERROR;\n    for (i = 0; i < len; ++i)\n\tlp->sl_regions[i] = getc(fd);\t\t\t// <regionname>\n    lp->sl_regions[len] = NUL;\n    return 0;\n}\n\n/*\n * Read SN_CHARFLAGS section: <charflagslen> <charflags>\n *\t\t\t\t<folcharslen> <folchars>\n * Return SP_*ERROR flags.\n */\n    static int\nread_charflags_section(FILE *fd)\n{\n    char_u\t*flags;\n    char_u\t*fol;\n    int\t\tflagslen, follen;\n\n    // <charflagslen> <charflags>\n    flags = read_cnt_string(fd, 1, &flagslen);\n    if (flagslen < 0)\n\treturn flagslen;\n\n    // <folcharslen> <folchars>\n    fol = read_cnt_string(fd, 2, &follen);\n    if (follen < 0)\n    {\n\tvim_free(flags);\n\treturn follen;\n    }\n\n    // Set the word-char flags and fill SPELL_ISUPPER() table.\n    if (flags != NULL && fol != NULL)\n\tset_spell_charflags(flags, flagslen, fol);\n\n    vim_free(flags);\n    vim_free(fol);\n\n    // When <charflagslen> is zero then <fcharlen> must also be zero.\n    if ((flags == NULL) != (fol == NULL))\n\treturn SP_FORMERROR;\n    return 0;\n}\n\n/*\n * Read SN_PREFCOND section.\n * Return SP_*ERROR flags.\n */\n    static int\nread_prefcond_section(FILE *fd, slang_T *lp)\n{\n    int\t\tcnt;\n    int\t\ti;\n    int\t\tn;\n    char_u\t*p;\n    char_u\tbuf[MAXWLEN + 1];\n\n    // <prefcondcnt> <prefcond> ...\n    cnt = get2c(fd);\t\t\t\t\t// <prefcondcnt>\n    if (cnt <= 0)\n\treturn SP_FORMERROR;\n\n    lp->sl_prefprog = ALLOC_CLEAR_MULT(regprog_T *, cnt);\n    if (lp->sl_prefprog == NULL)\n\treturn SP_OTHERERROR;\n    lp->sl_prefixcnt = cnt;\n\n    for (i = 0; i < cnt; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tn = getc(fd);\t\t\t\t\t// <condlen>\n\tif (n < 0 || n >= MAXWLEN)\n\t    return SP_FORMERROR;\n\n\t// When <condlen> is zero we have an empty condition.  Otherwise\n\t// compile the regexp program used to check for the condition.\n\tif (n > 0)\n\t{\n\t    buf[0] = '^';\t    // always match at one position only\n\t    p = buf + 1;\n\t    while (n-- > 0)\n\t\t*p++ = getc(fd);\t\t\t// <condstr>\n\t    *p = NUL;\n\t    lp->sl_prefprog[i] = vim_regcomp(buf, RE_MAGIC + RE_STRING);\n\t}\n    }\n    return 0;\n}\n\n/*\n * Read REP or REPSAL items section from \"fd\": <repcount> <rep> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_rep_section(FILE *fd, garray_T *gap, short *first)\n{\n    int\t\tcnt;\n    fromto_T\t*ftp;\n    int\t\ti;\n\n    cnt = get2c(fd);\t\t\t\t\t// <repcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    if (ga_grow(gap, cnt) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[gap->ga_len];\n\tftp->ft_from = read_cnt_string(fd, 1, &i);\n\tif (i < 0)\n\t    return i;\n\tif (i == 0)\n\t    return SP_FORMERROR;\n\tftp->ft_to = read_cnt_string(fd, 1, &i);\n\tif (i <= 0)\n\t{\n\t    vim_free(ftp->ft_from);\n\t    if (i < 0)\n\t\treturn i;\n\t    return SP_FORMERROR;\n\t}\n    }\n\n    // Fill the first-index table.\n    for (i = 0; i < 256; ++i)\n\tfirst[i] = -1;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tftp = &((fromto_T *)gap->ga_data)[i];\n\tif (first[*ftp->ft_from] == -1)\n\t    first[*ftp->ft_from] = i;\n    }\n    return 0;\n}\n\n/*\n * Read SN_SAL section: <salflags> <salcount> <sal> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_sal_section(FILE *fd, slang_T *slang)\n{\n    int\t\ti;\n    int\t\tcnt;\n    garray_T\t*gap;\n    salitem_T\t*smp;\n    int\t\tccnt;\n    char_u\t*p;\n\n    slang->sl_sofo = FALSE;\n\n    i = getc(fd);\t\t\t\t// <salflags>\n    if (i & SAL_F0LLOWUP)\n\tslang->sl_followup = TRUE;\n    if (i & SAL_COLLAPSE)\n\tslang->sl_collapse = TRUE;\n    if (i & SAL_REM_ACCENTS)\n\tslang->sl_rem_accents = TRUE;\n\n    cnt = get2c(fd);\t\t\t\t// <salcount>\n    if (cnt < 0)\n\treturn SP_TRUNCERROR;\n\n    gap = &slang->sl_sal;\n    ga_init2(gap, sizeof(salitem_T), 10);\n    if (ga_grow(gap, cnt + 1) == FAIL)\n\treturn SP_OTHERERROR;\n\n    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n    for (; gap->ga_len < cnt; ++gap->ga_len)\n    {\n\tint\tc = NUL;\n\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tccnt = getc(fd);\t\t\t// <salfromlen>\n\tif (ccnt < 0)\n\t    return SP_TRUNCERROR;\n\tif ((p = alloc(ccnt + 2)) == NULL)\n\t    return SP_OTHERERROR;\n\tsmp->sm_lead = p;\n\n\t// Read up to the first special char into sm_lead.\n\tfor (i = 0; i < ccnt; ++i)\n\t{\n\t    c = getc(fd);\t\t\t// <salfrom>\n\t    if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)\n\t\tbreak;\n\t    *p++ = c;\n\t}\n\tsmp->sm_leadlen = (int)(p - smp->sm_lead);\n\t*p++ = NUL;\n\n\t// Put (abc) chars in sm_oneof, if any.\n\tif (c == '(')\n\t{\n\t    smp->sm_oneof = p;\n\t    for (++i; i < ccnt; ++i)\n\t    {\n\t\tc = getc(fd);\t\t\t// <salfrom>\n\t\tif (c == ')')\n\t\t    break;\n\t\t*p++ = c;\n\t    }\n\t    *p++ = NUL;\n\t    if (++i < ccnt)\n\t\tc = getc(fd);\n\t}\n\telse\n\t    smp->sm_oneof = NULL;\n\n\t// Any following chars go in sm_rules.\n\tsmp->sm_rules = p;\n\tif (i < ccnt)\n\t    // store the char we got while checking for end of sm_lead\n\t    *p++ = c;\n\tfor (++i; i < ccnt; ++i)\n\t    *p++ = getc(fd);\t\t\t// <salfrom>\n\t*p++ = NUL;\n\n\t// <saltolen> <salto>\n\tsmp->sm_to = read_cnt_string(fd, 1, &ccnt);\n\tif (ccnt < 0)\n\t{\n\t    vim_free(smp->sm_lead);\n\t    return ccnt;\n\t}\n\n\tif (has_mbyte)\n\t{\n\t    // convert the multi-byte strings to wide char strings\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = mb_charlen(smp->sm_lead);\n\t    if (smp->sm_oneof == NULL)\n\t\tsmp->sm_oneof_w = NULL;\n\t    else\n\t\tsmp->sm_oneof_w = mb_str2wide(smp->sm_oneof);\n\t    if (smp->sm_to == NULL)\n\t\tsmp->sm_to_w = NULL;\n\t    else\n\t\tsmp->sm_to_w = mb_str2wide(smp->sm_to);\n\t    if (smp->sm_lead_w == NULL\n\t\t    || (smp->sm_oneof_w == NULL && smp->sm_oneof != NULL)\n\t\t    || (smp->sm_to_w == NULL && smp->sm_to != NULL))\n\t    {\n\t\tvim_free(smp->sm_lead);\n\t\tvim_free(smp->sm_to);\n\t\tvim_free(smp->sm_lead_w);\n\t\tvim_free(smp->sm_oneof_w);\n\t\tvim_free(smp->sm_to_w);\n\t\treturn SP_OTHERERROR;\n\t    }\n\t}\n    }\n\n    if (gap->ga_len > 0)\n    {\n\t// Add one extra entry to mark the end with an empty sm_lead.  Avoids\n\t// that we need to check the index every time.\n\tsmp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n\tif ((p = alloc(1)) == NULL)\n\t    return SP_OTHERERROR;\n\tp[0] = NUL;\n\tsmp->sm_lead = p;\n\tsmp->sm_leadlen = 0;\n\tsmp->sm_oneof = NULL;\n\tsmp->sm_rules = p;\n\tsmp->sm_to = NULL;\n\tif (has_mbyte)\n\t{\n\t    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n\t    smp->sm_leadlen = 0;\n\t    smp->sm_oneof_w = NULL;\n\t    smp->sm_to_w = NULL;\n\t}\n\t++gap->ga_len;\n    }\n\n    // Fill the first-index table.\n    set_sal_first(slang);\n\n    return 0;\n}\n\n/*\n * Read SN_WORDS: <word> ...\n * Return SP_*ERROR flags.\n */\n    static int\nread_words_section(FILE *fd, slang_T *lp, int len)\n{\n    int\t\tdone = 0;\n    int\t\ti;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    while (done < len)\n    {\n\t// Read one word at a time.\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t\treturn SP_TRUNCERROR;\n\t    word[i] = c;\n\t    if (word[i] == NUL)\n\t\tbreak;\n\t    if (i == MAXWLEN - 1)\n\t\treturn SP_FORMERROR;\n\t}\n\n\t// Init the count to 10.\n\tcount_common_word(lp, word, -1, 10);\n\tdone += i + 1;\n    }\n    return 0;\n}\n\n/*\n * SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n * Return SP_*ERROR flags.\n */\n    static int\nread_sofo_section(FILE *fd, slang_T *slang)\n{\n    int\t\tcnt;\n    char_u\t*from, *to;\n    int\t\tres;\n\n    slang->sl_sofo = TRUE;\n\n    // <sofofromlen> <sofofrom>\n    from = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n\treturn cnt;\n\n    // <sofotolen> <sofoto>\n    to = read_cnt_string(fd, 2, &cnt);\n    if (cnt < 0)\n    {\n\tvim_free(from);\n\treturn cnt;\n    }\n\n    // Store the info in slang->sl_sal and/or slang->sl_sal_first.\n    if (from != NULL && to != NULL)\n\tres = set_sofo(slang, from, to);\n    else if (from != NULL || to != NULL)\n\tres = SP_FORMERROR;    // only one of two strings is an error\n    else\n\tres = 0;\n\n    vim_free(from);\n    vim_free(to);\n    return res;\n}\n\n/*\n * Read the compound section from the .spl file:\n *\t<compmax> <compminlen> <compsylmax> <compoptions> <compflags>\n * Returns SP_*ERROR flags.\n */\n    static int\nread_compound(FILE *fd, slang_T *slang, int len)\n{\n    int\t\ttodo = len;\n    int\t\tc;\n    int\t\tatstart;\n    char_u\t*pat;\n    char_u\t*pp;\n    char_u\t*cp;\n    char_u\t*ap;\n    char_u\t*crp;\n    int\t\tcnt;\n    garray_T\t*gap;\n\n    if (todo < 2)\n\treturn SP_FORMERROR;\t// need at least two bytes\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compmax>\n    if (c < 2)\n\tc = MAXWLEN;\n    slang->sl_compmax = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compminlen>\n    if (c < 1)\n\tc = 0;\n    slang->sl_compminlen = c;\n\n    --todo;\n    c = getc(fd);\t\t\t\t\t// <compsylmax>\n    if (c < 1)\n\tc = MAXWLEN;\n    slang->sl_compsylmax = c;\n\n    c = getc(fd);\t\t\t\t\t// <compoptions>\n    if (c != 0)\n\tungetc(c, fd);\t    // be backwards compatible with Vim 7.0b\n    else\n    {\n\t--todo;\n\tc = getc(fd);\t    // only use the lower byte for now\n\t--todo;\n\tslang->sl_compoptions = c;\n\n\tgap = &slang->sl_comppat;\n\tc = get2c(fd);\t\t\t\t\t// <comppatcount>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\ttodo -= 2;\n\tga_init2(gap, sizeof(char_u *), c);\n\tif (ga_grow(gap, c) == OK)\n\t    while (--c >= 0)\n\t    {\n\t\t((char_u **)(gap->ga_data))[gap->ga_len++] =\n\t\t\t\t\t\t  read_cnt_string(fd, 1, &cnt);\n\t\t\t\t\t    // <comppatlen> <comppattext>\n\t\tif (cnt < 0)\n\t\t    return cnt;\n\t\ttodo -= cnt + 1;\n\t    }\n    }\n    if (todo < 0)\n\treturn SP_FORMERROR;\n\n    // Turn the COMPOUNDRULE items into a regexp pattern:\n    // \"a[bc]/a*b+\" -> \"^\\(a[bc]\\|a*b\\+\\)$\".\n    // Inserting backslashes may double the length, \"^\\(\\)$<Nul>\" is 7 bytes.\n    // Conversion to utf-8 may double the size.\n    c = todo * 2 + 7;\n    if (enc_utf8)\n\tc += todo * 2;\n    pat = alloc(c);\n    if (pat == NULL)\n\treturn SP_OTHERERROR;\n\n    // We also need a list of all flags that can appear at the start and one\n    // for all flags.\n    cp = alloc(todo + 1);\n    if (cp == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compstartflags = cp;\n    *cp = NUL;\n\n    ap = alloc(todo + 1);\n    if (ap == NULL)\n    {\n\tvim_free(pat);\n\treturn SP_OTHERERROR;\n    }\n    slang->sl_compallflags = ap;\n    *ap = NUL;\n\n    // And a list of all patterns in their original form, for checking whether\n    // compounding may work in match_compoundrule().  This is freed when we\n    // encounter a wildcard, the check doesn't work then.\n    crp = alloc(todo + 1);\n    slang->sl_comprules = crp;\n\n    pp = pat;\n    *pp++ = '^';\n    *pp++ = '\\\\';\n    *pp++ = '(';\n\n    atstart = 1;\n    while (todo-- > 0)\n    {\n\tc = getc(fd);\t\t\t\t\t// <compflags>\n\tif (c == EOF)\n\t{\n\t    vim_free(pat);\n\t    return SP_TRUNCERROR;\n\t}\n\n\t// Add all flags to \"sl_compallflags\".\n\tif (vim_strchr((char_u *)\"?*+[]/\", c) == NULL\n\t\t&& !byte_in_str(slang->sl_compallflags, c))\n\t{\n\t    *ap++ = c;\n\t    *ap = NUL;\n\t}\n\n\tif (atstart != 0)\n\t{\n\t    // At start of item: copy flags to \"sl_compstartflags\".  For a\n\t    // [abc] item set \"atstart\" to 2 and copy up to the ']'.\n\t    if (c == '[')\n\t\tatstart = 2;\n\t    else if (c == ']')\n\t\tatstart = 0;\n\t    else\n\t    {\n\t\tif (!byte_in_str(slang->sl_compstartflags, c))\n\t\t{\n\t\t    *cp++ = c;\n\t\t    *cp = NUL;\n\t\t}\n\t\tif (atstart == 1)\n\t\t    atstart = 0;\n\t    }\n\t}\n\n\t// Copy flag to \"sl_comprules\", unless we run into a wildcard.\n\tif (crp != NULL)\n\t{\n\t    if (c == '?' || c == '+' || c == '*')\n\t    {\n\t\tVIM_CLEAR(slang->sl_comprules);\n\t\tcrp = NULL;\n\t    }\n\t    else\n\t\t*crp++ = c;\n\t}\n\n\tif (c == '/')\t    // slash separates two items\n\t{\n\t    *pp++ = '\\\\';\n\t    *pp++ = '|';\n\t    atstart = 1;\n\t}\n\telse\t\t    // normal char, \"[abc]\" and '*' are copied as-is\n\t{\n\t    if (c == '?' || c == '+' || c == '~')\n\t\t*pp++ = '\\\\';\t    // \"a?\" becomes \"a\\?\", \"a+\" becomes \"a\\+\"\n\t    if (enc_utf8)\n\t\tpp += mb_char2bytes(c, pp);\n\t    else\n\t\t*pp++ = c;\n\t}\n    }\n\n    *pp++ = '\\\\';\n    *pp++ = ')';\n    *pp++ = '$';\n    *pp = NUL;\n\n    if (crp != NULL)\n\t*crp = NUL;\n\n    slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);\n    vim_free(pat);\n    if (slang->sl_compprog == NULL)\n\treturn SP_FORMERROR;\n\n    return 0;\n}\n\n/*\n * Set the SOFOFROM and SOFOTO items in language \"lp\".\n * Returns SP_*ERROR flags when there is something wrong.\n */\n    static int\nset_sofo(slang_T *lp, char_u *from, char_u *to)\n{\n    int\t\ti;\n\n    garray_T\t*gap;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tc;\n    int\t\t*inp;\n\n    if (has_mbyte)\n    {\n\t// Use \"sl_sal\" as an array with 256 pointers to a list of wide\n\t// characters.  The index is the low byte of the character.\n\t// The list contains from-to pairs with a terminating NUL.\n\t// sl_sal_first[] is used for latin1 \"from\" characters.\n\tgap = &lp->sl_sal;\n\tga_init2(gap, sizeof(int *), 1);\n\tif (ga_grow(gap, 256) == FAIL)\n\t    return SP_OTHERERROR;\n\tvim_memset(gap->ga_data, 0, sizeof(int *) * 256);\n\tgap->ga_len = 256;\n\n\t// First count the number of items for each list.  Temporarily use\n\t// sl_sal_first[] for this.\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    MB_CPTR_ADV(s);\n\t    if (c >= 256)\n\t\t++lp->sl_sal_first[c & 0xff];\n\t}\n\tif (*p != NUL || *s != NUL)\t    // lengths differ\n\t    return SP_FORMERROR;\n\n\t// Allocate the lists.\n\tfor (i = 0; i < 256; ++i)\n\t    if (lp->sl_sal_first[i] > 0)\n\t    {\n\t\tp = alloc(sizeof(int) * (lp->sl_sal_first[i] * 2 + 1));\n\t\tif (p == NULL)\n\t\t    return SP_OTHERERROR;\n\t\t((int **)gap->ga_data)[i] = (int *)p;\n\t\t*(int *)p = 0;\n\t    }\n\n\t// Put the characters up to 255 in sl_sal_first[] the rest in a sl_sal\n\t// list.\n\tvim_memset(lp->sl_sal_first, 0, sizeof(salfirst_T) * 256);\n\tfor (p = from, s = to; *p != NUL && *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&p);\n\t    i = mb_cptr2char_adv(&s);\n\t    if (c >= 256)\n\t    {\n\t\t// Append the from-to chars at the end of the list with\n\t\t// the low byte.\n\t\tinp = ((int **)gap->ga_data)[c & 0xff];\n\t\twhile (*inp != 0)\n\t\t    ++inp;\n\t\t*inp++ = c;\t\t// from char\n\t\t*inp++ = i;\t\t// to char\n\t\t*inp++ = NUL;\t\t// NUL at the end\n\t    }\n\t    else\n\t\t// mapping byte to char is done in sl_sal_first[]\n\t\tlp->sl_sal_first[c] = i;\n\t}\n    }\n    else\n    {\n\t// mapping bytes to bytes is done in sl_sal_first[]\n\tif (STRLEN(from) != STRLEN(to))\n\t    return SP_FORMERROR;\n\n\tfor (i = 0; to[i] != NUL; ++i)\n\t    lp->sl_sal_first[from[i]] = to[i];\n\tlp->sl_sal.ga_len = 1;\t\t// indicates we have soundfolding\n    }\n\n    return 0;\n}\n\n/*\n * Fill the first-index table for \"lp\".\n */\n    static void\nset_sal_first(slang_T *lp)\n{\n    salfirst_T\t*sfirst;\n    int\t\ti;\n    salitem_T\t*smp;\n    int\t\tc;\n    garray_T\t*gap = &lp->sl_sal;\n\n    sfirst = lp->sl_sal_first;\n    for (i = 0; i < 256; ++i)\n\tsfirst[i] = -1;\n    smp = (salitem_T *)gap->ga_data;\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tif (has_mbyte)\n\t    // Use the lowest byte of the first character.  For latin1 it's\n\t    // the character, for other encodings it should differ for most\n\t    // characters.\n\t    c = *smp[i].sm_lead_w & 0xff;\n\telse\n\t    c = *smp[i].sm_lead;\n\tif (sfirst[c] == -1)\n\t{\n\t    sfirst[c] = i;\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\tn;\n\n\t\t// Make sure all entries with this byte are following each\n\t\t// other.  Move the ones that are in the wrong position.  Do\n\t\t// keep the same ordering!\n\t\twhile (i + 1 < gap->ga_len\n\t\t\t\t       && (*smp[i + 1].sm_lead_w & 0xff) == c)\n\t\t    // Skip over entry with same index byte.\n\t\t    ++i;\n\n\t\tfor (n = 1; i + n < gap->ga_len; ++n)\n\t\t    if ((*smp[i + n].sm_lead_w & 0xff) == c)\n\t\t    {\n\t\t\tsalitem_T  tsal;\n\n\t\t\t// Move entry with same index byte after the entries\n\t\t\t// we already found.\n\t\t\t++i;\n\t\t\t--n;\n\t\t\ttsal = smp[i + n];\n\t\t\tmch_memmove(smp + i + 1, smp + i,\n\t\t\t\t\t\t       sizeof(salitem_T) * n);\n\t\t\tsmp[i] = tsal;\n\t\t    }\n\t    }\n\t}\n    }\n}\n\n/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */\n    static int *\nmb_str2wide(char_u *s)\n{\n    int\t\t*res;\n    char_u\t*p;\n    int\t\ti = 0;\n\n    res = ALLOC_MULT(int, mb_charlen(s) + 1);\n    if (res != NULL)\n    {\n\tfor (p = s; *p != NUL; )\n\t    res[i++] = mb_ptr2char_adv(&p);\n\tres[i] = NUL;\n    }\n    return res;\n}\n\n/*\n * Read a tree from the .spl or .sug file.\n * Allocates the memory and stores pointers in \"bytsp\" and \"idxsp\".\n * This is skipped when the tree has zero length.\n * Returns zero when OK, SP_ value for an error.\n */\n    static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    long\t*bytsp_len,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t// TRUE for the prefix tree\n    int\t\tprefixcnt)\t// when \"prefixtree\" is TRUE: prefix count\n{\n    long\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    // The tree size was computed when writing the file, so that we can\n    // allocate it as one long block. <nodecount>\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= LONG_MAX / (long)sizeof(int))\n\t// Invalid length, multiply with sizeof(int) would overflow.\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t// Allocate the byte array.\n\tbp = alloc(len);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tif (bytsp_len != NULL)\n\t    *bytsp_len = len;\n\n\t// Allocate the index array.\n\tip = lalloc_clear(len * sizeof(int), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t// Recursively read the tree and store it in the array.\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}\n\n/*\n * Read one row of siblings from the spell file and store it in the byte array\n * \"byts\" and index array \"idxs\".  Recursively read the children.\n *\n * NOTE: The code here must match put_node()!\n *\n * Returns the index (>= 0) following the siblings.\n * Returns SP_TRUNCERROR if the file is shorter than expected.\n * Returns SP_FORMERROR if there is a format error.\n */\n    static idx_T\nread_tree_node(\n    FILE\t*fd,\n    char_u\t*byts,\n    idx_T\t*idxs,\n    int\t\tmaxidx,\t\t    // size of arrays\n    idx_T\tstartidx,\t    // current index in \"byts\" and \"idxs\"\n    int\t\tprefixtree,\t    // TRUE for reading PREFIXTREE\n    int\t\tmaxprefcondnr)\t    // maximum for <prefcondnr>\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tn;\n    idx_T\tidx = startidx;\n    int\t\tc;\n    int\t\tc2;\n#define SHARED_MASK\t0x8000000\n\n    len = getc(fd);\t\t\t\t\t// <siblingcount>\n    if (len <= 0)\n\treturn SP_TRUNCERROR;\n\n    if (startidx + len >= maxidx)\n\treturn SP_FORMERROR;\n    byts[idx++] = len;\n\n    // Read the byte values, flag/region bytes and shared indexes.\n    for (i = 1; i <= len; ++i)\n    {\n\tc = getc(fd);\t\t\t\t\t// <byte>\n\tif (c < 0)\n\t    return SP_TRUNCERROR;\n\tif (c <= BY_SPECIAL)\n\t{\n\t    if (c == BY_NOFLAGS && !prefixtree)\n\t    {\n\t\t// No flags, all regions.\n\t\tidxs[idx] = 0;\n\t\tc = 0;\n\t    }\n\t    else if (c != BY_INDEX)\n\t    {\n\t\tif (prefixtree)\n\t\t{\n\t\t    // Read the optional pflags byte, the prefix ID and the\n\t\t    // condition nr.  In idxs[] store the prefix ID in the low\n\t\t    // byte, the condition index shifted up 8 bits, the flags\n\t\t    // shifted up 24 bits.\n\t\t    if (c == BY_FLAGS)\n\t\t\tc = getc(fd) << 24;\t\t// <pflags>\n\t\t    else\n\t\t\tc = 0;\n\n\t\t    c |= getc(fd);\t\t\t// <affixID>\n\n\t\t    n = get2c(fd);\t\t\t// <prefcondnr>\n\t\t    if (n >= maxprefcondnr)\n\t\t\treturn SP_FORMERROR;\n\t\t    c |= (n << 8);\n\t\t}\n\t\telse // c must be BY_FLAGS or BY_FLAGS2\n\t\t{\n\t\t    // Read flags and optional region and prefix ID.  In\n\t\t    // idxs[] the flags go in the low two bytes, region above\n\t\t    // that and prefix ID above the region.\n\t\t    c2 = c;\n\t\t    c = getc(fd);\t\t\t// <flags>\n\t\t    if (c2 == BY_FLAGS2)\n\t\t\tc = (getc(fd) << 8) + c;\t// <flags2>\n\t\t    if (c & WF_REGION)\n\t\t\tc = (getc(fd) << 16) + c;\t// <region>\n\t\t    if (c & WF_AFX)\n\t\t\tc = (getc(fd) << 24) + c;\t// <affixID>\n\t\t}\n\n\t\tidxs[idx] = c;\n\t\tc = 0;\n\t    }\n\t    else // c == BY_INDEX\n\t    {\n\t\t\t\t\t\t\t// <nodeidx>\n\t\tn = get3c(fd);\n\t\tif (n < 0 || n >= maxidx)\n\t\t    return SP_FORMERROR;\n\t\tidxs[idx] = n + SHARED_MASK;\n\t\tc = getc(fd);\t\t\t\t// <xbyte>\n\t    }\n\t}\n\tbyts[idx++] = c;\n    }\n\n    // Recursively read the children for non-shared siblings.\n    // Skip the end-of-word ones (zero byte value) and the shared ones (and\n    // remove SHARED_MASK)\n    for (i = 1; i <= len; ++i)\n\tif (byts[startidx + i] != 0)\n\t{\n\t    if (idxs[startidx + i] & SHARED_MASK)\n\t\tidxs[startidx + i] &= ~SHARED_MASK;\n\t    else\n\t    {\n\t\tidxs[startidx + i] = idx;\n\t\tidx = read_tree_node(fd, byts, idxs, maxidx, idx,\n\t\t\t\t\t\t     prefixtree, maxprefcondnr);\n\t\tif (idx < 0)\n\t\t    break;\n\t    }\n\t}\n\n    return idx;\n}\n\n/*\n * Reload the spell file \"fname\" if it's loaded.\n */\n    static void\nspell_reload_one(\n    char_u\t*fname,\n    int\t\tadded_word)\t// invoked through \"zg\"\n{\n    slang_T\t*slang;\n    int\t\tdidit = FALSE;\n\n    FOR_ALL_SPELL_LANGS(slang)\n    {\n\tif (fullpathcmp(fname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t{\n\t    slang_clear(slang);\n\t    if (spell_load_file(fname, NULL, slang, FALSE) == NULL)\n\t\t// reloading failed, clear the language\n\t\tslang_clear(slang);\n\t    redraw_all_later(SOME_VALID);\n\t    didit = TRUE;\n\t}\n    }\n\n    // When \"zg\" was used and the file wasn't loaded yet, should redo\n    // 'spelllang' to load it now.\n    if (added_word && !didit)\n\tdid_set_spelllang(curwin);\n}\n\n\n/*\n * Functions for \":mkspell\".\n */\n\n#define MAXLINELEN  500\t\t// Maximum length in bytes of a line in a .aff\n\t\t\t\t// and .dic file.\n/*\n * Main structure to store the contents of a \".aff\" file.\n */\ntypedef struct afffile_S\n{\n    char_u\t*af_enc;\t// \"SET\", normalized, alloc'ed string or NULL\n    int\t\taf_flagtype;\t// AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG\n    unsigned\taf_rare;\t// RARE ID for rare word\n    unsigned\taf_keepcase;\t// KEEPCASE ID for keep-case word\n    unsigned\taf_bad;\t\t// BAD ID for banned word\n    unsigned\taf_needaffix;\t// NEEDAFFIX ID\n    unsigned\taf_circumfix;\t// CIRCUMFIX ID\n    unsigned\taf_needcomp;\t// NEEDCOMPOUND ID\n    unsigned\taf_comproot;\t// COMPOUNDROOT ID\n    unsigned\taf_compforbid;\t// COMPOUNDFORBIDFLAG ID\n    unsigned\taf_comppermit;\t// COMPOUNDPERMITFLAG ID\n    unsigned\taf_nosuggest;\t// NOSUGGEST ID\n    int\t\taf_pfxpostpone;\t// postpone prefixes without chop string and\n\t\t\t\t// without flags\n    int\t\taf_ignoreextra;\t// IGNOREEXTRA present\n    hashtab_T\taf_pref;\t// hashtable for prefixes, affheader_T\n    hashtab_T\taf_suff;\t// hashtable for suffixes, affheader_T\n    hashtab_T\taf_comp;\t// hashtable for compound flags, compitem_T\n} afffile_T;\n\n#define AFT_CHAR\t0\t// flags are one character\n#define AFT_LONG\t1\t// flags are two characters\n#define AFT_CAPLONG\t2\t// flags are one or two characters\n#define AFT_NUM\t\t3\t// flags are numbers, comma separated\n\ntypedef struct affentry_S affentry_T;\n// Affix entry from \".aff\" file.  Used for prefixes and suffixes.\nstruct affentry_S\n{\n    affentry_T\t*ae_next;\t// next affix with same name/number\n    char_u\t*ae_chop;\t// text to chop off basic word (can be NULL)\n    char_u\t*ae_add;\t// text to add to basic word (can be NULL)\n    char_u\t*ae_flags;\t// flags on the affix (can be NULL)\n    char_u\t*ae_cond;\t// condition (NULL for \".\")\n    regprog_T\t*ae_prog;\t// regexp program for ae_cond or NULL\n    char\tae_compforbid;\t// COMPOUNDFORBIDFLAG found\n    char\tae_comppermit;\t// COMPOUNDPERMITFLAG found\n};\n\n#define AH_KEY_LEN 17\t\t// 2 x 8 bytes + NUL\n\n// Affix header from \".aff\" file.  Used for af_pref and af_suff.\ntypedef struct affheader_S\n{\n    char_u\tah_key[AH_KEY_LEN]; // key for hashtab == name of affix\n    unsigned\tah_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tah_newID;\t// prefix ID after renumbering; 0 if not used\n    int\t\tah_combine;\t// suffix may combine with prefix\n    int\t\tah_follows;\t// another affix block should be following\n    affentry_T\t*ah_first;\t// first affix entry\n} affheader_T;\n\n#define HI2AH(hi)   ((affheader_T *)(hi)->hi_key)\n\n// Flag used in compound items.\ntypedef struct compitem_S\n{\n    char_u\tci_key[AH_KEY_LEN]; // key for hashtab == name of compound\n    unsigned\tci_flag;\t// affix name as number, uses \"af_flagtype\"\n    int\t\tci_newID;\t// affix ID after renumbering.\n} compitem_T;\n\n#define HI2CI(hi)   ((compitem_T *)(hi)->hi_key)\n\n/*\n * Structure that is used to store the items in the word tree.  This avoids\n * the need to keep track of each allocated thing, everything is freed all at\n * once after \":mkspell\" is done.\n * Note: \"sb_next\" must be just before \"sb_data\" to make sure the alignment of\n * \"sb_data\" is correct for systems where pointers must be aligned on\n * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).\n */\n#define  SBLOCKSIZE 16000\t// size of sb_data\ntypedef struct sblock_S sblock_T;\nstruct sblock_S\n{\n    int\t\tsb_used;\t// nr of bytes already in use\n    sblock_T\t*sb_next;\t// next block in list\n    char_u\tsb_data[1];\t// data, actually longer\n};\n\n/*\n * A node in the tree.\n */\ntypedef struct wordnode_S wordnode_T;\nstruct wordnode_S\n{\n    union   // shared to save space\n    {\n\tchar_u\thashkey[6];\t// the hash key, only used while compressing\n\tint\tindex;\t\t// index in written nodes (valid after first\n\t\t\t\t// round)\n    } wn_u1;\n    union   // shared to save space\n    {\n\twordnode_T *next;\t// next node with same hash key\n\twordnode_T *wnode;\t// parent node that will write this node\n    } wn_u2;\n    wordnode_T\t*wn_child;\t// child (next byte in word)\n    wordnode_T  *wn_sibling;\t// next sibling (alternate byte in word,\n\t\t\t\t// always sorted)\n    int\t\twn_refs;\t// Nr. of references to this node.  Only\n\t\t\t\t// relevant for first node in a list of\n\t\t\t\t// siblings, in following siblings it is\n\t\t\t\t// always one.\n    char_u\twn_byte;\t// Byte for this node. NUL for word end\n\n    // Info for when \"wn_byte\" is NUL.\n    // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n    // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n    // \"wn_region\" the LSW of the wordnr.\n    char_u\twn_affixID;\t// supported/required prefix ID or 0\n    short_u\twn_flags;\t// WF_ flags\n    short\twn_region;\t// region mask\n\n#ifdef SPELL_PRINTTREE\n    int\t\twn_nr;\t\t// sequence nr for printing\n#endif\n};\n\n#define WN_MASK\t 0xffff\t\t// mask relevant bits of \"wn_flags\"\n\n#define HI2WN(hi)    (wordnode_T *)((hi)->hi_key)\n\n/*\n * Info used while reading the spell files.\n */\ntypedef struct spellinfo_S\n{\n    wordnode_T\t*si_foldroot;\t// tree with case-folded words\n    long\tsi_foldwcount;\t// nr of words in si_foldroot\n\n    wordnode_T\t*si_keeproot;\t// tree with keep-case words\n    long\tsi_keepwcount;\t// nr of words in si_keeproot\n\n    wordnode_T\t*si_prefroot;\t// tree with postponed prefixes\n\n    long\tsi_sugtree;\t// creating the soundfolding trie\n\n    sblock_T\t*si_blocks;\t// memory blocks used\n    long\tsi_blocks_cnt;\t// memory blocks allocated\n    int\t\tsi_did_emsg;\t// TRUE when ran out of memory\n\n    long\tsi_compress_cnt;    // words to add before lowering\n\t\t\t\t    // compression limit\n    wordnode_T\t*si_first_free; // List of nodes that have been freed during\n\t\t\t\t// compression, linked by \"wn_child\" field.\n    long\tsi_free_count;\t// number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n    int\t\tsi_wordnode_nr;\t// sequence nr for nodes\n#endif\n    buf_T\t*si_spellbuf;\t// buffer used to store soundfold word table\n\n    int\t\tsi_ascii;\t// handling only ASCII words\n    int\t\tsi_add;\t\t// addition file\n    int\t\tsi_clear_chartab;   // when TRUE clear char tables\n    int\t\tsi_region;\t// region mask\n    vimconv_T\tsi_conv;\t// for conversion to 'encoding'\n    int\t\tsi_memtot;\t// runtime memory used\n    int\t\tsi_verbose;\t// verbose messages\n    int\t\tsi_msg_count;\t// number of words added since last message\n    char_u\t*si_info;\t// info text chars or NULL\n    int\t\tsi_region_count; // number of regions supported (1 when there\n\t\t\t\t // are no regions)\n    char_u\tsi_region_name[MAXREGIONS * 2 + 1];\n\t\t\t\t// region names; used only if\n\t\t\t\t// si_region_count > 1)\n\n    garray_T\tsi_rep;\t\t// list of fromto_T entries from REP lines\n    garray_T\tsi_repsal;\t// list of fromto_T entries from REPSAL lines\n    garray_T\tsi_sal;\t\t// list of fromto_T entries from SAL lines\n    char_u\t*si_sofofr;\t// SOFOFROM text\n    char_u\t*si_sofoto;\t// SOFOTO text\n    int\t\tsi_nosugfile;\t// NOSUGFILE item found\n    int\t\tsi_nosplitsugs;\t// NOSPLITSUGS item found\n    int\t\tsi_nocompoundsugs; // NOCOMPOUNDSUGS item found\n    int\t\tsi_followup;\t// soundsalike: ?\n    int\t\tsi_collapse;\t// soundsalike: ?\n    hashtab_T\tsi_commonwords;\t// hashtable for common words\n    time_t\tsi_sugtime;\t// timestamp for .sug file\n    int\t\tsi_rem_accents;\t// soundsalike: remove accents\n    garray_T\tsi_map;\t\t// MAP info concatenated\n    char_u\t*si_midword;\t// MIDWORD chars or NULL\n    int\t\tsi_compmax;\t// max nr of words for compounding\n    int\t\tsi_compminlen;\t// minimal length for compounding\n    int\t\tsi_compsylmax;\t// max nr of syllables for compounding\n    int\t\tsi_compoptions;\t// COMP_ flags\n    garray_T\tsi_comppat;\t// CHECKCOMPOUNDPATTERN items, each stored as\n\t\t\t\t// a string\n    char_u\t*si_compflags;\t// flags used for compounding\n    char_u\tsi_nobreak;\t// NOBREAK\n    char_u\t*si_syllable;\t// syllable string\n    garray_T\tsi_prefcond;\t// table with conditions for postponed\n\t\t\t\t// prefixes, each stored as a string\n    int\t\tsi_newprefID;\t// current value for ah_newID\n    int\t\tsi_newcompID;\t// current value for compound ID\n} spellinfo_T;\n\nstatic int is_aff_rule(char_u **items, int itemcnt, char *rulename, int\t mincount);\nstatic void aff_process_flags(afffile_T *affile, affentry_T *entry);\nstatic int spell_info_item(char_u *s);\nstatic unsigned affitem2flag(int flagtype, char_u *item, char_u\t*fname, int lnum);\nstatic unsigned get_affitem(int flagtype, char_u **pp);\nstatic void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags);\nstatic void check_renumber(spellinfo_T *spin);\nstatic void aff_check_number(int spinval, int affval, char *name);\nstatic void aff_check_string(char_u *spinval, char_u *affval, char *name);\nstatic int str_equal(char_u *s1, char_u\t*s2);\nstatic void add_fromto(spellinfo_T *spin, garray_T *gap, char_u\t*from, char_u *to);\nstatic int sal_to_bool(char_u *s);\nstatic int get_affix_flags(afffile_T *affile, char_u *afflist);\nstatic int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist);\nstatic int store_aff_word(spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen);\nstatic void *getroom(spellinfo_T *spin, size_t len, int align);\nstatic char_u *getroom_save(spellinfo_T *spin, char_u *s);\nstatic int store_word(spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix);\nstatic int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID);\nstatic wordnode_T *get_wordnode(spellinfo_T *spin);\nstatic void free_wordnode(spellinfo_T *spin, wordnode_T *n);\nstatic void wordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name);\nstatic long node_compress(spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, long *tot);\nstatic int node_equal(wordnode_T *n1, wordnode_T *n2);\nstatic void clear_node(wordnode_T *node);\nstatic int put_node(FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree);\nstatic int sug_filltree(spellinfo_T *spin, slang_T *slang);\nstatic int sug_maketable(spellinfo_T *spin);\nstatic int sug_filltable(spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap);\nstatic int offset2bytes(int nr, char_u *buf);\nstatic void sug_write(spellinfo_T *spin, char_u *fname);\nstatic void spell_message(spellinfo_T *spin, char_u *str);\nstatic void init_spellfile(void);\n\n// In the postponed prefixes tree wn_flags is used to store the WFP_ flags,\n// but it must be negative to indicate the prefix tree to tree_add_word().\n// Use a negative number with the lower 8 bits zero.\n#define PFX_FLAGS\t(-256)\n\n// flags for \"condit\" argument of store_aff_word()\n#define CONDIT_COMB\t1\t// affix must combine\n#define CONDIT_CFIX\t2\t// affix must have CIRCUMFIX flag\n#define CONDIT_SUF\t4\t// add a suffix for matching flags\n#define CONDIT_AFF\t8\t// word already has an affix\n\n/*\n * Tunable parameters for when the tree is compressed.  Filled from the\n * 'mkspellmem' option.\n */\nstatic long compress_start = 30000;\t// memory / SBLOCKSIZE\nstatic long compress_inc = 100;\t\t// memory / SBLOCKSIZE\nstatic long compress_added = 500000;\t// word count\n\n/*\n * Check the 'mkspellmem' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\".\n */\n    int\nspell_check_msm(void)\n{\n    char_u\t*p = p_msm;\n    long\tstart = 0;\n    long\tincr = 0;\n    long\tadded = 0;\n\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    // block count = (value * 1024) / SBLOCKSIZE (but avoid overflow)\n    start = (getdigits(&p) * 10) / (SBLOCKSIZE / 102);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);\n    if (*p != ',')\n\treturn FAIL;\n    ++p;\n    if (!VIM_ISDIGIT(*p))\n\treturn FAIL;\n    added = getdigits(&p) * 1024;\n    if (*p != NUL)\n\treturn FAIL;\n\n    if (start == 0 || incr == 0 || added == 0 || incr > start)\n\treturn FAIL;\n\n    compress_start = start;\n    compress_inc = incr;\n    compress_added = added;\n    return OK;\n}\n\n#ifdef SPELL_PRINTTREE\n/*\n * For debugging the tree code: print the current tree in a (more or less)\n * readable format, so that we can see what happens when adding a word and/or\n * compressing the tree.\n * Based on code from Olaf Seibert.\n */\n#define PRINTLINESIZE\t1000\n#define PRINTWIDTH\t6\n\n#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\\n\t    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)\n\nstatic char line1[PRINTLINESIZE];\nstatic char line2[PRINTLINESIZE];\nstatic char line3[PRINTLINESIZE];\n\n    static void\nspell_clear_flags(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tnp->wn_u1.index = FALSE;\n\tspell_clear_flags(np->wn_child);\n    }\n}\n\n    static void\nspell_print_node(wordnode_T *node, int depth)\n{\n    if (node->wn_u1.index)\n    {\n\t// Done this node before, print the reference.\n\tPRINTSOME(line1, depth, \"(%d)\", node->wn_nr, 0);\n\tPRINTSOME(line2, depth, \"    \", 0, 0);\n\tPRINTSOME(line3, depth, \"    \", 0, 0);\n\tmsg(line1);\n\tmsg(line2);\n\tmsg(line3);\n    }\n    else\n    {\n\tnode->wn_u1.index = TRUE;\n\n\tif (node->wn_byte != NUL)\n\t{\n\t    if (node->wn_child != NULL)\n\t\tPRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);\n\t    else\n\t\t// Cannot happen?\n\t\tPRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);\n\t}\n\telse\n\t    PRINTSOME(line1, depth, \" $    \", 0, 0);\n\n\tPRINTSOME(line2, depth, \"%d/%d    \", node->wn_nr, node->wn_refs);\n\n\tif (node->wn_sibling != NULL)\n\t    PRINTSOME(line3, depth, \" |    \", 0, 0);\n\telse\n\t    PRINTSOME(line3, depth, \"      \", 0, 0);\n\n\tif (node->wn_byte == NUL)\n\t{\n\t    msg(line1);\n\t    msg(line2);\n\t    msg(line3);\n\t}\n\n\t// do the children\n\tif (node->wn_byte != NUL && node->wn_child != NULL)\n\t    spell_print_node(node->wn_child, depth + 1);\n\n\t// do the siblings\n\tif (node->wn_sibling != NULL)\n\t{\n\t    // get rid of all parent details except |\n\t    STRCPY(line1, line3);\n\t    STRCPY(line2, line3);\n\t    spell_print_node(node->wn_sibling, depth);\n\t}\n    }\n}\n\n    static void\nspell_print_tree(wordnode_T *root)\n{\n    if (root != NULL)\n    {\n\t// Clear the \"wn_u1.index\" fields, used to remember what has been\n\t// done.\n\tspell_clear_flags(root);\n\n\t// Recursively print the tree.\n\tspell_print_node(root, 0);\n    }\n}\n#endif // SPELL_PRINTTREE\n\n/*\n * Read the affix file \"fname\".\n * Returns an afffile_T, NULL for complete failure.\n */\n    static afffile_T *\nspell_read_aff(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    afffile_T\t*aff;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n#define MAXITEMCNT  30\n    char_u\t*(items[MAXITEMCNT]);\n    int\t\titemcnt;\n    char_u\t*p;\n    int\t\tlnum = 0;\n    affheader_T\t*cur_aff = NULL;\n    int\t\tdid_postpone_prefix = FALSE;\n    int\t\taff_todo = 0;\n    hashtab_T\t*tp;\n    char_u\t*low = NULL;\n    char_u\t*fol = NULL;\n    char_u\t*upp = NULL;\n    int\t\tdo_rep;\n    int\t\tdo_repsal;\n    int\t\tdo_sal;\n    int\t\tdo_mapline;\n    int\t\tfound_map = FALSE;\n    hashitem_T\t*hi;\n    int\t\tl;\n    int\t\tcompminlen = 0;\t\t// COMPOUNDMIN value\n    int\t\tcompsylmax = 0;\t\t// COMPOUNDSYLMAX value\n    int\t\tcompoptions = 0;\t// COMP_ flags\n    int\t\tcompmax = 0;\t\t// COMPOUNDWORDMAX value\n    char_u\t*compflags = NULL;\t// COMPOUNDFLAG and COMPOUNDRULE\n\t\t\t\t\t// concatenated\n    char_u\t*midword = NULL;\t// MIDWORD value\n    char_u\t*syllable = NULL;\t// SYLLABLE value\n    char_u\t*sofofrom = NULL;\t// SOFOFROM value\n    char_u\t*sofoto = NULL;\t\t// SOFOTO value\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn NULL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading affix file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // Only do REP lines when not done in another .aff file already.\n    do_rep = spin->si_rep.ga_len == 0;\n\n    // Only do REPSAL lines when not done in another .aff file already.\n    do_repsal = spin->si_repsal.ga_len == 0;\n\n    // Only do SAL lines when not done in another .aff file already.\n    do_sal = spin->si_sal.ga_len == 0;\n\n    // Only do MAP lines when not done in another .aff file already.\n    do_mapline = spin->si_map.ga_len == 0;\n\n    /*\n     * Allocate and init the afffile_T structure.\n     */\n    aff = (afffile_T *)getroom(spin, sizeof(afffile_T), TRUE);\n    if (aff == NULL)\n    {\n\tfclose(fd);\n\treturn NULL;\n    }\n    hash_init(&aff->af_pref);\n    hash_init(&aff->af_suff);\n    hash_init(&aff->af_comp);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\t// Split the line up in white separated items.  Put a NUL after each\n\t// item.\n\titemcnt = 0;\n\tfor (p = line; ; )\n\t{\n\t    while (*p != NUL && *p <= ' ')  // skip white space and CR/NL\n\t\t++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    if (itemcnt == MAXITEMCNT)\t    // too many items\n\t\tbreak;\n\t    items[itemcnt++] = p;\n\t    // A few items have arbitrary text argument, don't split them.\n\t    if (itemcnt == 2 && spell_info_item(items[0]))\n\t\twhile (*p >= ' ' || *p == TAB)    // skip until CR/NL\n\t\t    ++p;\n\t    else\n\t\twhile (*p > ' ')    // skip until white space or CR/NL\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *p++ = NUL;\n\t}\n\n\t// Handle non-empty lines.\n\tif (itemcnt > 0)\n\t{\n\t    if (is_aff_rule(items, itemcnt, \"SET\", 2) && aff->af_enc == NULL)\n\t    {\n\t\t// Setup for conversion from \"ENC\" to 'encoding'.\n\t\taff->af_enc = enc_canonize(items[1]);\n\t\tif (aff->af_enc != NULL && !spin->si_ascii\n\t\t\t&& convert_setup(&spin->si_conv, aff->af_enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t    smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t       fname, aff->af_enc, p_enc);\n\t\tspin->si_conv.vc_fail = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FLAG\", 2)\n\t\t\t\t\t      && aff->af_flagtype == AFT_CHAR)\n\t    {\n\t\tif (STRCMP(items[1], \"long\") == 0)\n\t\t    aff->af_flagtype = AFT_LONG;\n\t\telse if (STRCMP(items[1], \"num\") == 0)\n\t\t    aff->af_flagtype = AFT_NUM;\n\t\telse if (STRCMP(items[1], \"caplong\") == 0)\n\t\t    aff->af_flagtype = AFT_CAPLONG;\n\t\telse\n\t\t    smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t\tif (aff->af_rare != 0\n\t\t\t|| aff->af_keepcase != 0\n\t\t\t|| aff->af_bad != 0\n\t\t\t|| aff->af_needaffix != 0\n\t\t\t|| aff->af_circumfix != 0\n\t\t\t|| aff->af_needcomp != 0\n\t\t\t|| aff->af_comproot != 0\n\t\t\t|| aff->af_nosuggest != 0\n\t\t\t|| compflags != NULL\n\t\t\t|| aff->af_suff.ht_used > 0\n\t\t\t|| aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"FLAG after using flags in %s line %d: %s\"),\n\t\t\t    fname, lnum, items[1]);\n\t    }\n\t    else if (spell_info_item(items[0]))\n\t    {\n\t\t    p = (char_u *)getroom(spin,\n\t\t\t    (spin->si_info == NULL ? 0 : STRLEN(spin->si_info))\n\t\t\t    + STRLEN(items[0])\n\t\t\t    + STRLEN(items[1]) + 3, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (spin->si_info != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, spin->si_info);\n\t\t\t    STRCAT(p, \"\\n\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[0]);\n\t\t\tSTRCAT(p, \" \");\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tspin->si_info = p;\n\t\t    }\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MIDWORD\", 2)\n\t\t\t\t\t\t\t   && midword == NULL)\n\t    {\n\t\tmidword = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"TRY\", 2))\n\t    {\n\t\t// ignored, we look in the tree for what chars may appear\n\t    }\n\t    // TODO: remove \"RAR\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"RARE\", 2))\n\t\t\t\t\t\t\t && aff->af_rare == 0)\n\t    {\n\t\taff->af_rare = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    // TODO: remove \"KEP\" later\n\t    else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))\n\t\t\t\t\t\t     && aff->af_keepcase == 0)\n\t    {\n\t\taff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"FORBIDDENWORD\", 2))\n\t\t\t\t\t\t\t  && aff->af_bad == 0)\n\t    {\n\t\taff->af_bad = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)\n\t\t\t\t\t\t    && aff->af_needaffix == 0)\n\t    {\n\t\taff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)\n\t\t\t\t\t\t    && aff->af_circumfix == 0)\n\t    {\n\t\taff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)\n\t\t\t\t\t\t    && aff->af_nosuggest == 0)\n\t    {\n\t\taff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)\n\t\t\t|| is_aff_rule(items, itemcnt, \"ONLYINCOMPOUND\", 2))\n\t\t\t\t\t\t     && aff->af_needcomp == 0)\n\t    {\n\t\taff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)\n\t\t\t\t\t\t     && aff->af_comproot == 0)\n\t    {\n\t\taff->af_comproot = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_compforbid == 0)\n\t    {\n\t\taff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDPERMITFLAG\", 2)\n\t\t\t\t\t\t   && aff->af_comppermit == 0)\n\t    {\n\t\taff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\tif (aff->af_pref.ht_used > 0)\n\t\t    smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),\n\t\t\t    fname, lnum);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDFLAG\", 2)\n\t\t\t\t\t\t\t && compflags == NULL)\n\t    {\n\t\t// Turn flag \"c\" into COMPOUNDRULE compatible string \"c+\",\n\t\t// \"Na\" into \"Na+\", \"1234\" into \"1234+\".\n\t\tp = getroom(spin, STRLEN(items[1]) + 2, FALSE);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCPY(p, items[1]);\n\t\t    STRCAT(p, \"+\");\n\t\t    compflags = p;\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULES\", 2))\n\t    {\n\t\t// We don't use the count, but do check that it's a number and\n\t\t// not COMPOUNDRULE mistyped.\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULE\", 2))\n\t    {\n\t\t// Don't use the first rule if it is a number.\n\t\tif (compflags != NULL || *skipdigits(items[1]) != NUL)\n\t\t{\n\t\t    // Concatenate this string to previously defined ones,\n\t\t    // using a slash to separate them.\n\t\t    l = (int)STRLEN(items[1]) + 1;\n\t\t    if (compflags != NULL)\n\t\t\tl += (int)STRLEN(compflags) + 1;\n\t\t    p = getroom(spin, l, FALSE);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tif (compflags != NULL)\n\t\t\t{\n\t\t\t    STRCPY(p, compflags);\n\t\t\t    STRCAT(p, \"/\");\n\t\t\t}\n\t\t\tSTRCAT(p, items[1]);\n\t\t\tcompflags = p;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDWORDMAX\", 2)\n\t\t\t\t\t\t\t      && compmax == 0)\n\t    {\n\t\tcompmax = atoi((char *)items[1]);\n\t\tif (compmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDMIN\", 2)\n\t\t\t\t\t\t\t   && compminlen == 0)\n\t    {\n\t\tcompminlen = atoi((char *)items[1]);\n\t\tif (compminlen == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"COMPOUNDSYLMAX\", 2)\n\t\t\t\t\t\t\t   && compsylmax == 0)\n\t    {\n\t\tcompsylmax = atoi((char *)items[1]);\n\t\tif (compsylmax == 0)\n\t\t    smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDDUP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKDUP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDREP\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKREP;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDCASE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKCASE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDTRIPLE\", 1))\n\t    {\n\t\tcompoptions |= COMP_CHECKTRIPLE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))\n\t    {\n\t\tif (atoi((char *)items[1]) == 0)\n\t\t    smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 3))\n\t    {\n\t\tgarray_T    *gap = &spin->si_comppat;\n\t\tint\t    i;\n\n\t\t// Only add the couple if it isn't already there.\n\t\tfor (i = 0; i < gap->ga_len - 1; i += 2)\n\t\t    if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0\n\t\t\t    && STRCMP(((char_u **)(gap->ga_data))[i + 1],\n\t\t\t\t\t\t\t       items[2]) == 0)\n\t\t\tbreak;\n\t\tif (i >= gap->ga_len && ga_grow(gap, 2) == OK)\n\t\t{\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[1]);\n\t\t    ((char_u **)(gap->ga_data))[gap->ga_len++]\n\t\t\t\t\t       = getroom_save(spin, items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SYLLABLE\", 2)\n\t\t\t\t\t\t\t  && syllable == NULL)\n\t    {\n\t\tsyllable = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOBREAK\", 1))\n\t    {\n\t\tspin->si_nobreak = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSPLITSUGS\", 1))\n\t    {\n\t\tspin->si_nosplitsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOCOMPOUNDSUGS\", 1))\n\t    {\n\t\tspin->si_nocompoundsugs = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"NOSUGFILE\", 1))\n\t    {\n\t\tspin->si_nosugfile = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"PFXPOSTPONE\", 1))\n\t    {\n\t\taff->af_pfxpostpone = TRUE;\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"IGNOREEXTRA\", 1))\n\t    {\n\t\taff->af_ignoreextra = TRUE;\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo == 0\n\t\t    && itemcnt >= 4)\n\t    {\n\t\tint\tlasti = 4;\n\t\tchar_u\tkey[AH_KEY_LEN];\n\n\t\tif (*items[0] == 'P')\n\t\t    tp = &aff->af_pref;\n\t\telse\n\t\t    tp = &aff->af_suff;\n\n\t\t// Myspell allows the same affix name to be used multiple\n\t\t// times.  The affix files that do this have an undocumented\n\t\t// \"S\" flag on all but the last block, thus we check for that\n\t\t// and store it in ah_follows.\n\t\tvim_strncpy(key, items[1], AH_KEY_LEN - 1);\n\t\thi = hash_find(tp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    cur_aff = HI2AH(hi);\n\t\t    if (cur_aff->ah_combine != (*items[2] == 'Y'))\n\t\t\tsmsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),\n\t\t\t\t\t\t   fname, lnum, items[1]);\n\t\t    if (!cur_aff->ah_follows)\n\t\t\tsmsg(_(\"Duplicate affix in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // New affix letter.\n\t\t    cur_aff = (affheader_T *)getroom(spin,\n\t\t\t\t\t\t   sizeof(affheader_T), TRUE);\n\t\t    if (cur_aff == NULL)\n\t\t\tbreak;\n\t\t    cur_aff->ah_flag = affitem2flag(aff->af_flagtype, items[1],\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    if (cur_aff->ah_flag == 0 || STRLEN(items[1]) >= AH_KEY_LEN)\n\t\t\tbreak;\n\t\t    if (cur_aff->ah_flag == aff->af_bad\n\t\t\t    || cur_aff->ah_flag == aff->af_rare\n\t\t\t    || cur_aff->ah_flag == aff->af_keepcase\n\t\t\t    || cur_aff->ah_flag == aff->af_needaffix\n\t\t\t    || cur_aff->ah_flag == aff->af_circumfix\n\t\t\t    || cur_aff->ah_flag == aff->af_nosuggest\n\t\t\t    || cur_aff->ah_flag == aff->af_needcomp\n\t\t\t    || cur_aff->ah_flag == aff->af_comproot)\n\t\t\tsmsg(_(\"Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[1]);\n\t\t    STRCPY(cur_aff->ah_key, items[1]);\n\t\t    hash_add(tp, cur_aff->ah_key);\n\n\t\t    cur_aff->ah_combine = (*items[2] == 'Y');\n\t\t}\n\n\t\t// Check for the \"S\" flag, which apparently means that another\n\t\t// block with the same affix name is following.\n\t\tif (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0)\n\t\t{\n\t\t    ++lasti;\n\t\t    cur_aff->ah_follows = TRUE;\n\t\t}\n\t\telse\n\t\t    cur_aff->ah_follows = FALSE;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter.\n\t\tif (itemcnt > lasti && *items[lasti] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\tif (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)\n\t\t    smsg(_(\"Expected Y or N in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[2]);\n\n\t\tif (*items[0] == 'P' && aff->af_pfxpostpone)\n\t\t{\n\t\t    if (cur_aff->ah_newID == 0)\n\t\t    {\n\t\t\t// Use a new number in the .spl file later, to be able\n\t\t\t// to handle multiple .aff files.\n\t\t\tcheck_renumber(spin);\n\t\t\tcur_aff->ah_newID = ++spin->si_newprefID;\n\n\t\t\t// We only really use ah_newID if the prefix is\n\t\t\t// postponed.  We know that only after handling all\n\t\t\t// the items.\n\t\t\tdid_postpone_prefix = FALSE;\n\t\t    }\n\t\t    else\n\t\t\t// Did use the ID in a previous block.\n\t\t\tdid_postpone_prefix = TRUE;\n\t\t}\n\n\t\taff_todo = atoi((char *)items[3]);\n\t    }\n\t    else if ((STRCMP(items[0], \"PFX\") == 0\n\t\t\t\t\t      || STRCMP(items[0], \"SFX\") == 0)\n\t\t    && aff_todo > 0\n\t\t    && STRCMP(cur_aff->ah_key, items[1]) == 0\n\t\t    && itemcnt >= 5)\n\t    {\n\t\taffentry_T\t*aff_entry;\n\t\tint\t\tupper = FALSE;\n\t\tint\t\tlasti = 5;\n\n\t\t// Myspell allows extra text after the item, but that might\n\t\t// mean mistakes go unnoticed.  Require a comment-starter,\n\t\t// unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.\n\t\tif (itemcnt > lasti\n\t\t\t&& !aff->af_ignoreextra\n\t\t\t&& *items[lasti] != '#'\n\t\t\t&& (STRCMP(items[lasti], \"-\") != 0\n\t\t\t\t\t\t     || itemcnt != lasti + 1))\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n\t\t// New item for an affix letter.\n\t\t--aff_todo;\n\t\taff_entry = (affentry_T *)getroom(spin,\n\t\t\t\t\t\t    sizeof(affentry_T), TRUE);\n\t\tif (aff_entry == NULL)\n\t\t    break;\n\n\t\tif (STRCMP(items[2], \"0\") != 0)\n\t\t    aff_entry->ae_chop = getroom_save(spin, items[2]);\n\t\tif (STRCMP(items[3], \"0\") != 0)\n\t\t{\n\t\t    aff_entry->ae_add = getroom_save(spin, items[3]);\n\n\t\t    // Recognize flags on the affix: abcd/XYZ\n\t\t    aff_entry->ae_flags = vim_strchr(aff_entry->ae_add, '/');\n\t\t    if (aff_entry->ae_flags != NULL)\n\t\t    {\n\t\t\t*aff_entry->ae_flags++ = NUL;\n\t\t\taff_process_flags(aff, aff_entry);\n\t\t    }\n\t\t}\n\n\t\t// Don't use an affix entry with non-ASCII characters when\n\t\t// \"spin->si_ascii\" is TRUE.\n\t\tif (!spin->si_ascii || !(has_non_ascii(aff_entry->ae_chop)\n\t\t\t\t\t  || has_non_ascii(aff_entry->ae_add)))\n\t\t{\n\t\t    aff_entry->ae_next = cur_aff->ah_first;\n\t\t    cur_aff->ah_first = aff_entry;\n\n\t\t    if (STRCMP(items[4], \".\") != 0)\n\t\t    {\n\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\taff_entry->ae_cond = getroom_save(spin, items[4]);\n\t\t\tif (*items[0] == 'P')\n\t\t\t    sprintf((char *)buf, \"^%s\", items[4]);\n\t\t\telse\n\t\t\t    sprintf((char *)buf, \"%s$\", items[4]);\n\t\t\taff_entry->ae_prog = vim_regcomp(buf,\n\t\t\t\t\t    RE_MAGIC + RE_STRING + RE_STRICT);\n\t\t\tif (aff_entry->ae_prog == NULL)\n\t\t\t    smsg(_(\"Broken condition in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[4]);\n\t\t    }\n\n\t\t    // For postponed prefixes we need an entry in si_prefcond\n\t\t    // for the condition.  Use an existing one if possible.\n\t\t    // Can't be done for an affix with flags, ignoring\n\t\t    // COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG.\n\t\t    if (*items[0] == 'P' && aff->af_pfxpostpone\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t    {\n\t\t\t// When the chop string is one lower-case letter and\n\t\t\t// the add string ends in the upper-case letter we set\n\t\t\t// the \"upper\" flag, clear \"ae_chop\" and remove the\n\t\t\t// letters from \"ae_add\".  The condition must either\n\t\t\t// be empty or start with the same letter.\n\t\t\tif (aff_entry->ae_chop != NULL\n\t\t\t\t&& aff_entry->ae_add != NULL\n\t\t\t\t&& aff_entry->ae_chop[(*mb_ptr2len)(\n\t\t\t\t\t\t   aff_entry->ae_chop)] == NUL)\n\t\t\t{\n\t\t\t    int\t\tc, c_up;\n\n\t\t\t    c = PTR2CHAR(aff_entry->ae_chop);\n\t\t\t    c_up = SPELL_TOUPPER(c);\n\t\t\t    if (c_up != c\n\t\t\t\t    && (aff_entry->ae_cond == NULL\n\t\t\t\t\t|| PTR2CHAR(aff_entry->ae_cond) == c))\n\t\t\t    {\n\t\t\t\tp = aff_entry->ae_add\n\t\t\t\t\t\t  + STRLEN(aff_entry->ae_add);\n\t\t\t\tMB_PTR_BACK(aff_entry->ae_add, p);\n\t\t\t\tif (PTR2CHAR(p) == c_up)\n\t\t\t\t{\n\t\t\t\t    upper = TRUE;\n\t\t\t\t    aff_entry->ae_chop = NULL;\n\t\t\t\t    *p = NUL;\n\n\t\t\t\t    // The condition is matched with the\n\t\t\t\t    // actual word, thus must check for the\n\t\t\t\t    // upper-case letter.\n\t\t\t\t    if (aff_entry->ae_cond != NULL)\n\t\t\t\t    {\n\t\t\t\t\tchar_u\tbuf[MAXLINELEN];\n\n\t\t\t\t\tif (has_mbyte)\n\t\t\t\t\t{\n\t\t\t\t\t    onecap_copy(items[4], buf, TRUE);\n\t\t\t\t\t    aff_entry->ae_cond = getroom_save(\n\t\t\t\t\t\t\t\t   spin, buf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t    *aff_entry->ae_cond = c_up;\n\t\t\t\t\tif (aff_entry->ae_cond != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    sprintf((char *)buf, \"^%s\",\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t\t\t    vim_regfree(aff_entry->ae_prog);\n\t\t\t\t\t    aff_entry->ae_prog = vim_regcomp(\n\t\t\t\t\t\t    buf, RE_MAGIC + RE_STRING);\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (aff_entry->ae_chop == NULL\n\t\t\t\t\t       && aff_entry->ae_flags == NULL)\n\t\t\t{\n\t\t\t    int\t\tidx;\n\t\t\t    char_u\t**pp;\n\t\t\t    int\t\tn;\n\n\t\t\t    // Find a previously used condition.\n\t\t\t    for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;\n\t\t\t\t\t\t\t\t\t--idx)\n\t\t\t    {\n\t\t\t\tp = ((char_u **)spin->si_prefcond.ga_data)[idx];\n\t\t\t\tif (str_equal(p, aff_entry->ae_cond))\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (idx < 0 && ga_grow(&spin->si_prefcond, 1) == OK)\n\t\t\t    {\n\t\t\t\t// Not found, add a new condition.\n\t\t\t\tidx = spin->si_prefcond.ga_len++;\n\t\t\t\tpp = ((char_u **)spin->si_prefcond.ga_data)\n\t\t\t\t\t\t\t\t\t+ idx;\n\t\t\t\tif (aff_entry->ae_cond == NULL)\n\t\t\t\t    *pp = NULL;\n\t\t\t\telse\n\t\t\t\t    *pp = getroom_save(spin,\n\t\t\t\t\t\t\t  aff_entry->ae_cond);\n\t\t\t    }\n\n\t\t\t    // Add the prefix to the prefix tree.\n\t\t\t    if (aff_entry->ae_add == NULL)\n\t\t\t\tp = (char_u *)\"\";\n\t\t\t    else\n\t\t\t\tp = aff_entry->ae_add;\n\n\t\t\t    // PFX_FLAGS is a negative number, so that\n\t\t\t    // tree_add_word() knows this is the prefix tree.\n\t\t\t    n = PFX_FLAGS;\n\t\t\t    if (!cur_aff->ah_combine)\n\t\t\t\tn |= WFP_NC;\n\t\t\t    if (upper)\n\t\t\t\tn |= WFP_UP;\n\t\t\t    if (aff_entry->ae_comppermit)\n\t\t\t\tn |= WFP_COMPPERMIT;\n\t\t\t    if (aff_entry->ae_compforbid)\n\t\t\t\tn |= WFP_COMPFORBID;\n\t\t\t    tree_add_word(spin, p, spin->si_prefroot, n,\n\t\t\t\t\t\t      idx, cur_aff->ah_newID);\n\t\t\t    did_postpone_prefix = TRUE;\n\t\t\t}\n\n\t\t\t// Didn't actually use ah_newID, backup si_newprefID.\n\t\t\tif (aff_todo == 0 && !did_postpone_prefix)\n\t\t\t{\n\t\t\t    --spin->si_newprefID;\n\t\t\t    cur_aff->ah_newID = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"FOL\", 2) && fol == NULL)\n\t    {\n\t\tfol = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"LOW\", 2) && low == NULL)\n\t    {\n\t\tlow = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"UPP\", 2) && upp == NULL)\n\t    {\n\t\tupp = vim_strsave(items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"REP\", 2)\n\t\t     || is_aff_rule(items, itemcnt, \"REPSAL\", 2))\n\t    {\n\t\t// Ignore REP/REPSAL count\n\t\tif (!isdigit(*items[1]))\n\t\t    smsg(_(\"Expected REP(SAL) count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t    }\n\t    else if ((STRCMP(items[0], \"REP\") == 0\n\t\t\t|| STRCMP(items[0], \"REPSAL\") == 0)\n\t\t    && itemcnt >= 3)\n\t    {\n\t\t// REP/REPSAL item\n\t\t// Myspell ignores extra arguments, we require it starts with\n\t\t// # to detect mistakes.\n\t\tif (itemcnt > 3 && items[3][0] != '#')\n\t\t    smsg(_(e_afftrailing), fname, lnum, items[3]);\n\t\tif (items[0][3] == 'S' ? do_repsal : do_rep)\n\t\t{\n\t\t    // Replace underscore with space (can't include a space\n\t\t    // directly).\n\t\t    for (p = items[1]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    for (p = items[2]; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (*p == '_')\n\t\t\t    *p = ' ';\n\t\t    add_fromto(spin, items[0][3] == 'S'\n\t\t\t\t\t ? &spin->si_repsal\n\t\t\t\t\t : &spin->si_rep, items[1], items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"MAP\", 2))\n\t    {\n\t\t// MAP item or count\n\t\tif (!found_map)\n\t\t{\n\t\t    // First line contains the count.\n\t\t    found_map = TRUE;\n\t\t    if (!isdigit(*items[1]))\n\t\t\tsmsg(_(\"Expected MAP count in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t}\n\t\telse if (do_mapline)\n\t\t{\n\t\t    int\t\tc;\n\n\t\t    // Check that every character appears only once.\n\t\t    for (p = items[1]; *p != NUL; )\n\t\t    {\n\t\t\tc = mb_ptr2char_adv(&p);\n\t\t\tif ((spin->si_map.ga_len > 0\n\t\t\t\t    && vim_strchr(spin->si_map.ga_data, c)\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t\t|| vim_strchr(p, c) != NULL)\n\t\t\t    smsg(_(\"Duplicate character in MAP in %s line %d\"),\n\t\t\t\t\t\t\t\t fname, lnum);\n\t\t    }\n\n\t\t    // We simply concatenate all the MAP strings, separated by\n\t\t    // slashes.\n\t\t    ga_concat(&spin->si_map, items[1]);\n\t\t    ga_append(&spin->si_map, '/');\n\t\t}\n\t    }\n\t    // Accept \"SAL from to\" and \"SAL from to  #comment\".\n\t    else if (is_aff_rule(items, itemcnt, \"SAL\", 3))\n\t    {\n\t\tif (do_sal)\n\t\t{\n\t\t    // SAL item (sounds-a-like)\n\t\t    // Either one of the known keys or a from-to pair.\n\t\t    if (STRCMP(items[1], \"followup\") == 0)\n\t\t\tspin->si_followup = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"collapse_result\") == 0)\n\t\t\tspin->si_collapse = sal_to_bool(items[2]);\n\t\t    else if (STRCMP(items[1], \"remove_accents\") == 0)\n\t\t\tspin->si_rem_accents = sal_to_bool(items[2]);\n\t\t    else\n\t\t\t// when \"to\" is \"_\" it means empty\n\t\t\tadd_fromto(spin, &spin->si_sal, items[1],\n\t\t\t\t     STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"\n\t\t\t\t\t\t\t\t: items[2]);\n\t\t}\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOFROM\", 2)\n\t\t\t\t\t\t\t  && sofofrom == NULL)\n\t    {\n\t\tsofofrom = getroom_save(spin, items[1]);\n\t    }\n\t    else if (is_aff_rule(items, itemcnt, \"SOFOTO\", 2)\n\t\t\t\t\t\t\t    && sofoto == NULL)\n\t    {\n\t\tsofoto = getroom_save(spin, items[1]);\n\t    }\n\t    else if (STRCMP(items[0], \"COMMON\") == 0)\n\t    {\n\t\tint\ti;\n\n\t\tfor (i = 1; i < itemcnt; ++i)\n\t\t{\n\t\t    if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,\n\t\t\t\t\t\t\t\t   items[i])))\n\t\t    {\n\t\t\tp = vim_strsave(items[i]);\n\t\t\tif (p == NULL)\n\t\t\t    break;\n\t\t\thash_add(&spin->si_commonwords, p);\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tsmsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, items[0]);\n\t}\n    }\n\n    if (fol != NULL || low != NULL || upp != NULL)\n    {\n\tif (spin->si_clear_chartab)\n\t{\n\t    // Clear the char type tables, don't want to use any of the\n\t    // currently used spell properties.\n\t    init_spell_chartab();\n\t    spin->si_clear_chartab = FALSE;\n\t}\n\n\t/*\n\t * Don't write a word table for an ASCII file, so that we don't check\n\t * for conflicts with a word table that matches 'encoding'.\n\t * Don't write one for utf-8 either, we use utf_*() and\n\t * mb_get_class(), the list of chars in the file will be incomplete.\n\t */\n\tif (!spin->si_ascii && !enc_utf8)\n\t{\n\t    if (fol == NULL || low == NULL || upp == NULL)\n\t\tsmsg(_(\"Missing FOL/LOW/UPP line in %s\"), fname);\n\t    else\n\t\t(void)set_spell_chartab(fol, low, upp);\n\t}\n\n\tvim_free(fol);\n\tvim_free(low);\n\tvim_free(upp);\n    }\n\n    // Use compound specifications of the .aff file for the spell info.\n    if (compmax != 0)\n    {\n\taff_check_number(spin->si_compmax, compmax, \"COMPOUNDWORDMAX\");\n\tspin->si_compmax = compmax;\n    }\n\n    if (compminlen != 0)\n    {\n\taff_check_number(spin->si_compminlen, compminlen, \"COMPOUNDMIN\");\n\tspin->si_compminlen = compminlen;\n    }\n\n    if (compsylmax != 0)\n    {\n\tif (syllable == NULL)\n\t    smsg(_(\"COMPOUNDSYLMAX used without SYLLABLE\"));\n\taff_check_number(spin->si_compsylmax, compsylmax, \"COMPOUNDSYLMAX\");\n\tspin->si_compsylmax = compsylmax;\n    }\n\n    if (compoptions != 0)\n    {\n\taff_check_number(spin->si_compoptions, compoptions, \"COMPOUND options\");\n\tspin->si_compoptions |= compoptions;\n    }\n\n    if (compflags != NULL)\n\tprocess_compflags(spin, aff, compflags);\n\n    // Check that we didn't use too many renumbered flags.\n    if (spin->si_newcompID < spin->si_newprefID)\n    {\n\tif (spin->si_newcompID == 127 || spin->si_newcompID == 255)\n\t    msg(_(\"Too many postponed prefixes\"));\n\telse if (spin->si_newprefID == 0 || spin->si_newprefID == 127)\n\t    msg(_(\"Too many compound flags\"));\n\telse\n\t    msg(_(\"Too many postponed prefixes and/or compound flags\"));\n    }\n\n    if (syllable != NULL)\n    {\n\taff_check_string(spin->si_syllable, syllable, \"SYLLABLE\");\n\tspin->si_syllable = syllable;\n    }\n\n    if (sofofrom != NULL || sofoto != NULL)\n    {\n\tif (sofofrom == NULL || sofoto == NULL)\n\t    smsg(_(\"Missing SOFO%s line in %s\"),\n\t\t\t\t     sofofrom == NULL ? \"FROM\" : \"TO\", fname);\n\telse if (spin->si_sal.ga_len > 0)\n\t    smsg(_(\"Both SAL and SOFO lines in %s\"), fname);\n\telse\n\t{\n\t    aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");\n\t    aff_check_string(spin->si_sofoto, sofoto, \"SOFOTO\");\n\t    spin->si_sofofr = sofofrom;\n\t    spin->si_sofoto = sofoto;\n\t}\n    }\n\n    if (midword != NULL)\n    {\n\taff_check_string(spin->si_midword, midword, \"MIDWORD\");\n\tspin->si_midword = midword;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n    return aff;\n}\n\n/*\n * Return TRUE when items[0] equals \"rulename\", there are \"mincount\" items or\n * a comment is following after item \"mincount\".\n */\n    static int\nis_aff_rule(\n    char_u\t**items,\n    int\t\titemcnt,\n    char\t*rulename,\n    int\t\tmincount)\n{\n    return (STRCMP(items[0], rulename) == 0\n\t    && (itemcnt == mincount\n\t\t|| (itemcnt > mincount && items[mincount][0] == '#')));\n}\n\n/*\n * For affix \"entry\" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from\n * ae_flags to ae_comppermit and ae_compforbid.\n */\n    static void\naff_process_flags(afffile_T *affile, affentry_T *entry)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n\n    if (entry->ae_flags != NULL\n\t\t&& (affile->af_compforbid != 0 || affile->af_comppermit != 0))\n    {\n\tfor (p = entry->ae_flags; *p != NUL; )\n\t{\n\t    prevp = p;\n\t    flag = get_affitem(affile->af_flagtype, &p);\n\t    if (flag == affile->af_comppermit || flag == affile->af_compforbid)\n\t    {\n\t\tSTRMOVE(prevp, p);\n\t\tp = prevp;\n\t\tif (flag == affile->af_comppermit)\n\t\t    entry->ae_comppermit = TRUE;\n\t\telse\n\t\t    entry->ae_compforbid = TRUE;\n\t    }\n\t    if (affile->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n\tif (*entry->ae_flags == NUL)\n\t    entry->ae_flags = NULL;\t// nothing left\n    }\n}\n\n/*\n * Return TRUE if \"s\" is the name of an info item in the affix file.\n */\n    static int\nspell_info_item(char_u *s)\n{\n    return STRCMP(s, \"NAME\") == 0\n\t|| STRCMP(s, \"HOME\") == 0\n\t|| STRCMP(s, \"VERSION\") == 0\n\t|| STRCMP(s, \"AUTHOR\") == 0\n\t|| STRCMP(s, \"EMAIL\") == 0\n\t|| STRCMP(s, \"COPYRIGHT\") == 0;\n}\n\n/*\n * Turn an affix flag name into a number, according to the FLAG type.\n * returns zero for failure.\n */\n    static unsigned\naffitem2flag(\n    int\t\tflagtype,\n    char_u\t*item,\n    char_u\t*fname,\n    int\t\tlnum)\n{\n    unsigned\tres;\n    char_u\t*p = item;\n\n    res = get_affitem(flagtype, &p);\n    if (res == 0)\n    {\n\tif (flagtype == AFT_NUM)\n\t    smsg(_(\"Flag is not a number in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n\telse\n\t    smsg(_(\"Illegal flag in %s line %d: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, item);\n    }\n    if (*p != NUL)\n    {\n\tsmsg(_(e_affname), fname, lnum, item);\n\treturn 0;\n    }\n\n    return res;\n}\n\n/*\n * Get one affix name from \"*pp\" and advance the pointer.\n * Returns ZERO_FLAG for \"0\".\n * Returns zero for an error, still advances the pointer then.\n */\n    static unsigned\nget_affitem(int flagtype, char_u **pp)\n{\n    int\t\tres;\n\n    if (flagtype == AFT_NUM)\n    {\n\tif (!VIM_ISDIGIT(**pp))\n\t{\n\t    ++*pp;\t// always advance, avoid getting stuck\n\t    return 0;\n\t}\n\tres = getdigits(pp);\n\tif (res == 0)\n\t    res = ZERO_FLAG;\n    }\n    else\n    {\n\tres = mb_ptr2char_adv(pp);\n\tif (flagtype == AFT_LONG || (flagtype == AFT_CAPLONG\n\t\t\t\t\t\t && res >= 'A' && res <= 'Z'))\n\t{\n\t    if (**pp == NUL)\n\t\treturn 0;\n\t    res = mb_ptr2char_adv(pp) + (res << 16);\n\t}\n    }\n    return res;\n}\n\n/*\n * Process the \"compflags\" string used in an affix file and append it to\n * spin->si_compflags.\n * The processing involves changing the affix names to ID numbers, so that\n * they fit in one byte.\n */\n    static void\nprocess_compflags(\n    spellinfo_T\t*spin,\n    afffile_T\t*aff,\n    char_u\t*compflags)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    unsigned\tflag;\n    compitem_T\t*ci;\n    int\t\tid;\n    int\t\tlen;\n    char_u\t*tp;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    // Make room for the old and the new compflags, concatenated with a / in\n    // between.  Processing it makes it shorter, but we don't know by how\n    // much, thus allocate the maximum.\n    len = (int)STRLEN(compflags) + 1;\n    if (spin->si_compflags != NULL)\n\tlen += (int)STRLEN(spin->si_compflags) + 1;\n    p = getroom(spin, len, FALSE);\n    if (p == NULL)\n\treturn;\n    if (spin->si_compflags != NULL)\n    {\n\tSTRCPY(p, spin->si_compflags);\n\tSTRCAT(p, \"/\");\n    }\n    spin->si_compflags = p;\n    tp = p + STRLEN(p);\n\n    for (p = compflags; *p != NUL; )\n    {\n\tif (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)\n\t    // Copy non-flag characters directly.\n\t    *tp++ = *p++;\n\telse\n\t{\n\t    // First get the flag number, also checks validity.\n\t    prevp = p;\n\t    flag = get_affitem(aff->af_flagtype, &p);\n\t    if (flag != 0)\n\t    {\n\t\t// Find the flag in the hashtable.  If it was used before, use\n\t\t// the existing ID.  Otherwise add a new entry.\n\t\tvim_strncpy(key, prevp, p - prevp);\n\t\thi = hash_find(&aff->af_comp, key);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    id = HI2CI(hi)->ci_newID;\n\t\telse\n\t\t{\n\t\t    ci = (compitem_T *)getroom(spin, sizeof(compitem_T), TRUE);\n\t\t    if (ci == NULL)\n\t\t\tbreak;\n\t\t    STRCPY(ci->ci_key, key);\n\t\t    ci->ci_flag = flag;\n\t\t    // Avoid using a flag ID that has a special meaning in a\n\t\t    // regexp (also inside []).\n\t\t    do\n\t\t    {\n\t\t\tcheck_renumber(spin);\n\t\t\tid = spin->si_newcompID--;\n\t\t    } while (vim_strchr((char_u *)\"/?*+[]\\\\-^\", id) != NULL);\n\t\t    ci->ci_newID = id;\n\t\t    hash_add(&aff->af_comp, ci->ci_key);\n\t\t}\n\t\t*tp++ = id;\n\t    }\n\t    if (aff->af_flagtype == AFT_NUM && *p == ',')\n\t\t++p;\n\t}\n    }\n\n    *tp = NUL;\n}\n\n/*\n * Check that the new IDs for postponed affixes and compounding don't overrun\n * each other.  We have almost 255 available, but start at 0-127 to avoid\n * using two bytes for utf-8.  When the 0-127 range is used up go to 128-255.\n * When that is used up an error message is given.\n */\n    static void\ncheck_renumber(spellinfo_T *spin)\n{\n    if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)\n    {\n\tspin->si_newprefID = 127;\n\tspin->si_newcompID = 255;\n    }\n}\n\n/*\n * Return TRUE if flag \"flag\" appears in affix list \"afflist\".\n */\n    static int\nflag_in_afflist(int flagtype, char_u *afflist, unsigned flag)\n{\n    char_u\t*p;\n    unsigned\tn;\n\n    switch (flagtype)\n    {\n\tcase AFT_CHAR:\n\t    return vim_strchr(afflist, flag) != NULL;\n\n\tcase AFT_CAPLONG:\n\tcase AFT_LONG:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = mb_ptr2char_adv(&p);\n\t\tif ((flagtype == AFT_LONG || (n >= 'A' && n <= 'Z'))\n\t\t\t\t\t\t\t\t && *p != NUL)\n\t\t    n = mb_ptr2char_adv(&p) + (n << 16);\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t    }\n\t    break;\n\n\tcase AFT_NUM:\n\t    for (p = afflist; *p != NUL; )\n\t    {\n\t\tn = getdigits(&p);\n\t\tif (n == 0)\n\t\t    n = ZERO_FLAG;\n\t\tif (n == flag)\n\t\t    return TRUE;\n\t\tif (*p != NUL)\t// skip over comma\n\t\t    ++p;\n\t    }\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" numbers are set and not the same.\n */\n    static void\naff_check_number(int spinval, int affval, char *name)\n{\n    if (spinval != 0 && spinval != affval)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Give a warning when \"spinval\" and \"affval\" strings are set and not the same.\n */\n    static void\naff_check_string(char_u *spinval, char_u *affval, char *name)\n{\n    if (spinval != NULL && STRCMP(spinval, affval) != 0)\n\tsmsg(_(\"%s value differs from what is used in another .aff file\"), name);\n}\n\n/*\n * Return TRUE if strings \"s1\" and \"s2\" are equal.  Also consider both being\n * NULL as equal.\n */\n    static int\nstr_equal(char_u *s1, char_u *s2)\n{\n    if (s1 == NULL || s2 == NULL)\n\treturn s1 == s2;\n    return STRCMP(s1, s2) == 0;\n}\n\n/*\n * Add a from-to item to \"gap\".  Used for REP and SAL items.\n * They are stored case-folded.\n */\n    static void\nadd_fromto(\n    spellinfo_T\t*spin,\n    garray_T\t*gap,\n    char_u\t*from,\n    char_u\t*to)\n{\n    fromto_T\t*ftp;\n    char_u\tword[MAXWLEN];\n\n    if (ga_grow(gap, 1) == OK)\n    {\n\tftp = ((fromto_T *)gap->ga_data) + gap->ga_len;\n\t(void)spell_casefold(curwin, from, (int)STRLEN(from), word, MAXWLEN);\n\tftp->ft_from = getroom_save(spin, word);\n\t(void)spell_casefold(curwin, to, (int)STRLEN(to), word, MAXWLEN);\n\tftp->ft_to = getroom_save(spin, word);\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Convert a boolean argument in a SAL line to TRUE or FALSE;\n */\n    static int\nsal_to_bool(char_u *s)\n{\n    return STRCMP(s, \"1\") == 0 || STRCMP(s, \"true\") == 0;\n}\n\n/*\n * Free the structure filled by spell_read_aff().\n */\n    static void\nspell_free_aff(afffile_T *aff)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n\n    vim_free(aff->af_enc);\n\n    // All this trouble to free the \"ae_prog\" items...\n    for (ht = &aff->af_pref; ; ht = &aff->af_suff)\n    {\n\ttodo = (int)ht->ht_used;\n\tfor (hi = ht->ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tah = HI2AH(hi);\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t    vim_regfree(ae->ae_prog);\n\t    }\n\t}\n\tif (ht == &aff->af_suff)\n\t    break;\n    }\n\n    hash_clear(&aff->af_pref);\n    hash_clear(&aff->af_suff);\n    hash_clear(&aff->af_comp);\n}\n\n/*\n * Read dictionary file \"fname\".\n * Returns OK or FAIL;\n */\n    static int\nspell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)\n{\n    hashtab_T\tht;\n    char_u\tline[MAXLINELEN];\n    char_u\t*p;\n    char_u\t*afflist;\n    char_u\tstore_afflist[MAXWLEN];\n    int\t\tpfxlen;\n    int\t\tneed_affix;\n    char_u\t*dw;\n    char_u\t*pc;\n    char_u\t*w;\n    int\t\tl;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    FILE\t*fd;\n    int\t\tlnum = 1;\n    int\t\tnon_ascii = 0;\n    int\t\tretval = OK;\n    char_u\tmessage[MAXLINELEN + MAXWLEN];\n    int\t\tflags;\n    int\t\tduplicate = 0;\n    time_T\tlast_msg_time = 0;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // The hashtable is only used to detect duplicated words.\n    hash_init(&ht);\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Reading dictionary file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    // start with a message for the first line\n    spin->si_msg_count = 999999;\n\n    // Read and ignore the first line: word count.\n    if (vim_fgets(line, MAXLINELEN, fd) || !vim_isdigit(*skipwhite(line)))\n\tsemsg(_(e_no_word_count_in_str), fname);\n\n    /*\n     * Read all the lines in the file one by one.\n     * The words are converted to 'encoding' here, before being added to\n     * the hashtable.\n     */\n    while (!vim_fgets(line, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\tif (line[0] == '#' || line[0] == '/')\n\t    continue;\t// comment line\n\n\t// Remove CR, LF and white space from the end.  White space halfway\n\t// the word is kept to allow e.g., \"et al.\".\n\tl = (int)STRLEN(line);\n\twhile (l > 0 && line[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty line\n\tline[l] = NUL;\n\n\t// Convert from \"SET\" to 'encoding' when needed.\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, line, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %d: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\tcontinue;\n\t    }\n\t    w = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    w = line;\n\t}\n\n\t// Truncate the word at the \"/\", set \"afflist\" to what follows.\n\t// Replace \"\\/\" by \"/\" and \"\\\\\" by \"\\\".\n\tafflist = NULL;\n\tfor (p = w; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (*p == '\\\\' && (p[1] == '\\\\' || p[1] == '/'))\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '/')\n\t    {\n\t\t*p = NUL;\n\t\tafflist = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(w))\n\t{\n\t    ++non_ascii;\n\t    vim_free(pc);\n\t    continue;\n\t}\n\n\t// This takes time, print a message every 10000 words, but not more\n\t// often than once per second.\n\tif (spin->si_verbose && spin->si_msg_count > 10000)\n\t{\n\t    spin->si_msg_count = 0;\n\t    if (vim_time() > last_msg_time)\n\t    {\n\t\tlast_msg_time = vim_time();\n\t\tvim_snprintf((char *)message, sizeof(message),\n\t\t\t_(\"line %6d, word %6ld - %s\"),\n\t\t\t   lnum, spin->si_foldwcount + spin->si_keepwcount, w);\n\t\tmsg_start();\n\t\tmsg_outtrans_long_attr(message, 0);\n\t\tmsg_clr_eos();\n\t\tmsg_didout = FALSE;\n\t\tmsg_col = 0;\n\t\tout_flush();\n\t    }\n\t}\n\n\t// Store the word in the hashtable to be able to find duplicates.\n\tdw = getroom_save(spin, w);\n\tif (dw == NULL)\n\t{\n\t    retval = FAIL;\n\t    vim_free(pc);\n\t    break;\n\t}\n\n\thash = hash_hash(dw);\n\thi = hash_lookup(&ht, dw, hash);\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    if (p_verbose > 0)\n\t\tsmsg(_(\"Duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    else if (duplicate == 0)\n\t\tsmsg(_(\"First duplicate word in %s line %d: %s\"),\n\t\t\t\t\t\t\t     fname, lnum, dw);\n\t    ++duplicate;\n\t}\n\telse\n\t    hash_add_item(&ht, hi, dw, hash);\n\n\tflags = 0;\n\tstore_afflist[0] = NUL;\n\tpfxlen = 0;\n\tneed_affix = FALSE;\n\tif (afflist != NULL)\n\t{\n\t    // Extract flags from the affix list.\n\t    flags |= get_affix_flags(affile, afflist);\n\n\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_needaffix))\n\t\tneed_affix = TRUE;\n\n\t    if (affile->af_pfxpostpone)\n\t\t// Need to store the list of prefix IDs with the word.\n\t\tpfxlen = get_pfxlist(affile, afflist, store_afflist);\n\n\t    if (spin->si_compflags != NULL)\n\t\t// Need to store the list of compound flags with the word.\n\t\t// Concatenate them to the list of prefix IDs.\n\t\tget_compflags(affile, afflist, store_afflist + pfxlen);\n\t}\n\n\t// Add the word to the word tree(s).\n\tif (store_word(spin, dw, flags, spin->si_region,\n\t\t\t\t\t   store_afflist, need_affix) == FAIL)\n\t    retval = FAIL;\n\n\tif (afflist != NULL)\n\t{\n\t    // Find all matching suffixes and add the resulting words.\n\t    // Additionally do matching prefixes that combine.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t   &affile->af_suff, &affile->af_pref,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\n\t    // Find all matching prefixes and add the resulting words.\n\t    if (store_aff_word(spin, dw, afflist, affile,\n\t\t\t  &affile->af_pref, NULL,\n\t\t\t    CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n\t\tretval = FAIL;\n\t}\n\n\tvim_free(pc);\n    }\n\n    if (duplicate > 0)\n\tsmsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);\n    if (spin->si_ascii && non_ascii > 0)\n\tsmsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),\n\t\t\t\t\t\t\t    non_ascii, fname);\n    hash_clear(&ht);\n\n    fclose(fd);\n    return retval;\n}\n\n/*\n * Check for affix flags in \"afflist\" that are turned into word flags.\n * Return WF_ flags.\n */\n    static int\nget_affix_flags(afffile_T *affile, char_u *afflist)\n{\n    int\t\tflags = 0;\n\n    if (affile->af_keepcase != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_keepcase))\n\tflags |= WF_KEEPCAP | WF_FIXCAP;\n    if (affile->af_rare != 0 && flag_in_afflist(\n\t\t\t       affile->af_flagtype, afflist, affile->af_rare))\n\tflags |= WF_RARE;\n    if (affile->af_bad != 0 && flag_in_afflist(\n\t\t\t\taffile->af_flagtype, afflist, affile->af_bad))\n\tflags |= WF_BANNED;\n    if (affile->af_needcomp != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_needcomp))\n\tflags |= WF_NEEDCOMP;\n    if (affile->af_comproot != 0 && flag_in_afflist(\n\t\t\t   affile->af_flagtype, afflist, affile->af_comproot))\n\tflags |= WF_COMPROOT;\n    if (affile->af_nosuggest != 0 && flag_in_afflist(\n\t\t\t  affile->af_flagtype, afflist, affile->af_nosuggest))\n\tflags |= WF_NOSUGGEST;\n    return flags;\n}\n\n/*\n * Get the list of prefix IDs from the affix list \"afflist\".\n * Used for PFXPOSTPONE.\n * Put the resulting flags in \"store_afflist[MAXWLEN]\" with a terminating NUL\n * and return the number of affixes.\n */\n    static int\nget_pfxlist(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    int\t\tid;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a postponed prefix flag if it appears in \"af_pref\"\n\t    // and its ID is not zero.\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_pref, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tid = HI2AH(hi)->ah_newID;\n\t\tif (id != 0)\n\t\t    store_afflist[cnt++] = id;\n\t    }\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n    return cnt;\n}\n\n/*\n * Get the list of compound IDs from the affix list \"afflist\" that are used\n * for compound words.\n * Puts the flags in \"store_afflist[]\".\n */\n    static void\nget_compflags(\n    afffile_T\t*affile,\n    char_u\t*afflist,\n    char_u\t*store_afflist)\n{\n    char_u\t*p;\n    char_u\t*prevp;\n    int\t\tcnt = 0;\n    char_u\tkey[AH_KEY_LEN];\n    hashitem_T\t*hi;\n\n    for (p = afflist; *p != NUL; )\n    {\n\tprevp = p;\n\tif (get_affitem(affile->af_flagtype, &p) != 0)\n\t{\n\t    // A flag is a compound flag if it appears in \"af_comp\".\n\t    vim_strncpy(key, prevp, p - prevp);\n\t    hi = hash_find(&affile->af_comp, key);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\tstore_afflist[cnt++] = HI2CI(hi)->ci_newID;\n\t}\n\tif (affile->af_flagtype == AFT_NUM && *p == ',')\n\t    ++p;\n    }\n\n    store_afflist[cnt] = NUL;\n}\n\n/*\n * Apply affixes to a word and store the resulting words.\n * \"ht\" is the hashtable with affentry_T that need to be applied, either\n * prefixes or suffixes.\n * \"xht\", when not NULL, is the prefix hashtable, to be used additionally on\n * the resulting words for combining affixes.\n *\n * Returns FAIL when out of memory.\n */\n    static int\nstore_aff_word(\n    spellinfo_T\t*spin,\t\t// spell info\n    char_u\t*word,\t\t// basic word start\n    char_u\t*afflist,\t// list of names of supported affixes\n    afffile_T\t*affile,\n    hashtab_T\t*ht,\n    hashtab_T\t*xht,\n    int\t\tcondit,\t\t// CONDIT_SUF et al.\n    int\t\tflags,\t\t// flags for the word\n    char_u\t*pfxlist,\t// list of prefix IDs\n    int\t\tpfxlen)\t\t// nr of flags in \"pfxlist\" for prefixes, rest\n\t\t\t\t// is compound flags\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    affheader_T\t*ah;\n    affentry_T\t*ae;\n    char_u\tnewword[MAXWLEN];\n    int\t\tretval = OK;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tuse_flags;\n    char_u\t*use_pfxlist;\n    int\t\tuse_pfxlen;\n    int\t\tneed_affix;\n    char_u\tstore_afflist[MAXWLEN];\n    char_u\tpfx_pfxlist[MAXWLEN];\n    size_t\twordlen = STRLEN(word);\n    int\t\tuse_condit;\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ah = HI2AH(hi);\n\n\t    // Check that the affix combines, if required, and that the word\n\t    // supports this affix.\n\t    if (((condit & CONDIT_COMB) == 0 || ah->ah_combine)\n\t\t    && flag_in_afflist(affile->af_flagtype, afflist,\n\t\t\t\t\t\t\t\t ah->ah_flag))\n\t    {\n\t\t// Loop over all affix entries with this name.\n\t\tfor (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n\t\t{\n\t\t    // Check the condition.  It's not logical to match case\n\t\t    // here, but it is required for compatibility with\n\t\t    // Myspell.\n\t\t    // Another requirement from Myspell is that the chop\n\t\t    // string is shorter than the word itself.\n\t\t    // For prefixes, when \"PFXPOSTPONE\" was used, only do\n\t\t    // prefixes with a chop string and/or flags.\n\t\t    // When a previously added affix had CIRCUMFIX this one\n\t\t    // must have it too, if it had not then this one must not\n\t\t    // have one either.\n\t\t    if ((xht != NULL || !affile->af_pfxpostpone\n\t\t\t\t|| ae->ae_chop != NULL\n\t\t\t\t|| ae->ae_flags != NULL)\n\t\t\t    && (ae->ae_chop == NULL\n\t\t\t\t|| STRLEN(ae->ae_chop) < wordlen)\n\t\t\t    && (ae->ae_prog == NULL\n\t\t\t\t|| vim_regexec_prog(&ae->ae_prog, FALSE,\n\t\t\t\t\t\t\t    word, (colnr_T)0))\n\t\t\t    && (((condit & CONDIT_CFIX) == 0)\n\t\t\t\t== ((condit & CONDIT_AFF) == 0\n\t\t\t\t    || ae->ae_flags == NULL\n\t\t\t\t    || !flag_in_afflist(affile->af_flagtype,\n\t\t\t\t\tae->ae_flags, affile->af_circumfix))))\n\t\t    {\n\t\t\t// Match.  Remove the chop and add the affix.\n\t\t\tif (xht == NULL)\n\t\t\t{\n\t\t\t    // prefix: chop/add at the start of the word\n\t\t\t    if (ae->ae_add == NULL)\n\t\t\t\t*newword = NUL;\n\t\t\t    else\n\t\t\t\tvim_strncpy(newword, ae->ae_add, MAXWLEN - 1);\n\t\t\t    p = word;\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Skip chop string.\n\t\t\t\tif (has_mbyte)\n\t\t\t\t{\n\t\t\t\t    i = mb_charlen(ae->ae_chop);\n\t\t\t\t    for ( ; i > 0; --i)\n\t\t\t\t\tMB_PTR_ADV(p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    p += STRLEN(ae->ae_chop);\n\t\t\t    }\n\t\t\t    STRCAT(newword, p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // suffix: chop/add at the end of the word\n\t\t\t    vim_strncpy(newword, word, MAXWLEN - 1);\n\t\t\t    if (ae->ae_chop != NULL)\n\t\t\t    {\n\t\t\t\t// Remove chop string.\n\t\t\t\tp = newword + STRLEN(newword);\n\t\t\t\ti = (int)MB_CHARLEN(ae->ae_chop);\n\t\t\t\tfor ( ; i > 0; --i)\n\t\t\t\t    MB_PTR_BACK(newword, p);\n\t\t\t\t*p = NUL;\n\t\t\t    }\n\t\t\t    if (ae->ae_add != NULL)\n\t\t\t\tSTRCAT(newword, ae->ae_add);\n\t\t\t}\n\n\t\t\tuse_flags = flags;\n\t\t\tuse_pfxlist = pfxlist;\n\t\t\tuse_pfxlen = pfxlen;\n\t\t\tneed_affix = FALSE;\n\t\t\tuse_condit = condit | CONDIT_COMB | CONDIT_AFF;\n\t\t\tif (ae->ae_flags != NULL)\n\t\t\t{\n\t\t\t    // Extract flags from the affix list.\n\t\t\t    use_flags |= get_affix_flags(affile, ae->ae_flags);\n\n\t\t\t    if (affile->af_needaffix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_needaffix))\n\t\t\t\tneed_affix = TRUE;\n\n\t\t\t    // When there is a CIRCUMFIX flag the other affix\n\t\t\t    // must also have it and we don't add the word\n\t\t\t    // with one affix.\n\t\t\t    if (affile->af_circumfix != 0 && flag_in_afflist(\n\t\t\t\t\taffile->af_flagtype, ae->ae_flags,\n\t\t\t\t\t\t\taffile->af_circumfix))\n\t\t\t    {\n\t\t\t\tuse_condit |= CONDIT_CFIX;\n\t\t\t\tif ((condit & CONDIT_CFIX) == 0)\n\t\t\t\t    need_affix = TRUE;\n\t\t\t    }\n\n\t\t\t    if (affile->af_pfxpostpone\n\t\t\t\t\t\t|| spin->si_compflags != NULL)\n\t\t\t    {\n\t\t\t\tif (affile->af_pfxpostpone)\n\t\t\t\t    // Get prefix IDS from the affix list.\n\t\t\t\t    use_pfxlen = get_pfxlist(affile,\n\t\t\t\t\t\t ae->ae_flags, store_afflist);\n\t\t\t\telse\n\t\t\t\t    use_pfxlen = 0;\n\t\t\t\tuse_pfxlist = store_afflist;\n\n\t\t\t\t// Combine the prefix IDs. Avoid adding the\n\t\t\t\t// same ID twice.\n\t\t\t\tfor (i = 0; i < pfxlen; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = 0; j < use_pfxlen; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j == use_pfxlen)\n\t\t\t\t\tuse_pfxlist[use_pfxlen++] = pfxlist[i];\n\t\t\t\t}\n\n\t\t\t\tif (spin->si_compflags != NULL)\n\t\t\t\t    // Get compound IDS from the affix list.\n\t\t\t\t    get_compflags(affile, ae->ae_flags,\n\t\t\t\t\t\t  use_pfxlist + use_pfxlen);\n\n\t\t\t\t// Combine the list of compound flags.\n\t\t\t\t// Concatenate them to the prefix IDs list.\n\t\t\t\t// Avoid adding the same ID twice.\n\t\t\t\tfor (i = pfxlen; pfxlist[i] != NUL; ++i)\n\t\t\t\t{\n\t\t\t\t    for (j = use_pfxlen;\n\t\t\t\t\t\t   use_pfxlist[j] != NUL; ++j)\n\t\t\t\t\tif (pfxlist[i] == use_pfxlist[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (use_pfxlist[j] == NUL)\n\t\t\t\t    {\n\t\t\t\t\tuse_pfxlist[j++] = pfxlist[i];\n\t\t\t\t\tuse_pfxlist[j] = NUL;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// Obey a \"COMPOUNDFORBIDFLAG\" of the affix: don't\n\t\t\t// use the compound flags.\n\t\t\tif (use_pfxlist != NULL && ae->ae_compforbid)\n\t\t\t{\n\t\t\t    vim_strncpy(pfx_pfxlist, use_pfxlist, use_pfxlen);\n\t\t\t    use_pfxlist = pfx_pfxlist;\n\t\t\t}\n\n\t\t\t// When there are postponed prefixes...\n\t\t\tif (spin->si_prefroot != NULL\n\t\t\t\t&& spin->si_prefroot->wn_sibling != NULL)\n\t\t\t{\n\t\t\t    // ... add a flag to indicate an affix was used.\n\t\t\t    use_flags |= WF_HAS_AFF;\n\n\t\t\t    // ... don't use a prefix list if combining\n\t\t\t    // affixes is not allowed.  But do use the\n\t\t\t    // compound flags after them.\n\t\t\t    if (!ah->ah_combine && use_pfxlist != NULL)\n\t\t\t\tuse_pfxlist += use_pfxlen;\n\t\t\t}\n\n\t\t\t// When compounding is supported and there is no\n\t\t\t// \"COMPOUNDPERMITFLAG\" then forbid compounding on the\n\t\t\t// side where the affix is applied.\n\t\t\tif (spin->si_compflags != NULL && !ae->ae_comppermit)\n\t\t\t{\n\t\t\t    if (xht != NULL)\n\t\t\t\tuse_flags |= WF_NOCOMPAFT;\n\t\t\t    else\n\t\t\t\tuse_flags |= WF_NOCOMPBEF;\n\t\t\t}\n\n\t\t\t// Store the modified word.\n\t\t\tif (store_word(spin, newword, use_flags,\n\t\t\t\t\t\t spin->si_region, use_pfxlist,\n\t\t\t\t\t\t\t  need_affix) == FAIL)\n\t\t\t    retval = FAIL;\n\n\t\t\t// When added a prefix or a first suffix and the affix\n\t\t\t// has flags may add a(nother) suffix.  RECURSIVE!\n\t\t\tif ((condit & CONDIT_SUF) && ae->ae_flags != NULL)\n\t\t\t    if (store_aff_word(spin, newword, ae->ae_flags,\n\t\t\t\t\taffile, &affile->af_suff, xht,\n\t\t\t\t\t   use_condit & (xht == NULL\n\t\t\t\t\t\t\t? ~0 :  ~CONDIT_SUF),\n\t\t\t\t      use_flags, use_pfxlist, pfxlen) == FAIL)\n\t\t\t\tretval = FAIL;\n\n\t\t\t// When added a suffix and combining is allowed also\n\t\t\t// try adding a prefix additionally.  Both for the\n\t\t\t// word flags and for the affix flags.  RECURSIVE!\n\t\t\tif (xht != NULL && ah->ah_combine)\n\t\t\t{\n\t\t\t    if (store_aff_word(spin, newword,\n\t\t\t\t\tafflist, affile,\n\t\t\t\t\txht, NULL, use_condit,\n\t\t\t\t\tuse_flags, use_pfxlist,\n\t\t\t\t\tpfxlen) == FAIL\n\t\t\t\t    || (ae->ae_flags != NULL\n\t\t\t\t\t&& store_aff_word(spin, newword,\n\t\t\t\t\t    ae->ae_flags, affile,\n\t\t\t\t\t    xht, NULL, use_condit,\n\t\t\t\t\t    use_flags, use_pfxlist,\n\t\t\t\t\t    pfxlen) == FAIL))\n\t\t\t\tretval = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a file with a list of words.\n */\n    static int\nspell_read_wordfile(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    long\tlnum = 0;\n    char_u\trline[MAXLINELEN];\n    char_u\t*line;\n    char_u\t*pc = NULL;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tretval = OK;\n    int\t\tdid_word = FALSE;\n    int\t\tnon_ascii = 0;\n    int\t\tflags;\n    int\t\tregionmask;\n\n    /*\n     * Open the file.\n     */\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading word file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * Read all the lines in the file one by one.\n     */\n    while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int)\n    {\n\tline_breakcheck();\n\t++lnum;\n\n\t// Skip comment lines.\n\tif (*rline == '#')\n\t    continue;\n\n\t// Remove CR, LF and white space from the end.\n\tl = (int)STRLEN(rline);\n\twhile (l > 0 && rline[l - 1] <= ' ')\n\t    --l;\n\tif (l == 0)\n\t    continue;\t// empty or blank line\n\trline[l] = NUL;\n\n\t// Convert from \"/encoding={encoding}\" to 'encoding' when needed.\n\tvim_free(pc);\n\tif (spin->si_conv.vc_type != CONV_NONE)\n\t{\n\t    pc = string_convert(&spin->si_conv, rline, NULL);\n\t    if (pc == NULL)\n\t    {\n\t\tsmsg(_(\"Conversion failure for word in %s line %ld: %s\"),\n\t\t\t\t\t\t\t   fname, lnum, rline);\n\t\tcontinue;\n\t    }\n\t    line = pc;\n\t}\n\telse\n\t{\n\t    pc = NULL;\n\t    line = rline;\n\t}\n\n\tif (*line == '/')\n\t{\n\t    ++line;\n\t    if (STRNCMP(line, \"encoding=\", 9) == 0)\n\t    {\n\t\tif (spin->si_conv.vc_type != CONV_NONE)\n\t\t    smsg(_(\"Duplicate /encoding= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse if (did_word)\n\t\t    smsg(_(\"/encoding= line after word ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t\telse\n\t\t{\n\t\t    char_u\t*enc;\n\n\t\t    // Setup for conversion to 'encoding'.\n\t\t    line += 9;\n\t\t    enc = enc_canonize(line);\n\t\t    if (enc != NULL && !spin->si_ascii\n\t\t\t    && convert_setup(&spin->si_conv, enc,\n\t\t\t\t\t\t\t       p_enc) == FAIL)\n\t\t\tsmsg(_(\"Conversion in %s not supported: from %s to %s\"),\n\t\t\t\t\t\t\t  fname, line, p_enc);\n\t\t    vim_free(enc);\n\t\t    spin->si_conv.vc_fail = TRUE;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (STRNCMP(line, \"regions=\", 8) == 0)\n\t    {\n\t\tif (spin->si_region_count > 1)\n\t\t    smsg(_(\"Duplicate /regions= line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\telse\n\t\t{\n\t\t    line += 8;\n\t\t    if (STRLEN(line) > MAXREGIONS * 2)\n\t\t\tsmsg(_(\"Too many regions in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line);\n\t\t    else\n\t\t    {\n\t\t\tspin->si_region_count = (int)STRLEN(line) / 2;\n\t\t\tSTRCPY(spin->si_region_name, line);\n\n\t\t\t// Adjust the mask for a word valid in all regions.\n\t\t\tspin->si_region = (1 << spin->si_region_count) - 1;\n\t\t    }\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    smsg(_(\"/ line ignored in %s line %ld: %s\"),\n\t\t\t\t\t\t       fname, lnum, line - 1);\n\t    continue;\n\t}\n\n\tflags = 0;\n\tregionmask = spin->si_region;\n\n\t// Check for flags and region after a slash.\n\tp = vim_strchr(line, '/');\n\tif (p != NULL)\n\t{\n\t    *p++ = NUL;\n\t    while (*p != NUL)\n\t    {\n\t\tif (*p == '=')\t\t// keep-case word\n\t\t    flags |= WF_KEEPCAP | WF_FIXCAP;\n\t\telse if (*p == '!')\t// Bad, bad, wicked word.\n\t\t    flags |= WF_BANNED;\n\t\telse if (*p == '?')\t// Rare word.\n\t\t    flags |= WF_RARE;\n\t\telse if (VIM_ISDIGIT(*p)) // region number(s)\n\t\t{\n\t\t    if ((flags & WF_REGION) == 0)   // first one\n\t\t\tregionmask = 0;\n\t\t    flags |= WF_REGION;\n\n\t\t    l = *p - '0';\n\t\t    if (l == 0 || l > spin->si_region_count)\n\t\t    {\n\t\t\tsmsg(_(\"Invalid region nr in %s line %ld: %s\"),\n\t\t\t\t\t\t\t  fname, lnum, p);\n\t\t\tbreak;\n\t\t    }\n\t\t    regionmask |= 1 << (l - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    smsg(_(\"Unrecognized flags in %s line %ld: %s\"),\n\t\t\t\t\t\t\t      fname, lnum, p);\n\t\t    break;\n\t\t}\n\t\t++p;\n\t    }\n\t}\n\n\t// Skip non-ASCII words when \"spin->si_ascii\" is TRUE.\n\tif (spin->si_ascii && has_non_ascii(line))\n\t{\n\t    ++non_ascii;\n\t    continue;\n\t}\n\n\t// Normal word: store it.\n\tif (store_word(spin, line, flags, regionmask, NULL, FALSE) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    break;\n\t}\n\tdid_word = TRUE;\n    }\n\n    vim_free(pc);\n    fclose(fd);\n\n    if (spin->si_ascii && non_ascii > 0)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t  _(\"Ignored %d words with non-ASCII characters\"), non_ascii);\n\tspell_message(spin, IObuff);\n    }\n\n    return retval;\n}\n\n/*\n * Get part of an sblock_T, \"len\" bytes long.\n * This avoids calling free() for every little struct we use (and keeping\n * track of them).\n * The memory is cleared to all zeros.\n * Returns NULL when out of memory.\n */\n    static void *\ngetroom(\n    spellinfo_T *spin,\n    size_t\tlen,\t\t// length needed\n    int\t\talign)\t\t// align for pointer\n{\n    char_u\t*p;\n    sblock_T\t*bl = spin->si_blocks;\n\n    if (align && bl != NULL)\n\t// Round size up for alignment.  On some systems structures need to be\n\t// aligned to the size of a pointer (e.g., SPARC).\n\tbl->sb_used = (bl->sb_used + sizeof(char *) - 1)\n\t\t\t\t\t\t      & ~(sizeof(char *) - 1);\n\n    if (bl == NULL || bl->sb_used + len > SBLOCKSIZE)\n    {\n\tif (len >= SBLOCKSIZE)\n\t    bl = NULL;\n\telse\n\t    // Allocate a block of memory. It is not freed until much later.\n\t    bl = alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);\n\tif (bl == NULL)\n\t{\n\t    if (!spin->si_did_emsg)\n\t    {\n\t\temsg(_(e_insufficient_memory_word_list_will_be_incomplete));\n\t\tspin->si_did_emsg = TRUE;\n\t    }\n\t    return NULL;\n\t}\n\tbl->sb_next = spin->si_blocks;\n\tspin->si_blocks = bl;\n\tbl->sb_used = 0;\n\t++spin->si_blocks_cnt;\n    }\n\n    p = bl->sb_data + bl->sb_used;\n    bl->sb_used += (int)len;\n\n    return p;\n}\n\n/*\n * Make a copy of a string into memory allocated with getroom().\n * Returns NULL when out of memory.\n */\n    static char_u *\ngetroom_save(spellinfo_T *spin, char_u *s)\n{\n    char_u\t*sc;\n\n    sc = (char_u *)getroom(spin, STRLEN(s) + 1, FALSE);\n    if (sc != NULL)\n\tSTRCPY(sc, s);\n    return sc;\n}\n\n\n/*\n * Free the list of allocated sblock_T.\n */\n    static void\nfree_blocks(sblock_T *bl)\n{\n    sblock_T\t*next;\n\n    while (bl != NULL)\n    {\n\tnext = bl->sb_next;\n\tvim_free(bl);\n\tbl = next;\n    }\n}\n\n/*\n * Allocate the root of a word tree.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nwordtree_alloc(spellinfo_T *spin)\n{\n    return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n}\n\n/*\n * Return TRUE if \"word\" contains valid word characters.\n * Control characters and trailing '/' are invalid.  Space is OK.\n */\n    static int\nvalid_spell_word(char_u *word)\n{\n    char_u *p;\n\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n\treturn FALSE;\n    for (p = word; *p != NUL; p += mb_ptr2len(p))\n\tif (*p < ' ' || (p[0] == '/' && p[1] == NUL))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Store a word in the tree(s).\n * Always store it in the case-folded tree.  For a keep-case word this is\n * useful when the word can also be used with all caps (no WF_FIXCAP flag) and\n * used to find suggestions.\n * For a keep-case word also store it in the keep-case tree.\n * When \"pfxlist\" is not NULL store the word for each postponed prefix ID and\n * compound flag.\n */\n    static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    // Avoid adding illegal bytes to the word tree.\n    if (!valid_spell_word(word))\n\treturn FAIL;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}\n\n/*\n * Add word \"word\" to a word tree at \"root\".\n * When \"flags\" < 0 we are adding to the prefix tree where \"flags\" is used for\n * \"rare\" and \"region\" is the condition nr.\n * Returns FAIL when out of memory.\n */\n    static int\ntree_add_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    wordnode_T\t*root,\n    int\t\tflags,\n    int\t\tregion,\n    int\t\taffixID)\n{\n    wordnode_T\t*node = root;\n    wordnode_T\t*np;\n    wordnode_T\t*copyp, **copyprev;\n    wordnode_T\t**prev = NULL;\n    int\t\ti;\n\n    // Add each byte of the word to the tree, including the NUL at the end.\n    for (i = 0; ; ++i)\n    {\n\t// When there is more than one reference to this node we need to make\n\t// a copy, so that we can modify it.  Copy the whole list of siblings\n\t// (we don't optimize for a partly shared list of siblings).\n\tif (node != NULL && node->wn_refs > 1)\n\t{\n\t    --node->wn_refs;\n\t    copyprev = prev;\n\t    FOR_ALL_NODE_SIBLINGS(node, copyp)\n\t    {\n\t\t// Allocate a new node and copy the info.\n\t\tnp = get_wordnode(spin);\n\t\tif (np == NULL)\n\t\t    return FAIL;\n\t\tnp->wn_child = copyp->wn_child;\n\t\tif (np->wn_child != NULL)\n\t\t    ++np->wn_child->wn_refs;\t// child gets extra ref\n\t\tnp->wn_byte = copyp->wn_byte;\n\t\tif (np->wn_byte == NUL)\n\t\t{\n\t\t    np->wn_flags = copyp->wn_flags;\n\t\t    np->wn_region = copyp->wn_region;\n\t\t    np->wn_affixID = copyp->wn_affixID;\n\t\t}\n\n\t\t// Link the new node in the list, there will be one ref.\n\t\tnp->wn_refs = 1;\n\t\tif (copyprev != NULL)\n\t\t    *copyprev = np;\n\t\tcopyprev = &np->wn_sibling;\n\n\t\t// Let \"node\" point to the head of the copied list.\n\t\tif (copyp == node)\n\t\t    node = np;\n\t    }\n\t}\n\n\t// Look for the sibling that has the same character.  They are sorted\n\t// on byte value, thus stop searching when a sibling is found with a\n\t// higher byte value.  For zero bytes (end of word) the sorting is\n\t// done on flags and then on affixID.\n\twhile (node != NULL\n\t\t&& (node->wn_byte < word[i]\n\t\t    || (node->wn_byte == NUL\n\t\t\t&& (flags < 0\n\t\t\t    ? node->wn_affixID < (unsigned)affixID\n\t\t\t    : (node->wn_flags < (unsigned)(flags & WN_MASK)\n\t\t\t\t|| (node->wn_flags == (flags & WN_MASK)\n\t\t\t\t    && (spin->si_sugtree\n\t\t\t\t\t? (node->wn_region & 0xffff) < region\n\t\t\t\t\t: node->wn_affixID\n\t\t\t\t\t\t    < (unsigned)affixID)))))))\n\t{\n\t    prev = &node->wn_sibling;\n\t    node = *prev;\n\t}\n\tif (node == NULL\n\t\t|| node->wn_byte != word[i]\n\t\t|| (word[i] == NUL\n\t\t    && (flags < 0\n\t\t\t|| spin->si_sugtree\n\t\t\t|| node->wn_flags != (flags & WN_MASK)\n\t\t\t|| node->wn_affixID != affixID)))\n\t{\n\t    // Allocate a new node.\n\t    np = get_wordnode(spin);\n\t    if (np == NULL)\n\t\treturn FAIL;\n\t    np->wn_byte = word[i];\n\n\t    // If \"node\" is NULL this is a new child or the end of the sibling\n\t    // list: ref count is one.  Otherwise use ref count of sibling and\n\t    // make ref count of sibling one (matters when inserting in front\n\t    // of the list of siblings).\n\t    if (node == NULL)\n\t\tnp->wn_refs = 1;\n\t    else\n\t    {\n\t\tnp->wn_refs = node->wn_refs;\n\t\tnode->wn_refs = 1;\n\t    }\n\t    if (prev != NULL)\n\t\t*prev = np;\n\t    np->wn_sibling = node;\n\t    node = np;\n\t}\n\n\tif (word[i] == NUL)\n\t{\n\t    node->wn_flags = flags;\n\t    node->wn_region |= region;\n\t    node->wn_affixID = affixID;\n\t    break;\n\t}\n\tprev = &node->wn_child;\n\tnode = *prev;\n    }\n#ifdef SPELL_PRINTTREE\n    smsg(\"Added \\\"%s\\\"\", word);\n    spell_print_tree(root->wn_sibling);\n#endif\n\n    // count nr of words added since last message\n    ++spin->si_msg_count;\n\n    if (spin->si_compress_cnt > 1)\n    {\n\tif (--spin->si_compress_cnt == 1)\n\t    // Did enough words to lower the block count limit.\n\t    spin->si_blocks_cnt += compress_inc;\n    }\n\n    /*\n     * When we have allocated lots of memory we need to compress the word tree\n     * to free up some room.  But compression is slow, and we might actually\n     * need that room, thus only compress in the following situations:\n     * 1. When not compressed before (si_compress_cnt == 0): when using\n     *    \"compress_start\" blocks.\n     * 2. When compressed before and used \"compress_inc\" blocks before\n     *    adding \"compress_added\" words (si_compress_cnt > 1).\n     * 3. When compressed before, added \"compress_added\" words\n     *    (si_compress_cnt == 1) and the number of free nodes drops below the\n     *    maximum word length.\n     */\n#ifndef SPELL_COMPRESS_ALLWAYS\n    if (spin->si_compress_cnt == 1\n\t    ? spin->si_free_count < MAXWLEN\n\t    : spin->si_blocks_cnt >= compress_start)\n#endif\n    {\n\t// Decrement the block counter.  The effect is that we compress again\n\t// when the freed up room has been used and another \"compress_inc\"\n\t// blocks have been allocated.  Unless \"compress_added\" words have\n\t// been added, then the limit is put back again.\n\tspin->si_blocks_cnt -= compress_inc;\n\tspin->si_compress_cnt = compress_added;\n\n\tif (spin->si_verbose)\n\t{\n\t    msg_start();\n\t    msg_puts(_(msg_compressing));\n\t    msg_clr_eos();\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    out_flush();\n\t}\n\n\t// Compress both trees.  Either they both have many nodes, which makes\n\t// compression useful, or one of them is small, which means\n\t// compression goes fast.  But when filling the soundfold word tree\n\t// there is no keep-case tree.\n\twordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\tif (affixID >= 0)\n\t    wordtree_compress(spin, spin->si_keeproot, \"keep-case\");\n    }\n\n    return OK;\n}\n\n/*\n * Get a wordnode_T, either from the list of previously freed nodes or\n * allocate a new one.\n * Returns NULL when out of memory.\n */\n    static wordnode_T *\nget_wordnode(spellinfo_T *spin)\n{\n    wordnode_T *n;\n\n    if (spin->si_first_free == NULL)\n\tn = (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n    else\n    {\n\tn = spin->si_first_free;\n\tspin->si_first_free = n->wn_child;\n\tCLEAR_POINTER(n);\n\t--spin->si_free_count;\n    }\n#ifdef SPELL_PRINTTREE\n    if (n != NULL)\n\tn->wn_nr = ++spin->si_wordnode_nr;\n#endif\n    return n;\n}\n\n/*\n * Decrement the reference count on a node (which is the head of a list of\n * siblings).  If the reference count becomes zero free the node and its\n * siblings.\n * Returns the number of nodes actually freed.\n */\n    static int\nderef_wordnode(spellinfo_T *spin, wordnode_T *node)\n{\n    wordnode_T\t*np;\n    int\t\tcnt = 0;\n\n    if (--node->wn_refs == 0)\n    {\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    if (np->wn_child != NULL)\n\t\tcnt += deref_wordnode(spin, np->wn_child);\n\t    free_wordnode(spin, np);\n\t    ++cnt;\n\t}\n\t++cnt;\t    // length field\n    }\n    return cnt;\n}\n\n/*\n * Free a wordnode_T for re-use later.\n * Only the \"wn_child\" field becomes invalid.\n */\n    static void\nfree_wordnode(spellinfo_T *spin, wordnode_T *n)\n{\n    n->wn_child = spin->si_first_free;\n    spin->si_first_free = n;\n    ++spin->si_free_count;\n}\n\n/*\n * Compress a tree: find tails that are identical and can be shared.\n */\n    static void\nwordtree_compress(spellinfo_T *spin, wordnode_T *root, char *name)\n{\n    hashtab_T\t    ht;\n    long\t    n;\n    long\t    tot = 0;\n    long\t    perc;\n\n    // Skip the root itself, it's not actually used.  The first sibling is the\n    // start of the tree.\n    if (root->wn_sibling != NULL)\n    {\n\thash_init(&ht);\n\tn = node_compress(spin, root->wn_sibling, &ht, &tot);\n\n#ifndef SPELL_PRINTTREE\n\tif (spin->si_verbose || p_verbose > 2)\n#endif\n\t{\n\t    if (tot > 1000000)\n\t\tperc = (tot - n) / (tot / 100);\n\t    else if (tot == 0)\n\t\tperc = 0;\n\t    else\n\t\tperc = (tot - n) * 100 / tot;\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t       _(\"Compressed %s: %ld of %ld nodes; %ld (%ld%%) remaining\"),\n\t\t\t\t\t\t       name, n, tot, tot - n, perc);\n\t    spell_message(spin, IObuff);\n\t}\n#ifdef SPELL_PRINTTREE\n\tspell_print_tree(root->wn_sibling);\n#endif\n\thash_clear(&ht);\n    }\n}\n\n/*\n * Compress a node, its siblings and its children, depth first.\n * Returns the number of compressed nodes.\n */\n    static long\nnode_compress(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    hashtab_T\t*ht,\n    long\t*tot)\t    // total count of nodes before compressing,\n\t\t\t    // incremented while going through the tree\n{\n    wordnode_T\t*np;\n    wordnode_T\t*tp;\n    wordnode_T\t*child;\n    hash_T\thash;\n    hashitem_T\t*hi;\n    long\tlen = 0;\n    unsigned\tnr, n;\n    long\tcompressed = 0;\n\n    /*\n     * Go through the list of siblings.  Compress each child and then try\n     * finding an identical child to replace it.\n     * Note that with \"child\" we mean not just the node that is pointed to,\n     * but the whole list of siblings of which the child node is the first.\n     */\n    for (np = node; np != NULL && !got_int; np = np->wn_sibling)\n    {\n\t++len;\n\tif ((child = np->wn_child) != NULL)\n\t{\n\t    // Compress the child first.  This fills hashkey.\n\t    compressed += node_compress(spin, child, ht, tot);\n\n\t    // Try to find an identical child.\n\t    hash = hash_hash(child->wn_u1.hashkey);\n\t    hi = hash_lookup(ht, child->wn_u1.hashkey, hash);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// There are children we encountered before with a hash value\n\t\t// identical to the current child.  Now check if there is one\n\t\t// that is really identical.\n\t\tfor (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)\n\t\t    if (node_equal(child, tp))\n\t\t    {\n\t\t\t// Found one!  Now use that child in place of the\n\t\t\t// current one.  This means the current child and all\n\t\t\t// its siblings is unlinked from the tree.\n\t\t\t++tp->wn_refs;\n\t\t\tcompressed += deref_wordnode(spin, child);\n\t\t\tnp->wn_child = tp;\n\t\t\tbreak;\n\t\t    }\n\t\tif (tp == NULL)\n\t\t{\n\t\t    // No other child with this hash value equals the child of\n\t\t    // the node, add it to the linked list after the first\n\t\t    // item.\n\t\t    tp = HI2WN(hi);\n\t\t    child->wn_u2.next = tp->wn_u2.next;\n\t\t    tp->wn_u2.next = child;\n\t\t}\n\t    }\n\t    else\n\t\t// No other child has this hash value, add it to the\n\t\t// hashtable.\n\t\thash_add_item(ht, hi, child->wn_u1.hashkey, hash);\n\t}\n    }\n    *tot += len + 1;\t// add one for the node that stores the length\n\n    /*\n     * Make a hash key for the node and its siblings, so that we can quickly\n     * find a lookalike node.  This must be done after compressing the sibling\n     * list, otherwise the hash key would become invalid by the compression.\n     */\n    node->wn_u1.hashkey[0] = len;\n    nr = 0;\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == NUL)\n\t    // end node: use wn_flags, wn_region and wn_affixID\n\t    n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);\n\telse\n\t    // byte node: use the byte value and the child pointer\n\t    n = (unsigned)(np->wn_byte + ((long_u)np->wn_child << 8));\n\tnr = nr * 101 + n;\n    }\n\n    // Avoid NUL bytes, it terminates the hash key.\n    n = nr & 0xff;\n    node->wn_u1.hashkey[1] = n == 0 ? 1 : n;\n    n = (nr >> 8) & 0xff;\n    node->wn_u1.hashkey[2] = n == 0 ? 1 : n;\n    n = (nr >> 16) & 0xff;\n    node->wn_u1.hashkey[3] = n == 0 ? 1 : n;\n    n = (nr >> 24) & 0xff;\n    node->wn_u1.hashkey[4] = n == 0 ? 1 : n;\n    node->wn_u1.hashkey[5] = NUL;\n\n    // Check for CTRL-C pressed now and then.\n    veryfast_breakcheck();\n\n    return compressed;\n}\n\n/*\n * Return TRUE when two nodes have identical siblings and children.\n */\n    static int\nnode_equal(wordnode_T *n1, wordnode_T *n2)\n{\n    wordnode_T\t*p1;\n    wordnode_T\t*p2;\n\n    for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;\n\t\t\t\t     p1 = p1->wn_sibling, p2 = p2->wn_sibling)\n\tif (p1->wn_byte != p2->wn_byte\n\t\t|| (p1->wn_byte == NUL\n\t\t    ? (p1->wn_flags != p2->wn_flags\n\t\t\t|| p1->wn_region != p2->wn_region\n\t\t\t|| p1->wn_affixID != p2->wn_affixID)\n\t\t    : (p1->wn_child != p2->wn_child)))\n\t    break;\n\n    return p1 == NULL && p2 == NULL;\n}\n\nstatic int rep_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the REP items on \"from\" string.\n */\n    static int\nrep_compare(const void *s1, const void *s2)\n{\n    fromto_T\t*p1 = (fromto_T *)s1;\n    fromto_T\t*p2 = (fromto_T *)s2;\n\n    return STRCMP(p1->ft_from, p2->ft_from);\n}\n\n/*\n * Write the Vim .spl file \"fname\".\n * Return FAIL or OK;\n */\n    static int\nwrite_vim_spell(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    int\t\tregionmask;\n    int\t\tround;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\ti;\n    int\t\tl;\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    char_u\t*p;\n    int\t\trr;\n    int\t\tretval = OK;\n    size_t\tfwv = 1;  // collect return value of fwrite() to avoid\n\t\t\t  // warnings from picky compiler\n\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn FAIL;\n    }\n\n    // <HEADER>: <fileID> <versionnr>\n\t\t\t\t\t\t\t    // <fileID>\n    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);\n    if (fwv != (size_t)1)\n\t// Catch first write error, don't try writing more.\n\tgoto theend;\n\n    putc(VIMSPELLVERSION, fd);\t\t\t\t    // <versionnr>\n\n    /*\n     * <SECTIONS>: <section> ... <sectionend>\n     */\n\n    // SN_INFO: <infotext>\n    if (spin->si_info != NULL)\n    {\n\tputc(SN_INFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_info);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); // <infotext>\n    }\n\n    // SN_REGION: <regionname> ...\n    // Write the region names only if there is more than one.\n    if (spin->si_region_count > 1)\n    {\n\tputc(SN_REGION, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\tl = spin->si_region_count * 2;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <regionname> ...\n\tregionmask = (1 << spin->si_region_count) - 1;\n    }\n    else\n\tregionmask = 0;\n\n    // SN_CHARFLAGS: <charflagslen> <charflags> <folcharslen> <folchars>\n    //\n    // The table with character flags and the table for case folding.\n    // This makes sure the same characters are recognized as word characters\n    // when generating and when using a spell file.\n    // Skip this for ASCII, the table may conflict with the one used for\n    // 'encoding'.\n    // Also skip this for an .add.spl file, the main spell file must contain\n    // the table (avoids that it conflicts).  File is shorter too.\n    if (!spin->si_ascii && !spin->si_add)\n    {\n\tchar_u\tfolchars[128 * 8];\n\tint\tflags;\n\n\tputc(SN_CHARFLAGS, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\t// Form the <folchars> string first, we need to know its length.\n\tl = 0;\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tl += mb_char2bytes(spelltab.st_fold[i], folchars + l);\n\t    else\n\t\tfolchars[l++] = spelltab.st_fold[i];\n\t}\n\tput_bytes(fd, (long_u)(1 + 128 + 2 + l), 4);\t// <sectionlen>\n\n\tfputc(128, fd);\t\t\t\t\t// <charflagslen>\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    flags = 0;\n\t    if (spelltab.st_isw[i])\n\t\tflags |= CF_WORD;\n\t    if (spelltab.st_isu[i])\n\t\tflags |= CF_UPPER;\n\t    fputc(flags, fd);\t\t\t\t// <charflags>\n\t}\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <folcharslen>\n\tfwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); // <folchars>\n    }\n\n    // SN_MIDWORD: <midword>\n    if (spin->si_midword != NULL)\n    {\n\tputc(SN_MIDWORD, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\ti = (int)STRLEN(spin->si_midword);\n\tput_bytes(fd, (long_u)i, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);\n\t\t\t\t\t\t\t// <midword>\n    }\n\n    // SN_PREFCOND: <prefcondcnt> <prefcond> ...\n    if (spin->si_prefcond.ga_len > 0)\n    {\n\tputc(SN_PREFCOND, fd);\t\t\t\t// <sectionID>\n\tputc(SNF_REQUIRED, fd);\t\t\t\t// <sectionflags>\n\n\tl = write_spell_prefcond(NULL, &spin->si_prefcond, &fwv);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\twrite_spell_prefcond(fd, &spin->si_prefcond, &fwv);\n    }\n\n    // SN_REP: <repcount> <rep> ...\n    // SN_SAL: <salflags> <salcount> <sal> ...\n    // SN_REPSAL: <repcount> <rep> ...\n\n    // round 1: SN_REP section\n    // round 2: SN_SAL section (unless SN_SOFO is used)\n    // round 3: SN_REPSAL section\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    gap = &spin->si_rep;\n\telse if (round == 2)\n\t{\n\t    // Don't write SN_SAL when using a SN_SOFO section\n\t    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n\t\tcontinue;\n\t    gap = &spin->si_sal;\n\t}\n\telse\n\t    gap = &spin->si_repsal;\n\n\t// Don't write the section if there are no items.\n\tif (gap->ga_len == 0)\n\t    continue;\n\n\t// Sort the REP/REPSAL items.\n\tif (round != 2)\n\t    qsort(gap->ga_data, (size_t)gap->ga_len,\n\t\t\t\t\t       sizeof(fromto_T), rep_compare);\n\n\ti = round == 1 ? SN_REP : (round == 2 ? SN_SAL : SN_REPSAL);\n\tputc(i, fd);\t\t\t\t\t// <sectionID>\n\n\t// This is for making suggestions, section is not required.\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// Compute the length of what follows.\n\tl = 2;\t    // count <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    l += 1 + (int)STRLEN(ftp->ft_from);  // count <*fromlen> and <*from>\n\t    l += 1 + (int)STRLEN(ftp->ft_to);    // count <*tolen> and <*to>\n\t}\n\tif (round == 2)\n\t    ++l;\t// count <salflags>\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\n\tif (round == 2)\n\t{\n\t    i = 0;\n\t    if (spin->si_followup)\n\t\ti |= SAL_F0LLOWUP;\n\t    if (spin->si_collapse)\n\t\ti |= SAL_COLLAPSE;\n\t    if (spin->si_rem_accents)\n\t\ti |= SAL_REM_ACCENTS;\n\t    putc(i, fd);\t\t\t// <salflags>\n\t}\n\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t// <repcount> or <salcount>\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n\t    // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n\t    ftp = &((fromto_T *)gap->ga_data)[i];\n\t    for (rr = 1; rr <= 2; ++rr)\n\t    {\n\t\tp = rr == 1 ? ftp->ft_from : ftp->ft_to;\n\t\tl = (int)STRLEN(p);\n\t\tputc(l, fd);\n\t\tif (l > 0)\n\t\t    fwv &= fwrite(p, l, (size_t)1, fd);\n\t    }\n\t}\n\n    }\n\n    // SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n    // This is for making suggestions, section is not required.\n    if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n    {\n\tputc(SN_SOFO, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_sofofr);\n\tput_bytes(fd, (long_u)(l + STRLEN(spin->si_sofoto) + 4), 4);\n\t\t\t\t\t\t\t// <sectionlen>\n\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofofromlen>\n\tfwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); // <sofofrom>\n\n\tl = (int)STRLEN(spin->si_sofoto);\n\tput_bytes(fd, (long_u)l, 2);\t\t\t// <sofotolen>\n\tfwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); // <sofoto>\n    }\n\n    // SN_WORDS: <word> ...\n    // This is for making suggestions, section is not required.\n    if (spin->si_commonwords.ht_used > 0)\n    {\n\tputc(SN_WORDS, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// round 1: count the bytes\n\t// round 2: write the bytes\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    int\t\ttodo;\n\t    int\t\tlen = 0;\n\t    hashitem_T\t*hi;\n\n\t    todo = (int)spin->si_commonwords.ht_used;\n\t    for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    l = (int)STRLEN(hi->hi_key) + 1;\n\t\t    len += l;\n\t\t    if (round == 2)\t\t\t// <word>\n\t\t\tfwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);\n\t\t    --todo;\n\t\t}\n\t    if (round == 1)\n\t\tput_bytes(fd, (long_u)len, 4);\t\t// <sectionlen>\n\t}\n    }\n\n    // SN_MAP: <mapstr>\n    // This is for making suggestions, section is not required.\n    if (spin->si_map.ga_len > 0)\n    {\n\tputc(SN_MAP, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tl = spin->si_map.ga_len;\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <mapstr>\n    }\n\n    // SN_SUGFILE: <timestamp>\n    // This is used to notify that a .sug file may be available and at the\n    // same time allows for checking that a .sug file that is found matches\n    // with this .spl file.  That's because the word numbers must be exactly\n    // right.\n    if (!spin->si_nosugfile\n\t    && (spin->si_sal.ga_len > 0\n\t\t     || (spin->si_sofofr != NULL && spin->si_sofoto != NULL)))\n    {\n\tputc(SN_SUGFILE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)8, 4);\t\t\t// <sectionlen>\n\n\t// Set si_sugtime and write it to the file.\n\tspin->si_sugtime = time(NULL);\n\tput_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n    }\n\n    // SN_NOSPLITSUGS: nothing\n    // This is used to notify that no suggestions with word splits are to be\n    // made.\n    if (spin->si_nosplitsugs)\n    {\n\tputc(SN_NOSPLITSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_NOCOMPUNDSUGS: nothing\n    // This is used to notify that no suggestions with compounds are to be\n    // made.\n    if (spin->si_nocompoundsugs)\n    {\n\tputc(SN_NOCOMPOUNDSUGS, fd);\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_COMPOUND: compound info.\n    // We don't mark it required, when not supported all compound words will\n    // be bad words.\n    if (spin->si_compflags != NULL)\n    {\n\tputc(SN_COMPOUND, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_compflags);\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t    l += (int)STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;\n\tput_bytes(fd, (long_u)(l + 7), 4);\t\t// <sectionlen>\n\n\tputc(spin->si_compmax, fd);\t\t\t// <compmax>\n\tputc(spin->si_compminlen, fd);\t\t\t// <compminlen>\n\tputc(spin->si_compsylmax, fd);\t\t\t// <compsylmax>\n\tputc(0, fd);\t\t// for Vim 7.0b compatibility\n\tputc(spin->si_compoptions, fd);\t\t\t// <compoptions>\n\tput_bytes(fd, (long_u)spin->si_comppat.ga_len, 2);\n\t\t\t\t\t\t\t// <comppatcount>\n\tfor (i = 0; i < spin->si_comppat.ga_len; ++i)\n\t{\n\t    p = ((char_u **)(spin->si_comppat.ga_data))[i];\n\t    putc((int)STRLEN(p), fd);\t\t\t// <comppatlen>\n\t    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);\n\t\t\t\t\t\t\t// <comppattext>\n\t}\n\t\t\t\t\t\t\t// <compflags>\n\tfwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),\n\t\t\t\t\t\t\t       (size_t)1, fd);\n    }\n\n    // SN_NOBREAK: NOBREAK flag\n    if (spin->si_nobreak)\n    {\n\tputc(SN_NOBREAK, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\t// It's empty, the presence of the section flags the feature.\n\tput_bytes(fd, (long_u)0, 4);\t\t\t// <sectionlen>\n    }\n\n    // SN_SYLLABLE: syllable info.\n    // We don't mark it required, when not supported syllables will not be\n    // counted.\n    if (spin->si_syllable != NULL)\n    {\n\tputc(SN_SYLLABLE, fd);\t\t\t\t// <sectionID>\n\tputc(0, fd);\t\t\t\t\t// <sectionflags>\n\n\tl = (int)STRLEN(spin->si_syllable);\n\tput_bytes(fd, (long_u)l, 4);\t\t\t// <sectionlen>\n\tfwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);\n\t\t\t\t\t\t\t// <syllable>\n    }\n\n    // end of <SECTIONS>\n    putc(SN_END, fd);\t\t\t\t\t// <sectionend>\n\n\n    /*\n     * <LWORDTREE>  <KWORDTREE>  <PREFIXTREE>\n     */\n    spin->si_memtot = 0;\n    for (round = 1; round <= 3; ++round)\n    {\n\tif (round == 1)\n\t    tree = spin->si_foldroot->wn_sibling;\n\telse if (round == 2)\n\t    tree = spin->si_keeproot->wn_sibling;\n\telse\n\t    tree = spin->si_prefroot->wn_sibling;\n\n\t// Clear the index and wnode fields in the tree.\n\tclear_node(tree);\n\n\t// Count the number of nodes.  Needed to be able to allocate the\n\t// memory when reading the nodes.  Also fills in index for shared\n\t// nodes.\n\tnodecount = put_node(NULL, tree, 0, regionmask, round == 3);\n\n\t// number of nodes in 4 bytes\n\tput_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n\tspin->si_memtot += nodecount + nodecount * sizeof(int);\n\n\t// Write the nodes.\n\t(void)put_node(fd, tree, 0, regionmask, round == 3);\n    }\n\n    // Write another byte to check for errors (file system full).\n    if (putc(0, fd) == EOF)\n\tretval = FAIL;\ntheend:\n    if (fclose(fd) == EOF)\n\tretval = FAIL;\n\n    if (fwv != (size_t)1)\n\tretval = FAIL;\n    if (retval == FAIL)\n\temsg(_(e_error_while_writing));\n\n    return retval;\n}\n\n/*\n * Clear the index and wnode fields of \"node\", it siblings and its\n * children.  This is needed because they are a union with other items to save\n * space.\n */\n    static void\nclear_node(wordnode_T *node)\n{\n    wordnode_T\t*np;\n\n    if (node != NULL)\n\tFOR_ALL_NODE_SIBLINGS(node, np)\n\t{\n\t    np->wn_u1.index = 0;\n\t    np->wn_u2.wnode = NULL;\n\n\t    if (np->wn_byte != NUL)\n\t\tclear_node(np->wn_child);\n\t}\n}\n\n\n/*\n * Dump a word tree at node \"node\".\n *\n * This first writes the list of possible bytes (siblings).  Then for each\n * byte recursively write the children.\n *\n * NOTE: The code here must match the code in read_tree_node(), since\n * assumptions are made about the indexes (so that we don't have to write them\n * in the file).\n *\n * Returns the number of nodes used.\n */\n    static int\nput_node(\n    FILE\t*fd,\t\t// NULL when only counting\n    wordnode_T\t*node,\n    int\t\tidx,\n    int\t\tregionmask,\n    int\t\tprefixtree)\t// TRUE for PREFIXTREE\n{\n    int\t\tnewindex = idx;\n    int\t\tsiblingcount = 0;\n    wordnode_T\t*np;\n    int\t\tflags;\n\n    // If \"node\" is zero the tree is empty.\n    if (node == NULL)\n\treturn 0;\n\n    // Store the index where this node is written.\n    node->wn_u1.index = idx;\n\n    // Count the number of siblings.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\t++siblingcount;\n\n    // Write the sibling count.\n    if (fd != NULL)\n\tputc(siblingcount, fd);\t\t\t\t// <siblingcount>\n\n    // Write each sibling byte and optionally extra info.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n    {\n\tif (np->wn_byte == 0)\n\t{\n\t    if (fd != NULL)\n\t    {\n\t\t// For a NUL byte (end of word) write the flags etc.\n\t\tif (prefixtree)\n\t\t{\n\t\t    // In PREFIXTREE write the required affixID and the\n\t\t    // associated condition nr (stored in wn_region).  The\n\t\t    // byte value is misused to store the \"rare\" and \"not\n\t\t    // combining\" flags\n\t\t    if (np->wn_flags == (short_u)PFX_FLAGS)\n\t\t\tputc(BY_NOFLAGS, fd);\t\t// <byte>\n\t\t    else\n\t\t    {\n\t\t\tputc(BY_FLAGS, fd);\t\t// <byte>\n\t\t\tputc(np->wn_flags, fd);\t\t// <pflags>\n\t\t    }\n\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    put_bytes(fd, (long_u)np->wn_region, 2); // <prefcondnr>\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For word trees we write the flag/region items.\n\t\t    flags = np->wn_flags;\n\t\t    if (regionmask != 0 && np->wn_region != regionmask)\n\t\t\tflags |= WF_REGION;\n\t\t    if (np->wn_affixID != 0)\n\t\t\tflags |= WF_AFX;\n\t\t    if (flags == 0)\n\t\t    {\n\t\t\t// word without flags or region\n\t\t\tputc(BY_NOFLAGS, fd);\t\t\t// <byte>\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (np->wn_flags >= 0x100)\n\t\t\t{\n\t\t\t    putc(BY_FLAGS2, fd);\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t    putc((unsigned)flags >> 8, fd);\t// <flags2>\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    putc(BY_FLAGS, fd);\t\t\t// <byte>\n\t\t\t    putc(flags, fd);\t\t\t// <flags>\n\t\t\t}\n\t\t\tif (flags & WF_REGION)\n\t\t\t    putc(np->wn_region, fd);\t\t// <region>\n\t\t\tif (flags & WF_AFX)\n\t\t\t    putc(np->wn_affixID, fd);\t\t// <affixID>\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if (np->wn_child->wn_u1.index != 0\n\t\t\t\t\t && np->wn_child->wn_u2.wnode != node)\n\t    {\n\t\t// The child is written elsewhere, write the reference.\n\t\tif (fd != NULL)\n\t\t{\n\t\t    putc(BY_INDEX, fd);\t\t\t// <byte>\n\t\t\t\t\t\t\t// <nodeidx>\n\t\t    put_bytes(fd, (long_u)np->wn_child->wn_u1.index, 3);\n\t\t}\n\t    }\n\t    else if (np->wn_child->wn_u2.wnode == NULL)\n\t\t// We will write the child below and give it an index.\n\t\tnp->wn_child->wn_u2.wnode = node;\n\n\t    if (fd != NULL)\n\t\tif (putc(np->wn_byte, fd) == EOF) // <byte> or <xbyte>\n\t\t{\n\t\t    emsg(_(e_error_while_writing));\n\t\t    return 0;\n\t\t}\n\t}\n    }\n\n    // Space used in the array when reading: one for each sibling and one for\n    // the count.\n    newindex += siblingcount + 1;\n\n    // Recursively dump the children of each sibling.\n    FOR_ALL_NODE_SIBLINGS(node, np)\n\tif (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)\n\t    newindex = put_node(fd, np->wn_child, newindex, regionmask,\n\t\t\t\t\t\t\t\t  prefixtree);\n\n    return newindex;\n}\n\n\n/*\n * \":mkspell [-ascii] outfile  infile ...\"\n * \":mkspell [-ascii] addfile\"\n */\n    void\nex_mkspell(exarg_T *eap)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    char_u\t*arg = eap->arg;\n    int\t\tascii = FALSE;\n\n    if (STRNCMP(arg, \"-ascii\", 6) == 0)\n    {\n\tascii = TRUE;\n\targ = skipwhite(arg + 6);\n    }\n\n    // Expand all the remaining arguments (e.g., $VIMRUNTIME).\n    if (get_arglist_exp(arg, &fcount, &fnames, FALSE) == OK)\n    {\n\tmkspell(fcount, fnames, ascii, eap->forceit, FALSE);\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Create the .sug file.\n * Uses the soundfold info in \"spin\".\n * Writes the file with the name \"wfname\", with \".spl\" changed to \".sug\".\n */\n    static void\nspell_make_sugfile(spellinfo_T *spin, char_u *wfname)\n{\n    char_u\t*fname = NULL;\n    int\t\tlen;\n    slang_T\t*slang;\n    int\t\tfree_slang = FALSE;\n\n    /*\n     * Read back the .spl file that was written.  This fills the required\n     * info for soundfolding.  This also uses less memory than the\n     * pointer-linked version of the trie.  And it avoids having two versions\n     * of the code for the soundfolding stuff.\n     * It might have been done already by spell_reload_one().\n     */\n    FOR_ALL_SPELL_LANGS(slang)\n\tif (fullpathcmp(wfname, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t    break;\n    if (slang == NULL)\n    {\n\tspell_message(spin, (char_u *)_(\"Reading back spell file...\"));\n\tslang = spell_load_file(wfname, NULL, NULL, FALSE);\n\tif (slang == NULL)\n\t    return;\n\tfree_slang = TRUE;\n    }\n\n    /*\n     * Clear the info in \"spin\" that is used.\n     */\n    spin->si_blocks = NULL;\n    spin->si_blocks_cnt = 0;\n    spin->si_compress_cnt = 0;\t    // will stay at 0 all the time\n    spin->si_free_count = 0;\n    spin->si_first_free = NULL;\n    spin->si_foldwcount = 0;\n\n    /*\n     * Go through the trie of good words, soundfold each word and add it to\n     * the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));\n    if (sug_filltree(spin, slang) == FAIL)\n\tgoto theend;\n\n    /*\n     * Create the table which links each soundfold word with a list of the\n     * good words it may come from.  Creates buffer \"spin->si_spellbuf\".\n     * This also removes the wordnr from the NUL byte entries to make\n     * compression possible.\n     */\n    if (sug_maketable(spin) == FAIL)\n\tgoto theend;\n\n    smsg(_(\"Number of words after soundfolding: %ld\"),\n\t\t\t\t (long)spin->si_spellbuf->b_ml.ml_line_count);\n\n    /*\n     * Compress the soundfold trie.\n     */\n    spell_message(spin, (char_u *)_(msg_compressing));\n    wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\n    /*\n     * Write the .sug file.\n     * Make the file name by changing \".spl\" to \".sug\".\n     */\n    fname = alloc(MAXPATHL);\n    if (fname == NULL)\n\tgoto theend;\n    vim_strncpy(fname, wfname, MAXPATHL - 1);\n    len = (int)STRLEN(fname);\n    fname[len - 2] = 'u';\n    fname[len - 1] = 'g';\n    sug_write(spin, fname);\n\ntheend:\n    vim_free(fname);\n    if (free_slang)\n\tslang_free(slang);\n    free_blocks(spin->si_blocks);\n    close_spellbuf(spin->si_spellbuf);\n}\n\n/*\n * Build the soundfold trie for language \"slang\".\n */\n    static int\nsug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}\n\n/*\n * Make the table that links each word in the soundfold trie to the words it\n * can be produced from.\n * This is not unlike lines in a file, thus use a memfile to be able to access\n * the table efficiently.\n * Returns FAIL when out of memory.\n */\n    static int\nsug_maketable(spellinfo_T *spin)\n{\n    garray_T\tga;\n    int\t\tres = OK;\n\n    // Allocate a buffer, open a memline for it and create the swap file\n    // (uses a temp file, not a .swp file).\n    spin->si_spellbuf = open_spellbuf();\n    if (spin->si_spellbuf == NULL)\n\treturn FAIL;\n\n    // Use a buffer to store the line info, avoids allocating many small\n    // pieces of memory.\n    ga_init2(&ga, 1, 100);\n\n    // recursively go through the tree\n    if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)\n\tres = FAIL;\n\n    ga_clear(&ga);\n    return res;\n}\n\n/*\n * Fill the table for one node and its children.\n * Returns the wordnr at the start of the node.\n * Returns -1 when out of memory.\n */\n    static int\nsug_filltable(\n    spellinfo_T\t*spin,\n    wordnode_T\t*node,\n    int\t\tstartwordnr,\n    garray_T\t*gap)\t    // place to store line of numbers\n{\n    wordnode_T\t*p, *np;\n    int\t\twordnr = startwordnr;\n    int\t\tnr;\n    int\t\tprev_nr;\n\n    FOR_ALL_NODE_SIBLINGS(node, p)\n    {\n\tif (p->wn_byte == NUL)\n\t{\n\t    gap->ga_len = 0;\n\t    prev_nr = 0;\n\t    for (np = p; np != NULL && np->wn_byte == NUL; np = np->wn_sibling)\n\t    {\n\t\tif (ga_grow(gap, 10) == FAIL)\n\t\t    return -1;\n\n\t\tnr = (np->wn_flags << 16) + (np->wn_region & 0xffff);\n\t\t// Compute the offset from the previous nr and store the\n\t\t// offset in a way that it takes a minimum number of bytes.\n\t\t// It's a bit like utf-8, but without the need to mark\n\t\t// following bytes.\n\t\tnr -= prev_nr;\n\t\tprev_nr += nr;\n\t\tgap->ga_len += offset2bytes(nr,\n\t\t\t\t\t (char_u *)gap->ga_data + gap->ga_len);\n\t    }\n\n\t    // add the NUL byte\n\t    ((char_u *)gap->ga_data)[gap->ga_len++] = NUL;\n\n\t    if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,\n\t\t\t\t     gap->ga_data, gap->ga_len, TRUE) == FAIL)\n\t\treturn -1;\n\t    ++wordnr;\n\n\t    // Remove extra NUL entries, we no longer need them. We don't\n\t    // bother freeing the nodes, they won't be reused anyway.\n\t    while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)\n\t\tp->wn_sibling = p->wn_sibling->wn_sibling;\n\n\t    // Clear the flags on the remaining NUL node, so that compression\n\t    // works a lot better.\n\t    p->wn_flags = 0;\n\t    p->wn_region = 0;\n\t}\n\telse\n\t{\n\t    wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);\n\t    if (wordnr == -1)\n\t\treturn -1;\n\t}\n    }\n    return wordnr;\n}\n\n/*\n * Convert an offset into a minimal number of bytes.\n * Similar to utf_char2byters, but use 8 bits in followup bytes and avoid NUL\n * bytes.\n */\n    static int\noffset2bytes(int nr, char_u *buf)\n{\n    int\t    rem;\n    int\t    b1, b2, b3, b4;\n\n    // Split the number in parts of base 255.  We need to avoid NUL bytes.\n    b1 = nr % 255 + 1;\n    rem = nr / 255;\n    b2 = rem % 255 + 1;\n    rem = rem / 255;\n    b3 = rem % 255 + 1;\n    b4 = rem / 255 + 1;\n\n    if (b4 > 1 || b3 > 0x1f)\t// 4 bytes\n    {\n\tbuf[0] = 0xe0 + b4;\n\tbuf[1] = b3;\n\tbuf[2] = b2;\n\tbuf[3] = b1;\n\treturn 4;\n    }\n    if (b3 > 1 || b2 > 0x3f )\t// 3 bytes\n    {\n\tbuf[0] = 0xc0 + b3;\n\tbuf[1] = b2;\n\tbuf[2] = b1;\n\treturn 3;\n    }\n    if (b2 > 1 || b1 > 0x7f )\t// 2 bytes\n    {\n\tbuf[0] = 0x80 + b2;\n\tbuf[1] = b1;\n\treturn 2;\n    }\n\t\t\t\t// 1 byte\n    buf[0] = b1;\n    return 1;\n}\n\n/*\n * Write the .sug file in \"fname\".\n */\n    static void\nsug_write(spellinfo_T *spin, char_u *fname)\n{\n    FILE\t*fd;\n    wordnode_T\t*tree;\n    int\t\tnodecount;\n    int\t\twcount;\n    char_u\t*line;\n    linenr_T\tlnum;\n    int\t\tlen;\n\n    // Create the file.  Note that an existing file is silently overwritten!\n    fd = mch_fopen((char *)fname, \"w\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t  _(\"Writing suggestion file %s...\"), fname);\n    spell_message(spin, IObuff);\n\n    /*\n     * <SUGHEADER>: <fileID> <versionnr> <timestamp>\n     */\n    if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) // <fileID>\n    {\n\temsg(_(e_error_while_writing));\n\tgoto theend;\n    }\n    putc(VIMSUGVERSION, fd);\t\t\t\t// <versionnr>\n\n    // Write si_sugtime to the file.\n    put_time(fd, spin->si_sugtime);\t\t\t// <timestamp>\n\n    /*\n     * <SUGWORDTREE>\n     */\n    spin->si_memtot = 0;\n    tree = spin->si_foldroot->wn_sibling;\n\n    // Clear the index and wnode fields in the tree.\n    clear_node(tree);\n\n    // Count the number of nodes.  Needed to be able to allocate the\n    // memory when reading the nodes.  Also fills in index for shared\n    // nodes.\n    nodecount = put_node(NULL, tree, 0, 0, FALSE);\n\n    // number of nodes in 4 bytes\n    put_bytes(fd, (long_u)nodecount, 4);\t// <nodecount>\n    spin->si_memtot += nodecount + nodecount * sizeof(int);\n\n    // Write the nodes.\n    (void)put_node(fd, tree, 0, 0, FALSE);\n\n    /*\n     * <SUGTABLE>: <sugwcount> <sugline> ...\n     */\n    wcount = spin->si_spellbuf->b_ml.ml_line_count;\n    put_bytes(fd, (long_u)wcount, 4);\t// <sugwcount>\n\n    for (lnum = 1; lnum <= (linenr_T)wcount; ++lnum)\n    {\n\t// <sugline>: <sugnr> ... NUL\n\tline = ml_get_buf(spin->si_spellbuf, lnum, FALSE);\n\tlen = (int)STRLEN(line) + 1;\n\tif (fwrite(line, (size_t)len, (size_t)1, fd) == 0)\n\t{\n\t    emsg(_(e_error_while_writing));\n\t    goto theend;\n\t}\n\tspin->si_memtot += len;\n    }\n\n    // Write another byte to check for errors.\n    if (putc(0, fd) == EOF)\n\temsg(_(e_error_while_writing));\n\n    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);\n    spell_message(spin, IObuff);\n\ntheend:\n    // close the file\n    fclose(fd);\n}\n\n\n/*\n * Create a Vim spell file from one or more word lists.\n * \"fnames[0]\" is the output file name.\n * \"fnames[fcount - 1]\" is the last input file name.\n * Exception: when \"fnames[0]\" ends in \".add\" it's used as the input file name\n * and \".spl\" is appended to make the output file name.\n */\n    void\nmkspell(\n    int\t\tfcount,\n    char_u\t**fnames,\n    int\t\tascii,\t\t    // -ascii argument given\n    int\t\tover_write,\t    // overwrite existing output file\n    int\t\tadded_word)\t    // invoked through \"zg\"\n{\n    char_u\t*fname = NULL;\n    char_u\t*wfname;\n    char_u\t**innames;\n    int\t\tincount;\n    afffile_T\t*(afile[MAXREGIONS]);\n    int\t\ti;\n    int\t\tlen;\n    stat_T\tst;\n    int\t\terror = FALSE;\n    spellinfo_T spin;\n\n    CLEAR_FIELD(spin);\n    spin.si_verbose = !added_word;\n    spin.si_ascii = ascii;\n    spin.si_followup = TRUE;\n    spin.si_rem_accents = TRUE;\n    ga_init2(&spin.si_rep, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_repsal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_sal, sizeof(fromto_T), 20);\n    ga_init2(&spin.si_map, sizeof(char_u), 100);\n    ga_init2(&spin.si_comppat, sizeof(char_u *), 20);\n    ga_init2(&spin.si_prefcond, sizeof(char_u *), 50);\n    hash_init(&spin.si_commonwords);\n    spin.si_newcompID = 127;\t// start compound ID at first maximum\n\n    // default: fnames[0] is output file, following are input files\n    // When \"fcount\" is 1 there is only one file.\n    innames = &fnames[fcount == 1 ? 0 : 1];\n    incount = fcount - 1;\n\n    wfname = alloc(MAXPATHL);\n    if (wfname == NULL)\n\treturn;\n\n    if (fcount >= 1)\n    {\n\tlen = (int)STRLEN(fnames[0]);\n\tif (fcount == 1 && len > 4 && STRCMP(fnames[0] + len - 4, \".add\") == 0)\n\t{\n\t    // For \":mkspell path/en.latin1.add\" output file is\n\t    // \"path/en.latin1.add.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, \"%s.spl\", fnames[0]);\n\t}\n\telse if (fcount == 1)\n\t{\n\t    // For \":mkspell path/vim\" output file is \"path/vim.latin1.spl\".\n\t    incount = 1;\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\t}\n\telse if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)\n\t{\n\t    // Name ends in \".spl\", use as the file name.\n\t    vim_strncpy(wfname, fnames[0], MAXPATHL - 1);\n\t}\n\telse\n\t    // Name should be language, make the file name from it.\n\t    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t  fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\n\t// Check for .ascii.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)\n\t    spin.si_ascii = TRUE;\n\n\t// Check for .add.spl.\n\tif (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)\n\t    spin.si_add = TRUE;\n    }\n\n    if (incount <= 0)\n\temsg(_(e_invalid_argument));\t// need at least output and input names\n    else if (vim_strchr(gettail(wfname), '_') != NULL)\n\temsg(_(e_output_file_name_must_not_have_region_name));\n    else if (incount > MAXREGIONS)\n\tsemsg(_(e_only_up_to_nr_regions_supported), MAXREGIONS);\n    else\n    {\n\t// Check for overwriting before doing things that may take a lot of\n\t// time.\n\tif (!over_write && mch_stat((char *)wfname, &st) >= 0)\n\t{\n\t    emsg(_(e_file_exists));\n\t    goto theend;\n\t}\n\tif (mch_isdir(wfname))\n\t{\n\t    semsg(_(e_str_is_directory), wfname);\n\t    goto theend;\n\t}\n\n\tfname = alloc(MAXPATHL);\n\tif (fname == NULL)\n\t    goto theend;\n\n\t/*\n\t * Init the aff and dic pointers.\n\t * Get the region names if there are more than 2 arguments.\n\t */\n\tfor (i = 0; i < incount; ++i)\n\t{\n\t    afile[i] = NULL;\n\n\t    if (incount > 1)\n\t    {\n\t\tlen = (int)STRLEN(innames[i]);\n\t\tif (STRLEN(gettail(innames[i])) < 5\n\t\t\t\t\t\t|| innames[i][len - 3] != '_')\n\t\t{\n\t\t    semsg(_(e_invalid_region_in_str), innames[i]);\n\t\t    goto theend;\n\t\t}\n\t\tspin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);\n\t\tspin.si_region_name[i * 2 + 1] =\n\t\t\t\t\t     TOLOWER_ASC(innames[i][len - 1]);\n\t    }\n\t}\n\tspin.si_region_count = incount;\n\n\tspin.si_foldroot = wordtree_alloc(&spin);\n\tspin.si_keeproot = wordtree_alloc(&spin);\n\tspin.si_prefroot = wordtree_alloc(&spin);\n\tif (spin.si_foldroot == NULL\n\t\t|| spin.si_keeproot == NULL\n\t\t|| spin.si_prefroot == NULL)\n\t{\n\t    free_blocks(spin.si_blocks);\n\t    goto theend;\n\t}\n\n\t// When not producing a .add.spl file clear the character table when\n\t// we encounter one in the .aff file.  This means we dump the current\n\t// one in the .spl file if the .aff file doesn't define one.  That's\n\t// better than guessing the contents, the table will match a\n\t// previously loaded spell file.\n\tif (!spin.si_add)\n\t    spin.si_clear_chartab = TRUE;\n\n\t/*\n\t * Read all the .aff and .dic files.\n\t * Text is converted to 'encoding'.\n\t * Words are stored in the case-folded and keep-case trees.\n\t */\n\tfor (i = 0; i < incount && !error; ++i)\n\t{\n\t    spin.si_conv.vc_type = CONV_NONE;\n\t    spin.si_region = 1 << i;\n\n\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.aff\", innames[i]);\n\t    if (mch_stat((char *)fname, &st) >= 0)\n\t    {\n\t\t// Read the .aff file.  Will init \"spin->si_conv\" based on the\n\t\t// \"SET\" line.\n\t\tafile[i] = spell_read_aff(&spin, fname);\n\t\tif (afile[i] == NULL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // Read the .dic file and store the words in the trees.\n\t\t    vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",\n\t\t\t\t\t\t\t\t  innames[i]);\n\t\t    if (spell_read_dic(&spin, fname, afile[i]) == FAIL)\n\t\t\terror = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// No .aff file, try reading the file as a word list.  Store\n\t\t// the words in the trees.\n\t\tif (spell_read_wordfile(&spin, innames[i]) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\n\t    // Free any conversion stuff.\n\t    convert_setup(&spin.si_conv, NULL, NULL);\n\t}\n\n\tif (spin.si_compflags != NULL && spin.si_nobreak)\n\t    msg(_(\"Warning: both compounding and NOBREAK specified\"));\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Combine tails in the tree.\n\t     */\n\t    spell_message(&spin, (char_u *)_(msg_compressing));\n\t    wordtree_compress(&spin, spin.si_foldroot, \"case-folded\");\n\t    wordtree_compress(&spin, spin.si_keeproot, \"keep-case\");\n\t    wordtree_compress(&spin, spin.si_prefroot, \"prefixes\");\n\t}\n\n\tif (!error && !got_int)\n\t{\n\t    /*\n\t     * Write the info in the spell file.\n\t     */\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t      _(\"Writing spell file %s...\"), wfname);\n\t    spell_message(&spin, IObuff);\n\n\t    error = write_vim_spell(&spin, wfname) == FAIL;\n\n\t    spell_message(&spin, (char_u *)_(\"Done!\"));\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);\n\t    spell_message(&spin, IObuff);\n\n\t    /*\n\t     * If the file is loaded need to reload it.\n\t     */\n\t    if (!error)\n\t\tspell_reload_one(wfname, added_word);\n\t}\n\n\t// Free the allocated memory.\n\tga_clear(&spin.si_rep);\n\tga_clear(&spin.si_repsal);\n\tga_clear(&spin.si_sal);\n\tga_clear(&spin.si_map);\n\tga_clear(&spin.si_comppat);\n\tga_clear(&spin.si_prefcond);\n\thash_clear_all(&spin.si_commonwords, 0);\n\n\t// Free the .aff file structures.\n\tfor (i = 0; i < incount; ++i)\n\t    if (afile[i] != NULL)\n\t\tspell_free_aff(afile[i]);\n\n\t// Free all the bits and pieces at once.\n\tfree_blocks(spin.si_blocks);\n\n\t/*\n\t * If there is soundfolding info and no NOSUGFILE item create the\n\t * .sug file with the soundfolded word trie.\n\t */\n\tif (spin.si_sugtime != 0 && !error && !got_int)\n\t    spell_make_sugfile(&spin, wfname);\n\n    }\n\ntheend:\n    vim_free(fname);\n    vim_free(wfname);\n}\n\n/*\n * Display a message for spell file processing when 'verbose' is set or using\n * \":mkspell\".  \"str\" can be IObuff.\n */\n    static void\nspell_message(spellinfo_T *spin, char_u *str)\n{\n    if (spin->si_verbose || p_verbose > 2)\n    {\n\tif (!spin->si_verbose)\n\t    verbose_enter();\n\tmsg((char *)str);\n\tout_flush();\n\tif (!spin->si_verbose)\n\t    verbose_leave();\n    }\n}\n\n/*\n * \":[count]spellgood  {word}\"\n * \":[count]spellwrong {word}\"\n * \":[count]spellundo  {word}\"\n * \":[count]spellrare  {word}\"\n */\n    void\nex_spell(exarg_T *eap)\n{\n    spell_add_word(eap->arg, (int)STRLEN(eap->arg),\n\t\teap->cmdidx == CMD_spellwrong ? SPELL_ADD_BAD :\n\t\teap->cmdidx == CMD_spellrare ? SPELL_ADD_RARE : SPELL_ADD_GOOD,\n\t\t\t\t   eap->forceit ? 0 : (int)eap->line2,\n\t\t\t\t   eap->cmdidx == CMD_spellundo);\n}\n\n/*\n * Add \"word[len]\" to 'spellfile' as a good, rare or bad word.\n */\n    void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (!valid_spell_word(word))\n    {\n\temsg(_(e_illegal_character_in_word));\n\treturn;\n    }\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}\n\n/*\n * Initialize 'spellfile' for the current buffer.\n */\n    static void\ninit_spellfile(void)\n{\n    char_u\t*buf;\n    int\t\tl;\n    char_u\t*fname;\n    char_u\t*rtp;\n    char_u\t*lend;\n    int\t\taspath = FALSE;\n    char_u\t*lstart = curbuf->b_s.b_p_spl;\n\n    if (*curwin->w_s->b_p_spl != NUL && curwin->w_s->b_langp.ga_len > 0)\n    {\n\tbuf = alloc(MAXPATHL);\n\tif (buf == NULL)\n\t    return;\n\n\t// Find the end of the language name.  Exclude the region.  If there\n\t// is a path separator remember the start of the tail.\n\tfor (lend = curwin->w_s->b_p_spl; *lend != NUL\n\t\t\t&& vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)\n\t    if (vim_ispathsep(*lend))\n\t    {\n\t\taspath = TRUE;\n\t\tlstart = lend + 1;\n\t    }\n\n\t// Loop over all entries in 'runtimepath'.  Use the first one where we\n\t// are allowed to write.\n\trtp = p_rtp;\n\twhile (*rtp != NUL)\n\t{\n\t    if (aspath)\n\t\t// Use directory of an entry with path, e.g., for\n\t\t// \"/dir/lg.utf-8.spl\" use \"/dir\".\n\t\tvim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t    lstart - curbuf->b_s.b_p_spl - 1);\n\t    else\n\t\t// Copy the path from 'runtimepath' to buf[].\n\t\tcopy_option_part(&rtp, buf, MAXPATHL, \",\");\n\t    if (filewritable(buf) == 2)\n\t    {\n\t\t// Use the first language name from 'spelllang' and the\n\t\t// encoding used in the first loaded .spl file.\n\t\tif (aspath)\n\t\t    vim_strncpy(buf, curbuf->b_s.b_p_spl,\n\t\t\t\t\t\t  lend - curbuf->b_s.b_p_spl);\n\t\telse\n\t\t{\n\t\t    // Create the \"spell\" directory if it doesn't exist yet.\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l, \"/spell\");\n\t\t    if (filewritable(buf) != 2)\n\t\t\tvim_mkdir(buf, 0755);\n\n\t\t    l = (int)STRLEN(buf);\n\t\t    vim_snprintf((char *)buf + l, MAXPATHL - l,\n\t\t\t\t \"/%.*s\", (int)(lend - lstart), lstart);\n\t\t}\n\t\tl = (int)STRLEN(buf);\n\t\tfname = LANGP_ENTRY(curwin->w_s->b_langp, 0)\n\t\t\t\t\t\t\t ->lp_slang->sl_fname;\n\t\tvim_snprintf((char *)buf + l, MAXPATHL - l, \".%s.add\",\n\t\t\tfname != NULL\n\t\t\t  && strstr((char *)gettail(fname), \".ascii.\") != NULL\n\t\t\t\t       ? (char_u *)\"ascii\" : spell_enc());\n\t\tset_option_value_give_err((char_u *)\"spellfile\",\n\t\t\t\t\t\t\t   0L, buf, OPT_LOCAL);\n\t\tbreak;\n\t    }\n\t    aspath = FALSE;\n\t}\n\n\tvim_free(buf);\n    }\n}\n\n\n\n/*\n * Set the spell character tables from strings in the affix file.\n */\n    static int\nset_spell_chartab(char_u *fol, char_u *low, char_u *upp)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    char_u\t*pf = fol, *pl = low, *pu = upp;\n    int\t\tf, l, u;\n\n    clear_spell_chartab(&new_st);\n\n    while (*pf != NUL)\n    {\n\tif (*pl == NUL || *pu == NUL)\n\t{\n\t    emsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\t    return FAIL;\n\t}\n\tf = mb_ptr2char_adv(&pf);\n\tl = mb_ptr2char_adv(&pl);\n\tu = mb_ptr2char_adv(&pu);\n\n\t// Every character that appears is a word character.\n\tif (f < 256)\n\t    new_st.st_isw[f] = TRUE;\n\tif (l < 256)\n\t    new_st.st_isw[l] = TRUE;\n\tif (u < 256)\n\t    new_st.st_isw[u] = TRUE;\n\n\t// if \"LOW\" and \"FOL\" are not the same the \"LOW\" char needs\n\t// case-folding\n\tif (l < 256 && l != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[l] = f;\n\t}\n\n\t// if \"UPP\" and \"FOL\" are not the same the \"UPP\" char needs\n\t// case-folding, it's upper case and the \"UPP\" is the upper case of\n\t// \"FOL\" .\n\tif (u < 256 && u != f)\n\t{\n\t    if (f >= 256)\n\t    {\n\t\temsg(_(e_character_in_fol_low_or_upp_is_out_of_range));\n\t\treturn FAIL;\n\t    }\n\t    new_st.st_fold[u] = f;\n\t    new_st.st_isu[u] = TRUE;\n\t    new_st.st_upper[f] = u;\n\t}\n    }\n\n    if (*pl != NUL || *pu != NUL)\n    {\n\temsg(_(e_format_error_in_affix_file_fol_low_or_upp));\n\treturn FAIL;\n    }\n\n    return set_spell_finish(&new_st);\n}\n\n/*\n * Set the spell character tables from strings in the .spl file.\n */\n    static void\nset_spell_charflags(\n    char_u\t*flags,\n    int\t\tcnt,\t    // length of \"flags\"\n    char_u\t*fol)\n{\n    // We build the new tables here first, so that we can compare with the\n    // previous one.\n    spelltab_T\tnew_st;\n    int\t\ti;\n    char_u\t*p = fol;\n    int\t\tc;\n\n    clear_spell_chartab(&new_st);\n\n    for (i = 0; i < 128; ++i)\n    {\n\tif (i < cnt)\n\t{\n\t    new_st.st_isw[i + 128] = (flags[i] & CF_WORD) != 0;\n\t    new_st.st_isu[i + 128] = (flags[i] & CF_UPPER) != 0;\n\t}\n\n\tif (*p != NUL)\n\t{\n\t    c = mb_ptr2char_adv(&p);\n\t    new_st.st_fold[i + 128] = c;\n\t    if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)\n\t\tnew_st.st_upper[c] = i + 128;\n\t}\n    }\n\n    (void)set_spell_finish(&new_st);\n}\n\n    static int\nset_spell_finish(spelltab_T *new_st)\n{\n    int\t\ti;\n\n    if (did_set_spelltab)\n    {\n\t// check that it's the same table\n\tfor (i = 0; i < 256; ++i)\n\t{\n\t    if (spelltab.st_isw[i] != new_st->st_isw[i]\n\t\t    || spelltab.st_isu[i] != new_st->st_isu[i]\n\t\t    || spelltab.st_fold[i] != new_st->st_fold[i]\n\t\t    || spelltab.st_upper[i] != new_st->st_upper[i])\n\t    {\n\t\temsg(_(e_word_characters_differ_between_spell_files));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// copy the new spelltab into the one being used\n\tspelltab = *new_st;\n\tdid_set_spelltab = TRUE;\n    }\n\n    return OK;\n}\n\n/*\n * Write the table with prefix conditions to the .spl file.\n * When \"fd\" is NULL only count the length of what is written and return it.\n */\n    static int\nwrite_spell_prefcond(FILE *fd, garray_T *gap, size_t *fwv)\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ttotlen;\n\n    if (fd != NULL)\n\tput_bytes(fd, (long_u)gap->ga_len, 2);\t    // <prefcondcnt>\n\n    totlen = 2 + gap->ga_len; // length of <prefcondcnt> and <condlen> bytes\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\t// <prefcond> : <condlen> <condstr>\n\tp = ((char_u **)gap->ga_data)[i];\n\tif (p != NULL)\n\t{\n\t    len = (int)STRLEN(p);\n\t    if (fd != NULL)\n\t    {\n\t\tfputc(len, fd);\n\t\t*fwv &= fwrite(p, (size_t)len, (size_t)1, fd);\n\t    }\n\t    totlen += len;\n\t}\n\telse if (fd != NULL)\n\t    fputc(0, fd);\n    }\n\n    return totlen;\n}\n\n/*\n * Use map string \"map\" for languages \"lp\".\n */\n    static void\nset_map_str(slang_T *lp, char_u *map)\n{\n    char_u\t*p;\n    int\t\theadc = 0;\n    int\t\tc;\n    int\t\ti;\n\n    if (*map == NUL)\n    {\n\tlp->sl_has_map = FALSE;\n\treturn;\n    }\n    lp->sl_has_map = TRUE;\n\n    // Init the array and hash tables empty.\n    for (i = 0; i < 256; ++i)\n\tlp->sl_map_array[i] = 0;\n    hash_init(&lp->sl_map_hash);\n\n    /*\n     * The similar characters are stored separated with slashes:\n     * \"aaa/bbb/ccc/\".  Fill sl_map_array[c] with the character before c and\n     * before the same slash.  For characters above 255 sl_map_hash is used.\n     */\n    for (p = map; *p != NUL; )\n    {\n\tc = mb_cptr2char_adv(&p);\n\tif (c == '/')\n\t    headc = 0;\n\telse\n\t{\n\t    if (headc == 0)\n\t\t headc = c;\n\n\t    // Characters above 255 don't fit in sl_map_array[], put them in\n\t    // the hash table.  Each entry is the char, a NUL the headchar and\n\t    // a NUL.\n\t    if (c >= 256)\n\t    {\n\t\tint\t    cl = mb_char2len(c);\n\t\tint\t    headcl = mb_char2len(headc);\n\t\tchar_u\t    *b;\n\t\thash_T\t    hash;\n\t\thashitem_T  *hi;\n\n\t\tb = alloc(cl + headcl + 2);\n\t\tif (b == NULL)\n\t\t    return;\n\t\tmb_char2bytes(c, b);\n\t\tb[cl] = NUL;\n\t\tmb_char2bytes(headc, b + cl + 1);\n\t\tb[cl + 1 + headcl] = NUL;\n\t\thash = hash_hash(b);\n\t\thi = hash_lookup(&lp->sl_map_hash, b, hash);\n\t\tif (HASHITEM_EMPTY(hi))\n\t\t    hash_add_item(&lp->sl_map_hash, hi, b, hash);\n\t\telse\n\t\t{\n\t\t    // This should have been checked when generating the .spl\n\t\t    // file.\n\t\t    emsg(_(e_duplicate_char_in_map_entry));\n\t\t    vim_free(b);\n\t\t}\n\t    }\n\t    else\n\t\tlp->sl_map_array[c] = headc;\n\t}\n    }\n}\n\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E797:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_invalid()\n  \" This was adding a word with a 0x02 byte, which causes havoc.\n  enew\n  norm o0\n  sil! norm rzzWs00\u0002/\n  2\n  sil! norm VzGprzzW\n  sil! norm z=\n\n  bwipe!\n  \" clear the internal word list\n  set enc=latin1\n  set enc=utf-8\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestSpell')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/spellfile.c", "src/testdir/test_spell.vim", "src/version.c"], "buggy_code_start_loc": [4369, 854, 737], "buggy_code_end_loc": [6198, 854, 737], "fixing_code_start_loc": [4370, 855, 738], "fixing_code_end_loc": [6215, 870, 740], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.", "other": {"cve": {"id": "CVE-2022-2287", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-02T22:15:09.657", "lastModified": "2023-05-03T12:15:54.793", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0."}, {"lang": "es", "value": "Una Lectura Fuera de L\u00edmites en el repositorio GitHub vim/vim versiones anteriores a 9.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0021", "matchCriteriaId": "9FC93F6F-D872-4FBA-972F-84D355278C88"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/5e59ea54c0c37c2f84770f068d95280069828774", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/654aa069-3a9d-45d3-9a52-c1cf3490c284", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/5e59ea54c0c37c2f84770f068d95280069828774"}}