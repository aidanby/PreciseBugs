{"buggy_code": ["/******************************************************************************\n *\n * Back-end of the driver for virtual block devices. This portion of the\n * driver exports a 'unified' block-device interface that can be accessed\n * by any operating system that implements a compatible front end. A\n * reference front-end implementation can be found in:\n *  drivers/block/xen-blkfront.c\n *\n * Copyright (c) 2003-2004, Keir Fraser & Steve Hand\n * Copyright (c) 2005, Christopher Clark\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation; or, when distributed\n * separately from the Linux kernel or incorporated into other\n * software packages, subject to the following license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this source file (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#define pr_fmt(fmt) \"xen-blkback: \" fmt\n\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/bitmap.h>\n\n#include <xen/events.h>\n#include <xen/page.h>\n#include <xen/xen.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n#include <xen/balloon.h>\n#include <xen/grant_table.h>\n#include \"common.h\"\n\n/*\n * Maximum number of unused free pages to keep in the internal buffer.\n * Setting this to a value too low will reduce memory used in each backend,\n * but can have a performance penalty.\n *\n * A sane value is xen_blkif_reqs * BLKIF_MAX_SEGMENTS_PER_REQUEST, but can\n * be set to a lower value that might degrade performance on some intensive\n * IO workloads.\n */\n\nstatic int xen_blkif_max_buffer_pages = 1024;\nmodule_param_named(max_buffer_pages, xen_blkif_max_buffer_pages, int, 0644);\nMODULE_PARM_DESC(max_buffer_pages,\n\"Maximum number of free pages to keep in each block backend buffer\");\n\n/*\n * Maximum number of grants to map persistently in blkback. For maximum\n * performance this should be the total numbers of grants that can be used\n * to fill the ring, but since this might become too high, specially with\n * the use of indirect descriptors, we set it to a value that provides good\n * performance without using too much memory.\n *\n * When the list of persistent grants is full we clean it up using a LRU\n * algorithm.\n */\n\nstatic int xen_blkif_max_pgrants = 1056;\nmodule_param_named(max_persistent_grants, xen_blkif_max_pgrants, int, 0644);\nMODULE_PARM_DESC(max_persistent_grants,\n                 \"Maximum number of grants to map persistently\");\n\n/*\n * Maximum number of rings/queues blkback supports, allow as many queues as there\n * are CPUs if user has not specified a value.\n */\nunsigned int xenblk_max_queues;\nmodule_param_named(max_queues, xenblk_max_queues, uint, 0644);\nMODULE_PARM_DESC(max_queues,\n\t\t \"Maximum number of hardware queues per virtual disk.\" \\\n\t\t \"By default it is the number of online CPUs.\");\n\n/*\n * Maximum order of pages to be used for the shared ring between front and\n * backend, 4KB page granularity is used.\n */\nunsigned int xen_blkif_max_ring_order = XENBUS_MAX_RING_GRANT_ORDER;\nmodule_param_named(max_ring_page_order, xen_blkif_max_ring_order, int, S_IRUGO);\nMODULE_PARM_DESC(max_ring_page_order, \"Maximum order of pages to be used for the shared ring\");\n/*\n * The LRU mechanism to clean the lists of persistent grants needs to\n * be executed periodically. The time interval between consecutive executions\n * of the purge mechanism is set in ms.\n */\n#define LRU_INTERVAL 100\n\n/*\n * When the persistent grants list is full we will remove unused grants\n * from the list. The percent number of grants to be removed at each LRU\n * execution.\n */\n#define LRU_PERCENT_CLEAN 5\n\n/* Run-time switchable: /sys/module/blkback/parameters/ */\nstatic unsigned int log_stats;\nmodule_param(log_stats, int, 0644);\n\n#define BLKBACK_INVALID_HANDLE (~0)\n\n/* Number of free pages to remove on each call to gnttab_free_pages */\n#define NUM_BATCH_FREE_PAGES 10\n\nstatic inline int get_free_page(struct xen_blkif_ring *ring, struct page **page)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\tif (list_empty(&ring->free_pages)) {\n\t\tBUG_ON(ring->free_pages_num != 0);\n\t\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\t\treturn gnttab_alloc_pages(1, page);\n\t}\n\tBUG_ON(ring->free_pages_num == 0);\n\tpage[0] = list_first_entry(&ring->free_pages, struct page, lru);\n\tlist_del(&page[0]->lru);\n\tring->free_pages_num--;\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\n\treturn 0;\n}\n\nstatic inline void put_free_pages(struct xen_blkif_ring *ring, struct page **page,\n                                  int num)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\tfor (i = 0; i < num; i++)\n\t\tlist_add(&page[i]->lru, &ring->free_pages);\n\tring->free_pages_num += num;\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n}\n\nstatic inline void shrink_free_pagepool(struct xen_blkif_ring *ring, int num)\n{\n\t/* Remove requested pages in batches of NUM_BATCH_FREE_PAGES */\n\tstruct page *page[NUM_BATCH_FREE_PAGES];\n\tunsigned int num_pages = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\twhile (ring->free_pages_num > num) {\n\t\tBUG_ON(list_empty(&ring->free_pages));\n\t\tpage[num_pages] = list_first_entry(&ring->free_pages,\n\t\t                                   struct page, lru);\n\t\tlist_del(&page[num_pages]->lru);\n\t\tring->free_pages_num--;\n\t\tif (++num_pages == NUM_BATCH_FREE_PAGES) {\n\t\t\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\t\t\tgnttab_free_pages(num_pages, page);\n\t\t\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\t\t\tnum_pages = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\tif (num_pages != 0)\n\t\tgnttab_free_pages(num_pages, page);\n}\n\n#define vaddr(page) ((unsigned long)pfn_to_kaddr(page_to_pfn(page)))\n\nstatic int do_block_io_op(struct xen_blkif_ring *ring);\nstatic int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req,\n\t\t\t\tstruct pending_req *pending_req);\nstatic void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st);\n\n#define foreach_grant_safe(pos, n, rbtree, node) \\\n\tfor ((pos) = container_of(rb_first((rbtree)), typeof(*(pos)), node), \\\n\t     (n) = (&(pos)->node != NULL) ? rb_next(&(pos)->node) : NULL; \\\n\t     &(pos)->node != NULL; \\\n\t     (pos) = container_of(n, typeof(*(pos)), node), \\\n\t     (n) = (&(pos)->node != NULL) ? rb_next(&(pos)->node) : NULL)\n\n\n/*\n * We don't need locking around the persistent grant helpers\n * because blkback uses a single-thread for each backend, so we\n * can be sure that this functions will never be called recursively.\n *\n * The only exception to that is put_persistent_grant, that can be called\n * from interrupt context (by xen_blkbk_unmap), so we have to use atomic\n * bit operations to modify the flags of a persistent grant and to count\n * the number of used grants.\n */\nstatic int add_persistent_gnt(struct xen_blkif_ring *ring,\n\t\t\t       struct persistent_gnt *persistent_gnt)\n{\n\tstruct rb_node **new = NULL, *parent = NULL;\n\tstruct persistent_gnt *this;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tif (ring->persistent_gnt_c >= xen_blkif_max_pgrants) {\n\t\tif (!blkif->vbd.overflow_max_grants)\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\treturn -EBUSY;\n\t}\n\t/* Figure out where to put new node */\n\tnew = &ring->persistent_gnts.rb_node;\n\twhile (*new) {\n\t\tthis = container_of(*new, struct persistent_gnt, node);\n\n\t\tparent = *new;\n\t\tif (persistent_gnt->gnt < this->gnt)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (persistent_gnt->gnt > this->gnt)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse {\n\t\t\tpr_alert_ratelimited(\"trying to add a gref that's already in the tree\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbitmap_zero(persistent_gnt->flags, PERSISTENT_GNT_FLAGS_SIZE);\n\tset_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&(persistent_gnt->node), parent, new);\n\trb_insert_color(&(persistent_gnt->node), &ring->persistent_gnts);\n\tring->persistent_gnt_c++;\n\tatomic_inc(&ring->persistent_gnt_in_use);\n\treturn 0;\n}\n\nstatic struct persistent_gnt *get_persistent_gnt(struct xen_blkif_ring *ring,\n\t\t\t\t\t\t grant_ref_t gref)\n{\n\tstruct persistent_gnt *data;\n\tstruct rb_node *node = NULL;\n\n\tnode = ring->persistent_gnts.rb_node;\n\twhile (node) {\n\t\tdata = container_of(node, struct persistent_gnt, node);\n\n\t\tif (gref < data->gnt)\n\t\t\tnode = node->rb_left;\n\t\telse if (gref > data->gnt)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tif(test_bit(PERSISTENT_GNT_ACTIVE, data->flags)) {\n\t\t\t\tpr_alert_ratelimited(\"requesting a grant already in use\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tset_bit(PERSISTENT_GNT_ACTIVE, data->flags);\n\t\t\tatomic_inc(&ring->persistent_gnt_in_use);\n\t\t\treturn data;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void put_persistent_gnt(struct xen_blkif_ring *ring,\n                               struct persistent_gnt *persistent_gnt)\n{\n\tif(!test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t\tpr_alert_ratelimited(\"freeing a grant already unused\\n\");\n\tset_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\tclear_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\n\tatomic_dec(&ring->persistent_gnt_in_use);\n}\n\nstatic void free_persistent_gnts(struct xen_blkif_ring *ring, struct rb_root *root,\n                                 unsigned int num)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt;\n\tstruct rb_node *n;\n\tint segs_to_unmap = 0;\n\tstruct gntab_unmap_queue_data unmap_data;\n\n\tunmap_data.pages = pages;\n\tunmap_data.unmap_ops = unmap;\n\tunmap_data.kunmap_ops = NULL;\n\n\tforeach_grant_safe(persistent_gnt, n, root, node) {\n\t\tBUG_ON(persistent_gnt->handle ==\n\t\t\tBLKBACK_INVALID_HANDLE);\n\t\tgnttab_set_unmap_op(&unmap[segs_to_unmap],\n\t\t\t(unsigned long) pfn_to_kaddr(page_to_pfn(\n\t\t\t\tpersistent_gnt->page)),\n\t\t\tGNTMAP_host_map,\n\t\t\tpersistent_gnt->handle);\n\n\t\tpages[segs_to_unmap] = persistent_gnt->page;\n\n\t\tif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST ||\n\t\t\t!rb_next(&persistent_gnt->node)) {\n\n\t\t\tunmap_data.count = segs_to_unmap;\n\t\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\n\t\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t\t\tsegs_to_unmap = 0;\n\t\t}\n\n\t\trb_erase(&persistent_gnt->node, root);\n\t\tkfree(persistent_gnt);\n\t\tnum--;\n\t}\n\tBUG_ON(num != 0);\n}\n\nvoid xen_blkbk_unmap_purged_grants(struct work_struct *work)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt;\n\tint segs_to_unmap = 0;\n\tstruct xen_blkif_ring *ring = container_of(work, typeof(*ring), persistent_purge_work);\n\tstruct gntab_unmap_queue_data unmap_data;\n\n\tunmap_data.pages = pages;\n\tunmap_data.unmap_ops = unmap;\n\tunmap_data.kunmap_ops = NULL;\n\n\twhile(!list_empty(&ring->persistent_purge_list)) {\n\t\tpersistent_gnt = list_first_entry(&ring->persistent_purge_list,\n\t\t                                  struct persistent_gnt,\n\t\t                                  remove_node);\n\t\tlist_del(&persistent_gnt->remove_node);\n\n\t\tgnttab_set_unmap_op(&unmap[segs_to_unmap],\n\t\t\tvaddr(persistent_gnt->page),\n\t\t\tGNTMAP_host_map,\n\t\t\tpersistent_gnt->handle);\n\n\t\tpages[segs_to_unmap] = persistent_gnt->page;\n\n\t\tif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST) {\n\t\t\tunmap_data.count = segs_to_unmap;\n\t\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\t\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t\t\tsegs_to_unmap = 0;\n\t\t}\n\t\tkfree(persistent_gnt);\n\t}\n\tif (segs_to_unmap > 0) {\n\t\tunmap_data.count = segs_to_unmap;\n\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t}\n}\n\nstatic void purge_persistent_gnt(struct xen_blkif_ring *ring)\n{\n\tstruct persistent_gnt *persistent_gnt;\n\tstruct rb_node *n;\n\tunsigned int num_clean, total;\n\tbool scan_used = false, clean_used = false;\n\tstruct rb_root *root;\n\n\tif (ring->persistent_gnt_c < xen_blkif_max_pgrants ||\n\t    (ring->persistent_gnt_c == xen_blkif_max_pgrants &&\n\t    !ring->blkif->vbd.overflow_max_grants)) {\n\t\tgoto out;\n\t}\n\n\tif (work_busy(&ring->persistent_purge_work)) {\n\t\tpr_alert_ratelimited(\"Scheduled work from previous purge is still busy, cannot purge list\\n\");\n\t\tgoto out;\n\t}\n\n\tnum_clean = (xen_blkif_max_pgrants / 100) * LRU_PERCENT_CLEAN;\n\tnum_clean = ring->persistent_gnt_c - xen_blkif_max_pgrants + num_clean;\n\tnum_clean = min(ring->persistent_gnt_c, num_clean);\n\tif ((num_clean == 0) ||\n\t    (num_clean > (ring->persistent_gnt_c - atomic_read(&ring->persistent_gnt_in_use))))\n\t\tgoto out;\n\n\t/*\n\t * At this point, we can assure that there will be no calls\n         * to get_persistent_grant (because we are executing this code from\n         * xen_blkif_schedule), there can only be calls to put_persistent_gnt,\n         * which means that the number of currently used grants will go down,\n         * but never up, so we will always be able to remove the requested\n         * number of grants.\n\t */\n\n\ttotal = num_clean;\n\n\tpr_debug(\"Going to purge %u persistent grants\\n\", num_clean);\n\n\tBUG_ON(!list_empty(&ring->persistent_purge_list));\n\troot = &ring->persistent_gnts;\npurge_list:\n\tforeach_grant_safe(persistent_gnt, n, root, node) {\n\t\tBUG_ON(persistent_gnt->handle ==\n\t\t\tBLKBACK_INVALID_HANDLE);\n\n\t\tif (clean_used) {\n\t\t\tclear_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t\t\tcontinue;\n\t\tif (!scan_used &&\n\t\t    (test_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags)))\n\t\t\tcontinue;\n\n\t\trb_erase(&persistent_gnt->node, root);\n\t\tlist_add(&persistent_gnt->remove_node,\n\t\t\t &ring->persistent_purge_list);\n\t\tif (--num_clean == 0)\n\t\t\tgoto finished;\n\t}\n\t/*\n\t * If we get here it means we also need to start cleaning\n\t * grants that were used since last purge in order to cope\n\t * with the requested num\n\t */\n\tif (!scan_used && !clean_used) {\n\t\tpr_debug(\"Still missing %u purged frames\\n\", num_clean);\n\t\tscan_used = true;\n\t\tgoto purge_list;\n\t}\nfinished:\n\tif (!clean_used) {\n\t\tpr_debug(\"Finished scanning for grants to clean, removing used flag\\n\");\n\t\tclean_used = true;\n\t\tgoto purge_list;\n\t}\n\n\tring->persistent_gnt_c -= (total - num_clean);\n\tring->blkif->vbd.overflow_max_grants = 0;\n\n\t/* We can defer this work */\n\tschedule_work(&ring->persistent_purge_work);\n\tpr_debug(\"Purged %u/%u\\n\", (total - num_clean), total);\n\nout:\n\treturn;\n}\n\n/*\n * Retrieve from the 'pending_reqs' a free pending_req structure to be used.\n */\nstatic struct pending_req *alloc_req(struct xen_blkif_ring *ring)\n{\n\tstruct pending_req *req = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->pending_free_lock, flags);\n\tif (!list_empty(&ring->pending_free)) {\n\t\treq = list_entry(ring->pending_free.next, struct pending_req,\n\t\t\t\t free_list);\n\t\tlist_del(&req->free_list);\n\t}\n\tspin_unlock_irqrestore(&ring->pending_free_lock, flags);\n\treturn req;\n}\n\n/*\n * Return the 'pending_req' structure back to the freepool. We also\n * wake up the thread if it was waiting for a free page.\n */\nstatic void free_req(struct xen_blkif_ring *ring, struct pending_req *req)\n{\n\tunsigned long flags;\n\tint was_empty;\n\n\tspin_lock_irqsave(&ring->pending_free_lock, flags);\n\twas_empty = list_empty(&ring->pending_free);\n\tlist_add(&req->free_list, &ring->pending_free);\n\tspin_unlock_irqrestore(&ring->pending_free_lock, flags);\n\tif (was_empty)\n\t\twake_up(&ring->pending_free_wq);\n}\n\n/*\n * Routines for managing virtual block devices (vbds).\n */\nstatic int xen_vbd_translate(struct phys_req *req, struct xen_blkif *blkif,\n\t\t\t     int operation)\n{\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tint rc = -EACCES;\n\n\tif ((operation != REQ_OP_READ) && vbd->readonly)\n\t\tgoto out;\n\n\tif (likely(req->nr_sects)) {\n\t\tblkif_sector_t end = req->sector_number + req->nr_sects;\n\n\t\tif (unlikely(end < req->sector_number))\n\t\t\tgoto out;\n\t\tif (unlikely(end > vbd_sz(vbd)))\n\t\t\tgoto out;\n\t}\n\n\treq->dev  = vbd->pdevice;\n\treq->bdev = vbd->bdev;\n\trc = 0;\n\n out:\n\treturn rc;\n}\n\nstatic void xen_vbd_resize(struct xen_blkif *blkif)\n{\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tstruct xenbus_device *dev = xen_blkbk_xenbus(blkif->be);\n\tunsigned long long new_size = vbd_sz(vbd);\n\n\tpr_info(\"VBD Resize: Domid: %d, Device: (%d, %d)\\n\",\n\t\tblkif->domid, MAJOR(vbd->pdevice), MINOR(vbd->pdevice));\n\tpr_info(\"VBD Resize: new size %llu\\n\", new_size);\n\tvbd->size = new_size;\nagain:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err) {\n\t\tpr_warn(\"Error starting transaction\\n\");\n\t\treturn;\n\t}\n\terr = xenbus_printf(xbt, dev->nodename, \"sectors\", \"%llu\",\n\t\t\t    (unsigned long long)vbd_sz(vbd));\n\tif (err) {\n\t\tpr_warn(\"Error writing new size\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * Write the current state; we will use this to synchronize\n\t * the front-end. If the current state is \"connected\" the\n\t * front-end will get the new size information online.\n\t */\n\terr = xenbus_printf(xbt, dev->nodename, \"state\", \"%d\", dev->state);\n\tif (err) {\n\t\tpr_warn(\"Error writing the state\\n\");\n\t\tgoto abort;\n\t}\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\tif (err)\n\t\tpr_warn(\"Error ending transaction\\n\");\n\treturn;\nabort:\n\txenbus_transaction_end(xbt, 1);\n}\n\n/*\n * Notification from the guest OS.\n */\nstatic void blkif_notify_work(struct xen_blkif_ring *ring)\n{\n\tring->waiting_reqs = 1;\n\twake_up(&ring->wq);\n}\n\nirqreturn_t xen_blkif_be_int(int irq, void *dev_id)\n{\n\tblkif_notify_work(dev_id);\n\treturn IRQ_HANDLED;\n}\n\n/*\n * SCHEDULER FUNCTIONS\n */\n\nstatic void print_stats(struct xen_blkif_ring *ring)\n{\n\tpr_info(\"(%s): oo %3llu  |  rd %4llu  |  wr %4llu  |  f %4llu\"\n\t\t \"  |  ds %4llu | pg: %4u/%4d\\n\",\n\t\t current->comm, ring->st_oo_req,\n\t\t ring->st_rd_req, ring->st_wr_req,\n\t\t ring->st_f_req, ring->st_ds_req,\n\t\t ring->persistent_gnt_c,\n\t\t xen_blkif_max_pgrants);\n\tring->st_print = jiffies + msecs_to_jiffies(10 * 1000);\n\tring->st_rd_req = 0;\n\tring->st_wr_req = 0;\n\tring->st_oo_req = 0;\n\tring->st_ds_req = 0;\n}\n\nint xen_blkif_schedule(void *arg)\n{\n\tstruct xen_blkif_ring *ring = arg;\n\tstruct xen_blkif *blkif = ring->blkif;\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tunsigned long timeout;\n\tint ret;\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (unlikely(vbd->size != vbd_sz(vbd)))\n\t\t\txen_vbd_resize(blkif);\n\n\t\ttimeout = msecs_to_jiffies(LRU_INTERVAL);\n\n\t\ttimeout = wait_event_interruptible_timeout(\n\t\t\tring->wq,\n\t\t\tring->waiting_reqs || kthread_should_stop(),\n\t\t\ttimeout);\n\t\tif (timeout == 0)\n\t\t\tgoto purge_gnt_list;\n\t\ttimeout = wait_event_interruptible_timeout(\n\t\t\tring->pending_free_wq,\n\t\t\t!list_empty(&ring->pending_free) ||\n\t\t\tkthread_should_stop(),\n\t\t\ttimeout);\n\t\tif (timeout == 0)\n\t\t\tgoto purge_gnt_list;\n\n\t\tring->waiting_reqs = 0;\n\t\tsmp_mb(); /* clear flag *before* checking for work */\n\n\t\tret = do_block_io_op(ring);\n\t\tif (ret > 0)\n\t\t\tring->waiting_reqs = 1;\n\t\tif (ret == -EACCES)\n\t\t\twait_event_interruptible(ring->shutdown_wq,\n\t\t\t\t\t\t kthread_should_stop());\n\npurge_gnt_list:\n\t\tif (blkif->vbd.feature_gnt_persistent &&\n\t\t    time_after(jiffies, ring->next_lru)) {\n\t\t\tpurge_persistent_gnt(ring);\n\t\t\tring->next_lru = jiffies + msecs_to_jiffies(LRU_INTERVAL);\n\t\t}\n\n\t\t/* Shrink if we have more than xen_blkif_max_buffer_pages */\n\t\tshrink_free_pagepool(ring, xen_blkif_max_buffer_pages);\n\n\t\tif (log_stats && time_after(jiffies, ring->st_print))\n\t\t\tprint_stats(ring);\n\t}\n\n\t/* Drain pending purge work */\n\tflush_work(&ring->persistent_purge_work);\n\n\tif (log_stats)\n\t\tprint_stats(ring);\n\n\tring->xenblkd = NULL;\n\n\treturn 0;\n}\n\n/*\n * Remove persistent grants and empty the pool of free pages\n */\nvoid xen_blkbk_free_caches(struct xen_blkif_ring *ring)\n{\n\t/* Free all persistent grant pages */\n\tif (!RB_EMPTY_ROOT(&ring->persistent_gnts))\n\t\tfree_persistent_gnts(ring, &ring->persistent_gnts,\n\t\t\tring->persistent_gnt_c);\n\n\tBUG_ON(!RB_EMPTY_ROOT(&ring->persistent_gnts));\n\tring->persistent_gnt_c = 0;\n\n\t/* Since we are shutting down remove all pages from the buffer */\n\tshrink_free_pagepool(ring, 0 /* All */);\n}\n\nstatic unsigned int xen_blkbk_unmap_prepare(\n\tstruct xen_blkif_ring *ring,\n\tstruct grant_page **pages,\n\tunsigned int num,\n\tstruct gnttab_unmap_grant_ref *unmap_ops,\n\tstruct page **unmap_pages)\n{\n\tunsigned int i, invcount = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (pages[i]->persistent_gnt != NULL) {\n\t\t\tput_persistent_gnt(ring, pages[i]->persistent_gnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pages[i]->handle == BLKBACK_INVALID_HANDLE)\n\t\t\tcontinue;\n\t\tunmap_pages[invcount] = pages[i]->page;\n\t\tgnttab_set_unmap_op(&unmap_ops[invcount], vaddr(pages[i]->page),\n\t\t\t\t    GNTMAP_host_map, pages[i]->handle);\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\t\tinvcount++;\n       }\n\n       return invcount;\n}\n\nstatic void xen_blkbk_unmap_and_respond_callback(int result, struct gntab_unmap_queue_data *data)\n{\n\tstruct pending_req *pending_req = (struct pending_req *)(data->data);\n\tstruct xen_blkif_ring *ring = pending_req->ring;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\t/* BUG_ON used to reproduce existing behaviour,\n\t   but is this the best way to deal with this? */\n\tBUG_ON(result);\n\n\tput_free_pages(ring, data->pages, data->count);\n\tmake_response(ring, pending_req->id,\n\t\t      pending_req->operation, pending_req->status);\n\tfree_req(ring, pending_req);\n\t/*\n\t * Make sure the request is freed before releasing blkif,\n\t * or there could be a race between free_req and the\n\t * cleanup done in xen_blkif_free during shutdown.\n\t *\n\t * NB: The fact that we might try to wake up pending_free_wq\n\t * before drain_complete (in case there's a drain going on)\n\t * it's not a problem with our current implementation\n\t * because we can assure there's no thread waiting on\n\t * pending_free_wq if there's a drain going on, but it has\n\t * to be taken into account if the current model is changed.\n\t */\n\tif (atomic_dec_and_test(&ring->inflight) && atomic_read(&blkif->drain)) {\n\t\tcomplete(&blkif->drain_complete);\n\t}\n\txen_blkif_put(blkif);\n}\n\nstatic void xen_blkbk_unmap_and_respond(struct pending_req *req)\n{\n\tstruct gntab_unmap_queue_data* work = &req->gnttab_unmap_data;\n\tstruct xen_blkif_ring *ring = req->ring;\n\tstruct grant_page **pages = req->segments;\n\tunsigned int invcount;\n\n\tinvcount = xen_blkbk_unmap_prepare(ring, pages, req->nr_segs,\n\t\t\t\t\t   req->unmap, req->unmap_pages);\n\n\twork->data = req;\n\twork->done = xen_blkbk_unmap_and_respond_callback;\n\twork->unmap_ops = req->unmap;\n\twork->kunmap_ops = NULL;\n\twork->pages = req->unmap_pages;\n\twork->count = invcount;\n\n\tgnttab_unmap_refs_async(&req->gnttab_unmap_data);\n}\n\n\n/*\n * Unmap the grant references.\n *\n * This could accumulate ops up to the batch size to reduce the number\n * of hypercalls, but since this is only used in error paths there's\n * no real need.\n */\nstatic void xen_blkbk_unmap(struct xen_blkif_ring *ring,\n                            struct grant_page *pages[],\n                            int num)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *unmap_pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tunsigned int invcount = 0;\n\tint ret;\n\n\twhile (num) {\n\t\tunsigned int batch = min(num, BLKIF_MAX_SEGMENTS_PER_REQUEST);\n\n\t\tinvcount = xen_blkbk_unmap_prepare(ring, pages, batch,\n\t\t\t\t\t\t   unmap, unmap_pages);\n\t\tif (invcount) {\n\t\t\tret = gnttab_unmap_refs(unmap, NULL, unmap_pages, invcount);\n\t\t\tBUG_ON(ret);\n\t\t\tput_free_pages(ring, unmap_pages, invcount);\n\t\t}\n\t\tpages += batch;\n\t\tnum -= batch;\n\t}\n}\n\nstatic int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (get_free_page(ring, &pages[i]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map) {\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\t\tBUG_ON(ret);\n\t}\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tput_free_pages(ring, &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= 1;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < xen_blkif_max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t xen_blkif_max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (map_until != num)\n\t\tgoto again;\n\n\treturn ret;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", __func__);\n\tput_free_pages(ring, pages_to_gnt, segs_to_map);\n\treturn -ENOMEM;\n}\n\nstatic int xen_blkbk_map_seg(struct pending_req *pending_req)\n{\n\tint rc;\n\n\trc = xen_blkbk_map(pending_req->ring, pending_req->segments,\n\t\t\t   pending_req->nr_segs,\n\t                   (pending_req->operation != BLKIF_OP_READ));\n\n\treturn rc;\n}\n\nstatic int xen_blkbk_parse_indirect(struct blkif_request *req,\n\t\t\t\t    struct pending_req *pending_req,\n\t\t\t\t    struct seg_buf seg[],\n\t\t\t\t    struct phys_req *preq)\n{\n\tstruct grant_page **pages = pending_req->indirect_pages;\n\tstruct xen_blkif_ring *ring = pending_req->ring;\n\tint indirect_grefs, rc, n, nseg, i;\n\tstruct blkif_request_segment *segments = NULL;\n\n\tnseg = pending_req->nr_segs;\n\tindirect_grefs = INDIRECT_PAGES(nseg);\n\tBUG_ON(indirect_grefs > BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST);\n\n\tfor (i = 0; i < indirect_grefs; i++)\n\t\tpages[i]->gref = req->u.indirect.indirect_grefs[i];\n\n\trc = xen_blkbk_map(ring, pages, indirect_grefs, true);\n\tif (rc)\n\t\tgoto unmap;\n\n\tfor (n = 0, i = 0; n < nseg; n++) {\n\t\tuint8_t first_sect, last_sect;\n\n\t\tif ((n % SEGS_PER_INDIRECT_FRAME) == 0) {\n\t\t\t/* Map indirect segments */\n\t\t\tif (segments)\n\t\t\t\tkunmap_atomic(segments);\n\t\t\tsegments = kmap_atomic(pages[n/SEGS_PER_INDIRECT_FRAME]->page);\n\t\t}\n\t\ti = n % SEGS_PER_INDIRECT_FRAME;\n\n\t\tpending_req->segments[n]->gref = segments[i].gref;\n\n\t\tfirst_sect = READ_ONCE(segments[i].first_sect);\n\t\tlast_sect = READ_ONCE(segments[i].last_sect);\n\t\tif (last_sect >= (XEN_PAGE_SIZE >> 9) || last_sect < first_sect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto unmap;\n\t\t}\n\n\t\tseg[n].nsec = last_sect - first_sect + 1;\n\t\tseg[n].offset = first_sect << 9;\n\t\tpreq->nr_sects += seg[n].nsec;\n\t}\n\nunmap:\n\tif (segments)\n\t\tkunmap_atomic(segments);\n\txen_blkbk_unmap(ring, pages, indirect_grefs);\n\treturn rc;\n}\n\nstatic int dispatch_discard_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct xen_blkif *blkif = ring->blkif;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tstruct phys_req preq;\n\n\txen_blkif_get(blkif);\n\n\tpreq.sector_number = req->u.discard.sector_number;\n\tpreq.nr_sects      = req->u.discard.nr_sectors;\n\n\terr = xen_vbd_translate(&preq, blkif, REQ_OP_WRITE);\n\tif (err) {\n\t\tpr_warn(\"access denied: DISCARD [%llu->%llu] on dev=%04x\\n\",\n\t\t\tpreq.sector_number,\n\t\t\tpreq.sector_number + preq.nr_sects, blkif->vbd.pdevice);\n\t\tgoto fail_response;\n\t}\n\tring->st_ds_req++;\n\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\nfail_response:\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(\"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(ring, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}\n\nstatic int dispatch_other_io(struct xen_blkif_ring *ring,\n\t\t\t     struct blkif_request *req,\n\t\t\t     struct pending_req *pending_req)\n{\n\tfree_req(ring, pending_req);\n\tmake_response(ring, req->u.other.id, req->operation,\n\t\t      BLKIF_RSP_EOPNOTSUPP);\n\treturn -EIO;\n}\n\nstatic void xen_blk_drain_io(struct xen_blkif_ring *ring)\n{\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tatomic_set(&blkif->drain, 1);\n\tdo {\n\t\tif (atomic_read(&ring->inflight) == 0)\n\t\t\tbreak;\n\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t&blkif->drain_complete, HZ);\n\n\t\tif (!atomic_read(&blkif->drain))\n\t\t\tbreak;\n\t} while (!kthread_should_stop());\n\tatomic_set(&blkif->drain, 0);\n}\n\n/*\n * Completion callback on the bio's. Called as bh->b_end_io()\n */\n\nstatic void __end_block_io_op(struct pending_req *pending_req, int error)\n{\n\t/* An error fails the entire request. */\n\tif ((pending_req->operation == BLKIF_OP_FLUSH_DISKCACHE) &&\n\t    (error == -EOPNOTSUPP)) {\n\t\tpr_debug(\"flush diskcache op failed, not supported\\n\");\n\t\txen_blkbk_flush_diskcache(XBT_NIL, pending_req->ring->blkif->be, 0);\n\t\tpending_req->status = BLKIF_RSP_EOPNOTSUPP;\n\t} else if ((pending_req->operation == BLKIF_OP_WRITE_BARRIER) &&\n\t\t    (error == -EOPNOTSUPP)) {\n\t\tpr_debug(\"write barrier op failed, not supported\\n\");\n\t\txen_blkbk_barrier(XBT_NIL, pending_req->ring->blkif->be, 0);\n\t\tpending_req->status = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (error) {\n\t\tpr_debug(\"Buffer not up-to-date at end of operation,\"\n\t\t\t \" error=%d\\n\", error);\n\t\tpending_req->status = BLKIF_RSP_ERROR;\n\t}\n\n\t/*\n\t * If all of the bio's have completed it is time to unmap\n\t * the grant references associated with 'request' and provide\n\t * the proper response on the ring.\n\t */\n\tif (atomic_dec_and_test(&pending_req->pendcnt))\n\t\txen_blkbk_unmap_and_respond(pending_req);\n}\n\n/*\n * bio callback.\n */\nstatic void end_block_io_op(struct bio *bio)\n{\n\t__end_block_io_op(bio->bi_private, bio->bi_error);\n\tbio_put(bio);\n}\n\n\n\n/*\n * Function to copy the from the ring buffer the 'struct blkif_request'\n * (which has the sectors we want, number of them, grant references, etc),\n * and transmute  it to the block API to hand it over to the proper block disk.\n */\nstatic int\n__do_block_io_op(struct xen_blkif_ring *ring)\n{\n\tunion blkif_back_rings *blk_rings = &ring->blk_rings;\n\tstruct blkif_request req;\n\tstruct pending_req *pending_req;\n\tRING_IDX rc, rp;\n\tint more_to_do = 0;\n\n\trc = blk_rings->common.req_cons;\n\trp = blk_rings->common.sring->req_prod;\n\trmb(); /* Ensure we see queued requests up to 'rp'. */\n\n\tif (RING_REQUEST_PROD_OVERFLOW(&blk_rings->common, rp)) {\n\t\trc = blk_rings->common.rsp_prod_pvt;\n\t\tpr_warn(\"Frontend provided bogus ring requests (%d - %d = %d). Halting ring processing on dev=%04x\\n\",\n\t\t\trp, rc, rp - rc, ring->blkif->vbd.pdevice);\n\t\treturn -EACCES;\n\t}\n\twhile (rc != rp) {\n\n\t\tif (RING_REQUEST_CONS_OVERFLOW(&blk_rings->common, rc))\n\t\t\tbreak;\n\n\t\tif (kthread_should_stop()) {\n\t\t\tmore_to_do = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tpending_req = alloc_req(ring);\n\t\tif (NULL == pending_req) {\n\t\t\tring->st_oo_req++;\n\t\t\tmore_to_do = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ring->blkif->blk_protocol) {\n\t\tcase BLKIF_PROTOCOL_NATIVE:\n\t\t\tmemcpy(&req, RING_GET_REQUEST(&blk_rings->native, rc), sizeof(req));\n\t\t\tbreak;\n\t\tcase BLKIF_PROTOCOL_X86_32:\n\t\t\tblkif_get_x86_32_req(&req, RING_GET_REQUEST(&blk_rings->x86_32, rc));\n\t\t\tbreak;\n\t\tcase BLKIF_PROTOCOL_X86_64:\n\t\t\tblkif_get_x86_64_req(&req, RING_GET_REQUEST(&blk_rings->x86_64, rc));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tblk_rings->common.req_cons = ++rc; /* before make_response() */\n\n\t\t/* Apply all sanity checks to /private copy/ of request. */\n\t\tbarrier();\n\n\t\tswitch (req.operation) {\n\t\tcase BLKIF_OP_READ:\n\t\tcase BLKIF_OP_WRITE:\n\t\tcase BLKIF_OP_WRITE_BARRIER:\n\t\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tcase BLKIF_OP_INDIRECT:\n\t\t\tif (dispatch_rw_block_io(ring, &req, pending_req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase BLKIF_OP_DISCARD:\n\t\t\tfree_req(ring, pending_req);\n\t\t\tif (dispatch_discard_io(ring, &req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (dispatch_other_io(ring, &req, pending_req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Yield point for this unbounded loop. */\n\t\tcond_resched();\n\t}\ndone:\n\treturn more_to_do;\n}\n\nstatic int\ndo_block_io_op(struct xen_blkif_ring *ring)\n{\n\tunion blkif_back_rings *blk_rings = &ring->blk_rings;\n\tint more_to_do;\n\n\tdo {\n\t\tmore_to_do = __do_block_io_op(ring);\n\t\tif (more_to_do)\n\t\t\tbreak;\n\n\t\tRING_FINAL_CHECK_FOR_REQUESTS(&blk_rings->common, more_to_do);\n\t} while (more_to_do);\n\n\treturn more_to_do;\n}\n/*\n * Transmutation of the 'struct blkif_request' to a proper 'struct bio'\n * and call the 'submit_bio' to pass it to the underlying storage.\n */\nstatic int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req,\n\t\t\t\tstruct pending_req *pending_req)\n{\n\tstruct phys_req preq;\n\tstruct seg_buf *seg = pending_req->seg;\n\tunsigned int nseg;\n\tstruct bio *bio = NULL;\n\tstruct bio **biolist = pending_req->biolist;\n\tint i, nbio = 0;\n\tint operation;\n\tint operation_flags = 0;\n\tstruct blk_plug plug;\n\tbool drain = false;\n\tstruct grant_page **pages = pending_req->segments;\n\tunsigned short req_operation;\n\n\treq_operation = req->operation == BLKIF_OP_INDIRECT ?\n\t\t\treq->u.indirect.indirect_op : req->operation;\n\n\tif ((req->operation == BLKIF_OP_INDIRECT) &&\n\t    (req_operation != BLKIF_OP_READ) &&\n\t    (req_operation != BLKIF_OP_WRITE)) {\n\t\tpr_debug(\"Invalid indirect operation (%u)\\n\", req_operation);\n\t\tgoto fail_response;\n\t}\n\n\tswitch (req_operation) {\n\tcase BLKIF_OP_READ:\n\t\tring->st_rd_req++;\n\t\toperation = REQ_OP_READ;\n\t\tbreak;\n\tcase BLKIF_OP_WRITE:\n\t\tring->st_wr_req++;\n\t\toperation = REQ_OP_WRITE;\n\t\toperation_flags = REQ_SYNC | REQ_IDLE;\n\t\tbreak;\n\tcase BLKIF_OP_WRITE_BARRIER:\n\t\tdrain = true;\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tring->st_f_req++;\n\t\toperation = REQ_OP_WRITE;\n\t\toperation_flags = REQ_PREFLUSH;\n\t\tbreak;\n\tdefault:\n\t\toperation = 0; /* make gcc happy */\n\t\tgoto fail_response;\n\t\tbreak;\n\t}\n\n\t/* Check that the number of segments is sane. */\n\tnseg = req->operation == BLKIF_OP_INDIRECT ?\n\t       req->u.indirect.nr_segments : req->u.rw.nr_segments;\n\n\tif (unlikely(nseg == 0 && operation_flags != REQ_PREFLUSH) ||\n\t    unlikely((req->operation != BLKIF_OP_INDIRECT) &&\n\t\t     (nseg > BLKIF_MAX_SEGMENTS_PER_REQUEST)) ||\n\t    unlikely((req->operation == BLKIF_OP_INDIRECT) &&\n\t\t     (nseg > MAX_INDIRECT_SEGMENTS))) {\n\t\tpr_debug(\"Bad number of segments in request (%d)\\n\", nseg);\n\t\t/* Haven't submitted any bio's yet. */\n\t\tgoto fail_response;\n\t}\n\n\tpreq.nr_sects      = 0;\n\n\tpending_req->ring      = ring;\n\tpending_req->id        = req->u.rw.id;\n\tpending_req->operation = req_operation;\n\tpending_req->status    = BLKIF_RSP_OKAY;\n\tpending_req->nr_segs   = nseg;\n\n\tif (req->operation != BLKIF_OP_INDIRECT) {\n\t\tpreq.dev               = req->u.rw.handle;\n\t\tpreq.sector_number     = req->u.rw.sector_number;\n\t\tfor (i = 0; i < nseg; i++) {\n\t\t\tpages[i]->gref = req->u.rw.seg[i].gref;\n\t\t\tseg[i].nsec = req->u.rw.seg[i].last_sect -\n\t\t\t\treq->u.rw.seg[i].first_sect + 1;\n\t\t\tseg[i].offset = (req->u.rw.seg[i].first_sect << 9);\n\t\t\tif ((req->u.rw.seg[i].last_sect >= (XEN_PAGE_SIZE >> 9)) ||\n\t\t\t    (req->u.rw.seg[i].last_sect <\n\t\t\t     req->u.rw.seg[i].first_sect))\n\t\t\t\tgoto fail_response;\n\t\t\tpreq.nr_sects += seg[i].nsec;\n\t\t}\n\t} else {\n\t\tpreq.dev               = req->u.indirect.handle;\n\t\tpreq.sector_number     = req->u.indirect.sector_number;\n\t\tif (xen_blkbk_parse_indirect(req, pending_req, seg, &preq))\n\t\t\tgoto fail_response;\n\t}\n\n\tif (xen_vbd_translate(&preq, ring->blkif, operation) != 0) {\n\t\tpr_debug(\"access denied: %s of [%llu,%llu] on dev=%04x\\n\",\n\t\t\t operation == REQ_OP_READ ? \"read\" : \"write\",\n\t\t\t preq.sector_number,\n\t\t\t preq.sector_number + preq.nr_sects,\n\t\t\t ring->blkif->vbd.pdevice);\n\t\tgoto fail_response;\n\t}\n\n\t/*\n\t * This check _MUST_ be done after xen_vbd_translate as the preq.bdev\n\t * is set there.\n\t */\n\tfor (i = 0; i < nseg; i++) {\n\t\tif (((int)preq.sector_number|(int)seg[i].nsec) &\n\t\t    ((bdev_logical_block_size(preq.bdev) >> 9) - 1)) {\n\t\t\tpr_debug(\"Misaligned I/O request from domain %d\\n\",\n\t\t\t\t ring->blkif->domid);\n\t\t\tgoto fail_response;\n\t\t}\n\t}\n\n\t/* Wait on all outstanding I/O's and once that has been completed\n\t * issue the flush.\n\t */\n\tif (drain)\n\t\txen_blk_drain_io(pending_req->ring);\n\n\t/*\n\t * If we have failed at this point, we need to undo the M2P override,\n\t * set gnttab_set_unmap_op on all of the grant references and perform\n\t * the hypercall to unmap the grants - that is all done in\n\t * xen_blkbk_unmap.\n\t */\n\tif (xen_blkbk_map_seg(pending_req))\n\t\tgoto fail_flush;\n\n\t/*\n\t * This corresponding xen_blkif_put is done in __end_block_io_op, or\n\t * below (in \"!bio\") if we are handling a BLKIF_OP_DISCARD.\n\t */\n\txen_blkif_get(ring->blkif);\n\tatomic_inc(&ring->inflight);\n\n\tfor (i = 0; i < nseg; i++) {\n\t\twhile ((bio == NULL) ||\n\t\t       (bio_add_page(bio,\n\t\t\t\t     pages[i]->page,\n\t\t\t\t     seg[i].nsec << 9,\n\t\t\t\t     seg[i].offset) == 0)) {\n\n\t\t\tint nr_iovecs = min_t(int, (nseg-i), BIO_MAX_PAGES);\n\t\t\tbio = bio_alloc(GFP_KERNEL, nr_iovecs);\n\t\t\tif (unlikely(bio == NULL))\n\t\t\t\tgoto fail_put_bio;\n\n\t\t\tbiolist[nbio++] = bio;\n\t\t\tbio->bi_bdev    = preq.bdev;\n\t\t\tbio->bi_private = pending_req;\n\t\t\tbio->bi_end_io  = end_block_io_op;\n\t\t\tbio->bi_iter.bi_sector  = preq.sector_number;\n\t\t\tbio_set_op_attrs(bio, operation, operation_flags);\n\t\t}\n\n\t\tpreq.sector_number += seg[i].nsec;\n\t}\n\n\t/* This will be hit if the operation was a flush or discard. */\n\tif (!bio) {\n\t\tBUG_ON(operation_flags != REQ_PREFLUSH);\n\n\t\tbio = bio_alloc(GFP_KERNEL, 0);\n\t\tif (unlikely(bio == NULL))\n\t\t\tgoto fail_put_bio;\n\n\t\tbiolist[nbio++] = bio;\n\t\tbio->bi_bdev    = preq.bdev;\n\t\tbio->bi_private = pending_req;\n\t\tbio->bi_end_io  = end_block_io_op;\n\t\tbio_set_op_attrs(bio, operation, operation_flags);\n\t}\n\n\tatomic_set(&pending_req->pendcnt, nbio);\n\tblk_start_plug(&plug);\n\n\tfor (i = 0; i < nbio; i++)\n\t\tsubmit_bio(biolist[i]);\n\n\t/* Let the I/Os go.. */\n\tblk_finish_plug(&plug);\n\n\tif (operation == REQ_OP_READ)\n\t\tring->st_rd_sect += preq.nr_sects;\n\telse if (operation == REQ_OP_WRITE)\n\t\tring->st_wr_sect += preq.nr_sects;\n\n\treturn 0;\n\n fail_flush:\n\txen_blkbk_unmap(ring, pending_req->segments,\n\t                pending_req->nr_segs);\n fail_response:\n\t/* Haven't submitted any bio's yet. */\n\tmake_response(ring, req->u.rw.id, req_operation, BLKIF_RSP_ERROR);\n\tfree_req(ring, pending_req);\n\tmsleep(1); /* back off a bit */\n\treturn -EIO;\n\n fail_put_bio:\n\tfor (i = 0; i < nbio; i++)\n\t\tbio_put(biolist[i]);\n\tatomic_set(&pending_req->pendcnt, 1);\n\t__end_block_io_op(pending_req, -EINVAL);\n\tmsleep(1); /* back off a bit */\n\treturn -EIO;\n}\n\n\n\n/*\n * Put a response on the ring on how the operation fared.\n */\nstatic void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\t/* Place on the response ring for the relevant domain. */\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n\nstatic int __init xen_blkif_init(void)\n{\n\tint rc = 0;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tif (xen_blkif_max_ring_order > XENBUS_MAX_RING_GRANT_ORDER) {\n\t\tpr_info(\"Invalid max_ring_order (%d), will use default max: %d.\\n\",\n\t\t\txen_blkif_max_ring_order, XENBUS_MAX_RING_GRANT_ORDER);\n\t\txen_blkif_max_ring_order = XENBUS_MAX_RING_GRANT_ORDER;\n\t}\n\n\tif (xenblk_max_queues == 0)\n\t\txenblk_max_queues = num_online_cpus();\n\n\trc = xen_blkif_interface_init();\n\tif (rc)\n\t\tgoto failed_init;\n\n\trc = xen_blkif_xenbus_init();\n\tif (rc)\n\t\tgoto failed_init;\n\n failed_init:\n\treturn rc;\n}\n\nmodule_init(xen_blkif_init);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"xen-backend:vbd\");\n", "/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation; or, when distributed\n * separately from the Linux kernel or incorporated into other\n * software packages, subject to the following license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this source file (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef __XEN_BLKIF__BACKEND__COMMON_H__\n#define __XEN_BLKIF__BACKEND__COMMON_H__\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/io.h>\n#include <linux/rbtree.h>\n#include <asm/setup.h>\n#include <asm/pgalloc.h>\n#include <asm/hypervisor.h>\n#include <xen/grant_table.h>\n#include <xen/page.h>\n#include <xen/xenbus.h>\n#include <xen/interface/io/ring.h>\n#include <xen/interface/io/blkif.h>\n#include <xen/interface/io/protocols.h>\n\nextern unsigned int xen_blkif_max_ring_order;\nextern unsigned int xenblk_max_queues;\n/*\n * This is the maximum number of segments that would be allowed in indirect\n * requests. This value will also be passed to the frontend.\n */\n#define MAX_INDIRECT_SEGMENTS 256\n\n/*\n * Xen use 4K pages. The guest may use different page size (4K or 64K)\n * Number of Xen pages per segment\n */\n#define XEN_PAGES_PER_SEGMENT   (PAGE_SIZE / XEN_PAGE_SIZE)\n\n#define XEN_PAGES_PER_INDIRECT_FRAME \\\n\t(XEN_PAGE_SIZE/sizeof(struct blkif_request_segment))\n#define SEGS_PER_INDIRECT_FRAME\t\\\n\t(XEN_PAGES_PER_INDIRECT_FRAME / XEN_PAGES_PER_SEGMENT)\n\n#define MAX_INDIRECT_PAGES \\\n\t((MAX_INDIRECT_SEGMENTS + SEGS_PER_INDIRECT_FRAME - 1)/SEGS_PER_INDIRECT_FRAME)\n#define INDIRECT_PAGES(_segs) DIV_ROUND_UP(_segs, XEN_PAGES_PER_INDIRECT_FRAME)\n\n/* Not a real protocol.  Used to generate ring structs which contain\n * the elements common to all protocols only.  This way we get a\n * compiler-checkable way to use common struct elements, so we can\n * avoid using switch(protocol) in a number of places.  */\nstruct blkif_common_request {\n\tchar dummy;\n};\nstruct blkif_common_response {\n\tchar dummy;\n};\n\nstruct blkif_x86_32_request_rw {\n\tuint8_t        nr_segments;  /* number of segments                   */\n\tblkif_vdev_t   handle;       /* only for read/write requests         */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tstruct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_discard {\n\tuint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */\n\tblkif_vdev_t   _pad1;        /* was \"handle\" for read/write requests */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tuint64_t       nr_sectors;\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_other {\n\tuint8_t        _pad1;\n\tblkif_vdev_t   _pad2;\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_indirect {\n\tuint8_t        indirect_op;\n\tuint16_t       nr_segments;\n\tuint64_t       id;\n\tblkif_sector_t sector_number;\n\tblkif_vdev_t   handle;\n\tuint16_t       _pad1;\n\tgrant_ref_t    indirect_grefs[BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST];\n\t/*\n\t * The maximum number of indirect segments (and pages) that will\n\t * be used is determined by MAX_INDIRECT_SEGMENTS, this value\n\t * is also exported to the guest (via xenstore\n\t * feature-max-indirect-segments entry), so the frontend knows how\n\t * many indirect segments the backend supports.\n\t */\n\tuint64_t       _pad2;        /* make it 64 byte aligned */\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request {\n\tuint8_t        operation;    /* BLKIF_OP_???                         */\n\tunion {\n\t\tstruct blkif_x86_32_request_rw rw;\n\t\tstruct blkif_x86_32_request_discard discard;\n\t\tstruct blkif_x86_32_request_other other;\n\t\tstruct blkif_x86_32_request_indirect indirect;\n\t} u;\n} __attribute__((__packed__));\n\n/* i386 protocol version */\n#pragma pack(push, 4)\nstruct blkif_x86_32_response {\n\tuint64_t        id;              /* copied from request */\n\tuint8_t         operation;       /* copied from request */\n\tint16_t         status;          /* BLKIF_RSP_???       */\n};\n#pragma pack(pop)\n/* x86_64 protocol version */\n\nstruct blkif_x86_64_request_rw {\n\tuint8_t        nr_segments;  /* number of segments                   */\n\tblkif_vdev_t   handle;       /* only for read/write requests         */\n\tuint32_t       _pad1;        /* offsetof(blkif_reqest..,u.rw.id)==8  */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tstruct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_discard {\n\tuint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */\n\tblkif_vdev_t   _pad1;        /* was \"handle\" for read/write requests */\n        uint32_t       _pad2;        /* offsetof(blkif_..,u.discard.id)==8   */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tuint64_t       nr_sectors;\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_other {\n\tuint8_t        _pad1;\n\tblkif_vdev_t   _pad2;\n\tuint32_t       _pad3;        /* offsetof(blkif_..,u.discard.id)==8   */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_indirect {\n\tuint8_t        indirect_op;\n\tuint16_t       nr_segments;\n\tuint32_t       _pad1;        /* offsetof(blkif_..,u.indirect.id)==8   */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;\n\tblkif_vdev_t   handle;\n\tuint16_t       _pad2;\n\tgrant_ref_t    indirect_grefs[BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST];\n\t/*\n\t * The maximum number of indirect segments (and pages) that will\n\t * be used is determined by MAX_INDIRECT_SEGMENTS, this value\n\t * is also exported to the guest (via xenstore\n\t * feature-max-indirect-segments entry), so the frontend knows how\n\t * many indirect segments the backend supports.\n\t */\n\tuint32_t       _pad3;        /* make it 64 byte aligned */\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request {\n\tuint8_t        operation;    /* BLKIF_OP_???                         */\n\tunion {\n\t\tstruct blkif_x86_64_request_rw rw;\n\t\tstruct blkif_x86_64_request_discard discard;\n\t\tstruct blkif_x86_64_request_other other;\n\t\tstruct blkif_x86_64_request_indirect indirect;\n\t} u;\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_response {\n\tuint64_t       __attribute__((__aligned__(8))) id;\n\tuint8_t         operation;       /* copied from request */\n\tint16_t         status;          /* BLKIF_RSP_???       */\n};\n\nDEFINE_RING_TYPES(blkif_common, struct blkif_common_request,\n\t\t  struct blkif_common_response);\nDEFINE_RING_TYPES(blkif_x86_32, struct blkif_x86_32_request,\n\t\t  struct blkif_x86_32_response);\nDEFINE_RING_TYPES(blkif_x86_64, struct blkif_x86_64_request,\n\t\t  struct blkif_x86_64_response);\n\nunion blkif_back_rings {\n\tstruct blkif_back_ring        native;\n\tstruct blkif_common_back_ring common;\n\tstruct blkif_x86_32_back_ring x86_32;\n\tstruct blkif_x86_64_back_ring x86_64;\n};\n\nenum blkif_protocol {\n\tBLKIF_PROTOCOL_NATIVE = 1,\n\tBLKIF_PROTOCOL_X86_32 = 2,\n\tBLKIF_PROTOCOL_X86_64 = 3,\n};\n\n/*\n * Default protocol if the frontend doesn't specify one.\n */\n#ifdef CONFIG_X86\n#  define BLKIF_PROTOCOL_DEFAULT BLKIF_PROTOCOL_X86_32\n#else\n#  define BLKIF_PROTOCOL_DEFAULT BLKIF_PROTOCOL_NATIVE\n#endif\n\nstruct xen_vbd {\n\t/* What the domain refers to this vbd as. */\n\tblkif_vdev_t\t\thandle;\n\t/* Non-zero -> read-only */\n\tunsigned char\t\treadonly;\n\t/* VDISK_xxx */\n\tunsigned char\t\ttype;\n\t/* phys device that this vbd maps to. */\n\tu32\t\t\tpdevice;\n\tstruct block_device\t*bdev;\n\t/* Cached size parameter. */\n\tsector_t\t\tsize;\n\tunsigned int\t\tflush_support:1;\n\tunsigned int\t\tdiscard_secure:1;\n\tunsigned int\t\tfeature_gnt_persistent:1;\n\tunsigned int\t\toverflow_max_grants:1;\n};\n\nstruct backend_info;\n\n/* Number of available flags */\n#define PERSISTENT_GNT_FLAGS_SIZE\t2\n/* This persistent grant is currently in use */\n#define PERSISTENT_GNT_ACTIVE\t\t0\n/*\n * This persistent grant has been used, this flag is set when we remove the\n * PERSISTENT_GNT_ACTIVE, to know that this grant has been used recently.\n */\n#define PERSISTENT_GNT_WAS_ACTIVE\t1\n\n/* Number of requests that we can fit in a ring */\n#define XEN_BLKIF_REQS_PER_PAGE\t\t32\n\nstruct persistent_gnt {\n\tstruct page *page;\n\tgrant_ref_t gnt;\n\tgrant_handle_t handle;\n\tDECLARE_BITMAP(flags, PERSISTENT_GNT_FLAGS_SIZE);\n\tstruct rb_node node;\n\tstruct list_head remove_node;\n};\n\n/* Per-ring information. */\nstruct xen_blkif_ring {\n\t/* Physical parameters of the comms window. */\n\tunsigned int\t\tirq;\n\tunion blkif_back_rings\tblk_rings;\n\tvoid\t\t\t*blk_ring;\n\t/* Private fields. */\n\tspinlock_t\t\tblk_ring_lock;\n\n\twait_queue_head_t\twq;\n\tatomic_t\t\tinflight;\n\tbool\t\t\tactive;\n\t/* One thread per blkif ring. */\n\tstruct task_struct\t*xenblkd;\n\tunsigned int\t\twaiting_reqs;\n\n\t/* List of all 'pending_req' available */\n\tstruct list_head\tpending_free;\n\t/* And its spinlock. */\n\tspinlock_t\t\tpending_free_lock;\n\twait_queue_head_t\tpending_free_wq;\n\n\t/* Tree to store persistent grants. */\n\tspinlock_t\t\tpers_gnts_lock;\n\tstruct rb_root\t\tpersistent_gnts;\n\tunsigned int\t\tpersistent_gnt_c;\n\tatomic_t\t\tpersistent_gnt_in_use;\n\tunsigned long           next_lru;\n\n\t/* Statistics. */\n\tunsigned long\t\tst_print;\n\tunsigned long long\tst_rd_req;\n\tunsigned long long\tst_wr_req;\n\tunsigned long long\tst_oo_req;\n\tunsigned long long\tst_f_req;\n\tunsigned long long\tst_ds_req;\n\tunsigned long long\tst_rd_sect;\n\tunsigned long long\tst_wr_sect;\n\n\t/* Used by the kworker that offload work from the persistent purge. */\n\tstruct list_head\tpersistent_purge_list;\n\tstruct work_struct\tpersistent_purge_work;\n\n\t/* Buffer of free pages to map grant refs. */\n\tspinlock_t\t\tfree_pages_lock;\n\tint\t\t\tfree_pages_num;\n\tstruct list_head\tfree_pages;\n\n\tstruct work_struct\tfree_work;\n\t/* Thread shutdown wait queue. */\n\twait_queue_head_t\tshutdown_wq;\n\tstruct xen_blkif \t*blkif;\n};\n\nstruct xen_blkif {\n\t/* Unique identifier for this interface. */\n\tdomid_t\t\t\tdomid;\n\tunsigned int\t\thandle;\n\t/* Comms information. */\n\tenum blkif_protocol\tblk_protocol;\n\t/* The VBD attached to this interface. */\n\tstruct xen_vbd\t\tvbd;\n\t/* Back pointer to the backend_info. */\n\tstruct backend_info\t*be;\n\tatomic_t\t\trefcnt;\n\t/* for barrier (drain) requests */\n\tstruct completion\tdrain_complete;\n\tatomic_t\t\tdrain;\n\n\tstruct work_struct\tfree_work;\n\tunsigned int \t\tnr_ring_pages;\n\t/* All rings for this device. */\n\tstruct xen_blkif_ring\t*rings;\n\tunsigned int\t\tnr_rings;\n};\n\nstruct seg_buf {\n\tunsigned long offset;\n\tunsigned int nsec;\n};\n\nstruct grant_page {\n\tstruct page \t\t*page;\n\tstruct persistent_gnt\t*persistent_gnt;\n\tgrant_handle_t\t\thandle;\n\tgrant_ref_t\t\tgref;\n};\n\n/*\n * Each outstanding request that we've passed to the lower device layers has a\n * 'pending_req' allocated to it. Each buffer_head that completes decrements\n * the pendcnt towards zero. When it hits zero, the specified domain has a\n * response queued for it, with the saved 'id' passed back.\n */\nstruct pending_req {\n\tstruct xen_blkif_ring   *ring;\n\tu64\t\t\tid;\n\tint\t\t\tnr_segs;\n\tatomic_t\t\tpendcnt;\n\tunsigned short\t\toperation;\n\tint\t\t\tstatus;\n\tstruct list_head\tfree_list;\n\tstruct grant_page\t*segments[MAX_INDIRECT_SEGMENTS];\n\t/* Indirect descriptors */\n\tstruct grant_page\t*indirect_pages[MAX_INDIRECT_PAGES];\n\tstruct seg_buf\t\tseg[MAX_INDIRECT_SEGMENTS];\n\tstruct bio\t\t*biolist[MAX_INDIRECT_SEGMENTS];\n\tstruct gnttab_unmap_grant_ref unmap[MAX_INDIRECT_SEGMENTS];\n\tstruct page                   *unmap_pages[MAX_INDIRECT_SEGMENTS];\n\tstruct gntab_unmap_queue_data gnttab_unmap_data;\n};\n\n\n#define vbd_sz(_v)\t((_v)->bdev->bd_part ? \\\n\t\t\t (_v)->bdev->bd_part->nr_sects : \\\n\t\t\t  get_capacity((_v)->bdev->bd_disk))\n\n#define xen_blkif_get(_b) (atomic_inc(&(_b)->refcnt))\n#define xen_blkif_put(_b)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (atomic_dec_and_test(&(_b)->refcnt))\t\\\n\t\t\tschedule_work(&(_b)->free_work);\\\n\t} while (0)\n\nstruct phys_req {\n\tunsigned short\t\tdev;\n\tblkif_sector_t\t\tnr_sects;\n\tstruct block_device\t*bdev;\n\tblkif_sector_t\t\tsector_number;\n};\nint xen_blkif_interface_init(void);\n\nint xen_blkif_xenbus_init(void);\n\nirqreturn_t xen_blkif_be_int(int irq, void *dev_id);\nint xen_blkif_schedule(void *arg);\nint xen_blkif_purge_persistent(void *arg);\nvoid xen_blkbk_free_caches(struct xen_blkif_ring *ring);\n\nint xen_blkbk_flush_diskcache(struct xenbus_transaction xbt,\n\t\t\t      struct backend_info *be, int state);\n\nint xen_blkbk_barrier(struct xenbus_transaction xbt,\n\t\t      struct backend_info *be, int state);\nstruct xenbus_device *xen_blkbk_xenbus(struct backend_info *be);\nvoid xen_blkbk_unmap_purged_grants(struct work_struct *work);\n\nstatic inline void blkif_get_x86_32_req(struct blkif_request *dst,\n\t\t\t\t\tstruct blkif_x86_32_request *src)\n{\n\tint i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;\n\tdst->operation = READ_ONCE(src->operation);\n\tswitch (dst->operation) {\n\tcase BLKIF_OP_READ:\n\tcase BLKIF_OP_WRITE:\n\tcase BLKIF_OP_WRITE_BARRIER:\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tdst->u.rw.nr_segments = src->u.rw.nr_segments;\n\t\tdst->u.rw.handle = src->u.rw.handle;\n\t\tdst->u.rw.id = src->u.rw.id;\n\t\tdst->u.rw.sector_number = src->u.rw.sector_number;\n\t\tbarrier();\n\t\tif (n > dst->u.rw.nr_segments)\n\t\t\tn = dst->u.rw.nr_segments;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst->u.rw.seg[i] = src->u.rw.seg[i];\n\t\tbreak;\n\tcase BLKIF_OP_DISCARD:\n\t\tdst->u.discard.flag = src->u.discard.flag;\n\t\tdst->u.discard.id = src->u.discard.id;\n\t\tdst->u.discard.sector_number = src->u.discard.sector_number;\n\t\tdst->u.discard.nr_sectors = src->u.discard.nr_sectors;\n\t\tbreak;\n\tcase BLKIF_OP_INDIRECT:\n\t\tdst->u.indirect.indirect_op = src->u.indirect.indirect_op;\n\t\tdst->u.indirect.nr_segments = src->u.indirect.nr_segments;\n\t\tdst->u.indirect.handle = src->u.indirect.handle;\n\t\tdst->u.indirect.id = src->u.indirect.id;\n\t\tdst->u.indirect.sector_number = src->u.indirect.sector_number;\n\t\tbarrier();\n\t\tj = min(MAX_INDIRECT_PAGES, INDIRECT_PAGES(dst->u.indirect.nr_segments));\n\t\tfor (i = 0; i < j; i++)\n\t\t\tdst->u.indirect.indirect_grefs[i] =\n\t\t\t\tsrc->u.indirect.indirect_grefs[i];\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Don't know how to translate this op. Only get the\n\t\t * ID so failure can be reported to the frontend.\n\t\t */\n\t\tdst->u.other.id = src->u.other.id;\n\t\tbreak;\n\t}\n}\n\nstatic inline void blkif_get_x86_64_req(struct blkif_request *dst,\n\t\t\t\t\tstruct blkif_x86_64_request *src)\n{\n\tint i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;\n\tdst->operation = READ_ONCE(src->operation);\n\tswitch (dst->operation) {\n\tcase BLKIF_OP_READ:\n\tcase BLKIF_OP_WRITE:\n\tcase BLKIF_OP_WRITE_BARRIER:\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tdst->u.rw.nr_segments = src->u.rw.nr_segments;\n\t\tdst->u.rw.handle = src->u.rw.handle;\n\t\tdst->u.rw.id = src->u.rw.id;\n\t\tdst->u.rw.sector_number = src->u.rw.sector_number;\n\t\tbarrier();\n\t\tif (n > dst->u.rw.nr_segments)\n\t\t\tn = dst->u.rw.nr_segments;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst->u.rw.seg[i] = src->u.rw.seg[i];\n\t\tbreak;\n\tcase BLKIF_OP_DISCARD:\n\t\tdst->u.discard.flag = src->u.discard.flag;\n\t\tdst->u.discard.id = src->u.discard.id;\n\t\tdst->u.discard.sector_number = src->u.discard.sector_number;\n\t\tdst->u.discard.nr_sectors = src->u.discard.nr_sectors;\n\t\tbreak;\n\tcase BLKIF_OP_INDIRECT:\n\t\tdst->u.indirect.indirect_op = src->u.indirect.indirect_op;\n\t\tdst->u.indirect.nr_segments = src->u.indirect.nr_segments;\n\t\tdst->u.indirect.handle = src->u.indirect.handle;\n\t\tdst->u.indirect.id = src->u.indirect.id;\n\t\tdst->u.indirect.sector_number = src->u.indirect.sector_number;\n\t\tbarrier();\n\t\tj = min(MAX_INDIRECT_PAGES, INDIRECT_PAGES(dst->u.indirect.nr_segments));\n\t\tfor (i = 0; i < j; i++)\n\t\t\tdst->u.indirect.indirect_grefs[i] =\n\t\t\t\tsrc->u.indirect.indirect_grefs[i];\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Don't know how to translate this op. Only get the\n\t\t * ID so failure can be reported to the frontend.\n\t\t */\n\t\tdst->u.other.id = src->u.other.id;\n\t\tbreak;\n\t}\n}\n\n#endif /* __XEN_BLKIF__BACKEND__COMMON_H__ */\n"], "fixing_code": ["/******************************************************************************\n *\n * Back-end of the driver for virtual block devices. This portion of the\n * driver exports a 'unified' block-device interface that can be accessed\n * by any operating system that implements a compatible front end. A\n * reference front-end implementation can be found in:\n *  drivers/block/xen-blkfront.c\n *\n * Copyright (c) 2003-2004, Keir Fraser & Steve Hand\n * Copyright (c) 2005, Christopher Clark\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation; or, when distributed\n * separately from the Linux kernel or incorporated into other\n * software packages, subject to the following license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this source file (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#define pr_fmt(fmt) \"xen-blkback: \" fmt\n\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/bitmap.h>\n\n#include <xen/events.h>\n#include <xen/page.h>\n#include <xen/xen.h>\n#include <asm/xen/hypervisor.h>\n#include <asm/xen/hypercall.h>\n#include <xen/balloon.h>\n#include <xen/grant_table.h>\n#include \"common.h\"\n\n/*\n * Maximum number of unused free pages to keep in the internal buffer.\n * Setting this to a value too low will reduce memory used in each backend,\n * but can have a performance penalty.\n *\n * A sane value is xen_blkif_reqs * BLKIF_MAX_SEGMENTS_PER_REQUEST, but can\n * be set to a lower value that might degrade performance on some intensive\n * IO workloads.\n */\n\nstatic int xen_blkif_max_buffer_pages = 1024;\nmodule_param_named(max_buffer_pages, xen_blkif_max_buffer_pages, int, 0644);\nMODULE_PARM_DESC(max_buffer_pages,\n\"Maximum number of free pages to keep in each block backend buffer\");\n\n/*\n * Maximum number of grants to map persistently in blkback. For maximum\n * performance this should be the total numbers of grants that can be used\n * to fill the ring, but since this might become too high, specially with\n * the use of indirect descriptors, we set it to a value that provides good\n * performance without using too much memory.\n *\n * When the list of persistent grants is full we clean it up using a LRU\n * algorithm.\n */\n\nstatic int xen_blkif_max_pgrants = 1056;\nmodule_param_named(max_persistent_grants, xen_blkif_max_pgrants, int, 0644);\nMODULE_PARM_DESC(max_persistent_grants,\n                 \"Maximum number of grants to map persistently\");\n\n/*\n * Maximum number of rings/queues blkback supports, allow as many queues as there\n * are CPUs if user has not specified a value.\n */\nunsigned int xenblk_max_queues;\nmodule_param_named(max_queues, xenblk_max_queues, uint, 0644);\nMODULE_PARM_DESC(max_queues,\n\t\t \"Maximum number of hardware queues per virtual disk.\" \\\n\t\t \"By default it is the number of online CPUs.\");\n\n/*\n * Maximum order of pages to be used for the shared ring between front and\n * backend, 4KB page granularity is used.\n */\nunsigned int xen_blkif_max_ring_order = XENBUS_MAX_RING_GRANT_ORDER;\nmodule_param_named(max_ring_page_order, xen_blkif_max_ring_order, int, S_IRUGO);\nMODULE_PARM_DESC(max_ring_page_order, \"Maximum order of pages to be used for the shared ring\");\n/*\n * The LRU mechanism to clean the lists of persistent grants needs to\n * be executed periodically. The time interval between consecutive executions\n * of the purge mechanism is set in ms.\n */\n#define LRU_INTERVAL 100\n\n/*\n * When the persistent grants list is full we will remove unused grants\n * from the list. The percent number of grants to be removed at each LRU\n * execution.\n */\n#define LRU_PERCENT_CLEAN 5\n\n/* Run-time switchable: /sys/module/blkback/parameters/ */\nstatic unsigned int log_stats;\nmodule_param(log_stats, int, 0644);\n\n#define BLKBACK_INVALID_HANDLE (~0)\n\n/* Number of free pages to remove on each call to gnttab_free_pages */\n#define NUM_BATCH_FREE_PAGES 10\n\nstatic inline int get_free_page(struct xen_blkif_ring *ring, struct page **page)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\tif (list_empty(&ring->free_pages)) {\n\t\tBUG_ON(ring->free_pages_num != 0);\n\t\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\t\treturn gnttab_alloc_pages(1, page);\n\t}\n\tBUG_ON(ring->free_pages_num == 0);\n\tpage[0] = list_first_entry(&ring->free_pages, struct page, lru);\n\tlist_del(&page[0]->lru);\n\tring->free_pages_num--;\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\n\treturn 0;\n}\n\nstatic inline void put_free_pages(struct xen_blkif_ring *ring, struct page **page,\n                                  int num)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\tfor (i = 0; i < num; i++)\n\t\tlist_add(&page[i]->lru, &ring->free_pages);\n\tring->free_pages_num += num;\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n}\n\nstatic inline void shrink_free_pagepool(struct xen_blkif_ring *ring, int num)\n{\n\t/* Remove requested pages in batches of NUM_BATCH_FREE_PAGES */\n\tstruct page *page[NUM_BATCH_FREE_PAGES];\n\tunsigned int num_pages = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\twhile (ring->free_pages_num > num) {\n\t\tBUG_ON(list_empty(&ring->free_pages));\n\t\tpage[num_pages] = list_first_entry(&ring->free_pages,\n\t\t                                   struct page, lru);\n\t\tlist_del(&page[num_pages]->lru);\n\t\tring->free_pages_num--;\n\t\tif (++num_pages == NUM_BATCH_FREE_PAGES) {\n\t\t\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\t\t\tgnttab_free_pages(num_pages, page);\n\t\t\tspin_lock_irqsave(&ring->free_pages_lock, flags);\n\t\t\tnum_pages = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ring->free_pages_lock, flags);\n\tif (num_pages != 0)\n\t\tgnttab_free_pages(num_pages, page);\n}\n\n#define vaddr(page) ((unsigned long)pfn_to_kaddr(page_to_pfn(page)))\n\nstatic int do_block_io_op(struct xen_blkif_ring *ring);\nstatic int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req,\n\t\t\t\tstruct pending_req *pending_req);\nstatic void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st);\n\n#define foreach_grant_safe(pos, n, rbtree, node) \\\n\tfor ((pos) = container_of(rb_first((rbtree)), typeof(*(pos)), node), \\\n\t     (n) = (&(pos)->node != NULL) ? rb_next(&(pos)->node) : NULL; \\\n\t     &(pos)->node != NULL; \\\n\t     (pos) = container_of(n, typeof(*(pos)), node), \\\n\t     (n) = (&(pos)->node != NULL) ? rb_next(&(pos)->node) : NULL)\n\n\n/*\n * We don't need locking around the persistent grant helpers\n * because blkback uses a single-thread for each backend, so we\n * can be sure that this functions will never be called recursively.\n *\n * The only exception to that is put_persistent_grant, that can be called\n * from interrupt context (by xen_blkbk_unmap), so we have to use atomic\n * bit operations to modify the flags of a persistent grant and to count\n * the number of used grants.\n */\nstatic int add_persistent_gnt(struct xen_blkif_ring *ring,\n\t\t\t       struct persistent_gnt *persistent_gnt)\n{\n\tstruct rb_node **new = NULL, *parent = NULL;\n\tstruct persistent_gnt *this;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tif (ring->persistent_gnt_c >= xen_blkif_max_pgrants) {\n\t\tif (!blkif->vbd.overflow_max_grants)\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\treturn -EBUSY;\n\t}\n\t/* Figure out where to put new node */\n\tnew = &ring->persistent_gnts.rb_node;\n\twhile (*new) {\n\t\tthis = container_of(*new, struct persistent_gnt, node);\n\n\t\tparent = *new;\n\t\tif (persistent_gnt->gnt < this->gnt)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (persistent_gnt->gnt > this->gnt)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse {\n\t\t\tpr_alert_ratelimited(\"trying to add a gref that's already in the tree\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbitmap_zero(persistent_gnt->flags, PERSISTENT_GNT_FLAGS_SIZE);\n\tset_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&(persistent_gnt->node), parent, new);\n\trb_insert_color(&(persistent_gnt->node), &ring->persistent_gnts);\n\tring->persistent_gnt_c++;\n\tatomic_inc(&ring->persistent_gnt_in_use);\n\treturn 0;\n}\n\nstatic struct persistent_gnt *get_persistent_gnt(struct xen_blkif_ring *ring,\n\t\t\t\t\t\t grant_ref_t gref)\n{\n\tstruct persistent_gnt *data;\n\tstruct rb_node *node = NULL;\n\n\tnode = ring->persistent_gnts.rb_node;\n\twhile (node) {\n\t\tdata = container_of(node, struct persistent_gnt, node);\n\n\t\tif (gref < data->gnt)\n\t\t\tnode = node->rb_left;\n\t\telse if (gref > data->gnt)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tif(test_bit(PERSISTENT_GNT_ACTIVE, data->flags)) {\n\t\t\t\tpr_alert_ratelimited(\"requesting a grant already in use\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tset_bit(PERSISTENT_GNT_ACTIVE, data->flags);\n\t\t\tatomic_inc(&ring->persistent_gnt_in_use);\n\t\t\treturn data;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void put_persistent_gnt(struct xen_blkif_ring *ring,\n                               struct persistent_gnt *persistent_gnt)\n{\n\tif(!test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t\tpr_alert_ratelimited(\"freeing a grant already unused\\n\");\n\tset_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\tclear_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags);\n\tatomic_dec(&ring->persistent_gnt_in_use);\n}\n\nstatic void free_persistent_gnts(struct xen_blkif_ring *ring, struct rb_root *root,\n                                 unsigned int num)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt;\n\tstruct rb_node *n;\n\tint segs_to_unmap = 0;\n\tstruct gntab_unmap_queue_data unmap_data;\n\n\tunmap_data.pages = pages;\n\tunmap_data.unmap_ops = unmap;\n\tunmap_data.kunmap_ops = NULL;\n\n\tforeach_grant_safe(persistent_gnt, n, root, node) {\n\t\tBUG_ON(persistent_gnt->handle ==\n\t\t\tBLKBACK_INVALID_HANDLE);\n\t\tgnttab_set_unmap_op(&unmap[segs_to_unmap],\n\t\t\t(unsigned long) pfn_to_kaddr(page_to_pfn(\n\t\t\t\tpersistent_gnt->page)),\n\t\t\tGNTMAP_host_map,\n\t\t\tpersistent_gnt->handle);\n\n\t\tpages[segs_to_unmap] = persistent_gnt->page;\n\n\t\tif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST ||\n\t\t\t!rb_next(&persistent_gnt->node)) {\n\n\t\t\tunmap_data.count = segs_to_unmap;\n\t\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\n\t\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t\t\tsegs_to_unmap = 0;\n\t\t}\n\n\t\trb_erase(&persistent_gnt->node, root);\n\t\tkfree(persistent_gnt);\n\t\tnum--;\n\t}\n\tBUG_ON(num != 0);\n}\n\nvoid xen_blkbk_unmap_purged_grants(struct work_struct *work)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt;\n\tint segs_to_unmap = 0;\n\tstruct xen_blkif_ring *ring = container_of(work, typeof(*ring), persistent_purge_work);\n\tstruct gntab_unmap_queue_data unmap_data;\n\n\tunmap_data.pages = pages;\n\tunmap_data.unmap_ops = unmap;\n\tunmap_data.kunmap_ops = NULL;\n\n\twhile(!list_empty(&ring->persistent_purge_list)) {\n\t\tpersistent_gnt = list_first_entry(&ring->persistent_purge_list,\n\t\t                                  struct persistent_gnt,\n\t\t                                  remove_node);\n\t\tlist_del(&persistent_gnt->remove_node);\n\n\t\tgnttab_set_unmap_op(&unmap[segs_to_unmap],\n\t\t\tvaddr(persistent_gnt->page),\n\t\t\tGNTMAP_host_map,\n\t\t\tpersistent_gnt->handle);\n\n\t\tpages[segs_to_unmap] = persistent_gnt->page;\n\n\t\tif (++segs_to_unmap == BLKIF_MAX_SEGMENTS_PER_REQUEST) {\n\t\t\tunmap_data.count = segs_to_unmap;\n\t\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\t\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t\t\tsegs_to_unmap = 0;\n\t\t}\n\t\tkfree(persistent_gnt);\n\t}\n\tif (segs_to_unmap > 0) {\n\t\tunmap_data.count = segs_to_unmap;\n\t\tBUG_ON(gnttab_unmap_refs_sync(&unmap_data));\n\t\tput_free_pages(ring, pages, segs_to_unmap);\n\t}\n}\n\nstatic void purge_persistent_gnt(struct xen_blkif_ring *ring)\n{\n\tstruct persistent_gnt *persistent_gnt;\n\tstruct rb_node *n;\n\tunsigned int num_clean, total;\n\tbool scan_used = false, clean_used = false;\n\tstruct rb_root *root;\n\n\tif (ring->persistent_gnt_c < xen_blkif_max_pgrants ||\n\t    (ring->persistent_gnt_c == xen_blkif_max_pgrants &&\n\t    !ring->blkif->vbd.overflow_max_grants)) {\n\t\tgoto out;\n\t}\n\n\tif (work_busy(&ring->persistent_purge_work)) {\n\t\tpr_alert_ratelimited(\"Scheduled work from previous purge is still busy, cannot purge list\\n\");\n\t\tgoto out;\n\t}\n\n\tnum_clean = (xen_blkif_max_pgrants / 100) * LRU_PERCENT_CLEAN;\n\tnum_clean = ring->persistent_gnt_c - xen_blkif_max_pgrants + num_clean;\n\tnum_clean = min(ring->persistent_gnt_c, num_clean);\n\tif ((num_clean == 0) ||\n\t    (num_clean > (ring->persistent_gnt_c - atomic_read(&ring->persistent_gnt_in_use))))\n\t\tgoto out;\n\n\t/*\n\t * At this point, we can assure that there will be no calls\n         * to get_persistent_grant (because we are executing this code from\n         * xen_blkif_schedule), there can only be calls to put_persistent_gnt,\n         * which means that the number of currently used grants will go down,\n         * but never up, so we will always be able to remove the requested\n         * number of grants.\n\t */\n\n\ttotal = num_clean;\n\n\tpr_debug(\"Going to purge %u persistent grants\\n\", num_clean);\n\n\tBUG_ON(!list_empty(&ring->persistent_purge_list));\n\troot = &ring->persistent_gnts;\npurge_list:\n\tforeach_grant_safe(persistent_gnt, n, root, node) {\n\t\tBUG_ON(persistent_gnt->handle ==\n\t\t\tBLKBACK_INVALID_HANDLE);\n\n\t\tif (clean_used) {\n\t\t\tclear_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t\t\tcontinue;\n\t\tif (!scan_used &&\n\t\t    (test_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags)))\n\t\t\tcontinue;\n\n\t\trb_erase(&persistent_gnt->node, root);\n\t\tlist_add(&persistent_gnt->remove_node,\n\t\t\t &ring->persistent_purge_list);\n\t\tif (--num_clean == 0)\n\t\t\tgoto finished;\n\t}\n\t/*\n\t * If we get here it means we also need to start cleaning\n\t * grants that were used since last purge in order to cope\n\t * with the requested num\n\t */\n\tif (!scan_used && !clean_used) {\n\t\tpr_debug(\"Still missing %u purged frames\\n\", num_clean);\n\t\tscan_used = true;\n\t\tgoto purge_list;\n\t}\nfinished:\n\tif (!clean_used) {\n\t\tpr_debug(\"Finished scanning for grants to clean, removing used flag\\n\");\n\t\tclean_used = true;\n\t\tgoto purge_list;\n\t}\n\n\tring->persistent_gnt_c -= (total - num_clean);\n\tring->blkif->vbd.overflow_max_grants = 0;\n\n\t/* We can defer this work */\n\tschedule_work(&ring->persistent_purge_work);\n\tpr_debug(\"Purged %u/%u\\n\", (total - num_clean), total);\n\nout:\n\treturn;\n}\n\n/*\n * Retrieve from the 'pending_reqs' a free pending_req structure to be used.\n */\nstatic struct pending_req *alloc_req(struct xen_blkif_ring *ring)\n{\n\tstruct pending_req *req = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->pending_free_lock, flags);\n\tif (!list_empty(&ring->pending_free)) {\n\t\treq = list_entry(ring->pending_free.next, struct pending_req,\n\t\t\t\t free_list);\n\t\tlist_del(&req->free_list);\n\t}\n\tspin_unlock_irqrestore(&ring->pending_free_lock, flags);\n\treturn req;\n}\n\n/*\n * Return the 'pending_req' structure back to the freepool. We also\n * wake up the thread if it was waiting for a free page.\n */\nstatic void free_req(struct xen_blkif_ring *ring, struct pending_req *req)\n{\n\tunsigned long flags;\n\tint was_empty;\n\n\tspin_lock_irqsave(&ring->pending_free_lock, flags);\n\twas_empty = list_empty(&ring->pending_free);\n\tlist_add(&req->free_list, &ring->pending_free);\n\tspin_unlock_irqrestore(&ring->pending_free_lock, flags);\n\tif (was_empty)\n\t\twake_up(&ring->pending_free_wq);\n}\n\n/*\n * Routines for managing virtual block devices (vbds).\n */\nstatic int xen_vbd_translate(struct phys_req *req, struct xen_blkif *blkif,\n\t\t\t     int operation)\n{\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tint rc = -EACCES;\n\n\tif ((operation != REQ_OP_READ) && vbd->readonly)\n\t\tgoto out;\n\n\tif (likely(req->nr_sects)) {\n\t\tblkif_sector_t end = req->sector_number + req->nr_sects;\n\n\t\tif (unlikely(end < req->sector_number))\n\t\t\tgoto out;\n\t\tif (unlikely(end > vbd_sz(vbd)))\n\t\t\tgoto out;\n\t}\n\n\treq->dev  = vbd->pdevice;\n\treq->bdev = vbd->bdev;\n\trc = 0;\n\n out:\n\treturn rc;\n}\n\nstatic void xen_vbd_resize(struct xen_blkif *blkif)\n{\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tstruct xenbus_device *dev = xen_blkbk_xenbus(blkif->be);\n\tunsigned long long new_size = vbd_sz(vbd);\n\n\tpr_info(\"VBD Resize: Domid: %d, Device: (%d, %d)\\n\",\n\t\tblkif->domid, MAJOR(vbd->pdevice), MINOR(vbd->pdevice));\n\tpr_info(\"VBD Resize: new size %llu\\n\", new_size);\n\tvbd->size = new_size;\nagain:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err) {\n\t\tpr_warn(\"Error starting transaction\\n\");\n\t\treturn;\n\t}\n\terr = xenbus_printf(xbt, dev->nodename, \"sectors\", \"%llu\",\n\t\t\t    (unsigned long long)vbd_sz(vbd));\n\tif (err) {\n\t\tpr_warn(\"Error writing new size\\n\");\n\t\tgoto abort;\n\t}\n\t/*\n\t * Write the current state; we will use this to synchronize\n\t * the front-end. If the current state is \"connected\" the\n\t * front-end will get the new size information online.\n\t */\n\terr = xenbus_printf(xbt, dev->nodename, \"state\", \"%d\", dev->state);\n\tif (err) {\n\t\tpr_warn(\"Error writing the state\\n\");\n\t\tgoto abort;\n\t}\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\tif (err)\n\t\tpr_warn(\"Error ending transaction\\n\");\n\treturn;\nabort:\n\txenbus_transaction_end(xbt, 1);\n}\n\n/*\n * Notification from the guest OS.\n */\nstatic void blkif_notify_work(struct xen_blkif_ring *ring)\n{\n\tring->waiting_reqs = 1;\n\twake_up(&ring->wq);\n}\n\nirqreturn_t xen_blkif_be_int(int irq, void *dev_id)\n{\n\tblkif_notify_work(dev_id);\n\treturn IRQ_HANDLED;\n}\n\n/*\n * SCHEDULER FUNCTIONS\n */\n\nstatic void print_stats(struct xen_blkif_ring *ring)\n{\n\tpr_info(\"(%s): oo %3llu  |  rd %4llu  |  wr %4llu  |  f %4llu\"\n\t\t \"  |  ds %4llu | pg: %4u/%4d\\n\",\n\t\t current->comm, ring->st_oo_req,\n\t\t ring->st_rd_req, ring->st_wr_req,\n\t\t ring->st_f_req, ring->st_ds_req,\n\t\t ring->persistent_gnt_c,\n\t\t xen_blkif_max_pgrants);\n\tring->st_print = jiffies + msecs_to_jiffies(10 * 1000);\n\tring->st_rd_req = 0;\n\tring->st_wr_req = 0;\n\tring->st_oo_req = 0;\n\tring->st_ds_req = 0;\n}\n\nint xen_blkif_schedule(void *arg)\n{\n\tstruct xen_blkif_ring *ring = arg;\n\tstruct xen_blkif *blkif = ring->blkif;\n\tstruct xen_vbd *vbd = &blkif->vbd;\n\tunsigned long timeout;\n\tint ret;\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (unlikely(vbd->size != vbd_sz(vbd)))\n\t\t\txen_vbd_resize(blkif);\n\n\t\ttimeout = msecs_to_jiffies(LRU_INTERVAL);\n\n\t\ttimeout = wait_event_interruptible_timeout(\n\t\t\tring->wq,\n\t\t\tring->waiting_reqs || kthread_should_stop(),\n\t\t\ttimeout);\n\t\tif (timeout == 0)\n\t\t\tgoto purge_gnt_list;\n\t\ttimeout = wait_event_interruptible_timeout(\n\t\t\tring->pending_free_wq,\n\t\t\t!list_empty(&ring->pending_free) ||\n\t\t\tkthread_should_stop(),\n\t\t\ttimeout);\n\t\tif (timeout == 0)\n\t\t\tgoto purge_gnt_list;\n\n\t\tring->waiting_reqs = 0;\n\t\tsmp_mb(); /* clear flag *before* checking for work */\n\n\t\tret = do_block_io_op(ring);\n\t\tif (ret > 0)\n\t\t\tring->waiting_reqs = 1;\n\t\tif (ret == -EACCES)\n\t\t\twait_event_interruptible(ring->shutdown_wq,\n\t\t\t\t\t\t kthread_should_stop());\n\npurge_gnt_list:\n\t\tif (blkif->vbd.feature_gnt_persistent &&\n\t\t    time_after(jiffies, ring->next_lru)) {\n\t\t\tpurge_persistent_gnt(ring);\n\t\t\tring->next_lru = jiffies + msecs_to_jiffies(LRU_INTERVAL);\n\t\t}\n\n\t\t/* Shrink if we have more than xen_blkif_max_buffer_pages */\n\t\tshrink_free_pagepool(ring, xen_blkif_max_buffer_pages);\n\n\t\tif (log_stats && time_after(jiffies, ring->st_print))\n\t\t\tprint_stats(ring);\n\t}\n\n\t/* Drain pending purge work */\n\tflush_work(&ring->persistent_purge_work);\n\n\tif (log_stats)\n\t\tprint_stats(ring);\n\n\tring->xenblkd = NULL;\n\n\treturn 0;\n}\n\n/*\n * Remove persistent grants and empty the pool of free pages\n */\nvoid xen_blkbk_free_caches(struct xen_blkif_ring *ring)\n{\n\t/* Free all persistent grant pages */\n\tif (!RB_EMPTY_ROOT(&ring->persistent_gnts))\n\t\tfree_persistent_gnts(ring, &ring->persistent_gnts,\n\t\t\tring->persistent_gnt_c);\n\n\tBUG_ON(!RB_EMPTY_ROOT(&ring->persistent_gnts));\n\tring->persistent_gnt_c = 0;\n\n\t/* Since we are shutting down remove all pages from the buffer */\n\tshrink_free_pagepool(ring, 0 /* All */);\n}\n\nstatic unsigned int xen_blkbk_unmap_prepare(\n\tstruct xen_blkif_ring *ring,\n\tstruct grant_page **pages,\n\tunsigned int num,\n\tstruct gnttab_unmap_grant_ref *unmap_ops,\n\tstruct page **unmap_pages)\n{\n\tunsigned int i, invcount = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (pages[i]->persistent_gnt != NULL) {\n\t\t\tput_persistent_gnt(ring, pages[i]->persistent_gnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pages[i]->handle == BLKBACK_INVALID_HANDLE)\n\t\t\tcontinue;\n\t\tunmap_pages[invcount] = pages[i]->page;\n\t\tgnttab_set_unmap_op(&unmap_ops[invcount], vaddr(pages[i]->page),\n\t\t\t\t    GNTMAP_host_map, pages[i]->handle);\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\t\tinvcount++;\n       }\n\n       return invcount;\n}\n\nstatic void xen_blkbk_unmap_and_respond_callback(int result, struct gntab_unmap_queue_data *data)\n{\n\tstruct pending_req *pending_req = (struct pending_req *)(data->data);\n\tstruct xen_blkif_ring *ring = pending_req->ring;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\t/* BUG_ON used to reproduce existing behaviour,\n\t   but is this the best way to deal with this? */\n\tBUG_ON(result);\n\n\tput_free_pages(ring, data->pages, data->count);\n\tmake_response(ring, pending_req->id,\n\t\t      pending_req->operation, pending_req->status);\n\tfree_req(ring, pending_req);\n\t/*\n\t * Make sure the request is freed before releasing blkif,\n\t * or there could be a race between free_req and the\n\t * cleanup done in xen_blkif_free during shutdown.\n\t *\n\t * NB: The fact that we might try to wake up pending_free_wq\n\t * before drain_complete (in case there's a drain going on)\n\t * it's not a problem with our current implementation\n\t * because we can assure there's no thread waiting on\n\t * pending_free_wq if there's a drain going on, but it has\n\t * to be taken into account if the current model is changed.\n\t */\n\tif (atomic_dec_and_test(&ring->inflight) && atomic_read(&blkif->drain)) {\n\t\tcomplete(&blkif->drain_complete);\n\t}\n\txen_blkif_put(blkif);\n}\n\nstatic void xen_blkbk_unmap_and_respond(struct pending_req *req)\n{\n\tstruct gntab_unmap_queue_data* work = &req->gnttab_unmap_data;\n\tstruct xen_blkif_ring *ring = req->ring;\n\tstruct grant_page **pages = req->segments;\n\tunsigned int invcount;\n\n\tinvcount = xen_blkbk_unmap_prepare(ring, pages, req->nr_segs,\n\t\t\t\t\t   req->unmap, req->unmap_pages);\n\n\twork->data = req;\n\twork->done = xen_blkbk_unmap_and_respond_callback;\n\twork->unmap_ops = req->unmap;\n\twork->kunmap_ops = NULL;\n\twork->pages = req->unmap_pages;\n\twork->count = invcount;\n\n\tgnttab_unmap_refs_async(&req->gnttab_unmap_data);\n}\n\n\n/*\n * Unmap the grant references.\n *\n * This could accumulate ops up to the batch size to reduce the number\n * of hypercalls, but since this is only used in error paths there's\n * no real need.\n */\nstatic void xen_blkbk_unmap(struct xen_blkif_ring *ring,\n                            struct grant_page *pages[],\n                            int num)\n{\n\tstruct gnttab_unmap_grant_ref unmap[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *unmap_pages[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tunsigned int invcount = 0;\n\tint ret;\n\n\twhile (num) {\n\t\tunsigned int batch = min(num, BLKIF_MAX_SEGMENTS_PER_REQUEST);\n\n\t\tinvcount = xen_blkbk_unmap_prepare(ring, pages, batch,\n\t\t\t\t\t\t   unmap, unmap_pages);\n\t\tif (invcount) {\n\t\t\tret = gnttab_unmap_refs(unmap, NULL, unmap_pages, invcount);\n\t\t\tBUG_ON(ret);\n\t\t\tput_free_pages(ring, unmap_pages, invcount);\n\t\t}\n\t\tpages += batch;\n\t\tnum -= batch;\n\t}\n}\n\nstatic int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (get_free_page(ring, &pages[i]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map) {\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\t\tBUG_ON(ret);\n\t}\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tput_free_pages(ring, &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= 1;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < xen_blkif_max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t xen_blkif_max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (map_until != num)\n\t\tgoto again;\n\n\treturn ret;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", __func__);\n\tput_free_pages(ring, pages_to_gnt, segs_to_map);\n\treturn -ENOMEM;\n}\n\nstatic int xen_blkbk_map_seg(struct pending_req *pending_req)\n{\n\tint rc;\n\n\trc = xen_blkbk_map(pending_req->ring, pending_req->segments,\n\t\t\t   pending_req->nr_segs,\n\t                   (pending_req->operation != BLKIF_OP_READ));\n\n\treturn rc;\n}\n\nstatic int xen_blkbk_parse_indirect(struct blkif_request *req,\n\t\t\t\t    struct pending_req *pending_req,\n\t\t\t\t    struct seg_buf seg[],\n\t\t\t\t    struct phys_req *preq)\n{\n\tstruct grant_page **pages = pending_req->indirect_pages;\n\tstruct xen_blkif_ring *ring = pending_req->ring;\n\tint indirect_grefs, rc, n, nseg, i;\n\tstruct blkif_request_segment *segments = NULL;\n\n\tnseg = pending_req->nr_segs;\n\tindirect_grefs = INDIRECT_PAGES(nseg);\n\tBUG_ON(indirect_grefs > BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST);\n\n\tfor (i = 0; i < indirect_grefs; i++)\n\t\tpages[i]->gref = req->u.indirect.indirect_grefs[i];\n\n\trc = xen_blkbk_map(ring, pages, indirect_grefs, true);\n\tif (rc)\n\t\tgoto unmap;\n\n\tfor (n = 0, i = 0; n < nseg; n++) {\n\t\tuint8_t first_sect, last_sect;\n\n\t\tif ((n % SEGS_PER_INDIRECT_FRAME) == 0) {\n\t\t\t/* Map indirect segments */\n\t\t\tif (segments)\n\t\t\t\tkunmap_atomic(segments);\n\t\t\tsegments = kmap_atomic(pages[n/SEGS_PER_INDIRECT_FRAME]->page);\n\t\t}\n\t\ti = n % SEGS_PER_INDIRECT_FRAME;\n\n\t\tpending_req->segments[n]->gref = segments[i].gref;\n\n\t\tfirst_sect = READ_ONCE(segments[i].first_sect);\n\t\tlast_sect = READ_ONCE(segments[i].last_sect);\n\t\tif (last_sect >= (XEN_PAGE_SIZE >> 9) || last_sect < first_sect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto unmap;\n\t\t}\n\n\t\tseg[n].nsec = last_sect - first_sect + 1;\n\t\tseg[n].offset = first_sect << 9;\n\t\tpreq->nr_sects += seg[n].nsec;\n\t}\n\nunmap:\n\tif (segments)\n\t\tkunmap_atomic(segments);\n\txen_blkbk_unmap(ring, pages, indirect_grefs);\n\treturn rc;\n}\n\nstatic int dispatch_discard_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct xen_blkif *blkif = ring->blkif;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tstruct phys_req preq;\n\n\txen_blkif_get(blkif);\n\n\tpreq.sector_number = req->u.discard.sector_number;\n\tpreq.nr_sects      = req->u.discard.nr_sectors;\n\n\terr = xen_vbd_translate(&preq, blkif, REQ_OP_WRITE);\n\tif (err) {\n\t\tpr_warn(\"access denied: DISCARD [%llu->%llu] on dev=%04x\\n\",\n\t\t\tpreq.sector_number,\n\t\t\tpreq.sector_number + preq.nr_sects, blkif->vbd.pdevice);\n\t\tgoto fail_response;\n\t}\n\tring->st_ds_req++;\n\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\nfail_response:\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(\"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(ring, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}\n\nstatic int dispatch_other_io(struct xen_blkif_ring *ring,\n\t\t\t     struct blkif_request *req,\n\t\t\t     struct pending_req *pending_req)\n{\n\tfree_req(ring, pending_req);\n\tmake_response(ring, req->u.other.id, req->operation,\n\t\t      BLKIF_RSP_EOPNOTSUPP);\n\treturn -EIO;\n}\n\nstatic void xen_blk_drain_io(struct xen_blkif_ring *ring)\n{\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tatomic_set(&blkif->drain, 1);\n\tdo {\n\t\tif (atomic_read(&ring->inflight) == 0)\n\t\t\tbreak;\n\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t&blkif->drain_complete, HZ);\n\n\t\tif (!atomic_read(&blkif->drain))\n\t\t\tbreak;\n\t} while (!kthread_should_stop());\n\tatomic_set(&blkif->drain, 0);\n}\n\n/*\n * Completion callback on the bio's. Called as bh->b_end_io()\n */\n\nstatic void __end_block_io_op(struct pending_req *pending_req, int error)\n{\n\t/* An error fails the entire request. */\n\tif ((pending_req->operation == BLKIF_OP_FLUSH_DISKCACHE) &&\n\t    (error == -EOPNOTSUPP)) {\n\t\tpr_debug(\"flush diskcache op failed, not supported\\n\");\n\t\txen_blkbk_flush_diskcache(XBT_NIL, pending_req->ring->blkif->be, 0);\n\t\tpending_req->status = BLKIF_RSP_EOPNOTSUPP;\n\t} else if ((pending_req->operation == BLKIF_OP_WRITE_BARRIER) &&\n\t\t    (error == -EOPNOTSUPP)) {\n\t\tpr_debug(\"write barrier op failed, not supported\\n\");\n\t\txen_blkbk_barrier(XBT_NIL, pending_req->ring->blkif->be, 0);\n\t\tpending_req->status = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (error) {\n\t\tpr_debug(\"Buffer not up-to-date at end of operation,\"\n\t\t\t \" error=%d\\n\", error);\n\t\tpending_req->status = BLKIF_RSP_ERROR;\n\t}\n\n\t/*\n\t * If all of the bio's have completed it is time to unmap\n\t * the grant references associated with 'request' and provide\n\t * the proper response on the ring.\n\t */\n\tif (atomic_dec_and_test(&pending_req->pendcnt))\n\t\txen_blkbk_unmap_and_respond(pending_req);\n}\n\n/*\n * bio callback.\n */\nstatic void end_block_io_op(struct bio *bio)\n{\n\t__end_block_io_op(bio->bi_private, bio->bi_error);\n\tbio_put(bio);\n}\n\n\n\n/*\n * Function to copy the from the ring buffer the 'struct blkif_request'\n * (which has the sectors we want, number of them, grant references, etc),\n * and transmute  it to the block API to hand it over to the proper block disk.\n */\nstatic int\n__do_block_io_op(struct xen_blkif_ring *ring)\n{\n\tunion blkif_back_rings *blk_rings = &ring->blk_rings;\n\tstruct blkif_request req;\n\tstruct pending_req *pending_req;\n\tRING_IDX rc, rp;\n\tint more_to_do = 0;\n\n\trc = blk_rings->common.req_cons;\n\trp = blk_rings->common.sring->req_prod;\n\trmb(); /* Ensure we see queued requests up to 'rp'. */\n\n\tif (RING_REQUEST_PROD_OVERFLOW(&blk_rings->common, rp)) {\n\t\trc = blk_rings->common.rsp_prod_pvt;\n\t\tpr_warn(\"Frontend provided bogus ring requests (%d - %d = %d). Halting ring processing on dev=%04x\\n\",\n\t\t\trp, rc, rp - rc, ring->blkif->vbd.pdevice);\n\t\treturn -EACCES;\n\t}\n\twhile (rc != rp) {\n\n\t\tif (RING_REQUEST_CONS_OVERFLOW(&blk_rings->common, rc))\n\t\t\tbreak;\n\n\t\tif (kthread_should_stop()) {\n\t\t\tmore_to_do = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tpending_req = alloc_req(ring);\n\t\tif (NULL == pending_req) {\n\t\t\tring->st_oo_req++;\n\t\t\tmore_to_do = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ring->blkif->blk_protocol) {\n\t\tcase BLKIF_PROTOCOL_NATIVE:\n\t\t\tmemcpy(&req, RING_GET_REQUEST(&blk_rings->native, rc), sizeof(req));\n\t\t\tbreak;\n\t\tcase BLKIF_PROTOCOL_X86_32:\n\t\t\tblkif_get_x86_32_req(&req, RING_GET_REQUEST(&blk_rings->x86_32, rc));\n\t\t\tbreak;\n\t\tcase BLKIF_PROTOCOL_X86_64:\n\t\t\tblkif_get_x86_64_req(&req, RING_GET_REQUEST(&blk_rings->x86_64, rc));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tblk_rings->common.req_cons = ++rc; /* before make_response() */\n\n\t\t/* Apply all sanity checks to /private copy/ of request. */\n\t\tbarrier();\n\n\t\tswitch (req.operation) {\n\t\tcase BLKIF_OP_READ:\n\t\tcase BLKIF_OP_WRITE:\n\t\tcase BLKIF_OP_WRITE_BARRIER:\n\t\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tcase BLKIF_OP_INDIRECT:\n\t\t\tif (dispatch_rw_block_io(ring, &req, pending_req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase BLKIF_OP_DISCARD:\n\t\t\tfree_req(ring, pending_req);\n\t\t\tif (dispatch_discard_io(ring, &req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (dispatch_other_io(ring, &req, pending_req))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Yield point for this unbounded loop. */\n\t\tcond_resched();\n\t}\ndone:\n\treturn more_to_do;\n}\n\nstatic int\ndo_block_io_op(struct xen_blkif_ring *ring)\n{\n\tunion blkif_back_rings *blk_rings = &ring->blk_rings;\n\tint more_to_do;\n\n\tdo {\n\t\tmore_to_do = __do_block_io_op(ring);\n\t\tif (more_to_do)\n\t\t\tbreak;\n\n\t\tRING_FINAL_CHECK_FOR_REQUESTS(&blk_rings->common, more_to_do);\n\t} while (more_to_do);\n\n\treturn more_to_do;\n}\n/*\n * Transmutation of the 'struct blkif_request' to a proper 'struct bio'\n * and call the 'submit_bio' to pass it to the underlying storage.\n */\nstatic int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n\t\t\t\tstruct blkif_request *req,\n\t\t\t\tstruct pending_req *pending_req)\n{\n\tstruct phys_req preq;\n\tstruct seg_buf *seg = pending_req->seg;\n\tunsigned int nseg;\n\tstruct bio *bio = NULL;\n\tstruct bio **biolist = pending_req->biolist;\n\tint i, nbio = 0;\n\tint operation;\n\tint operation_flags = 0;\n\tstruct blk_plug plug;\n\tbool drain = false;\n\tstruct grant_page **pages = pending_req->segments;\n\tunsigned short req_operation;\n\n\treq_operation = req->operation == BLKIF_OP_INDIRECT ?\n\t\t\treq->u.indirect.indirect_op : req->operation;\n\n\tif ((req->operation == BLKIF_OP_INDIRECT) &&\n\t    (req_operation != BLKIF_OP_READ) &&\n\t    (req_operation != BLKIF_OP_WRITE)) {\n\t\tpr_debug(\"Invalid indirect operation (%u)\\n\", req_operation);\n\t\tgoto fail_response;\n\t}\n\n\tswitch (req_operation) {\n\tcase BLKIF_OP_READ:\n\t\tring->st_rd_req++;\n\t\toperation = REQ_OP_READ;\n\t\tbreak;\n\tcase BLKIF_OP_WRITE:\n\t\tring->st_wr_req++;\n\t\toperation = REQ_OP_WRITE;\n\t\toperation_flags = REQ_SYNC | REQ_IDLE;\n\t\tbreak;\n\tcase BLKIF_OP_WRITE_BARRIER:\n\t\tdrain = true;\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tring->st_f_req++;\n\t\toperation = REQ_OP_WRITE;\n\t\toperation_flags = REQ_PREFLUSH;\n\t\tbreak;\n\tdefault:\n\t\toperation = 0; /* make gcc happy */\n\t\tgoto fail_response;\n\t\tbreak;\n\t}\n\n\t/* Check that the number of segments is sane. */\n\tnseg = req->operation == BLKIF_OP_INDIRECT ?\n\t       req->u.indirect.nr_segments : req->u.rw.nr_segments;\n\n\tif (unlikely(nseg == 0 && operation_flags != REQ_PREFLUSH) ||\n\t    unlikely((req->operation != BLKIF_OP_INDIRECT) &&\n\t\t     (nseg > BLKIF_MAX_SEGMENTS_PER_REQUEST)) ||\n\t    unlikely((req->operation == BLKIF_OP_INDIRECT) &&\n\t\t     (nseg > MAX_INDIRECT_SEGMENTS))) {\n\t\tpr_debug(\"Bad number of segments in request (%d)\\n\", nseg);\n\t\t/* Haven't submitted any bio's yet. */\n\t\tgoto fail_response;\n\t}\n\n\tpreq.nr_sects      = 0;\n\n\tpending_req->ring      = ring;\n\tpending_req->id        = req->u.rw.id;\n\tpending_req->operation = req_operation;\n\tpending_req->status    = BLKIF_RSP_OKAY;\n\tpending_req->nr_segs   = nseg;\n\n\tif (req->operation != BLKIF_OP_INDIRECT) {\n\t\tpreq.dev               = req->u.rw.handle;\n\t\tpreq.sector_number     = req->u.rw.sector_number;\n\t\tfor (i = 0; i < nseg; i++) {\n\t\t\tpages[i]->gref = req->u.rw.seg[i].gref;\n\t\t\tseg[i].nsec = req->u.rw.seg[i].last_sect -\n\t\t\t\treq->u.rw.seg[i].first_sect + 1;\n\t\t\tseg[i].offset = (req->u.rw.seg[i].first_sect << 9);\n\t\t\tif ((req->u.rw.seg[i].last_sect >= (XEN_PAGE_SIZE >> 9)) ||\n\t\t\t    (req->u.rw.seg[i].last_sect <\n\t\t\t     req->u.rw.seg[i].first_sect))\n\t\t\t\tgoto fail_response;\n\t\t\tpreq.nr_sects += seg[i].nsec;\n\t\t}\n\t} else {\n\t\tpreq.dev               = req->u.indirect.handle;\n\t\tpreq.sector_number     = req->u.indirect.sector_number;\n\t\tif (xen_blkbk_parse_indirect(req, pending_req, seg, &preq))\n\t\t\tgoto fail_response;\n\t}\n\n\tif (xen_vbd_translate(&preq, ring->blkif, operation) != 0) {\n\t\tpr_debug(\"access denied: %s of [%llu,%llu] on dev=%04x\\n\",\n\t\t\t operation == REQ_OP_READ ? \"read\" : \"write\",\n\t\t\t preq.sector_number,\n\t\t\t preq.sector_number + preq.nr_sects,\n\t\t\t ring->blkif->vbd.pdevice);\n\t\tgoto fail_response;\n\t}\n\n\t/*\n\t * This check _MUST_ be done after xen_vbd_translate as the preq.bdev\n\t * is set there.\n\t */\n\tfor (i = 0; i < nseg; i++) {\n\t\tif (((int)preq.sector_number|(int)seg[i].nsec) &\n\t\t    ((bdev_logical_block_size(preq.bdev) >> 9) - 1)) {\n\t\t\tpr_debug(\"Misaligned I/O request from domain %d\\n\",\n\t\t\t\t ring->blkif->domid);\n\t\t\tgoto fail_response;\n\t\t}\n\t}\n\n\t/* Wait on all outstanding I/O's and once that has been completed\n\t * issue the flush.\n\t */\n\tif (drain)\n\t\txen_blk_drain_io(pending_req->ring);\n\n\t/*\n\t * If we have failed at this point, we need to undo the M2P override,\n\t * set gnttab_set_unmap_op on all of the grant references and perform\n\t * the hypercall to unmap the grants - that is all done in\n\t * xen_blkbk_unmap.\n\t */\n\tif (xen_blkbk_map_seg(pending_req))\n\t\tgoto fail_flush;\n\n\t/*\n\t * This corresponding xen_blkif_put is done in __end_block_io_op, or\n\t * below (in \"!bio\") if we are handling a BLKIF_OP_DISCARD.\n\t */\n\txen_blkif_get(ring->blkif);\n\tatomic_inc(&ring->inflight);\n\n\tfor (i = 0; i < nseg; i++) {\n\t\twhile ((bio == NULL) ||\n\t\t       (bio_add_page(bio,\n\t\t\t\t     pages[i]->page,\n\t\t\t\t     seg[i].nsec << 9,\n\t\t\t\t     seg[i].offset) == 0)) {\n\n\t\t\tint nr_iovecs = min_t(int, (nseg-i), BIO_MAX_PAGES);\n\t\t\tbio = bio_alloc(GFP_KERNEL, nr_iovecs);\n\t\t\tif (unlikely(bio == NULL))\n\t\t\t\tgoto fail_put_bio;\n\n\t\t\tbiolist[nbio++] = bio;\n\t\t\tbio->bi_bdev    = preq.bdev;\n\t\t\tbio->bi_private = pending_req;\n\t\t\tbio->bi_end_io  = end_block_io_op;\n\t\t\tbio->bi_iter.bi_sector  = preq.sector_number;\n\t\t\tbio_set_op_attrs(bio, operation, operation_flags);\n\t\t}\n\n\t\tpreq.sector_number += seg[i].nsec;\n\t}\n\n\t/* This will be hit if the operation was a flush or discard. */\n\tif (!bio) {\n\t\tBUG_ON(operation_flags != REQ_PREFLUSH);\n\n\t\tbio = bio_alloc(GFP_KERNEL, 0);\n\t\tif (unlikely(bio == NULL))\n\t\t\tgoto fail_put_bio;\n\n\t\tbiolist[nbio++] = bio;\n\t\tbio->bi_bdev    = preq.bdev;\n\t\tbio->bi_private = pending_req;\n\t\tbio->bi_end_io  = end_block_io_op;\n\t\tbio_set_op_attrs(bio, operation, operation_flags);\n\t}\n\n\tatomic_set(&pending_req->pendcnt, nbio);\n\tblk_start_plug(&plug);\n\n\tfor (i = 0; i < nbio; i++)\n\t\tsubmit_bio(biolist[i]);\n\n\t/* Let the I/Os go.. */\n\tblk_finish_plug(&plug);\n\n\tif (operation == REQ_OP_READ)\n\t\tring->st_rd_sect += preq.nr_sects;\n\telse if (operation == REQ_OP_WRITE)\n\t\tring->st_wr_sect += preq.nr_sects;\n\n\treturn 0;\n\n fail_flush:\n\txen_blkbk_unmap(ring, pending_req->segments,\n\t                pending_req->nr_segs);\n fail_response:\n\t/* Haven't submitted any bio's yet. */\n\tmake_response(ring, req->u.rw.id, req_operation, BLKIF_RSP_ERROR);\n\tfree_req(ring, pending_req);\n\tmsleep(1); /* back off a bit */\n\treturn -EIO;\n\n fail_put_bio:\n\tfor (i = 0; i < nbio; i++)\n\t\tbio_put(biolist[i]);\n\tatomic_set(&pending_req->pendcnt, 1);\n\t__end_block_io_op(pending_req, -EINVAL);\n\tmsleep(1); /* back off a bit */\n\treturn -EIO;\n}\n\n\n\n/*\n * Put a response on the ring on how the operation fared.\n */\nstatic void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response *resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\t/* Place on the response ring for the relevant domain. */\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->native,\n\t\t\t\t\t blk_rings->native.rsp_prod_pvt);\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_32,\n\t\t\t\t\t blk_rings->x86_32.rsp_prod_pvt);\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_64,\n\t\t\t\t\t blk_rings->x86_64.rsp_prod_pvt);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tresp->id        = id;\n\tresp->operation = op;\n\tresp->status    = st;\n\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n\nstatic int __init xen_blkif_init(void)\n{\n\tint rc = 0;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tif (xen_blkif_max_ring_order > XENBUS_MAX_RING_GRANT_ORDER) {\n\t\tpr_info(\"Invalid max_ring_order (%d), will use default max: %d.\\n\",\n\t\t\txen_blkif_max_ring_order, XENBUS_MAX_RING_GRANT_ORDER);\n\t\txen_blkif_max_ring_order = XENBUS_MAX_RING_GRANT_ORDER;\n\t}\n\n\tif (xenblk_max_queues == 0)\n\t\txenblk_max_queues = num_online_cpus();\n\n\trc = xen_blkif_interface_init();\n\tif (rc)\n\t\tgoto failed_init;\n\n\trc = xen_blkif_xenbus_init();\n\tif (rc)\n\t\tgoto failed_init;\n\n failed_init:\n\treturn rc;\n}\n\nmodule_init(xen_blkif_init);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"xen-backend:vbd\");\n", "/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation; or, when distributed\n * separately from the Linux kernel or incorporated into other\n * software packages, subject to the following license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this source file (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef __XEN_BLKIF__BACKEND__COMMON_H__\n#define __XEN_BLKIF__BACKEND__COMMON_H__\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/io.h>\n#include <linux/rbtree.h>\n#include <asm/setup.h>\n#include <asm/pgalloc.h>\n#include <asm/hypervisor.h>\n#include <xen/grant_table.h>\n#include <xen/page.h>\n#include <xen/xenbus.h>\n#include <xen/interface/io/ring.h>\n#include <xen/interface/io/blkif.h>\n#include <xen/interface/io/protocols.h>\n\nextern unsigned int xen_blkif_max_ring_order;\nextern unsigned int xenblk_max_queues;\n/*\n * This is the maximum number of segments that would be allowed in indirect\n * requests. This value will also be passed to the frontend.\n */\n#define MAX_INDIRECT_SEGMENTS 256\n\n/*\n * Xen use 4K pages. The guest may use different page size (4K or 64K)\n * Number of Xen pages per segment\n */\n#define XEN_PAGES_PER_SEGMENT   (PAGE_SIZE / XEN_PAGE_SIZE)\n\n#define XEN_PAGES_PER_INDIRECT_FRAME \\\n\t(XEN_PAGE_SIZE/sizeof(struct blkif_request_segment))\n#define SEGS_PER_INDIRECT_FRAME\t\\\n\t(XEN_PAGES_PER_INDIRECT_FRAME / XEN_PAGES_PER_SEGMENT)\n\n#define MAX_INDIRECT_PAGES \\\n\t((MAX_INDIRECT_SEGMENTS + SEGS_PER_INDIRECT_FRAME - 1)/SEGS_PER_INDIRECT_FRAME)\n#define INDIRECT_PAGES(_segs) DIV_ROUND_UP(_segs, XEN_PAGES_PER_INDIRECT_FRAME)\n\n/* Not a real protocol.  Used to generate ring structs which contain\n * the elements common to all protocols only.  This way we get a\n * compiler-checkable way to use common struct elements, so we can\n * avoid using switch(protocol) in a number of places.  */\nstruct blkif_common_request {\n\tchar dummy;\n};\n\n/* i386 protocol version */\n\nstruct blkif_x86_32_request_rw {\n\tuint8_t        nr_segments;  /* number of segments                   */\n\tblkif_vdev_t   handle;       /* only for read/write requests         */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tstruct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_discard {\n\tuint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */\n\tblkif_vdev_t   _pad1;        /* was \"handle\" for read/write requests */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tuint64_t       nr_sectors;\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_other {\n\tuint8_t        _pad1;\n\tblkif_vdev_t   _pad2;\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request_indirect {\n\tuint8_t        indirect_op;\n\tuint16_t       nr_segments;\n\tuint64_t       id;\n\tblkif_sector_t sector_number;\n\tblkif_vdev_t   handle;\n\tuint16_t       _pad1;\n\tgrant_ref_t    indirect_grefs[BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST];\n\t/*\n\t * The maximum number of indirect segments (and pages) that will\n\t * be used is determined by MAX_INDIRECT_SEGMENTS, this value\n\t * is also exported to the guest (via xenstore\n\t * feature-max-indirect-segments entry), so the frontend knows how\n\t * many indirect segments the backend supports.\n\t */\n\tuint64_t       _pad2;        /* make it 64 byte aligned */\n} __attribute__((__packed__));\n\nstruct blkif_x86_32_request {\n\tuint8_t        operation;    /* BLKIF_OP_???                         */\n\tunion {\n\t\tstruct blkif_x86_32_request_rw rw;\n\t\tstruct blkif_x86_32_request_discard discard;\n\t\tstruct blkif_x86_32_request_other other;\n\t\tstruct blkif_x86_32_request_indirect indirect;\n\t} u;\n} __attribute__((__packed__));\n\n/* x86_64 protocol version */\n\nstruct blkif_x86_64_request_rw {\n\tuint8_t        nr_segments;  /* number of segments                   */\n\tblkif_vdev_t   handle;       /* only for read/write requests         */\n\tuint32_t       _pad1;        /* offsetof(blkif_reqest..,u.rw.id)==8  */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tstruct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_discard {\n\tuint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */\n\tblkif_vdev_t   _pad1;        /* was \"handle\" for read/write requests */\n        uint32_t       _pad2;        /* offsetof(blkif_..,u.discard.id)==8   */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */\n\tuint64_t       nr_sectors;\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_other {\n\tuint8_t        _pad1;\n\tblkif_vdev_t   _pad2;\n\tuint32_t       _pad3;        /* offsetof(blkif_..,u.discard.id)==8   */\n\tuint64_t       id;           /* private guest value, echoed in resp  */\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request_indirect {\n\tuint8_t        indirect_op;\n\tuint16_t       nr_segments;\n\tuint32_t       _pad1;        /* offsetof(blkif_..,u.indirect.id)==8   */\n\tuint64_t       id;\n\tblkif_sector_t sector_number;\n\tblkif_vdev_t   handle;\n\tuint16_t       _pad2;\n\tgrant_ref_t    indirect_grefs[BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST];\n\t/*\n\t * The maximum number of indirect segments (and pages) that will\n\t * be used is determined by MAX_INDIRECT_SEGMENTS, this value\n\t * is also exported to the guest (via xenstore\n\t * feature-max-indirect-segments entry), so the frontend knows how\n\t * many indirect segments the backend supports.\n\t */\n\tuint32_t       _pad3;        /* make it 64 byte aligned */\n} __attribute__((__packed__));\n\nstruct blkif_x86_64_request {\n\tuint8_t        operation;    /* BLKIF_OP_???                         */\n\tunion {\n\t\tstruct blkif_x86_64_request_rw rw;\n\t\tstruct blkif_x86_64_request_discard discard;\n\t\tstruct blkif_x86_64_request_other other;\n\t\tstruct blkif_x86_64_request_indirect indirect;\n\t} u;\n} __attribute__((__packed__));\n\nDEFINE_RING_TYPES(blkif_common, struct blkif_common_request,\n\t\t  struct blkif_response);\nDEFINE_RING_TYPES(blkif_x86_32, struct blkif_x86_32_request,\n\t\t  struct blkif_response __packed);\nDEFINE_RING_TYPES(blkif_x86_64, struct blkif_x86_64_request,\n\t\t  struct blkif_response);\n\nunion blkif_back_rings {\n\tstruct blkif_back_ring        native;\n\tstruct blkif_common_back_ring common;\n\tstruct blkif_x86_32_back_ring x86_32;\n\tstruct blkif_x86_64_back_ring x86_64;\n};\n\nenum blkif_protocol {\n\tBLKIF_PROTOCOL_NATIVE = 1,\n\tBLKIF_PROTOCOL_X86_32 = 2,\n\tBLKIF_PROTOCOL_X86_64 = 3,\n};\n\n/*\n * Default protocol if the frontend doesn't specify one.\n */\n#ifdef CONFIG_X86\n#  define BLKIF_PROTOCOL_DEFAULT BLKIF_PROTOCOL_X86_32\n#else\n#  define BLKIF_PROTOCOL_DEFAULT BLKIF_PROTOCOL_NATIVE\n#endif\n\nstruct xen_vbd {\n\t/* What the domain refers to this vbd as. */\n\tblkif_vdev_t\t\thandle;\n\t/* Non-zero -> read-only */\n\tunsigned char\t\treadonly;\n\t/* VDISK_xxx */\n\tunsigned char\t\ttype;\n\t/* phys device that this vbd maps to. */\n\tu32\t\t\tpdevice;\n\tstruct block_device\t*bdev;\n\t/* Cached size parameter. */\n\tsector_t\t\tsize;\n\tunsigned int\t\tflush_support:1;\n\tunsigned int\t\tdiscard_secure:1;\n\tunsigned int\t\tfeature_gnt_persistent:1;\n\tunsigned int\t\toverflow_max_grants:1;\n};\n\nstruct backend_info;\n\n/* Number of available flags */\n#define PERSISTENT_GNT_FLAGS_SIZE\t2\n/* This persistent grant is currently in use */\n#define PERSISTENT_GNT_ACTIVE\t\t0\n/*\n * This persistent grant has been used, this flag is set when we remove the\n * PERSISTENT_GNT_ACTIVE, to know that this grant has been used recently.\n */\n#define PERSISTENT_GNT_WAS_ACTIVE\t1\n\n/* Number of requests that we can fit in a ring */\n#define XEN_BLKIF_REQS_PER_PAGE\t\t32\n\nstruct persistent_gnt {\n\tstruct page *page;\n\tgrant_ref_t gnt;\n\tgrant_handle_t handle;\n\tDECLARE_BITMAP(flags, PERSISTENT_GNT_FLAGS_SIZE);\n\tstruct rb_node node;\n\tstruct list_head remove_node;\n};\n\n/* Per-ring information. */\nstruct xen_blkif_ring {\n\t/* Physical parameters of the comms window. */\n\tunsigned int\t\tirq;\n\tunion blkif_back_rings\tblk_rings;\n\tvoid\t\t\t*blk_ring;\n\t/* Private fields. */\n\tspinlock_t\t\tblk_ring_lock;\n\n\twait_queue_head_t\twq;\n\tatomic_t\t\tinflight;\n\tbool\t\t\tactive;\n\t/* One thread per blkif ring. */\n\tstruct task_struct\t*xenblkd;\n\tunsigned int\t\twaiting_reqs;\n\n\t/* List of all 'pending_req' available */\n\tstruct list_head\tpending_free;\n\t/* And its spinlock. */\n\tspinlock_t\t\tpending_free_lock;\n\twait_queue_head_t\tpending_free_wq;\n\n\t/* Tree to store persistent grants. */\n\tspinlock_t\t\tpers_gnts_lock;\n\tstruct rb_root\t\tpersistent_gnts;\n\tunsigned int\t\tpersistent_gnt_c;\n\tatomic_t\t\tpersistent_gnt_in_use;\n\tunsigned long           next_lru;\n\n\t/* Statistics. */\n\tunsigned long\t\tst_print;\n\tunsigned long long\tst_rd_req;\n\tunsigned long long\tst_wr_req;\n\tunsigned long long\tst_oo_req;\n\tunsigned long long\tst_f_req;\n\tunsigned long long\tst_ds_req;\n\tunsigned long long\tst_rd_sect;\n\tunsigned long long\tst_wr_sect;\n\n\t/* Used by the kworker that offload work from the persistent purge. */\n\tstruct list_head\tpersistent_purge_list;\n\tstruct work_struct\tpersistent_purge_work;\n\n\t/* Buffer of free pages to map grant refs. */\n\tspinlock_t\t\tfree_pages_lock;\n\tint\t\t\tfree_pages_num;\n\tstruct list_head\tfree_pages;\n\n\tstruct work_struct\tfree_work;\n\t/* Thread shutdown wait queue. */\n\twait_queue_head_t\tshutdown_wq;\n\tstruct xen_blkif \t*blkif;\n};\n\nstruct xen_blkif {\n\t/* Unique identifier for this interface. */\n\tdomid_t\t\t\tdomid;\n\tunsigned int\t\thandle;\n\t/* Comms information. */\n\tenum blkif_protocol\tblk_protocol;\n\t/* The VBD attached to this interface. */\n\tstruct xen_vbd\t\tvbd;\n\t/* Back pointer to the backend_info. */\n\tstruct backend_info\t*be;\n\tatomic_t\t\trefcnt;\n\t/* for barrier (drain) requests */\n\tstruct completion\tdrain_complete;\n\tatomic_t\t\tdrain;\n\n\tstruct work_struct\tfree_work;\n\tunsigned int \t\tnr_ring_pages;\n\t/* All rings for this device. */\n\tstruct xen_blkif_ring\t*rings;\n\tunsigned int\t\tnr_rings;\n};\n\nstruct seg_buf {\n\tunsigned long offset;\n\tunsigned int nsec;\n};\n\nstruct grant_page {\n\tstruct page \t\t*page;\n\tstruct persistent_gnt\t*persistent_gnt;\n\tgrant_handle_t\t\thandle;\n\tgrant_ref_t\t\tgref;\n};\n\n/*\n * Each outstanding request that we've passed to the lower device layers has a\n * 'pending_req' allocated to it. Each buffer_head that completes decrements\n * the pendcnt towards zero. When it hits zero, the specified domain has a\n * response queued for it, with the saved 'id' passed back.\n */\nstruct pending_req {\n\tstruct xen_blkif_ring   *ring;\n\tu64\t\t\tid;\n\tint\t\t\tnr_segs;\n\tatomic_t\t\tpendcnt;\n\tunsigned short\t\toperation;\n\tint\t\t\tstatus;\n\tstruct list_head\tfree_list;\n\tstruct grant_page\t*segments[MAX_INDIRECT_SEGMENTS];\n\t/* Indirect descriptors */\n\tstruct grant_page\t*indirect_pages[MAX_INDIRECT_PAGES];\n\tstruct seg_buf\t\tseg[MAX_INDIRECT_SEGMENTS];\n\tstruct bio\t\t*biolist[MAX_INDIRECT_SEGMENTS];\n\tstruct gnttab_unmap_grant_ref unmap[MAX_INDIRECT_SEGMENTS];\n\tstruct page                   *unmap_pages[MAX_INDIRECT_SEGMENTS];\n\tstruct gntab_unmap_queue_data gnttab_unmap_data;\n};\n\n\n#define vbd_sz(_v)\t((_v)->bdev->bd_part ? \\\n\t\t\t (_v)->bdev->bd_part->nr_sects : \\\n\t\t\t  get_capacity((_v)->bdev->bd_disk))\n\n#define xen_blkif_get(_b) (atomic_inc(&(_b)->refcnt))\n#define xen_blkif_put(_b)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tif (atomic_dec_and_test(&(_b)->refcnt))\t\\\n\t\t\tschedule_work(&(_b)->free_work);\\\n\t} while (0)\n\nstruct phys_req {\n\tunsigned short\t\tdev;\n\tblkif_sector_t\t\tnr_sects;\n\tstruct block_device\t*bdev;\n\tblkif_sector_t\t\tsector_number;\n};\nint xen_blkif_interface_init(void);\n\nint xen_blkif_xenbus_init(void);\n\nirqreturn_t xen_blkif_be_int(int irq, void *dev_id);\nint xen_blkif_schedule(void *arg);\nint xen_blkif_purge_persistent(void *arg);\nvoid xen_blkbk_free_caches(struct xen_blkif_ring *ring);\n\nint xen_blkbk_flush_diskcache(struct xenbus_transaction xbt,\n\t\t\t      struct backend_info *be, int state);\n\nint xen_blkbk_barrier(struct xenbus_transaction xbt,\n\t\t      struct backend_info *be, int state);\nstruct xenbus_device *xen_blkbk_xenbus(struct backend_info *be);\nvoid xen_blkbk_unmap_purged_grants(struct work_struct *work);\n\nstatic inline void blkif_get_x86_32_req(struct blkif_request *dst,\n\t\t\t\t\tstruct blkif_x86_32_request *src)\n{\n\tint i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;\n\tdst->operation = READ_ONCE(src->operation);\n\tswitch (dst->operation) {\n\tcase BLKIF_OP_READ:\n\tcase BLKIF_OP_WRITE:\n\tcase BLKIF_OP_WRITE_BARRIER:\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tdst->u.rw.nr_segments = src->u.rw.nr_segments;\n\t\tdst->u.rw.handle = src->u.rw.handle;\n\t\tdst->u.rw.id = src->u.rw.id;\n\t\tdst->u.rw.sector_number = src->u.rw.sector_number;\n\t\tbarrier();\n\t\tif (n > dst->u.rw.nr_segments)\n\t\t\tn = dst->u.rw.nr_segments;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst->u.rw.seg[i] = src->u.rw.seg[i];\n\t\tbreak;\n\tcase BLKIF_OP_DISCARD:\n\t\tdst->u.discard.flag = src->u.discard.flag;\n\t\tdst->u.discard.id = src->u.discard.id;\n\t\tdst->u.discard.sector_number = src->u.discard.sector_number;\n\t\tdst->u.discard.nr_sectors = src->u.discard.nr_sectors;\n\t\tbreak;\n\tcase BLKIF_OP_INDIRECT:\n\t\tdst->u.indirect.indirect_op = src->u.indirect.indirect_op;\n\t\tdst->u.indirect.nr_segments = src->u.indirect.nr_segments;\n\t\tdst->u.indirect.handle = src->u.indirect.handle;\n\t\tdst->u.indirect.id = src->u.indirect.id;\n\t\tdst->u.indirect.sector_number = src->u.indirect.sector_number;\n\t\tbarrier();\n\t\tj = min(MAX_INDIRECT_PAGES, INDIRECT_PAGES(dst->u.indirect.nr_segments));\n\t\tfor (i = 0; i < j; i++)\n\t\t\tdst->u.indirect.indirect_grefs[i] =\n\t\t\t\tsrc->u.indirect.indirect_grefs[i];\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Don't know how to translate this op. Only get the\n\t\t * ID so failure can be reported to the frontend.\n\t\t */\n\t\tdst->u.other.id = src->u.other.id;\n\t\tbreak;\n\t}\n}\n\nstatic inline void blkif_get_x86_64_req(struct blkif_request *dst,\n\t\t\t\t\tstruct blkif_x86_64_request *src)\n{\n\tint i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;\n\tdst->operation = READ_ONCE(src->operation);\n\tswitch (dst->operation) {\n\tcase BLKIF_OP_READ:\n\tcase BLKIF_OP_WRITE:\n\tcase BLKIF_OP_WRITE_BARRIER:\n\tcase BLKIF_OP_FLUSH_DISKCACHE:\n\t\tdst->u.rw.nr_segments = src->u.rw.nr_segments;\n\t\tdst->u.rw.handle = src->u.rw.handle;\n\t\tdst->u.rw.id = src->u.rw.id;\n\t\tdst->u.rw.sector_number = src->u.rw.sector_number;\n\t\tbarrier();\n\t\tif (n > dst->u.rw.nr_segments)\n\t\t\tn = dst->u.rw.nr_segments;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst->u.rw.seg[i] = src->u.rw.seg[i];\n\t\tbreak;\n\tcase BLKIF_OP_DISCARD:\n\t\tdst->u.discard.flag = src->u.discard.flag;\n\t\tdst->u.discard.id = src->u.discard.id;\n\t\tdst->u.discard.sector_number = src->u.discard.sector_number;\n\t\tdst->u.discard.nr_sectors = src->u.discard.nr_sectors;\n\t\tbreak;\n\tcase BLKIF_OP_INDIRECT:\n\t\tdst->u.indirect.indirect_op = src->u.indirect.indirect_op;\n\t\tdst->u.indirect.nr_segments = src->u.indirect.nr_segments;\n\t\tdst->u.indirect.handle = src->u.indirect.handle;\n\t\tdst->u.indirect.id = src->u.indirect.id;\n\t\tdst->u.indirect.sector_number = src->u.indirect.sector_number;\n\t\tbarrier();\n\t\tj = min(MAX_INDIRECT_PAGES, INDIRECT_PAGES(dst->u.indirect.nr_segments));\n\t\tfor (i = 0; i < j; i++)\n\t\t\tdst->u.indirect.indirect_grefs[i] =\n\t\t\t\tsrc->u.indirect.indirect_grefs[i];\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Don't know how to translate this op. Only get the\n\t\t * ID so failure can be reported to the frontend.\n\t\t */\n\t\tdst->u.other.id = src->u.other.id;\n\t\tbreak;\n\t}\n}\n\n#endif /* __XEN_BLKIF__BACKEND__COMMON_H__ */\n"], "filenames": ["drivers/block/xen-blkback/blkback.c", "drivers/block/xen-blkback/common.h"], "buggy_code_start_loc": [1436, 78], "buggy_code_end_loc": [1463, 208], "fixing_code_start_loc": [1436, 78], "fixing_code_end_loc": [1465, 193], "type": "CWE-200", "message": "The make_response function in drivers/block/xen-blkback/blkback.c in the Linux kernel before 4.11.8 allows guest OS users to obtain sensitive information from host OS (or other guest OS) kernel memory by leveraging the copying of uninitialized padding fields in Xen block-interface response structures, aka XSA-216.", "other": {"cve": {"id": "CVE-2017-10911", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-05T01:29:00.550", "lastModified": "2018-09-07T10:29:02.227", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The make_response function in drivers/block/xen-blkback/blkback.c in the Linux kernel before 4.11.8 allows guest OS users to obtain sensitive information from host OS (or other guest OS) kernel memory by leveraging the copying of uninitialized padding fields in Xen block-interface response structures, aka XSA-216."}, {"lang": "es", "value": "La funci\u00f3n make_response en el archivo drivers/block/xen-blkback/blkback.c en el kernel de Linux anterior a versi\u00f3n 4.11.8, permite a los usuarios del sistema operativo invitado obtener informaci\u00f3n confidencial de la memoria del kernel del sistema operativo host (u otro sistema operativo invitado) mediante el aprovechamiento de la copia de campos de relleno no inicializados en estructuras de respuesta de la interfaz del bloque Xen, tambi\u00e9n se conoce como XSA-216."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.0, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.11.7", "matchCriteriaId": "5556BED7-53AD-4C99-8470-F833F13AB73C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=089bc0143f489bd3a4578bdff5f4ca68fb26f341", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3920", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2017/dsa-3927", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2017/dsa-3945", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99162", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038720", "source": "cve@mitre.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/089bc0143f489bd3a4578bdff5f4ca68fb26f341", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00007.html", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201708-03", "source": "cve@mitre.org"}, {"url": "https://xenbits.xen.org/xsa/advisory-216.html", "source": "cve@mitre.org", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/089bc0143f489bd3a4578bdff5f4ca68fb26f341"}}