{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        DDDD   RRRR    AAA   W   W                           %\n%                        D   D  R   R  A   A  W   W                           %\n%                        D   D  RRRR   AAAAA  W W W                           %\n%                        D   D  R RN   A   A  WW WW                           %\n%                        DDDD   R  R   A   A  W   W                           %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Drawing Methods                        %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Bill Radcliffe of Corbis (www.corbis.com) contributed the polygon\n% rendering code based on Paul Heckbert's \"Concave Polygon Scan Conversion\",\n% Graphics Gems, 1990.  Leonard Rosenthal and David Harr of Appligent\n% (www.appligent.com) contributed the dash pattern, linecap stroking\n% algorithm, and minor rendering improvements.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resample-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define AntialiasThreshold  (1.0/3.0)\n#define BezierQuantum  200\n#define PrimitiveExtentPad  4296.0\n#define MaxBezierCoordinates  67108864\n#define ThrowPointExpectedException(token,exception) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DrawError, \\\n    \"NonconformingDrawingPrimitiveDefinition\",\"`%s'\",token); \\\n  status=MagickFalse; \\\n  break; \\\n}\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _EdgeInfo\n{\n  SegmentInfo\n    bounds;\n\n  double\n    scanline;\n\n  PointInfo\n    *points;\n\n  size_t\n    number_points;\n\n  ssize_t\n    direction;\n\n  MagickBooleanType\n    ghostline;\n\n  size_t\n    highwater;\n} EdgeInfo;\n\ntypedef struct _ElementInfo\n{\n  double\n    cx,\n    cy,\n    major,\n    minor,\n    angle;\n} ElementInfo;\n\ntypedef struct _MVGInfo\n{\n  PrimitiveInfo\n    **primitive_info;\n\n  size_t\n    *extent;\n\n  ssize_t\n    offset;\n\n  PointInfo\n    point;\n\n  ExceptionInfo\n    *exception;\n} MVGInfo;\n\ntypedef struct _PolygonInfo\n{\n  EdgeInfo\n    *edges;\n\n  size_t\n    number_edges;\n} PolygonInfo;\n\ntypedef enum\n{\n  MoveToCode,\n  OpenCode,\n  GhostlineCode,\n  LineToCode,\n  EndCode\n} PathInfoCode;\n\ntypedef struct _PathInfo\n{\n  PointInfo\n    point;\n\n  PathInfoCode\n    code;\n} PathInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image\n  *DrawClippingMask(Image *,const DrawInfo *,const char *,const char *,\n    ExceptionInfo *);\n\nstatic MagickBooleanType\n  DrawStrokePolygon(Image *,const DrawInfo *,const PrimitiveInfo *,\n    ExceptionInfo *),\n  RenderMVGContent(Image *,const DrawInfo *,const size_t,ExceptionInfo *),\n  TraceArc(MVGInfo *,const PointInfo,const PointInfo,const PointInfo),\n  TraceArcPath(MVGInfo *,const PointInfo,const PointInfo,const PointInfo,\n    const double,const MagickBooleanType,const MagickBooleanType),\n  TraceBezier(MVGInfo *,const size_t),\n  TraceCircle(MVGInfo *,const PointInfo,const PointInfo),\n  TraceEllipse(MVGInfo *,const PointInfo,const PointInfo,const PointInfo),\n  TraceLine(PrimitiveInfo *,const PointInfo,const PointInfo),\n  TraceRectangle(PrimitiveInfo *,const PointInfo,const PointInfo),\n  TraceRoundRectangle(MVGInfo *,const PointInfo,const PointInfo,PointInfo),\n  TraceSquareLinecap(PrimitiveInfo *,const size_t,const double);\n\nstatic PrimitiveInfo\n  *TraceStrokePolygon(const DrawInfo *,const PrimitiveInfo *,ExceptionInfo *);\n\nstatic ssize_t\n  TracePath(MVGInfo *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e D r a w I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireDrawInfo() returns a DrawInfo structure properly initialized.\n%\n%  The format of the AcquireDrawInfo method is:\n%\n%      DrawInfo *AcquireDrawInfo(void)\n%\n*/\nMagickExport DrawInfo *AcquireDrawInfo(void)\n{\n  DrawInfo\n    *draw_info;\n\n  draw_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*draw_info));\n  GetDrawInfo((ImageInfo *) NULL,draw_info);\n  return(draw_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e D r a w I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneDrawInfo() makes a copy of the given draw_info structure.  If NULL\n%  is specified, a new DrawInfo structure is created initialized to default\n%  values.\n%\n%  The format of the CloneDrawInfo method is:\n%\n%      DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n%        const DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n  const DrawInfo *draw_info)\n{\n  DrawInfo\n    *clone_info;\n\n  ExceptionInfo\n    *exception;\n\n  clone_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetDrawInfo(image_info,clone_info);\n  if (draw_info == (DrawInfo *) NULL)\n    return(clone_info);\n  exception=AcquireExceptionInfo();\n  if (draw_info->id != (char *) NULL)\n    (void) CloneString(&clone_info->id,draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    (void) CloneString(&clone_info->primitive,draw_info->primitive);\n  if (draw_info->geometry != (char *) NULL)\n    (void) CloneString(&clone_info->geometry,draw_info->geometry);\n  clone_info->compliance=draw_info->compliance;\n  clone_info->viewbox=draw_info->viewbox;\n  clone_info->affine=draw_info->affine;\n  clone_info->gravity=draw_info->gravity;\n  clone_info->fill=draw_info->fill;\n  clone_info->stroke=draw_info->stroke;\n  clone_info->stroke_width=draw_info->stroke_width;\n  if (draw_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(draw_info->fill_pattern,0,0,MagickTrue,\n      exception);\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=CloneImage(draw_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke_antialias=draw_info->stroke_antialias;\n  clone_info->text_antialias=draw_info->text_antialias;\n  clone_info->fill_rule=draw_info->fill_rule;\n  clone_info->linecap=draw_info->linecap;\n  clone_info->linejoin=draw_info->linejoin;\n  clone_info->miterlimit=draw_info->miterlimit;\n  clone_info->dash_offset=draw_info->dash_offset;\n  clone_info->decorate=draw_info->decorate;\n  clone_info->compose=draw_info->compose;\n  if (draw_info->text != (char *) NULL)\n    (void) CloneString(&clone_info->text,draw_info->text);\n  if (draw_info->font != (char *) NULL)\n    (void) CloneString(&clone_info->font,draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    (void) CloneString(&clone_info->metrics,draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    (void) CloneString(&clone_info->family,draw_info->family);\n  clone_info->style=draw_info->style;\n  clone_info->stretch=draw_info->stretch;\n  clone_info->weight=draw_info->weight;\n  if (draw_info->encoding != (char *) NULL)\n    (void) CloneString(&clone_info->encoding,draw_info->encoding);\n  clone_info->pointsize=draw_info->pointsize;\n  clone_info->kerning=draw_info->kerning;\n  clone_info->interline_spacing=draw_info->interline_spacing;\n  clone_info->interword_spacing=draw_info->interword_spacing;\n  clone_info->direction=draw_info->direction;\n  clone_info->word_break=draw_info->word_break;\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&clone_info->density,draw_info->density);\n  clone_info->align=draw_info->align;\n  clone_info->undercolor=draw_info->undercolor;\n  clone_info->border_color=draw_info->border_color;\n  if (draw_info->server_name != (char *) NULL)\n    (void) CloneString(&clone_info->server_name,draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    {\n      ssize_t\n        x;\n\n      for (x=0; fabs(draw_info->dash_pattern[x]) >= MagickEpsilon; x++) ;\n      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) (2*x+2),\n        sizeof(*clone_info->dash_pattern));\n      if (clone_info->dash_pattern == (double *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memset(clone_info->dash_pattern,0,(size_t) (2*x+2)*\n        sizeof(*clone_info->dash_pattern));\n      (void) memcpy(clone_info->dash_pattern,draw_info->dash_pattern,(size_t)\n        (x+1)*sizeof(*clone_info->dash_pattern));\n    }\n  clone_info->gradient=draw_info->gradient;\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    {\n      size_t\n        number_stops;\n\n      number_stops=clone_info->gradient.number_stops;\n      clone_info->gradient.stops=(StopInfo *) AcquireQuantumMemory((size_t)\n        number_stops,sizeof(*clone_info->gradient.stops));\n      if (clone_info->gradient.stops == (StopInfo *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memcpy(clone_info->gradient.stops,draw_info->gradient.stops,\n        (size_t) number_stops*sizeof(*clone_info->gradient.stops));\n    }\n  clone_info->bounds=draw_info->bounds;\n  clone_info->fill_alpha=draw_info->fill_alpha;\n  clone_info->stroke_alpha=draw_info->stroke_alpha;\n  clone_info->element_reference=draw_info->element_reference;\n  clone_info->clip_path=draw_info->clip_path;\n  clone_info->clip_units=draw_info->clip_units;\n  if (draw_info->clip_mask != (char *) NULL)\n    (void) CloneString(&clone_info->clip_mask,draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    clone_info->clipping_mask=CloneImage(draw_info->clipping_mask,0,0,\n      MagickTrue,exception);\n  if (draw_info->composite_mask != (Image *) NULL)\n    clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,\n      MagickTrue,exception);\n  clone_info->render=draw_info->render;\n  clone_info->image_info=CloneImageInfo(draw_info->image_info);\n  clone_info->debug=draw_info->debug;\n  exception=DestroyExceptionInfo(exception);\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C o n v e r t P a t h T o P o l y g o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConvertPathToPolygon() converts a path to the more efficient sorted\n%  rendering form.\n%\n%  The format of the ConvertPathToPolygon method is:\n%\n%      PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o ConvertPathToPolygon() returns the path in a more efficient sorted\n%      rendering form of type PolygonInfo.\n%\n%    o draw_info: Specifies a pointer to an DrawInfo structure.\n%\n%    o path_info: Specifies a pointer to an PathInfo structure.\n%\n%\n*/\n\nstatic PolygonInfo *DestroyPolygonInfo(PolygonInfo *polygon_info)\n{\n  ssize_t\n    i;\n\n  if (polygon_info->edges != (EdgeInfo *) NULL)\n    {\n      for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n        if (polygon_info->edges[i].points != (PointInfo *) NULL)\n          polygon_info->edges[i].points=(PointInfo *)\n            RelinquishMagickMemory(polygon_info->edges[i].points);\n      polygon_info->edges=(EdgeInfo *) RelinquishMagickMemory(\n        polygon_info->edges);\n    }\n  return((PolygonInfo *) RelinquishMagickMemory(polygon_info));\n}\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int DrawCompareEdges(const void *p_edge,const void *q_edge)\n{\n#define DrawCompareEdge(p,q) \\\n{ \\\n  if (((p)-(q)) < 0.0) \\\n    return(-1); \\\n  if (((p)-(q)) > 0.0) \\\n    return(1); \\\n}\n\n  const PointInfo\n    *p,\n    *q;\n\n  /*\n    Edge sorting for right-handed coordinate system.\n  */\n  p=((const EdgeInfo *) p_edge)->points;\n  q=((const EdgeInfo *) q_edge)->points;\n  DrawCompareEdge(p[0].y,q[0].y);\n  DrawCompareEdge(p[0].x,q[0].x);\n  DrawCompareEdge((p[1].x-p[0].x)*(q[1].y-q[0].y),(p[1].y-p[0].y)*\n    (q[1].x-q[0].x));\n  DrawCompareEdge(p[1].y,q[1].y);\n  DrawCompareEdge(p[1].x,q[1].x);\n  return(0);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic void LogPolygonInfo(const PolygonInfo *polygon_info)\n{\n  EdgeInfo\n    *p;\n\n  ssize_t\n    i,\n    j;\n\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin active-edge\");\n  p=polygon_info->edges;\n  for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n  {\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      edge %.20g:\",\n      (double) i);\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      direction: %s\",\n      p->direction != MagickFalse ? \"down\" : \"up\");\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      ghostline: %s\",\n      p->ghostline != MagickFalse ? \"transparent\" : \"opaque\");\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"      bounds: %g,%g - %g,%g\",p->bounds.x1,p->bounds.y1,\n      p->bounds.x2,p->bounds.y2);\n    for (j=0; j < (ssize_t) p->number_points; j++)\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"        %g,%g\",\n        p->points[j].x,p->points[j].y);\n    p++;\n  }\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end active-edge\");\n}\n\nstatic void ReversePoints(PointInfo *points,const size_t number_points)\n{\n  PointInfo\n    point;\n\n  ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) (number_points >> 1); i++)\n  {\n    point=points[i];\n    points[i]=points[number_points-(i+1)];\n    points[number_points-(i+1)]=point;\n  }\n}\n\nstatic PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info,\n  ExceptionInfo *exception)\n{\n  long\n    direction,\n    next_direction;\n\n  PointInfo\n    point,\n    *points;\n\n  PolygonInfo\n    *polygon_info;\n\n  SegmentInfo\n    bounds;\n\n  ssize_t\n    i,\n    n;\n\n  MagickBooleanType\n    ghostline;\n\n  size_t\n    edge,\n    number_edges,\n    number_points;\n\n  /*\n    Convert a path to the more efficient sorted rendering form.\n  */\n  polygon_info=(PolygonInfo *) AcquireMagickMemory(sizeof(*polygon_info));\n  if (polygon_info == (PolygonInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PolygonInfo *) NULL);\n    }\n  number_edges=16;\n  polygon_info->edges=(EdgeInfo *) AcquireQuantumMemory(number_edges,\n    sizeof(*polygon_info->edges));\n  if (polygon_info->edges == (EdgeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonInfo(polygon_info));\n    }\n  (void) memset(polygon_info->edges,0,number_edges*\n    sizeof(*polygon_info->edges));\n  direction=0;\n  edge=0;\n  ghostline=MagickFalse;\n  n=0;\n  number_points=0;\n  points=(PointInfo *) NULL;\n  (void) memset(&point,0,sizeof(point));\n  (void) memset(&bounds,0,sizeof(bounds));\n  polygon_info->edges[edge].number_points=(size_t) n;\n  polygon_info->edges[edge].scanline=0.0;\n  polygon_info->edges[edge].highwater=0;\n  polygon_info->edges[edge].ghostline=ghostline;\n  polygon_info->edges[edge].direction=(ssize_t) direction;\n  polygon_info->edges[edge].points=points;\n  polygon_info->edges[edge].bounds=bounds;\n  polygon_info->number_edges=0;\n  for (i=0; path_info[i].code != EndCode; i++)\n  {\n    if ((path_info[i].code == MoveToCode) || (path_info[i].code == OpenCode) ||\n        (path_info[i].code == GhostlineCode))\n      {\n        /*\n          Move to.\n        */\n        if ((points != (PointInfo *) NULL) && (n >= 2))\n          {\n            if (edge == number_edges)\n              {\n                number_edges<<=1;\n                polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n                  polygon_info->edges,(size_t) number_edges,\n                  sizeof(*polygon_info->edges));\n                if (polygon_info->edges == (EdgeInfo *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                    points=(PointInfo *) RelinquishMagickMemory(points);\n                    return(DestroyPolygonInfo(polygon_info));\n                  }\n              }\n            polygon_info->edges[edge].number_points=(size_t) n;\n            polygon_info->edges[edge].scanline=(-1.0);\n            polygon_info->edges[edge].highwater=0;\n            polygon_info->edges[edge].ghostline=ghostline;\n            polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n            if (direction < 0)\n              ReversePoints(points,(size_t) n);\n            polygon_info->edges[edge].points=points;\n            polygon_info->edges[edge].bounds=bounds;\n            polygon_info->edges[edge].bounds.y1=points[0].y;\n            polygon_info->edges[edge].bounds.y2=points[n-1].y;\n            points=(PointInfo *) NULL;\n            ghostline=MagickFalse;\n            edge++;\n            polygon_info->number_edges=edge;\n          }\n        if (points == (PointInfo *) NULL)\n          {\n            number_points=16;\n            points=(PointInfo *) AcquireQuantumMemory((size_t) number_points,\n              sizeof(*points));\n            if (points == (PointInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                return(DestroyPolygonInfo(polygon_info));\n              }\n          }\n        ghostline=path_info[i].code == GhostlineCode ? MagickTrue : MagickFalse;\n        point=path_info[i].point;\n        points[0]=point;\n        bounds.x1=point.x;\n        bounds.x2=point.x;\n        direction=0;\n        n=1;\n        continue;\n      }\n    /*\n      Line to.\n    */\n    next_direction=((path_info[i].point.y > point.y) ||\n      ((fabs(path_info[i].point.y-point.y) < MagickEpsilon) &&\n       (path_info[i].point.x > point.x))) ? 1 : -1;\n    if ((points != (PointInfo *) NULL) && (direction != 0) &&\n        (direction != next_direction))\n      {\n        /*\n          New edge.\n        */\n        point=points[n-1];\n        if (edge == number_edges)\n          {\n            number_edges<<=1;\n            polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n              polygon_info->edges,(size_t) number_edges,\n              sizeof(*polygon_info->edges));\n            if (polygon_info->edges == (EdgeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                points=(PointInfo *) RelinquishMagickMemory(points);\n                return(DestroyPolygonInfo(polygon_info));\n              }\n          }\n        polygon_info->edges[edge].number_points=(size_t) n;\n        polygon_info->edges[edge].scanline=(-1.0);\n        polygon_info->edges[edge].highwater=0;\n        polygon_info->edges[edge].ghostline=ghostline;\n        polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n        if (direction < 0)\n          ReversePoints(points,(size_t) n);\n        polygon_info->edges[edge].points=points;\n        polygon_info->edges[edge].bounds=bounds;\n        polygon_info->edges[edge].bounds.y1=points[0].y;\n        polygon_info->edges[edge].bounds.y2=points[n-1].y;\n        polygon_info->number_edges=edge+1;\n        points=(PointInfo *) NULL;\n        number_points=16;\n        points=(PointInfo *) AcquireQuantumMemory((size_t) number_points,\n          sizeof(*points));\n        if (points == (PointInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n            return(DestroyPolygonInfo(polygon_info));\n          }\n        n=1;\n        ghostline=MagickFalse;\n        points[0]=point;\n        bounds.x1=point.x;\n        bounds.x2=point.x;\n        edge++;\n      }\n    direction=next_direction;\n    if (points == (PointInfo *) NULL)\n      continue;\n    if (n == (ssize_t) number_points)\n      {\n        number_points<<=1;\n        points=(PointInfo *) ResizeQuantumMemory(points,(size_t) number_points,\n          sizeof(*points));\n        if (points == (PointInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n            return(DestroyPolygonInfo(polygon_info));\n          }\n      }\n    point=path_info[i].point;\n    points[n]=point;\n    if (point.x < bounds.x1)\n      bounds.x1=point.x;\n    if (point.x > bounds.x2)\n      bounds.x2=point.x;\n    n++;\n  }\n  if (points != (PointInfo *) NULL)\n    {\n      if (n < 2)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      else\n        {\n          if (edge == number_edges)\n            {\n              number_edges<<=1;\n              polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n                polygon_info->edges,(size_t) number_edges,\n                sizeof(*polygon_info->edges));\n              if (polygon_info->edges == (EdgeInfo *) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  return(DestroyPolygonInfo(polygon_info));\n                }\n            }\n          polygon_info->edges[edge].number_points=(size_t) n;\n          polygon_info->edges[edge].scanline=(-1.0);\n          polygon_info->edges[edge].highwater=0;\n          polygon_info->edges[edge].ghostline=ghostline;\n          polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n          if (direction < 0)\n            ReversePoints(points,(size_t) n);\n          polygon_info->edges[edge].points=points;\n          polygon_info->edges[edge].bounds=bounds;\n          polygon_info->edges[edge].bounds.y1=points[0].y;\n          polygon_info->edges[edge].bounds.y2=points[n-1].y;\n          points=(PointInfo *) NULL;\n          ghostline=MagickFalse;\n          edge++;\n          polygon_info->number_edges=edge;\n        }\n    }\n  polygon_info->number_edges=edge;\n  polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(polygon_info->edges,\n    polygon_info->number_edges,sizeof(*polygon_info->edges));\n  if (polygon_info->edges == (EdgeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonInfo(polygon_info));\n    }\n  for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n  {\n    EdgeInfo\n      *edge_info;\n\n    edge_info=polygon_info->edges+i;\n    edge_info->points=(PointInfo *) ResizeQuantumMemory(edge_info->points,\n      edge_info->number_points,sizeof(*edge_info->points));\n    if (edge_info->points == (PointInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(DestroyPolygonInfo(polygon_info));\n      }\n  }\n  qsort(polygon_info->edges,(size_t) polygon_info->number_edges,\n    sizeof(*polygon_info->edges),DrawCompareEdges);\n  if ((GetLogEventMask() & DrawEvent) != 0)\n    LogPolygonInfo(polygon_info);\n  return(polygon_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C o n v e r t P r i m i t i v e T o P a t h                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConvertPrimitiveToPath() converts a PrimitiveInfo structure into a vector\n%  path structure.\n%\n%  The format of the ConvertPrimitiveToPath method is:\n%\n%      PathInfo *ConvertPrimitiveToPath(const DrawInfo *draw_info,\n%        const PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o ConvertPrimitiveToPath() returns a vector path structure of type\n%      PathInfo.\n%\n%    o draw_info: a structure of type DrawInfo.\n%\n%    o primitive_info: Specifies a pointer to an PrimitiveInfo structure.\n%\n*/\n\nstatic void LogPathInfo(const PathInfo *path_info)\n{\n  const PathInfo\n    *p;\n\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin vector-path\");\n  for (p=path_info; p->code != EndCode; p++)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"      %g,%g %s\",p->point.x,p->point.y,p->code == GhostlineCode ?\n      \"moveto ghostline\" : p->code == OpenCode ? \"moveto open\" :\n      p->code == MoveToCode ? \"moveto\" : p->code == LineToCode ? \"lineto\" :\n      \"?\");\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end vector-path\");\n}\n\nstatic PathInfo *ConvertPrimitiveToPath(const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    closed_subpath;\n\n  PathInfo\n    *path_info;\n\n  PathInfoCode\n    code;\n\n  PointInfo\n    p,\n    q;\n\n  ssize_t\n    i,\n    n;\n\n  ssize_t\n    coordinates,\n    start;\n\n  /*\n    Converts a PrimitiveInfo structure into a vector path structure.\n  */\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    case ColorPrimitive:\n    case ImagePrimitive:\n    case PointPrimitive:\n    case TextPrimitive:\n      return((PathInfo *) NULL);\n    default:\n      break;\n  }\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  path_info=(PathInfo *) AcquireQuantumMemory((size_t) (3UL*i+1UL),\n    sizeof(*path_info));\n  if (path_info == (PathInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PathInfo *) NULL);\n    }\n  coordinates=0;\n  closed_subpath=MagickFalse;\n  n=0;\n  p.x=(-1.0);\n  p.y=(-1.0);\n  q.x=(-1.0);\n  q.y=(-1.0);\n  start=0;\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n  {\n    code=LineToCode;\n    if (coordinates <= 0)\n      {\n        /*\n          New subpath.\n        */\n        coordinates=(ssize_t) primitive_info[i].coordinates;\n        p=primitive_info[i].point;\n        start=n;\n        code=MoveToCode;\n        closed_subpath=primitive_info[i].closed_subpath;\n      }\n    coordinates--;\n    if ((code == MoveToCode) || (coordinates <= 0) ||\n        (fabs(q.x-primitive_info[i].point.x) >= MagickEpsilon) ||\n        (fabs(q.y-primitive_info[i].point.y) >= MagickEpsilon))\n      {\n        /*\n          Eliminate duplicate points.\n        */\n        path_info[n].code=code;\n        path_info[n].point=primitive_info[i].point;\n        q=primitive_info[i].point;\n        n++;\n      }\n    if (coordinates > 0)\n      continue;  /* next point in current subpath */\n    if (closed_subpath != MagickFalse)\n      {\n        closed_subpath=MagickFalse;\n        continue;\n      }\n    /*\n      Mark the p point as open if the subpath is not closed.\n    */\n    path_info[start].code=OpenCode;\n    path_info[n].code=GhostlineCode;\n    path_info[n].point=primitive_info[i].point;\n    n++;\n    path_info[n].code=LineToCode;\n    path_info[n].point=p;\n    n++;\n  }\n  path_info[n].code=EndCode;\n  path_info[n].point.x=0.0;\n  path_info[n].point.y=0.0;\n  if (IsEventLogging() != MagickFalse)\n    LogPathInfo(path_info);\n  path_info=(PathInfo *) ResizeQuantumMemory(path_info,(size_t) (n+1),\n    sizeof(*path_info));\n  return(path_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y D r a w I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyDrawInfo() deallocates memory associated with an DrawInfo structure.\n%\n%  The format of the DestroyDrawInfo method is:\n%\n%      DrawInfo *DestroyDrawInfo(DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport DrawInfo *DestroyDrawInfo(DrawInfo *draw_info)\n{\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (draw_info->id != (char *) NULL)\n    draw_info->id=DestroyString(draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    draw_info->primitive=DestroyString(draw_info->primitive);\n  if (draw_info->text != (char *) NULL)\n    draw_info->text=DestroyString(draw_info->text);\n  if (draw_info->geometry != (char *) NULL)\n    draw_info->geometry=DestroyString(draw_info->geometry);\n  if (draw_info->fill_pattern != (Image *) NULL)\n    draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    draw_info->stroke_pattern=DestroyImage(draw_info->stroke_pattern);\n  if (draw_info->font != (char *) NULL)\n    draw_info->font=DestroyString(draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    draw_info->metrics=DestroyString(draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    draw_info->family=DestroyString(draw_info->family);\n  if (draw_info->encoding != (char *) NULL)\n    draw_info->encoding=DestroyString(draw_info->encoding);\n  if (draw_info->density != (char *) NULL)\n    draw_info->density=DestroyString(draw_info->density);\n  if (draw_info->server_name != (char *) NULL)\n    draw_info->server_name=(char *)\n     RelinquishMagickMemory(draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    draw_info->dash_pattern=(double *) RelinquishMagickMemory(\n      draw_info->dash_pattern);\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    draw_info->gradient.stops=(StopInfo *) RelinquishMagickMemory(\n      draw_info->gradient.stops);\n  if (draw_info->clip_mask != (char *) NULL)\n    draw_info->clip_mask=DestroyString(draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    draw_info->clipping_mask=DestroyImage(draw_info->clipping_mask);\n  if (draw_info->composite_mask != (Image *) NULL)\n    draw_info->composite_mask=DestroyImage(draw_info->composite_mask);\n  if (draw_info->image_info != (ImageInfo *) NULL)\n    draw_info->image_info=DestroyImageInfo(draw_info->image_info);\n  draw_info->signature=(~MagickCoreSignature);\n  draw_info=(DrawInfo *) RelinquishMagickMemory(draw_info);\n  return(draw_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     D r a w A f f i n e I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawAffineImage() composites the source over the destination image as\n%  dictated by the affine transform.\n%\n%  The format of the DrawAffineImage method is:\n%\n%      MagickBooleanType DrawAffineImage(Image *image,const Image *source,\n%        const AffineMatrix *affine,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o source: the source image.\n%\n%    o affine: the affine transform.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic SegmentInfo AffineEdge(const Image *image,const AffineMatrix *affine,\n  const double y,const SegmentInfo *edge)\n{\n  double\n    intercept,\n    z;\n\n  double\n    x;\n\n  SegmentInfo\n    inverse_edge;\n\n  /*\n    Determine left and right edges.\n  */\n  inverse_edge.x1=edge->x1;\n  inverse_edge.y1=edge->y1;\n  inverse_edge.x2=edge->x2;\n  inverse_edge.y2=edge->y2;\n  z=affine->ry*y+affine->tx;\n  if (affine->sx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->sx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->columns)/affine->sx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->sx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->columns)/affine->sx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->sx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->columns))\n        {\n          inverse_edge.x2=edge->x1;\n          return(inverse_edge);\n        }\n  /*\n    Determine top and bottom edges.\n  */\n  z=affine->sy*y+affine->ty;\n  if (affine->rx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->rx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->rows)/affine->rx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->rx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->rows)/affine->rx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->rx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->rows))\n        {\n          inverse_edge.x2=edge->x2;\n          return(inverse_edge);\n        }\n  return(inverse_edge);\n}\n\nstatic AffineMatrix InverseAffineMatrix(const AffineMatrix *affine)\n{\n  AffineMatrix\n    inverse_affine;\n\n  double\n    determinant;\n\n  determinant=PerceptibleReciprocal(affine->sx*affine->sy-affine->rx*\n    affine->ry);\n  inverse_affine.sx=determinant*affine->sy;\n  inverse_affine.rx=determinant*(-affine->rx);\n  inverse_affine.ry=determinant*(-affine->ry);\n  inverse_affine.sy=determinant*affine->sx;\n  inverse_affine.tx=(-affine->tx)*inverse_affine.sx-affine->ty*\n    inverse_affine.ry;\n  inverse_affine.ty=(-affine->tx)*inverse_affine.rx-affine->ty*\n    inverse_affine.sy;\n  return(inverse_affine);\n}\n\nMagickExport MagickBooleanType DrawAffineImage(Image *image,\n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception)\n{\n  AffineMatrix\n    inverse_affine;\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    zero;\n\n  PointInfo\n    extent[4],\n    min,\n    max;\n\n  ssize_t\n    i;\n\n  SegmentInfo\n    edge;\n\n  ssize_t\n    start,\n    stop,\n    y;\n\n  /*\n    Determine bounding box.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(source != (const Image *) NULL);\n  assert(source->signature == MagickCoreSignature);\n  assert(affine != (AffineMatrix *) NULL);\n  extent[0].x=0.0;\n  extent[0].y=0.0;\n  extent[1].x=(double) source->columns;\n  extent[1].y=0.0;\n  extent[2].x=(double) source->columns;\n  extent[2].y=(double) source->rows;\n  extent[3].x=0.0;\n  extent[3].y=(double) source->rows;\n  for (i=0; i < 4; i++)\n  {\n    PointInfo\n      point;\n\n    point=extent[i];\n    extent[i].x=point.x*affine->sx+point.y*affine->ry+affine->tx;\n    extent[i].y=point.x*affine->rx+point.y*affine->sy+affine->ty;\n  }\n  min=extent[0];\n  max=extent[0];\n  for (i=1; i < 4; i++)\n  {\n    if (min.x > extent[i].x)\n      min.x=extent[i].x;\n    if (min.y > extent[i].y)\n      min.y=extent[i].y;\n    if (max.x < extent[i].x)\n      max.x=extent[i].x;\n    if (max.y < extent[i].y)\n      max.y=extent[i].y;\n  }\n  /*\n    Affine transform image.\n  */\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  edge.x1=min.x;\n  edge.y1=min.y;\n  edge.x2=max.x;\n  edge.y2=max.y;\n  inverse_affine=InverseAffineMatrix(affine);\n  if (edge.y1 < 0.0)\n    edge.y1=0.0;\n  if (edge.y2 > (image->rows-1.0))\n    edge.y2=image->rows-1.0;\n  GetPixelInfo(image,&zero);\n  start=CastDoubleToLong(ceil(edge.y1-0.5));\n  stop=CastDoubleToLong(floor(edge.y2+0.5));\n  source_view=AcquireVirtualCacheView(source,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(source,image,stop-start,1)\n#endif\n  for (y=start; y <= stop; y++)\n  {\n    PixelInfo\n      composite,\n      pixel;\n\n    PointInfo\n      point;\n\n    Quantum\n      *magick_restrict q;\n\n    SegmentInfo\n      inverse_edge;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge);\n    if (inverse_edge.x2 < inverse_edge.x1)\n      continue;\n    if (inverse_edge.x1 < 0.0)\n      inverse_edge.x1=0.0;\n    if (inverse_edge.x2 > image->columns-1.0)\n      inverse_edge.x2=image->columns-1.0;\n    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToLong(\n      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToLong(floor(\n      inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1),1,exception);\n    if (q == (Quantum *) NULL)\n      continue;\n    pixel=zero;\n    composite=zero;\n    for (x=CastDoubleToLong(ceil(inverse_edge.x1-0.5));\n         x <= CastDoubleToLong(floor(inverse_edge.x2+0.5)); x++)\n    {\n      point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+\n        inverse_affine.tx;\n      point.y=(double) x*inverse_affine.rx+y*inverse_affine.sy+\n        inverse_affine.ty;\n      status=InterpolatePixelInfo(source,source_view,UndefinedInterpolatePixel,\n        point.x,point.y,&pixel,exception);\n      if (status == MagickFalse)\n        break;\n      GetPixelInfoPixel(image,q,&composite);\n      CompositePixelInfoOver(&pixel,pixel.alpha,&composite,composite.alpha,\n        &composite);\n      SetPixelViaPixelInfo(image,&composite,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w B o u n d i n g R e c t a n g l e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawBoundingRectangles() draws the bounding rectangles on the image.  This\n%  is only useful for developers debugging the rendering algorithm.\n%\n%  The format of the DrawBoundingRectangles method is:\n%\n%      MagickBooleanType DrawBoundingRectangles(Image *image,\n%        const DrawInfo *draw_info,PolygonInfo *polygon_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o polygon_info: Specifies a pointer to a PolygonInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType DrawBoundingRectangles(Image *image,\n  const DrawInfo *draw_info,const PolygonInfo *polygon_info,\n  ExceptionInfo *exception)\n{\n  double\n    mid;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  PointInfo\n    end,\n    resolution,\n    start;\n\n  PrimitiveInfo\n    primitive_info[6];\n\n  ssize_t\n    i;\n\n  SegmentInfo\n    bounds;\n\n  ssize_t\n    coordinates;\n\n  (void) memset(primitive_info,0,sizeof(primitive_info));\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  status=QueryColorCompliance(\"#000F\",AllCompliance,&clone_info->fill,\n    exception);\n  if (status == MagickFalse)\n    {\n      clone_info=DestroyDrawInfo(clone_info);\n      return(MagickFalse);\n    }\n  resolution.x=96.0;\n  resolution.y=96.0;\n  if (clone_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(clone_info->density,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        resolution.x=geometry_info.rho;\n      resolution.y=resolution.x;\n      if ((flags & SigmaValue) != 0)\n        resolution.y=geometry_info.sigma;\n    }\n  mid=(resolution.x/96.0)*ExpandAffine(&clone_info->affine)*\n    clone_info->stroke_width/2.0;\n  bounds.x1=0.0;\n  bounds.y1=0.0;\n  bounds.x2=0.0;\n  bounds.y2=0.0;\n  if (polygon_info != (PolygonInfo *) NULL)\n    {\n      bounds=polygon_info->edges[0].bounds;\n      for (i=1; i < (ssize_t) polygon_info->number_edges; i++)\n      {\n        if (polygon_info->edges[i].bounds.x1 < (double) bounds.x1)\n          bounds.x1=polygon_info->edges[i].bounds.x1;\n        if (polygon_info->edges[i].bounds.y1 < (double) bounds.y1)\n          bounds.y1=polygon_info->edges[i].bounds.y1;\n        if (polygon_info->edges[i].bounds.x2 > (double) bounds.x2)\n          bounds.x2=polygon_info->edges[i].bounds.x2;\n        if (polygon_info->edges[i].bounds.y2 > (double) bounds.y2)\n          bounds.y2=polygon_info->edges[i].bounds.y2;\n      }\n      bounds.x1-=mid;\n      bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double)\n        image->columns ? (double) image->columns-1 : bounds.x1;\n      bounds.y1-=mid;\n      bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double)\n        image->rows ? (double) image->rows-1 : bounds.y1;\n      bounds.x2+=mid;\n      bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double)\n        image->columns ? (double) image->columns-1 : bounds.x2;\n      bounds.y2+=mid;\n      bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double)\n        image->rows ? (double) image->rows-1 : bounds.y2;\n      for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n      {\n        if (polygon_info->edges[i].direction != 0)\n          status=QueryColorCompliance(\"#f00\",AllCompliance,&clone_info->stroke,\n            exception);\n        else\n          status=QueryColorCompliance(\"#0f0\",AllCompliance,&clone_info->stroke,\n            exception);\n        if (status == MagickFalse)\n          break;\n        start.x=(double) (polygon_info->edges[i].bounds.x1-mid);\n        start.y=(double) (polygon_info->edges[i].bounds.y1-mid);\n        end.x=(double) (polygon_info->edges[i].bounds.x2+mid);\n        end.y=(double) (polygon_info->edges[i].bounds.y2+mid);\n        primitive_info[0].primitive=RectanglePrimitive;\n        status&=TraceRectangle(primitive_info,start,end);\n        primitive_info[0].method=ReplaceMethod;\n        coordinates=(ssize_t) primitive_info[0].coordinates;\n        primitive_info[coordinates].primitive=UndefinedPrimitive;\n        status=DrawPrimitive(image,clone_info,primitive_info,exception);\n        if (status == MagickFalse)\n          break;\n      }\n      if (i < (ssize_t) polygon_info->number_edges)\n        {\n          clone_info=DestroyDrawInfo(clone_info);\n          return(status == 0 ? MagickFalse : MagickTrue);\n        }\n    }\n  status=QueryColorCompliance(\"#00f\",AllCompliance,&clone_info->stroke,\n    exception);\n  if (status == MagickFalse)\n    {\n      clone_info=DestroyDrawInfo(clone_info);\n      return(MagickFalse);\n    }\n  start.x=(double) (bounds.x1-mid);\n  start.y=(double) (bounds.y1-mid);\n  end.x=(double) (bounds.x2+mid);\n  end.y=(double) (bounds.y2+mid);\n  primitive_info[0].primitive=RectanglePrimitive;\n  status&=TraceRectangle(primitive_info,start,end);\n  primitive_info[0].method=ReplaceMethod;\n  coordinates=(ssize_t) primitive_info[0].coordinates;\n  primitive_info[coordinates].primitive=UndefinedPrimitive;\n  status=DrawPrimitive(image,clone_info,primitive_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  return(status == 0 ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C l i p P a t h                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawClipPath() draws the clip path on the image mask.\n%\n%  The format of the DrawClipPath method is:\n%\n%      MagickBooleanType DrawClipPath(Image *image,const DrawInfo *draw_info,\n%        const char *id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the clip path id.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *id,ExceptionInfo *exception)\n{\n  const char\n    *clip_path;\n\n  Image\n    *clipping_mask;\n\n  MagickBooleanType\n    status;\n\n  clip_path=GetImageArtifact(image,id);\n  if (clip_path == (const char *) NULL)\n    return(MagickFalse);\n  clipping_mask=DrawClippingMask(image,draw_info,draw_info->clip_mask,clip_path,\n    exception);\n  if (clipping_mask == (Image *) NULL)\n    return(MagickFalse);\n  status=SetImageMask(image,WritePixelMask,clipping_mask,exception);\n  clipping_mask=DestroyImage(clipping_mask);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C l i p p i n g M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawClippingMask() draws the clip path and returns it as an image clipping\n%  mask.\n%\n%  The format of the DrawClippingMask method is:\n%\n%      Image *DrawClippingMask(Image *image,const DrawInfo *draw_info,\n%        const char *id,const char *clip_path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the clip path id.\n%\n%    o clip_path: the clip path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *DrawClippingMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *clip_path,ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  Image\n    *clip_mask,\n    *separate_mask;\n\n  MagickStatusType\n    status;\n\n  /*\n    Draw a clip path.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  clip_mask=AcquireImage((const ImageInfo *) NULL,exception);\n  status=SetImageExtent(clip_mask,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImage(clip_mask));\n  status=SetImageMask(clip_mask,WritePixelMask,(Image *) NULL,exception);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(MagickRealType) TransparentAlpha;\n  clip_mask->background_color.alpha_trait=BlendPixelTrait;\n  status=SetImageBackgroundColor(clip_mask,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,clip_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  if (clone_info->clip_mask != (char *) NULL)\n    clone_info->clip_mask=DestroyString(clone_info->clip_mask);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->alpha=OpaqueAlpha;\n  clone_info->clip_path=MagickTrue;\n  status=RenderMVGContent(clip_mask,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  separate_mask=SeparateImage(clip_mask,AlphaChannel,exception);\n  if (separate_mask == (Image *) NULL)\n    status=MagickFalse; \n  else\n    {\n      clip_mask=DestroyImage(clip_mask);\n      clip_mask=separate_mask;\n      status&=NegateImage(clip_mask,MagickFalse,exception);\n    }\n  if (status == MagickFalse)\n    clip_mask=DestroyImage(clip_mask);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(clip_mask);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C o m p o s i t e M a s k                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawCompositeMask() draws the mask path and returns it as an image mask.\n%\n%  The format of the DrawCompositeMask method is:\n%\n%      Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n%        const char *id,const char *mask_path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the mask path id.\n%\n%    o mask_path: the mask path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *mask_path,ExceptionInfo *exception)\n{\n  Image\n    *composite_mask,\n    *separate_mask;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  /*\n    Draw a mask path.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  composite_mask=AcquireImage((const ImageInfo *) NULL,exception);\n  status=SetImageExtent(composite_mask,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImage(composite_mask));\n  status=SetImageMask(composite_mask,CompositePixelMask,(Image *) NULL,\n    exception);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &composite_mask->background_color,exception);\n  composite_mask->background_color.alpha=(MagickRealType) TransparentAlpha;\n  composite_mask->background_color.alpha_trait=BlendPixelTrait;\n  (void) SetImageBackgroundColor(composite_mask,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin mask-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,mask_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->alpha=OpaqueAlpha;\n  status=RenderMVGContent(composite_mask,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  separate_mask=SeparateImage(composite_mask,AlphaChannel,exception);\n  if (separate_mask != (Image *) NULL)\n    {\n      composite_mask=DestroyImage(composite_mask);\n      composite_mask=separate_mask;\n      status=NegateImage(composite_mask,MagickFalse,exception);\n      if (status == MagickFalse)\n        composite_mask=DestroyImage(composite_mask);\n    }\n  if (status == MagickFalse)\n    composite_mask=DestroyImage(composite_mask);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end mask-path\");\n  return(composite_mask);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w D a s h P o l y g o n                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawDashPolygon() draws a dashed polygon (line, rectangle, ellipse) on the\n%  image while respecting the dash offset and dash pattern attributes.\n%\n%  The format of the DrawDashPolygon method is:\n%\n%      MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n%        const PrimitiveInfo *primitive_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)\n{\n  double\n    dx,\n    dy,\n    length,\n    maximum_length,\n    offset,\n    scale,\n    total_length;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *dash_polygon;\n\n  ssize_t\n    i;\n\n  size_t\n    number_vertices;\n\n  ssize_t\n    j,\n    n;\n\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-dash\");\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  number_vertices=(size_t) i;\n  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (2UL*number_vertices+32UL),sizeof(*dash_polygon));\n  if (dash_polygon == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  (void) memset(dash_polygon,0,(2UL*number_vertices+32UL)*\n    sizeof(*dash_polygon));\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->miterlimit=0;\n  dash_polygon[0]=primitive_info[0];\n  scale=ExpandAffine(&draw_info->affine);\n  length=scale*draw_info->dash_pattern[0];\n  offset=fabs(draw_info->dash_offset) >= MagickEpsilon ?\n    scale*draw_info->dash_offset : 0.0;\n  j=1;\n  for (n=0; offset > 0.0; j=0)\n  {\n    if (draw_info->dash_pattern[n] <= 0.0)\n      break;\n    length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    if (offset > length)\n      {\n        offset-=length;\n        n++;\n        length=scale*draw_info->dash_pattern[n];\n        continue;\n      }\n    if (offset < length)\n      {\n        length-=offset;\n        offset=0.0;\n        break;\n      }\n    offset=0.0;\n    n++;\n  }\n  status=MagickTrue;\n  maximum_length=0.0;\n  total_length=0.0;\n  for (i=1; (i < (ssize_t) number_vertices) && (length >= 0.0); i++)\n  {\n    dx=primitive_info[i].point.x-primitive_info[i-1].point.x;\n    dy=primitive_info[i].point.y-primitive_info[i-1].point.y;\n    maximum_length=hypot(dx,dy);\n    if (maximum_length > (double) (MaxBezierCoordinates >> 2))\n      continue;\n    if (fabs(length) < MagickEpsilon)\n      {\n        if (fabs(draw_info->dash_pattern[n]) >= MagickEpsilon)\n          n++;\n        if (fabs(draw_info->dash_pattern[n]) < MagickEpsilon)\n          n=0;\n        length=scale*draw_info->dash_pattern[n];\n      }\n    for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); )\n    {\n      total_length+=length;\n      if ((n & 0x01) != 0)\n        {\n          dash_polygon[0]=primitive_info[0];\n          dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length*PerceptibleReciprocal(maximum_length));\n          j=1;\n        }\n      else\n        {\n          if ((j+1) > (ssize_t) number_vertices)\n            break;\n          dash_polygon[j]=primitive_info[i-1];\n          dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[j].coordinates=1;\n          j++;\n          dash_polygon[0].coordinates=(size_t) j;\n          dash_polygon[j].primitive=UndefinedPrimitive;\n          status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n          if (status == MagickFalse)\n            break;\n        }\n      if (fabs(draw_info->dash_pattern[n]) >= MagickEpsilon)\n        n++;\n      if (fabs(draw_info->dash_pattern[n]) < MagickEpsilon)\n        n=0;\n      length=scale*draw_info->dash_pattern[n];\n    }\n    length-=(maximum_length-total_length);\n    if ((n & 0x01) != 0)\n      continue;\n    dash_polygon[j]=primitive_info[i];\n    dash_polygon[j].coordinates=1;\n    j++;\n  }\n  if ((status != MagickFalse) && (total_length < maximum_length) &&\n      ((n & 0x01) == 0) && (j > 1))\n    {\n      dash_polygon[j]=primitive_info[i-1];\n      dash_polygon[j].point.x+=MagickEpsilon;\n      dash_polygon[j].point.y+=MagickEpsilon;\n      dash_polygon[j].coordinates=1;\n      j++;\n      dash_polygon[0].coordinates=(size_t) j;\n      dash_polygon[j].primitive=UndefinedPrimitive;\n      status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n    }\n  dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-dash\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     D r a w G r a d i e n t I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawGradientImage() draws a linear gradient on the image.\n%\n%  The format of the DrawGradientImage method is:\n%\n%      MagickBooleanType DrawGradientImage(Image *image,\n%        const DrawInfo *draw_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double GetStopColorOffset(const GradientInfo *gradient,\n  const ssize_t x,const ssize_t y)\n{\n  switch (gradient->type)\n  {\n    case UndefinedGradient:\n    case LinearGradient:\n    {\n      double\n        gamma,\n        length,\n        offset,\n        scale;\n\n      PointInfo\n        p,\n        q;\n\n      const SegmentInfo\n        *gradient_vector;\n\n      gradient_vector=(&gradient->gradient_vector);\n      p.x=gradient_vector->x2-gradient_vector->x1;\n      p.y=gradient_vector->y2-gradient_vector->y1;\n      q.x=(double) x-gradient_vector->x1;\n      q.y=(double) y-gradient_vector->y1;\n      length=sqrt(q.x*q.x+q.y*q.y);\n      gamma=sqrt(p.x*p.x+p.y*p.y)*length;\n      gamma=PerceptibleReciprocal(gamma);\n      scale=p.x*q.x+p.y*q.y;\n      offset=gamma*scale*length;\n      return(offset);\n    }\n    case RadialGradient:\n    {\n      PointInfo\n        v;\n\n      if (gradient->spread == RepeatSpread)\n        {\n          v.x=(double) x-gradient->center.x;\n          v.y=(double) y-gradient->center.y;\n          return(sqrt(v.x*v.x+v.y*v.y));\n        }\n      v.x=(double) (((x-gradient->center.x)*cos(DegreesToRadians(\n        gradient->angle)))+((y-gradient->center.y)*sin(DegreesToRadians(\n        gradient->angle))))*PerceptibleReciprocal(gradient->radii.x);\n      v.y=(double) (((x-gradient->center.x)*sin(DegreesToRadians(\n        gradient->angle)))-((y-gradient->center.y)*cos(DegreesToRadians(\n        gradient->angle))))*PerceptibleReciprocal(gradient->radii.y);\n      return(sqrt(v.x*v.x+v.y*v.y));\n    }\n  }\n  return(0.0);\n}\n\nstatic int StopInfoCompare(const void *x,const void *y)\n{\n  StopInfo\n    *stop_1,\n    *stop_2;\n\n  stop_1=(StopInfo *) x;\n  stop_2=(StopInfo *) y;\n  if (stop_1->offset > stop_2->offset)\n    return(1);\n  if (fabs(stop_1->offset-stop_2->offset) <= MagickEpsilon)\n    return(0);\n  return(-1);\n}\n\nMagickExport MagickBooleanType DrawGradientImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const GradientInfo\n    *gradient;\n\n  const SegmentInfo\n    *gradient_vector;\n\n  double\n    length;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    zero;\n\n  PointInfo\n    point;\n\n  RectangleInfo\n    bounding_box;\n\n  ssize_t\n    y;\n\n  /*\n    Draw linear or radial gradient on image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  gradient=(&draw_info->gradient);\n  qsort(gradient->stops,gradient->number_stops,sizeof(StopInfo),\n    StopInfoCompare);\n  gradient_vector=(&gradient->gradient_vector);\n  point.x=gradient_vector->x2-gradient_vector->x1;\n  point.y=gradient_vector->y2-gradient_vector->y1;\n  length=sqrt(point.x*point.x+point.y*point.y);\n  bounding_box=gradient->bounding_box;\n  status=MagickTrue;\n  GetPixelInfo(image,&zero);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,bounding_box.height-bounding_box.y,1)\n#endif\n  for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++)\n  {\n    double\n      alpha,\n      offset;\n\n    PixelInfo\n      composite,\n      pixel;\n\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      i,\n      x;\n\n    ssize_t\n      j;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    pixel=zero;\n    composite=zero;\n    offset=GetStopColorOffset(gradient,0,y);\n    if (gradient->type != RadialGradient)\n      offset*=PerceptibleReciprocal(length);\n    for (x=bounding_box.x; x < (ssize_t) bounding_box.width; x++)\n    {\n      GetPixelInfoPixel(image,q,&pixel);\n      switch (gradient->spread)\n      {\n        case UndefinedSpread:\n        case PadSpread:\n        {\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type != RadialGradient)\n                offset*=PerceptibleReciprocal(length);\n            }\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if ((offset < 0.0) || (i == 0))\n            composite=gradient->stops[0].color;\n          else\n            if ((offset > 1.0) || (i == (ssize_t) gradient->number_stops))\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n        case ReflectSpread:\n        {\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type != RadialGradient)\n                offset*=PerceptibleReciprocal(length);\n            }\n          if (offset < 0.0)\n            offset=(-offset);\n          if ((ssize_t) fmod(offset,2.0) == 0)\n            offset=fmod(offset,1.0);\n          else\n            offset=1.0-fmod(offset,1.0);\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if (i == 0)\n            composite=gradient->stops[0].color;\n          else\n            if (i == (ssize_t) gradient->number_stops)\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n        case RepeatSpread:\n        {\n          double\n            repeat;\n\n          MagickBooleanType\n            antialias;\n\n          antialias=MagickFalse;\n          repeat=0.0;\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type == LinearGradient)\n                {\n                  repeat=fmod(offset,length);\n                  if (repeat < 0.0)\n                    repeat=length-fmod(-repeat,length);\n                  else\n                    repeat=fmod(offset,length);\n                  antialias=(repeat < length) && ((repeat+1.0) > length) ?\n                    MagickTrue : MagickFalse;\n                  offset=PerceptibleReciprocal(length)*repeat;\n                }\n              else\n                {\n                  repeat=fmod(offset,gradient->radius);\n                  if (repeat < 0.0)\n                    repeat=gradient->radius-fmod(-repeat,gradient->radius);\n                  else\n                    repeat=fmod(offset,gradient->radius);\n                  antialias=repeat+1.0 > gradient->radius ? MagickTrue :\n                    MagickFalse;\n                  offset=repeat*PerceptibleReciprocal(gradient->radius);\n                }\n            }\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if (i == 0)\n            composite=gradient->stops[0].color;\n          else\n            if (i == (ssize_t) gradient->number_stops)\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                if (antialias != MagickFalse)\n                  {\n                    if (gradient->type == LinearGradient)\n                      alpha=length-repeat;\n                    else\n                      alpha=gradient->radius-repeat;\n                    i=0;\n                    j=(ssize_t) gradient->number_stops-1L;\n                  }\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n      }\n      CompositePixelInfoOver(&composite,composite.alpha,&pixel,pixel.alpha,\n        &pixel);\n      SetPixelViaPixelInfo(image,&pixel,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawImage() draws a graphic primitive on your image.  The primitive\n%  may be represented as a string or filename.  Precede the filename with an\n%  \"at\" sign (@) and the contents of the file are drawn on the image.  You\n%  can affect how text is drawn by setting one or more members of the draw\n%  info structure.\n%\n%  The format of the DrawImage method is:\n%\n%      MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  char\n    **text = (char **) NULL;\n\n  double\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    i;\n\n  /*\n    Check if there is enough storage for drawing primitives.\n  */\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*(double) quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if ((extent >= (double) MAGICK_SSIZE_MAX) || (IsNaN(extent) != 0))\n    return(MagickFalse);\n  if (mvg_info->offset > 0)\n    {\n      text=(char **) AcquireQuantumMemory(mvg_info->offset,sizeof(*text));\n      if (text == (char **) NULL)\n        return(MagickFalse);\n      for (i=0; i < mvg_info->offset; i++)\n        text[i]=(*mvg_info->primitive_info)[i].text;\n    }\n  *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n    *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    {\n      if (text != (char **) NULL)\n        text=(char **) RelinquishMagickMemory(text);\n      *mvg_info->extent=(size_t) extent;\n      for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n      {\n        (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n        (*mvg_info->primitive_info)[i].text=(char *) NULL;\n      }\n      return(MagickTrue);\n    }\n  /*\n    Reallocation failed, allocate a primitive to facilitate unwinding.\n  */\n  if (text != (char **) NULL)\n    {\n      for (i=0; i < mvg_info->offset; i++)\n        if (text[i] != (char *) NULL)\n          text[i]=DestroyString(text[i]);\n      text=(char **) RelinquishMagickMemory(text);\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t)\n    (PrimitiveExtentPad+1)*quantum);\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}\n\nstatic inline double GetDrawValue(const char *magick_restrict string,\n  char **magick_restrict sentinel)\n{\n  char\n    **magick_restrict q;\n\n  double\n    value;\n\n  q=sentinel;\n  value=InterpretLocaleValue(string,q);\n  sentinel=q;\n  return(value);\n}\n\nstatic int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}\n\nstatic SplayTreeInfo *GetMVGMacros(const char *primitive)\n{\n  char\n    *macro,\n    *token;\n\n  const char\n    *q;\n\n  size_t\n    extent;\n\n  SplayTreeInfo\n    *macros;\n\n  /*\n    Scan graphic primitives for definitions and classes.\n  */\n  if (primitive == (const char *) NULL)\n    return((SplayTreeInfo *) NULL);\n  macros=NewSplayTree(MVGMacroCompare,RelinquishMagickMemory,\n    RelinquishMagickMemory);\n  macro=AcquireString(primitive);\n  token=AcquireString(primitive);\n  extent=strlen(token)+MagickPathExtent;\n  for (q=primitive; *q != '\\0'; )\n  {\n    if (GetNextToken(q,&q,extent,token) < 1)\n      break;\n    if (*token == '\\0')\n      break;\n    if (LocaleCompare(\"push\",token) == 0)\n      {\n        const char\n          *end,\n          *start;\n\n        (void) GetNextToken(q,&q,extent,token);\n        if (*q == '\"')\n          {\n            char\n              name[MagickPathExtent];\n\n            const char\n              *p;\n\n            ssize_t\n              n;\n\n            /*\n              Named macro (e.g. push graphic-context \"wheel\").\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            start=q;\n            end=q;\n            (void) CopyMagickString(name,token,MagickPathExtent);\n            n=1;\n            for (p=q; *p != '\\0'; )\n            {\n              if (GetNextToken(p,&p,extent,token) < 1)\n                break;\n              if (*token == '\\0')\n                break;\n              if (LocaleCompare(token,\"pop\") == 0)\n                {\n                  end=p-strlen(token)-1;\n                  n--;\n                }\n              if (LocaleCompare(token,\"push\") == 0)\n                n++;\n              if ((n == 0) && (end > start))\n                {\n                  /*\n                    Extract macro.\n                  */\n                  (void) GetNextToken(p,&p,extent,token);\n                  (void) CopyMagickString(macro,start,(size_t) (end-start));\n                  (void) AddValueToSplayTree(macros,ConstantString(name),\n                    ConstantString(macro));\n                  break;\n                }\n            }\n          }\n      }\n  }\n  token=DestroyString(token);\n  macro=DestroyString(macro);\n  return(macros);\n}\n\nstatic inline MagickBooleanType IsPoint(const char *point)\n{\n  char\n    *p;\n\n  double\n    value;\n\n  value=GetDrawValue(point,&p);\n  return((fabs(value) < MagickEpsilon) && (p == point) ? MagickFalse :\n    MagickTrue);\n}\n\nstatic inline MagickBooleanType TracePoint(PrimitiveInfo *primitive_info,\n  const PointInfo point)\n{\n  primitive_info->coordinates=1;\n  primitive_info->closed_subpath=MagickFalse;\n  primitive_info->point=point;\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType RenderMVGContent(Image *image,\n  const DrawInfo *draw_info,const size_t depth,ExceptionInfo *exception)\n{\n#define RenderImageTag  \"Render/Image\"\n\n  AffineMatrix\n    affine,\n    current;\n\n  char\n    keyword[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *next_token,\n    pattern[MagickPathExtent],\n    *primitive,\n    *token;\n\n  const char\n    *q;\n\n  double\n    angle,\n    coordinates,\n    cursor,\n    factor,\n    primitive_extent;\n\n  DrawInfo\n    *clone_info,\n    **graphic_context;\n\n  MagickBooleanType\n    proceed;\n\n  MagickStatusType\n    status;\n\n  MVGInfo\n    mvg_info;\n\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  const char\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    extent,\n    number_points,\n    number_stops;\n\n  SplayTreeInfo\n    *macros;\n\n  ssize_t\n    defsDepth,\n    j,\n    k,\n    n,\n    symbolDepth;\n\n  StopInfo\n    *stops;\n\n  TypeMetric\n    metrics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (depth > MagickMaxRecursionDepth)\n    ThrowBinaryException(DrawError,\"VectorGraphicsNestedTooDeeply\",\n      image->filename);\n  if ((draw_info->primitive == (char *) NULL) ||\n      (*draw_info->primitive == '\\0'))\n    return(MagickFalse);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"begin draw-image\");\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (status == MagickFalse)\n        return(MagickFalse);\n    }\n  if ((*draw_info->primitive == '@') && (strlen(draw_info->primitive) > 1) &&\n      (*(draw_info->primitive+1) != '-') && (depth == 0))\n    primitive=FileToString(draw_info->primitive,~0UL,exception);\n  else\n    primitive=AcquireString(draw_info->primitive);\n  if (primitive == (char *) NULL)\n    return(MagickFalse);\n  primitive_extent=(double) strlen(primitive);\n  (void) SetImageArtifact(image,\"mvg:vector-graphics\",primitive);\n  n=0;\n  number_stops=0;\n  stops=(StopInfo *) NULL;\n  /*\n    Allocate primitive info memory.\n  */\n  graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));\n  if (graphic_context == (DrawInfo **) NULL)\n    {\n      primitive=DestroyString(primitive);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  number_points=(size_t) PrimitiveExtentPad;\n  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (number_points+1),sizeof(*primitive_info));\n  if (primitive_info == (PrimitiveInfo *) NULL)\n    {\n      primitive=DestroyString(primitive);\n      for ( ; n >= 0; n--)\n        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(primitive_info,0,(size_t) (number_points+1)*\n    sizeof(*primitive_info));\n  (void) memset(&mvg_info,0,sizeof(mvg_info));\n  mvg_info.primitive_info=(&primitive_info);\n  mvg_info.extent=(&number_points);\n  mvg_info.exception=exception;\n  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  graphic_context[n]->viewbox=image->page;\n  if ((image->page.width == 0) || (image->page.height == 0))\n    {\n      graphic_context[n]->viewbox.width=image->columns;\n      graphic_context[n]->viewbox.height=image->rows;\n    }\n  token=AcquireString(primitive);\n  extent=strlen(token)+MagickPathExtent;\n  defsDepth=0;\n  symbolDepth=0;\n  cursor=0.0;\n  macros=GetMVGMacros(primitive);\n  status=MagickTrue;\n  for (q=primitive; *q != '\\0'; )\n  {\n    /*\n      Interpret graphic primitive.\n    */\n    if (GetNextToken(q,&q,MagickPathExtent,keyword) < 1)\n      break;\n    if (*keyword == '\\0')\n      break;\n    if (*keyword == '#')\n      {\n        /*\n          Comment.\n        */\n        while ((*q != '\\n') && (*q != '\\0'))\n          q++;\n        continue;\n      }\n    p=q-strlen(keyword)-1;\n    primitive_type=UndefinedPrimitive;\n    current=graphic_context[n]->affine;\n    GetAffineMatrix(&affine);\n    *token='\\0';\n    switch (*keyword)\n    {\n      case ';':\n        break;\n      case 'a':\n      case 'A':\n      {\n        if (LocaleCompare(\"affine\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.rx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ry=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.tx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",keyword) == 0)\n          {\n            primitive_type=AlphaPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"arc\",keyword) == 0)\n          {\n            primitive_type=ArcPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'b':\n      case 'B':\n      {\n        if (LocaleCompare(\"bezier\",keyword) == 0)\n          {\n            primitive_type=BezierPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"border-color\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->border_color,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        if (LocaleCompare(\"class\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if ((*token == '\\0') || (*token == ';'))\n              {\n                status=MagickFalse;\n                break;\n              }\n            if (LocaleCompare(token,graphic_context[n]->id) == 0)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if ((graphic_context[n]->render != MagickFalse) &&\n                (mvg_class != (const char *) NULL) && (p > primitive))\n              {\n                char\n                  *elements;\n\n                ssize_t\n                  offset;\n\n                /*\n                  Inject class elements in stream.\n                */\n                offset=(ssize_t) (p-primitive);\n                elements=AcquireString(primitive);\n                elements[offset]='\\0';\n                (void) ConcatenateString(&elements,mvg_class);\n                (void) ConcatenateString(&elements,\"\\n\");\n                (void) ConcatenateString(&elements,q);\n                primitive=DestroyString(primitive);\n                primitive=elements;\n                q=primitive+offset;\n              }\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",keyword) == 0)\n          {\n            const char\n              *clip_path;\n\n            /*\n              Take a node from within the MVG document, and duplicate it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == '\\0')\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) CloneString(&graphic_context[n]->clip_mask,token);\n            clip_path=(const char *) GetValueFromSplayTree(macros,token);\n            if (clip_path != (const char *) NULL)\n              {\n                if (graphic_context[n]->clipping_mask != (Image *) NULL)\n                  graphic_context[n]->clipping_mask=\n                    DestroyImage(graphic_context[n]->clipping_mask);\n                graphic_context[n]->clipping_mask=DrawClippingMask(image,\n                  graphic_context[n],token,clip_path,exception);\n                if (graphic_context[n]->compliance != SVGCompliance)\n                  {\n                    clip_path=(const char *) GetValueFromSplayTree(macros,\n                      graphic_context[n]->clip_mask);\n                    if (clip_path != (const char *) NULL)\n                      (void) SetImageArtifact(image,\n                        graphic_context[n]->clip_mask,clip_path);\n                    status&=DrawClipPath(image,graphic_context[n],\n                      graphic_context[n]->clip_mask,exception);\n                  }\n              }\n            break;\n          }\n        if (LocaleCompare(\"clip-rule\",keyword) == 0)\n          {\n            ssize_t\n              fill_rule;\n\n            (void) GetNextToken(q,&q,extent,token);\n            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,\n              token);\n            if (fill_rule == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->fill_rule=(FillRule) fill_rule;\n            break;\n          }\n        if (LocaleCompare(\"clip-units\",keyword) == 0)\n          {\n            ssize_t\n              clip_units;\n\n            (void) GetNextToken(q,&q,extent,token);\n            clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,\n              token);\n            if (clip_units == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->clip_units=(ClipPathUnits) clip_units;\n            if (clip_units == ObjectBoundingBox)\n              {\n                GetAffineMatrix(&current);\n                affine.sx=draw_info->bounds.x2;\n                affine.sy=draw_info->bounds.y2;\n                affine.tx=draw_info->bounds.x1;\n                affine.ty=draw_info->bounds.y1;\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"circle\",keyword) == 0)\n          {\n            primitive_type=CirclePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"color\",keyword) == 0)\n          {\n            primitive_type=ColorPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"compliance\",keyword) == 0)\n          {\n            /*\n              MVG compliance associates a clipping mask with an image; SVG\n              compliance associates a clipping mask with a graphics context.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->compliance=(ComplianceType) ParseCommandOption(\n              MagickComplianceOptions,MagickFalse,token);\n            break;\n          }\n        if (LocaleCompare(\"currentColor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'd':\n      case 'D':\n      {\n        if (LocaleCompare(\"decorate\",keyword) == 0)\n          {\n            ssize_t\n              decorate;\n\n            (void) GetNextToken(q,&q,extent,token);\n            decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,\n              token);\n            if (decorate == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->decorate=(DecorationType) decorate;\n            break;\n          }\n        if (LocaleCompare(\"density\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->density,token);\n            break;\n          }\n        if (LocaleCompare(\"direction\",keyword) == 0)\n          {\n            ssize_t\n              direction;\n\n            (void) GetNextToken(q,&q,extent,token);\n            direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,\n              token);\n            if (direction == -1)\n              status=MagickFalse;\n            else\n              graphic_context[n]->direction=(DirectionType) direction;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'e':\n      case 'E':\n      {\n        if (LocaleCompare(\"ellipse\",keyword) == 0)\n          {\n            primitive_type=EllipsePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"encoding\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->encoding,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'f':\n      case 'F':\n      {\n        if (LocaleCompare(\"fill\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if (mvg_class != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,mvg_class,\n                  &graphic_context[n]->fill_pattern,exception);\n                break;\n              }\n            (void) FormatLocaleString(pattern,MagickPathExtent,\"%s\",token);\n            if (GetImageArtifact(image,pattern) != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,token,\n                  &graphic_context[n]->fill_pattern,exception);\n                break;\n              }\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->fill,exception);\n            if (graphic_context[n]->fill_alpha != OpaqueAlpha)\n              graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;\n            break;\n          }\n        if (LocaleCompare(\"fill-opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*\n              GetDrawValue(token,&next_token),0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              graphic_context[n]->fill_alpha*=opacity;\n            else\n              graphic_context[n]->fill_alpha=QuantumRange*opacity;\n            if (graphic_context[n]->fill.alpha != TransparentAlpha)\n              graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;\n            else\n              graphic_context[n]->fill.alpha=(MagickRealType)\n                ClampToQuantum(QuantumRange*opacity);\n            graphic_context[n]->fill.alpha_trait=BlendPixelTrait;\n            break;\n          }\n        if (LocaleCompare(\"fill-rule\",keyword) == 0)\n          {\n            ssize_t\n              fill_rule;\n\n            (void) GetNextToken(q,&q,extent,token);\n            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,\n              token);\n            if (fill_rule == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->fill_rule=(FillRule) fill_rule;\n            break;\n          }\n        if (LocaleCompare(\"font\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->font,token);\n            if (LocaleCompare(\"none\",token) == 0)\n              graphic_context[n]->font=(char *) RelinquishMagickMemory(\n                graphic_context[n]->font);\n            break;\n          }\n        if (LocaleCompare(\"font-family\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->family,token);\n            break;\n          }\n        if (LocaleCompare(\"font-size\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->pointsize=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"font-stretch\",keyword) == 0)\n          {\n            ssize_t\n              stretch;\n\n            (void) GetNextToken(q,&q,extent,token);\n            stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);\n            if (stretch == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->stretch=(StretchType) stretch;\n            break;\n          }\n        if (LocaleCompare(\"font-style\",keyword) == 0)\n          {\n            ssize_t\n              style;\n\n            (void) GetNextToken(q,&q,extent,token);\n            style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);\n            if (style == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->style=(StyleType) style;\n            break;\n          }\n        if (LocaleCompare(\"font-weight\",keyword) == 0)\n          {\n            ssize_t\n              weight;\n\n            (void) GetNextToken(q,&q,extent,token);\n            weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);\n            if (weight == -1)\n              weight=(ssize_t) StringToUnsignedLong(token);\n            graphic_context[n]->weight=(size_t) weight;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'g':\n      case 'G':\n      {\n        if (LocaleCompare(\"gradient-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",keyword) == 0)\n          {\n            ssize_t\n              gravity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);\n            if (gravity == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->gravity=(GravityType) gravity;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'i':\n      case 'I':\n      {\n        if (LocaleCompare(\"image\",keyword) == 0)\n          {\n            ssize_t\n              compose;\n\n            primitive_type=ImagePrimitive;\n            (void) GetNextToken(q,&q,extent,token);\n            compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);\n            if (compose == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->compose=(CompositeOperator) compose;\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interline_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interword_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'k':\n      case 'K':\n      {\n        if (LocaleCompare(\"kerning\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->kerning=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        if (LocaleCompare(\"letter-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (IsPoint(token) == MagickFalse)\n              break;\n            clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n            clone_info->text=AcquireString(\" \");\n            status&=GetTypeMetrics(image,clone_info,&metrics,exception);\n            graphic_context[n]->kerning=metrics.width*\n              GetDrawValue(token,&next_token);\n            clone_info=DestroyDrawInfo(clone_info);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"line\",keyword) == 0)\n          {\n            primitive_type=LinePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'm':\n      case 'M':\n      {\n        if (LocaleCompare(\"mask\",keyword) == 0)\n          {\n            const char\n              *mask_path;\n\n            /*\n              Take a node from within the MVG document, and duplicate it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            mask_path=(const char *) GetValueFromSplayTree(macros,token);\n            if (mask_path != (const char *) NULL)\n              {\n                if (graphic_context[n]->composite_mask != (Image *) NULL)\n                  graphic_context[n]->composite_mask=\n                    DestroyImage(graphic_context[n]->composite_mask);\n                graphic_context[n]->composite_mask=DrawCompositeMask(image,\n                  graphic_context[n],token,mask_path,exception);\n                if (graphic_context[n]->compliance != SVGCompliance)\n                  status=SetImageMask(image,CompositePixelMask,\n                    graphic_context[n]->composite_mask,exception);\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'o':\n      case 'O':\n      {\n        if (LocaleCompare(\"offset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*\n              GetDrawValue(token,&next_token),0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              {\n                graphic_context[n]->fill_alpha*=opacity;\n                graphic_context[n]->stroke_alpha*=opacity;\n              }\n            else\n              {\n                graphic_context[n]->fill_alpha=QuantumRange*opacity;\n                graphic_context[n]->stroke_alpha=QuantumRange*opacity;\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'p':\n      case 'P':\n      {\n        if (LocaleCompare(\"path\",keyword) == 0)\n          {\n            primitive_type=PathPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"point\",keyword) == 0)\n          {\n            primitive_type=PointPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polyline\",keyword) == 0)\n          {\n            primitive_type=PolylinePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polygon\",keyword) == 0)\n          {\n            primitive_type=PolygonPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"pop\",keyword) == 0)\n          {\n            if (GetNextToken(q,&q,extent,token) < 1)\n              break;\n            if (LocaleCompare(\"class\",token) == 0)\n              break;\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              break;\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                defsDepth--;\n                graphic_context[n]->render=defsDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              break;\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                if (n <= 0)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      DrawError,\"UnbalancedGraphicContextPushPop\",\"`%s'\",token);\n                    status=MagickFalse;\n                    n=0;\n                    break;\n                  }\n                if ((graphic_context[n]->clip_mask != (char *) NULL) &&\n                    (graphic_context[n]->compliance != SVGCompliance))\n                  if (LocaleCompare(graphic_context[n]->clip_mask,\n                      graphic_context[n-1]->clip_mask) != 0)\n                    status=SetImageMask(image,WritePixelMask,(Image *) NULL,\n                      exception);\n                graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n                n--;\n                break;\n              }\n            if (LocaleCompare(\"mask\",token) == 0)\n              break;\n            if (LocaleCompare(\"pattern\",token) == 0)\n              break;\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                symbolDepth--;\n                graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            status=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"push\",keyword) == 0)\n          {\n            if (GetNextToken(q,&q,extent,token) < 1)\n              break;\n            if (LocaleCompare(\"class\",token) == 0)\n              {\n                /*\n                  Class context.\n                */\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"class\") != 0)\n                    continue;\n                  break;\n                }\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"clip-path\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                defsDepth++;\n                graphic_context[n]->render=defsDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                char\n                  key[2*MagickPathExtent],\n                  name[MagickPathExtent],\n                  type[MagickPathExtent];\n\n                SegmentInfo\n                  segment;\n\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(type,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                segment.x1=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.y1=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.x2=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.y2=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                if (LocaleCompare(type,\"radial\") == 0)\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    if (*token == ',')\n                      (void) GetNextToken(q,&q,extent,token);\n                  }\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"gradient\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (*q == '\\0') || \n                    (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));\n                bounds.x1=graphic_context[n]->affine.sx*segment.x1+\n                  graphic_context[n]->affine.ry*segment.y1+\n                  graphic_context[n]->affine.tx;\n                bounds.y1=graphic_context[n]->affine.rx*segment.x1+\n                  graphic_context[n]->affine.sy*segment.y1+\n                  graphic_context[n]->affine.ty;\n                bounds.x2=graphic_context[n]->affine.sx*segment.x2+\n                  graphic_context[n]->affine.ry*segment.y2+\n                  graphic_context[n]->affine.tx;\n                bounds.y2=graphic_context[n]->affine.rx*segment.x2+\n                  graphic_context[n]->affine.sy*segment.y2+\n                  graphic_context[n]->affine.ty;\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s\",name);\n                (void) SetImageArtifact(image,key,token);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-type\",name);\n                (void) SetImageArtifact(image,key,type);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-geometry\",\n                  name);\n                (void) FormatLocaleString(geometry,MagickPathExtent,\n                  \"%gx%g%+.15g%+.15g\",\n                  MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),\n                  MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),\n                  bounds.x1,bounds.y1);\n                (void) SetImageArtifact(image,key,geometry);\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n++;\n                graphic_context=(DrawInfo **) ResizeQuantumMemory(\n                  graphic_context,(size_t) (n+1),sizeof(*graphic_context));\n                if (graphic_context == (DrawInfo **) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                      image->filename);\n                    break;\n                  }\n                graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,\n                  graphic_context[n-1]);\n                if (*q == '\"')\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    (void) CloneString(&graphic_context[n]->id,token);\n                  }\n                break;\n              }\n            if (LocaleCompare(\"mask\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                char\n                  key[2*MagickPathExtent],\n                  name[MagickPathExtent];\n\n                RectangleInfo\n                  region;\n\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                region.x=CastDoubleToLong(ceil(GetDrawValue(token,\n                  &next_token)-0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.y=CastDoubleToLong(ceil(GetDrawValue(token,\n                  &next_token)-0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.width=(size_t) CastDoubleToLong(floor(GetDrawValue(\n                  token,&next_token)+0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.height=(size_t) floor(GetDrawValue(token,&next_token)+\n                  0.5);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"pattern\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s\",name);\n                (void) SetImageArtifact(image,key,token);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-geometry\",\n                  name);\n                (void) FormatLocaleString(geometry,MagickPathExtent,\n                  \"%.20gx%.20g%+.20g%+.20g\",(double) region.width,(double)\n                  region.height,(double) region.x,(double) region.y);\n                (void) SetImageArtifact(image,key,geometry);\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                symbolDepth++;\n                graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            status=MagickFalse;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'r':\n      case 'R':\n      {\n        if (LocaleCompare(\"rectangle\",keyword) == 0)\n          {\n            primitive_type=RectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"rotate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));\n            affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));\n            affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));\n            affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));\n            break;\n          }\n        if (LocaleCompare(\"roundRectangle\",keyword) == 0)\n          {\n            primitive_type=RoundRectanglePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        if (LocaleCompare(\"scale\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"skewX\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.ry=sin(DegreesToRadians(angle));\n            break;\n          }\n        if (LocaleCompare(\"skewY\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.rx=(-tan(DegreesToRadians(angle)/2.0));\n            break;\n          }\n        if (LocaleCompare(\"stop-color\",keyword) == 0)\n          {\n            PixelInfo\n              stop_color;\n\n            number_stops++;\n            if (number_stops == 1)\n              stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));\n            else\n              if (number_stops > 2)\n                stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,\n                  sizeof(*stops));\n            if (stops == (StopInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,&stop_color,\n              exception);\n            stops[number_stops-1].color=stop_color;\n            (void) GetNextToken(q,&q,extent,token);\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            stops[number_stops-1].offset=factor*GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if (mvg_class != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,mvg_class,\n                  &graphic_context[n]->stroke_pattern,exception);\n                break;\n              }\n            (void) FormatLocaleString(pattern,MagickPathExtent,\"%s\",token);\n            if (GetImageArtifact(image,pattern) != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,token,\n                  &graphic_context[n]->stroke_pattern,exception);\n                break;\n              }\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->stroke,exception);\n            if (graphic_context[n]->stroke_alpha != OpaqueAlpha)\n              graphic_context[n]->stroke.alpha=\n                graphic_context[n]->stroke_alpha;\n            break;\n          }\n        if (LocaleCompare(\"stroke-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->stroke_antialias=StringToLong(token) != 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"stroke-dasharray\",keyword) == 0)\n          {\n            if (graphic_context[n]->dash_pattern != (double *) NULL)\n              graphic_context[n]->dash_pattern=(double *)\n                RelinquishMagickMemory(graphic_context[n]->dash_pattern);\n            if (IsPoint(q) != MagickFalse)\n              {\n                const char\n                  *r;\n\n                r=q;\n                (void) GetNextToken(r,&r,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(r,&r,extent,token);\n                for (x=0; IsPoint(token) != MagickFalse; x++)\n                {\n                  (void) GetNextToken(r,&r,extent,token);\n                  if (*token == ',')\n                    (void) GetNextToken(r,&r,extent,token);\n                }\n                graphic_context[n]->dash_pattern=(double *)\n                  AcquireQuantumMemory((size_t) (2*x+2),\n                  sizeof(*graphic_context[n]->dash_pattern));\n                if (graphic_context[n]->dash_pattern == (double *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                      image->filename);\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) memset(graphic_context[n]->dash_pattern,0,(size_t)\n                  (2*x+2)*sizeof(*graphic_context[n]->dash_pattern));\n                for (j=0; j < x; j++)\n                {\n                  (void) GetNextToken(q,&q,extent,token);\n                  if (*token == ',')\n                    (void) GetNextToken(q,&q,extent,token);\n                  graphic_context[n]->dash_pattern[j]=GetDrawValue(token,\n                    &next_token);\n                  if (token == next_token)\n                    ThrowPointExpectedException(token,exception);\n                  if (graphic_context[n]->dash_pattern[j] <= 0.0)\n                    status=MagickFalse;\n                }\n                if ((x & 0x01) != 0)\n                  for ( ; j < (2*x); j++)\n                    graphic_context[n]->dash_pattern[j]=\n                      graphic_context[n]->dash_pattern[j-x];\n                graphic_context[n]->dash_pattern[j]=0.0;\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dashoffset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->dash_offset=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linecap\",keyword) == 0)\n          {\n            ssize_t\n              linecap;\n\n            (void) GetNextToken(q,&q,extent,token);\n            linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);\n            if (linecap == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->linecap=(LineCap) linecap;\n            break;\n          }\n        if (LocaleCompare(\"stroke-linejoin\",keyword) == 0)\n          {\n            ssize_t\n              linejoin;\n\n            (void) GetNextToken(q,&q,extent,token);\n            linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,\n              token);\n            if (linejoin == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->linejoin=(LineJoin) linejoin;\n            break;\n          }\n        if (LocaleCompare(\"stroke-miterlimit\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->miterlimit=StringToUnsignedLong(token);\n            break;\n          }\n        if (LocaleCompare(\"stroke-opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*GetDrawValue(token,&next_token),\n              0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              graphic_context[n]->stroke_alpha*=opacity;\n            else\n              graphic_context[n]->stroke_alpha=QuantumRange*opacity;\n            if (graphic_context[n]->stroke.alpha != TransparentAlpha)\n              graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;\n            else\n              graphic_context[n]->stroke.alpha=(MagickRealType)\n                ClampToQuantum(QuantumRange*opacity);\n            graphic_context[n]->stroke.alpha_trait=BlendPixelTrait;\n            break;\n          }\n        if (LocaleCompare(\"stroke-width\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            graphic_context[n]->stroke_width=GetDrawValue(token,&next_token);\n            if ((token == next_token) ||\n                (graphic_context[n]->stroke_width < 0.0))\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(\"text\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            cursor=0.0;\n            break;\n          }\n        if (LocaleCompare(\"text-align\",keyword) == 0)\n          {\n            ssize_t\n              align;\n\n            (void) GetNextToken(q,&q,extent,token);\n            align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);\n            if (align == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->align=(AlignType) align;\n            break;\n          }\n        if (LocaleCompare(\"text-anchor\",keyword) == 0)\n          {\n            ssize_t\n              align;\n\n            (void) GetNextToken(q,&q,extent,token);\n            align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);\n            if (align == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->align=(AlignType) align;\n            break;\n          }\n        if (LocaleCompare(\"text-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->text_antialias=StringToLong(token) != 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"text-undercolor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"translate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.tx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            cursor=0.0;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'u':\n      case 'U':\n      {\n        if (LocaleCompare(\"use\",keyword) == 0)\n          {\n            const char\n              *use;\n\n            /*\n              Get a macro from the MVG document, and \"use\" it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            use=(const char *) GetValueFromSplayTree(macros,token);\n            if (use != (const char *) NULL)\n              {\n                clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n                (void) CloneString(&clone_info->primitive,use);\n                status=RenderMVGContent(image,clone_info,depth+1,exception);\n                clone_info=DestroyDrawInfo(clone_info);\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        if (LocaleCompare(\"viewbox\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.x=CastDoubleToLong(ceil(\n              GetDrawValue(token,&next_token)-0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.y=CastDoubleToLong(ceil(\n              GetDrawValue(token,&next_token)-0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.width=(size_t) CastDoubleToLong(\n              floor(GetDrawValue(token,&next_token)+0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.height=(size_t) CastDoubleToLong(\n              floor(GetDrawValue(token,&next_token)+0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'w':\n      case 'W':\n      {\n        if (LocaleCompare(\"word-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interword_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      default:\n      {\n        status=MagickFalse;\n        break;\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    if ((fabs(affine.sx-1.0) >= MagickEpsilon) ||\n        (fabs(affine.rx) >= MagickEpsilon) || (fabs(affine.ry) >= MagickEpsilon) ||\n        (fabs(affine.sy-1.0) >= MagickEpsilon) ||\n        (fabs(affine.tx) >= MagickEpsilon) || (fabs(affine.ty) >= MagickEpsilon))\n      {\n        graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;\n        graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;\n        graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;\n        graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;\n        graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+\n          current.tx;\n        graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+\n          current.ty;\n      }\n    if (primitive_type == UndefinedPrimitive)\n      {\n        if (*q == '\\0')\n          {\n            if (number_stops > 1)\n              {\n                GradientType\n                  type;\n\n              type=LinearGradient;\n              if (draw_info->gradient.type == RadialGradient)\n                type=RadialGradient;\n              (void) GradientImage(image,type,PadSpread,stops,number_stops,\n                exception);\n             }\n           if (number_stops > 0)\n             stops=(StopInfo *) RelinquishMagickMemory(stops);\n          }\n        if ((draw_info->debug != MagickFalse) && (q > p))\n          (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  %.*s\",(int)\n            (q-p-1),p);\n        continue;\n      }\n    /*\n      Parse the primitive attributes.\n    */\n    for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n      if (primitive_info[i].text != (char *) NULL)\n        primitive_info[i].text=DestroyString(primitive_info[i].text);\n    i=0;\n    mvg_info.offset=i;\n    j=0;\n    primitive_info[0].point.x=0.0;\n    primitive_info[0].point.y=0.0;\n    primitive_info[0].coordinates=0;\n    primitive_info[0].method=FloodfillMethod;\n    primitive_info[0].closed_subpath=MagickFalse;\n    for (x=0; *q != '\\0'; x++)\n    {\n      /*\n        Define points.\n      */\n      if (IsPoint(q) == MagickFalse)\n        break;\n      (void) GetNextToken(q,&q,extent,token);\n      point.x=GetDrawValue(token,&next_token);\n      if (token == next_token)\n        ThrowPointExpectedException(token,exception);\n      (void) GetNextToken(q,&q,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      point.y=GetDrawValue(token,&next_token);\n      if (token == next_token)\n        ThrowPointExpectedException(token,exception);\n      (void) GetNextToken(q,(const char **) NULL,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      primitive_info[i].primitive=primitive_type;\n      primitive_info[i].point=point;\n      primitive_info[i].coordinates=0;\n      primitive_info[i].method=FloodfillMethod;\n      primitive_info[i].closed_subpath=MagickFalse;\n      i++;\n      mvg_info.offset=i;\n      if (i < (ssize_t) number_points)\n        continue;\n      status&=CheckPrimitiveExtent(&mvg_info,(double) number_points);\n      primitive_info=(*mvg_info.primitive_info);\n    }\n    if (status == MagickFalse)\n      break;\n    if (primitive_info[j].text != (char *) NULL)\n      primitive_info[j].text=DestroyString(primitive_info[j].text);\n    primitive_info[j].primitive=primitive_type;\n    primitive_info[j].coordinates=(size_t) x;\n    primitive_info[j].method=FloodfillMethod;\n    primitive_info[j].closed_subpath=MagickFalse;\n    /*\n      Circumscribe primitive within a circle.\n    */\n    bounds.x1=primitive_info[j].point.x;\n    bounds.y1=primitive_info[j].point.y;\n    bounds.x2=primitive_info[j].point.x;\n    bounds.y2=primitive_info[j].point.y;\n    for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)\n    {\n      point=primitive_info[j+k].point;\n      if (point.x < bounds.x1)\n        bounds.x1=point.x;\n      if (point.y < bounds.y1)\n        bounds.y1=point.y;\n      if (point.x > bounds.x2)\n        bounds.x2=point.x;\n      if (point.y > bounds.y2)\n        bounds.y2=point.y;\n    }\n    /*\n      Speculate how many points our primitive might consume.\n    */\n    coordinates=(double) primitive_info[j].coordinates;\n    switch (primitive_type)\n    {\n      case RectanglePrimitive:\n      {\n        coordinates*=5.0;\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        double\n          alpha,\n          beta,\n          radius;\n\n        alpha=bounds.x2-bounds.x1;\n        beta=bounds.y2-bounds.y1;\n        radius=hypot(alpha,beta);\n        coordinates*=5.0;\n        coordinates+=2.0*((size_t) ceil((double) MagickPI*radius))+6.0*\n          BezierQuantum+360.0;\n        break;\n      }\n      case BezierPrimitive:\n      {\n        coordinates=(BezierQuantum*(double) primitive_info[j].coordinates);\n        break;\n      }\n      case PathPrimitive:\n      {\n        char\n          *s,\n          *t;\n\n        (void) GetNextToken(q,&q,extent,token);\n        coordinates=1.0;\n        t=token;\n        for (s=token; *s != '\\0'; s=t)\n        {\n          double\n            value;\n\n          value=GetDrawValue(s,&t);\n          (void) value;\n          if (s == t)\n            {\n              t++;\n              continue;\n            }\n          coordinates++;\n        }\n        for (s=token; *s != '\\0'; s++)\n          if (strspn(s,\"AaCcQqSsTt\") != 0)\n            coordinates+=(20.0*BezierQuantum)+360.0;\n        break;\n      }\n      default:\n        break;\n    }\n    if (status == MagickFalse)\n      break;\n    if (((size_t) (i+coordinates)) >= number_points)\n      {\n        /*\n          Resize based on speculative points required by primitive.\n        */\n        number_points+=coordinates+1;\n        if (number_points < (size_t) coordinates)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        mvg_info.offset=i;\n        status&=CheckPrimitiveExtent(&mvg_info,(double) number_points);\n        primitive_info=(*mvg_info.primitive_info);\n      }\n    status&=CheckPrimitiveExtent(&mvg_info,PrimitiveExtentPad);\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == MagickFalse)\n      break;\n    mvg_info.offset=j;\n    switch (primitive_type)\n    {\n      case PointPrimitive:\n      default:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TracePoint(primitive_info+j,primitive_info[j].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case LinePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceLine(primitive_info+j,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case RectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceRectangle(primitive_info+j,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+2].point.x < 0.0) ||\n            (primitive_info[j+2].point.y < 0.0))\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceRoundRectangle(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case ArcPrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceArc(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case EllipsePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.x < 0.0) ||\n            (primitive_info[j+1].point.y < 0.0))\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceEllipse(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case CirclePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceCircle(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case PolylinePrimitive:\n      {\n        if (primitive_info[j].coordinates < 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case PolygonPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[i]=primitive_info[j];\n        primitive_info[i].coordinates=0;\n        primitive_info[j].coordinates++;\n        primitive_info[j].closed_subpath=MagickTrue;\n        i++;\n        break;\n      }\n      case BezierPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceBezier(&mvg_info,primitive_info[j].coordinates);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case PathPrimitive:\n      {\n        coordinates=(double) TracePath(&mvg_info,token,exception);\n        primitive_info=(*mvg_info.primitive_info); \n        if (coordinates < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        i=(ssize_t) (j+coordinates);\n        break;\n      }\n      case AlphaPrimitive:\n      case ColorPrimitive:\n      {\n        ssize_t\n          method;\n\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);\n        if (method == -1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[j].method=(PaintMethod) method;\n        break;\n      }\n      case TextPrimitive:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if (*token != ',')\n          (void) GetNextToken(q,&q,extent,token);\n        (void) CloneString(&primitive_info[j].text,token);\n        /*\n          Compute text cursor offset.\n        */\n        clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n        if ((fabs(mvg_info.point.x-primitive_info->point.x) < MagickEpsilon) &&\n            (fabs(mvg_info.point.y-primitive_info->point.y) < MagickEpsilon))\n          {\n            mvg_info.point=primitive_info->point;\n            primitive_info->point.x+=cursor;\n          }\n        else\n          {\n            mvg_info.point=primitive_info->point;\n            cursor=0.0;\n          }\n        clone_info->render=MagickFalse;\n        clone_info->text=AcquireString(token);\n        status&=GetTypeMetrics(image,clone_info,&metrics,exception);\n        clone_info=DestroyDrawInfo(clone_info);\n        cursor+=metrics.width;\n        if (graphic_context[n]->compliance != SVGCompliance)\n          cursor=0.0;\n        break;\n      }\n      case ImagePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) CloneString(&primitive_info[j].text,token);\n        break;\n      }\n    }\n    mvg_info.offset=i;\n    if (status == 0)\n      break;\n    primitive_info[i].primitive=UndefinedPrimitive;\n    if ((draw_info->debug != MagickFalse) && (q > p))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  %.*s\",(int) (q-p),p);\n    /*\n      Sanity check.\n    */\n    status&=CheckPrimitiveExtent(&mvg_info,ExpandAffine(\n      &graphic_context[n]->affine));\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == 0)\n      break;\n    status&=CheckPrimitiveExtent(&mvg_info,(double)\n      graphic_context[n]->stroke_width);\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == 0)\n      break;\n    if (i == 0)\n      continue;\n    /*\n      Transform points.\n    */\n    for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n    {\n      point=primitive_info[i].point;\n      primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+\n        graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;\n      primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+\n        graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;\n      point=primitive_info[i].point;\n      if (point.x < graphic_context[n]->bounds.x1)\n        graphic_context[n]->bounds.x1=point.x;\n      if (point.y < graphic_context[n]->bounds.y1)\n        graphic_context[n]->bounds.y1=point.y;\n      if (point.x > graphic_context[n]->bounds.x2)\n        graphic_context[n]->bounds.x2=point.x;\n      if (point.y > graphic_context[n]->bounds.y2)\n        graphic_context[n]->bounds.y2=point.y;\n      if (primitive_info[i].primitive == ImagePrimitive)\n        break;\n      if (i >= (ssize_t) number_points)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n    }\n    if (graphic_context[n]->render != MagickFalse)\n      {\n        if ((n != 0) && (graphic_context[n]->compliance != SVGCompliance) &&\n            (graphic_context[n]->clip_mask != (char *) NULL) &&\n            (LocaleCompare(graphic_context[n]->clip_mask,\n             graphic_context[n-1]->clip_mask) != 0))\n          {\n            const char\n              *clip_path;\n\n            clip_path=(const char *) GetValueFromSplayTree(macros,\n              graphic_context[n]->clip_mask);\n            if (clip_path != (const char *) NULL)\n              (void) SetImageArtifact(image,graphic_context[n]->clip_mask,\n                clip_path);\n            status&=DrawClipPath(image,graphic_context[n],\n              graphic_context[n]->clip_mask,exception);\n          }\n        status&=DrawPrimitive(image,graphic_context[n],primitive_info,\n          exception);\n      }\n    proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)\n      primitive_extent);\n    if (proceed == MagickFalse)\n      break;\n    if (status == 0)\n      break;\n  }\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end draw-image\");\n  /*\n    Relinquish resources.\n  */\n  macros=DestroySplayTree(macros);\n  token=DestroyString(token);\n  if (primitive_info != (PrimitiveInfo *) NULL)\n    {\n      for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n        if (primitive_info[i].text != (char *) NULL)\n          primitive_info[i].text=DestroyString(primitive_info[i].text);\n      primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);\n    }\n  primitive=DestroyString(primitive);\n  if (stops != (StopInfo *) NULL)\n    stops=(StopInfo *) RelinquishMagickMemory(stops);\n  for ( ; n >= 0; n--)\n    graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n  graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);\n  if (status == MagickFalse)\n    ThrowBinaryException(DrawError,\"NonconformingDrawingPrimitiveDefinition\",\n      keyword);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\nMagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,\n  ExceptionInfo *exception)\n{\n  return(RenderMVGContent(image,draw_info,0,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w P a t t e r n P a t h                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPatternPath() draws a pattern.\n%\n%  The format of the DrawPatternPath method is:\n%\n%      MagickBooleanType DrawPatternPath(Image *image,const DrawInfo *draw_info,\n%        const char *name,Image **pattern,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o name: the pattern name.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n\n  const char\n    *geometry,\n    *path,\n    *type;\n\n  DrawInfo\n    *clone_info;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w P o l y g o n P r i m i t i v e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPolygonPrimitive() draws a polygon on the image.\n%\n%  The format of the DrawPolygonPrimitive method is:\n%\n%      MagickBooleanType DrawPolygonPrimitive(Image *image,\n%        const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic PolygonInfo **DestroyPolygonTLS(PolygonInfo **polygon_info)\n{\n  ssize_t\n    i;\n\n  assert(polygon_info != (PolygonInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (polygon_info[i] != (PolygonInfo *) NULL)\n      polygon_info[i]=DestroyPolygonInfo(polygon_info[i]);\n  polygon_info=(PolygonInfo **) RelinquishMagickMemory(polygon_info);\n  return(polygon_info);\n}\n\nstatic PolygonInfo **AcquirePolygonTLS(const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  PathInfo\n    *magick_restrict path_info;\n\n  PolygonInfo\n    **polygon_info;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  polygon_info=(PolygonInfo **) AcquireQuantumMemory(number_threads,\n    sizeof(*polygon_info));\n  if (polygon_info == (PolygonInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PolygonInfo **) NULL);\n    }\n  (void) memset(polygon_info,0,number_threads*sizeof(*polygon_info));\n  path_info=ConvertPrimitiveToPath(primitive_info,exception);\n  if (path_info == (PathInfo *) NULL)\n    return(DestroyPolygonTLS(polygon_info));\n  polygon_info[0]=ConvertPathToPolygon(path_info,exception);\n  if (polygon_info[0] == (PolygonInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonTLS(polygon_info));\n    }\n  path_info=(PathInfo *) RelinquishMagickMemory(path_info);\n  return(polygon_info);\n}\n\nstatic MagickBooleanType ClonePolygonEdgesTLS(PolygonInfo **polygon_info,\n  const size_t number_threads,ExceptionInfo *exception)\n{\n  ssize_t\n    i;\n\n  for (i=1; i < (ssize_t) number_threads; i++)\n  {\n    EdgeInfo\n      *edge_info;\n\n    ssize_t\n      j;\n\n    polygon_info[i]=(PolygonInfo *) AcquireMagickMemory(\n      sizeof(*polygon_info[i]));\n    if (polygon_info[i] == (PolygonInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(MagickFalse);\n      }\n    polygon_info[i]->number_edges=0;\n    edge_info=polygon_info[0]->edges;\n    polygon_info[i]->edges=(EdgeInfo *) AcquireQuantumMemory(\n      polygon_info[0]->number_edges,sizeof(*edge_info));\n    if (polygon_info[i]->edges == (EdgeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(MagickFalse);\n      }\n    (void) memcpy(polygon_info[i]->edges,edge_info,\n      polygon_info[0]->number_edges*sizeof(*edge_info));\n    for (j=0; j < (ssize_t) polygon_info[i]->number_edges; j++)\n      polygon_info[i]->edges[j].points=(PointInfo *) NULL;\n    polygon_info[i]->number_edges=polygon_info[0]->number_edges;\n    for (j=0; j < (ssize_t) polygon_info[i]->number_edges; j++)\n    {\n      edge_info=polygon_info[0]->edges+j;\n      polygon_info[i]->edges[j].points=(PointInfo *) AcquireQuantumMemory(\n        edge_info->number_points,sizeof(*edge_info));\n      if (polygon_info[i]->edges[j].points == (PointInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      (void) memcpy(polygon_info[i]->edges[j].points,edge_info->points,\n        edge_info->number_points*sizeof(*edge_info->points));\n    }\n  }\n  return(MagickTrue);\n}\n\nstatic size_t DestroyEdge(PolygonInfo *polygon_info,const ssize_t edge)\n{\n  assert(edge < (ssize_t) polygon_info->number_edges);\n  polygon_info->edges[edge].points=(PointInfo *) RelinquishMagickMemory(\n    polygon_info->edges[edge].points);\n  polygon_info->number_edges--;\n  if (edge < (ssize_t) polygon_info->number_edges)\n    (void) memmove(polygon_info->edges+edge,polygon_info->edges+edge+1,\n      (size_t) (polygon_info->number_edges-edge)*sizeof(*polygon_info->edges));\n  return(polygon_info->number_edges);\n}\n\nstatic double GetFillAlpha(PolygonInfo *polygon_info,const double mid,\n  const MagickBooleanType fill,const FillRule fill_rule,const ssize_t x,\n  const ssize_t y,double *stroke_alpha)\n{\n  double\n    alpha,\n    beta,\n    distance,\n    subpath_alpha;\n\n  const PointInfo\n    *q;\n\n  EdgeInfo\n    *p;\n\n  PointInfo\n    delta;\n\n  ssize_t\n    i,\n    j,\n    winding_number;\n\n  /*\n    Compute fill & stroke opacity for this (x,y) point.\n  */\n  *stroke_alpha=0.0;\n  subpath_alpha=0.0;\n  p=polygon_info->edges;\n  for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)\n  {\n    if ((double) y <= (p->bounds.y1-mid-0.5))\n      break;\n    if ((double) y > (p->bounds.y2+mid+0.5))\n      {\n        p--;\n        (void) DestroyEdge(polygon_info,j--);\n        continue;\n      }\n    if (((double) x <= (p->bounds.x1-mid-0.5)) ||\n        ((double) x > (p->bounds.x2+mid+0.5)))\n      continue;\n    i=(ssize_t) MagickMax((double) p->highwater,1.0);\n    for ( ; i < (ssize_t) p->number_points; i++)\n    {\n      if ((double) y <= (p->points[i-1].y-mid-0.5))\n        break;\n      if ((double) y > (p->points[i].y+mid+0.5))\n        continue;\n      if (p->scanline != (double) y)\n        {\n          p->scanline=(double) y;\n          p->highwater=(size_t) i;\n        }\n      /*\n        Compute distance between a point and an edge.\n      */\n      q=p->points+i-1;\n      delta.x=(q+1)->x-q->x;\n      delta.y=(q+1)->y-q->y;\n      beta=delta.x*(x-q->x)+delta.y*(y-q->y);  /* segLen*point-cos(theta) */\n      if (beta <= 0.0)\n        {\n          /*\n            Cosine <= 0, point is closest to q.\n          */\n          delta.x=(double) x-q->x;\n          delta.y=(double) y-q->y;\n          distance=delta.x*delta.x+delta.y*delta.y;\n        }\n      else\n        {\n          alpha=delta.x*delta.x+delta.y*delta.y;  /* segLen*segLen */\n          if (beta >= alpha)\n            {\n              /*\n                Point is closest to q+1.\n              */\n              delta.x=(double) x-(q+1)->x;\n              delta.y=(double) y-(q+1)->y;\n              distance=delta.x*delta.x+delta.y*delta.y;\n            }\n          else\n            {\n              /*\n                Point is closest to point between q & q+1.\n              */\n              alpha=PerceptibleReciprocal(alpha);\n              beta=delta.x*(y-q->y)-delta.y*(x-q->x);\n              distance=alpha*beta*beta;\n            }\n        }\n      /*\n        Compute stroke & subpath opacity.\n      */\n      beta=0.0;\n      if (p->ghostline == MagickFalse)\n        {\n          alpha=mid+0.5;\n          if ((*stroke_alpha < 1.0) &&\n              (distance <= ((alpha+0.25)*(alpha+0.25))))\n            {\n              alpha=mid-0.5;\n              if (distance <= ((alpha+0.25)*(alpha+0.25)))\n                *stroke_alpha=1.0;\n              else\n                {\n                  beta=1.0;\n                  if (fabs(distance-1.0) >= MagickEpsilon)\n                    beta=sqrt((double) distance);\n                  alpha=beta-mid-0.5;\n                  if (*stroke_alpha < ((alpha-0.25)*(alpha-0.25)))\n                    *stroke_alpha=(alpha-0.25)*(alpha-0.25);\n                }\n            }\n        }\n      if ((fill == MagickFalse) || (distance > 1.0) || (subpath_alpha >= 1.0))\n        continue;\n      if (distance <= 0.0)\n        {\n          subpath_alpha=1.0;\n          continue;\n        }\n      if (distance > 1.0)\n        continue;\n      if (fabs(beta) < MagickEpsilon)\n        {\n          beta=1.0;\n          if (fabs(distance-1.0) >= MagickEpsilon)\n            beta=sqrt(distance);\n        }\n      alpha=beta-1.0;\n      if (subpath_alpha < (alpha*alpha))\n        subpath_alpha=alpha*alpha;\n    }\n  }\n  /*\n    Compute fill opacity.\n  */\n  if (fill == MagickFalse)\n    return(0.0);\n  if (subpath_alpha >= 1.0)\n    return(1.0);\n  /*\n    Determine winding number.\n  */\n  winding_number=0;\n  p=polygon_info->edges;\n  for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)\n  {\n    if ((double) y <= p->bounds.y1)\n      break;\n    if (((double) y > p->bounds.y2) || ((double) x <= p->bounds.x1))\n      continue;\n    if ((double) x > p->bounds.x2)\n      {\n        winding_number+=p->direction != 0 ? 1 : -1;\n        continue;\n      }\n    i=(ssize_t) MagickMax((double) p->highwater,1.0);\n    for ( ; i < (ssize_t) (p->number_points-1); i++)\n      if ((double) y <= p->points[i].y)\n        break;\n    q=p->points+i-1;\n    if ((((q+1)->x-q->x)*(y-q->y)) <= (((q+1)->y-q->y)*(x-q->x)))\n      winding_number+=p->direction != 0 ? 1 : -1;\n  }\n  if (fill_rule != NonZeroRule)\n    {\n      if ((MagickAbsoluteValue(winding_number) & 0x01) != 0)\n        return(1.0);\n    }\n  else\n    if (MagickAbsoluteValue(winding_number) != 0)\n      return(1.0);\n  return(subpath_alpha);\n}\n\nstatic MagickBooleanType DrawPolygonPrimitive(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  typedef struct _ExtentInfo\n  {\n    ssize_t\n      x1,\n      y1,\n      x2,\n      y2;\n  } ExtentInfo;\n\n  CacheView\n    *image_view;\n\n  const char\n    *artifact;\n\n  double\n    mid;\n\n  EdgeInfo\n    *p;\n\n  ExtentInfo\n    poly_extent;\n\n  MagickBooleanType\n    fill,\n    status;\n\n  PolygonInfo\n    **magick_restrict polygon_info;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    number_threads;\n\n  ssize_t\n    i,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  assert(primitive_info != (PrimitiveInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (primitive_info->coordinates <= 1)\n    return(MagickTrue);\n  /*\n    Compute bounding box.\n  */\n  polygon_info=AcquirePolygonTLS(primitive_info,exception);\n  if (polygon_info == (PolygonInfo **) NULL)\n    return(MagickFalse);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-polygon\");\n  fill=(primitive_info->method == FillToBorderMethod) ||\n    (primitive_info->method == FloodfillMethod) ? MagickTrue : MagickFalse;\n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n  bounds=polygon_info[0]->edges[0].bounds;\n  artifact=GetImageArtifact(image,\"draw:render-bounding-rectangles\");\n  if (IsStringTrue(artifact) != MagickFalse)\n    (void) DrawBoundingRectangles(image,draw_info,polygon_info[0],exception);\n  for (i=1; i < (ssize_t) polygon_info[0]->number_edges; i++)\n  {\n    p=polygon_info[0]->edges+i;\n    if (p->bounds.x1 < bounds.x1)\n      bounds.x1=p->bounds.x1;\n    if (p->bounds.y1 < bounds.y1)\n      bounds.y1=p->bounds.y1;\n    if (p->bounds.x2 > bounds.x2)\n      bounds.x2=p->bounds.x2;\n    if (p->bounds.y2 > bounds.y2)\n      bounds.y2=p->bounds.y2;\n  }\n  bounds.x1-=(mid+1.0);\n  bounds.y1-=(mid+1.0);\n  bounds.x2+=(mid+1.0);\n  bounds.y2+=(mid+1.0);\n  if ((bounds.x1 >= (double) image->columns) ||\n      (bounds.y1 >= (double) image->rows) ||\n      (bounds.x2 <= 0.0) || (bounds.y2 <= 0.0))\n    {\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      return(MagickTrue);  /* virtual polygon */\n    }\n  bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double) image->columns-1.0 ?\n    (double) image->columns-1.0 : bounds.x1;\n  bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double) image->rows-1.0 ?\n    (double) image->rows-1.0 : bounds.y1;\n  bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double) image->columns-1.0 ?\n    (double) image->columns-1.0 : bounds.x2;\n  bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double) image->rows-1.0 ?\n    (double) image->rows-1.0 : bounds.y2;\n  poly_extent.x1=CastDoubleToLong(ceil(bounds.x1-0.5));\n  poly_extent.y1=CastDoubleToLong(ceil(bounds.y1-0.5));\n  poly_extent.x2=CastDoubleToLong(floor(bounds.x2+0.5));\n  poly_extent.y2=CastDoubleToLong(floor(bounds.y2+0.5));\n  number_threads=GetMagickNumberThreads(image,image,poly_extent.y2-\n    poly_extent.y1+1,1);\n  status=ClonePolygonEdgesTLS(polygon_info,number_threads,exception);\n  if (status == MagickFalse)\n    {\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      return(status);\n    }\n  image_view=AcquireAuthenticCacheView(image,exception);\n  if ((primitive_info->coordinates == 1) ||\n      (polygon_info[0]->number_edges == 0))\n    {\n      /*\n        Draw point.\n      */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        num_threads(number_threads)\n#endif\n      for (y=poly_extent.y1; y <= poly_extent.y2; y++)\n      {\n        PixelInfo\n          pixel;\n\n        ssize_t\n          x;\n\n        Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        x=poly_extent.x1;\n        q=GetCacheViewAuthenticPixels(image_view,x,y,(size_t) (poly_extent.x2-\n          x+1),1,exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        GetPixelInfo(image,&pixel);\n        for ( ; x <= poly_extent.x2; x++)\n        {\n          if ((x == CastDoubleToLong(ceil(primitive_info->point.x-0.5))) &&\n              (y == CastDoubleToLong(ceil(primitive_info->point.y-0.5))))\n            {\n              GetFillColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&pixel,\n                exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n            }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      if (draw_info->debug != MagickFalse)\n        (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n          \"    end draw-polygon\");\n      return(status);\n    }\n  /*\n    Draw polygon or line.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    num_threads(number_threads)\n#endif\n  for (y=poly_extent.y1; y <= poly_extent.y2; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,poly_extent.x1,y,(size_t)\n      (poly_extent.x2-poly_extent.x1+1),1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=poly_extent.x1; x <= poly_extent.x2; x++)\n    {\n      double\n        fill_alpha,\n        stroke_alpha;\n\n      PixelInfo\n        fill_color,\n        stroke_color;\n\n      /*\n        Fill and/or stroke.\n      */\n      fill_alpha=GetFillAlpha(polygon_info[id],mid,fill,draw_info->fill_rule,\n        x,y,&stroke_alpha);\n      if (draw_info->stroke_antialias == MagickFalse)\n        {\n          fill_alpha=fill_alpha >= AntialiasThreshold ? 1.0 : 0.0;\n          stroke_alpha=stroke_alpha >= AntialiasThreshold ? 1.0 : 0.0;\n        }\n      GetFillColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&fill_color,\n        exception);\n      CompositePixelOver(image,&fill_color,fill_alpha*fill_color.alpha,q,\n        (double) GetPixelAlpha(image,q),q);\n      GetStrokeColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&stroke_color,\n        exception);\n      CompositePixelOver(image,&stroke_color,stroke_alpha*stroke_color.alpha,q,\n        (double) GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  polygon_info=DestroyPolygonTLS(polygon_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-polygon\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w P r i m i t i v e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPrimitive() draws a primitive (line, rectangle, ellipse) on the image.\n%\n%  The format of the DrawPrimitive method is:\n%\n%      MagickBooleanType DrawPrimitive(Image *image,const DrawInfo *draw_info,\n%        PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic void LogPrimitiveInfo(const PrimitiveInfo *primitive_info)\n{\n  const char\n    *methods[] =\n    {\n      \"point\",\n      \"replace\",\n      \"floodfill\",\n      \"filltoborder\",\n      \"reset\",\n      \"?\"\n    };\n\n  PointInfo\n    p,\n    point,\n    q;\n\n  ssize_t\n    i,\n    x;\n\n  ssize_t\n    coordinates,\n    y;\n\n  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));\n  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"AlphaPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case ColorPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"ColorPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case ImagePrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"ImagePrimitive %.20g,%.20g\",(double) x,(double) y);\n      return;\n    }\n    case PointPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"PointPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case TextPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"TextPrimitive %.20g,%.20g\",(double) x,(double) y);\n      return;\n    }\n    default:\n      break;\n  }\n  coordinates=0;\n  p=primitive_info[0].point;\n  q.x=(-1.0);\n  q.y=(-1.0);\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n  {\n    point=primitive_info[i].point;\n    if (coordinates <= 0)\n      {\n        coordinates=(ssize_t) primitive_info[i].coordinates;\n        (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n          \"    begin open (%.20g)\",(double) coordinates);\n        p=point;\n      }\n    point=primitive_info[i].point;\n    if ((fabs(q.x-point.x) >= MagickEpsilon) ||\n        (fabs(q.y-point.y) >= MagickEpsilon))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"      %.20g: %.18g,%.18g\",(double) coordinates,point.x,point.y);\n    else\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"      %.20g: %g %g (duplicate)\",(double) coordinates,point.x,point.y);\n    q=point;\n    coordinates--;\n    if (coordinates > 0)\n      continue;\n    if ((fabs(p.x-point.x) >= MagickEpsilon) ||\n        (fabs(p.y-point.y) >= MagickEpsilon))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end last (%.20g)\",\n        (double) coordinates);\n    else\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end open (%.20g)\",\n        (double) coordinates);\n  }\n}\n\nMagickExport MagickBooleanType DrawPrimitive(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  if (draw_info->debug != MagickFalse)\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"  begin draw-primitive\");\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"    affine: %g,%g,%g,%g,%g,%g\",draw_info->affine.sx,\n        draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,\n        draw_info->affine.tx,draw_info->affine.ty);\n    }\n  status=MagickTrue;\n  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&\n      ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||\n       (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))\n    status&=SetImageColorspace(image,sRGBColorspace,exception);\n  if (draw_info->compliance == SVGCompliance)\n    {\n      status&=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,\n        exception);\n      status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,\n        exception);\n    }\n  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));\n  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));\n  image_view=AcquireAuthenticCacheView(image,exception);\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status&=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      switch (primitive_info->method)\n      {\n        case PointMethod:\n        default:\n        {\n          PixelInfo\n            pixel;\n\n          Quantum\n            *q;\n\n          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          GetFillColor(draw_info,x,y,&pixel,exception);\n          SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n          status&=SyncCacheViewAuthenticPixels(image_view,exception);\n          break;\n        }\n        case ReplaceMethod:\n        {\n          PixelInfo\n            pixel,\n            target;\n\n          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,\n            exception);\n          GetPixelInfo(image,&pixel);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetPixelInfoPixel(image,q,&pixel);\n              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)\n                {\n                  q+=GetPixelChannels(image);\n                  continue;\n                }\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n        case FloodfillMethod:\n        case FillToBorderMethod:\n        {\n          ChannelType\n            channel_mask;\n\n          PixelInfo\n            target;\n\n          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,\n            &target,exception);\n          if (primitive_info->method == FillToBorderMethod)\n            {\n              target.red=(double) draw_info->border_color.red;\n              target.green=(double) draw_info->border_color.green;\n              target.blue=(double) draw_info->border_color.blue;\n            }\n          channel_mask=SetImageChannelMask(image,AlphaChannel);\n          status&=FloodfillPaintImage(image,draw_info,&target,x,y,\n            primitive_info->method == FloodfillMethod ? MagickFalse :\n            MagickTrue,exception);\n          (void) SetImageChannelMask(image,channel_mask);\n          break;\n        }\n        case ResetMethod:\n        {\n          PixelInfo\n            pixel;\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ColorPrimitive:\n    {\n      switch (primitive_info->method)\n      {\n        case PointMethod:\n        default:\n        {\n          PixelInfo\n            pixel;\n\n          Quantum\n            *q;\n\n          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          GetPixelInfo(image,&pixel);\n          GetFillColor(draw_info,x,y,&pixel,exception);\n          SetPixelViaPixelInfo(image,&pixel,q);\n          status&=SyncCacheViewAuthenticPixels(image_view,exception);\n          break;\n        }\n        case ReplaceMethod:\n        {\n          PixelInfo\n            pixel,\n            target;\n\n          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,\n            exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetPixelInfoPixel(image,q,&pixel);\n              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)\n                {\n                  q+=GetPixelChannels(image);\n                  continue;\n                }\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n        case FloodfillMethod:\n        case FillToBorderMethod:\n        {\n          PixelInfo\n            target;\n\n          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,\n            &target,exception);\n          if (primitive_info->method == FillToBorderMethod)\n            {\n              target.red=(double) draw_info->border_color.red;\n              target.green=(double) draw_info->border_color.green;\n              target.blue=(double) draw_info->border_color.blue;\n            }\n          status&=FloodfillPaintImage(image,draw_info,&target,x,y,\n            primitive_info->method == FloodfillMethod ? MagickFalse :\n            MagickTrue,exception);\n          break;\n        }\n        case ResetMethod:\n        {\n          PixelInfo\n            pixel;\n\n          GetPixelInfo(image,&pixel);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ImagePrimitive:\n    {\n      AffineMatrix\n        affine;\n\n      char\n        composite_geometry[MagickPathExtent];\n\n      Image\n        *composite_image,\n        *composite_images;\n\n      ImageInfo\n        *clone_info;\n\n      RectangleInfo\n        geometry;\n\n      ssize_t\n        x1,\n        y1;\n\n      if (primitive_info->text == (char *) NULL)\n        break;\n      clone_info=CloneImageInfo(draw_info->image_info);\n      composite_images=(Image *) NULL;\n      if (LocaleNCompare(primitive_info->text,\"data:\",5) == 0)\n        composite_images=ReadInlineImage(clone_info,primitive_info->text,\n          exception);\n      else\n        if (*primitive_info->text != '\\0')\n          {\n            MagickBooleanType\n              path_status;\n\n            struct stat\n              attributes;\n\n            /*\n              Read composite image.\n            */\n            (void) CopyMagickString(clone_info->filename,primitive_info->text,\n              MagickPathExtent);\n            (void) SetImageInfo(clone_info,1,exception);\n            (void) CopyMagickString(clone_info->filename,primitive_info->text,\n              MagickPathExtent);\n            if (clone_info->size != (char *) NULL)\n              clone_info->size=DestroyString(clone_info->size);\n            if (clone_info->extract != (char *) NULL)\n              clone_info->extract=DestroyString(clone_info->extract);\n            path_status=GetPathAttributes(clone_info->filename,&attributes);\n            if (path_status != MagickFalse)\n              {\n                if (S_ISCHR(attributes.st_mode) == 0)\n                  composite_images=ReadImage(clone_info,exception);\n                else\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    FileOpenError,\"UnableToOpenFile\",\"`%s'\",\n                      clone_info->filename);\n              }\n            else\n              if ((LocaleCompare(clone_info->magick,\"ftp\") != 0) &&\n                  (LocaleCompare(clone_info->magick,\"http\") != 0) &&\n                  (LocaleCompare(clone_info->magick,\"https\") != 0))\n                composite_images=ReadImage(clone_info,exception);\n              else\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  FileOpenError,\"UnableToOpenFile\",\"`%s'\",clone_info->filename);\n          }\n      clone_info=DestroyImageInfo(clone_info);\n      if (composite_images == (Image *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      composite_image=RemoveFirstImageFromList(&composite_images);\n      composite_images=DestroyImageList(composite_images);\n      (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)\n        NULL,(void *) NULL);\n      x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));\n      y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));\n      if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||\n          ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))\n        {\n          /*\n            Resize image.\n          */\n          (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n            \"%gx%g!\",primitive_info[1].point.x,primitive_info[1].point.y);\n          composite_image->filter=image->filter;\n          status&=TransformImage(&composite_image,(char *) NULL,\n            composite_geometry,exception);\n        }\n      if (composite_image->alpha_trait == UndefinedPixelTrait)\n        status&=SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,\n          exception);\n      if (draw_info->alpha != OpaqueAlpha)\n        status&=SetImageAlpha(composite_image,draw_info->alpha,exception);\n      SetGeometry(image,&geometry);\n      image->gravity=draw_info->gravity;\n      geometry.x=x;\n      geometry.y=y;\n      (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) composite_image->columns,(double)\n        composite_image->rows,(double) geometry.x,(double) geometry.y);\n      (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);\n      affine=draw_info->affine;\n      affine.tx=(double) geometry.x;\n      affine.ty=(double) geometry.y;\n      composite_image->interpolate=image->interpolate;\n      if ((draw_info->compose == OverCompositeOp) ||\n          (draw_info->compose == SrcOverCompositeOp))\n        status&=DrawAffineImage(image,composite_image,&affine,exception);\n      else\n        status&=CompositeImage(image,composite_image,draw_info->compose,\n          MagickTrue,geometry.x,geometry.y,exception);\n      composite_image=DestroyImage(composite_image);\n      break;\n    }\n    case PointPrimitive:\n    {\n      PixelInfo\n        fill_color;\n\n      Quantum\n        *q;\n\n      if ((y < 0) || (y >= (ssize_t) image->rows))\n        break;\n      if ((x < 0) || (x >= (ssize_t) image->columns))\n        break;\n      q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      GetFillColor(draw_info,x,y,&fill_color,exception);\n      CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      status&=SyncCacheViewAuthenticPixels(image_view,exception);\n      break;\n    }\n    case TextPrimitive:\n    {\n      char\n        geometry[MagickPathExtent];\n\n      DrawInfo\n        *clone_info;\n\n      if (primitive_info->text == (char *) NULL)\n        break;\n      clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n      (void) CloneString(&clone_info->text,primitive_info->text);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n        primitive_info->point.x,primitive_info->point.y);\n      (void) CloneString(&clone_info->geometry,geometry);\n      status&=AnnotateImage(image,clone_info,exception);\n      clone_info=DestroyDrawInfo(clone_info);\n      break;\n    }\n    default:\n    {\n      double\n        mid,\n        scale;\n\n      DrawInfo\n        *clone_info;\n\n      if (IsEventLogging() != MagickFalse)\n        LogPrimitiveInfo(primitive_info);\n      scale=ExpandAffine(&draw_info->affine);\n      if ((draw_info->dash_pattern != (double *) NULL) &&\n          (fabs(draw_info->dash_pattern[0]) >= MagickEpsilon) &&\n          (fabs(scale*draw_info->stroke_width) >= MagickEpsilon) &&\n          (draw_info->stroke.alpha != (Quantum) TransparentAlpha))\n        {\n          /*\n            Draw dash polygon.\n          */\n          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n          clone_info->stroke_width=0.0;\n          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,\n            exception);\n          clone_info=DestroyDrawInfo(clone_info);\n          if (status != MagickFalse)\n            status&=DrawDashPolygon(draw_info,primitive_info,image,exception);\n          break;\n        }\n      mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n      if ((mid > 1.0) &&\n          ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||\n           (draw_info->stroke_pattern != (Image *) NULL)))\n        {\n          double\n            point_x,\n            point_y;\n\n          MagickBooleanType\n            closed_path;\n\n          /*\n            Draw strokes while respecting line cap/join attributes.\n          */\n          closed_path=primitive_info[0].closed_subpath;\n          i=(ssize_t) primitive_info[0].coordinates;\n          point_x=fabs(primitive_info[i-1].point.x-primitive_info[0].point.x);\n          point_y=fabs(primitive_info[i-1].point.y-primitive_info[0].point.y);\n          if ((point_x < MagickEpsilon) && (point_y < MagickEpsilon))\n            closed_path=MagickTrue;\n          if ((((draw_info->linecap == RoundCap) ||\n                (closed_path != MagickFalse)) &&\n               (draw_info->linejoin == RoundJoin)) ||\n               (primitive_info[i].primitive != UndefinedPrimitive))\n            {\n              status&=DrawPolygonPrimitive(image,draw_info,primitive_info,\n                exception);\n              break;\n            }\n          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n          clone_info->stroke_width=0.0;\n          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,\n            exception);\n          clone_info=DestroyDrawInfo(clone_info);\n          if (status != MagickFalse)\n            status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);\n          break;\n        }\n      status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);\n      break;\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (draw_info->compliance == SVGCompliance)\n    {\n      status&=SetImageMask(image,WritePixelMask,(Image *) NULL,exception);\n      status&=SetImageMask(image,CompositePixelMask,(Image *) NULL,exception);\n    }\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  end draw-primitive\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w S t r o k e P o l y g o n                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawStrokePolygon() draws a stroked polygon (line, rectangle, ellipse) on\n%  the image while respecting the line cap and join attributes.\n%\n%  The format of the DrawStrokePolygon method is:\n%\n%      MagickBooleanType DrawStrokePolygon(Image *image,\n%        const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%\n*/\n\nstatic MagickBooleanType DrawRoundLinecap(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  PrimitiveInfo\n    linecap[5];\n\n  ssize_t\n    i;\n\n  for (i=0; i < 4; i++)\n    linecap[i]=(*primitive_info);\n  linecap[0].coordinates=4;\n  linecap[1].point.x+=2.0*MagickEpsilon;\n  linecap[2].point.x+=2.0*MagickEpsilon;\n  linecap[2].point.y+=2.0*MagickEpsilon;\n  linecap[3].point.y+=2.0*MagickEpsilon;\n  linecap[4].primitive=UndefinedPrimitive;\n  return(DrawPolygonPrimitive(image,draw_info,linecap,exception));\n}\n\nstatic MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  MagickBooleanType\n    closed_path;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *stroke_polygon;\n\n  const PrimitiveInfo\n    *p,\n    *q;\n\n  /*\n    Draw stroked polygon.\n  */\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    if (p->coordinates == 1)\n      continue;\n    stroke_polygon=TraceStrokePolygon(draw_info,p,exception);\n    if (stroke_polygon == (PrimitiveInfo *) NULL)\n      {\n        status=0;\n        break;\n      }\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    if (status == 0)\n      break;\n    q=p+p->coordinates-1;\n    closed_path=p->closed_subpath;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        status&=DrawRoundLinecap(image,draw_info,p,exception);\n        status&=DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A f f i n e M a t r i x                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAffineMatrix() returns an AffineMatrix initialized to the identity\n%  matrix.\n%\n%  The format of the GetAffineMatrix method is:\n%\n%      void GetAffineMatrix(AffineMatrix *affine_matrix)\n%\n%  A description of each parameter follows:\n%\n%    o affine_matrix: the affine matrix.\n%\n*/\nMagickExport void GetAffineMatrix(AffineMatrix *affine_matrix)\n{\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(affine_matrix != (AffineMatrix *) NULL);\n  (void) memset(affine_matrix,0,sizeof(*affine_matrix));\n  affine_matrix->sx=1.0;\n  affine_matrix->sy=1.0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t D r a w I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetDrawInfo() initializes draw_info to default values from image_info.\n%\n%  The format of the GetDrawInfo method is:\n%\n%      void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n{\n  char\n    *next_token;\n\n  const char\n    *option;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    Initialize draw attributes.\n  */\n  assert(draw_info != (DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  (void) memset(draw_info,0,sizeof(*draw_info));\n  draw_info->image_info=CloneImageInfo(image_info);\n  GetAffineMatrix(&draw_info->affine);\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(\"#000F\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#FFF0\",AllCompliance,&draw_info->stroke,\n    exception);\n  draw_info->stroke_antialias=draw_info->image_info->antialias;\n  draw_info->stroke_width=1.0;\n  draw_info->fill_rule=EvenOddRule;\n  draw_info->alpha=OpaqueAlpha;\n  draw_info->fill_alpha=OpaqueAlpha;\n  draw_info->stroke_alpha=OpaqueAlpha;\n  draw_info->linecap=ButtCap;\n  draw_info->linejoin=MiterJoin;\n  draw_info->miterlimit=10;\n  draw_info->decorate=NoDecoration;\n  draw_info->pointsize=12.0;\n  draw_info->undercolor.alpha=(MagickRealType) TransparentAlpha;\n  draw_info->compose=OverCompositeOp;\n  draw_info->render=MagickTrue;\n  draw_info->clip_path=MagickFalse;\n  draw_info->debug=(GetLogEventMask() & (DrawEvent | AnnotateEvent)) != 0 ?\n    MagickTrue : MagickFalse;\n  if (draw_info->image_info->font != (char *) NULL)\n    draw_info->font=AcquireString(draw_info->image_info->font);\n  if (draw_info->image_info->density != (char *) NULL)\n    draw_info->density=AcquireString(draw_info->image_info->density);\n  draw_info->text_antialias=draw_info->image_info->antialias;\n  if (fabs(draw_info->image_info->pointsize) >= MagickEpsilon)\n    draw_info->pointsize=draw_info->image_info->pointsize;\n  draw_info->border_color=draw_info->image_info->border_color;\n  if (draw_info->image_info->server_name != (char *) NULL)\n    draw_info->server_name=AcquireString(draw_info->image_info->server_name);\n  option=GetImageOption(draw_info->image_info,\"direction\");\n  if (option != (const char *) NULL)\n    draw_info->direction=(DirectionType) ParseCommandOption(\n      MagickDirectionOptions,MagickFalse,option);\n  else\n    draw_info->direction=UndefinedDirection;\n  option=GetImageOption(draw_info->image_info,\"encoding\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->encoding,option);\n  option=GetImageOption(draw_info->image_info,\"family\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->family,option);\n  option=GetImageOption(draw_info->image_info,\"fill\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->fill,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(draw_info->image_info,\"interline-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interline_spacing=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"interword-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interword_spacing=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"kerning\");\n  if (option != (const char *) NULL)\n    draw_info->kerning=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"stroke\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->stroke,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"strokewidth\");\n  if (option != (const char *) NULL)\n    draw_info->stroke_width=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"style\");\n  if (option != (const char *) NULL)\n    draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n      MagickFalse,option);\n  option=GetImageOption(draw_info->image_info,\"undercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->undercolor,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"weight\");\n  if (option != (const char *) NULL)\n    {\n      ssize_t\n        weight;\n\n      weight=ParseCommandOption(MagickWeightOptions,MagickFalse,option);\n      if (weight == -1)\n        weight=(ssize_t) StringToUnsignedLong(option);\n      draw_info->weight=(size_t) weight;\n    }\n  option=GetImageOption(draw_info->image_info,\"word-break\");\n  if (option != (const char *) NULL)\n    draw_info->word_break=(WordBreakType) ParseCommandOption(\n      MagickWordBreakOptions,MagickFalse,option);\n  exception=DestroyExceptionInfo(exception);\n  draw_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r m u t a t e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Permutate() returns the permutation of the (n,k).\n%\n%  The format of the Permutate method is:\n%\n%      void Permutate(ssize_t n,ssize_t k)\n%\n%  A description of each parameter follows:\n%\n%    o n:\n%\n%    o k:\n%\n%\n*/\nstatic inline double Permutate(const ssize_t n,const ssize_t k)\n{\n  double\n    r;\n\n  ssize_t\n    i;\n\n  r=1.0;\n  for (i=k+1; i <= n; i++)\n    r*=i;\n  for (i=1; i <= (n-k); i++)\n    r/=i;\n  return(r);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   T r a c e P r i m i t i v e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TracePrimitive is a collection of methods for generating graphic\n%  primitives such as arcs, ellipses, paths, etc.\n%\n*/\n\nstatic MagickBooleanType TraceArc(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end,const PointInfo degrees)\n{\n  PointInfo\n    center,\n    radius;\n\n  center.x=0.5*(end.x+start.x);\n  center.y=0.5*(end.y+start.y);\n  radius.x=fabs(center.x-start.x);\n  radius.y=fabs(center.y-start.y);\n  return(TraceEllipse(mvg_info,center,radius,degrees));\n}\n\nstatic MagickBooleanType TraceArcPath(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end,const PointInfo arc,const double angle,\n  const MagickBooleanType large_arc,const MagickBooleanType sweep)\n{\n  double\n    alpha,\n    beta,\n    delta,\n    factor,\n    gamma,\n    theta;\n\n  MagickStatusType\n    status;\n\n  PointInfo\n    center,\n    points[3],\n    radii;\n\n  double\n    cosine,\n    sine;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    arc_segments;\n\n  ssize_t\n    offset;\n\n  offset=mvg_info->offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=0;\n  if ((fabs(start.x-end.x) < MagickEpsilon) &&\n      (fabs(start.y-end.y) < MagickEpsilon))\n    return(TracePoint(primitive_info,end));\n  radii.x=fabs(arc.x);\n  radii.y=fabs(arc.y);\n  if ((radii.x < MagickEpsilon) || (radii.y < MagickEpsilon))\n    return(TraceLine(primitive_info,start,end));\n  cosine=cos(DegreesToRadians(fmod((double) angle,360.0)));\n  sine=sin(DegreesToRadians(fmod((double) angle,360.0)));\n  center.x=(double) (cosine*(end.x-start.x)/2+sine*(end.y-start.y)/2);\n  center.y=(double) (cosine*(end.y-start.y)/2-sine*(end.x-start.x)/2);\n  delta=(center.x*center.x)/(radii.x*radii.x)+(center.y*center.y)/\n    (radii.y*radii.y);\n  if (delta < MagickEpsilon)\n    return(TraceLine(primitive_info,start,end));\n  if (delta > 1.0)\n    {\n      radii.x*=sqrt((double) delta);\n      radii.y*=sqrt((double) delta);\n    }\n  points[0].x=(double) (cosine*start.x/radii.x+sine*start.y/radii.x);\n  points[0].y=(double) (cosine*start.y/radii.y-sine*start.x/radii.y);\n  points[1].x=(double) (cosine*end.x/radii.x+sine*end.y/radii.x);\n  points[1].y=(double) (cosine*end.y/radii.y-sine*end.x/radii.y);\n  alpha=points[1].x-points[0].x;\n  beta=points[1].y-points[0].y;\n  if (fabs(alpha*alpha+beta*beta) < MagickEpsilon)\n    return(TraceLine(primitive_info,start,end));\n  factor=PerceptibleReciprocal(alpha*alpha+beta*beta)-0.25;\n  if (factor <= 0.0)\n    factor=0.0;\n  else\n    {\n      factor=sqrt((double) factor);\n      if (sweep == large_arc)\n        factor=(-factor);\n    }\n  center.x=(double) ((points[0].x+points[1].x)/2-factor*beta);\n  center.y=(double) ((points[0].y+points[1].y)/2+factor*alpha);\n  alpha=atan2(points[0].y-center.y,points[0].x-center.x);\n  theta=atan2(points[1].y-center.y,points[1].x-center.x)-alpha;\n  if ((theta < 0.0) && (sweep != MagickFalse))\n    theta+=2.0*MagickPI;\n  else\n    if ((theta > 0.0) && (sweep == MagickFalse))\n      theta-=2.0*MagickPI;\n  arc_segments=(size_t) CastDoubleToLong(ceil(fabs((double) (theta/(0.5*\n    MagickPI+MagickEpsilon)))));\n  status=MagickTrue;\n  p=primitive_info;\n  for (i=0; i < (ssize_t) arc_segments; i++)\n  {\n    beta=0.5*((alpha+(i+1)*theta/arc_segments)-(alpha+i*theta/arc_segments));\n    gamma=(8.0/3.0)*sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))*\n      sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))/\n      sin(fmod((double) beta,DegreesToRadians(360.0)));\n    points[0].x=(double) (center.x+cos(fmod((double) (alpha+(double) i*theta/\n      arc_segments),DegreesToRadians(360.0)))-gamma*sin(fmod((double) (alpha+\n      (double) i*theta/arc_segments),DegreesToRadians(360.0))));\n    points[0].y=(double) (center.y+sin(fmod((double) (alpha+(double) i*theta/\n      arc_segments),DegreesToRadians(360.0)))+gamma*cos(fmod((double) (alpha+\n      (double) i*theta/arc_segments),DegreesToRadians(360.0))));\n    points[2].x=(double) (center.x+cos(fmod((double) (alpha+(double) (i+1)*\n      theta/arc_segments),DegreesToRadians(360.0))));\n    points[2].y=(double) (center.y+sin(fmod((double) (alpha+(double) (i+1)*\n      theta/arc_segments),DegreesToRadians(360.0))));\n    points[1].x=(double) (points[2].x+gamma*sin(fmod((double) (alpha+(double)\n      (i+1)*theta/arc_segments),DegreesToRadians(360.0))));\n    points[1].y=(double) (points[2].y-gamma*cos(fmod((double) (alpha+(double)\n      (i+1)*theta/arc_segments),DegreesToRadians(360.0))));\n    p->point.x=(p == primitive_info) ? start.x : (p-1)->point.x;\n    p->point.y=(p == primitive_info) ? start.y : (p-1)->point.y;\n    (p+1)->point.x=(double) (cosine*radii.x*points[0].x-sine*radii.y*\n      points[0].y);\n    (p+1)->point.y=(double) (sine*radii.x*points[0].x+cosine*radii.y*\n      points[0].y);\n    (p+2)->point.x=(double) (cosine*radii.x*points[1].x-sine*radii.y*\n      points[1].y);\n    (p+2)->point.y=(double) (sine*radii.x*points[1].x+cosine*radii.y*\n      points[1].y);\n    (p+3)->point.x=(double) (cosine*radii.x*points[2].x-sine*radii.y*\n      points[2].y);\n    (p+3)->point.y=(double) (sine*radii.x*points[2].x+cosine*radii.y*\n      points[2].y);\n    if (i == (ssize_t) (arc_segments-1))\n      (p+3)->point=end;\n    status&=TraceBezier(mvg_info,4);\n    if (status == 0)\n      break;\n    p=(*mvg_info->primitive_info)+mvg_info->offset;\n    mvg_info->offset+=p->coordinates;\n    p+=p->coordinates;\n  }\n  if (status == 0)\n    return(MagickFalse);\n  mvg_info->offset=offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) MAGICK_SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) MAGICK_SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,(double) control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceCircle(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end)\n{\n  double\n    alpha,\n    beta,\n    radius;\n\n  PointInfo\n    offset,\n    degrees;\n\n  alpha=end.x-start.x;\n  beta=end.y-start.y;\n  radius=hypot((double) alpha,(double) beta);\n  offset.x=(double) radius;\n  offset.y=(double) radius;\n  degrees.x=0.0;\n  degrees.y=360.0;\n  return(TraceEllipse(mvg_info,start,offset,degrees));\n}\n\nstatic MagickBooleanType TraceEllipse(MVGInfo *mvg_info,const PointInfo center,\n  const PointInfo radii,const PointInfo arc)\n{\n  double\n    coordinates,\n    delta,\n    step,\n    x,\n    y;\n\n  PointInfo\n    angle,\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  /*\n    Ellipses are just short segmented polys.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=0;\n  if ((fabs(radii.x) < MagickEpsilon) || (fabs(radii.y) < MagickEpsilon))\n    return(MagickTrue);\n  delta=2.0*PerceptibleReciprocal(MagickMax(radii.x,radii.y));\n  step=MagickPI/8.0;\n  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))\n    step=MagickPI/4.0/(MagickPI*PerceptibleReciprocal(delta)/2.0);\n  angle.x=DegreesToRadians(arc.x);\n  y=arc.y;\n  while (y < arc.x)\n    y+=360.0;\n  angle.y=DegreesToRadians(y);\n  coordinates=ceil((angle.y-angle.x)/step+1.0);\n  if (CheckPrimitiveExtent(mvg_info,coordinates) == MagickFalse)\n    return(MagickFalse);\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  for (p=primitive_info; angle.x < angle.y; angle.x+=step)\n  {\n    point.x=cos(fmod(angle.x,DegreesToRadians(360.0)))*radii.x+center.x;\n    point.y=sin(fmod(angle.x,DegreesToRadians(360.0)))*radii.y+center.y;\n    if (TracePoint(p,point) == MagickFalse)\n      return(MagickFalse);\n    p+=p->coordinates;\n  }\n  point.x=cos(fmod(angle.y,DegreesToRadians(360.0)))*radii.x+center.x;\n  point.y=sin(fmod(angle.y,DegreesToRadians(360.0)))*radii.y+center.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  x=fabs(primitive_info[0].point.x-\n    primitive_info[primitive_info->coordinates-1].point.x);\n  y=fabs(primitive_info[0].point.y-\n    primitive_info[primitive_info->coordinates-1].point.y);\n  if ((x < MagickEpsilon) && (y < MagickEpsilon))\n    primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceLine(PrimitiveInfo *primitive_info,\n  const PointInfo start,const PointInfo end)\n{\n  if (TracePoint(primitive_info,start) == MagickFalse)\n    return(MagickFalse);\n  if (TracePoint(primitive_info+1,end) == MagickFalse)\n    return(MagickFalse);\n  (primitive_info+1)->primitive=primitive_info->primitive;\n  primitive_info->coordinates=2;\n  primitive_info->closed_subpath=MagickFalse;\n  return(MagickTrue);\n}\n\nstatic ssize_t TracePath(MVGInfo *mvg_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    *next_token,\n    token[MagickPathExtent] = \"\";\n\n  const char\n    *p;\n\n  double\n    x,\n    y;\n\n  int\n    attribute,\n    last_attribute;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    end = {0.0, 0.0},\n    points[4] = { {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0} },\n    point = {0.0, 0.0},\n    start = {0.0, 0.0};\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  PrimitiveInfo\n    *q;\n\n  ssize_t\n    i;\n\n  size_t\n    number_coordinates,\n    z_count;\n\n  ssize_t\n    subpath_offset;\n\n  subpath_offset=mvg_info->offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  status=MagickTrue;\n  attribute=0;\n  number_coordinates=0;\n  z_count=0;\n  primitive_type=primitive_info->primitive;\n  q=primitive_info;\n  for (p=path; *p != '\\0'; )\n  {\n    if (status == MagickFalse)\n      break;\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == '\\0')\n      break;\n    last_attribute=attribute;\n    attribute=(int) (*p++);\n    switch (attribute)\n    {\n      case 'a':\n      case 'A':\n      {\n        double\n          angle = 0.0;\n\n        MagickBooleanType\n          large_arc = MagickFalse,\n          sweep = MagickFalse;\n\n        PointInfo\n          arc = {0.0, 0.0};\n\n        /*\n          Elliptical arc.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          arc.x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          arc.y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          angle=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          sweep=StringToLong(token) != 0 ? MagickTrue : MagickFalse;\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          end.x=(double) (attribute == (int) 'A' ? x : point.x+x);\n          end.y=(double) (attribute == (int) 'A' ? y : point.y+y);\n          if (TraceArcPath(mvg_info,point,end,arc,angle,large_arc,sweep) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        /*\n          Cubic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=point;\n          for (i=1; i < 4; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            end.x=(double) (attribute == (int) 'C' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'C' ? y : point.y+y);\n            points[i]=end;\n          }\n          for (i=0; i < 4; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,4) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'H':\n      case 'h':\n      {\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'H' ? x: point.x+x);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        /*\n          Line to.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'L' ? x : point.x+x);\n          point.y=(double) (attribute == (int) 'L' ? y : point.y+y);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'M':\n      case 'm':\n      {\n        /*\n          Move to.\n        */\n        if (mvg_info->offset != subpath_offset)\n          {\n            primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n            primitive_info->coordinates=(size_t) (q-primitive_info);\n            number_coordinates+=primitive_info->coordinates;\n            primitive_info=q;\n            subpath_offset=mvg_info->offset;\n          }\n        i=0;\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'M' ? x : point.x+x);\n          point.y=(double) (attribute == (int) 'M' ? y : point.y+y);\n          if (i == 0)\n            start=point;\n          i++;\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'q':\n      case 'Q':\n      {\n        /*\n          Quadratic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=point;\n          for (i=1; i < 3; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (*p == ',')\n              p++;\n            end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);\n            points[i]=end;\n          }\n          for (i=0; i < 3; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,3) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        /*\n          Cubic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=points[3];\n          points[1].x=2.0*points[3].x-points[2].x;\n          points[1].y=2.0*points[3].y-points[2].y;\n          for (i=2; i < 4; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (*p == ',')\n              p++;\n            end.x=(double) (attribute == (int) 'S' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'S' ? y : point.y+y);\n            points[i]=end;\n          }\n          if (strchr(\"CcSs\",last_attribute) == (char *) NULL)\n            {\n              points[0]=point;\n              points[1]=point;\n            }\n          for (i=0; i < 4; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,4) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          last_attribute=attribute;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        /*\n          Quadratic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=points[2];\n          points[1].x=2.0*points[2].x-points[1].x;\n          points[1].y=2.0*points[2].y-points[1].y;\n          for (i=2; i < 3; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            end.x=(double) (attribute == (int) 'T' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'T' ? y : point.y+y);\n            points[i]=end;\n          }\n          if (status == MagickFalse)\n            break;\n          if (strchr(\"QqTt\",last_attribute) == (char *) NULL)\n            {\n              points[0]=point;\n              points[1]=point;\n            }\n          for (i=0; i < 3; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,3) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          last_attribute=attribute;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        /*\n          Line to.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.y=(double) (attribute == (int) 'V' ? y : point.y+y);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'z':\n      case 'Z':\n      {\n        /*\n          Close path.\n        */\n        point=start;\n        if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n          return(-1);\n        q=(*mvg_info->primitive_info)+mvg_info->offset;\n        if (TracePoint(q,point) == MagickFalse)\n          return(-1);\n        mvg_info->offset+=q->coordinates;\n        q+=q->coordinates;\n        primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n        primitive_info->coordinates=(size_t) (q-primitive_info);\n        primitive_info->closed_subpath=MagickTrue;\n        number_coordinates+=primitive_info->coordinates;\n        primitive_info=q;\n        subpath_offset=mvg_info->offset;\n        z_count++;\n        break;\n      }\n      default:\n      {\n        ThrowPointExpectedException(token,exception);\n        break;\n      }\n    }\n  }\n  if (status == MagickFalse)\n    return(-1);\n  primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n  primitive_info->coordinates=(size_t) (q-primitive_info);\n  number_coordinates+=primitive_info->coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    q--;\n    q->primitive=primitive_type;\n    if (z_count > 1)\n      q->method=FillToBorderMethod;\n  }\n  q=primitive_info;\n  return((ssize_t) number_coordinates);\n}\n\nstatic MagickBooleanType TraceRectangle(PrimitiveInfo *primitive_info,\n  const PointInfo start,const PointInfo end)\n{\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  p=primitive_info;\n  if (TracePoint(p,start) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  point.x=start.x;\n  point.y=end.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  if (TracePoint(p,end) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  point.x=end.x;\n  point.y=start.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  if (TracePoint(p,start) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceRoundRectangle(MVGInfo *mvg_info,\n  const PointInfo start,const PointInfo end,PointInfo arc)\n{\n  PointInfo\n    degrees,\n    point,\n    segment;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  ssize_t\n    offset;\n\n  offset=mvg_info->offset;\n  segment.x=fabs(end.x-start.x);\n  segment.y=fabs(end.y-start.y);\n  if ((segment.x < MagickEpsilon) || (segment.y < MagickEpsilon))\n    {\n      (*mvg_info->primitive_info+mvg_info->offset)->coordinates=0;\n      return(MagickTrue);\n    }\n  if (arc.x > (0.5*segment.x))\n    arc.x=0.5*segment.x;\n  if (arc.y > (0.5*segment.y))\n    arc.y=0.5*segment.y;\n  point.x=start.x+segment.x-arc.x;\n  point.y=start.y+arc.y;\n  degrees.x=270.0;\n  degrees.y=360.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+segment.x-arc.x;\n  point.y=start.y+segment.y-arc.y;\n  degrees.x=0.0;\n  degrees.y=90.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+arc.x;\n  point.y=start.y+segment.y-arc.y;\n  degrees.x=90.0;\n  degrees.y=180.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+arc.x;\n  point.y=start.y+arc.y;\n  degrees.x=180.0;\n  degrees.y=270.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  if (TracePoint(p,(*mvg_info->primitive_info+offset)->point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  mvg_info->offset=offset;\n  primitive_info=(*mvg_info->primitive_info)+offset;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceSquareLinecap(PrimitiveInfo *primitive_info,\n  const size_t number_vertices,const double offset)\n{\n  double\n    distance;\n\n  double\n    dx,\n    dy;\n\n  ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  dx=0.0;\n  dy=0.0;\n  for (i=1; i < (ssize_t) number_vertices; i++)\n  {\n    dx=primitive_info[0].point.x-primitive_info[i].point.x;\n    dy=primitive_info[0].point.y-primitive_info[i].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  if (i == (ssize_t) number_vertices)\n    i=(ssize_t) number_vertices-1L;\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[0].point.x=(double) (primitive_info[i].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[0].point.y=(double) (primitive_info[i].point.y+\n    dy*(distance+offset)/distance);\n  for (j=(ssize_t) number_vertices-2; j >= 0;  j--)\n  {\n    dx=primitive_info[number_vertices-1].point.x-primitive_info[j].point.x;\n    dy=primitive_info[number_vertices-1].point.y-primitive_info[j].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[number_vertices-1].point.x=(double) (primitive_info[j].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[number_vertices-1].point.y=(double) (primitive_info[j].point.y+\n    dy*(distance+offset)/distance);\n  return(MagickTrue);\n}\n\nstatic PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n{\n#define MaxStrokePad  (6*BezierQuantum+360)\n#define CheckPathExtent(pad_p,pad_q) \\\n{   \\\n  if ((pad_p) > MaxBezierCoordinates) \\\n    stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n  else \\\n    if ((ssize_t) (p+(pad_p)) >= (ssize_t) extent_p) \\\n      { \\\n        if (~extent_p < (pad_p)) \\\n          stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n        else \\\n          { \\\n            extent_p+=(pad_p); \\\n            stroke_p=(PointInfo *) ResizeQuantumMemory(stroke_p,extent_p+ \\\n              MaxStrokePad,sizeof(*stroke_p)); \\\n          } \\\n      } \\\n  if ((pad_q) > MaxBezierCoordinates) \\\n    stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n  else \\\n    if ((ssize_t) (q+(pad_q)) >= (ssize_t) extent_q) \\\n      { \\\n        if (~extent_q < (pad_q)) \\\n          stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n        else \\\n          { \\\n            extent_q+=(pad_q); \\\n            stroke_q=(PointInfo *) ResizeQuantumMemory(stroke_q,extent_q+ \\\n              MaxStrokePad,sizeof(*stroke_q)); \\\n          } \\\n      } \\\n  if ((stroke_p == (PointInfo *) NULL) || (stroke_q == (PointInfo *) NULL)) \\\n    { \\\n      if (stroke_p != (PointInfo *) NULL) \\\n        stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n      if (stroke_q != (PointInfo *) NULL) \\\n        stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n      polygon_primitive=(PrimitiveInfo *) \\\n        RelinquishMagickMemory(polygon_primitive); \\\n      (void) ThrowMagickException(exception,GetMagickModule(), \\\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\"); \\\n      return((PrimitiveInfo *) NULL); \\\n    } \\\n}\n\n  typedef struct _StrokeSegment\n  {\n    double\n      p,\n      q;\n  } StrokeSegment;\n\n  double\n    delta_theta,\n    dot_product,\n    mid,\n    miterlimit;\n\n  MagickBooleanType\n    closed_path;\n\n  PointInfo\n    box_p[5],\n    box_q[5],\n    center,\n    offset,\n    *stroke_p,\n    *stroke_q;\n\n  PrimitiveInfo\n    *polygon_primitive,\n    *stroke_polygon;\n\n  ssize_t\n    i;\n\n  size_t\n    arc_segments,\n    extent_p,\n    extent_q,\n    number_vertices;\n\n  ssize_t\n    j,\n    n,\n    p,\n    q;\n\n  StrokeSegment\n    dx = {0.0, 0.0},\n    dy = {0.0, 0.0},\n    inverse_slope = {0.0, 0.0},\n    slope = {0.0, 0.0},\n    theta = {0.0, 0.0};\n\n  /*\n    Allocate paths.\n  */\n  number_vertices=primitive_info->coordinates;\n  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    number_vertices+2UL,sizeof(*polygon_primitive));\n  if (polygon_primitive == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PrimitiveInfo *) NULL);\n    }\n  (void) memcpy(polygon_primitive,primitive_info,(size_t) number_vertices*\n    sizeof(*polygon_primitive));\n  offset.x=primitive_info[number_vertices-1].point.x-primitive_info[0].point.x;\n  offset.y=primitive_info[number_vertices-1].point.y-primitive_info[0].point.y;\n  closed_path=(fabs(offset.x) < MagickEpsilon) &&\n    (fabs(offset.y) < MagickEpsilon) ?  MagickTrue : MagickFalse;\n  if (((draw_info->linejoin == RoundJoin) ||\n       (draw_info->linejoin == MiterJoin)) && (closed_path != MagickFalse))\n    {\n      polygon_primitive[number_vertices]=primitive_info[1];\n      number_vertices++;\n    }\n  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;\n  /*\n    Compute the slope for the first line segment, p.\n  */\n  dx.p=0.0;\n  dy.p=0.0;\n  for (n=1; n < (ssize_t) number_vertices; n++)\n  {\n    dx.p=polygon_primitive[n].point.x-polygon_primitive[0].point.x;\n    dy.p=polygon_primitive[n].point.y-polygon_primitive[0].point.y;\n    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))\n      break;\n  }\n  if (n == (ssize_t) number_vertices)\n    {\n      if ((draw_info->linecap != RoundCap) || (closed_path != MagickFalse))\n        {\n          /*\n            Zero length subpath.\n          */\n          stroke_polygon=(PrimitiveInfo *) AcquireCriticalMemory(\n            sizeof(*stroke_polygon));\n          stroke_polygon[0]=polygon_primitive[0];\n          stroke_polygon[0].coordinates=0;\n          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(\n            polygon_primitive);\n          return(stroke_polygon);\n        }\n      n=(ssize_t) number_vertices-1L;\n    }\n  extent_p=2*number_vertices;\n  extent_q=2*number_vertices;\n  stroke_p=(PointInfo *) AcquireQuantumMemory((size_t) extent_p+MaxStrokePad,\n    sizeof(*stroke_p));\n  stroke_q=(PointInfo *) AcquireQuantumMemory((size_t) extent_q+MaxStrokePad,\n    sizeof(*stroke_q));\n  if ((stroke_p == (PointInfo *) NULL) || (stroke_q == (PointInfo *) NULL))\n    {\n      if (stroke_p != (PointInfo *) NULL)\n        stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n      if (stroke_q != (PointInfo *) NULL)\n        stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n      polygon_primitive=(PrimitiveInfo *)\n        RelinquishMagickMemory(polygon_primitive);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PrimitiveInfo *) NULL);\n    }\n  slope.p=0.0;\n  inverse_slope.p=0.0;\n  if (fabs(dx.p) < MagickEpsilon)\n    {\n      if (dx.p >= 0.0)\n        slope.p=dy.p < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n      else\n        slope.p=dy.p < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n    }\n  else\n    if (fabs(dy.p) < MagickEpsilon)\n      {\n        if (dy.p >= 0.0)\n          inverse_slope.p=dx.p < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n        else\n          inverse_slope.p=dx.p < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n      }\n    else\n      {\n        slope.p=dy.p/dx.p;\n        inverse_slope.p=(-1.0*PerceptibleReciprocal(slope.p));\n      }\n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n  miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);\n  if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))\n    (void) TraceSquareLinecap(polygon_primitive,number_vertices,mid);\n  offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));\n  offset.y=(double) (offset.x*inverse_slope.p);\n  if ((dy.p*offset.x-dx.p*offset.y) > 0.0)\n    {\n      box_p[0].x=polygon_primitive[0].point.x-offset.x;\n      box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;\n      box_p[1].x=polygon_primitive[n].point.x-offset.x;\n      box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;\n      box_q[0].x=polygon_primitive[0].point.x+offset.x;\n      box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;\n      box_q[1].x=polygon_primitive[n].point.x+offset.x;\n      box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;\n    }\n  else\n    {\n      box_p[0].x=polygon_primitive[0].point.x+offset.x;\n      box_p[0].y=polygon_primitive[0].point.y+offset.y;\n      box_p[1].x=polygon_primitive[n].point.x+offset.x;\n      box_p[1].y=polygon_primitive[n].point.y+offset.y;\n      box_q[0].x=polygon_primitive[0].point.x-offset.x;\n      box_q[0].y=polygon_primitive[0].point.y-offset.y;\n      box_q[1].x=polygon_primitive[n].point.x-offset.x;\n      box_q[1].y=polygon_primitive[n].point.y-offset.y;\n    }\n  /*\n    Create strokes for the line join attribute: bevel, miter, round.\n  */\n  p=0;\n  q=0;\n  stroke_q[p++]=box_q[0];\n  stroke_p[q++]=box_p[0];\n  for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)\n  {\n    /*\n      Compute the slope for this line segment, q.\n    */\n    dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;\n    dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;\n    dot_product=dx.q*dx.q+dy.q*dy.q;\n    if (dot_product < 0.25)\n      continue;\n    slope.q=0.0;\n    inverse_slope.q=0.0;\n    if (fabs(dx.q) < MagickEpsilon)\n      {\n        if (dx.q >= 0.0)\n          slope.q=dy.q < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n        else\n          slope.q=dy.q < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n      }\n    else\n      if (fabs(dy.q) < MagickEpsilon)\n        {\n          if (dy.q >= 0.0)\n            inverse_slope.q=dx.q < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n          else\n            inverse_slope.q=dx.q < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n        }\n      else\n        {\n          slope.q=dy.q/dx.q;\n          inverse_slope.q=(-1.0*PerceptibleReciprocal(slope.q));\n        }\n    offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));\n    offset.y=(double) (offset.x*inverse_slope.q);\n    dot_product=dy.q*offset.x-dx.q*offset.y;\n    if (dot_product > 0.0)\n      {\n        box_p[2].x=polygon_primitive[n].point.x-offset.x;\n        box_p[2].y=polygon_primitive[n].point.y-offset.y;\n        box_p[3].x=polygon_primitive[i].point.x-offset.x;\n        box_p[3].y=polygon_primitive[i].point.y-offset.y;\n        box_q[2].x=polygon_primitive[n].point.x+offset.x;\n        box_q[2].y=polygon_primitive[n].point.y+offset.y;\n        box_q[3].x=polygon_primitive[i].point.x+offset.x;\n        box_q[3].y=polygon_primitive[i].point.y+offset.y;\n      }\n    else\n      {\n        box_p[2].x=polygon_primitive[n].point.x+offset.x;\n        box_p[2].y=polygon_primitive[n].point.y+offset.y;\n        box_p[3].x=polygon_primitive[i].point.x+offset.x;\n        box_p[3].y=polygon_primitive[i].point.y+offset.y;\n        box_q[2].x=polygon_primitive[n].point.x-offset.x;\n        box_q[2].y=polygon_primitive[n].point.y-offset.y;\n        box_q[3].x=polygon_primitive[i].point.x-offset.x;\n        box_q[3].y=polygon_primitive[i].point.y-offset.y;\n      }\n    if (fabs((double) (slope.p-slope.q)) < MagickEpsilon)\n      {\n        box_p[4]=box_p[1];\n        box_q[4]=box_q[1];\n      }\n    else\n      {\n        box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+\n          box_p[3].y)/(slope.p-slope.q));\n        box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);\n        box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+\n          box_q[3].y)/(slope.p-slope.q));\n        box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);\n      }\n    DisableMSCWarning(4127)\n    CheckPathExtent(MaxStrokePad,MaxStrokePad);\n    RestoreMSCWarning\n    dot_product=dx.q*dy.p-dx.p*dy.q;\n    if (dot_product <= 0.0)\n      switch (draw_info->linejoin)\n      {\n        case BevelJoin:\n        {\n          stroke_q[q++]=box_q[1];\n          stroke_q[q++]=box_q[2];\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_p[p++]=box_p[4];\n          else\n            {\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case MiterJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            {\n              stroke_q[q++]=box_q[4];\n              stroke_p[p++]=box_p[4];\n            }\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case RoundJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_p[p++]=box_p[4];\n          else\n            {\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          center=polygon_primitive[n].point;\n          theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);\n          theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);\n          if (theta.q < theta.p)\n            theta.q+=2.0*MagickPI;\n          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.q-\n            theta.p)/(2.0*sqrt(PerceptibleReciprocal(mid))))));\n          DisableMSCWarning(4127)\n          CheckPathExtent(MaxStrokePad,arc_segments+MaxStrokePad);\n          RestoreMSCWarning\n          stroke_q[q].x=box_q[1].x;\n          stroke_q[q].y=box_q[1].y;\n          q++;\n          for (j=1; j < (ssize_t) arc_segments; j++)\n          {\n            delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);\n            stroke_q[q].x=(double) (center.x+mid*cos(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            stroke_q[q].y=(double) (center.y+mid*sin(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            q++;\n          }\n          stroke_q[q++]=box_q[2];\n          break;\n        }\n        default:\n          break;\n      }\n    else\n      switch (draw_info->linejoin)\n      {\n        case BevelJoin:\n        {\n          stroke_p[p++]=box_p[1];\n          stroke_p[p++]=box_p[2];\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_q[q++]=box_q[4];\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n            }\n          break;\n        }\n        case MiterJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            {\n              stroke_q[q++]=box_q[4];\n              stroke_p[p++]=box_p[4];\n            }\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case RoundJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_q[q++]=box_q[4];\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n            }\n          center=polygon_primitive[n].point;\n          theta.p=atan2(box_p[1].y-center.y,box_p[1].x-center.x);\n          theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);\n          if (theta.p < theta.q)\n            theta.p+=2.0*MagickPI;\n          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.p-\n            theta.q)/(2.0*sqrt((double) (PerceptibleReciprocal(mid)))))));\n          DisableMSCWarning(4127)\n          CheckPathExtent(arc_segments+MaxStrokePad,MaxStrokePad);\n          RestoreMSCWarning\n          stroke_p[p++]=box_p[1];\n          for (j=1; j < (ssize_t) arc_segments; j++)\n          {\n            delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);\n            stroke_p[p].x=(double) (center.x+mid*cos(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            stroke_p[p].y=(double) (center.y+mid*sin(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            p++;\n          }\n          stroke_p[p++]=box_p[2];\n          break;\n        }\n        default:\n          break;\n      }\n    slope.p=slope.q;\n    inverse_slope.p=inverse_slope.q;\n    box_p[0]=box_p[2];\n    box_p[1]=box_p[3];\n    box_q[0]=box_q[2];\n    box_q[1]=box_q[3];\n    dx.p=dx.q;\n    dy.p=dy.q;\n    n=i;\n  }\n  stroke_p[p++]=box_p[1];\n  stroke_q[q++]=box_q[1];\n  /*\n    Trace stroked polygon.\n  */\n  stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (p+q+2UL*closed_path+2UL),sizeof(*stroke_polygon));\n  if (stroke_polygon == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n      stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(\n        polygon_primitive);\n      return(stroke_polygon);\n    }\n  for (i=0; i < (ssize_t) p; i++)\n  {\n    stroke_polygon[i]=polygon_primitive[0];\n    stroke_polygon[i].point=stroke_p[i];\n  }\n  if (closed_path != MagickFalse)\n    {\n      stroke_polygon[i]=polygon_primitive[0];\n      stroke_polygon[i].point=stroke_polygon[0].point;\n      i++;\n    }\n  for ( ; i < (ssize_t) (p+q+closed_path); i++)\n  {\n    stroke_polygon[i]=polygon_primitive[0];\n    stroke_polygon[i].point=stroke_q[p+q+closed_path-(i+1)];\n  }\n  if (closed_path != MagickFalse)\n    {\n      stroke_polygon[i]=polygon_primitive[0];\n      stroke_polygon[i].point=stroke_polygon[p+closed_path].point;\n      i++;\n    }\n  stroke_polygon[i]=polygon_primitive[0];\n  stroke_polygon[i].point=stroke_polygon[0].point;\n  i++;\n  stroke_polygon[i].primitive=UndefinedPrimitive;\n  stroke_polygon[0].coordinates=(size_t) (p+q+2*closed_path+1);\n  stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n  stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n  polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);\n  return(stroke_polygon);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        DDDD   RRRR    AAA   W   W                           %\n%                        D   D  R   R  A   A  W   W                           %\n%                        D   D  RRRR   AAAAA  W W W                           %\n%                        D   D  R RN   A   A  WW WW                           %\n%                        DDDD   R  R   A   A  W   W                           %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Drawing Methods                        %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1998                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Bill Radcliffe of Corbis (www.corbis.com) contributed the polygon\n% rendering code based on Paul Heckbert's \"Concave Polygon Scan Conversion\",\n% Graphics Gems, 1990.  Leonard Rosenthal and David Harr of Appligent\n% (www.appligent.com) contributed the dash pattern, linecap stroking\n% algorithm, and minor rendering improvements.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resample-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define AntialiasThreshold  (1.0/3.0)\n#define BezierQuantum  200\n#define PrimitiveExtentPad  4296.0\n#define MaxBezierCoordinates  67108864\n#define ThrowPointExpectedException(token,exception) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DrawError, \\\n    \"NonconformingDrawingPrimitiveDefinition\",\"`%s'\",token); \\\n  status=MagickFalse; \\\n  break; \\\n}\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _EdgeInfo\n{\n  SegmentInfo\n    bounds;\n\n  double\n    scanline;\n\n  PointInfo\n    *points;\n\n  size_t\n    number_points;\n\n  ssize_t\n    direction;\n\n  MagickBooleanType\n    ghostline;\n\n  size_t\n    highwater;\n} EdgeInfo;\n\ntypedef struct _ElementInfo\n{\n  double\n    cx,\n    cy,\n    major,\n    minor,\n    angle;\n} ElementInfo;\n\ntypedef struct _MVGInfo\n{\n  PrimitiveInfo\n    **primitive_info;\n\n  size_t\n    *extent;\n\n  ssize_t\n    offset;\n\n  PointInfo\n    point;\n\n  ExceptionInfo\n    *exception;\n} MVGInfo;\n\ntypedef struct _PolygonInfo\n{\n  EdgeInfo\n    *edges;\n\n  size_t\n    number_edges;\n} PolygonInfo;\n\ntypedef enum\n{\n  MoveToCode,\n  OpenCode,\n  GhostlineCode,\n  LineToCode,\n  EndCode\n} PathInfoCode;\n\ntypedef struct _PathInfo\n{\n  PointInfo\n    point;\n\n  PathInfoCode\n    code;\n} PathInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic Image\n  *DrawClippingMask(Image *,const DrawInfo *,const char *,const char *,\n    ExceptionInfo *);\n\nstatic MagickBooleanType\n  DrawStrokePolygon(Image *,const DrawInfo *,const PrimitiveInfo *,\n    ExceptionInfo *),\n  RenderMVGContent(Image *,const DrawInfo *,const size_t,ExceptionInfo *),\n  TraceArc(MVGInfo *,const PointInfo,const PointInfo,const PointInfo),\n  TraceArcPath(MVGInfo *,const PointInfo,const PointInfo,const PointInfo,\n    const double,const MagickBooleanType,const MagickBooleanType),\n  TraceBezier(MVGInfo *,const size_t),\n  TraceCircle(MVGInfo *,const PointInfo,const PointInfo),\n  TraceEllipse(MVGInfo *,const PointInfo,const PointInfo,const PointInfo),\n  TraceLine(PrimitiveInfo *,const PointInfo,const PointInfo),\n  TraceRectangle(PrimitiveInfo *,const PointInfo,const PointInfo),\n  TraceRoundRectangle(MVGInfo *,const PointInfo,const PointInfo,PointInfo),\n  TraceSquareLinecap(PrimitiveInfo *,const size_t,const double);\n\nstatic PrimitiveInfo\n  *TraceStrokePolygon(const DrawInfo *,const PrimitiveInfo *,ExceptionInfo *);\n\nstatic ssize_t\n  TracePath(MVGInfo *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e D r a w I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireDrawInfo() returns a DrawInfo structure properly initialized.\n%\n%  The format of the AcquireDrawInfo method is:\n%\n%      DrawInfo *AcquireDrawInfo(void)\n%\n*/\nMagickExport DrawInfo *AcquireDrawInfo(void)\n{\n  DrawInfo\n    *draw_info;\n\n  draw_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*draw_info));\n  GetDrawInfo((ImageInfo *) NULL,draw_info);\n  return(draw_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e D r a w I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneDrawInfo() makes a copy of the given draw_info structure.  If NULL\n%  is specified, a new DrawInfo structure is created initialized to default\n%  values.\n%\n%  The format of the CloneDrawInfo method is:\n%\n%      DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n%        const DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n  const DrawInfo *draw_info)\n{\n  DrawInfo\n    *clone_info;\n\n  ExceptionInfo\n    *exception;\n\n  clone_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetDrawInfo(image_info,clone_info);\n  if (draw_info == (DrawInfo *) NULL)\n    return(clone_info);\n  exception=AcquireExceptionInfo();\n  if (draw_info->id != (char *) NULL)\n    (void) CloneString(&clone_info->id,draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    (void) CloneString(&clone_info->primitive,draw_info->primitive);\n  if (draw_info->geometry != (char *) NULL)\n    (void) CloneString(&clone_info->geometry,draw_info->geometry);\n  clone_info->compliance=draw_info->compliance;\n  clone_info->viewbox=draw_info->viewbox;\n  clone_info->affine=draw_info->affine;\n  clone_info->gravity=draw_info->gravity;\n  clone_info->fill=draw_info->fill;\n  clone_info->stroke=draw_info->stroke;\n  clone_info->stroke_width=draw_info->stroke_width;\n  if (draw_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(draw_info->fill_pattern,0,0,MagickTrue,\n      exception);\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=CloneImage(draw_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke_antialias=draw_info->stroke_antialias;\n  clone_info->text_antialias=draw_info->text_antialias;\n  clone_info->fill_rule=draw_info->fill_rule;\n  clone_info->linecap=draw_info->linecap;\n  clone_info->linejoin=draw_info->linejoin;\n  clone_info->miterlimit=draw_info->miterlimit;\n  clone_info->dash_offset=draw_info->dash_offset;\n  clone_info->decorate=draw_info->decorate;\n  clone_info->compose=draw_info->compose;\n  if (draw_info->text != (char *) NULL)\n    (void) CloneString(&clone_info->text,draw_info->text);\n  if (draw_info->font != (char *) NULL)\n    (void) CloneString(&clone_info->font,draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    (void) CloneString(&clone_info->metrics,draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    (void) CloneString(&clone_info->family,draw_info->family);\n  clone_info->style=draw_info->style;\n  clone_info->stretch=draw_info->stretch;\n  clone_info->weight=draw_info->weight;\n  if (draw_info->encoding != (char *) NULL)\n    (void) CloneString(&clone_info->encoding,draw_info->encoding);\n  clone_info->pointsize=draw_info->pointsize;\n  clone_info->kerning=draw_info->kerning;\n  clone_info->interline_spacing=draw_info->interline_spacing;\n  clone_info->interword_spacing=draw_info->interword_spacing;\n  clone_info->direction=draw_info->direction;\n  clone_info->word_break=draw_info->word_break;\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&clone_info->density,draw_info->density);\n  clone_info->align=draw_info->align;\n  clone_info->undercolor=draw_info->undercolor;\n  clone_info->border_color=draw_info->border_color;\n  if (draw_info->server_name != (char *) NULL)\n    (void) CloneString(&clone_info->server_name,draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    {\n      ssize_t\n        x;\n\n      for (x=0; fabs(draw_info->dash_pattern[x]) >= MagickEpsilon; x++) ;\n      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) (2*x+2),\n        sizeof(*clone_info->dash_pattern));\n      if (clone_info->dash_pattern == (double *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memset(clone_info->dash_pattern,0,(size_t) (2*x+2)*\n        sizeof(*clone_info->dash_pattern));\n      (void) memcpy(clone_info->dash_pattern,draw_info->dash_pattern,(size_t)\n        (x+1)*sizeof(*clone_info->dash_pattern));\n    }\n  clone_info->gradient=draw_info->gradient;\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    {\n      size_t\n        number_stops;\n\n      number_stops=clone_info->gradient.number_stops;\n      clone_info->gradient.stops=(StopInfo *) AcquireQuantumMemory((size_t)\n        number_stops,sizeof(*clone_info->gradient.stops));\n      if (clone_info->gradient.stops == (StopInfo *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memcpy(clone_info->gradient.stops,draw_info->gradient.stops,\n        (size_t) number_stops*sizeof(*clone_info->gradient.stops));\n    }\n  clone_info->bounds=draw_info->bounds;\n  clone_info->fill_alpha=draw_info->fill_alpha;\n  clone_info->stroke_alpha=draw_info->stroke_alpha;\n  clone_info->element_reference=draw_info->element_reference;\n  clone_info->clip_path=draw_info->clip_path;\n  clone_info->clip_units=draw_info->clip_units;\n  if (draw_info->clip_mask != (char *) NULL)\n    (void) CloneString(&clone_info->clip_mask,draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    clone_info->clipping_mask=CloneImage(draw_info->clipping_mask,0,0,\n      MagickTrue,exception);\n  if (draw_info->composite_mask != (Image *) NULL)\n    clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,\n      MagickTrue,exception);\n  clone_info->render=draw_info->render;\n  clone_info->image_info=CloneImageInfo(draw_info->image_info);\n  clone_info->debug=draw_info->debug;\n  exception=DestroyExceptionInfo(exception);\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C o n v e r t P a t h T o P o l y g o n                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConvertPathToPolygon() converts a path to the more efficient sorted\n%  rendering form.\n%\n%  The format of the ConvertPathToPolygon method is:\n%\n%      PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o ConvertPathToPolygon() returns the path in a more efficient sorted\n%      rendering form of type PolygonInfo.\n%\n%    o draw_info: Specifies a pointer to an DrawInfo structure.\n%\n%    o path_info: Specifies a pointer to an PathInfo structure.\n%\n%\n*/\n\nstatic PolygonInfo *DestroyPolygonInfo(PolygonInfo *polygon_info)\n{\n  ssize_t\n    i;\n\n  if (polygon_info->edges != (EdgeInfo *) NULL)\n    {\n      for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n        if (polygon_info->edges[i].points != (PointInfo *) NULL)\n          polygon_info->edges[i].points=(PointInfo *)\n            RelinquishMagickMemory(polygon_info->edges[i].points);\n      polygon_info->edges=(EdgeInfo *) RelinquishMagickMemory(\n        polygon_info->edges);\n    }\n  return((PolygonInfo *) RelinquishMagickMemory(polygon_info));\n}\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int DrawCompareEdges(const void *p_edge,const void *q_edge)\n{\n#define DrawCompareEdge(p,q) \\\n{ \\\n  if (((p)-(q)) < 0.0) \\\n    return(-1); \\\n  if (((p)-(q)) > 0.0) \\\n    return(1); \\\n}\n\n  const PointInfo\n    *p,\n    *q;\n\n  /*\n    Edge sorting for right-handed coordinate system.\n  */\n  p=((const EdgeInfo *) p_edge)->points;\n  q=((const EdgeInfo *) q_edge)->points;\n  DrawCompareEdge(p[0].y,q[0].y);\n  DrawCompareEdge(p[0].x,q[0].x);\n  DrawCompareEdge((p[1].x-p[0].x)*(q[1].y-q[0].y),(p[1].y-p[0].y)*\n    (q[1].x-q[0].x));\n  DrawCompareEdge(p[1].y,q[1].y);\n  DrawCompareEdge(p[1].x,q[1].x);\n  return(0);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic void LogPolygonInfo(const PolygonInfo *polygon_info)\n{\n  EdgeInfo\n    *p;\n\n  ssize_t\n    i,\n    j;\n\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin active-edge\");\n  p=polygon_info->edges;\n  for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n  {\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      edge %.20g:\",\n      (double) i);\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      direction: %s\",\n      p->direction != MagickFalse ? \"down\" : \"up\");\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"      ghostline: %s\",\n      p->ghostline != MagickFalse ? \"transparent\" : \"opaque\");\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"      bounds: %g,%g - %g,%g\",p->bounds.x1,p->bounds.y1,\n      p->bounds.x2,p->bounds.y2);\n    for (j=0; j < (ssize_t) p->number_points; j++)\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"        %g,%g\",\n        p->points[j].x,p->points[j].y);\n    p++;\n  }\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end active-edge\");\n}\n\nstatic void ReversePoints(PointInfo *points,const size_t number_points)\n{\n  PointInfo\n    point;\n\n  ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) (number_points >> 1); i++)\n  {\n    point=points[i];\n    points[i]=points[number_points-(i+1)];\n    points[number_points-(i+1)]=point;\n  }\n}\n\nstatic PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info,\n  ExceptionInfo *exception)\n{\n  long\n    direction,\n    next_direction;\n\n  PointInfo\n    point,\n    *points;\n\n  PolygonInfo\n    *polygon_info;\n\n  SegmentInfo\n    bounds;\n\n  ssize_t\n    i,\n    n;\n\n  MagickBooleanType\n    ghostline;\n\n  size_t\n    edge,\n    number_edges,\n    number_points;\n\n  /*\n    Convert a path to the more efficient sorted rendering form.\n  */\n  polygon_info=(PolygonInfo *) AcquireMagickMemory(sizeof(*polygon_info));\n  if (polygon_info == (PolygonInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PolygonInfo *) NULL);\n    }\n  number_edges=16;\n  polygon_info->edges=(EdgeInfo *) AcquireQuantumMemory(number_edges,\n    sizeof(*polygon_info->edges));\n  if (polygon_info->edges == (EdgeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonInfo(polygon_info));\n    }\n  (void) memset(polygon_info->edges,0,number_edges*\n    sizeof(*polygon_info->edges));\n  direction=0;\n  edge=0;\n  ghostline=MagickFalse;\n  n=0;\n  number_points=0;\n  points=(PointInfo *) NULL;\n  (void) memset(&point,0,sizeof(point));\n  (void) memset(&bounds,0,sizeof(bounds));\n  polygon_info->edges[edge].number_points=(size_t) n;\n  polygon_info->edges[edge].scanline=0.0;\n  polygon_info->edges[edge].highwater=0;\n  polygon_info->edges[edge].ghostline=ghostline;\n  polygon_info->edges[edge].direction=(ssize_t) direction;\n  polygon_info->edges[edge].points=points;\n  polygon_info->edges[edge].bounds=bounds;\n  polygon_info->number_edges=0;\n  for (i=0; path_info[i].code != EndCode; i++)\n  {\n    if ((path_info[i].code == MoveToCode) || (path_info[i].code == OpenCode) ||\n        (path_info[i].code == GhostlineCode))\n      {\n        /*\n          Move to.\n        */\n        if ((points != (PointInfo *) NULL) && (n >= 2))\n          {\n            if (edge == number_edges)\n              {\n                number_edges<<=1;\n                polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n                  polygon_info->edges,(size_t) number_edges,\n                  sizeof(*polygon_info->edges));\n                if (polygon_info->edges == (EdgeInfo *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                    points=(PointInfo *) RelinquishMagickMemory(points);\n                    return(DestroyPolygonInfo(polygon_info));\n                  }\n              }\n            polygon_info->edges[edge].number_points=(size_t) n;\n            polygon_info->edges[edge].scanline=(-1.0);\n            polygon_info->edges[edge].highwater=0;\n            polygon_info->edges[edge].ghostline=ghostline;\n            polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n            if (direction < 0)\n              ReversePoints(points,(size_t) n);\n            polygon_info->edges[edge].points=points;\n            polygon_info->edges[edge].bounds=bounds;\n            polygon_info->edges[edge].bounds.y1=points[0].y;\n            polygon_info->edges[edge].bounds.y2=points[n-1].y;\n            points=(PointInfo *) NULL;\n            ghostline=MagickFalse;\n            edge++;\n            polygon_info->number_edges=edge;\n          }\n        if (points == (PointInfo *) NULL)\n          {\n            number_points=16;\n            points=(PointInfo *) AcquireQuantumMemory((size_t) number_points,\n              sizeof(*points));\n            if (points == (PointInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                return(DestroyPolygonInfo(polygon_info));\n              }\n          }\n        ghostline=path_info[i].code == GhostlineCode ? MagickTrue : MagickFalse;\n        point=path_info[i].point;\n        points[0]=point;\n        bounds.x1=point.x;\n        bounds.x2=point.x;\n        direction=0;\n        n=1;\n        continue;\n      }\n    /*\n      Line to.\n    */\n    next_direction=((path_info[i].point.y > point.y) ||\n      ((fabs(path_info[i].point.y-point.y) < MagickEpsilon) &&\n       (path_info[i].point.x > point.x))) ? 1 : -1;\n    if ((points != (PointInfo *) NULL) && (direction != 0) &&\n        (direction != next_direction))\n      {\n        /*\n          New edge.\n        */\n        point=points[n-1];\n        if (edge == number_edges)\n          {\n            number_edges<<=1;\n            polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n              polygon_info->edges,(size_t) number_edges,\n              sizeof(*polygon_info->edges));\n            if (polygon_info->edges == (EdgeInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                points=(PointInfo *) RelinquishMagickMemory(points);\n                return(DestroyPolygonInfo(polygon_info));\n              }\n          }\n        polygon_info->edges[edge].number_points=(size_t) n;\n        polygon_info->edges[edge].scanline=(-1.0);\n        polygon_info->edges[edge].highwater=0;\n        polygon_info->edges[edge].ghostline=ghostline;\n        polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n        if (direction < 0)\n          ReversePoints(points,(size_t) n);\n        polygon_info->edges[edge].points=points;\n        polygon_info->edges[edge].bounds=bounds;\n        polygon_info->edges[edge].bounds.y1=points[0].y;\n        polygon_info->edges[edge].bounds.y2=points[n-1].y;\n        polygon_info->number_edges=edge+1;\n        points=(PointInfo *) NULL;\n        number_points=16;\n        points=(PointInfo *) AcquireQuantumMemory((size_t) number_points,\n          sizeof(*points));\n        if (points == (PointInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n            return(DestroyPolygonInfo(polygon_info));\n          }\n        n=1;\n        ghostline=MagickFalse;\n        points[0]=point;\n        bounds.x1=point.x;\n        bounds.x2=point.x;\n        edge++;\n      }\n    direction=next_direction;\n    if (points == (PointInfo *) NULL)\n      continue;\n    if (n == (ssize_t) number_points)\n      {\n        number_points<<=1;\n        points=(PointInfo *) ResizeQuantumMemory(points,(size_t) number_points,\n          sizeof(*points));\n        if (points == (PointInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n            return(DestroyPolygonInfo(polygon_info));\n          }\n      }\n    point=path_info[i].point;\n    points[n]=point;\n    if (point.x < bounds.x1)\n      bounds.x1=point.x;\n    if (point.x > bounds.x2)\n      bounds.x2=point.x;\n    n++;\n  }\n  if (points != (PointInfo *) NULL)\n    {\n      if (n < 2)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      else\n        {\n          if (edge == number_edges)\n            {\n              number_edges<<=1;\n              polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(\n                polygon_info->edges,(size_t) number_edges,\n                sizeof(*polygon_info->edges));\n              if (polygon_info->edges == (EdgeInfo *) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  return(DestroyPolygonInfo(polygon_info));\n                }\n            }\n          polygon_info->edges[edge].number_points=(size_t) n;\n          polygon_info->edges[edge].scanline=(-1.0);\n          polygon_info->edges[edge].highwater=0;\n          polygon_info->edges[edge].ghostline=ghostline;\n          polygon_info->edges[edge].direction=(ssize_t) (direction > 0);\n          if (direction < 0)\n            ReversePoints(points,(size_t) n);\n          polygon_info->edges[edge].points=points;\n          polygon_info->edges[edge].bounds=bounds;\n          polygon_info->edges[edge].bounds.y1=points[0].y;\n          polygon_info->edges[edge].bounds.y2=points[n-1].y;\n          points=(PointInfo *) NULL;\n          ghostline=MagickFalse;\n          edge++;\n          polygon_info->number_edges=edge;\n        }\n    }\n  polygon_info->number_edges=edge;\n  polygon_info->edges=(EdgeInfo *) ResizeQuantumMemory(polygon_info->edges,\n    polygon_info->number_edges,sizeof(*polygon_info->edges));\n  if (polygon_info->edges == (EdgeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonInfo(polygon_info));\n    }\n  for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n  {\n    EdgeInfo\n      *edge_info;\n\n    edge_info=polygon_info->edges+i;\n    edge_info->points=(PointInfo *) ResizeQuantumMemory(edge_info->points,\n      edge_info->number_points,sizeof(*edge_info->points));\n    if (edge_info->points == (PointInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(DestroyPolygonInfo(polygon_info));\n      }\n  }\n  qsort(polygon_info->edges,(size_t) polygon_info->number_edges,\n    sizeof(*polygon_info->edges),DrawCompareEdges);\n  if ((GetLogEventMask() & DrawEvent) != 0)\n    LogPolygonInfo(polygon_info);\n  return(polygon_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C o n v e r t P r i m i t i v e T o P a t h                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConvertPrimitiveToPath() converts a PrimitiveInfo structure into a vector\n%  path structure.\n%\n%  The format of the ConvertPrimitiveToPath method is:\n%\n%      PathInfo *ConvertPrimitiveToPath(const DrawInfo *draw_info,\n%        const PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o ConvertPrimitiveToPath() returns a vector path structure of type\n%      PathInfo.\n%\n%    o draw_info: a structure of type DrawInfo.\n%\n%    o primitive_info: Specifies a pointer to an PrimitiveInfo structure.\n%\n*/\n\nstatic void LogPathInfo(const PathInfo *path_info)\n{\n  const PathInfo\n    *p;\n\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin vector-path\");\n  for (p=path_info; p->code != EndCode; p++)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"      %g,%g %s\",p->point.x,p->point.y,p->code == GhostlineCode ?\n      \"moveto ghostline\" : p->code == OpenCode ? \"moveto open\" :\n      p->code == MoveToCode ? \"moveto\" : p->code == LineToCode ? \"lineto\" :\n      \"?\");\n  (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end vector-path\");\n}\n\nstatic PathInfo *ConvertPrimitiveToPath(const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    closed_subpath;\n\n  PathInfo\n    *path_info;\n\n  PathInfoCode\n    code;\n\n  PointInfo\n    p,\n    q;\n\n  ssize_t\n    i,\n    n;\n\n  ssize_t\n    coordinates,\n    start;\n\n  /*\n    Converts a PrimitiveInfo structure into a vector path structure.\n  */\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    case ColorPrimitive:\n    case ImagePrimitive:\n    case PointPrimitive:\n    case TextPrimitive:\n      return((PathInfo *) NULL);\n    default:\n      break;\n  }\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  path_info=(PathInfo *) AcquireQuantumMemory((size_t) (3UL*i+1UL),\n    sizeof(*path_info));\n  if (path_info == (PathInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PathInfo *) NULL);\n    }\n  coordinates=0;\n  closed_subpath=MagickFalse;\n  n=0;\n  p.x=(-1.0);\n  p.y=(-1.0);\n  q.x=(-1.0);\n  q.y=(-1.0);\n  start=0;\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n  {\n    code=LineToCode;\n    if (coordinates <= 0)\n      {\n        /*\n          New subpath.\n        */\n        coordinates=(ssize_t) primitive_info[i].coordinates;\n        p=primitive_info[i].point;\n        start=n;\n        code=MoveToCode;\n        closed_subpath=primitive_info[i].closed_subpath;\n      }\n    coordinates--;\n    if ((code == MoveToCode) || (coordinates <= 0) ||\n        (fabs(q.x-primitive_info[i].point.x) >= MagickEpsilon) ||\n        (fabs(q.y-primitive_info[i].point.y) >= MagickEpsilon))\n      {\n        /*\n          Eliminate duplicate points.\n        */\n        path_info[n].code=code;\n        path_info[n].point=primitive_info[i].point;\n        q=primitive_info[i].point;\n        n++;\n      }\n    if (coordinates > 0)\n      continue;  /* next point in current subpath */\n    if (closed_subpath != MagickFalse)\n      {\n        closed_subpath=MagickFalse;\n        continue;\n      }\n    /*\n      Mark the p point as open if the subpath is not closed.\n    */\n    path_info[start].code=OpenCode;\n    path_info[n].code=GhostlineCode;\n    path_info[n].point=primitive_info[i].point;\n    n++;\n    path_info[n].code=LineToCode;\n    path_info[n].point=p;\n    n++;\n  }\n  path_info[n].code=EndCode;\n  path_info[n].point.x=0.0;\n  path_info[n].point.y=0.0;\n  if (IsEventLogging() != MagickFalse)\n    LogPathInfo(path_info);\n  path_info=(PathInfo *) ResizeQuantumMemory(path_info,(size_t) (n+1),\n    sizeof(*path_info));\n  return(path_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y D r a w I n f o                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyDrawInfo() deallocates memory associated with an DrawInfo structure.\n%\n%  The format of the DestroyDrawInfo method is:\n%\n%      DrawInfo *DestroyDrawInfo(DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport DrawInfo *DestroyDrawInfo(DrawInfo *draw_info)\n{\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (draw_info->id != (char *) NULL)\n    draw_info->id=DestroyString(draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    draw_info->primitive=DestroyString(draw_info->primitive);\n  if (draw_info->text != (char *) NULL)\n    draw_info->text=DestroyString(draw_info->text);\n  if (draw_info->geometry != (char *) NULL)\n    draw_info->geometry=DestroyString(draw_info->geometry);\n  if (draw_info->fill_pattern != (Image *) NULL)\n    draw_info->fill_pattern=DestroyImage(draw_info->fill_pattern);\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    draw_info->stroke_pattern=DestroyImage(draw_info->stroke_pattern);\n  if (draw_info->font != (char *) NULL)\n    draw_info->font=DestroyString(draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    draw_info->metrics=DestroyString(draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    draw_info->family=DestroyString(draw_info->family);\n  if (draw_info->encoding != (char *) NULL)\n    draw_info->encoding=DestroyString(draw_info->encoding);\n  if (draw_info->density != (char *) NULL)\n    draw_info->density=DestroyString(draw_info->density);\n  if (draw_info->server_name != (char *) NULL)\n    draw_info->server_name=(char *)\n     RelinquishMagickMemory(draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    draw_info->dash_pattern=(double *) RelinquishMagickMemory(\n      draw_info->dash_pattern);\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    draw_info->gradient.stops=(StopInfo *) RelinquishMagickMemory(\n      draw_info->gradient.stops);\n  if (draw_info->clip_mask != (char *) NULL)\n    draw_info->clip_mask=DestroyString(draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    draw_info->clipping_mask=DestroyImage(draw_info->clipping_mask);\n  if (draw_info->composite_mask != (Image *) NULL)\n    draw_info->composite_mask=DestroyImage(draw_info->composite_mask);\n  if (draw_info->image_info != (ImageInfo *) NULL)\n    draw_info->image_info=DestroyImageInfo(draw_info->image_info);\n  draw_info->signature=(~MagickCoreSignature);\n  draw_info=(DrawInfo *) RelinquishMagickMemory(draw_info);\n  return(draw_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     D r a w A f f i n e I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawAffineImage() composites the source over the destination image as\n%  dictated by the affine transform.\n%\n%  The format of the DrawAffineImage method is:\n%\n%      MagickBooleanType DrawAffineImage(Image *image,const Image *source,\n%        const AffineMatrix *affine,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o source: the source image.\n%\n%    o affine: the affine transform.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic SegmentInfo AffineEdge(const Image *image,const AffineMatrix *affine,\n  const double y,const SegmentInfo *edge)\n{\n  double\n    intercept,\n    z;\n\n  double\n    x;\n\n  SegmentInfo\n    inverse_edge;\n\n  /*\n    Determine left and right edges.\n  */\n  inverse_edge.x1=edge->x1;\n  inverse_edge.y1=edge->y1;\n  inverse_edge.x2=edge->x2;\n  inverse_edge.y2=edge->y2;\n  z=affine->ry*y+affine->tx;\n  if (affine->sx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->sx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->columns)/affine->sx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->sx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->columns)/affine->sx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->sx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->columns))\n        {\n          inverse_edge.x2=edge->x1;\n          return(inverse_edge);\n        }\n  /*\n    Determine top and bottom edges.\n  */\n  z=affine->sy*y+affine->ty;\n  if (affine->rx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->rx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->rows)/affine->rx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->rx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->rows)/affine->rx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->rx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->rows))\n        {\n          inverse_edge.x2=edge->x2;\n          return(inverse_edge);\n        }\n  return(inverse_edge);\n}\n\nstatic AffineMatrix InverseAffineMatrix(const AffineMatrix *affine)\n{\n  AffineMatrix\n    inverse_affine;\n\n  double\n    determinant;\n\n  determinant=PerceptibleReciprocal(affine->sx*affine->sy-affine->rx*\n    affine->ry);\n  inverse_affine.sx=determinant*affine->sy;\n  inverse_affine.rx=determinant*(-affine->rx);\n  inverse_affine.ry=determinant*(-affine->ry);\n  inverse_affine.sy=determinant*affine->sx;\n  inverse_affine.tx=(-affine->tx)*inverse_affine.sx-affine->ty*\n    inverse_affine.ry;\n  inverse_affine.ty=(-affine->tx)*inverse_affine.rx-affine->ty*\n    inverse_affine.sy;\n  return(inverse_affine);\n}\n\nMagickExport MagickBooleanType DrawAffineImage(Image *image,\n  const Image *source,const AffineMatrix *affine,ExceptionInfo *exception)\n{\n  AffineMatrix\n    inverse_affine;\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    zero;\n\n  PointInfo\n    extent[4],\n    min,\n    max;\n\n  ssize_t\n    i;\n\n  SegmentInfo\n    edge;\n\n  ssize_t\n    start,\n    stop,\n    y;\n\n  /*\n    Determine bounding box.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(source != (const Image *) NULL);\n  assert(source->signature == MagickCoreSignature);\n  assert(affine != (AffineMatrix *) NULL);\n  extent[0].x=0.0;\n  extent[0].y=0.0;\n  extent[1].x=(double) source->columns;\n  extent[1].y=0.0;\n  extent[2].x=(double) source->columns;\n  extent[2].y=(double) source->rows;\n  extent[3].x=0.0;\n  extent[3].y=(double) source->rows;\n  for (i=0; i < 4; i++)\n  {\n    PointInfo\n      point;\n\n    point=extent[i];\n    extent[i].x=point.x*affine->sx+point.y*affine->ry+affine->tx;\n    extent[i].y=point.x*affine->rx+point.y*affine->sy+affine->ty;\n  }\n  min=extent[0];\n  max=extent[0];\n  for (i=1; i < 4; i++)\n  {\n    if (min.x > extent[i].x)\n      min.x=extent[i].x;\n    if (min.y > extent[i].y)\n      min.y=extent[i].y;\n    if (max.x < extent[i].x)\n      max.x=extent[i].x;\n    if (max.y < extent[i].y)\n      max.y=extent[i].y;\n  }\n  /*\n    Affine transform image.\n  */\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  edge.x1=min.x;\n  edge.y1=min.y;\n  edge.x2=max.x;\n  edge.y2=max.y;\n  inverse_affine=InverseAffineMatrix(affine);\n  if (edge.y1 < 0.0)\n    edge.y1=0.0;\n  if (edge.y2 > (image->rows-1.0))\n    edge.y2=image->rows-1.0;\n  GetPixelInfo(image,&zero);\n  start=CastDoubleToLong(ceil(edge.y1-0.5));\n  stop=CastDoubleToLong(floor(edge.y2+0.5));\n  source_view=AcquireVirtualCacheView(source,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(source,image,stop-start,1)\n#endif\n  for (y=start; y <= stop; y++)\n  {\n    PixelInfo\n      composite,\n      pixel;\n\n    PointInfo\n      point;\n\n    Quantum\n      *magick_restrict q;\n\n    SegmentInfo\n      inverse_edge;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge);\n    if (inverse_edge.x2 < inverse_edge.x1)\n      continue;\n    if (inverse_edge.x1 < 0.0)\n      inverse_edge.x1=0.0;\n    if (inverse_edge.x2 > image->columns-1.0)\n      inverse_edge.x2=image->columns-1.0;\n    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToLong(\n      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToLong(floor(\n      inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1),1,exception);\n    if (q == (Quantum *) NULL)\n      continue;\n    pixel=zero;\n    composite=zero;\n    for (x=CastDoubleToLong(ceil(inverse_edge.x1-0.5));\n         x <= CastDoubleToLong(floor(inverse_edge.x2+0.5)); x++)\n    {\n      point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+\n        inverse_affine.tx;\n      point.y=(double) x*inverse_affine.rx+y*inverse_affine.sy+\n        inverse_affine.ty;\n      status=InterpolatePixelInfo(source,source_view,UndefinedInterpolatePixel,\n        point.x,point.y,&pixel,exception);\n      if (status == MagickFalse)\n        break;\n      GetPixelInfoPixel(image,q,&composite);\n      CompositePixelInfoOver(&pixel,pixel.alpha,&composite,composite.alpha,\n        &composite);\n      SetPixelViaPixelInfo(image,&composite,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w B o u n d i n g R e c t a n g l e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawBoundingRectangles() draws the bounding rectangles on the image.  This\n%  is only useful for developers debugging the rendering algorithm.\n%\n%  The format of the DrawBoundingRectangles method is:\n%\n%      MagickBooleanType DrawBoundingRectangles(Image *image,\n%        const DrawInfo *draw_info,PolygonInfo *polygon_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o polygon_info: Specifies a pointer to a PolygonInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType DrawBoundingRectangles(Image *image,\n  const DrawInfo *draw_info,const PolygonInfo *polygon_info,\n  ExceptionInfo *exception)\n{\n  double\n    mid;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  PointInfo\n    end,\n    resolution,\n    start;\n\n  PrimitiveInfo\n    primitive_info[6];\n\n  ssize_t\n    i;\n\n  SegmentInfo\n    bounds;\n\n  ssize_t\n    coordinates;\n\n  (void) memset(primitive_info,0,sizeof(primitive_info));\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  status=QueryColorCompliance(\"#000F\",AllCompliance,&clone_info->fill,\n    exception);\n  if (status == MagickFalse)\n    {\n      clone_info=DestroyDrawInfo(clone_info);\n      return(MagickFalse);\n    }\n  resolution.x=96.0;\n  resolution.y=96.0;\n  if (clone_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(clone_info->density,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        resolution.x=geometry_info.rho;\n      resolution.y=resolution.x;\n      if ((flags & SigmaValue) != 0)\n        resolution.y=geometry_info.sigma;\n    }\n  mid=(resolution.x/96.0)*ExpandAffine(&clone_info->affine)*\n    clone_info->stroke_width/2.0;\n  bounds.x1=0.0;\n  bounds.y1=0.0;\n  bounds.x2=0.0;\n  bounds.y2=0.0;\n  if (polygon_info != (PolygonInfo *) NULL)\n    {\n      bounds=polygon_info->edges[0].bounds;\n      for (i=1; i < (ssize_t) polygon_info->number_edges; i++)\n      {\n        if (polygon_info->edges[i].bounds.x1 < (double) bounds.x1)\n          bounds.x1=polygon_info->edges[i].bounds.x1;\n        if (polygon_info->edges[i].bounds.y1 < (double) bounds.y1)\n          bounds.y1=polygon_info->edges[i].bounds.y1;\n        if (polygon_info->edges[i].bounds.x2 > (double) bounds.x2)\n          bounds.x2=polygon_info->edges[i].bounds.x2;\n        if (polygon_info->edges[i].bounds.y2 > (double) bounds.y2)\n          bounds.y2=polygon_info->edges[i].bounds.y2;\n      }\n      bounds.x1-=mid;\n      bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double)\n        image->columns ? (double) image->columns-1 : bounds.x1;\n      bounds.y1-=mid;\n      bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double)\n        image->rows ? (double) image->rows-1 : bounds.y1;\n      bounds.x2+=mid;\n      bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double)\n        image->columns ? (double) image->columns-1 : bounds.x2;\n      bounds.y2+=mid;\n      bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double)\n        image->rows ? (double) image->rows-1 : bounds.y2;\n      for (i=0; i < (ssize_t) polygon_info->number_edges; i++)\n      {\n        if (polygon_info->edges[i].direction != 0)\n          status=QueryColorCompliance(\"#f00\",AllCompliance,&clone_info->stroke,\n            exception);\n        else\n          status=QueryColorCompliance(\"#0f0\",AllCompliance,&clone_info->stroke,\n            exception);\n        if (status == MagickFalse)\n          break;\n        start.x=(double) (polygon_info->edges[i].bounds.x1-mid);\n        start.y=(double) (polygon_info->edges[i].bounds.y1-mid);\n        end.x=(double) (polygon_info->edges[i].bounds.x2+mid);\n        end.y=(double) (polygon_info->edges[i].bounds.y2+mid);\n        primitive_info[0].primitive=RectanglePrimitive;\n        status&=TraceRectangle(primitive_info,start,end);\n        primitive_info[0].method=ReplaceMethod;\n        coordinates=(ssize_t) primitive_info[0].coordinates;\n        primitive_info[coordinates].primitive=UndefinedPrimitive;\n        status=DrawPrimitive(image,clone_info,primitive_info,exception);\n        if (status == MagickFalse)\n          break;\n      }\n      if (i < (ssize_t) polygon_info->number_edges)\n        {\n          clone_info=DestroyDrawInfo(clone_info);\n          return(status == 0 ? MagickFalse : MagickTrue);\n        }\n    }\n  status=QueryColorCompliance(\"#00f\",AllCompliance,&clone_info->stroke,\n    exception);\n  if (status == MagickFalse)\n    {\n      clone_info=DestroyDrawInfo(clone_info);\n      return(MagickFalse);\n    }\n  start.x=(double) (bounds.x1-mid);\n  start.y=(double) (bounds.y1-mid);\n  end.x=(double) (bounds.x2+mid);\n  end.y=(double) (bounds.y2+mid);\n  primitive_info[0].primitive=RectanglePrimitive;\n  status&=TraceRectangle(primitive_info,start,end);\n  primitive_info[0].method=ReplaceMethod;\n  coordinates=(ssize_t) primitive_info[0].coordinates;\n  primitive_info[coordinates].primitive=UndefinedPrimitive;\n  status=DrawPrimitive(image,clone_info,primitive_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  return(status == 0 ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C l i p P a t h                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawClipPath() draws the clip path on the image mask.\n%\n%  The format of the DrawClipPath method is:\n%\n%      MagickBooleanType DrawClipPath(Image *image,const DrawInfo *draw_info,\n%        const char *id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the clip path id.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *id,ExceptionInfo *exception)\n{\n  const char\n    *clip_path;\n\n  Image\n    *clipping_mask;\n\n  MagickBooleanType\n    status;\n\n  clip_path=GetImageArtifact(image,id);\n  if (clip_path == (const char *) NULL)\n    return(MagickFalse);\n  clipping_mask=DrawClippingMask(image,draw_info,draw_info->clip_mask,clip_path,\n    exception);\n  if (clipping_mask == (Image *) NULL)\n    return(MagickFalse);\n  status=SetImageMask(image,WritePixelMask,clipping_mask,exception);\n  clipping_mask=DestroyImage(clipping_mask);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C l i p p i n g M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawClippingMask() draws the clip path and returns it as an image clipping\n%  mask.\n%\n%  The format of the DrawClippingMask method is:\n%\n%      Image *DrawClippingMask(Image *image,const DrawInfo *draw_info,\n%        const char *id,const char *clip_path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the clip path id.\n%\n%    o clip_path: the clip path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *DrawClippingMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *clip_path,ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  Image\n    *clip_mask,\n    *separate_mask;\n\n  MagickStatusType\n    status;\n\n  /*\n    Draw a clip path.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  clip_mask=AcquireImage((const ImageInfo *) NULL,exception);\n  status=SetImageExtent(clip_mask,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImage(clip_mask));\n  status=SetImageMask(clip_mask,WritePixelMask,(Image *) NULL,exception);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(MagickRealType) TransparentAlpha;\n  clip_mask->background_color.alpha_trait=BlendPixelTrait;\n  status=SetImageBackgroundColor(clip_mask,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,clip_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  if (clone_info->clip_mask != (char *) NULL)\n    clone_info->clip_mask=DestroyString(clone_info->clip_mask);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->alpha=OpaqueAlpha;\n  clone_info->clip_path=MagickTrue;\n  status=RenderMVGContent(clip_mask,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  separate_mask=SeparateImage(clip_mask,AlphaChannel,exception);\n  if (separate_mask == (Image *) NULL)\n    status=MagickFalse; \n  else\n    {\n      clip_mask=DestroyImage(clip_mask);\n      clip_mask=separate_mask;\n      status&=NegateImage(clip_mask,MagickFalse,exception);\n    }\n  if (status == MagickFalse)\n    clip_mask=DestroyImage(clip_mask);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(clip_mask);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w C o m p o s i t e M a s k                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawCompositeMask() draws the mask path and returns it as an image mask.\n%\n%  The format of the DrawCompositeMask method is:\n%\n%      Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n%        const char *id,const char *mask_path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o id: the mask path id.\n%\n%    o mask_path: the mask path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *mask_path,ExceptionInfo *exception)\n{\n  Image\n    *composite_mask,\n    *separate_mask;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  /*\n    Draw a mask path.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  composite_mask=AcquireImage((const ImageInfo *) NULL,exception);\n  status=SetImageExtent(composite_mask,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImage(composite_mask));\n  status=SetImageMask(composite_mask,CompositePixelMask,(Image *) NULL,\n    exception);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &composite_mask->background_color,exception);\n  composite_mask->background_color.alpha=(MagickRealType) TransparentAlpha;\n  composite_mask->background_color.alpha_trait=BlendPixelTrait;\n  (void) SetImageBackgroundColor(composite_mask,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin mask-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,mask_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->alpha=OpaqueAlpha;\n  status=RenderMVGContent(composite_mask,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  separate_mask=SeparateImage(composite_mask,AlphaChannel,exception);\n  if (separate_mask != (Image *) NULL)\n    {\n      composite_mask=DestroyImage(composite_mask);\n      composite_mask=separate_mask;\n      status=NegateImage(composite_mask,MagickFalse,exception);\n      if (status == MagickFalse)\n        composite_mask=DestroyImage(composite_mask);\n    }\n  if (status == MagickFalse)\n    composite_mask=DestroyImage(composite_mask);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end mask-path\");\n  return(composite_mask);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w D a s h P o l y g o n                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawDashPolygon() draws a dashed polygon (line, rectangle, ellipse) on the\n%  image while respecting the dash offset and dash pattern attributes.\n%\n%  The format of the DrawDashPolygon method is:\n%\n%      MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n%        const PrimitiveInfo *primitive_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)\n{\n  double\n    dx,\n    dy,\n    length,\n    maximum_length,\n    offset,\n    scale,\n    total_length;\n\n  DrawInfo\n    *clone_info;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *dash_polygon;\n\n  ssize_t\n    i;\n\n  size_t\n    number_vertices;\n\n  ssize_t\n    j,\n    n;\n\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-dash\");\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  number_vertices=(size_t) i;\n  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (2UL*number_vertices+32UL),sizeof(*dash_polygon));\n  if (dash_polygon == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  (void) memset(dash_polygon,0,(2UL*number_vertices+32UL)*\n    sizeof(*dash_polygon));\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->miterlimit=0;\n  dash_polygon[0]=primitive_info[0];\n  scale=ExpandAffine(&draw_info->affine);\n  length=scale*draw_info->dash_pattern[0];\n  offset=fabs(draw_info->dash_offset) >= MagickEpsilon ?\n    scale*draw_info->dash_offset : 0.0;\n  j=1;\n  for (n=0; offset > 0.0; j=0)\n  {\n    if (draw_info->dash_pattern[n] <= 0.0)\n      break;\n    length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    if (offset > length)\n      {\n        offset-=length;\n        n++;\n        length=scale*draw_info->dash_pattern[n];\n        continue;\n      }\n    if (offset < length)\n      {\n        length-=offset;\n        offset=0.0;\n        break;\n      }\n    offset=0.0;\n    n++;\n  }\n  status=MagickTrue;\n  maximum_length=0.0;\n  total_length=0.0;\n  for (i=1; (i < (ssize_t) number_vertices) && (length >= 0.0); i++)\n  {\n    dx=primitive_info[i].point.x-primitive_info[i-1].point.x;\n    dy=primitive_info[i].point.y-primitive_info[i-1].point.y;\n    maximum_length=hypot(dx,dy);\n    if (maximum_length > (double) (MaxBezierCoordinates >> 2))\n      continue;\n    if (fabs(length) < MagickEpsilon)\n      {\n        if (fabs(draw_info->dash_pattern[n]) >= MagickEpsilon)\n          n++;\n        if (fabs(draw_info->dash_pattern[n]) < MagickEpsilon)\n          n=0;\n        length=scale*draw_info->dash_pattern[n];\n      }\n    for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); )\n    {\n      total_length+=length;\n      if ((n & 0x01) != 0)\n        {\n          dash_polygon[0]=primitive_info[0];\n          dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length*PerceptibleReciprocal(maximum_length));\n          j=1;\n        }\n      else\n        {\n          if ((j+1) > (ssize_t) number_vertices)\n            break;\n          dash_polygon[j]=primitive_info[i-1];\n          dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length*PerceptibleReciprocal(maximum_length));\n          dash_polygon[j].coordinates=1;\n          j++;\n          dash_polygon[0].coordinates=(size_t) j;\n          dash_polygon[j].primitive=UndefinedPrimitive;\n          status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n          if (status == MagickFalse)\n            break;\n        }\n      if (fabs(draw_info->dash_pattern[n]) >= MagickEpsilon)\n        n++;\n      if (fabs(draw_info->dash_pattern[n]) < MagickEpsilon)\n        n=0;\n      length=scale*draw_info->dash_pattern[n];\n    }\n    length-=(maximum_length-total_length);\n    if ((n & 0x01) != 0)\n      continue;\n    dash_polygon[j]=primitive_info[i];\n    dash_polygon[j].coordinates=1;\n    j++;\n  }\n  if ((status != MagickFalse) && (total_length < maximum_length) &&\n      ((n & 0x01) == 0) && (j > 1))\n    {\n      dash_polygon[j]=primitive_info[i-1];\n      dash_polygon[j].point.x+=MagickEpsilon;\n      dash_polygon[j].point.y+=MagickEpsilon;\n      dash_polygon[j].coordinates=1;\n      j++;\n      dash_polygon[0].coordinates=(size_t) j;\n      dash_polygon[j].primitive=UndefinedPrimitive;\n      status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n    }\n  dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-dash\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     D r a w G r a d i e n t I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawGradientImage() draws a linear gradient on the image.\n%\n%  The format of the DrawGradientImage method is:\n%\n%      MagickBooleanType DrawGradientImage(Image *image,\n%        const DrawInfo *draw_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double GetStopColorOffset(const GradientInfo *gradient,\n  const ssize_t x,const ssize_t y)\n{\n  switch (gradient->type)\n  {\n    case UndefinedGradient:\n    case LinearGradient:\n    {\n      double\n        gamma,\n        length,\n        offset,\n        scale;\n\n      PointInfo\n        p,\n        q;\n\n      const SegmentInfo\n        *gradient_vector;\n\n      gradient_vector=(&gradient->gradient_vector);\n      p.x=gradient_vector->x2-gradient_vector->x1;\n      p.y=gradient_vector->y2-gradient_vector->y1;\n      q.x=(double) x-gradient_vector->x1;\n      q.y=(double) y-gradient_vector->y1;\n      length=sqrt(q.x*q.x+q.y*q.y);\n      gamma=sqrt(p.x*p.x+p.y*p.y)*length;\n      gamma=PerceptibleReciprocal(gamma);\n      scale=p.x*q.x+p.y*q.y;\n      offset=gamma*scale*length;\n      return(offset);\n    }\n    case RadialGradient:\n    {\n      PointInfo\n        v;\n\n      if (gradient->spread == RepeatSpread)\n        {\n          v.x=(double) x-gradient->center.x;\n          v.y=(double) y-gradient->center.y;\n          return(sqrt(v.x*v.x+v.y*v.y));\n        }\n      v.x=(double) (((x-gradient->center.x)*cos(DegreesToRadians(\n        gradient->angle)))+((y-gradient->center.y)*sin(DegreesToRadians(\n        gradient->angle))))*PerceptibleReciprocal(gradient->radii.x);\n      v.y=(double) (((x-gradient->center.x)*sin(DegreesToRadians(\n        gradient->angle)))-((y-gradient->center.y)*cos(DegreesToRadians(\n        gradient->angle))))*PerceptibleReciprocal(gradient->radii.y);\n      return(sqrt(v.x*v.x+v.y*v.y));\n    }\n  }\n  return(0.0);\n}\n\nstatic int StopInfoCompare(const void *x,const void *y)\n{\n  StopInfo\n    *stop_1,\n    *stop_2;\n\n  stop_1=(StopInfo *) x;\n  stop_2=(StopInfo *) y;\n  if (stop_1->offset > stop_2->offset)\n    return(1);\n  if (fabs(stop_1->offset-stop_2->offset) <= MagickEpsilon)\n    return(0);\n  return(-1);\n}\n\nMagickExport MagickBooleanType DrawGradientImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const GradientInfo\n    *gradient;\n\n  const SegmentInfo\n    *gradient_vector;\n\n  double\n    length;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    zero;\n\n  PointInfo\n    point;\n\n  RectangleInfo\n    bounding_box;\n\n  ssize_t\n    y;\n\n  /*\n    Draw linear or radial gradient on image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  gradient=(&draw_info->gradient);\n  qsort(gradient->stops,gradient->number_stops,sizeof(StopInfo),\n    StopInfoCompare);\n  gradient_vector=(&gradient->gradient_vector);\n  point.x=gradient_vector->x2-gradient_vector->x1;\n  point.y=gradient_vector->y2-gradient_vector->y1;\n  length=sqrt(point.x*point.x+point.y*point.y);\n  bounding_box=gradient->bounding_box;\n  status=MagickTrue;\n  GetPixelInfo(image,&zero);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,bounding_box.height-bounding_box.y,1)\n#endif\n  for (y=bounding_box.y; y < (ssize_t) bounding_box.height; y++)\n  {\n    double\n      alpha,\n      offset;\n\n    PixelInfo\n      composite,\n      pixel;\n\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      i,\n      x;\n\n    ssize_t\n      j;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    pixel=zero;\n    composite=zero;\n    offset=GetStopColorOffset(gradient,0,y);\n    if (gradient->type != RadialGradient)\n      offset*=PerceptibleReciprocal(length);\n    for (x=bounding_box.x; x < (ssize_t) bounding_box.width; x++)\n    {\n      GetPixelInfoPixel(image,q,&pixel);\n      switch (gradient->spread)\n      {\n        case UndefinedSpread:\n        case PadSpread:\n        {\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type != RadialGradient)\n                offset*=PerceptibleReciprocal(length);\n            }\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if ((offset < 0.0) || (i == 0))\n            composite=gradient->stops[0].color;\n          else\n            if ((offset > 1.0) || (i == (ssize_t) gradient->number_stops))\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n        case ReflectSpread:\n        {\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type != RadialGradient)\n                offset*=PerceptibleReciprocal(length);\n            }\n          if (offset < 0.0)\n            offset=(-offset);\n          if ((ssize_t) fmod(offset,2.0) == 0)\n            offset=fmod(offset,1.0);\n          else\n            offset=1.0-fmod(offset,1.0);\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if (i == 0)\n            composite=gradient->stops[0].color;\n          else\n            if (i == (ssize_t) gradient->number_stops)\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n        case RepeatSpread:\n        {\n          double\n            repeat;\n\n          MagickBooleanType\n            antialias;\n\n          antialias=MagickFalse;\n          repeat=0.0;\n          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||\n              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))\n            {\n              offset=GetStopColorOffset(gradient,x,y);\n              if (gradient->type == LinearGradient)\n                {\n                  repeat=fmod(offset,length);\n                  if (repeat < 0.0)\n                    repeat=length-fmod(-repeat,length);\n                  else\n                    repeat=fmod(offset,length);\n                  antialias=(repeat < length) && ((repeat+1.0) > length) ?\n                    MagickTrue : MagickFalse;\n                  offset=PerceptibleReciprocal(length)*repeat;\n                }\n              else\n                {\n                  repeat=fmod(offset,gradient->radius);\n                  if (repeat < 0.0)\n                    repeat=gradient->radius-fmod(-repeat,gradient->radius);\n                  else\n                    repeat=fmod(offset,gradient->radius);\n                  antialias=repeat+1.0 > gradient->radius ? MagickTrue :\n                    MagickFalse;\n                  offset=repeat*PerceptibleReciprocal(gradient->radius);\n                }\n            }\n          for (i=0; i < (ssize_t) gradient->number_stops; i++)\n            if (offset < gradient->stops[i].offset)\n              break;\n          if (i == 0)\n            composite=gradient->stops[0].color;\n          else\n            if (i == (ssize_t) gradient->number_stops)\n              composite=gradient->stops[gradient->number_stops-1].color;\n            else\n              {\n                j=i;\n                i--;\n                alpha=(offset-gradient->stops[i].offset)/\n                  (gradient->stops[j].offset-gradient->stops[i].offset);\n                if (antialias != MagickFalse)\n                  {\n                    if (gradient->type == LinearGradient)\n                      alpha=length-repeat;\n                    else\n                      alpha=gradient->radius-repeat;\n                    i=0;\n                    j=(ssize_t) gradient->number_stops-1L;\n                  }\n                CompositePixelInfoBlend(&gradient->stops[i].color,1.0-alpha,\n                  &gradient->stops[j].color,alpha,&composite);\n              }\n          break;\n        }\n      }\n      CompositePixelInfoOver(&composite,composite.alpha,&pixel,pixel.alpha,\n        &pixel);\n      SetPixelViaPixelInfo(image,&pixel,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawImage() draws a graphic primitive on your image.  The primitive\n%  may be represented as a string or filename.  Precede the filename with an\n%  \"at\" sign (@) and the contents of the file are drawn on the image.  You\n%  can affect how text is drawn by setting one or more members of the draw\n%  info structure.\n%\n%  The format of the DrawImage method is:\n%\n%      MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  char\n    **text = (char **) NULL;\n\n  double\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    i;\n\n  /*\n    Check if there is enough storage for drawing primitives.\n  */\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*(double) quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if ((extent >= (double) MAGICK_SSIZE_MAX) || (IsNaN(extent) != 0))\n    return(MagickFalse);\n  if (mvg_info->offset > 0)\n    {\n      text=(char **) AcquireQuantumMemory(mvg_info->offset,sizeof(*text));\n      if (text == (char **) NULL)\n        return(MagickFalse);\n      for (i=0; i < mvg_info->offset; i++)\n        text[i]=(*mvg_info->primitive_info)[i].text;\n    }\n  *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n    *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    {\n      if (text != (char **) NULL)\n        text=(char **) RelinquishMagickMemory(text);\n      *mvg_info->extent=(size_t) extent;\n      for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n      {\n        (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n        (*mvg_info->primitive_info)[i].text=(char *) NULL;\n      }\n      return(MagickTrue);\n    }\n  /*\n    Reallocation failed, allocate a primitive to facilitate unwinding.\n  */\n  if (text != (char **) NULL)\n    {\n      for (i=0; i < mvg_info->offset; i++)\n        if (text[i] != (char *) NULL)\n          text[i]=DestroyString(text[i]);\n      text=(char **) RelinquishMagickMemory(text);\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t)\n    (PrimitiveExtentPad+1)*quantum);\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}\n\nstatic inline double GetDrawValue(const char *magick_restrict string,\n  char **magick_restrict sentinel)\n{\n  char\n    **magick_restrict q;\n\n  double\n    value;\n\n  q=sentinel;\n  value=InterpretLocaleValue(string,q);\n  sentinel=q;\n  return(value);\n}\n\nstatic int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}\n\nstatic SplayTreeInfo *GetMVGMacros(const char *primitive)\n{\n  char\n    *macro,\n    *token;\n\n  const char\n    *q;\n\n  size_t\n    extent;\n\n  SplayTreeInfo\n    *macros;\n\n  /*\n    Scan graphic primitives for definitions and classes.\n  */\n  if (primitive == (const char *) NULL)\n    return((SplayTreeInfo *) NULL);\n  macros=NewSplayTree(MVGMacroCompare,RelinquishMagickMemory,\n    RelinquishMagickMemory);\n  macro=AcquireString(primitive);\n  token=AcquireString(primitive);\n  extent=strlen(token)+MagickPathExtent;\n  for (q=primitive; *q != '\\0'; )\n  {\n    if (GetNextToken(q,&q,extent,token) < 1)\n      break;\n    if (*token == '\\0')\n      break;\n    if (LocaleCompare(\"push\",token) == 0)\n      {\n        const char\n          *end,\n          *start;\n\n        (void) GetNextToken(q,&q,extent,token);\n        if (*q == '\"')\n          {\n            char\n              name[MagickPathExtent];\n\n            const char\n              *p;\n\n            ssize_t\n              n;\n\n            /*\n              Named macro (e.g. push graphic-context \"wheel\").\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            start=q;\n            end=q;\n            (void) CopyMagickString(name,token,MagickPathExtent);\n            n=1;\n            for (p=q; *p != '\\0'; )\n            {\n              if (GetNextToken(p,&p,extent,token) < 1)\n                break;\n              if (*token == '\\0')\n                break;\n              if (LocaleCompare(token,\"pop\") == 0)\n                {\n                  end=p-strlen(token)-1;\n                  n--;\n                }\n              if (LocaleCompare(token,\"push\") == 0)\n                n++;\n              if ((n == 0) && (end > start))\n                {\n                  /*\n                    Extract macro.\n                  */\n                  (void) GetNextToken(p,&p,extent,token);\n                  (void) CopyMagickString(macro,start,(size_t) (end-start));\n                  (void) AddValueToSplayTree(macros,ConstantString(name),\n                    ConstantString(macro));\n                  break;\n                }\n            }\n          }\n      }\n  }\n  token=DestroyString(token);\n  macro=DestroyString(macro);\n  return(macros);\n}\n\nstatic inline MagickBooleanType IsPoint(const char *point)\n{\n  char\n    *p;\n\n  double\n    value;\n\n  value=GetDrawValue(point,&p);\n  return((fabs(value) < MagickEpsilon) && (p == point) ? MagickFalse :\n    MagickTrue);\n}\n\nstatic inline MagickBooleanType TracePoint(PrimitiveInfo *primitive_info,\n  const PointInfo point)\n{\n  primitive_info->coordinates=1;\n  primitive_info->closed_subpath=MagickFalse;\n  primitive_info->point=point;\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType RenderMVGContent(Image *image,\n  const DrawInfo *draw_info,const size_t depth,ExceptionInfo *exception)\n{\n#define RenderImageTag  \"Render/Image\"\n\n  AffineMatrix\n    affine,\n    current;\n\n  char\n    keyword[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *next_token,\n    pattern[MagickPathExtent],\n    *primitive,\n    *token;\n\n  const char\n    *q;\n\n  double\n    angle,\n    coordinates,\n    cursor,\n    factor,\n    primitive_extent;\n\n  DrawInfo\n    *clone_info,\n    **graphic_context;\n\n  MagickBooleanType\n    proceed;\n\n  MagickStatusType\n    status;\n\n  MVGInfo\n    mvg_info;\n\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  const char\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    extent,\n    number_points,\n    number_stops;\n\n  SplayTreeInfo\n    *macros;\n\n  ssize_t\n    defsDepth,\n    j,\n    k,\n    n,\n    symbolDepth;\n\n  StopInfo\n    *stops;\n\n  TypeMetric\n    metrics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (depth > MagickMaxRecursionDepth)\n    ThrowBinaryException(DrawError,\"VectorGraphicsNestedTooDeeply\",\n      image->filename);\n  if ((draw_info->primitive == (char *) NULL) ||\n      (*draw_info->primitive == '\\0'))\n    return(MagickFalse);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"begin draw-image\");\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (status == MagickFalse)\n        return(MagickFalse);\n    }\n  if ((*draw_info->primitive == '@') && (strlen(draw_info->primitive) > 1) &&\n      (*(draw_info->primitive+1) != '-') && (depth == 0))\n    primitive=FileToString(draw_info->primitive,~0UL,exception);\n  else\n    primitive=AcquireString(draw_info->primitive);\n  if (primitive == (char *) NULL)\n    return(MagickFalse);\n  primitive_extent=(double) strlen(primitive);\n  (void) SetImageArtifact(image,\"mvg:vector-graphics\",primitive);\n  n=0;\n  number_stops=0;\n  stops=(StopInfo *) NULL;\n  /*\n    Allocate primitive info memory.\n  */\n  graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));\n  if (graphic_context == (DrawInfo **) NULL)\n    {\n      primitive=DestroyString(primitive);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  number_points=(size_t) PrimitiveExtentPad;\n  primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (number_points+1),sizeof(*primitive_info));\n  if (primitive_info == (PrimitiveInfo *) NULL)\n    {\n      primitive=DestroyString(primitive);\n      for ( ; n >= 0; n--)\n        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) memset(primitive_info,0,(size_t) (number_points+1)*\n    sizeof(*primitive_info));\n  (void) memset(&mvg_info,0,sizeof(mvg_info));\n  mvg_info.primitive_info=(&primitive_info);\n  mvg_info.extent=(&number_points);\n  mvg_info.exception=exception;\n  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  graphic_context[n]->viewbox=image->page;\n  if ((image->page.width == 0) || (image->page.height == 0))\n    {\n      graphic_context[n]->viewbox.width=image->columns;\n      graphic_context[n]->viewbox.height=image->rows;\n    }\n  token=AcquireString(primitive);\n  extent=strlen(token)+MagickPathExtent;\n  defsDepth=0;\n  symbolDepth=0;\n  cursor=0.0;\n  macros=GetMVGMacros(primitive);\n  status=MagickTrue;\n  for (q=primitive; *q != '\\0'; )\n  {\n    /*\n      Interpret graphic primitive.\n    */\n    if (GetNextToken(q,&q,MagickPathExtent,keyword) < 1)\n      break;\n    if (*keyword == '\\0')\n      break;\n    if (*keyword == '#')\n      {\n        /*\n          Comment.\n        */\n        while ((*q != '\\n') && (*q != '\\0'))\n          q++;\n        continue;\n      }\n    p=q-strlen(keyword)-1;\n    primitive_type=UndefinedPrimitive;\n    current=graphic_context[n]->affine;\n    GetAffineMatrix(&affine);\n    *token='\\0';\n    switch (*keyword)\n    {\n      case ';':\n        break;\n      case 'a':\n      case 'A':\n      {\n        if (LocaleCompare(\"affine\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.rx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ry=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.tx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"alpha\",keyword) == 0)\n          {\n            primitive_type=AlphaPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"arc\",keyword) == 0)\n          {\n            primitive_type=ArcPrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'b':\n      case 'B':\n      {\n        if (LocaleCompare(\"bezier\",keyword) == 0)\n          {\n            primitive_type=BezierPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"border-color\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->border_color,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        if (LocaleCompare(\"class\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if ((*token == '\\0') || (*token == ';'))\n              {\n                status=MagickFalse;\n                break;\n              }\n            if (LocaleCompare(token,graphic_context[n]->id) == 0)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if ((graphic_context[n]->render != MagickFalse) &&\n                (mvg_class != (const char *) NULL) && (p > primitive))\n              {\n                char\n                  *elements;\n\n                ssize_t\n                  offset;\n\n                /*\n                  Inject class elements in stream.\n                */\n                offset=(ssize_t) (p-primitive);\n                elements=AcquireString(primitive);\n                elements[offset]='\\0';\n                (void) ConcatenateString(&elements,mvg_class);\n                (void) ConcatenateString(&elements,\"\\n\");\n                (void) ConcatenateString(&elements,q);\n                primitive=DestroyString(primitive);\n                primitive=elements;\n                q=primitive+offset;\n              }\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",keyword) == 0)\n          {\n            const char\n              *clip_path;\n\n            /*\n              Take a node from within the MVG document, and duplicate it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == '\\0')\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) CloneString(&graphic_context[n]->clip_mask,token);\n            clip_path=(const char *) GetValueFromSplayTree(macros,token);\n            if (clip_path != (const char *) NULL)\n              {\n                if (graphic_context[n]->clipping_mask != (Image *) NULL)\n                  graphic_context[n]->clipping_mask=\n                    DestroyImage(graphic_context[n]->clipping_mask);\n                graphic_context[n]->clipping_mask=DrawClippingMask(image,\n                  graphic_context[n],token,clip_path,exception);\n                if (graphic_context[n]->compliance != SVGCompliance)\n                  {\n                    clip_path=(const char *) GetValueFromSplayTree(macros,\n                      graphic_context[n]->clip_mask);\n                    if (clip_path != (const char *) NULL)\n                      (void) SetImageArtifact(image,\n                        graphic_context[n]->clip_mask,clip_path);\n                    status&=DrawClipPath(image,graphic_context[n],\n                      graphic_context[n]->clip_mask,exception);\n                  }\n              }\n            break;\n          }\n        if (LocaleCompare(\"clip-rule\",keyword) == 0)\n          {\n            ssize_t\n              fill_rule;\n\n            (void) GetNextToken(q,&q,extent,token);\n            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,\n              token);\n            if (fill_rule == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->fill_rule=(FillRule) fill_rule;\n            break;\n          }\n        if (LocaleCompare(\"clip-units\",keyword) == 0)\n          {\n            ssize_t\n              clip_units;\n\n            (void) GetNextToken(q,&q,extent,token);\n            clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,\n              token);\n            if (clip_units == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->clip_units=(ClipPathUnits) clip_units;\n            if (clip_units == ObjectBoundingBox)\n              {\n                GetAffineMatrix(&current);\n                affine.sx=draw_info->bounds.x2;\n                affine.sy=draw_info->bounds.y2;\n                affine.tx=draw_info->bounds.x1;\n                affine.ty=draw_info->bounds.y1;\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"circle\",keyword) == 0)\n          {\n            primitive_type=CirclePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"color\",keyword) == 0)\n          {\n            primitive_type=ColorPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"compliance\",keyword) == 0)\n          {\n            /*\n              MVG compliance associates a clipping mask with an image; SVG\n              compliance associates a clipping mask with a graphics context.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->compliance=(ComplianceType) ParseCommandOption(\n              MagickComplianceOptions,MagickFalse,token);\n            break;\n          }\n        if (LocaleCompare(\"currentColor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'd':\n      case 'D':\n      {\n        if (LocaleCompare(\"decorate\",keyword) == 0)\n          {\n            ssize_t\n              decorate;\n\n            (void) GetNextToken(q,&q,extent,token);\n            decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,\n              token);\n            if (decorate == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->decorate=(DecorationType) decorate;\n            break;\n          }\n        if (LocaleCompare(\"density\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->density,token);\n            break;\n          }\n        if (LocaleCompare(\"direction\",keyword) == 0)\n          {\n            ssize_t\n              direction;\n\n            (void) GetNextToken(q,&q,extent,token);\n            direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,\n              token);\n            if (direction == -1)\n              status=MagickFalse;\n            else\n              graphic_context[n]->direction=(DirectionType) direction;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'e':\n      case 'E':\n      {\n        if (LocaleCompare(\"ellipse\",keyword) == 0)\n          {\n            primitive_type=EllipsePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"encoding\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->encoding,token);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'f':\n      case 'F':\n      {\n        if (LocaleCompare(\"fill\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if (mvg_class != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,mvg_class,\n                  &graphic_context[n]->fill_pattern,exception);\n                break;\n              }\n            (void) FormatLocaleString(pattern,MagickPathExtent,\"%s\",token);\n            if (GetImageArtifact(image,pattern) != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,token,\n                  &graphic_context[n]->fill_pattern,exception);\n                break;\n              }\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->fill,exception);\n            if (graphic_context[n]->fill_alpha != OpaqueAlpha)\n              graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;\n            break;\n          }\n        if (LocaleCompare(\"fill-opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*\n              GetDrawValue(token,&next_token),0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              graphic_context[n]->fill_alpha*=opacity;\n            else\n              graphic_context[n]->fill_alpha=QuantumRange*opacity;\n            if (graphic_context[n]->fill.alpha != TransparentAlpha)\n              graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;\n            else\n              graphic_context[n]->fill.alpha=(MagickRealType)\n                ClampToQuantum(QuantumRange*opacity);\n            graphic_context[n]->fill.alpha_trait=BlendPixelTrait;\n            break;\n          }\n        if (LocaleCompare(\"fill-rule\",keyword) == 0)\n          {\n            ssize_t\n              fill_rule;\n\n            (void) GetNextToken(q,&q,extent,token);\n            fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,\n              token);\n            if (fill_rule == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->fill_rule=(FillRule) fill_rule;\n            break;\n          }\n        if (LocaleCompare(\"font\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->font,token);\n            if (LocaleCompare(\"none\",token) == 0)\n              graphic_context[n]->font=(char *) RelinquishMagickMemory(\n                graphic_context[n]->font);\n            break;\n          }\n        if (LocaleCompare(\"font-family\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            (void) CloneString(&graphic_context[n]->family,token);\n            break;\n          }\n        if (LocaleCompare(\"font-size\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->pointsize=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"font-stretch\",keyword) == 0)\n          {\n            ssize_t\n              stretch;\n\n            (void) GetNextToken(q,&q,extent,token);\n            stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);\n            if (stretch == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->stretch=(StretchType) stretch;\n            break;\n          }\n        if (LocaleCompare(\"font-style\",keyword) == 0)\n          {\n            ssize_t\n              style;\n\n            (void) GetNextToken(q,&q,extent,token);\n            style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);\n            if (style == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->style=(StyleType) style;\n            break;\n          }\n        if (LocaleCompare(\"font-weight\",keyword) == 0)\n          {\n            ssize_t\n              weight;\n\n            (void) GetNextToken(q,&q,extent,token);\n            weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);\n            if (weight == -1)\n              weight=(ssize_t) StringToUnsignedLong(token);\n            graphic_context[n]->weight=(size_t) weight;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'g':\n      case 'G':\n      {\n        if (LocaleCompare(\"gradient-units\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"gravity\",keyword) == 0)\n          {\n            ssize_t\n              gravity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);\n            if (gravity == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->gravity=(GravityType) gravity;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'i':\n      case 'I':\n      {\n        if (LocaleCompare(\"image\",keyword) == 0)\n          {\n            ssize_t\n              compose;\n\n            primitive_type=ImagePrimitive;\n            (void) GetNextToken(q,&q,extent,token);\n            compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);\n            if (compose == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->compose=(CompositeOperator) compose;\n            break;\n          }\n        if (LocaleCompare(\"interline-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interline_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"interword-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interword_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'k':\n      case 'K':\n      {\n        if (LocaleCompare(\"kerning\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->kerning=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        if (LocaleCompare(\"letter-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (IsPoint(token) == MagickFalse)\n              break;\n            clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n            clone_info->text=AcquireString(\" \");\n            status&=GetTypeMetrics(image,clone_info,&metrics,exception);\n            graphic_context[n]->kerning=metrics.width*\n              GetDrawValue(token,&next_token);\n            clone_info=DestroyDrawInfo(clone_info);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"line\",keyword) == 0)\n          {\n            primitive_type=LinePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'm':\n      case 'M':\n      {\n        if (LocaleCompare(\"mask\",keyword) == 0)\n          {\n            const char\n              *mask_path;\n\n            /*\n              Take a node from within the MVG document, and duplicate it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            mask_path=(const char *) GetValueFromSplayTree(macros,token);\n            if (mask_path != (const char *) NULL)\n              {\n                if (graphic_context[n]->composite_mask != (Image *) NULL)\n                  graphic_context[n]->composite_mask=\n                    DestroyImage(graphic_context[n]->composite_mask);\n                graphic_context[n]->composite_mask=DrawCompositeMask(image,\n                  graphic_context[n],token,mask_path,exception);\n                if (graphic_context[n]->compliance != SVGCompliance)\n                  status=SetImageMask(image,CompositePixelMask,\n                    graphic_context[n]->composite_mask,exception);\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'o':\n      case 'O':\n      {\n        if (LocaleCompare(\"offset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*\n              GetDrawValue(token,&next_token),0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              {\n                graphic_context[n]->fill_alpha*=opacity;\n                graphic_context[n]->stroke_alpha*=opacity;\n              }\n            else\n              {\n                graphic_context[n]->fill_alpha=QuantumRange*opacity;\n                graphic_context[n]->stroke_alpha=QuantumRange*opacity;\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'p':\n      case 'P':\n      {\n        if (LocaleCompare(\"path\",keyword) == 0)\n          {\n            primitive_type=PathPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"point\",keyword) == 0)\n          {\n            primitive_type=PointPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polyline\",keyword) == 0)\n          {\n            primitive_type=PolylinePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"polygon\",keyword) == 0)\n          {\n            primitive_type=PolygonPrimitive;\n            break;\n          }\n        if (LocaleCompare(\"pop\",keyword) == 0)\n          {\n            if (GetNextToken(q,&q,extent,token) < 1)\n              break;\n            if (LocaleCompare(\"class\",token) == 0)\n              break;\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              break;\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                defsDepth--;\n                graphic_context[n]->render=defsDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              break;\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                if (n <= 0)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      DrawError,\"UnbalancedGraphicContextPushPop\",\"`%s'\",token);\n                    status=MagickFalse;\n                    n=0;\n                    break;\n                  }\n                if ((graphic_context[n]->clip_mask != (char *) NULL) &&\n                    (graphic_context[n]->compliance != SVGCompliance))\n                  if (LocaleCompare(graphic_context[n]->clip_mask,\n                      graphic_context[n-1]->clip_mask) != 0)\n                    status=SetImageMask(image,WritePixelMask,(Image *) NULL,\n                      exception);\n                graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n                n--;\n                break;\n              }\n            if (LocaleCompare(\"mask\",token) == 0)\n              break;\n            if (LocaleCompare(\"pattern\",token) == 0)\n              break;\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                symbolDepth--;\n                graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            status=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"push\",keyword) == 0)\n          {\n            if (GetNextToken(q,&q,extent,token) < 1)\n              break;\n            if (LocaleCompare(\"class\",token) == 0)\n              {\n                /*\n                  Class context.\n                */\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"class\") != 0)\n                    continue;\n                  break;\n                }\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"clip-path\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"clip-path\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"defs\",token) == 0)\n              {\n                defsDepth++;\n                graphic_context[n]->render=defsDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            if (LocaleCompare(\"gradient\",token) == 0)\n              {\n                char\n                  key[2*MagickPathExtent],\n                  name[MagickPathExtent],\n                  type[MagickPathExtent];\n\n                SegmentInfo\n                  segment;\n\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(type,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                segment.x1=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.y1=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.x2=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                segment.y2=GetDrawValue(token,&next_token);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                if (LocaleCompare(type,\"radial\") == 0)\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    if (*token == ',')\n                      (void) GetNextToken(q,&q,extent,token);\n                  }\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"gradient\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (*q == '\\0') || \n                    (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));\n                bounds.x1=graphic_context[n]->affine.sx*segment.x1+\n                  graphic_context[n]->affine.ry*segment.y1+\n                  graphic_context[n]->affine.tx;\n                bounds.y1=graphic_context[n]->affine.rx*segment.x1+\n                  graphic_context[n]->affine.sy*segment.y1+\n                  graphic_context[n]->affine.ty;\n                bounds.x2=graphic_context[n]->affine.sx*segment.x2+\n                  graphic_context[n]->affine.ry*segment.y2+\n                  graphic_context[n]->affine.tx;\n                bounds.y2=graphic_context[n]->affine.rx*segment.x2+\n                  graphic_context[n]->affine.sy*segment.y2+\n                  graphic_context[n]->affine.ty;\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s\",name);\n                (void) SetImageArtifact(image,key,token);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-type\",name);\n                (void) SetImageArtifact(image,key,type);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-geometry\",\n                  name);\n                (void) FormatLocaleString(geometry,MagickPathExtent,\n                  \"%gx%g%+.15g%+.15g\",\n                  MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),\n                  MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),\n                  bounds.x1,bounds.y1);\n                (void) SetImageArtifact(image,key,geometry);\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"graphic-context\",token) == 0)\n              {\n                n++;\n                graphic_context=(DrawInfo **) ResizeQuantumMemory(\n                  graphic_context,(size_t) (n+1),sizeof(*graphic_context));\n                if (graphic_context == (DrawInfo **) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                      image->filename);\n                    break;\n                  }\n                graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,\n                  graphic_context[n-1]);\n                if (*q == '\"')\n                  {\n                    (void) GetNextToken(q,&q,extent,token);\n                    (void) CloneString(&graphic_context[n]->id,token);\n                  }\n                break;\n              }\n            if (LocaleCompare(\"mask\",token) == 0)\n              {\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"pattern\",token) == 0)\n              {\n                char\n                  key[2*MagickPathExtent],\n                  name[MagickPathExtent];\n\n                RectangleInfo\n                  region;\n\n                (void) GetNextToken(q,&q,extent,token);\n                (void) CopyMagickString(name,token,MagickPathExtent);\n                (void) GetNextToken(q,&q,extent,token);\n                region.x=CastDoubleToLong(ceil(GetDrawValue(token,\n                  &next_token)-0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.y=CastDoubleToLong(ceil(GetDrawValue(token,\n                  &next_token)-0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.width=(size_t) CastDoubleToLong(floor(GetDrawValue(\n                  token,&next_token)+0.5));\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                (void) GetNextToken(q,&q,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(q,&q,extent,token);\n                region.height=(size_t) floor(GetDrawValue(token,&next_token)+\n                  0.5);\n                if (token == next_token)\n                  ThrowPointExpectedException(token,exception);\n                for (p=q; *q != '\\0'; )\n                {\n                  if (GetNextToken(q,&q,extent,token) < 1)\n                    break;\n                  if (LocaleCompare(token,\"pop\") != 0)\n                    continue;\n                  (void) GetNextToken(q,(const char **) NULL,extent,token);\n                  if (LocaleCompare(token,\"pattern\") != 0)\n                    continue;\n                  break;\n                }\n                if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s\",name);\n                (void) SetImageArtifact(image,key,token);\n                (void) FormatLocaleString(key,MagickPathExtent,\"%s-geometry\",\n                  name);\n                (void) FormatLocaleString(geometry,MagickPathExtent,\n                  \"%.20gx%.20g%+.20g%+.20g\",(double) region.width,(double)\n                  region.height,(double) region.x,(double) region.y);\n                (void) SetImageArtifact(image,key,geometry);\n                (void) GetNextToken(q,&q,extent,token);\n                break;\n              }\n            if (LocaleCompare(\"symbol\",token) == 0)\n              {\n                symbolDepth++;\n                graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :\n                  MagickTrue;\n                break;\n              }\n            status=MagickFalse;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'r':\n      case 'R':\n      {\n        if (LocaleCompare(\"rectangle\",keyword) == 0)\n          {\n            primitive_type=RectanglePrimitive;\n            break;\n          }\n        if (LocaleCompare(\"rotate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));\n            affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));\n            affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));\n            affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));\n            break;\n          }\n        if (LocaleCompare(\"roundRectangle\",keyword) == 0)\n          {\n            primitive_type=RoundRectanglePrimitive;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        if (LocaleCompare(\"scale\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.sx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.sy=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"skewX\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.ry=sin(DegreesToRadians(angle));\n            break;\n          }\n        if (LocaleCompare(\"skewY\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            angle=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            affine.rx=(-tan(DegreesToRadians(angle)/2.0));\n            break;\n          }\n        if (LocaleCompare(\"stop-color\",keyword) == 0)\n          {\n            PixelInfo\n              stop_color;\n\n            number_stops++;\n            if (number_stops == 1)\n              stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));\n            else\n              if (number_stops > 2)\n                stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,\n                  sizeof(*stops));\n            if (stops == (StopInfo *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                  image->filename);\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,&stop_color,\n              exception);\n            stops[number_stops-1].color=stop_color;\n            (void) GetNextToken(q,&q,extent,token);\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            stops[number_stops-1].offset=factor*GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke\",keyword) == 0)\n          {\n            const char\n              *mvg_class;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            mvg_class=(const char *) GetValueFromSplayTree(macros,token);\n            if (mvg_class != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,mvg_class,\n                  &graphic_context[n]->stroke_pattern,exception);\n                break;\n              }\n            (void) FormatLocaleString(pattern,MagickPathExtent,\"%s\",token);\n            if (GetImageArtifact(image,pattern) != (const char *) NULL)\n              {\n                (void) DrawPatternPath(image,draw_info,token,\n                  &graphic_context[n]->stroke_pattern,exception);\n                break;\n              }\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->stroke,exception);\n            if (graphic_context[n]->stroke_alpha != OpaqueAlpha)\n              graphic_context[n]->stroke.alpha=\n                graphic_context[n]->stroke_alpha;\n            break;\n          }\n        if (LocaleCompare(\"stroke-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->stroke_antialias=StringToLong(token) != 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"stroke-dasharray\",keyword) == 0)\n          {\n            if (graphic_context[n]->dash_pattern != (double *) NULL)\n              graphic_context[n]->dash_pattern=(double *)\n                RelinquishMagickMemory(graphic_context[n]->dash_pattern);\n            if (IsPoint(q) != MagickFalse)\n              {\n                const char\n                  *r;\n\n                r=q;\n                (void) GetNextToken(r,&r,extent,token);\n                if (*token == ',')\n                  (void) GetNextToken(r,&r,extent,token);\n                for (x=0; IsPoint(token) != MagickFalse; x++)\n                {\n                  (void) GetNextToken(r,&r,extent,token);\n                  if (*token == ',')\n                    (void) GetNextToken(r,&r,extent,token);\n                }\n                graphic_context[n]->dash_pattern=(double *)\n                  AcquireQuantumMemory((size_t) (2*x+2),\n                  sizeof(*graphic_context[n]->dash_pattern));\n                if (graphic_context[n]->dash_pattern == (double *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n                      image->filename);\n                    status=MagickFalse;\n                    break;\n                  }\n                (void) memset(graphic_context[n]->dash_pattern,0,(size_t)\n                  (2*x+2)*sizeof(*graphic_context[n]->dash_pattern));\n                for (j=0; j < x; j++)\n                {\n                  (void) GetNextToken(q,&q,extent,token);\n                  if (*token == ',')\n                    (void) GetNextToken(q,&q,extent,token);\n                  graphic_context[n]->dash_pattern[j]=GetDrawValue(token,\n                    &next_token);\n                  if (token == next_token)\n                    ThrowPointExpectedException(token,exception);\n                  if (graphic_context[n]->dash_pattern[j] <= 0.0)\n                    status=MagickFalse;\n                }\n                if ((x & 0x01) != 0)\n                  for ( ; j < (2*x); j++)\n                    graphic_context[n]->dash_pattern[j]=\n                      graphic_context[n]->dash_pattern[j-x];\n                graphic_context[n]->dash_pattern[j]=0.0;\n                break;\n              }\n            (void) GetNextToken(q,&q,extent,token);\n            break;\n          }\n        if (LocaleCompare(\"stroke-dashoffset\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->dash_offset=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        if (LocaleCompare(\"stroke-linecap\",keyword) == 0)\n          {\n            ssize_t\n              linecap;\n\n            (void) GetNextToken(q,&q,extent,token);\n            linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);\n            if (linecap == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->linecap=(LineCap) linecap;\n            break;\n          }\n        if (LocaleCompare(\"stroke-linejoin\",keyword) == 0)\n          {\n            ssize_t\n              linejoin;\n\n            (void) GetNextToken(q,&q,extent,token);\n            linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,\n              token);\n            if (linejoin == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->linejoin=(LineJoin) linejoin;\n            break;\n          }\n        if (LocaleCompare(\"stroke-miterlimit\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->miterlimit=StringToUnsignedLong(token);\n            break;\n          }\n        if (LocaleCompare(\"stroke-opacity\",keyword) == 0)\n          {\n            double\n              opacity;\n\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;\n            opacity=MagickMin(MagickMax(factor*GetDrawValue(token,&next_token),\n              0.0),1.0);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (graphic_context[n]->compliance == SVGCompliance)\n              graphic_context[n]->stroke_alpha*=opacity;\n            else\n              graphic_context[n]->stroke_alpha=QuantumRange*opacity;\n            if (graphic_context[n]->stroke.alpha != TransparentAlpha)\n              graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;\n            else\n              graphic_context[n]->stroke.alpha=(MagickRealType)\n                ClampToQuantum(QuantumRange*opacity);\n            graphic_context[n]->stroke.alpha_trait=BlendPixelTrait;\n            break;\n          }\n        if (LocaleCompare(\"stroke-width\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            if (graphic_context[n]->clip_path != MagickFalse)\n              break;\n            graphic_context[n]->stroke_width=GetDrawValue(token,&next_token);\n            if ((token == next_token) ||\n                (graphic_context[n]->stroke_width < 0.0))\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        if (LocaleCompare(\"text\",keyword) == 0)\n          {\n            primitive_type=TextPrimitive;\n            cursor=0.0;\n            break;\n          }\n        if (LocaleCompare(\"text-align\",keyword) == 0)\n          {\n            ssize_t\n              align;\n\n            (void) GetNextToken(q,&q,extent,token);\n            align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);\n            if (align == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->align=(AlignType) align;\n            break;\n          }\n        if (LocaleCompare(\"text-anchor\",keyword) == 0)\n          {\n            ssize_t\n              align;\n\n            (void) GetNextToken(q,&q,extent,token);\n            align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);\n            if (align == -1)\n              {\n                status=MagickFalse;\n                break;\n              }\n            graphic_context[n]->align=(AlignType) align;\n            break;\n          }\n        if (LocaleCompare(\"text-antialias\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->text_antialias=StringToLong(token) != 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"text-undercolor\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            status&=QueryColorCompliance(token,AllCompliance,\n              &graphic_context[n]->undercolor,exception);\n            break;\n          }\n        if (LocaleCompare(\"translate\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            affine.tx=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            affine.ty=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            cursor=0.0;\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'u':\n      case 'U':\n      {\n        if (LocaleCompare(\"use\",keyword) == 0)\n          {\n            const char\n              *use;\n\n            /*\n              Get a macro from the MVG document, and \"use\" it here.\n            */\n            (void) GetNextToken(q,&q,extent,token);\n            use=(const char *) GetValueFromSplayTree(macros,token);\n            if (use != (const char *) NULL)\n              {\n                clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n                (void) CloneString(&clone_info->primitive,use);\n                status=RenderMVGContent(image,clone_info,depth+1,exception);\n                clone_info=DestroyDrawInfo(clone_info);\n              }\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        if (LocaleCompare(\"viewbox\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.x=CastDoubleToLong(ceil(\n              GetDrawValue(token,&next_token)-0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.y=CastDoubleToLong(ceil(\n              GetDrawValue(token,&next_token)-0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.width=(size_t) CastDoubleToLong(\n              floor(GetDrawValue(token,&next_token)+0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(q,&q,extent,token);\n            if (*token == ',')\n              (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->viewbox.height=(size_t) CastDoubleToLong(\n              floor(GetDrawValue(token,&next_token)+0.5));\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      case 'w':\n      case 'W':\n      {\n        if (LocaleCompare(\"word-spacing\",keyword) == 0)\n          {\n            (void) GetNextToken(q,&q,extent,token);\n            graphic_context[n]->interword_spacing=GetDrawValue(token,\n              &next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            break;\n          }\n        status=MagickFalse;\n        break;\n      }\n      default:\n      {\n        status=MagickFalse;\n        break;\n      }\n    }\n    if (status == MagickFalse)\n      break;\n    if ((fabs(affine.sx-1.0) >= MagickEpsilon) ||\n        (fabs(affine.rx) >= MagickEpsilon) || (fabs(affine.ry) >= MagickEpsilon) ||\n        (fabs(affine.sy-1.0) >= MagickEpsilon) ||\n        (fabs(affine.tx) >= MagickEpsilon) || (fabs(affine.ty) >= MagickEpsilon))\n      {\n        graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;\n        graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;\n        graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;\n        graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;\n        graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+\n          current.tx;\n        graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+\n          current.ty;\n      }\n    if (primitive_type == UndefinedPrimitive)\n      {\n        if (*q == '\\0')\n          {\n            if (number_stops > 1)\n              {\n                GradientType\n                  type;\n\n              type=LinearGradient;\n              if (draw_info->gradient.type == RadialGradient)\n                type=RadialGradient;\n              (void) GradientImage(image,type,PadSpread,stops,number_stops,\n                exception);\n             }\n           if (number_stops > 0)\n             stops=(StopInfo *) RelinquishMagickMemory(stops);\n          }\n        if ((draw_info->debug != MagickFalse) && (q > p))\n          (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  %.*s\",(int)\n            (q-p-1),p);\n        continue;\n      }\n    /*\n      Parse the primitive attributes.\n    */\n    for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n      if (primitive_info[i].text != (char *) NULL)\n        primitive_info[i].text=DestroyString(primitive_info[i].text);\n    i=0;\n    mvg_info.offset=i;\n    j=0;\n    primitive_info[0].point.x=0.0;\n    primitive_info[0].point.y=0.0;\n    primitive_info[0].coordinates=0;\n    primitive_info[0].method=FloodfillMethod;\n    primitive_info[0].closed_subpath=MagickFalse;\n    for (x=0; *q != '\\0'; x++)\n    {\n      /*\n        Define points.\n      */\n      if (IsPoint(q) == MagickFalse)\n        break;\n      (void) GetNextToken(q,&q,extent,token);\n      point.x=GetDrawValue(token,&next_token);\n      if (token == next_token)\n        ThrowPointExpectedException(token,exception);\n      (void) GetNextToken(q,&q,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      point.y=GetDrawValue(token,&next_token);\n      if (token == next_token)\n        ThrowPointExpectedException(token,exception);\n      (void) GetNextToken(q,(const char **) NULL,extent,token);\n      if (*token == ',')\n        (void) GetNextToken(q,&q,extent,token);\n      primitive_info[i].primitive=primitive_type;\n      primitive_info[i].point=point;\n      primitive_info[i].coordinates=0;\n      primitive_info[i].method=FloodfillMethod;\n      primitive_info[i].closed_subpath=MagickFalse;\n      i++;\n      mvg_info.offset=i;\n      if (i < (ssize_t) number_points)\n        continue;\n      status&=CheckPrimitiveExtent(&mvg_info,(double) number_points);\n      primitive_info=(*mvg_info.primitive_info);\n    }\n    if (status == MagickFalse)\n      break;\n    if (primitive_info[j].text != (char *) NULL)\n      primitive_info[j].text=DestroyString(primitive_info[j].text);\n    primitive_info[j].primitive=primitive_type;\n    primitive_info[j].coordinates=(size_t) x;\n    primitive_info[j].method=FloodfillMethod;\n    primitive_info[j].closed_subpath=MagickFalse;\n    /*\n      Circumscribe primitive within a circle.\n    */\n    bounds.x1=primitive_info[j].point.x;\n    bounds.y1=primitive_info[j].point.y;\n    bounds.x2=primitive_info[j].point.x;\n    bounds.y2=primitive_info[j].point.y;\n    for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)\n    {\n      point=primitive_info[j+k].point;\n      if (point.x < bounds.x1)\n        bounds.x1=point.x;\n      if (point.y < bounds.y1)\n        bounds.y1=point.y;\n      if (point.x > bounds.x2)\n        bounds.x2=point.x;\n      if (point.y > bounds.y2)\n        bounds.y2=point.y;\n    }\n    /*\n      Speculate how many points our primitive might consume.\n    */\n    coordinates=(double) primitive_info[j].coordinates;\n    switch (primitive_type)\n    {\n      case RectanglePrimitive:\n      {\n        coordinates*=5.0;\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        double\n          alpha,\n          beta,\n          radius;\n\n        alpha=bounds.x2-bounds.x1;\n        beta=bounds.y2-bounds.y1;\n        radius=hypot(alpha,beta);\n        coordinates*=5.0;\n        coordinates+=2.0*((size_t) ceil((double) MagickPI*radius))+6.0*\n          BezierQuantum+360.0;\n        break;\n      }\n      case BezierPrimitive:\n      {\n        coordinates=(BezierQuantum*(double) primitive_info[j].coordinates);\n        break;\n      }\n      case PathPrimitive:\n      {\n        char\n          *s,\n          *t;\n\n        (void) GetNextToken(q,&q,extent,token);\n        coordinates=1.0;\n        t=token;\n        for (s=token; *s != '\\0'; s=t)\n        {\n          double\n            value;\n\n          value=GetDrawValue(s,&t);\n          (void) value;\n          if (s == t)\n            {\n              t++;\n              continue;\n            }\n          coordinates++;\n        }\n        for (s=token; *s != '\\0'; s++)\n          if (strspn(s,\"AaCcQqSsTt\") != 0)\n            coordinates+=(20.0*BezierQuantum)+360.0;\n        break;\n      }\n      default:\n        break;\n    }\n    if (status == MagickFalse)\n      break;\n    if (((size_t) (i+coordinates)) >= number_points)\n      {\n        /*\n          Resize based on speculative points required by primitive.\n        */\n        number_points+=coordinates+1;\n        if (number_points < (size_t) coordinates)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        mvg_info.offset=i;\n        status&=CheckPrimitiveExtent(&mvg_info,(double) number_points);\n        primitive_info=(*mvg_info.primitive_info);\n      }\n    status&=CheckPrimitiveExtent(&mvg_info,PrimitiveExtentPad);\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == MagickFalse)\n      break;\n    mvg_info.offset=j;\n    switch (primitive_type)\n    {\n      case PointPrimitive:\n      default:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TracePoint(primitive_info+j,primitive_info[j].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case LinePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceLine(primitive_info+j,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case RectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceRectangle(primitive_info+j,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case RoundRectanglePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+2].point.x < 0.0) ||\n            (primitive_info[j+2].point.y < 0.0))\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceRoundRectangle(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case ArcPrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceArc(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case EllipsePrimitive:\n      {\n        if (primitive_info[j].coordinates != 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if ((primitive_info[j+1].point.x < 0.0) ||\n            (primitive_info[j+1].point.y < 0.0))\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceEllipse(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point,primitive_info[j+2].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case CirclePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceCircle(&mvg_info,primitive_info[j].point,\n          primitive_info[j+1].point);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case PolylinePrimitive:\n      {\n        if (primitive_info[j].coordinates < 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        break;\n      }\n      case PolygonPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[i]=primitive_info[j];\n        primitive_info[i].coordinates=0;\n        primitive_info[j].coordinates++;\n        primitive_info[j].closed_subpath=MagickTrue;\n        i++;\n        break;\n      }\n      case BezierPrimitive:\n      {\n        if (primitive_info[j].coordinates < 3)\n          {\n            status=MagickFalse;\n            break;\n          }\n        status&=TraceBezier(&mvg_info,primitive_info[j].coordinates);\n        primitive_info=(*mvg_info.primitive_info);\n        i=(ssize_t) (j+primitive_info[j].coordinates);\n        break;\n      }\n      case PathPrimitive:\n      {\n        coordinates=(double) TracePath(&mvg_info,token,exception);\n        primitive_info=(*mvg_info.primitive_info); \n        if (coordinates < 0.0)\n          {\n            status=MagickFalse;\n            break;\n          }\n        i=(ssize_t) (j+coordinates);\n        break;\n      }\n      case AlphaPrimitive:\n      case ColorPrimitive:\n      {\n        ssize_t\n          method;\n\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);\n        if (method == -1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        primitive_info[j].method=(PaintMethod) method;\n        break;\n      }\n      case TextPrimitive:\n      {\n        if (primitive_info[j].coordinates != 1)\n          {\n            status=MagickFalse;\n            break;\n          }\n        if (*token != ',')\n          (void) GetNextToken(q,&q,extent,token);\n        (void) CloneString(&primitive_info[j].text,token);\n        /*\n          Compute text cursor offset.\n        */\n        clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);\n        if ((fabs(mvg_info.point.x-primitive_info->point.x) < MagickEpsilon) &&\n            (fabs(mvg_info.point.y-primitive_info->point.y) < MagickEpsilon))\n          {\n            mvg_info.point=primitive_info->point;\n            primitive_info->point.x+=cursor;\n          }\n        else\n          {\n            mvg_info.point=primitive_info->point;\n            cursor=0.0;\n          }\n        clone_info->render=MagickFalse;\n        clone_info->text=AcquireString(token);\n        status&=GetTypeMetrics(image,clone_info,&metrics,exception);\n        clone_info=DestroyDrawInfo(clone_info);\n        cursor+=metrics.width;\n        if (graphic_context[n]->compliance != SVGCompliance)\n          cursor=0.0;\n        break;\n      }\n      case ImagePrimitive:\n      {\n        if (primitive_info[j].coordinates != 2)\n          {\n            status=MagickFalse;\n            break;\n          }\n        (void) GetNextToken(q,&q,extent,token);\n        (void) CloneString(&primitive_info[j].text,token);\n        break;\n      }\n    }\n    mvg_info.offset=i;\n    if (status == 0)\n      break;\n    primitive_info[i].primitive=UndefinedPrimitive;\n    if ((draw_info->debug != MagickFalse) && (q > p))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  %.*s\",(int) (q-p),p);\n    /*\n      Sanity check.\n    */\n    status&=CheckPrimitiveExtent(&mvg_info,ExpandAffine(\n      &graphic_context[n]->affine));\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == 0)\n      break;\n    status&=CheckPrimitiveExtent(&mvg_info,(double)\n      graphic_context[n]->stroke_width);\n    primitive_info=(*mvg_info.primitive_info);\n    if (status == 0)\n      break;\n    if (i == 0)\n      continue;\n    /*\n      Transform points.\n    */\n    for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n    {\n      point=primitive_info[i].point;\n      primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+\n        graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;\n      primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+\n        graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;\n      point=primitive_info[i].point;\n      if (point.x < graphic_context[n]->bounds.x1)\n        graphic_context[n]->bounds.x1=point.x;\n      if (point.y < graphic_context[n]->bounds.y1)\n        graphic_context[n]->bounds.y1=point.y;\n      if (point.x > graphic_context[n]->bounds.x2)\n        graphic_context[n]->bounds.x2=point.x;\n      if (point.y > graphic_context[n]->bounds.y2)\n        graphic_context[n]->bounds.y2=point.y;\n      if (primitive_info[i].primitive == ImagePrimitive)\n        break;\n      if (i >= (ssize_t) number_points)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n    }\n    if (graphic_context[n]->render != MagickFalse)\n      {\n        if ((n != 0) && (graphic_context[n]->compliance != SVGCompliance) &&\n            (graphic_context[n]->clip_mask != (char *) NULL) &&\n            (LocaleCompare(graphic_context[n]->clip_mask,\n             graphic_context[n-1]->clip_mask) != 0))\n          {\n            const char\n              *clip_path;\n\n            clip_path=(const char *) GetValueFromSplayTree(macros,\n              graphic_context[n]->clip_mask);\n            if (clip_path != (const char *) NULL)\n              (void) SetImageArtifact(image,graphic_context[n]->clip_mask,\n                clip_path);\n            status&=DrawClipPath(image,graphic_context[n],\n              graphic_context[n]->clip_mask,exception);\n          }\n        status&=DrawPrimitive(image,graphic_context[n],primitive_info,\n          exception);\n      }\n    proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)\n      primitive_extent);\n    if (proceed == MagickFalse)\n      break;\n    if (status == 0)\n      break;\n  }\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end draw-image\");\n  /*\n    Relinquish resources.\n  */\n  macros=DestroySplayTree(macros);\n  token=DestroyString(token);\n  if (primitive_info != (PrimitiveInfo *) NULL)\n    {\n      for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n        if (primitive_info[i].text != (char *) NULL)\n          primitive_info[i].text=DestroyString(primitive_info[i].text);\n      primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);\n    }\n  primitive=DestroyString(primitive);\n  if (stops != (StopInfo *) NULL)\n    stops=(StopInfo *) RelinquishMagickMemory(stops);\n  for ( ; n >= 0; n--)\n    graphic_context[n]=DestroyDrawInfo(graphic_context[n]);\n  graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);\n  if (status == MagickFalse)\n    ThrowBinaryException(DrawError,\"NonconformingDrawingPrimitiveDefinition\",\n      keyword);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\nMagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,\n  ExceptionInfo *exception)\n{\n  return(RenderMVGContent(image,draw_info,0,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w P a t t e r n P a t h                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPatternPath() draws a pattern.\n%\n%  The format of the DrawPatternPath method is:\n%\n%      MagickBooleanType DrawPatternPath(Image *image,const DrawInfo *draw_info,\n%        const char *name,Image **pattern,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o name: the pattern name.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n\n  const char\n    *geometry,\n    *path,\n    *type;\n\n  DrawInfo\n    *clone_info;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w P o l y g o n P r i m i t i v e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPolygonPrimitive() draws a polygon on the image.\n%\n%  The format of the DrawPolygonPrimitive method is:\n%\n%      MagickBooleanType DrawPolygonPrimitive(Image *image,\n%        const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic PolygonInfo **DestroyPolygonTLS(PolygonInfo **polygon_info)\n{\n  ssize_t\n    i;\n\n  assert(polygon_info != (PolygonInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (polygon_info[i] != (PolygonInfo *) NULL)\n      polygon_info[i]=DestroyPolygonInfo(polygon_info[i]);\n  polygon_info=(PolygonInfo **) RelinquishMagickMemory(polygon_info);\n  return(polygon_info);\n}\n\nstatic PolygonInfo **AcquirePolygonTLS(const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  PathInfo\n    *magick_restrict path_info;\n\n  PolygonInfo\n    **polygon_info;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  polygon_info=(PolygonInfo **) AcquireQuantumMemory(number_threads,\n    sizeof(*polygon_info));\n  if (polygon_info == (PolygonInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PolygonInfo **) NULL);\n    }\n  (void) memset(polygon_info,0,number_threads*sizeof(*polygon_info));\n  path_info=ConvertPrimitiveToPath(primitive_info,exception);\n  if (path_info == (PathInfo *) NULL)\n    return(DestroyPolygonTLS(polygon_info));\n  polygon_info[0]=ConvertPathToPolygon(path_info,exception);\n  if (polygon_info[0] == (PolygonInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(DestroyPolygonTLS(polygon_info));\n    }\n  path_info=(PathInfo *) RelinquishMagickMemory(path_info);\n  return(polygon_info);\n}\n\nstatic MagickBooleanType ClonePolygonEdgesTLS(PolygonInfo **polygon_info,\n  const size_t number_threads,ExceptionInfo *exception)\n{\n  ssize_t\n    i;\n\n  for (i=1; i < (ssize_t) number_threads; i++)\n  {\n    EdgeInfo\n      *edge_info;\n\n    ssize_t\n      j;\n\n    polygon_info[i]=(PolygonInfo *) AcquireMagickMemory(\n      sizeof(*polygon_info[i]));\n    if (polygon_info[i] == (PolygonInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(MagickFalse);\n      }\n    polygon_info[i]->number_edges=0;\n    edge_info=polygon_info[0]->edges;\n    polygon_info[i]->edges=(EdgeInfo *) AcquireQuantumMemory(\n      polygon_info[0]->number_edges,sizeof(*edge_info));\n    if (polygon_info[i]->edges == (EdgeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n        return(MagickFalse);\n      }\n    (void) memcpy(polygon_info[i]->edges,edge_info,\n      polygon_info[0]->number_edges*sizeof(*edge_info));\n    for (j=0; j < (ssize_t) polygon_info[i]->number_edges; j++)\n      polygon_info[i]->edges[j].points=(PointInfo *) NULL;\n    polygon_info[i]->number_edges=polygon_info[0]->number_edges;\n    for (j=0; j < (ssize_t) polygon_info[i]->number_edges; j++)\n    {\n      edge_info=polygon_info[0]->edges+j;\n      polygon_info[i]->edges[j].points=(PointInfo *) AcquireQuantumMemory(\n        edge_info->number_points,sizeof(*edge_info));\n      if (polygon_info[i]->edges[j].points == (PointInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      (void) memcpy(polygon_info[i]->edges[j].points,edge_info->points,\n        edge_info->number_points*sizeof(*edge_info->points));\n    }\n  }\n  return(MagickTrue);\n}\n\nstatic size_t DestroyEdge(PolygonInfo *polygon_info,const ssize_t edge)\n{\n  assert(edge < (ssize_t) polygon_info->number_edges);\n  polygon_info->edges[edge].points=(PointInfo *) RelinquishMagickMemory(\n    polygon_info->edges[edge].points);\n  polygon_info->number_edges--;\n  if (edge < (ssize_t) polygon_info->number_edges)\n    (void) memmove(polygon_info->edges+edge,polygon_info->edges+edge+1,\n      (size_t) (polygon_info->number_edges-edge)*sizeof(*polygon_info->edges));\n  return(polygon_info->number_edges);\n}\n\nstatic double GetFillAlpha(PolygonInfo *polygon_info,const double mid,\n  const MagickBooleanType fill,const FillRule fill_rule,const ssize_t x,\n  const ssize_t y,double *stroke_alpha)\n{\n  double\n    alpha,\n    beta,\n    distance,\n    subpath_alpha;\n\n  const PointInfo\n    *q;\n\n  EdgeInfo\n    *p;\n\n  PointInfo\n    delta;\n\n  ssize_t\n    i,\n    j,\n    winding_number;\n\n  /*\n    Compute fill & stroke opacity for this (x,y) point.\n  */\n  *stroke_alpha=0.0;\n  subpath_alpha=0.0;\n  p=polygon_info->edges;\n  for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)\n  {\n    if ((double) y <= (p->bounds.y1-mid-0.5))\n      break;\n    if ((double) y > (p->bounds.y2+mid+0.5))\n      {\n        p--;\n        (void) DestroyEdge(polygon_info,j--);\n        continue;\n      }\n    if (((double) x <= (p->bounds.x1-mid-0.5)) ||\n        ((double) x > (p->bounds.x2+mid+0.5)))\n      continue;\n    i=(ssize_t) MagickMax((double) p->highwater,1.0);\n    for ( ; i < (ssize_t) p->number_points; i++)\n    {\n      if ((double) y <= (p->points[i-1].y-mid-0.5))\n        break;\n      if ((double) y > (p->points[i].y+mid+0.5))\n        continue;\n      if (p->scanline != (double) y)\n        {\n          p->scanline=(double) y;\n          p->highwater=(size_t) i;\n        }\n      /*\n        Compute distance between a point and an edge.\n      */\n      q=p->points+i-1;\n      delta.x=(q+1)->x-q->x;\n      delta.y=(q+1)->y-q->y;\n      beta=delta.x*(x-q->x)+delta.y*(y-q->y);  /* segLen*point-cos(theta) */\n      if (beta <= 0.0)\n        {\n          /*\n            Cosine <= 0, point is closest to q.\n          */\n          delta.x=(double) x-q->x;\n          delta.y=(double) y-q->y;\n          distance=delta.x*delta.x+delta.y*delta.y;\n        }\n      else\n        {\n          alpha=delta.x*delta.x+delta.y*delta.y;  /* segLen*segLen */\n          if (beta >= alpha)\n            {\n              /*\n                Point is closest to q+1.\n              */\n              delta.x=(double) x-(q+1)->x;\n              delta.y=(double) y-(q+1)->y;\n              distance=delta.x*delta.x+delta.y*delta.y;\n            }\n          else\n            {\n              /*\n                Point is closest to point between q & q+1.\n              */\n              alpha=PerceptibleReciprocal(alpha);\n              beta=delta.x*(y-q->y)-delta.y*(x-q->x);\n              distance=alpha*beta*beta;\n            }\n        }\n      /*\n        Compute stroke & subpath opacity.\n      */\n      beta=0.0;\n      if (p->ghostline == MagickFalse)\n        {\n          alpha=mid+0.5;\n          if ((*stroke_alpha < 1.0) &&\n              (distance <= ((alpha+0.25)*(alpha+0.25))))\n            {\n              alpha=mid-0.5;\n              if (distance <= ((alpha+0.25)*(alpha+0.25)))\n                *stroke_alpha=1.0;\n              else\n                {\n                  beta=1.0;\n                  if (fabs(distance-1.0) >= MagickEpsilon)\n                    beta=sqrt((double) distance);\n                  alpha=beta-mid-0.5;\n                  if (*stroke_alpha < ((alpha-0.25)*(alpha-0.25)))\n                    *stroke_alpha=(alpha-0.25)*(alpha-0.25);\n                }\n            }\n        }\n      if ((fill == MagickFalse) || (distance > 1.0) || (subpath_alpha >= 1.0))\n        continue;\n      if (distance <= 0.0)\n        {\n          subpath_alpha=1.0;\n          continue;\n        }\n      if (distance > 1.0)\n        continue;\n      if (fabs(beta) < MagickEpsilon)\n        {\n          beta=1.0;\n          if (fabs(distance-1.0) >= MagickEpsilon)\n            beta=sqrt(distance);\n        }\n      alpha=beta-1.0;\n      if (subpath_alpha < (alpha*alpha))\n        subpath_alpha=alpha*alpha;\n    }\n  }\n  /*\n    Compute fill opacity.\n  */\n  if (fill == MagickFalse)\n    return(0.0);\n  if (subpath_alpha >= 1.0)\n    return(1.0);\n  /*\n    Determine winding number.\n  */\n  winding_number=0;\n  p=polygon_info->edges;\n  for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)\n  {\n    if ((double) y <= p->bounds.y1)\n      break;\n    if (((double) y > p->bounds.y2) || ((double) x <= p->bounds.x1))\n      continue;\n    if ((double) x > p->bounds.x2)\n      {\n        winding_number+=p->direction != 0 ? 1 : -1;\n        continue;\n      }\n    i=(ssize_t) MagickMax((double) p->highwater,1.0);\n    for ( ; i < (ssize_t) (p->number_points-1); i++)\n      if ((double) y <= p->points[i].y)\n        break;\n    q=p->points+i-1;\n    if ((((q+1)->x-q->x)*(y-q->y)) <= (((q+1)->y-q->y)*(x-q->x)))\n      winding_number+=p->direction != 0 ? 1 : -1;\n  }\n  if (fill_rule != NonZeroRule)\n    {\n      if ((MagickAbsoluteValue(winding_number) & 0x01) != 0)\n        return(1.0);\n    }\n  else\n    if (MagickAbsoluteValue(winding_number) != 0)\n      return(1.0);\n  return(subpath_alpha);\n}\n\nstatic MagickBooleanType DrawPolygonPrimitive(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  typedef struct _ExtentInfo\n  {\n    ssize_t\n      x1,\n      y1,\n      x2,\n      y2;\n  } ExtentInfo;\n\n  CacheView\n    *image_view;\n\n  const char\n    *artifact;\n\n  double\n    mid;\n\n  EdgeInfo\n    *p;\n\n  ExtentInfo\n    poly_extent;\n\n  MagickBooleanType\n    fill,\n    status;\n\n  PolygonInfo\n    **magick_restrict polygon_info;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    number_threads;\n\n  ssize_t\n    i,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  assert(primitive_info != (PrimitiveInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (primitive_info->coordinates <= 1)\n    return(MagickTrue);\n  /*\n    Compute bounding box.\n  */\n  polygon_info=AcquirePolygonTLS(primitive_info,exception);\n  if (polygon_info == (PolygonInfo **) NULL)\n    return(MagickFalse);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-polygon\");\n  fill=(primitive_info->method == FillToBorderMethod) ||\n    (primitive_info->method == FloodfillMethod) ? MagickTrue : MagickFalse;\n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n  bounds=polygon_info[0]->edges[0].bounds;\n  artifact=GetImageArtifact(image,\"draw:render-bounding-rectangles\");\n  if (IsStringTrue(artifact) != MagickFalse)\n    (void) DrawBoundingRectangles(image,draw_info,polygon_info[0],exception);\n  for (i=1; i < (ssize_t) polygon_info[0]->number_edges; i++)\n  {\n    p=polygon_info[0]->edges+i;\n    if (p->bounds.x1 < bounds.x1)\n      bounds.x1=p->bounds.x1;\n    if (p->bounds.y1 < bounds.y1)\n      bounds.y1=p->bounds.y1;\n    if (p->bounds.x2 > bounds.x2)\n      bounds.x2=p->bounds.x2;\n    if (p->bounds.y2 > bounds.y2)\n      bounds.y2=p->bounds.y2;\n  }\n  bounds.x1-=(mid+1.0);\n  bounds.y1-=(mid+1.0);\n  bounds.x2+=(mid+1.0);\n  bounds.y2+=(mid+1.0);\n  if ((bounds.x1 >= (double) image->columns) ||\n      (bounds.y1 >= (double) image->rows) ||\n      (bounds.x2 <= 0.0) || (bounds.y2 <= 0.0))\n    {\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      return(MagickTrue);  /* virtual polygon */\n    }\n  bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double) image->columns-1.0 ?\n    (double) image->columns-1.0 : bounds.x1;\n  bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double) image->rows-1.0 ?\n    (double) image->rows-1.0 : bounds.y1;\n  bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double) image->columns-1.0 ?\n    (double) image->columns-1.0 : bounds.x2;\n  bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double) image->rows-1.0 ?\n    (double) image->rows-1.0 : bounds.y2;\n  poly_extent.x1=CastDoubleToLong(ceil(bounds.x1-0.5));\n  poly_extent.y1=CastDoubleToLong(ceil(bounds.y1-0.5));\n  poly_extent.x2=CastDoubleToLong(floor(bounds.x2+0.5));\n  poly_extent.y2=CastDoubleToLong(floor(bounds.y2+0.5));\n  number_threads=GetMagickNumberThreads(image,image,poly_extent.y2-\n    poly_extent.y1+1,1);\n  status=ClonePolygonEdgesTLS(polygon_info,number_threads,exception);\n  if (status == MagickFalse)\n    {\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      return(status);\n    }\n  image_view=AcquireAuthenticCacheView(image,exception);\n  if ((primitive_info->coordinates == 1) ||\n      (polygon_info[0]->number_edges == 0))\n    {\n      /*\n        Draw point.\n      */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        num_threads(number_threads)\n#endif\n      for (y=poly_extent.y1; y <= poly_extent.y2; y++)\n      {\n        PixelInfo\n          pixel;\n\n        ssize_t\n          x;\n\n        Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        x=poly_extent.x1;\n        q=GetCacheViewAuthenticPixels(image_view,x,y,(size_t) (poly_extent.x2-\n          x+1),1,exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        GetPixelInfo(image,&pixel);\n        for ( ; x <= poly_extent.x2; x++)\n        {\n          if ((x == CastDoubleToLong(ceil(primitive_info->point.x-0.5))) &&\n              (y == CastDoubleToLong(ceil(primitive_info->point.y-0.5))))\n            {\n              GetFillColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&pixel,\n                exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n            }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      polygon_info=DestroyPolygonTLS(polygon_info);\n      if (draw_info->debug != MagickFalse)\n        (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n          \"    end draw-polygon\");\n      return(status);\n    }\n  /*\n    Draw polygon or line.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    num_threads(number_threads)\n#endif\n  for (y=poly_extent.y1; y <= poly_extent.y2; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,poly_extent.x1,y,(size_t)\n      (poly_extent.x2-poly_extent.x1+1),1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=poly_extent.x1; x <= poly_extent.x2; x++)\n    {\n      double\n        fill_alpha,\n        stroke_alpha;\n\n      PixelInfo\n        fill_color,\n        stroke_color;\n\n      /*\n        Fill and/or stroke.\n      */\n      fill_alpha=GetFillAlpha(polygon_info[id],mid,fill,draw_info->fill_rule,\n        x,y,&stroke_alpha);\n      if (draw_info->stroke_antialias == MagickFalse)\n        {\n          fill_alpha=fill_alpha >= AntialiasThreshold ? 1.0 : 0.0;\n          stroke_alpha=stroke_alpha >= AntialiasThreshold ? 1.0 : 0.0;\n        }\n      GetFillColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&fill_color,\n        exception);\n      CompositePixelOver(image,&fill_color,fill_alpha*fill_color.alpha,q,\n        (double) GetPixelAlpha(image,q),q);\n      GetStrokeColor(draw_info,x-poly_extent.x1,y-poly_extent.y1,&stroke_color,\n        exception);\n      CompositePixelOver(image,&stroke_color,stroke_alpha*stroke_color.alpha,q,\n        (double) GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  polygon_info=DestroyPolygonTLS(polygon_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-polygon\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D r a w P r i m i t i v e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawPrimitive() draws a primitive (line, rectangle, ellipse) on the image.\n%\n%  The format of the DrawPrimitive method is:\n%\n%      MagickBooleanType DrawPrimitive(Image *image,const DrawInfo *draw_info,\n%        PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic void LogPrimitiveInfo(const PrimitiveInfo *primitive_info)\n{\n  const char\n    *methods[] =\n    {\n      \"point\",\n      \"replace\",\n      \"floodfill\",\n      \"filltoborder\",\n      \"reset\",\n      \"?\"\n    };\n\n  PointInfo\n    p,\n    point,\n    q;\n\n  ssize_t\n    i,\n    x;\n\n  ssize_t\n    coordinates,\n    y;\n\n  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));\n  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"AlphaPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case ColorPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"ColorPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case ImagePrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"ImagePrimitive %.20g,%.20g\",(double) x,(double) y);\n      return;\n    }\n    case PointPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"PointPrimitive %.20g,%.20g %s\",(double) x,(double) y,\n        methods[primitive_info->method]);\n      return;\n    }\n    case TextPrimitive:\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"TextPrimitive %.20g,%.20g\",(double) x,(double) y);\n      return;\n    }\n    default:\n      break;\n  }\n  coordinates=0;\n  p=primitive_info[0].point;\n  q.x=(-1.0);\n  q.y=(-1.0);\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)\n  {\n    point=primitive_info[i].point;\n    if (coordinates <= 0)\n      {\n        coordinates=(ssize_t) primitive_info[i].coordinates;\n        (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n          \"    begin open (%.20g)\",(double) coordinates);\n        p=point;\n      }\n    point=primitive_info[i].point;\n    if ((fabs(q.x-point.x) >= MagickEpsilon) ||\n        (fabs(q.y-point.y) >= MagickEpsilon))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"      %.20g: %.18g,%.18g\",(double) coordinates,point.x,point.y);\n    else\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"      %.20g: %g %g (duplicate)\",(double) coordinates,point.x,point.y);\n    q=point;\n    coordinates--;\n    if (coordinates > 0)\n      continue;\n    if ((fabs(p.x-point.x) >= MagickEpsilon) ||\n        (fabs(p.y-point.y) >= MagickEpsilon))\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end last (%.20g)\",\n        (double) coordinates);\n    else\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end open (%.20g)\",\n        (double) coordinates);\n  }\n}\n\nMagickExport MagickBooleanType DrawPrimitive(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  if (draw_info->debug != MagickFalse)\n    {\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"  begin draw-primitive\");\n      (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n        \"    affine: %g,%g,%g,%g,%g,%g\",draw_info->affine.sx,\n        draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,\n        draw_info->affine.tx,draw_info->affine.ty);\n    }\n  status=MagickTrue;\n  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&\n      ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||\n       (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))\n    status&=SetImageColorspace(image,sRGBColorspace,exception);\n  if (draw_info->compliance == SVGCompliance)\n    {\n      status&=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,\n        exception);\n      status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,\n        exception);\n    }\n  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));\n  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));\n  image_view=AcquireAuthenticCacheView(image,exception);\n  switch (primitive_info->primitive)\n  {\n    case AlphaPrimitive:\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status&=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      switch (primitive_info->method)\n      {\n        case PointMethod:\n        default:\n        {\n          PixelInfo\n            pixel;\n\n          Quantum\n            *q;\n\n          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          GetFillColor(draw_info,x,y,&pixel,exception);\n          SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n          status&=SyncCacheViewAuthenticPixels(image_view,exception);\n          break;\n        }\n        case ReplaceMethod:\n        {\n          PixelInfo\n            pixel,\n            target;\n\n          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,\n            exception);\n          GetPixelInfo(image,&pixel);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetPixelInfoPixel(image,q,&pixel);\n              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)\n                {\n                  q+=GetPixelChannels(image);\n                  continue;\n                }\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n        case FloodfillMethod:\n        case FillToBorderMethod:\n        {\n          ChannelType\n            channel_mask;\n\n          PixelInfo\n            target;\n\n          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,\n            &target,exception);\n          if (primitive_info->method == FillToBorderMethod)\n            {\n              target.red=(double) draw_info->border_color.red;\n              target.green=(double) draw_info->border_color.green;\n              target.blue=(double) draw_info->border_color.blue;\n            }\n          channel_mask=SetImageChannelMask(image,AlphaChannel);\n          status&=FloodfillPaintImage(image,draw_info,&target,x,y,\n            primitive_info->method == FloodfillMethod ? MagickFalse :\n            MagickTrue,exception);\n          (void) SetImageChannelMask(image,channel_mask);\n          break;\n        }\n        case ResetMethod:\n        {\n          PixelInfo\n            pixel;\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ColorPrimitive:\n    {\n      switch (primitive_info->method)\n      {\n        case PointMethod:\n        default:\n        {\n          PixelInfo\n            pixel;\n\n          Quantum\n            *q;\n\n          q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          GetPixelInfo(image,&pixel);\n          GetFillColor(draw_info,x,y,&pixel,exception);\n          SetPixelViaPixelInfo(image,&pixel,q);\n          status&=SyncCacheViewAuthenticPixels(image_view,exception);\n          break;\n        }\n        case ReplaceMethod:\n        {\n          PixelInfo\n            pixel,\n            target;\n\n          status&=GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,\n            exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetPixelInfoPixel(image,q,&pixel);\n              if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)\n                {\n                  q+=GetPixelChannels(image);\n                  continue;\n                }\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n        case FloodfillMethod:\n        case FillToBorderMethod:\n        {\n          PixelInfo\n            target;\n\n          status&=GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,\n            &target,exception);\n          if (primitive_info->method == FillToBorderMethod)\n            {\n              target.red=(double) draw_info->border_color.red;\n              target.green=(double) draw_info->border_color.green;\n              target.blue=(double) draw_info->border_color.blue;\n            }\n          status&=FloodfillPaintImage(image,draw_info,&target,x,y,\n            primitive_info->method == FloodfillMethod ? MagickFalse :\n            MagickTrue,exception);\n          break;\n        }\n        case ResetMethod:\n        {\n          PixelInfo\n            pixel;\n\n          GetPixelInfo(image,&pixel);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            Quantum\n              *magick_restrict q;\n\n            q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              GetFillColor(draw_info,x,y,&pixel,exception);\n              SetPixelViaPixelInfo(image,&pixel,q);\n              q+=GetPixelChannels(image);\n            }\n            status&=SyncCacheViewAuthenticPixels(image_view,exception);\n            if (status == MagickFalse)\n              break;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ImagePrimitive:\n    {\n      AffineMatrix\n        affine;\n\n      char\n        composite_geometry[MagickPathExtent];\n\n      Image\n        *composite_image,\n        *composite_images;\n\n      ImageInfo\n        *clone_info;\n\n      RectangleInfo\n        geometry;\n\n      ssize_t\n        x1,\n        y1;\n\n      if (primitive_info->text == (char *) NULL)\n        break;\n      clone_info=AcquireImageInfo();\n      clone_info->recursion_depth=draw_info->image_info->recursion_depth;\n      composite_images=(Image *) NULL;\n      if (LocaleNCompare(primitive_info->text,\"data:\",5) == 0)\n        composite_images=ReadInlineImage(clone_info,primitive_info->text,\n          exception);\n      else\n        if (*primitive_info->text != '\\0')\n          {\n            MagickBooleanType\n              path_status;\n\n            struct stat\n              attributes;\n\n            /*\n              Read composite image.\n            */\n            (void) CopyMagickString(clone_info->filename,primitive_info->text,\n              MagickPathExtent);\n            (void) SetImageInfo(clone_info,1,exception);\n            (void) CopyMagickString(clone_info->filename,primitive_info->text,\n              MagickPathExtent);\n            if (clone_info->size != (char *) NULL)\n              clone_info->size=DestroyString(clone_info->size);\n            if (clone_info->extract != (char *) NULL)\n              clone_info->extract=DestroyString(clone_info->extract);\n            path_status=GetPathAttributes(clone_info->filename,&attributes);\n            if (path_status != MagickFalse)\n              {\n                if (S_ISCHR(attributes.st_mode) == 0)\n                  composite_images=ReadImage(clone_info,exception);\n                else\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    FileOpenError,\"UnableToOpenFile\",\"`%s'\",\n                      clone_info->filename);\n              }\n            else\n              if ((LocaleCompare(clone_info->magick,\"ftp\") != 0) &&\n                  (LocaleCompare(clone_info->magick,\"http\") != 0) &&\n                  (LocaleCompare(clone_info->magick,\"https\") != 0))\n                composite_images=ReadImage(clone_info,exception);\n              else\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  FileOpenError,\"UnableToOpenFile\",\"`%s'\",clone_info->filename);\n          }\n      clone_info=DestroyImageInfo(clone_info);\n      if (composite_images == (Image *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      composite_image=RemoveFirstImageFromList(&composite_images);\n      composite_images=DestroyImageList(composite_images);\n      (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)\n        NULL,(void *) NULL);\n      x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));\n      y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));\n      if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||\n          ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))\n        {\n          /*\n            Resize image.\n          */\n          (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n            \"%gx%g!\",primitive_info[1].point.x,primitive_info[1].point.y);\n          composite_image->filter=image->filter;\n          status&=TransformImage(&composite_image,(char *) NULL,\n            composite_geometry,exception);\n        }\n      if (composite_image->alpha_trait == UndefinedPixelTrait)\n        status&=SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,\n          exception);\n      if (draw_info->alpha != OpaqueAlpha)\n        status&=SetImageAlpha(composite_image,draw_info->alpha,exception);\n      SetGeometry(image,&geometry);\n      image->gravity=draw_info->gravity;\n      geometry.x=x;\n      geometry.y=y;\n      (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) composite_image->columns,(double)\n        composite_image->rows,(double) geometry.x,(double) geometry.y);\n      (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);\n      affine=draw_info->affine;\n      affine.tx=(double) geometry.x;\n      affine.ty=(double) geometry.y;\n      composite_image->interpolate=image->interpolate;\n      if ((draw_info->compose == OverCompositeOp) ||\n          (draw_info->compose == SrcOverCompositeOp))\n        status&=DrawAffineImage(image,composite_image,&affine,exception);\n      else\n        status&=CompositeImage(image,composite_image,draw_info->compose,\n          MagickTrue,geometry.x,geometry.y,exception);\n      composite_image=DestroyImage(composite_image);\n      break;\n    }\n    case PointPrimitive:\n    {\n      PixelInfo\n        fill_color;\n\n      Quantum\n        *q;\n\n      if ((y < 0) || (y >= (ssize_t) image->rows))\n        break;\n      if ((x < 0) || (x >= (ssize_t) image->columns))\n        break;\n      q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      GetFillColor(draw_info,x,y,&fill_color,exception);\n      CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      status&=SyncCacheViewAuthenticPixels(image_view,exception);\n      break;\n    }\n    case TextPrimitive:\n    {\n      char\n        geometry[MagickPathExtent];\n\n      DrawInfo\n        *clone_info;\n\n      if (primitive_info->text == (char *) NULL)\n        break;\n      clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n      (void) CloneString(&clone_info->text,primitive_info->text);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n        primitive_info->point.x,primitive_info->point.y);\n      (void) CloneString(&clone_info->geometry,geometry);\n      status&=AnnotateImage(image,clone_info,exception);\n      clone_info=DestroyDrawInfo(clone_info);\n      break;\n    }\n    default:\n    {\n      double\n        mid,\n        scale;\n\n      DrawInfo\n        *clone_info;\n\n      if (IsEventLogging() != MagickFalse)\n        LogPrimitiveInfo(primitive_info);\n      scale=ExpandAffine(&draw_info->affine);\n      if ((draw_info->dash_pattern != (double *) NULL) &&\n          (fabs(draw_info->dash_pattern[0]) >= MagickEpsilon) &&\n          (fabs(scale*draw_info->stroke_width) >= MagickEpsilon) &&\n          (draw_info->stroke.alpha != (Quantum) TransparentAlpha))\n        {\n          /*\n            Draw dash polygon.\n          */\n          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n          clone_info->stroke_width=0.0;\n          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,\n            exception);\n          clone_info=DestroyDrawInfo(clone_info);\n          if (status != MagickFalse)\n            status&=DrawDashPolygon(draw_info,primitive_info,image,exception);\n          break;\n        }\n      mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n      if ((mid > 1.0) &&\n          ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||\n           (draw_info->stroke_pattern != (Image *) NULL)))\n        {\n          double\n            point_x,\n            point_y;\n\n          MagickBooleanType\n            closed_path;\n\n          /*\n            Draw strokes while respecting line cap/join attributes.\n          */\n          closed_path=primitive_info[0].closed_subpath;\n          i=(ssize_t) primitive_info[0].coordinates;\n          point_x=fabs(primitive_info[i-1].point.x-primitive_info[0].point.x);\n          point_y=fabs(primitive_info[i-1].point.y-primitive_info[0].point.y);\n          if ((point_x < MagickEpsilon) && (point_y < MagickEpsilon))\n            closed_path=MagickTrue;\n          if ((((draw_info->linecap == RoundCap) ||\n                (closed_path != MagickFalse)) &&\n               (draw_info->linejoin == RoundJoin)) ||\n               (primitive_info[i].primitive != UndefinedPrimitive))\n            {\n              status&=DrawPolygonPrimitive(image,draw_info,primitive_info,\n                exception);\n              break;\n            }\n          clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n          clone_info->stroke_width=0.0;\n          clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n          status&=DrawPolygonPrimitive(image,clone_info,primitive_info,\n            exception);\n          clone_info=DestroyDrawInfo(clone_info);\n          if (status != MagickFalse)\n            status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);\n          break;\n        }\n      status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);\n      break;\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (draw_info->compliance == SVGCompliance)\n    {\n      status&=SetImageMask(image,WritePixelMask,(Image *) NULL,exception);\n      status&=SetImageMask(image,CompositePixelMask,(Image *) NULL,exception);\n    }\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  end draw-primitive\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D r a w S t r o k e P o l y g o n                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DrawStrokePolygon() draws a stroked polygon (line, rectangle, ellipse) on\n%  the image while respecting the line cap and join attributes.\n%\n%  The format of the DrawStrokePolygon method is:\n%\n%      MagickBooleanType DrawStrokePolygon(Image *image,\n%        const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.\n%\n%\n*/\n\nstatic MagickBooleanType DrawRoundLinecap(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  PrimitiveInfo\n    linecap[5];\n\n  ssize_t\n    i;\n\n  for (i=0; i < 4; i++)\n    linecap[i]=(*primitive_info);\n  linecap[0].coordinates=4;\n  linecap[1].point.x+=2.0*MagickEpsilon;\n  linecap[2].point.x+=2.0*MagickEpsilon;\n  linecap[2].point.y+=2.0*MagickEpsilon;\n  linecap[3].point.y+=2.0*MagickEpsilon;\n  linecap[4].primitive=UndefinedPrimitive;\n  return(DrawPolygonPrimitive(image,draw_info,linecap,exception));\n}\n\nstatic MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  MagickBooleanType\n    closed_path;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *stroke_polygon;\n\n  const PrimitiveInfo\n    *p,\n    *q;\n\n  /*\n    Draw stroked polygon.\n  */\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    if (p->coordinates == 1)\n      continue;\n    stroke_polygon=TraceStrokePolygon(draw_info,p,exception);\n    if (stroke_polygon == (PrimitiveInfo *) NULL)\n      {\n        status=0;\n        break;\n      }\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    if (status == 0)\n      break;\n    q=p+p->coordinates-1;\n    closed_path=p->closed_subpath;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        status&=DrawRoundLinecap(image,draw_info,p,exception);\n        status&=DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (draw_info->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A f f i n e M a t r i x                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAffineMatrix() returns an AffineMatrix initialized to the identity\n%  matrix.\n%\n%  The format of the GetAffineMatrix method is:\n%\n%      void GetAffineMatrix(AffineMatrix *affine_matrix)\n%\n%  A description of each parameter follows:\n%\n%    o affine_matrix: the affine matrix.\n%\n*/\nMagickExport void GetAffineMatrix(AffineMatrix *affine_matrix)\n{\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(affine_matrix != (AffineMatrix *) NULL);\n  (void) memset(affine_matrix,0,sizeof(*affine_matrix));\n  affine_matrix->sx=1.0;\n  affine_matrix->sy=1.0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t D r a w I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetDrawInfo() initializes draw_info to default values from image_info.\n%\n%  The format of the GetDrawInfo method is:\n%\n%      void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o draw_info: the draw info.\n%\n*/\nMagickExport void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)\n{\n  char\n    *next_token;\n\n  const char\n    *option;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    Initialize draw attributes.\n  */\n  assert(draw_info != (DrawInfo *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  (void) memset(draw_info,0,sizeof(*draw_info));\n  draw_info->image_info=CloneImageInfo(image_info);\n  GetAffineMatrix(&draw_info->affine);\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(\"#000F\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#FFF0\",AllCompliance,&draw_info->stroke,\n    exception);\n  draw_info->stroke_antialias=draw_info->image_info->antialias;\n  draw_info->stroke_width=1.0;\n  draw_info->fill_rule=EvenOddRule;\n  draw_info->alpha=OpaqueAlpha;\n  draw_info->fill_alpha=OpaqueAlpha;\n  draw_info->stroke_alpha=OpaqueAlpha;\n  draw_info->linecap=ButtCap;\n  draw_info->linejoin=MiterJoin;\n  draw_info->miterlimit=10;\n  draw_info->decorate=NoDecoration;\n  draw_info->pointsize=12.0;\n  draw_info->undercolor.alpha=(MagickRealType) TransparentAlpha;\n  draw_info->compose=OverCompositeOp;\n  draw_info->render=MagickTrue;\n  draw_info->clip_path=MagickFalse;\n  draw_info->debug=(GetLogEventMask() & (DrawEvent | AnnotateEvent)) != 0 ?\n    MagickTrue : MagickFalse;\n  if (draw_info->image_info->font != (char *) NULL)\n    draw_info->font=AcquireString(draw_info->image_info->font);\n  if (draw_info->image_info->density != (char *) NULL)\n    draw_info->density=AcquireString(draw_info->image_info->density);\n  draw_info->text_antialias=draw_info->image_info->antialias;\n  if (fabs(draw_info->image_info->pointsize) >= MagickEpsilon)\n    draw_info->pointsize=draw_info->image_info->pointsize;\n  draw_info->border_color=draw_info->image_info->border_color;\n  if (draw_info->image_info->server_name != (char *) NULL)\n    draw_info->server_name=AcquireString(draw_info->image_info->server_name);\n  option=GetImageOption(draw_info->image_info,\"direction\");\n  if (option != (const char *) NULL)\n    draw_info->direction=(DirectionType) ParseCommandOption(\n      MagickDirectionOptions,MagickFalse,option);\n  else\n    draw_info->direction=UndefinedDirection;\n  option=GetImageOption(draw_info->image_info,\"encoding\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->encoding,option);\n  option=GetImageOption(draw_info->image_info,\"family\");\n  if (option != (const char *) NULL)\n    (void) CloneString(&draw_info->family,option);\n  option=GetImageOption(draw_info->image_info,\"fill\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->fill,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(draw_info->image_info,\"interline-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interline_spacing=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"interword-spacing\");\n  if (option != (const char *) NULL)\n    draw_info->interword_spacing=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"kerning\");\n  if (option != (const char *) NULL)\n    draw_info->kerning=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"stroke\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->stroke,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"strokewidth\");\n  if (option != (const char *) NULL)\n    draw_info->stroke_width=GetDrawValue(option,&next_token);\n  option=GetImageOption(draw_info->image_info,\"style\");\n  if (option != (const char *) NULL)\n    draw_info->style=(StyleType) ParseCommandOption(MagickStyleOptions,\n      MagickFalse,option);\n  option=GetImageOption(draw_info->image_info,\"undercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&draw_info->undercolor,\n      exception);\n  option=GetImageOption(draw_info->image_info,\"weight\");\n  if (option != (const char *) NULL)\n    {\n      ssize_t\n        weight;\n\n      weight=ParseCommandOption(MagickWeightOptions,MagickFalse,option);\n      if (weight == -1)\n        weight=(ssize_t) StringToUnsignedLong(option);\n      draw_info->weight=(size_t) weight;\n    }\n  option=GetImageOption(draw_info->image_info,\"word-break\");\n  if (option != (const char *) NULL)\n    draw_info->word_break=(WordBreakType) ParseCommandOption(\n      MagickWordBreakOptions,MagickFalse,option);\n  exception=DestroyExceptionInfo(exception);\n  draw_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r m u t a t e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Permutate() returns the permutation of the (n,k).\n%\n%  The format of the Permutate method is:\n%\n%      void Permutate(ssize_t n,ssize_t k)\n%\n%  A description of each parameter follows:\n%\n%    o n:\n%\n%    o k:\n%\n%\n*/\nstatic inline double Permutate(const ssize_t n,const ssize_t k)\n{\n  double\n    r;\n\n  ssize_t\n    i;\n\n  r=1.0;\n  for (i=k+1; i <= n; i++)\n    r*=i;\n  for (i=1; i <= (n-k); i++)\n    r/=i;\n  return(r);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   T r a c e P r i m i t i v e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TracePrimitive is a collection of methods for generating graphic\n%  primitives such as arcs, ellipses, paths, etc.\n%\n*/\n\nstatic MagickBooleanType TraceArc(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end,const PointInfo degrees)\n{\n  PointInfo\n    center,\n    radius;\n\n  center.x=0.5*(end.x+start.x);\n  center.y=0.5*(end.y+start.y);\n  radius.x=fabs(center.x-start.x);\n  radius.y=fabs(center.y-start.y);\n  return(TraceEllipse(mvg_info,center,radius,degrees));\n}\n\nstatic MagickBooleanType TraceArcPath(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end,const PointInfo arc,const double angle,\n  const MagickBooleanType large_arc,const MagickBooleanType sweep)\n{\n  double\n    alpha,\n    beta,\n    delta,\n    factor,\n    gamma,\n    theta;\n\n  MagickStatusType\n    status;\n\n  PointInfo\n    center,\n    points[3],\n    radii;\n\n  double\n    cosine,\n    sine;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    arc_segments;\n\n  ssize_t\n    offset;\n\n  offset=mvg_info->offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=0;\n  if ((fabs(start.x-end.x) < MagickEpsilon) &&\n      (fabs(start.y-end.y) < MagickEpsilon))\n    return(TracePoint(primitive_info,end));\n  radii.x=fabs(arc.x);\n  radii.y=fabs(arc.y);\n  if ((radii.x < MagickEpsilon) || (radii.y < MagickEpsilon))\n    return(TraceLine(primitive_info,start,end));\n  cosine=cos(DegreesToRadians(fmod((double) angle,360.0)));\n  sine=sin(DegreesToRadians(fmod((double) angle,360.0)));\n  center.x=(double) (cosine*(end.x-start.x)/2+sine*(end.y-start.y)/2);\n  center.y=(double) (cosine*(end.y-start.y)/2-sine*(end.x-start.x)/2);\n  delta=(center.x*center.x)/(radii.x*radii.x)+(center.y*center.y)/\n    (radii.y*radii.y);\n  if (delta < MagickEpsilon)\n    return(TraceLine(primitive_info,start,end));\n  if (delta > 1.0)\n    {\n      radii.x*=sqrt((double) delta);\n      radii.y*=sqrt((double) delta);\n    }\n  points[0].x=(double) (cosine*start.x/radii.x+sine*start.y/radii.x);\n  points[0].y=(double) (cosine*start.y/radii.y-sine*start.x/radii.y);\n  points[1].x=(double) (cosine*end.x/radii.x+sine*end.y/radii.x);\n  points[1].y=(double) (cosine*end.y/radii.y-sine*end.x/radii.y);\n  alpha=points[1].x-points[0].x;\n  beta=points[1].y-points[0].y;\n  if (fabs(alpha*alpha+beta*beta) < MagickEpsilon)\n    return(TraceLine(primitive_info,start,end));\n  factor=PerceptibleReciprocal(alpha*alpha+beta*beta)-0.25;\n  if (factor <= 0.0)\n    factor=0.0;\n  else\n    {\n      factor=sqrt((double) factor);\n      if (sweep == large_arc)\n        factor=(-factor);\n    }\n  center.x=(double) ((points[0].x+points[1].x)/2-factor*beta);\n  center.y=(double) ((points[0].y+points[1].y)/2+factor*alpha);\n  alpha=atan2(points[0].y-center.y,points[0].x-center.x);\n  theta=atan2(points[1].y-center.y,points[1].x-center.x)-alpha;\n  if ((theta < 0.0) && (sweep != MagickFalse))\n    theta+=2.0*MagickPI;\n  else\n    if ((theta > 0.0) && (sweep == MagickFalse))\n      theta-=2.0*MagickPI;\n  arc_segments=(size_t) CastDoubleToLong(ceil(fabs((double) (theta/(0.5*\n    MagickPI+MagickEpsilon)))));\n  status=MagickTrue;\n  p=primitive_info;\n  for (i=0; i < (ssize_t) arc_segments; i++)\n  {\n    beta=0.5*((alpha+(i+1)*theta/arc_segments)-(alpha+i*theta/arc_segments));\n    gamma=(8.0/3.0)*sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))*\n      sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))/\n      sin(fmod((double) beta,DegreesToRadians(360.0)));\n    points[0].x=(double) (center.x+cos(fmod((double) (alpha+(double) i*theta/\n      arc_segments),DegreesToRadians(360.0)))-gamma*sin(fmod((double) (alpha+\n      (double) i*theta/arc_segments),DegreesToRadians(360.0))));\n    points[0].y=(double) (center.y+sin(fmod((double) (alpha+(double) i*theta/\n      arc_segments),DegreesToRadians(360.0)))+gamma*cos(fmod((double) (alpha+\n      (double) i*theta/arc_segments),DegreesToRadians(360.0))));\n    points[2].x=(double) (center.x+cos(fmod((double) (alpha+(double) (i+1)*\n      theta/arc_segments),DegreesToRadians(360.0))));\n    points[2].y=(double) (center.y+sin(fmod((double) (alpha+(double) (i+1)*\n      theta/arc_segments),DegreesToRadians(360.0))));\n    points[1].x=(double) (points[2].x+gamma*sin(fmod((double) (alpha+(double)\n      (i+1)*theta/arc_segments),DegreesToRadians(360.0))));\n    points[1].y=(double) (points[2].y-gamma*cos(fmod((double) (alpha+(double)\n      (i+1)*theta/arc_segments),DegreesToRadians(360.0))));\n    p->point.x=(p == primitive_info) ? start.x : (p-1)->point.x;\n    p->point.y=(p == primitive_info) ? start.y : (p-1)->point.y;\n    (p+1)->point.x=(double) (cosine*radii.x*points[0].x-sine*radii.y*\n      points[0].y);\n    (p+1)->point.y=(double) (sine*radii.x*points[0].x+cosine*radii.y*\n      points[0].y);\n    (p+2)->point.x=(double) (cosine*radii.x*points[1].x-sine*radii.y*\n      points[1].y);\n    (p+2)->point.y=(double) (sine*radii.x*points[1].x+cosine*radii.y*\n      points[1].y);\n    (p+3)->point.x=(double) (cosine*radii.x*points[2].x-sine*radii.y*\n      points[2].y);\n    (p+3)->point.y=(double) (sine*radii.x*points[2].x+cosine*radii.y*\n      points[2].y);\n    if (i == (ssize_t) (arc_segments-1))\n      (p+3)->point=end;\n    status&=TraceBezier(mvg_info,4);\n    if (status == 0)\n      break;\n    p=(*mvg_info->primitive_info)+mvg_info->offset;\n    mvg_info->offset+=p->coordinates;\n    p+=p->coordinates;\n  }\n  if (status == 0)\n    return(MagickFalse);\n  mvg_info->offset=offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) MAGICK_SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) MAGICK_SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,(double) control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceCircle(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end)\n{\n  double\n    alpha,\n    beta,\n    radius;\n\n  PointInfo\n    offset,\n    degrees;\n\n  alpha=end.x-start.x;\n  beta=end.y-start.y;\n  radius=hypot((double) alpha,(double) beta);\n  offset.x=(double) radius;\n  offset.y=(double) radius;\n  degrees.x=0.0;\n  degrees.y=360.0;\n  return(TraceEllipse(mvg_info,start,offset,degrees));\n}\n\nstatic MagickBooleanType TraceEllipse(MVGInfo *mvg_info,const PointInfo center,\n  const PointInfo radii,const PointInfo arc)\n{\n  double\n    coordinates,\n    delta,\n    step,\n    x,\n    y;\n\n  PointInfo\n    angle,\n    point;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  /*\n    Ellipses are just short segmented polys.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  primitive_info->coordinates=0;\n  if ((fabs(radii.x) < MagickEpsilon) || (fabs(radii.y) < MagickEpsilon))\n    return(MagickTrue);\n  delta=2.0*PerceptibleReciprocal(MagickMax(radii.x,radii.y));\n  step=MagickPI/8.0;\n  if ((delta >= 0.0) && (delta < (MagickPI/8.0)))\n    step=MagickPI/4.0/(MagickPI*PerceptibleReciprocal(delta)/2.0);\n  angle.x=DegreesToRadians(arc.x);\n  y=arc.y;\n  while (y < arc.x)\n    y+=360.0;\n  angle.y=DegreesToRadians(y);\n  coordinates=ceil((angle.y-angle.x)/step+1.0);\n  if (CheckPrimitiveExtent(mvg_info,coordinates) == MagickFalse)\n    return(MagickFalse);\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  for (p=primitive_info; angle.x < angle.y; angle.x+=step)\n  {\n    point.x=cos(fmod(angle.x,DegreesToRadians(360.0)))*radii.x+center.x;\n    point.y=sin(fmod(angle.x,DegreesToRadians(360.0)))*radii.y+center.y;\n    if (TracePoint(p,point) == MagickFalse)\n      return(MagickFalse);\n    p+=p->coordinates;\n  }\n  point.x=cos(fmod(angle.y,DegreesToRadians(360.0)))*radii.x+center.x;\n  point.y=sin(fmod(angle.y,DegreesToRadians(360.0)))*radii.y+center.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  x=fabs(primitive_info[0].point.x-\n    primitive_info[primitive_info->coordinates-1].point.x);\n  y=fabs(primitive_info[0].point.y-\n    primitive_info[primitive_info->coordinates-1].point.y);\n  if ((x < MagickEpsilon) && (y < MagickEpsilon))\n    primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceLine(PrimitiveInfo *primitive_info,\n  const PointInfo start,const PointInfo end)\n{\n  if (TracePoint(primitive_info,start) == MagickFalse)\n    return(MagickFalse);\n  if (TracePoint(primitive_info+1,end) == MagickFalse)\n    return(MagickFalse);\n  (primitive_info+1)->primitive=primitive_info->primitive;\n  primitive_info->coordinates=2;\n  primitive_info->closed_subpath=MagickFalse;\n  return(MagickTrue);\n}\n\nstatic ssize_t TracePath(MVGInfo *mvg_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    *next_token,\n    token[MagickPathExtent] = \"\";\n\n  const char\n    *p;\n\n  double\n    x,\n    y;\n\n  int\n    attribute,\n    last_attribute;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    end = {0.0, 0.0},\n    points[4] = { {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0} },\n    point = {0.0, 0.0},\n    start = {0.0, 0.0};\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveType\n    primitive_type;\n\n  PrimitiveInfo\n    *q;\n\n  ssize_t\n    i;\n\n  size_t\n    number_coordinates,\n    z_count;\n\n  ssize_t\n    subpath_offset;\n\n  subpath_offset=mvg_info->offset;\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  status=MagickTrue;\n  attribute=0;\n  number_coordinates=0;\n  z_count=0;\n  primitive_type=primitive_info->primitive;\n  q=primitive_info;\n  for (p=path; *p != '\\0'; )\n  {\n    if (status == MagickFalse)\n      break;\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == '\\0')\n      break;\n    last_attribute=attribute;\n    attribute=(int) (*p++);\n    switch (attribute)\n    {\n      case 'a':\n      case 'A':\n      {\n        double\n          angle = 0.0;\n\n        MagickBooleanType\n          large_arc = MagickFalse,\n          sweep = MagickFalse;\n\n        PointInfo\n          arc = {0.0, 0.0};\n\n        /*\n          Elliptical arc.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          arc.x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          arc.y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          angle=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          sweep=StringToLong(token) != 0 ? MagickTrue : MagickFalse;\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          end.x=(double) (attribute == (int) 'A' ? x : point.x+x);\n          end.y=(double) (attribute == (int) 'A' ? y : point.y+y);\n          if (TraceArcPath(mvg_info,point,end,arc,angle,large_arc,sweep) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'c':\n      case 'C':\n      {\n        /*\n          Cubic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=point;\n          for (i=1; i < 4; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            end.x=(double) (attribute == (int) 'C' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'C' ? y : point.y+y);\n            points[i]=end;\n          }\n          for (i=0; i < 4; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,4) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'H':\n      case 'h':\n      {\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'H' ? x: point.x+x);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'l':\n      case 'L':\n      {\n        /*\n          Line to.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'L' ? x : point.x+x);\n          point.y=(double) (attribute == (int) 'L' ? y : point.y+y);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'M':\n      case 'm':\n      {\n        /*\n          Move to.\n        */\n        if (mvg_info->offset != subpath_offset)\n          {\n            primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n            primitive_info->coordinates=(size_t) (q-primitive_info);\n            number_coordinates+=primitive_info->coordinates;\n            primitive_info=q;\n            subpath_offset=mvg_info->offset;\n          }\n        i=0;\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          x=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.x=(double) (attribute == (int) 'M' ? x : point.x+x);\n          point.y=(double) (attribute == (int) 'M' ? y : point.y+y);\n          if (i == 0)\n            start=point;\n          i++;\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'q':\n      case 'Q':\n      {\n        /*\n          Quadratic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=point;\n          for (i=1; i < 3; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (*p == ',')\n              p++;\n            end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);\n            points[i]=end;\n          }\n          for (i=0; i < 3; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,3) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 's':\n      case 'S':\n      {\n        /*\n          Cubic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=points[3];\n          points[1].x=2.0*points[3].x-points[2].x;\n          points[1].y=2.0*points[3].y-points[2].y;\n          for (i=2; i < 4; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            if (*p == ',')\n              p++;\n            end.x=(double) (attribute == (int) 'S' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'S' ? y : point.y+y);\n            points[i]=end;\n          }\n          if (strchr(\"CcSs\",last_attribute) == (char *) NULL)\n            {\n              points[0]=point;\n              points[1]=point;\n            }\n          for (i=0; i < 4; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,4) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          last_attribute=attribute;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 't':\n      case 'T':\n      {\n        /*\n          Quadratic B\u00e9zier curve.\n        */\n        do\n        {\n          points[0]=points[2];\n          points[1].x=2.0*points[2].x-points[1].x;\n          points[1].y=2.0*points[2].y-points[1].y;\n          for (i=2; i < 3; i++)\n          {\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            x=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n            if (*token == ',')\n              (void) GetNextToken(p,&p,MagickPathExtent,token);\n            y=GetDrawValue(token,&next_token);\n            if (token == next_token)\n              ThrowPointExpectedException(token,exception);\n            end.x=(double) (attribute == (int) 'T' ? x : point.x+x);\n            end.y=(double) (attribute == (int) 'T' ? y : point.y+y);\n            points[i]=end;\n          }\n          if (status == MagickFalse)\n            break;\n          if (strchr(\"QqTt\",last_attribute) == (char *) NULL)\n            {\n              points[0]=point;\n              points[1]=point;\n            }\n          for (i=0; i < 3; i++)\n            (q+i)->point=points[i];\n          if (TraceBezier(mvg_info,3) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          point=end;\n          last_attribute=attribute;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'v':\n      case 'V':\n      {\n        /*\n          Line to.\n        */\n        do\n        {\n          (void) GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == ',')\n            (void) GetNextToken(p,&p,MagickPathExtent,token);\n          y=GetDrawValue(token,&next_token);\n          if (token == next_token)\n            ThrowPointExpectedException(token,exception);\n          point.y=(double) (attribute == (int) 'V' ? y : point.y+y);\n          if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n            return(-1);\n          q=(*mvg_info->primitive_info)+mvg_info->offset;\n          if (TracePoint(q,point) == MagickFalse)\n            return(-1);\n          mvg_info->offset+=q->coordinates;\n          q+=q->coordinates;\n          while (isspace((int) ((unsigned char) *p)) != 0)\n            p++;\n          if (*p == ',')\n            p++;\n        } while (IsPoint(p) != MagickFalse);\n        break;\n      }\n      case 'z':\n      case 'Z':\n      {\n        /*\n          Close path.\n        */\n        point=start;\n        if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n          return(-1);\n        q=(*mvg_info->primitive_info)+mvg_info->offset;\n        if (TracePoint(q,point) == MagickFalse)\n          return(-1);\n        mvg_info->offset+=q->coordinates;\n        q+=q->coordinates;\n        primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n        primitive_info->coordinates=(size_t) (q-primitive_info);\n        primitive_info->closed_subpath=MagickTrue;\n        number_coordinates+=primitive_info->coordinates;\n        primitive_info=q;\n        subpath_offset=mvg_info->offset;\n        z_count++;\n        break;\n      }\n      default:\n      {\n        ThrowPointExpectedException(token,exception);\n        break;\n      }\n    }\n  }\n  if (status == MagickFalse)\n    return(-1);\n  primitive_info=(*mvg_info->primitive_info)+subpath_offset;\n  primitive_info->coordinates=(size_t) (q-primitive_info);\n  number_coordinates+=primitive_info->coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    q--;\n    q->primitive=primitive_type;\n    if (z_count > 1)\n      q->method=FillToBorderMethod;\n  }\n  q=primitive_info;\n  return((ssize_t) number_coordinates);\n}\n\nstatic MagickBooleanType TraceRectangle(PrimitiveInfo *primitive_info,\n  const PointInfo start,const PointInfo end)\n{\n  PointInfo\n    point;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  p=primitive_info;\n  if (TracePoint(p,start) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  point.x=start.x;\n  point.y=end.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  if (TracePoint(p,end) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  point.x=end.x;\n  point.y=start.y;\n  if (TracePoint(p,point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  if (TracePoint(p,start) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceRoundRectangle(MVGInfo *mvg_info,\n  const PointInfo start,const PointInfo end,PointInfo arc)\n{\n  PointInfo\n    degrees,\n    point,\n    segment;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  PrimitiveInfo\n    *p;\n\n  ssize_t\n    i;\n\n  ssize_t\n    offset;\n\n  offset=mvg_info->offset;\n  segment.x=fabs(end.x-start.x);\n  segment.y=fabs(end.y-start.y);\n  if ((segment.x < MagickEpsilon) || (segment.y < MagickEpsilon))\n    {\n      (*mvg_info->primitive_info+mvg_info->offset)->coordinates=0;\n      return(MagickTrue);\n    }\n  if (arc.x > (0.5*segment.x))\n    arc.x=0.5*segment.x;\n  if (arc.y > (0.5*segment.y))\n    arc.y=0.5*segment.y;\n  point.x=start.x+segment.x-arc.x;\n  point.y=start.y+arc.y;\n  degrees.x=270.0;\n  degrees.y=360.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+segment.x-arc.x;\n  point.y=start.y+segment.y-arc.y;\n  degrees.x=0.0;\n  degrees.y=90.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+arc.x;\n  point.y=start.y+segment.y-arc.y;\n  degrees.x=90.0;\n  degrees.y=180.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  point.x=start.x+arc.x;\n  point.y=start.y+arc.y;\n  degrees.x=180.0;\n  degrees.y=270.0;\n  if (TraceEllipse(mvg_info,point,arc,degrees) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  mvg_info->offset+=p->coordinates;\n  if (CheckPrimitiveExtent(mvg_info,PrimitiveExtentPad) == MagickFalse)\n    return(MagickFalse);\n  p=(*mvg_info->primitive_info)+mvg_info->offset;\n  if (TracePoint(p,(*mvg_info->primitive_info+offset)->point) == MagickFalse)\n    return(MagickFalse);\n  p+=p->coordinates;\n  mvg_info->offset=offset;\n  primitive_info=(*mvg_info->primitive_info)+offset;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickTrue;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceSquareLinecap(PrimitiveInfo *primitive_info,\n  const size_t number_vertices,const double offset)\n{\n  double\n    distance;\n\n  double\n    dx,\n    dy;\n\n  ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  dx=0.0;\n  dy=0.0;\n  for (i=1; i < (ssize_t) number_vertices; i++)\n  {\n    dx=primitive_info[0].point.x-primitive_info[i].point.x;\n    dy=primitive_info[0].point.y-primitive_info[i].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  if (i == (ssize_t) number_vertices)\n    i=(ssize_t) number_vertices-1L;\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[0].point.x=(double) (primitive_info[i].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[0].point.y=(double) (primitive_info[i].point.y+\n    dy*(distance+offset)/distance);\n  for (j=(ssize_t) number_vertices-2; j >= 0;  j--)\n  {\n    dx=primitive_info[number_vertices-1].point.x-primitive_info[j].point.x;\n    dy=primitive_info[number_vertices-1].point.y-primitive_info[j].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[number_vertices-1].point.x=(double) (primitive_info[j].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[number_vertices-1].point.y=(double) (primitive_info[j].point.y+\n    dy*(distance+offset)/distance);\n  return(MagickTrue);\n}\n\nstatic PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,ExceptionInfo *exception)\n{\n#define MaxStrokePad  (6*BezierQuantum+360)\n#define CheckPathExtent(pad_p,pad_q) \\\n{   \\\n  if ((pad_p) > MaxBezierCoordinates) \\\n    stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n  else \\\n    if ((ssize_t) (p+(pad_p)) >= (ssize_t) extent_p) \\\n      { \\\n        if (~extent_p < (pad_p)) \\\n          stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n        else \\\n          { \\\n            extent_p+=(pad_p); \\\n            stroke_p=(PointInfo *) ResizeQuantumMemory(stroke_p,extent_p+ \\\n              MaxStrokePad,sizeof(*stroke_p)); \\\n          } \\\n      } \\\n  if ((pad_q) > MaxBezierCoordinates) \\\n    stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n  else \\\n    if ((ssize_t) (q+(pad_q)) >= (ssize_t) extent_q) \\\n      { \\\n        if (~extent_q < (pad_q)) \\\n          stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n        else \\\n          { \\\n            extent_q+=(pad_q); \\\n            stroke_q=(PointInfo *) ResizeQuantumMemory(stroke_q,extent_q+ \\\n              MaxStrokePad,sizeof(*stroke_q)); \\\n          } \\\n      } \\\n  if ((stroke_p == (PointInfo *) NULL) || (stroke_q == (PointInfo *) NULL)) \\\n    { \\\n      if (stroke_p != (PointInfo *) NULL) \\\n        stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p); \\\n      if (stroke_q != (PointInfo *) NULL) \\\n        stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q); \\\n      polygon_primitive=(PrimitiveInfo *) \\\n        RelinquishMagickMemory(polygon_primitive); \\\n      (void) ThrowMagickException(exception,GetMagickModule(), \\\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\"); \\\n      return((PrimitiveInfo *) NULL); \\\n    } \\\n}\n\n  typedef struct _StrokeSegment\n  {\n    double\n      p,\n      q;\n  } StrokeSegment;\n\n  double\n    delta_theta,\n    dot_product,\n    mid,\n    miterlimit;\n\n  MagickBooleanType\n    closed_path;\n\n  PointInfo\n    box_p[5],\n    box_q[5],\n    center,\n    offset,\n    *stroke_p,\n    *stroke_q;\n\n  PrimitiveInfo\n    *polygon_primitive,\n    *stroke_polygon;\n\n  ssize_t\n    i;\n\n  size_t\n    arc_segments,\n    extent_p,\n    extent_q,\n    number_vertices;\n\n  ssize_t\n    j,\n    n,\n    p,\n    q;\n\n  StrokeSegment\n    dx = {0.0, 0.0},\n    dy = {0.0, 0.0},\n    inverse_slope = {0.0, 0.0},\n    slope = {0.0, 0.0},\n    theta = {0.0, 0.0};\n\n  /*\n    Allocate paths.\n  */\n  number_vertices=primitive_info->coordinates;\n  polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    number_vertices+2UL,sizeof(*polygon_primitive));\n  if (polygon_primitive == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PrimitiveInfo *) NULL);\n    }\n  (void) memcpy(polygon_primitive,primitive_info,(size_t) number_vertices*\n    sizeof(*polygon_primitive));\n  offset.x=primitive_info[number_vertices-1].point.x-primitive_info[0].point.x;\n  offset.y=primitive_info[number_vertices-1].point.y-primitive_info[0].point.y;\n  closed_path=(fabs(offset.x) < MagickEpsilon) &&\n    (fabs(offset.y) < MagickEpsilon) ?  MagickTrue : MagickFalse;\n  if (((draw_info->linejoin == RoundJoin) ||\n       (draw_info->linejoin == MiterJoin)) && (closed_path != MagickFalse))\n    {\n      polygon_primitive[number_vertices]=primitive_info[1];\n      number_vertices++;\n    }\n  polygon_primitive[number_vertices].primitive=UndefinedPrimitive;\n  /*\n    Compute the slope for the first line segment, p.\n  */\n  dx.p=0.0;\n  dy.p=0.0;\n  for (n=1; n < (ssize_t) number_vertices; n++)\n  {\n    dx.p=polygon_primitive[n].point.x-polygon_primitive[0].point.x;\n    dy.p=polygon_primitive[n].point.y-polygon_primitive[0].point.y;\n    if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))\n      break;\n  }\n  if (n == (ssize_t) number_vertices)\n    {\n      if ((draw_info->linecap != RoundCap) || (closed_path != MagickFalse))\n        {\n          /*\n            Zero length subpath.\n          */\n          stroke_polygon=(PrimitiveInfo *) AcquireCriticalMemory(\n            sizeof(*stroke_polygon));\n          stroke_polygon[0]=polygon_primitive[0];\n          stroke_polygon[0].coordinates=0;\n          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(\n            polygon_primitive);\n          return(stroke_polygon);\n        }\n      n=(ssize_t) number_vertices-1L;\n    }\n  extent_p=2*number_vertices;\n  extent_q=2*number_vertices;\n  stroke_p=(PointInfo *) AcquireQuantumMemory((size_t) extent_p+MaxStrokePad,\n    sizeof(*stroke_p));\n  stroke_q=(PointInfo *) AcquireQuantumMemory((size_t) extent_q+MaxStrokePad,\n    sizeof(*stroke_q));\n  if ((stroke_p == (PointInfo *) NULL) || (stroke_q == (PointInfo *) NULL))\n    {\n      if (stroke_p != (PointInfo *) NULL)\n        stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n      if (stroke_q != (PointInfo *) NULL)\n        stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n      polygon_primitive=(PrimitiveInfo *)\n        RelinquishMagickMemory(polygon_primitive);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return((PrimitiveInfo *) NULL);\n    }\n  slope.p=0.0;\n  inverse_slope.p=0.0;\n  if (fabs(dx.p) < MagickEpsilon)\n    {\n      if (dx.p >= 0.0)\n        slope.p=dy.p < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n      else\n        slope.p=dy.p < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n    }\n  else\n    if (fabs(dy.p) < MagickEpsilon)\n      {\n        if (dy.p >= 0.0)\n          inverse_slope.p=dx.p < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n        else\n          inverse_slope.p=dx.p < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n      }\n    else\n      {\n        slope.p=dy.p/dx.p;\n        inverse_slope.p=(-1.0*PerceptibleReciprocal(slope.p));\n      }\n  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;\n  miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);\n  if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))\n    (void) TraceSquareLinecap(polygon_primitive,number_vertices,mid);\n  offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));\n  offset.y=(double) (offset.x*inverse_slope.p);\n  if ((dy.p*offset.x-dx.p*offset.y) > 0.0)\n    {\n      box_p[0].x=polygon_primitive[0].point.x-offset.x;\n      box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;\n      box_p[1].x=polygon_primitive[n].point.x-offset.x;\n      box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;\n      box_q[0].x=polygon_primitive[0].point.x+offset.x;\n      box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;\n      box_q[1].x=polygon_primitive[n].point.x+offset.x;\n      box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;\n    }\n  else\n    {\n      box_p[0].x=polygon_primitive[0].point.x+offset.x;\n      box_p[0].y=polygon_primitive[0].point.y+offset.y;\n      box_p[1].x=polygon_primitive[n].point.x+offset.x;\n      box_p[1].y=polygon_primitive[n].point.y+offset.y;\n      box_q[0].x=polygon_primitive[0].point.x-offset.x;\n      box_q[0].y=polygon_primitive[0].point.y-offset.y;\n      box_q[1].x=polygon_primitive[n].point.x-offset.x;\n      box_q[1].y=polygon_primitive[n].point.y-offset.y;\n    }\n  /*\n    Create strokes for the line join attribute: bevel, miter, round.\n  */\n  p=0;\n  q=0;\n  stroke_q[p++]=box_q[0];\n  stroke_p[q++]=box_p[0];\n  for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)\n  {\n    /*\n      Compute the slope for this line segment, q.\n    */\n    dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;\n    dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;\n    dot_product=dx.q*dx.q+dy.q*dy.q;\n    if (dot_product < 0.25)\n      continue;\n    slope.q=0.0;\n    inverse_slope.q=0.0;\n    if (fabs(dx.q) < MagickEpsilon)\n      {\n        if (dx.q >= 0.0)\n          slope.q=dy.q < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n        else\n          slope.q=dy.q < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n      }\n    else\n      if (fabs(dy.q) < MagickEpsilon)\n        {\n          if (dy.q >= 0.0)\n            inverse_slope.q=dx.q < 0.0 ? -1.0/MagickEpsilon : 1.0/MagickEpsilon;\n          else\n            inverse_slope.q=dx.q < 0.0 ? 1.0/MagickEpsilon : -1.0/MagickEpsilon;\n        }\n      else\n        {\n          slope.q=dy.q/dx.q;\n          inverse_slope.q=(-1.0*PerceptibleReciprocal(slope.q));\n        }\n    offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));\n    offset.y=(double) (offset.x*inverse_slope.q);\n    dot_product=dy.q*offset.x-dx.q*offset.y;\n    if (dot_product > 0.0)\n      {\n        box_p[2].x=polygon_primitive[n].point.x-offset.x;\n        box_p[2].y=polygon_primitive[n].point.y-offset.y;\n        box_p[3].x=polygon_primitive[i].point.x-offset.x;\n        box_p[3].y=polygon_primitive[i].point.y-offset.y;\n        box_q[2].x=polygon_primitive[n].point.x+offset.x;\n        box_q[2].y=polygon_primitive[n].point.y+offset.y;\n        box_q[3].x=polygon_primitive[i].point.x+offset.x;\n        box_q[3].y=polygon_primitive[i].point.y+offset.y;\n      }\n    else\n      {\n        box_p[2].x=polygon_primitive[n].point.x+offset.x;\n        box_p[2].y=polygon_primitive[n].point.y+offset.y;\n        box_p[3].x=polygon_primitive[i].point.x+offset.x;\n        box_p[3].y=polygon_primitive[i].point.y+offset.y;\n        box_q[2].x=polygon_primitive[n].point.x-offset.x;\n        box_q[2].y=polygon_primitive[n].point.y-offset.y;\n        box_q[3].x=polygon_primitive[i].point.x-offset.x;\n        box_q[3].y=polygon_primitive[i].point.y-offset.y;\n      }\n    if (fabs((double) (slope.p-slope.q)) < MagickEpsilon)\n      {\n        box_p[4]=box_p[1];\n        box_q[4]=box_q[1];\n      }\n    else\n      {\n        box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+\n          box_p[3].y)/(slope.p-slope.q));\n        box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);\n        box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+\n          box_q[3].y)/(slope.p-slope.q));\n        box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);\n      }\n    DisableMSCWarning(4127)\n    CheckPathExtent(MaxStrokePad,MaxStrokePad);\n    RestoreMSCWarning\n    dot_product=dx.q*dy.p-dx.p*dy.q;\n    if (dot_product <= 0.0)\n      switch (draw_info->linejoin)\n      {\n        case BevelJoin:\n        {\n          stroke_q[q++]=box_q[1];\n          stroke_q[q++]=box_q[2];\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_p[p++]=box_p[4];\n          else\n            {\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case MiterJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            {\n              stroke_q[q++]=box_q[4];\n              stroke_p[p++]=box_p[4];\n            }\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case RoundJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_p[p++]=box_p[4];\n          else\n            {\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          center=polygon_primitive[n].point;\n          theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);\n          theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);\n          if (theta.q < theta.p)\n            theta.q+=2.0*MagickPI;\n          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.q-\n            theta.p)/(2.0*sqrt(PerceptibleReciprocal(mid))))));\n          DisableMSCWarning(4127)\n          CheckPathExtent(MaxStrokePad,arc_segments+MaxStrokePad);\n          RestoreMSCWarning\n          stroke_q[q].x=box_q[1].x;\n          stroke_q[q].y=box_q[1].y;\n          q++;\n          for (j=1; j < (ssize_t) arc_segments; j++)\n          {\n            delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);\n            stroke_q[q].x=(double) (center.x+mid*cos(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            stroke_q[q].y=(double) (center.y+mid*sin(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            q++;\n          }\n          stroke_q[q++]=box_q[2];\n          break;\n        }\n        default:\n          break;\n      }\n    else\n      switch (draw_info->linejoin)\n      {\n        case BevelJoin:\n        {\n          stroke_p[p++]=box_p[1];\n          stroke_p[p++]=box_p[2];\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_q[q++]=box_q[4];\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n            }\n          break;\n        }\n        case MiterJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            {\n              stroke_q[q++]=box_q[4];\n              stroke_p[p++]=box_p[4];\n            }\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n              stroke_p[p++]=box_p[1];\n              stroke_p[p++]=box_p[2];\n            }\n          break;\n        }\n        case RoundJoin:\n        {\n          dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+\n            (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);\n          if (dot_product <= miterlimit)\n            stroke_q[q++]=box_q[4];\n          else\n            {\n              stroke_q[q++]=box_q[1];\n              stroke_q[q++]=box_q[2];\n            }\n          center=polygon_primitive[n].point;\n          theta.p=atan2(box_p[1].y-center.y,box_p[1].x-center.x);\n          theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);\n          if (theta.p < theta.q)\n            theta.p+=2.0*MagickPI;\n          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.p-\n            theta.q)/(2.0*sqrt((double) (PerceptibleReciprocal(mid)))))));\n          DisableMSCWarning(4127)\n          CheckPathExtent(arc_segments+MaxStrokePad,MaxStrokePad);\n          RestoreMSCWarning\n          stroke_p[p++]=box_p[1];\n          for (j=1; j < (ssize_t) arc_segments; j++)\n          {\n            delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);\n            stroke_p[p].x=(double) (center.x+mid*cos(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            stroke_p[p].y=(double) (center.y+mid*sin(fmod((double)\n              (theta.p+delta_theta),DegreesToRadians(360.0))));\n            p++;\n          }\n          stroke_p[p++]=box_p[2];\n          break;\n        }\n        default:\n          break;\n      }\n    slope.p=slope.q;\n    inverse_slope.p=inverse_slope.q;\n    box_p[0]=box_p[2];\n    box_p[1]=box_p[3];\n    box_q[0]=box_q[2];\n    box_q[1]=box_q[3];\n    dx.p=dx.q;\n    dy.p=dy.q;\n    n=i;\n  }\n  stroke_p[p++]=box_p[1];\n  stroke_q[q++]=box_q[1];\n  /*\n    Trace stroked polygon.\n  */\n  stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (p+q+2UL*closed_path+2UL),sizeof(*stroke_polygon));\n  if (stroke_polygon == (PrimitiveInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n      stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(\n        polygon_primitive);\n      return(stroke_polygon);\n    }\n  for (i=0; i < (ssize_t) p; i++)\n  {\n    stroke_polygon[i]=polygon_primitive[0];\n    stroke_polygon[i].point=stroke_p[i];\n  }\n  if (closed_path != MagickFalse)\n    {\n      stroke_polygon[i]=polygon_primitive[0];\n      stroke_polygon[i].point=stroke_polygon[0].point;\n      i++;\n    }\n  for ( ; i < (ssize_t) (p+q+closed_path); i++)\n  {\n    stroke_polygon[i]=polygon_primitive[0];\n    stroke_polygon[i].point=stroke_q[p+q+closed_path-(i+1)];\n  }\n  if (closed_path != MagickFalse)\n    {\n      stroke_polygon[i]=polygon_primitive[0];\n      stroke_polygon[i].point=stroke_polygon[p+closed_path].point;\n      i++;\n    }\n  stroke_polygon[i]=polygon_primitive[0];\n  stroke_polygon[i].point=stroke_polygon[0].point;\n  i++;\n  stroke_polygon[i].primitive=UndefinedPrimitive;\n  stroke_polygon[0].coordinates=(size_t) (p+q+2*closed_path+1);\n  stroke_p=(PointInfo *) RelinquishMagickMemory(stroke_p);\n  stroke_q=(PointInfo *) RelinquishMagickMemory(stroke_q);\n  polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);\n  return(stroke_polygon);\n}\n"], "filenames": ["MagickCore/draw.c"], "buggy_code_start_loc": [5608], "buggy_code_end_loc": [5609], "fixing_code_start_loc": [5608], "fixing_code_end_loc": [5610], "type": "CWE-20", "message": "A vulnerability was discovered in ImageMagick where a specially created SVG file loads itself and causes a segmentation fault. This flaw allows a remote attacker to pass a specially crafted SVG file that leads to a segmentation fault, generating many trash files in \"/tmp,\" resulting in a denial of service. When ImageMagick crashes, it generates a lot of trash files. These trash files can be large if the SVG file contains many render actions. In a denial of service attack, if a remote attacker uploads an SVG file of size t, ImageMagick generates files of size 103*t. If an attacker uploads a 100M SVG, the server will generate about 10G.", "other": {"cve": {"id": "CVE-2023-1289", "sourceIdentifier": "secalert@redhat.com", "published": "2023-03-23T20:15:14.393", "lastModified": "2023-03-30T15:07:29.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was discovered in ImageMagick where a specially created SVG file loads itself and causes a segmentation fault. This flaw allows a remote attacker to pass a specially crafted SVG file that leads to a segmentation fault, generating many trash files in \"/tmp,\" resulting in a denial of service. When ImageMagick crashes, it generates a lot of trash files. These trash files can be large if the SVG file contains many render actions. In a denial of service attack, if a remote attacker uploads an SVG file of size t, ImageMagick generates files of size 103*t. If an attacker uploads a 100M SVG, the server will generate about 10G."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.1.1-0", "matchCriteriaId": "A9DF6DDA-7BD8-46B0-B576-3B36C8E981CD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C30C1AC-01E4-4D7C-B03A-8EEEF3FC8C2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2176858", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/c5b23cbf2119540725e6dc81f4deb25798ead6a4", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/security/advisories/GHSA-j96m-mjp6-99xr", "source": "secalert@redhat.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c5b23cbf2119540725e6dc81f4deb25798ead6a4"}}