{"buggy_code": ["1.5.5 - 201812xx\n================\n\nBroker:\n- Add `socket_domain` option to allow listeners to disable IPv6 support.\n  This is required to work around a problem in libwebsockets that means\n  sockets only listen on IPv6 by default if IPv6 support is compiled in.\n  Closes #1004.\n- When using ADNS, don't ask for all network protocols when connecting,\n  because this can lead to confusing \"Protocol not supported\" errors if the\n  network is down. Closes #1062.\n- Fix outgoing retained messages not being sent by bridges on initial\n  connection. Closes #1040.\n- Don't reload auth_opt_ options on reload, to match the behaviour of the\n  other plugin options. Closes #1068.\n- Print message on error when installing/uninstalling as a Windows service.\n\nLibrary:\n- Fix reconnect delay backoff behaviour. Closes #1027.\n- Don't call on_disconnect() twice if keepalive tests fail. Closes #1067.\n\nClient:\n- Always print leading zeros in mosquitto_sub when output format is hex.\n  Closes #1066.\n\n\n1.5.4 - 20181108\n================\n\nSecurity:\n- When using a TLS enabled websockets listener with \"require_certificate\"\n  enabled, the mosquitto broker does not correctly verify client certificates.\n  This is now fixed. All other security measures operate as expected, and in\n  particular non-websockets listeners are not affected by this. Closes #996.\n\nBroker:\n- Process all pending messages even when a client has disconnected. This means\n  a client that send a PUBLISH then DISCONNECT quickly, then disconnects will\n  have its DISCONNECT message processed properly and so no Will will be sent.\n  Closes #7.\n- $SYS/broker/clients/disconnected should never be negative. Closes #287.\n- Give better error message if a client sends a password without a username.\n  Closes #1015.\n- Fix bridge not honoring restart_timeout. Closes #1019.\n- Don't disconnect a client if an auth plugin denies access to SUBSCRIBE.\n  Closes #1016.\n\nLibrary:\n- Fix memory leak that occurred if mosquitto_reconnect() was used when TLS\n  errors were present. Closes #592.\n- Fix TLS connections when using an external event loop with\n  mosquitto_loop_read() and mosquitto_write(). Closes #990.\n\nBuild:\n- Fix clients not being compiled with threading support when using CMake.\n  Closes #983.\n- Header fixes for FreeBSD. Closes #977.\n- Use _GNU_SOURCE to fix build errors in websockets and getaddrinfo usage.\n  Closes #862 and #933.\n- Fix builds on QNX 7.0.0. Closes #1018.\n\n\n1.5.3 - 20180925\n================\n\nSecurity:\n- Fix CVE-2018-12543. If a message is sent to Mosquitto with a topic that\n  begins with $, but is not $SYS, then an assert that should be unreachable is\n  triggered and Mosquitto will exit.\n\nBroker:\n- Elevate log level to warning for situation when socket limit is hit.\n- Remove requirement to use `user root` in snap package config files.\n- Fix retained messages not sent by bridges on outgoing topics at the first\n  connection. Closes #701.\n- Documentation fixes. Closes #520, #600.\n- Fix duplicate clients being added to by_id hash before the old client was\n  removed. Closes #645.\n- Fix Windows version not starting if include_dir did not contain any files.\n  Closes #566.\n- When an authentication plugin denied access to a SUBSCRIBE, the client would\n  be disconnected incorrectly. This has been fixed. Closes #1016.\n\nBuild:\n- Various fixes to ease building.\n\n\n1.5.2 - 20180919\n================\n\nBroker:\n- Fix build when using WITH_ADNS=yes.\n- Fix incorrect call to setsockopt() for TCP_NODELAY. Closes #941.\n- Fix excessive CPU usage when the number of sockets exceeds the system limit.\n  Closes #948.\n- Fix for bridge connections when using WITH_ADNS=yes.\n- Fix round_robin false behaviour. Closes #481.\n- Fix segfault on HUP when bridges and security options are configured.\n  Closes #965.\n\nLibrary:\n- Fix situation where username and password is used with SOCKS5 proxy. Closes\n  #927.\n- Fix SOCKS5 behaviour when passing IP addresses. Closes #927.\n\nBuild:\n- Make it easier to build without bundled uthash.h using \"WITH_BUNDLED_DEPS=no\".\n- Fix build with OPENSSL_NO_ENGINE. Closes #932.\n\n\n1.5.1 - 20180816\n================\n\nBroker:\n- Fix plugin cleanup function not being called on exit of the broker.\n  Closes #900.\n- Print more OpenSSL errors when loading certificates/keys fail.\n- Use AF_UNSPEC etc. instead of PF_UNSPEC to comply with POSIX. Closes #863.\n- Remove use of AI_ADDRCONFIG, which means the broker can be used on systems\n  where only the loopback interface is defined. Closes #869, Closes #901.\n- Fix IPv6 addresses not being able to be used as bridge addresses.\n  Closes #886.\n- All clients now time out if they exceed their keepalive*1.5, rather than\n  just reach it. This was inconsistent in two places.\n- Fix segfault on startup if bridge CA certificates could not be read.\n  Closes #851.\n- Fix problem opening listeners on Pi caused by unsigned char being default.\n  Found via #849.\n- ACL patterns that do not contain either %c or %u now produce a warning in\n  the log. Closes #209.\n- Fix bridge publishing failing when per_listener_settings was true. Closes\n  #860.\n- Fix `use_identity_as_username true` not working. Closes #833.\n- Fix UNSUBACK messages not being logged. Closes #903.\n- Fix possible endian issue when reading the `memory_limit` option.\n- Fix building for libwebsockets < 1.6.\n- Fix accessor functions for username and client id when used in plugin auth\n  check.\n\nLibrary:\n- Fix some places where return codes were incorrect, including to the\n  on_disconnect() callback. This has resulted in two new error codes,\n  MOSQ_ERR_KEEPALIVE and MOSQ_ERR_LOOKUP.\n- Fix connection problems when mosquitto_loop_start() was called before\n  mosquitto_connect_async(). Closes #848.\n\nClients:\n- When compiled using WITH_TLS=no, the default port was incorrectly being set\n  to -1. This has been fixed.\n- Fix compiling on Mac OS X <10.12. Closes #813 and #240.\n\nBuild:\n- Fixes for building on NetBSD. Closes #258.\n- Fixes for building on FreeBSD.\n- Add support for compiling with static libwebsockets library.\n\n\n1.5 - 20180502\n==============\n\nSecurity:\n- Fix memory leak that could be caused by a malicious CONNECT packet. This\n  does not yet have a CVE assigned. Closes #533493 (on Eclipse bugtracker)\n\nBroker features:\n- Add per_listener_settings to allow authentication and access control to be\n  per listener.\n- Add limited support for reloading listener settings. This allows settings\n  for an already defined listener to be reloaded, but port numbers must not be\n  changed.\n- Add ability to deny access to SUBSCRIBE messages as well as the current\n  read/write accesses. Currently for auth plugins only.\n- Reduce calls to malloc through the use of UHPA.\n- Outgoing messages with QoS>1 are no longer retried after a timeout period.\n  Messages will be retried when a client reconnects.  This change in behaviour\n  can be justified by considering when the timeout may have occurred.\n  * If a connection is unreliable and has dropped, but without one end\n    noticing, the messages will be retried on reconnection. Sending\n    additional PUBLISH or PUBREL would not have changed anything.\n  * If a client is overloaded/unable to respond/has a slow connection then\n    sending additional PUBLISH or PUBREL would not help the client catch\n    up. Once the backlog has cleared the client will respond. If it is not\n    able to catch up, sending additional duplicates would not help either.\n- Add use_subject_as_username option for certificate based client\n  authentication to use the entire certificate subject as a username, rather\n  than just the CN. Closes #469467.\n- Change sys tree printing output. This format shouldn't be relied upon and\n  may change at any time. Closes #470246.\n- Minimum supported libwebsockets version is now 1.3.\n- Add systemd startup notification and services. Closes #471053.\n- Reduce unnecessary malloc and memcpy when receiving a message and storing\n  it. Closes #470258.\n- Support for Windows XP has been dropped.\n- Bridge connections now default to using MQTT v3.1.1.\n- mosquitto_db_dump tool can now output some stats on clients.\n- Perform utf-8 validation on incoming will, subscription and unsubscription\n  topics.\n- new $SYS/broker/store/messages/count (deprecates $SYS/broker/messages/stored)\n- new $SYS/broker/store/messages/bytes\n- max_queued_bytes feature to limit queues by real size rather than\n  than just message count. Closes Eclipse #452919 or Github #100\n- Add support for bridges to be configured to only send notifications to the\n  local broker.\n- Add set_tcp_nodelay option to allow Nagle's algorithm to be disabled on\n  client sockets. Closes #433.\n- The behaviour of allow_anonymous has changed. In the old behaviour, the\n  default if not set was to allow anonymous access. The new behaviour is to\n  default is to allow anonymous access unless another security option is set.\n  For example, if password_file is set and allow_anonymous is not set, then\n  anonymous access will be denied. It is still possible to allow anonymous\n  access by setting it explicitly.\n\nBroker fixes:\n- Fix UNSUBSCRIBE with no topic is accepted on MQTT 3.1.1. Closes #665.\n- Produce an error if two bridges share the same local_clientid.\n- Miscellaneous fixes on Windows.\n- queue_qos0_messages was not observing max_queued_** limits\n- When using the include_dir configuration option sort the files\n  alphabetically before loading them.  Closes #17.\n- IPv6 is no longer disabled for websockets listeners.\n- Remove all build timestamp information including $SYS/broker/timestamp.\n  Close #651.\n- Correctly handle incoming strings that contain a NULL byte. Closes #693.\n- Use constant time memcmp for password comparisons.\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Fix memory leak if a client provided a username/password for a listener with\n  use_identity_as_username configured.\n- Fix use_identity_as_username not working on websockets clients.\n- Don't crash if an auth plugin returns MOSQ_ERR_AUTH for a username check on\n  a websockets client. Closes #490.\n- Fix 08-ssl-bridge.py test when using async dns lookups. Closes #507.\n- Lines in the config file are no longer limited to 1024 characters long.\n  Closes #652.\n- Fix $SYS counters of messages and bytes sent when message is sent over\n  a Websockets. Closes #250.\n- Fix upgrade_outgoing_qos for retained message. Closes #534.\n- Fix CONNACK message not being sent for unauthorised connect on websockets.\n  Closes #8.\n- Maximum connections on Windows increased to 2048.\n- When a client with an in-use client-id connects, if the old client has a\n  will, send the will message. Closes #26.\n- Fix parsing of configuration options that end with a space. Closes #804.\n\nClient library features:\n- Outgoing messages with QoS>1 are no longer retried after a timeout period.\n  Messages will be retried when a client reconnects.\n- DNS-SRV support is now disabled by default.\n- Add mosquitto_subscribe_simple() This is a helper function to make\n  retrieving messages from a broker very straightforward. Examples of its use\n  are in examples/subscribe_simple.\n- Add mosquitto_subscribe_callback() This is a helper function to make\n  processing messages from a broker very straightforward. An example of its use\n  is in examples/subscribe_simple.\n- Connections now default to using MQTT v3.1.1.\n- Add mosquitto_validate_utf8() to check whether a string is valid UTF-8\n  according to the UTF-8 spec and to the additional restrictions imposed by\n  the MQTT spec.\n- Topic inputs are checked for UTF-8 validity.\n- Add mosquitto_userdata function to allow retrieving the client userdata\n  member variable. Closes #111.\n- Add mosquitto_pub_topic_check2(), mosquitto_sub_topic_check2(), and\n  mosquitto_topic_matches_sub2() which are identical to the similarly named\n  functions but also take length arguments.\n- Add mosquitto_connect_with_flags_callback_set(), which allows a second\n  connect callback to be used which also exposes the connect flags parameter.\n  Closes #738 and #128.\n- Add MOSQ_OPT_SSL_CTX option to allow a user specified SSL_CTX to be used\n  instead of the one generated by libmosquitto. This allows greater control\n  over what options can be set. Closes #715.\n- Add MOSQ_OPT_SSL_CTX_WITH_DEFAULTS to work with MOSQ_OPT_SSL_CTX and have\n  the default libmosquitto SSL_CTX configuration applied to the user provided\n  SSL_CTX. Closes #567.\n\nClient library fixes:\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Initialise \"result\" variable as soon as possible in\n  mosquitto_topic_matches_sub. Closes #654.\n- No need to close socket again if setting non-blocking failed. Closes #649.\n- Fix mosquitto_topic_matches_sub() not correctly matching foo/bar against\n  foo/+/#. Closes #670.\n- SNI host support added.\n\nClient features:\n- Add -F to mosquitto_sub to allow the user to choose the output format.\n- Add -U to mosquitto_sub for unsubscribing from topics.\n- Add -c (clean session) to mosquitto_pub.\n- Add --retained-only to mosquitto_sub to exit after receiving all retained\n  messages.\n- Add -W to allow mosquitto_sub to stop processing incoming messages after a\n  timeout.\n- Connections now default to using MQTT v3.1.1.\n- Default to using port 8883 when using TLS.\n- mosquitto_sub doesn't continue to keep connecting if CONNACK tells it the\n  connection was refused.\n\nClient fixes:\n- Correctly handle empty files with \"mosquitto_pub -l\". Closes #676.\n\nBuild:\n- Add WITH_STRIP option (defaulting to \"no\") that when set to \"yes\" will strip\n  executables and shared libraries when installing.\n- Add WITH_STATIC_LIBRARIES (defaulting to \"no\") that when set to \"yes\" will\n  build and install static versions of the client libraries.\n- Don't run TLS-PSK tests if TLS-PSK disabled at compile time. Closes #636.\n- Support for openssl versions 1.0.0 and 1.0.1 has been removed as these are\n  no longer supported by openssl.\n\nDocumentation:\n- Replace mentions of deprecated 'c_rehash' with 'openssl rehash'.\n\n1.4.15 - 20180228\n=================\n\nSecurity:\n- Fix CVE-2017-7652. If a SIGHUP is sent to the broker when there are no more\n  file descriptors, then opening the configuration file will fail and security\n  settings will be set back to their default values.\n- Fix CVE-2017-7651. Unauthenticated clients can cause excessive memory use by\n  setting \"remaining length\" to be a large value. This is now mitigated by\n  limiting the size of remaining length to valid values. A \"memory_limit\"\n  configuration option has also been added to allow the overall memory used by\n  the broker to be limited.\n\nBroker:\n- Use constant time memcmp for password comparisons.\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Fix memory leak if a client provided a username/password for a listener with\n  use_identity_as_username configured.\n- Fix use_identity_as_username not working on websockets clients.\n- Don't crash if an auth plugin returns MOSQ_ERR_AUTH for a username check on\n  a websockets client. Closes #490.\n- Fix 08-ssl-bridge.py test when using async dns lookups. Closes #507.\n- Lines in the config file are no longer limited to 1024 characters long.\n  Closes #652.\n- Fix $SYS counters of messages and bytes sent when message is sent over\n  a Websockets. Closes #250.\n- Fix upgrade_outgoing_qos for retained message. Closes #534.\n- Fix CONNACK message not being sent for unauthorised connect on websockets.\n  Closes #8.\n\nClient library:\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Initialise \"result\" variable as soon as possible in\n  mosquitto_topic_matches_sub. Closes #654.\n- No need to close socket again if setting non-blocking failed. Closes #649.\n- Fix mosquitto_topic_matches_sub() not correctly matching foo/bar against\n  foo/+/#. Closes #670.\n\nClients:\n- Correctly handle empty files with \"mosquitto_pub -l\". Closes #676.\n\nBuild:\n- Don't run TLS-PSK tests if TLS-PSK disabled at compile time. Closes #636.\n\n\n1.4.14 - 20170710\n=================\n\nBroker:\n- Fix regression from 1.4.13 where persistence data was not being saved.\n\n\n1.4.13 - 20170627\n=================\n\nSecurity:\n- Fix CVE-2017-9868. The persistence file was readable by all local users,\n  potentially allowing sensitive information to be leaked.\n  This can also be fixed administratively, by restricting access to the\n  directory in which the persistence file is stored.\n\nBroker:\n- Fix for poor websockets performance.\n- Fix lazy bridges not timing out for idle_timeout. Closes #417.\n- Fix problems with large retained messages over websockets. Closes #427.\n- Set persistence file to only be readable by owner, except on Windows. Closes\n  #468.\n- Fix CONNECT check for reserved=0, as per MQTT v3.1.1 check MQTT-3.1.2-3.\n- When the broker stop, wills for any connected clients are now \"sent\". Closes\n  #477.\n- Auth plugins can be configured to disable the check for +# in\n  usernames/client ids with the auth_plugin_deny_special_chars option.\n  Partially closes #462.\n- Restrictions for CVE-2017-7650 have been relaxed - '/' is allowed in\n  usernames/client ids. Remainder of fix for #462.\n\nClients:\n- Don't use / in auto-generated client ids.\n\n\n1.4.12 - 20170528\n=================\n\nSecurity:\n- Fix CVE-2017-7650, which allows clients with username or client id set to\n  '#' or '+' to bypass pattern based ACLs or third party plugins. The fix\n  denies message sending or receiving of messages for clients with a '#' or\n  '+' in their username or client id and if the message is subject to a\n  pattern ACL check or plugin check.\n  Patches for other versions are available at\n  https://mosquitto.org/files/cve/2017-7650/\n\nBroker:\n- Fix mosquitto.db from becoming corrupted due to client messages being\n  persisted with no stored message. Closes #424.\n- Fix bridge not restarting properly. Closes #428.\n- Fix unitialized memory in gets_quiet on Windows. Closes #426.\n- Fix building with WITH_ADNS=no for systems that don't use glibc. Closes\n  #415.\n- Fixes to readme.md.\n- Fix deprecation warning for OpenSSL 1.1. PR #416.\n- Don't segfault on duplicate bridge names. Closes #446.\n- Fix CVE-2017-7650.\n\n\n1.4.11 - 20170220\n=================\n\nBroker:\n- Fix crash when \"lazy\" type bridge attempts to reconnect. Closes #259.\n- maximum_connections now applies to websockets listeners. Closes #271.\n- Allow bridges to use TLS with IPv6.\n- Don't error on zero length persistence files. Closes #316.\n- For http only websockets clients, close files served over http in all cases\n  when the client disconnects. Closes #354.\n- Fix error message when websockets http_dir directory does not exist.\n- Improve password utility error message. Closes #379.\n\nClients:\n- Use of --ciphers no longer requires you to also pass --tls-version.\n  Closes #380.\n\nClient library:\n- Clients can now use TLS with IPv6.\n- Fix potential socket leakage when reconnecting. Closes #304.\n- Fix potential negative timeout being passed to pselect. Closes #329.\n\n\n1.4.10 - 20160816\n=================\n\nBroker:\n- Fix TLS operation with websockets listeners and libwebsockts 2.x. Closes\n  #186.\n- Don't disconnect client on HUP before reading the pending data. Closes #7.\n- Fix some $SYS messages being incorrectly persisted. Closes #191.\n- Support OpenSSL 1.1.0.\n- Call fsync after persisting data to ensure it is correctly written. Closes\n  #189.\n- Fix persistence saving of subscription QoS on big-endian machines.\n- Fix will retained flag handling on Windows. Closes #222.\n- Broker now displays an error if it is unable to open the log file. Closes\n  #234.\n\nClient library:\n- Support OpenSSL 1.1.0.\n- Fixed the C++ library not allowing SOCKS support to be used. Closes #198.\n- Fix memory leak when verifying a server certificate with a subjectAltName\n  section. Closes #237.\n\nBuild:\n- Don't attempt to install docs when WITH_DOCS=no. Closes #184.\n\n\n1.4.9 - 20160603\n================\n\nBroker:\n- Ensure websockets clients that previously connected with clean session set\n  to false have their queued messages delivered immediately on reconnecting.\n  Closes #476314.\n- Reconnecting client with clean session set to false doesn't start with mid=1\n  again.\n- Will topic isn't truncated by one byte when using a mount_point any more.\n- Network errors are printed correctly on Windows.\n- Fix incorrect $SYS heap memory reporting when using ACLs.\n- Bridge config parameters couldn't contain a space, this has been fixed.\n  Closes #150.\n- Fix saving of persistence messages that start with a '/'. Closes #151.\n- Fix reconnecting for bridges that use TLS on Windows. Closes #154.\n- Broker and bridges can now cope with unknown incoming PUBACK, PUBREC,\n  PUBREL, PUBCOMP without disconnecting. Closes #57.\n- Fix websockets listeners not being able to bind to an IP address. Closes\n  #170.\n- mosquitto_passwd utility now correctly deals with unknown command line\n  arguments in all cases. Closes #169.\n- Fix publishing of $SYS/broker/clients/maximum\n- Fix order of #includes in lib/send_mosq.c to ensure struct mosquitto doesn't\n  differ between source files when websockets is being used. Closes #180.\n- Fix possible rare crash when writing out persistence file and a client has\n  incomplete messages inflight that it has been denied the right to publish.\n\nClient library:\n- Fix the case where a message received just before the keepalive timer\n  expired would cause the client to miss the keepalive timer.\n- Return value of pthread_create is now checked.\n- _mosquitto_destroy should not cancel threads that weren't created by\n  libmosquitto. Closes #166.\n- Clients can now cope with unknown incoming PUBACK, PUBREC, PUBREL, PUBCOMP\n  without disconnecting. Closes #57.\n- Fix mosquitto_topic_matches_sub() reporting matches on some invalid\n   subscriptions.\n\nClients:\n- Handle some unchecked malloc() calls. Closes #1.\n\nBuild:\n- Fix string quoting in CMakeLists.txt. Closes #4.\n- Fix building on Visual Studio 2015. Closes #136.\n\n\n1.4.8 - 20160214\n================\n\nBroker:\n- Wills published by clients connected to a listener with mount_point defined\n  now correctly obey the mount point. This was a potential security risk\n  because it allowed clients to publish messages outside of their restricted\n  mount point. This is only affects brokers where the mount_point option is in\n  use. Closes #487178.\n- Fix detection of broken connections on Windows. Closes #485143.\n- Close stdin etc. when daemonised. Closes #485589.\n- Fix incorrect detection of FreeBSD and OpenBSD. Closes #485131.\n\nClient library:\n- mosq->want_write should be cleared immediately before a call to SSL_write,\n  to allow clients using mosquitto_want_write() to get accurate results.\n\n\n1.4.7 - 20151221\n================\n\nBroker:\n- Fix support for libwebsockets 1.22.\n\n\n1.4.6 - 20151220\n================\n\nBroker:\n- Add support for libwebsockets 1.6.\n\nClient library:\n- Fix _mosquitto_socketpair() on Windows, reducing the chance of delays when\n  publishing. Closes #483979.\n\nClients:\n- Fix \"mosquitto_pub -l\" stripping the final character on a line. Closes\n  #483981.\n\n\n1.4.5 - 20151108\n================\n\nBroker:\n- Fix possible memory leak if bridge using SSL attempts to connect to a\n  host that is not up.\n- Free unused topic tree elements (fix in 1.4.3 was incomplete). Closes\n  #468987.\n\nClients:\n- \"mosquitto_pub -l\" now no longer limited to 1024 byte lines. Closes #478917.\n\n\n1.4.4 - 20150916\n================\n\nBroker:\n- Don't leak sockets when outgoing bridge with multiple addresses cannot\n  connect. Closes #477571.\n- Fix cross compiling of websockets. Closes #475807.\n- Fix memory free related crashes on openwrt. Closes #475707.\n- Fix excessive calls to message retry check.\n\n\n1.4.3 - 20150818\n================\n\nBroker:\n- Fix incorrect bridge notification on initial connection. Closes #467096.\n- Build fixes for OpenBSD.\n- Fix incorrect behaviour for autosave_interval, most noticable for\n  autosave_interval=1. Closes #465438.\n- Fix handling of outgoing QoS>0 messages for bridges that could not be sent\n  because the bridge connection was down.\n- Free unused topic tree elements. Closes #468987.\n- Fix some potential memory leaks. Closes #470253.\n- Fix potential crash on libwebsockets error.\n\nClient library:\n- Add missing error strings to mosquitto_strerror.\n- Handle fragmented TLS packets without a delay. Closes #470660.\n- Fix incorrect loop timeout being chosen when using threaded interface and\n  keepalive = 0. Closes #471334.\n- Increment inflight messages count correctly. Closes #474935.\n\nClients:\n- Report error string on connection failure rather than error code.\n\n\n1.4.2 - 20150507\n================\n\nBroker:\n- Fix bridge prefixes only working for the first outgoing message. Closes\n  #464437.\n- Fix incorrect bridge connection notifications on local broker.\n- Fix persistent db writing on Windows. Closes #464779.\n- ACLs are now checked before sending a will message.\n- Fix possible crash when using bridges on Windows. Closes #465384.\n- Fix parsing of auth_opt_ arguments with extra spaces/tabs.\n- Broker will return CONNACK rc=5 when a username/password is not authorised.\n  This was being incorrectly set as rc=4.\n- Fix handling of payload lengths>4096 with websockets.\n\nClient library:\n- Inflight message count wasn't being decreased for outgoing messages using\n  QoS 2, meaning that only up to 20 QoS 2 messages could be sent. This has\n  been fixed. Closes #464436.\n- Fix CMake dependencies for C++ wrapper building. Closes #463884.\n- Fix possibility of select() being called with a socket that is >FD_SETSIZE.\n  This is a fix for #464632 that will be followed up by removing the select()\n  call in a future version.\n- Fix calls to mosquitto_connect*_async() not completing.\n\n\n1.4.1 - 20150403\n================\n\nBroker:\n- Fix possible crash under heavy network load. Closes #463241.\n- Fix possible crash when using pattern ACLs.\n- Fix problems parsing config strings with multiple leading spaces. Closes\n  #462154.\n- Websockets clients are now periodically disconnected if they have not\n  maintained their keepalive timer. Closes #461619.\n- Fix possible minor memory leak on acl parsing.\n\nClient library:\n- Inflight limits should only apply to outgoing messages. Closes #461620.\n- Fix reconnect bug on Windows. Closes #463000.\n- Return -1 on error from mosquitto_socket(). Closes #461705.\n- Fix crash on multiple calls to mosquitto_lib_init/mosquitto_lib_cleanup.\n  Closes #462780.\n- Allow longer paths on Windows. Closes #462781.\n- Make _mosquitto_mid_generate() thread safe. Closes #463479.\n\n\n1.4 - 20150218\n==============\n\nImportant changes:\n- Websockets support in the broker.\n- Bridge behaviour on the local broker has changed due to the introduction of\n  the local_* options. This may affect you if you are using authentication\n  and/or ACLs with bridges.\n- The default TLS behaviour has changed to accept all of TLS v1.2, v1.1 and\n  v1.0, rather than only only one version of the protocol. It is still\n  possible to restrict a listener to a single version of TLS.\n- The Python client has been removed now that the Eclipse Paho Python client\n  has had a release.\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- New use_username_as_clientid option on the broker, for preventing hijacking\n  of a client id.\n- The client library and clients now have experimental SOCKS5 support.\n- Wildcard TLS certificates are now supported for bridges and clients.\n- The clients have support for config files with default options.\n- Client and client libraries have support for MQTT v3.1.1.\n- Bridge support for MQTT v3.1.1.\n\n\nBroker:\n- Websockets support in the broker.\n- Add local_clientid, local_username, local_password for bridge connections to\n  authenticate to the local broker.\n- Default TLS mode now accepts TLS v1.2, v1.1 and v1.0.\n- Support for ECDHE-ECDSA family ciphers.\n- Fix bug #1324411, which could have had unexpected consequences for delayed\n  messages in rare circumstances.\n- Add support for \"session present\" in CONNACK messages for MQTT v3.1.1.\n- Remove strict protocol #ifdefs.\n- Change $SYS/broker/clients/active -> $SYS/broker/clients/connected\n- Change $SYS/broker/clients/inactive -> $SYS/broker/clients/disconnected\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- libuuid is used to generate client ids, where it is available, when an MQTT\n  v3.1.1 client connects with a zero length client id.\n- Anonymous clients are no longer accidently disconnected from the broker\n  after a SIGHUP.\n- mosquitto_passwd now supports -b (batch mode) to allow the password to be\n  provided at the command line.\n- Removed $SYS/broker/changeset. This was intended for use with debugging, but\n  in practice is of no use.\n- Add support for use_username_as_clientid which can be used with\n  authentication to restrict ownership of client ids and hence prevent one\n  client disconnecting another by using the same client id.\n- When \"require_certificate\" was false, the broker was incorrectly asking for\n  a certificate (but not checking it). This caused problems with some clients\n  and has been fixed so the broker no longer asks.\n- When using syslog logging on non-Windows OSs, it is now possible to specify\n  the logging facility to one of local0-7 instead of the default \"daemon\".\n- The bridge_attempt_unsubscribe option has been added, to allow the sending\n  of UNSUBSCRIBE requests to be disabled for topics with \"out\" direction.\n  Closes bug #456899.\n- Wildcard TLS certificates are now supported for bridges.\n- Support for \"hour\" client expiration lengths for the\n  persistent_client_expiration option. Closes bug #425835.\n- Bridge support for MQTT v3.1.1.\n- Root privileges are now dropped after starting listeners and loading\n  certificates/private keys, to allow private keys to have their permissions\n  restricted to the root user only. Closes bug #452914.\n- Usernames and topics given in ACL files can now include a space. Closes bug\n  #431780.\n- Fix hang if pattern acl contains a %u but an anonymous client connect.\n  Closes bug #455402.\n- Fix man page installation with cmake. Closes bug #458843.\n- When using \"log_dest file\" the output file is now flushed periodically.\n\nClients:\n- Both clients can now load default configuration options from a file.\n- Add -C option to mosquitto_sub to allow the client to quit after receiving a\n  certain count of messages. Closes bug #453850.\n- Add --proxy SOCKS5 support for both clients.\n- Pub client supports setting its keepalive. Closes bug #454852.\n- Add support for config files with default options.\n- Add support for MQTT v3.1.1.\n\nClient library:\n- Add experimental SOCKS5 support.\n- mosquitto_loop_forever now quits after a fatal error, rather than blindly\n  retrying.\n- SRV support is now not compiled in by default.\n- Wildcard TLS certificates are now supported.\n- mosquittopp now has a virtual destructor. Closes bug #452915.\n- Add support for MQTT v3.1.1.\n- Don't quit mosquitto_loop_forever() if broker not available on first\n  connect. Closes bug #453293, but requires more work.\n\n\n1.3.5 - 20141008\n================\n\nBroker:\n- Fix possible memory leak when using a topic that has a leading slash. Fixes\n  bug #1360985.\n- Fix saving persistent database on Windows.\n- Temporarily disable ACL checks on subscriptions when using MQTT v3.1.1. This\n  is due to the complexity of checking wildcard ACLs against wildcard\n  subscriptions. This does not have a negative impact on security because\n  checks are still made before a message is sent to a client.\n  Fixes bug #1374291.\n- When using -v and the broker receives a SIGHUP, verbose logging was being\n  disabled. This has been fixed.\n\nClient library:\n- Fix mutex being incorrectly passed by value. Fixes bug #1373785.\n\n1.3.4 - 20140806\n================\n\nBroker:\n- Don't ask client for certificate when require_certificate is false.\n- Backout incomplete functionality that was incorrectly included in 1.3.2.\n\n1.3.3 - 20140801\n================\n\nBroker:\n- Fix incorrect handling of anonymous bridges on the local broker.\n\n1.3.2 - 20140713\n================\n\nBroker:\n- Don't allow access to clients when authenticating if a security plugin\n  returns an application error. Fixes bug #1340782.\n- Ensure that bridges verify certificates by default when using TLS.\n- Fix possible crash when using pattern ACLs that do not include a %u and\n  clients that connect without a username.\n- Fix subscriptions being deleted when clients subscribed to a topic beginning\n  with a $ but that is not $SYS.\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- Fix bug #1324411, which could have had unexpected consequences for delayed\n  messages in rare circumstances.\n- Anonymous clients are no longer accidently disconnected from the broker\n  after a SIGHUP.\n\nClient library:\n- Fix topic matching edge case.\n- Fix callback deadlocks after calling mosquitto_disconnect(), when using the\n  threaded interfaces. Closes bug #1313725.\n- Fix SRV support when building with CMake.\n- Remove strict protocol #ifdefs.\n\nGeneral:\n- Use $(STRIP) for stripping binaries when installing, to allow easier cross\n  compilation.\n\n1.3.1 - 20140324\n================\n\nBroker:\n- Prevent possible crash on client reconnect. Closes bug #1294108.\n- Don't accept zero length unsubscription strings (MQTT v3.1.1 fix)\n- Don't accept QoS 3 (MQTT v3.1.1 fix)\n- Don't disconnect clients immediately on HUP to give chance for all data to\n  be read.\n- Reject invalid un/subscriptions e.g. foo/+bar #/bar.\n- Take more care not to disconnect clients that are sending large messages.\n\nClient library:\n- Fix socketpair code on the Mac.\n- Fix compilation for WITH_THREADING=no.\n- Break out of select() when calling mosquitto_loop_stop().\n- Reject invalid un/subscriptions e.g. foo/+bar #/bar.\n- Add mosquitto_threaded_set().\n\nClients:\n- Fix keepalive value on mosquitto_pub.\n- Fix possibility of mosquitto_pub not exiting after sending messages when\n  using -l.\n\n1.3 - 20140316\n==============\n\nBroker:\n- The broker no longer ignores the auth_plugin_init() return value.\n- Accept SSLv2/SSLv3 HELLOs when using TLSv1, whilst keeping SSLv2 and SSLv3\n  disabled. This increases client compatibility without sacrificing security.\n- The $SYS tree can now be disabled at runtime as well as at compile time.\n- When remapping bridged topics, only check for matches when the message\n  direction is correct. This allows two identical topics to be remapped\n  differently for both in and out.\n- Change \"$SYS/broker/heap/current size\" to \"$SYS/broker/heap/current\" for\n  easier parsing.\n- Change \"$SYS/broker/heap/maximum size\" to \"$SYS/broker/heap/maximum\" for\n  easier parsing.\n- Topics are no longer normalised from e.g a///topic to a/topic. This matches\n  the behaviour as clarified by the Oasis MQTT spec. This will lead to\n  unexpected behaviour if you were using topics of this form.\n- Log when outgoing messages for a client begin to drop off the end of the\n  queue.\n- Bridge clients are recognised as bridges even after reloading from\n  persistence.\n- Basic support for MQTT v3.1.1. This does not include being able to bridge to\n  an MQTT v3.1.1 broker.\n- Username is displayed in log if present when a client connects.\n- Support for 0 length client ids (v3.1.1 only) that result in automatically\n  generated client ids on the broker (see option allow_zero_length_clientid).\n- Ability to set the prefix of automatically generated client ids (see option\n  auto_id_prefix).\n- Add support for TLS session resumption.\n- When using TLS, the server now chooses the cipher to use when negotiating\n  with the client.\n- Weak TLS ciphers are now disabled by default.\n\nClient library:\n- Fix support for Python 2.6, 3.0, 3.1.\n- Add support for un/subscribing to multiple topics at once in un/subscribe().\n- Clients now close their socket after sending DISCONNECT.\n- Python client now contains its version number.\n- C library mosquitto_want_write() now supports TLS clients.\n- Fix possible memory leak in C/C++ library when communicating with\n  a broker that doesn't follow the spec.\n- Return strerror() through mosquitto_strerror() to make error printing\n  easier.\n- Topics are no longer normalised from e.g a///topic to a/topic. This matches\n  the behaviour as clarified by the Oasis MQTT spec. This will lead to\n  unexpected behaviour if you were using topics of this form.\n- Add support for SRV lookups.\n- Break out of select() on publish(), subscribe() etc. when using the threaded\n  interface. Fixes bug #1270062.\n- Handle incoming and outgoing messages separately. Fixes bug #1263172.\n- Don't terminate threads on mosquitto_destroy() when a client is not using\n  the threaded interface but does use their own thread. Fixes bug #1291473.\n\nClients:\n- Add --ciphers to allow specifying which TLS ciphers to support.\n- Add support for SRV lookups.\n- Add -N to sub client to suppress printing of EOL after the payload.\n- Add -T to sub client to suppress printing of a topic hierarchy.\n\n1.2.3 - 20131202\n================\n\nBroker:\n- Don't always attempt to call read() for SSL clients, irrespective of whether\n  they were ready to read or not. Reduces syscalls significantly.\n- Possible memory leak fixes.\n- Further fix for bug #1226040: multiple retained messages being delivered for\n  subscriptions ending in #.\n- Fix bridge reconnections when using multiple bridge addresses.\n\nClient library:\n- Fix possible memory leak in C/C++ library when communicating with\n  a broker that doesn't follow the spec.\n- Block in Python loop_stop() until all messages are sent, as the\n  documentation states should happen.\n- Fix for asynchronous connections on Windows. Closes bug #1249202.\n- Module version is now available in mosquitto.py.\n\nClients:\n- mosquitto_sub now uses fwrite() instead of printf() to output messages, so\n  messages with NULL characters aren't truncated.\n\n1.2.2 - 20131021\n================\n\nBroker:\n- Fix compliance with max_inflight_messages when a non-clean session client\n  reconnects. Closes one of the issues on bug #1237389.\n\nClient library:\n- Fix incorrect inflight message accounting, which caused messages to go\n  unsent. Partial fix for bug #1237351.\n- Fix potential memory corruption when sending QoS>0 messages at a high rate\n  using the threaded interface. Further fix for #1237351.\n- Fix incorrect delay scaling when exponential_backoff=true in\n  mosquitto_reconnect_delay_set().\n- Some pep8 fixes for Python.\n\n1.2.1 - 20130918\n================\n\nBroker:\n- The broker no longer ignores the auth_plugin_init() return value. Closes\n  bug #1215084.\n- Use RTLD_GLOBAL when opening authentication plugins on posix systems. Fixes\n  resolving of symbols in libraries used by authentication plugins.\n- Add/fix some config documentation.\n- Fix ACLs for topics with $SYS.\n- Clients loaded from the persistence file on startup were not being added to\n  the client hash, causing subtle problems when the client reconnected,\n  including ACLs failing. This has been fixed.\n- Add note to mosquitto-tls man page stating that certificates need to be\n  unique. Closes bug #1221285.\n- Fix incorrect retained message delivery when using wildcard subs in some\n  circumstances. Fixes bug #1226040.\n\nClient library:\n- Fix support for Python 2.6, 3.0, 3.1.\n- Fix TLS subjectAltName verification and segfaults.\n- Handle EAGAIN in Python on Windows. Closes bug #1220004.\n- Fix compilation when using WITH_TLS=no.\n- Don't fail reconnecting in Python when broker is temporarily unavailable.\n\n1.2 - 20130708\n==============\n\nBroker:\n- Replace O(n) username lookup on CONNECT with a roughly O(1) hashtable version.\n- It is now possible to disable $SYS at compile time.\n- Add dropped publish messages to load tree in $SYS. Closes bug #1183318.\n- Add support for logging SUBSCRIBE/UNSUBSCRIBE events.\n- Add \"log_dest file\" logging support.\n- Auth plugin ACL check function now passes the client id as well as username\n  and password.\n- The queue_qos0_messages option wasn't working correctly, this has now been\n  fixed. Closes bug #1125200.\n- Don't drop all messages for disconnected durable clients when\n  max_queued_messages=0.\n- Add support for \"log_type all\".\n- Add support for \"-v\" option on the command line to provide the equivalent of\n  \"log_type all\" without needing a config file.\n- Add the \"upgrade_outgoing_qos\" option, a non-standard feature.\n- Persistence data is now written to a temporary file which is atomically\n  renamed on completion, so a crash during writing will not produce a corrupt\n  file.\n- mosquitto.conf is now installed as mosquitto.conf.example\n- Configuration file errors are now reported with filename and line number.\n- The broker now uses a monotonic clock if available, to avoid changes in time\n  causing client disconnections or message retries.\n- Clean session and keepalive status are now display the log when a client\n  connects.\n- Add support for TLSv1.2 and TLSv1.1.\n- Clients that connect with zero length will topics are now rejected.\n- Add the ability to set a maximum allowed PUBLISH payload size.\n- Fix an ACL with topic \"#\" incorrectly granting access to $SYS.\n- Fix retained messages incorrectly being set on wildcard topics, leading to\n  duplicate retained messages being sent on subscription. Closes bug #1116233.\n- Don't discard listener values when no \"port\" option given. Closes bug\n  #1131406.\n- Client password check was always failing when security was being reapplied\n  after a config reload. This meant that all clients were being disconnected.\n  This has been fixed.\n- Fix build when WITH_TLS=no. Closes bug #1174971.\n- Fix single outgoing packets not being sent in a timely fashion if they were\n  not sent in one call to write(). Closes bug #1176796.\n- Fix remapping of messages for clients connected to a listener with\n  mount_point set. Closes bug #1180765.\n- Fix duplicate retained messages being sent for some wildcard patterns.\n- If a client connects with a will topic to which they do not have write\n  access, they are now disconnected with CONNACK \"not authorised\".\n- Fix retained messages on topic foo being incorrectly delivered to\n  subscriptions of /#\n- Fix handling of SSL errors on SSL_accept().\n- Fix handling of QoS 2 messages on client reconnect.\n- Drop privileges now sets supplementary groups correctly.\n- Fix load reporting interval (is now 60s).\n- Be strict with malformed PUBLISH packets - clients are now disconnected\n  rather than the packet discarded. This goes inline with future OASIS spec\n  changes and makes other changes more straightforward.\n- Process incoming messages denied by ACL properly so that clients don't keep\n  resending them.\n\n- Add support for round_robin bridge option.\n- Add bridge support for verifying remote server certificate subject against\n  the remote hostname.\n- Fix problem with out of order calls to free() when restarting a lazy bridge.\n- The broker now attempts to resolve bind_address and bridge addresses\n  immediately when parsing the config file in order to detect invalid hosts.\n- Bridges now set their notification state before attempting to connect, so if\n  they fail to connect the state can still be seen.\n- Fix bridge notification payload length - no need to send a null byte.\n\n- mosquitto_passwd utility now reports errors more clearly.\n- Fix \"mosquitto_passwd -U\".\n\nClient library:\n- Add support for TLSv1.2 and TLSv1.1, except for on the Python module.\n- Add support for verifying remote server certificate subject against the\n  remote hostname.\n- Add mosquitto_reconnect_async() support and make asynchronous connections\n  truely asynchronous rather than simply deferred. DNS lookups are still\n  blocking, so asynchronous connections require an IP address instead of\n  hostname.\n- Allow control of reconnection timeouts in mosquitto_loop_forever() and after\n  mosquitto_loop_start() by using mosquitto_reconnect_delay_set().\n- Fix building on Android NDK.\n- Re-raise unhandled errors in Python so as not to provide confusing error\n  messages later on.\n- Python module supports IPv6 connections.\n- mosquitto_sub_topic_tokenise() was behaving incorrectly if the last topic\n  hierarchy had only a single character. This has been fixed. Closes bug\n  #1163348.\n- Fix possible crash after disconnects when using the threaded interface with\n  TLS.\n- Allow build/install without Python. Closes bug #1174972.\n- Add support for binding connection to a local interface.\n- Implement maximum inflight messages handling.\n- Fix Python client not handling will_payload==None.\n- Fix potential memory leak when setting username/password.\n- Fix handling of QoS 2 messages on reconnect.\n- Improve handling of mosquitto_disconnect() with threaded mode.\n\n\nClients:\n- Add support for TLSv1.2 and TLSv1.1.\n- Sub client can now suppress printing of messages with the retain bit set.\n- Add support for binding connection to a local interface.\n- Implement maximum inflight messages handling for the pub client.\n\n1.1.3 - 20130211\n================\n\nBroker:\n- mosquitto_passwd utility now uses tmpfile() to generate its temporary data\n  storage file. It also creates a backup file that can be used to recover data\n  if an errors occur.\n\nOther:\n- Build script fixes to help packaging on Debian.\n\n1.1.2 - 20130130\n================\n\nClient library:\n- Fix tls_cert_reqs not being set to SSL_VERIFY_PEER by default. This meant\n  that clients were not verifying the server certificate when connecting over\n  TLS. This affects the C, C++ and Python libraries.\n\n1.1.1 - 20130116\n================\n\nBroker:\n- Fix crash on reload if using acl patterns.\n\nClient library:\n- Fix static C++ functions not being exported on Windows. Fixes bug #1098256.\n\n1.1 - 20121219\n==============\n\nBroker:\n- Add $SYS/broker/messages/dropped\n- Add $SYS/broker/clients/expired\n- Replace $SYS/broker/+/per second/+ with moving average versions published at\n  $SYS/broker/load/#\n- Add $SYS/broker/load/sockets/+ and $SYS/broker/load/connections/+\n- Documentation on password file format has been fixed.\n- Disable SSL compression. This reduces memory usage significantly and removes\n  the possibility of CRIME type attacks.\n- Enable SSL_MODE_RELEASE_BUFFERS mode to reduce SSL memory usage further.\n- Add allow_duplicate_messages option.\n- ACL files can now have comment lines with # as the first character.\n- Display message on startup about which config is being loaded.\n- Fix max_inflight_messages and max_queued_messages not being applied.\n- Fix documentation error in mosquitto.conf.\n- Ensure that QoS 2 queued messages are sent out in a timely manner.\n- Local bridges now act on clean_session correctly.\n- Local bridges with clean_session==false now remove unused subscriptions on\n  broker restart.\n- The $SYS/broker/heap/# messages now no longer include \"bytes\" as part of the\n  string for ease of use.\n\nClient library:\n- Free memory used by OpenSSL in mosquitto_lib_cleanup() where possible.\n- Change WebSocket subprotocol name to mqttv3.1 to make future changes easier\n  and for compatibility with other implementations.\n- mosquitto_loop_read() and mosquitto_loop_write() now handle errors\n  themselves rather than having mosquitto_loop() handle their errors. This\n  makes using them in a separate event loop more straightforward.\n- Add mosquitto_loop_forever() / loop_forever() function call to make simple\n  clients easier.\n- Disable SSL compression. This reduces memory usage significantly and removes\n  the possibility of CRIME type attacks.\n- Enable SSL_MODE_RELEASE_BUFFERS mode to reduce SSL memory usage further.\n- mosquitto_tls_set() will now return an error or raise an exception\n  immediately if the CA certificate or client certificate/key cannot be\n  accessed.\n- Fix potential memory leaks on connection failures.\n- Don't produce return error from mosquitto_loop() if a system call is\n  interrupted. This prevents disconnects/reconnects in threaded mode and\n  simplifies non-threaded client handling.\n- Ignore SIGPIPE to prevent unnecessary client quits in threaded mode.\n- Fix document error for mosquitto_message_retry_set().\n- Fix mosquitto_topic_matches_sub() for subscriptions with + as the final\n  character. Fixes bug #1085797.\n- Rename all \"obj\" parameters to \"userdata\" for consistency with other\n  libraries.\n- Reset errno before network read/write to ensure EAGAIN isn't mistakenly\n  returned.\n- The message queue length is now tracked and used to determine the maximum\n  number of packets to process at once. This removes the need for the\n  max_packets parameter which is now unused.\n- Fix incorrect error value in Python error_string() function. Fixes bug\n  #1086777.\n- Reset last message in/out timer in Python module when we send a PINGREQ.\n  Fixes too-early disconnects.\n\nClients:\n- Clients now display their own version number and library version number in\n  their help messages.\n- Fix \"mosquitto_pub -l -q 2\" disconnecting before all messages were\n  transmitted.\n- Fix potential out-of-bounds array access with client ids. Fixes bug\n  #1083182.\n\nOther:\n- mosquitto_passwd can now convert password files with plain text files to\n  hashed versions.\n\n1.0.5 - 20121103\n================\n\nBroker:\n- Fix crash when the broker has use_identity_as_username set to true but a\n  client connects without a certificate.\n- mosquitto_passwd should only be installed if WITH_TLS=yes.\n\nLibrary:\n- Use symbolic errno values rather than numbers in Python module to avoid\n  cross platform issues (incorrect errno on Mac OS).\n\nOther:\n- Build script fixes for FreeBSD.\n\n1.0.4 - 20121017\n================\n\nBroker:\n- Deal with poll() POLLIN/POLLOUT before POLL[RD]HUP to correctly handle the\n  case where a client sends data and immediately closes its socket.\n\nLibrary:\n- Fix memory leak with messages of QoS=2. Fixes bug #1064981.\n- Fix potential thread synchronisation problem with outgoing packets in the\n  Python module. Fixes bug #1064977.\n\nClients:\n- Fix \"mosquitto_sub -l\" incorrectly only sending one message per second.\n\n1.0.3 - 20120927\n================\n\nBroker:\n- Fix loading of psk files.\n- Don't return an error when reloading config if an ACL file isn't defined.\n  This was preventing psk files being reloaded.\n- Clarify meaning of $SYS/broker/clients/total in mosquitto(8) man page.\n- Clarify meaning of $SYS/broker/messages/stored in mosquitto(8) man page.\n- Fix non-retained message delivery when subscribing to #.\n- Fix retained message delivery for subs to foo/# with retained messages at\n  foo.\n- Include the filename in password/acl file loading errors.\n\nLibrary:\n- Fix possible AttributeError when self._sock == None in Python module.\n- Fix reconnecting after a timeout in Python module.\n- Fix reconnecting when there were outgoing packets in the queue in the Python\n  module.\n- Fix problem with mutex initialisation causing crashes on some Windows\n  installations.\n\n1.0.2 - 20120919\n================\n\nBroker:\n- If the broker was configured for persistence, a durable client had a\n  subscription to topics in $SYS/# and had messages in its queue when the\n  broker restarted, then the persistent database would have messages missing\n  and so the broker would not restart properly. This has been fixed.\n\nLibrary:\n- Fix threading problem on some systems.\n\nTests:\n- Close socket after 08-ssl-connect-no-auth-wrong-ca.py test to prevent\n  subsequent tests having problems.\n\nBuild scripts:\n- Install pskfile.example in CMake. Fixes bug #1037504.\n\nOther:\n- Fix db_dump parameter printing message store and sub chunks.\n\n1.0.1 - 20120815\n================\n\nBroker:\n- Fix default log_dest when running as a Windows service.\n\nClient library:\n- Fix incorrect parameters in Python on_log() callback call. Fixes bug\n  #1036818.\n\nClients:\n- Clients now don't display TLS/TLS-PSK usage help if they don't support it.\n\nBuild scripts:\n- Fix TLS-PSK support in the CMake build files.\n- Fix man page installation in the CMake build files.\n- Fix SYSCONFDIR in cmake on *nix when installing to /usr. Fixes bug #1036908.\n\nDocumentation:\n- Fix mqtt/MQTT capitalisation in man pages.\n- Update compiling.txt.\n- Fix incorrect callback docs in mosquitto.py. Fixes bug #1036607.\n- Fix various doc typos and remove obsolete script. Fixes bug #1037088.\n\n1.0 - 20120814\n==============\n\nBroker:\n\n- Add SSL/TLS support.\n- Add TLS-PSK support, providing a simpler encryption method for constrained\n  devices.\n- Passwords are now salted+hashed if compiled with WITH_TLS (recommended).\n- Add mosquitto_passwd for handling password files.\n- Add $SYS/broker/publish/messages/{sent|received} to show the number of\n  PUBLISH messages sent/received.\n- Add $SYS/broker/publish/bytes/{sent|received} to show the number of\n  PUBLISH bytes sent/received.\n- Add reload parameter for security init/cleanup functions.\n- Add option for expiring disconnected persistent clients.\n- Add option for queueing of QoS 0 messages when persistent clients are\n  disconnected.\n- Enforce client id limits in the broker (only when WITH_STRICT_PROTOCOL is\n  defined).\n- Fix reloading of log configuration.\n- Add support for try_private config option for bridge connections.\n- Add support for autosave_on_changes config option.\n- Add support for include_dir config option.\n- Add support for topic remapping.\n- Usernames were being lost when a non clean-session client reconnected,\n  potentially causing problems with ACLs. This has been fixed.\n- Significant improvement to memory handling on Windows.\n- Bridges with outgoing topics will now set the retain flag correctly so that\n  messages will be retained on the remote broker.\n- Incoming bridge connections are now detected by checking if bit 8 of the\n  protocol version number is set. This requires support from the remote broker.\n- Add support for notification_topic option.\n- Add $SYS/broker/subscriptions/count and $SYS/broker/retained messages/count.\n- Add restart_timeout to control the amount of time an automatic bridge will\n  wait before reconnecting.\n- Overlapping subscriptions are now handled properly. Fixes bug #928538.\n- Fix reloading of persistence_file and persistence_location.\n- Fix broker crash on incorrect protocol number.\n- Fix missing COMPAT_ECONNRESET define on Windows.\n- Clients that had disconnected were not always being detected immediately on\n  Linux. This has been fixed.\n- Don't save $SYS messages to the on-disk persistent db. All $SYS messages\n  should be reconstructed on a restart. This means bridge connection\n  notifications will now be correct on a restart.\n- Fix reloading of bridge clients from the persistent db. This means that\n  outgoing bridged topics should always work.\n- Local bridges are now no longer restricted by local ACLs.\n- Discard publish messages with zero length topics.\n- Drop to \"mosquitto\" user even if no config file specified.\n- Don't incorrectly allow topic access if ACL patterns but no normal ACL rules\n  are defined.\n\nClient library:\n\n- Add SSL/TLS support.\n- Add TLS-PSK support, providing a simpler encryption method for constrained\n  devices.\n- Add javascript/websockets client library.\n- Add \"struct mosquitto *mosq\" parameter for all callbacks in the client\n  library. This is a binary incompatible change so the soversion of the\n  libraries has been incremented. The new parameter should make it easier to\n  use callbacks in practice.\n- Add mosquitto_want_write() for use when using own select() loop with\n  mosquitto_socket().\n- Add mosquitto_connect_async() to provide a non-blocking connect client call.\n- Add mosquitto_user_data_set() to allow user data pointer to be updated.\n- Add \"int rc\" parameter to disconnect callback to indicate whether disconnect\n  was unexpected or the result of calling mosquitto_disconnect().\n- Add mosquitto_strerror() for obtaining a string description of error numbers.\n- Add mosquitto_connack_string() for obtaining a string description of MQTT\n  connection results.\n- Add mosquitto_will_clear() and change mosquitto_will_set() to only set the\n  will.\n- Add mosquitto_sub_topic_tokenise() and mosquitto_sub_topic_tokens_free()\n  utility functions to tokenise a subscription/topic string into a string\n  array.\n- Add mosquitto_topic_matches_sub() to check whether a topic matches a\n  subscription.\n- Replaced mosquitto_log_init() with mosquitto_log_callback_set() to allow\n  clients to decide what to do with log messages.\n- Client will now disconnect itself from the broker if it doesn't receive a\n  PINGRESP in the keepalive period after sending a PINGREQ.\n- Client will now send a PINGREQ if it has not received a message from the\n  broker in keepalive seconds.\n- mosquitto_new() will now generate a random client id if the id parameter is\n  NULL.\n- Added max_packets to mosquitto_loop(), mosquitto_loop_read() and\n  mosquitto_loop_write() to control the maximum number of packets that are\n  handled per call.\n- Payload parameters are now void * instead of uint8_t *.\n- The clean_session parameter has been moved from mosquitto_connect() to\n  mosquitto_new() because it is a client parameter rather than a connection\n  parameter.\n- Functions now use int instead of uint*_t where possible.\n- mosquitto_new() now sets errno to indicate failure type.\n- Return MOSQ_ERR_INVAL on zero length topic.\n- Fix automatic client id generation on Windows.\n- mosquitto_loop_misq() can now return MOSQ_ERR_NO_CONN.\n- Compile static library as well as dynamic library with default makefiles.\n- Rename C++ namespace from mosquittopp to mosqpp to remove ambiguity.\n- C++ lib_init(), lib_version() and lib_cleanup() are now in the mosqpp\n  namespace directly, not mosquittopp class members.\n- The Python library is now written in pure Python and so no longer depends on\n  libmosquitto.\n- The Python library includes SSL/TLS support.\n- The Python library should now be compatible with Python 3.\n\nOther:\n\n- Fix db_dump reading of retained messages.\n- Add example of logging all messages to mysql.\n- Add C++ client example.\n- Fix potential buffer overflow in pub/sub clients.\n- Add \"make binary\" target that doesn't make documents.\n- Add \"--help\" arguments to pub/sub clients.\n- Fix building on Solaris.\n\n0.15 - 20120205\n===============\n\n- Add support for $SYS/broker/clients/maximum and $SYS/broker/clients/active\n  topics.\n- Add support for $SYS messages/byte per second received/sent topics.\n- Updated mosquitto man page - $SYS hierarchy and signal support were out of\n  date.\n- Auto generated pub/sub client ids now include the hostname.\n- Tool for dumping persistent DB contents is available in src/db_dump. It isn't\n  installed by default.\n- Enforce topic length checks in client library.\n- Implement \"once\" and \"lazy\" bridge start types.\n- Add new return type MOSQ_ERR_ERRNO to indicate that the errno variable should\n  be checked for the real error code.\n- Add support for connection_messages config option.\n- mosquitto_sub will now refuse to run if the -c option (disable clean session)\n  is given and no client id is provided.\n- mosquitto_pub now gives more useful error messages on invalid input or other\n  error conditions.\n- Fix Python will_set() true/True typo.\n- Fix messages to topic \"a/b\" incorrectly matching on a subscription \"a\" if\n  another subscription \"a/#\" exists.\n\n0.14.4 - 20120106\n=================\n\n- Fix local bridge notification messages.\n- Fix return values for more internal library calls.\n- Fix incorrect out of memory checks in library and broker.\n- Never time out local bridge connections.\n\n0.14.3 - 20111210\n=================\n\n- Fix potential crash when client connects with an invalid CONNECT packet.\n- Fix incorrect invalid socket comparison on Windows.\n- Server shouldn't crash when a message is published to foo/ when a\n  subscription to foo/# exists (bug #901697).\n- SO_REUSEADDR doesn't work the same on Windows, so don't use it.\n- Cygwin builds now support Windows service features.\n- Fix $SYS/broker/bytes/sent reporting.\n\n0.14.2 - 20111123\n=================\n\n- Add uninstall target for libs.\n- Don't try to write packet whilst in a callback.\n\n0.14.1 - 20111117\n=================\n\n- Fix Python sytax errors (bug #891673).\n\n0.14 - 20111116\n===============\n\n- Add support for matching ACLs based on client id and username.\n- Add a Windows installer file (NSIS based).\n- Add native support for running the broker as a Windows service. This is the\n  default when installed using the new installer.\n- Fix client count for listeners. When clients disconnect, decrement the\n  count. Allow max_connections to work again.\n- Attempt to send all packets immediately upon being queued. This will result\n  in more immediate network communication in many cases.\n- Log IP address when reporting CONNACK packets if the client id isn't yet\n  known.\n- Fix payload length calculation in python will_set function.\n- Fix Python publish and will_set functions for payload=None.\n- Fix keepalive value being lost when reconnecting a client (bug #880863).\n- Persistence file writing now uses portable file functions, so the Cygwin\n  broker build should no longer be necessary.\n- Duplicate code between the client and broker side has been reduced.\n- Queued messages for clients reconnecting with clean_session=false set were\n  not being sent until the next message for that client was received. This has\n  been fixed (bug #890724).\n- Fix subscriptions to # incorrectly matching against topics beginning with /\n\n0.13 - 20110920\n===============\n\n- Implement bridge state notification messages.\n- Save client last used mid in persistent database (DB version number bumped).\n- Expose message id in Python MosquittoMessage.\n- It is now possible to set the topic QoS level for bridges.\n- Python MosquittoMessage payload parameter is now a Python string, not a\n  ctypes object which makes it much easier to use.\n- Fix queueing of messages for disconnected clients. The max_queued_messages\n  option is now obeyed.\n- C++ library is now in its own namespace, mosquittopp.\n- Add support for adding log message timestamps in the broker.\n- Fix missing mosquitto_username_pw_set() python binding.\n- Fix keepalive timeout for reconnecting non clean-session clients. Prevents\n  immediate disconnection on reconnection.\n- Fix subscription wildcard matching - a subscription of +/+ will now match\n  against /foo\n- Fix subscription wildcard matching - a subscription of foo/# will now match\n  against foo\n- When restoring persistent database, clients should be set to non\n  clean-session or their subscriptions will be immediately removed.\n- Fix SUBACK payload for multiple topic subscriptions.\n- Don't send retained messages when a client subscribes to a topic it is\n  already subscribed to.\n\n0.12 - 20110725\n===============\n\n- Reload (most) configuration on SIGHUP.\n- Memory tracking is no longer compiled in the client library.\n- Add --help option to mosquitto to display usage.\n- Add --id-prefix option to clients to allow easier use with brokers that are\n  using the clientid_prefix option.\n- Fix compilation on QNX.\n- Add -P as a synonym argument for --pw in the clients.\n- Fix python MosquittoMessage payload parameter. This is now returned as a\n  pointer to an array of c_uint8 values so binary data is handled correctly.\n  If a string is needed, use msg.payload_str\n- Fix memory leaks on client authentication.\n- If password_file is not defined then clients can now connect even if they\n  use a username/password.\n- Add mosquitto_reconnect() to the client library.\n- Add option for compiling with liberal protocol compliance support (enabled\n  by default).\n- Fix problems with clients reconnecting and old messages remaining in the\n  message store.\n- Display both ip and client id in the log message when a client connects.\n  Change the socket connection message to make it more obvious that it is just\n  a socket connection being made (bug #801135).\n- Fix retained message delivery where a subscription contains a +.\n- Be more lenient when reloading persistent database to reduce errors with\n  empty retained messages.\n\n0.11.3 - 20110707\n=================\n\n- Don't complain and quit if persistence_file option is given (bug #802423).\n- Initialise listeners correctly when clients with duplicate client ids\n  connect. Bug #801678.\n- Memory tracking is now disabled for Symbian builds due to lack of malloc.h.\n- Fix memory tracking compilation for kFreeBSD.\n- Python callbacks can now be used with class member functions.\n- Fix persistent database writing of client message chunks which caused\n  errors when restoring (bug #798164).\n\n0.11.2 - 20110626\n=================\n\n- Don't free contexts in mqtt3_context_disconnect() (bug #799688 / #801678).\n- Only free will if present when freeing a client context.\n\n0.11.1 - 20110620\n=================\n\n- Fix buffer overrun when checking for + and # in topics (bug #799688).\n- Pub client now quits if publish fails.\n\n0.11 - 20110619\n===============\n\n- Removed all old sqlite code.\n- Remove client id limit in clients.\n- Implemented $SYS/broker/heap/maximum size\n- Implemented $SYS/broker/clients/inactive to show the number of disconnected\n  non-clean session clients.\n- $SYS/broker/heap/current size and maximum size messages now include \"bytes\"\n  to match rsmb message format.\n- Implemented the retained_persistence config file option - a synonym of the\n  \"persistence\" option.\n- Added security_external.c to broker source to make it easier for third\n  parties to add support for their existing username/password and ACL database\n  for security checks. See external_security_checks.txt.\n- $SYS messages are now only republished when their value changes.\n- Windows native broker now responds to command line arguments.\n- Simplify client disconnecting so wills gets sent in all cases (bug #792468).\n- Clients now have a --quiet option.\n- The on_disconnect() callback will always be called now, even if the client\n  has disconnected unexpectedly.\n- Always close persistent DB file after restoring.\n- Return error code when exiting the clients.\n- mosquitto_publish() now returns MOSQ_ERR_INVAL if the topic contains + or #\n- mosquitto now silently rejects published messages with + or # in the topic.\n- max_connections is now a per-listener setting instead of global.\n- Connection count is now reduced when clients disconnect (bug #797983).\n\n0.10.2 - 20110106\n=================\n\n- Don't abort when connecting if the first connection fails. This is important\n  on e.g. Windows 7, where IPV6 is offered as the first choice but may not be\n  available.\n- Deal with long logging messages properly (bug #785882).\n- Fix library compilation on Symbian - no pselect() available.\n- Don't stop processing subscriptions on received messages after a\n  subscription with # matches. (bug #791206).\n\n0.10.1 - 20110512\n=================\n\n- Fix Windows compilation.\n- Fix mosquitto.py on Windows - call lib init/cleanup.\n- Don't abort when connecting if given an unknown address type (assuming an\n  IPv4 or IPv6 address is given).\n\n0.10 - 20110429\n===============\n\n- Implement support for the password_file option and accompanying\n  authentication requirements in the broker.\n- Implement topic Access Control Lists.\n- mosquitto_will_set() and mosquitto_publish() now return\n  MOSQ_ERR_PAYLOAD_SIZE if the payload is too large (>268,435,455 bytes).\n- Bridge support can now be disabled at compile time.\n- Group together network writes for outgoing packets - don't send single byte\n  writes!\n- Add support for clientid_prefixes variable.\n- Add support for the clientid config variable for controlling bridge client\n  ids.\n- Remove 32-bit database ID support because htobe64() no longer used.\n- Multiple client subscriptions to the same topic result in only a single\n  subscription. Bug #744077.\n\n0.9.3 - 20110310\n================\n\n- Set retained message status for QoS 2 messages (bug #726535).\n- Only abort with an error when opening listening sockets if no address family\n  is available, rather than aborting when any address family is not available.\n- Don't clean queued messages when a non clean session client reconnects.\n- Make mosquitto.py compatible with Python <2.6.\n- Fix mosquitto.h header includes for Windows.\n\n0.9.2 - 20110208\n================\n\n- Only send a single DISCONNECT command when using -l in the pub client.\n- Set QoS=1 on PUBREL commands to meet protocol spec.\n- Don't leak sockets on connection failure in the library.\n- Install man pages when building under cmake.\n- Fix crash bug on malformed CONNECT message.\n- Clients are now rejected if their socket peer name cannot be obtained on\n  connection.\n- Fix a number of potential problems caused when a client with a duplicate id\n  connects.\n- Install mosquitto.conf under cmake.\n\n0.9.1 - 20101203\n================\n\n- Add missing code for parsing the \"bind_address\" configuration option.\n- Fix missing include when compiling with tcp-wrappers support.\n- Add linker version script for C library to control exported functions.\n\n0.9 - 20101114\n==============\n\n- Client and message data is now stored in memory with custom routines rather\n  than a sqlite database. This removes the dependencies on sqlite, pcre and\n  sqlite3-pcre. It also means that the persistent database format has had to\n  be reimplemented in a custom format. Optional support for importing old\n  sqlite databases is provided.\n- Added IPv6 support for mosquitto and the clients.\n- Provide username and password support for the clients and client libraries.\n  This is part of the new MQTT v3.1 spec.\n- The broker supports the username and password connection flags, but will not\n  do anything with the username and password.\n- Python callback functions now optionally take an extra argument which will\n  return the user object passed to the Mosquitto() constructor, or the calling\n  python object itself if nothing was given to Mosquitto().\n- Remove the mosquitto command line option \"-i interface\".\n- Remove the mosquitto.conf \"interface\" variable.\n- Add support for the listener config variable (replaces the interface\n  variable)\n- Add support for the bind_address config variable.\n- Change the port config variable behaviour to match that of rsmb (applies to\n  the default listener only, can be given just once).\n- Fix QoS 2 protocol compliance - stop sending duplicate messages and handle\n  timeouts correctly. Fixes bug #598290.\n- Set retain flag correctly for outgoing messages. It should only be set for\n  messages sent in response to a subscribe command (ie. stale data).\n- Fix bug in returning correct CONNACK result to on_connect client callback.\n- Don't send client will if it is disconnected for exceeding its keepalive\n  timer.\n- Fix client library unsubscribe function incorrectly sending a SUBSCRIBE\n  command when it should be UNSUBSCRIBE.\n- Fix max_inflight_messages and max_queued_messages operation. These\n  parameters now apply only to QoS 1 and 2 messages and are used regardless of\n  the client connection state.\n- mosquitto.conf now installed to /etc/mosquitto/mosquitto.conf instead of\n  /etc/mosquitto.conf. The /etc/mosquitto/ directory will be used for password\n  and access control files in the future.\n- Give the compile time option of using 32-bit integers for the database IDs\n  instead of 64-bit integers. This is useful where htobe64()/be64toh() are not\n  available or for embedded systems for example.\n- The DUP bit is now set correctly when resending PUBREL messages.\n- A port to Windows native has been partially completed. This currently drops a\n  number of features, including the ability to change configuration parameters\n  and persistent storage.\n\n0.8.3 - 20101004\n================\n\n- Fix QoS 2 protocol compliance - stop sending duplicate messages and handle\n  timeouts correctly. Fixes bug #598290. (backported from future 0.9 code)\n\n0.8.2 - 20100815\n================\n\n- Fix default loop() timeout value in mosquitto.py. Previous value was 0,\n  causing high cpu load.\n- Fix message handling problem in client library when more than one message was\n  in the client queue.\n- Fix the logic used to determine whether a QoS>0 message needs to be retried.\n- Fix the Python sub.py example so that it quits on error.\n\n0.8.1 - 20100812\n================\n\n- Improve python interface\n- Fix incorrect return value from message delete function\n- Use logging function to print error messages in clients.\n- Fix python installation script DESTDIR.\n- Fix library destination path for 64-bit machines.\n\n0.8 - 20100807\n==============\n\n- Topics starting with a / are treated as distinct to those not starting with\n  a /. For example, /topic/path is different to topic/path. This matches the\n  behaviour of rsmb.\n- Correctly calculate the will QoS on a new client connection (bug #597451).\n- Add \"addresses\" configuration file variable as an alias of \"address\", for\n  better rsmb compatibility.\n- Bridge clean_session setting is now false, to give more sensible behaviour\n  and be more compatible with rsmb.\n- Add cleansession variable for configuring bridges.\n- Add keepalive_interval variable for bridges.\n- Remove default topic subscription for mosquitto_sub because the old\n  behaviour was too confusing.\n- Added a C client library, which the pub and sub clients now use.\n- Added a C++ client library (bound to the C library).\n- Added a Python client library (bound to the C library).\n- Added CMake build scripts to allow the library and clients (not the broker)\n  to be compiled natively on Windows.\n\n0.7 - 20100615\n==============\n\n- mosquitto_pub can now send null (zero length) messages.\n- Don't store QoS=0 messages for disconnected clients with subscriptions of\n  QoS>0.\n- accept() all available sockets when new clients are connecting, rather than\n  just one.\n- Add option to print debug messages in pub and sub clients.\n- hg revision is now exported via $SYS/broker/changeset\n- Send Will when client exceeds keepalive timer and is disconnected.\n- Check to see if a client has a will before sending it.\n- Correctly deal with clients connecting with the same id multiple times.\n- Add compile time option to disable heap memory tracking.\n- Use poll() instead of select() to allow >1024 clients.\n- Implement max_connections.\n- Run VACUUM on in-memory database on receiving SIGUSR2.\n- Fix bridge keepalive timeouts and reconnects.\n- Don't attempt to drop root privileges when running on Windows as this isn't\n  well supported (bug #586231).\n\n0.6.1 - 20100506\n================\n\n- Fix DB auto upgrade for messages table.\n\n0.6 - 20100505\n==============\n\n- Basic support for connecting multiple MQTT brokers together (bridging).\n- mosquitto_sub can now subscribe to multiple topics (limited to a global QoS).\n- mosquitto_pub can now send a file as a message.\n- mosquitto_pub can now read all of stdin and send it as a message.\n- mosquitto_pub can now read stdin and send each line as a message.\n- mosquitto will now correctly run VACUUM on the persistent database on exit.\n- Implement a more efficient database design, so that only one copy of each\n  message is held in the database, rather than one per subscribed client.\n- Add the store_cleanup_interval config option for dealing with the internal\n  message store.\n- Add support for disabling \"clean session\" for the sub client.\n- Add support for automatic upgrading of the mosquitto DB from v1 to v2.\n- Add persistence_file config option to allow changing the filename of the\n  persistence database. This allows multiple mosquitto DBs to be stored in the\n  same location whilst keeping persistence_location compatible with rsmb.\n- Don't store QoS=0 messages for disconnected clients. Fixes bug #572608. This\n  wasn't correctly fixed in version 0.5.\n- Don't disconnect clients if they send a PUBLISH with zero length payload\n  (bug #573610).\n- If a retained message is received with a zero length payload, the retained\n  message for that topic is deleted.\n- Send through zero length messages.\n- Produce a warning on unsupported rsmb options instead of quitting.\n- Describe clean session flag in the mqtt man page.\n- Implement the max_inflight_messages and max_queued_messages features in the\n  broker.\n\n0.5.4 - 20100311\n================\n\n- Fix memory allocation in mqtt3_fix_sub_topic() (bug #531861).\n- Remove accidental limit of 100 client connections.\n- Fix mosquitto_pub handling of messages with QoS>0 (bug #537061).\n\n0.5.3 - 20100303\n================\n\n- Will messages are now only sent when a client disconnects unexpectedly.\n- Fix all incoming topics/subscriptions that start with a / or contain\n  multiple / in a row (//).\n- Do actually disconnect client when it sends an empty subscription/topic string.\n- Add missing $SYS/broker/clients/total to man page.\n\n0.5.2 - 20100302\n================\n\n- Always update last backup time, so that the backup doesn't run every time\n  through the main loop once autosave_interval has been reached.\n- Report $SYS/broker/uptime in the same format as rsmb.\n- Make mandatory options obvious in usage output and man page of mosquitto_pub.\n  Fixes bug #529990.\n- Treat subscriptions with a trailing slash correctly. This should fix bugs\n  #530369 and #530099.\n\n0.5.1 - 20100227\n================\n\n- Must daemonise before pid file is written.\n\n0.5 - 20100227\n==============\n\n- No longer store QoS=0 messages for disconnected clients that do not have\n  clean start set.\n- Rename msg_timeout option to retry_interval for better rsmb compatibility.\n- Change persistence behaviour. The database is now stored in memory even if\n  persistence is enabled. It is written to disk when mosquitto exits and also at\n  periodic intervals as defined by the new autosave_interval option.\n- The writing of the persistence database may be forced by sending mosquitto\n  the SIGUSR1 signal.\n- Clients that do not send CONNECT as their first command are now\n  disconnected.\n- Boolean configuration values may now be specified with true/false as well as\n  1/0.\n- Log message on CONNECT with invalid protocol or protocol version.\n- Default sqlite3-pcre path on Linux is now /usr/lib/sqlite3/pcre.so to match\n  future sqlite3-pcre packages.\n- Add mosquitto_sub and mosquitto_pub, simple clients for subscribe/publish.\n- Add man pages for clients.\n- Add general man page on mqtt.\n- Root privileges are now dropped only after attempting to write a pid file\n  (if configured). This means that the pid file can be written to /var/run/\n  directly and should fix bug #523183.\n\n0.4.2 - 20100203\n================\n\n- Fix segfault on client connect with invalid protocol name/version.\n\n0.4.1 - 20100112\n===============\n\n- Fix regex used for finding retained messages to send on new subscription.\n\n0.4 - 20100105\n==============\n\n- Added support for wildcard subscriptions using + and #.\n- All network operations are now non-blocking and can cope with partial\n  packets, meaning that networking should be a lot more reliable.\n- Total messsages/bytes sent/received are now available in $SYS.\n- Improved logging information - use client ip address and id instead of\n  socket number.\n- Broker build timestamp is available in $SYS.\n- Keepalive==0 is now correctly treated as \"never disconnect\".\n- Fixed manpage installation.\n- Fixed incorrect $SYS hierarchy locations in documentation and code.\n- Debug type log messages are no longer sent to \"topics\".\n- Default logging destination no longer includes \"topics\" to prevent possible\n  error logging to the db before it is initialised.\n- Periodic $SYS messages can now be disabled.\n- stdout and stderr are flushed when logging to them to give more timely\n  updates.\n- dup is now set correctly when resending messages.\n- Database format bumped due to topic column naming fix.\n\n0.3 - 20091217\n==============\n\n- The port option in the configuration file and --port command line argument\n  may now be given any number of times to make mosquitto listen on multiple\n  sockets.\n- Add new config file and command line option \"interface\" to specify an\n  interface to listen on, rather than all interfaces.\n- Added host access control through tcp-wrappers support.\n- Set SO_REUSEADDR on the listening socket so restart is much quicker.\n- Added support for tracking current heap memory usage - this is published on\n  the topic \"$SYS/broker/heap/current size\"\n- Added code for logging to stderr, stdout, syslog and topics.\n- Added logging to numerous places - still plenty of scope for more.\n\n0.2 - 20091204\n==============\n\n- Replaced the command line option --foreground with --daemon, swapping the\n  default behaviour.\n- Added the command line option --config-file, to specify a config file to\n  load.  If this is not given, no config file is load and the default options\n  are used.\n- Added the command line option --port for specifying the port to listen on.\n  This overrides values in the config file.\n- Don't use persistence by default.\n- Default behaviour is now more sane when run by a normal user with no command\n  line options (combination of above changes).\n- Added option user to config file, defaulting to a value of mosquitto. If\n  this value isn't blank and mosquitto is started by root, then it will drop\n  privileges by changing to the user and its primary group. This replaces the\n  current behaviour of refusing to start if run by root.\n- Fix non-persistent mode, which would never work in the previous release.\n- Added information on default values of msg_timeout and sys_interval to the\n  mosquitto.conf man page. (closes bug #492045).\n", "/*\nCopyright (c) 2009-2018 Roger Light <roger@atchoo.org>\n\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nand Eclipse Distribution License v1.0 which accompany this distribution.\n\nThe Eclipse Public License is available at\n   http://www.eclipse.org/legal/epl-v10.html\nand the Eclipse Distribution License is available at\n  http://www.eclipse.org/org/documents/edl-v10.php.\n\nContributors:\n   Roger Light - initial implementation and documentation.\n*/\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef WIN32\n#else\n#  include <dirent.h>\n#  include <strings.h>\n#endif\n\n#ifndef WIN32\n#  include <netdb.h>\n#  include <sys/socket.h>\n#else\n#  include <winsock2.h>\n#  include <ws2tcpip.h>\n#endif\n\n#if !defined(WIN32) && !defined(__CYGWIN__)\n#  include <syslog.h>\n#endif\n\n#include \"mosquitto_broker_internal.h\"\n#include \"memory_mosq.h\"\n#include \"tls_mosq.h\"\n#include \"util_mosq.h\"\n#include \"mqtt3_protocol.h\"\n\nstruct config_recurse {\n\tint log_dest;\n\tint log_dest_set;\n\tint log_type;\n\tint log_type_set;\n\tunsigned long max_inflight_bytes;\n\tunsigned long max_queued_bytes;\n\tint max_inflight_messages;\n\tint max_queued_messages;\n};\n\n#if defined(WIN32) || defined(__CYGWIN__)\n#include <windows.h>\nextern SERVICE_STATUS_HANDLE service_handle;\n#endif\n\nstatic int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr);\nstatic int conf__parse_int(char **token, const char *name, int *value, char *saveptr);\nstatic int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr);\nstatic int conf__parse_string(char **token, const char *name, char **value, char *saveptr);\nstatic int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *config_tmp, int level, int *lineno);\nstatic int config__check(struct mosquitto__config *config);\nstatic void config__cleanup_plugins(struct mosquitto__config *config);\n\nstatic char *fgets_extending(char **buf, int *buflen, FILE *stream)\n{\n\tchar *rc;\n\tchar endchar;\n\tint offset = 0;\n\tchar *newbuf;\n\n\tdo{\n\t\trc = fgets(&((*buf)[offset]), *buflen-offset, stream);\n\t\tif(feof(stream)){\n\t\t\treturn rc;\n\t\t}\n\n\t\tendchar = (*buf)[strlen(*buf)-1];\n\t\tif(endchar == '\\n'){\n\t\t\treturn rc;\n\t\t}\n\t\t/* No EOL char found, so extend buffer */\n\t\toffset = *buflen-1;\n\t\t*buflen += 1000;\n\t\tnewbuf = realloc(*buf, *buflen);\n\t\tif(!newbuf){\n\t\t\treturn NULL;\n\t\t}\n\t\t*buf = newbuf;\n\t}while(1);\n}\n\n\nstatic void conf__set_cur_security_options(struct mosquitto__config *config, struct mosquitto__listener *cur_listener, struct mosquitto__security_options **security_options)\n{\n\tif(config->per_listener_settings){\n\t\t(*security_options) = &cur_listener->security_options;\n\t}else{\n\t\t(*security_options) = &config->security_options;\n\t}\n}\n\nstatic int conf__attempt_resolve(const char *host, const char *text, int log, const char *msg)\n{\n\tstruct addrinfo gai_hints;\n\tstruct addrinfo *gai_res;\n\tint rc;\n\n\tmemset(&gai_hints, 0, sizeof(struct addrinfo));\n\tgai_hints.ai_family = AF_UNSPEC;\n\tgai_hints.ai_socktype = SOCK_STREAM;\n\tgai_res = NULL;\n\trc = getaddrinfo(host, NULL, &gai_hints, &gai_res);\n\tif(gai_res){\n\t\tfreeaddrinfo(gai_res);\n\t}\n\tif(rc != 0){\n#ifndef WIN32\n\t\tif(rc == EAI_SYSTEM){\n\t\t\tif(errno == ENOENT){\n\t\t\t\tlog__printf(NULL, log, \"%s: Unable to resolve %s %s.\", msg, text, host);\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s: %s.\", msg, text, strerror(errno));\n\t\t\t}\n\t\t}else{\n\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s: %s.\", msg, text, gai_strerror(rc));\n\t\t}\n#else\n\t\tif(rc == WSAHOST_NOT_FOUND){\n\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s.\", msg, text);\n\t\t}\n#endif\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nstatic void config__init_reload(struct mosquitto_db *db, struct mosquitto__config *config)\n{\n\tint i;\n\t/* Set defaults */\n\tfor(i=0; i<config->listener_count; i++){\n\t\tmosquitto__free(config->listeners[i].security_options.acl_file);\n\t\tconfig->listeners[i].security_options.acl_file = NULL;\n\n\t\tmosquitto__free(config->listeners[i].security_options.password_file);\n\t\tconfig->listeners[i].security_options.password_file = NULL;\n\n\t\tmosquitto__free(config->listeners[i].security_options.psk_file);\n\t\tconfig->listeners[i].security_options.psk_file = NULL;\n\n\t\tconfig->listeners[i].security_options.allow_anonymous = -1;\n\t\tconfig->listeners[i].security_options.allow_zero_length_clientid = true;\n\t\tconfig->listeners[i].security_options.auto_id_prefix = NULL;\n\t\tconfig->listeners[i].security_options.auto_id_prefix_len = 0;\n\t}\n\n\tconfig->allow_duplicate_messages = false;\n\n\tmosquitto__free(config->security_options.acl_file);\n\tconfig->security_options.acl_file = NULL;\n\n\tconfig->security_options.allow_anonymous = -1;\n\tconfig->security_options.allow_zero_length_clientid = true;\n\tconfig->security_options.auto_id_prefix = NULL;\n\tconfig->security_options.auto_id_prefix_len = 0;\n\n\tmosquitto__free(config->security_options.password_file);\n\tconfig->security_options.password_file = NULL;\n\n\tmosquitto__free(config->security_options.psk_file);\n\tconfig->security_options.psk_file = NULL;\n\n\tconfig->autosave_interval = 1800;\n\tconfig->autosave_on_changes = false;\n\tmosquitto__free(config->clientid_prefixes);\n\tconfig->connection_messages = true;\n\tconfig->clientid_prefixes = NULL;\n\tconfig->per_listener_settings = false;\n\tif(config->log_fptr){\n\t\tfclose(config->log_fptr);\n\t\tconfig->log_fptr = NULL;\n\t}\n\tmosquitto__free(config->log_file);\n\tconfig->log_file = NULL;\n\n#if defined(WIN32) || defined(__CYGWIN__)\n\tif(service_handle){\n\t\t/* This is running as a Windows service. Default to no logging. Using\n\t\t * stdout/stderr is forbidden because the first clients to connect will\n\t\t * get log information sent to them for some reason. */\n\t\tconfig->log_dest = MQTT3_LOG_NONE;\n\t}else{\n\t\tconfig->log_dest = MQTT3_LOG_STDERR;\n\t}\n#else\n\tconfig->log_facility = LOG_DAEMON;\n\tconfig->log_dest = MQTT3_LOG_STDERR;\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}else{\n\t\tconfig->log_type = MOSQ_LOG_ERR | MOSQ_LOG_WARNING | MOSQ_LOG_NOTICE | MOSQ_LOG_INFO;\n\t}\n#endif\n\tconfig->log_timestamp = true;\n\tconfig->persistence = false;\n\tmosquitto__free(config->persistence_location);\n\tconfig->persistence_location = NULL;\n\tmosquitto__free(config->persistence_file);\n\tconfig->persistence_file = NULL;\n\tconfig->persistent_client_expiration = 0;\n\tconfig->queue_qos0_messages = false;\n\tconfig->set_tcp_nodelay = false;\n\tconfig->sys_interval = 10;\n\tconfig->upgrade_outgoing_qos = false;\n\n\tconfig__cleanup_plugins(config);\n}\n\n\nstatic void config__cleanup_plugins(struct mosquitto__config *config)\n{\n\tint i, j;\n\tstruct mosquitto__auth_plugin_config *plug;\n\n\tif(config->security_options.auth_plugin_configs){\n\t\tfor(i=0; i<config->security_options.auth_plugin_config_count; i++){\n\t\t\tplug = &config->security_options.auth_plugin_configs[i];\n\t\t\tmosquitto__free(plug->path);\n\t\t\tplug->path = NULL;\n\n\t\t\tif(plug->options){\n\t\t\t\tfor(j=0; j<plug->option_count; j++){\n\t\t\t\t\tmosquitto__free(plug->options[j].key);\n\t\t\t\t\tmosquitto__free(plug->options[j].value);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(plug->options);\n\t\t\t\tplug->options = NULL;\n\t\t\t\tplug->option_count = 0;\n\t\t\t}\n\t\t}\n\t\tmosquitto__free(config->security_options.auth_plugin_configs);\n\t\tconfig->security_options.auth_plugin_configs = NULL;\n\t}\n}\n\n\nvoid config__init(struct mosquitto_db *db, struct mosquitto__config *config)\n{\n\tmemset(config, 0, sizeof(struct mosquitto__config));\n\tconfig__init_reload(db, config);\n\n\tconfig->daemon = false;\n\tmemset(&config->default_listener, 0, sizeof(struct mosquitto__listener));\n\tconfig->default_listener.max_connections = -1;\n\tconfig->default_listener.protocol = mp_mqtt;\n\tconfig->default_listener.security_options.allow_anonymous = -1;\n}\n\nvoid config__cleanup(struct mosquitto__config *config)\n{\n\tint i;\n\tint j;\n\n\tmosquitto__free(config->clientid_prefixes);\n\tmosquitto__free(config->persistence_location);\n\tmosquitto__free(config->persistence_file);\n\tmosquitto__free(config->persistence_filepath);\n\tmosquitto__free(config->security_options.auto_id_prefix);\n\tmosquitto__free(config->security_options.acl_file);\n\tmosquitto__free(config->security_options.password_file);\n\tmosquitto__free(config->security_options.psk_file);\n\tmosquitto__free(config->pid_file);\n\tif(config->listeners){\n\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\tmosquitto__free(config->listeners[i].host);\n\t\t\tmosquitto__free(config->listeners[i].mount_point);\n\t\t\tmosquitto__free(config->listeners[i].socks);\n\t\t\tmosquitto__free(config->listeners[i].security_options.auto_id_prefix);\n\t\t\tmosquitto__free(config->listeners[i].security_options.acl_file);\n\t\t\tmosquitto__free(config->listeners[i].security_options.password_file);\n\t\t\tmosquitto__free(config->listeners[i].security_options.psk_file);\n#ifdef WITH_TLS\n\t\t\tmosquitto__free(config->listeners[i].cafile);\n\t\t\tmosquitto__free(config->listeners[i].capath);\n\t\t\tmosquitto__free(config->listeners[i].certfile);\n\t\t\tmosquitto__free(config->listeners[i].keyfile);\n\t\t\tmosquitto__free(config->listeners[i].ciphers);\n\t\t\tmosquitto__free(config->listeners[i].psk_hint);\n\t\t\tmosquitto__free(config->listeners[i].crlfile);\n\t\t\tmosquitto__free(config->listeners[i].tls_version);\n#ifdef WITH_WEBSOCKETS\n\t\t\tif(!config->listeners[i].ws_context) /* libwebsockets frees its own SSL_CTX */\n#endif\n\t\t\t{\n\t\t\t\tSSL_CTX_free(config->listeners[i].ssl_ctx);\n\t\t\t}\n#endif\n#ifdef WITH_WEBSOCKETS\n\t\t\tmosquitto__free(config->listeners[i].http_dir);\n#endif\n\t\t}\n\t\tmosquitto__free(config->listeners);\n\t}\n#ifdef WITH_BRIDGE\n\tif(config->bridges){\n\t\tfor(i=0; i<config->bridge_count; i++){\n\t\t\tmosquitto__free(config->bridges[i].name);\n\t\t\tif(config->bridges[i].addresses){\n\t\t\t\tfor(j=0; j<config->bridges[i].address_count; j++){\n\t\t\t\t\tmosquitto__free(config->bridges[i].addresses[j].address);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(config->bridges[i].addresses);\n\t\t\t}\n\t\t\tmosquitto__free(config->bridges[i].remote_clientid);\n\t\t\tmosquitto__free(config->bridges[i].remote_username);\n\t\t\tmosquitto__free(config->bridges[i].remote_password);\n\t\t\tmosquitto__free(config->bridges[i].local_clientid);\n\t\t\tmosquitto__free(config->bridges[i].local_username);\n\t\t\tmosquitto__free(config->bridges[i].local_password);\n\t\t\tif(config->bridges[i].topics){\n\t\t\t\tfor(j=0; j<config->bridges[i].topic_count; j++){\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].topic);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].local_prefix);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].remote_prefix);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].local_topic);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].remote_topic);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(config->bridges[i].topics);\n\t\t\t}\n\t\t\tmosquitto__free(config->bridges[i].notification_topic);\n#ifdef WITH_TLS\n\t\t\tmosquitto__free(config->bridges[i].tls_version);\n\t\t\tmosquitto__free(config->bridges[i].tls_cafile);\n#ifdef WITH_TLS_PSK\n\t\t\tmosquitto__free(config->bridges[i].tls_psk_identity);\n\t\t\tmosquitto__free(config->bridges[i].tls_psk);\n#endif\n#endif\n\t\t}\n\t\tmosquitto__free(config->bridges);\n\t}\n#endif\n\tconfig__cleanup_plugins(config);\n\n\tif(config->log_fptr){\n\t\tfclose(config->log_fptr);\n\t\tconfig->log_fptr = NULL;\n\t}\n\tif(config->log_file){\n\t\tmosquitto__free(config->log_file);\n\t\tconfig->log_file = NULL;\n\t}\n}\n\nstatic void print_usage(void)\n{\n\tprintf(\"mosquitto version %s\\n\\n\", VERSION);\n\tprintf(\"mosquitto is an MQTT v3.1.1 broker.\\n\\n\");\n\tprintf(\"Usage: mosquitto [-c config_file] [-d] [-h] [-p port]\\n\\n\");\n\tprintf(\" -c : specify the broker config file.\\n\");\n\tprintf(\" -d : put the broker into the background after starting.\\n\");\n\tprintf(\" -h : display this help.\\n\");\n\tprintf(\" -p : start the broker listening on the specified port.\\n\");\n\tprintf(\"      Not recommended in conjunction with the -c option.\\n\");\n\tprintf(\" -v : verbose mode - enable all logging types. This overrides\\n\");\n\tprintf(\"      any logging options given in the config file.\\n\");\n\tprintf(\"\\nSee http://mosquitto.org/ for more information.\\n\\n\");\n}\n\nint config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n\t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n\t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n#endif\n\t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}\n\nvoid config__copy(struct mosquitto__config *src, struct mosquitto__config *dest)\n{\n\tmosquitto__free(dest->security_options.acl_file);\n\tdest->security_options.acl_file = src->security_options.acl_file;\n\n\tdest->security_options.allow_anonymous = src->security_options.allow_anonymous;\n\tdest->security_options.allow_zero_length_clientid = src->security_options.allow_zero_length_clientid;\n\n\tmosquitto__free(dest->security_options.auto_id_prefix);\n\tdest->security_options.auto_id_prefix = src->security_options.auto_id_prefix;\n\tdest->security_options.auto_id_prefix_len = src->security_options.auto_id_prefix_len;\n\n\tmosquitto__free(dest->security_options.password_file);\n\tdest->security_options.password_file = src->security_options.password_file;\n\n\tmosquitto__free(dest->security_options.psk_file);\n\tdest->security_options.psk_file = src->security_options.psk_file;\n\n\n\tdest->allow_duplicate_messages = src->allow_duplicate_messages;\n\n\n\tdest->autosave_interval = src->autosave_interval;\n\tdest->autosave_on_changes = src->autosave_on_changes;\n\n\tmosquitto__free(dest->clientid_prefixes);\n\tdest->clientid_prefixes = src->clientid_prefixes;\n\n\tdest->connection_messages = src->connection_messages;\n\tdest->log_dest = src->log_dest;\n\tdest->log_facility = src->log_facility;\n\tdest->log_type = src->log_type;\n\tdest->log_timestamp = src->log_timestamp;\n\n\tmosquitto__free(dest->log_file);\n\tdest->log_file = src->log_file;\n\n\tdest->message_size_limit = src->message_size_limit;\n\n\tdest->persistence = src->persistence;\n\n\tmosquitto__free(dest->persistence_location);\n\tdest->persistence_location = src->persistence_location;\n\n\tmosquitto__free(dest->persistence_file);\n\tdest->persistence_file = src->persistence_file;\n\n\tmosquitto__free(dest->persistence_filepath);\n\tdest->persistence_filepath = src->persistence_filepath;\n\n\tdest->persistent_client_expiration = src->persistent_client_expiration;\n\n\n\tdest->queue_qos0_messages = src->queue_qos0_messages;\n\tdest->sys_interval = src->sys_interval;\n\tdest->upgrade_outgoing_qos = src->upgrade_outgoing_qos;\n\n#ifdef WITH_WEBSOCKETS\n\tdest->websockets_log_level = src->websockets_log_level;\n#endif\n}\n\n\nint config__read(struct mosquitto_db *db, struct mosquitto__config *config, bool reload)\n{\n\tint rc = MOSQ_ERR_SUCCESS;\n\tstruct config_recurse cr;\n\tint lineno = 0;\n\tint len;\n\tstruct mosquitto__config config_reload;\n\tint i;\n\n\tif(reload){\n\t\tmemset(&config_reload, 0, sizeof(struct mosquitto__config));\n\t}\n\n\tcr.log_dest = MQTT3_LOG_NONE;\n\tcr.log_dest_set = 0;\n\tcr.log_type = MOSQ_LOG_NONE;\n\tcr.log_type_set = 0;\n\tcr.max_inflight_bytes = 0;\n\tcr.max_inflight_messages = 20;\n\tcr.max_queued_bytes = 0;\n\tcr.max_queued_messages = 100;\n\n\tif(!db->config_file) return 0;\n\n\tif(reload){\n\t\t/* Re-initialise appropriate config vars to default for reload. */\n\t\tconfig__init_reload(db, &config_reload);\n\t\tconfig_reload.listeners = config->listeners;\n\t\tconfig_reload.listener_count = config->listener_count;\n\t\trc = config__read_file(&config_reload, reload, db->config_file, &cr, 0, &lineno);\n\t}else{\n\t\trc = config__read_file(config, reload, db->config_file, &cr, 0, &lineno);\n\t}\n\tif(rc){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", db->config_file, lineno);\n\t\treturn rc;\n\t}\n\n\tif(reload){\n\t\tconfig__copy(&config_reload, config);\n\t}\n\n\t/* If auth/access options are set and allow_anonymous not explicitly set, disallow anon. */\n\tif(config->per_listener_settings){\n\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\tif(config->listeners[i].security_options.allow_anonymous == -1){\n\t\t\t\tif(config->listeners[i].security_options.password_file\n\t\t\t\t\t|| config->listeners[i].security_options.psk_file\n\t\t\t\t\t|| config->listeners[i].security_options.auth_plugin_configs){\n\n\t\t\t\t\t/* allow_anonymous not set explicitly, some other security options\n\t\t\t\t\t* have been set - so disable allow_anonymous\n\t\t\t\t\t*/\n\t\t\t\t\tconfig->listeners[i].security_options.allow_anonymous = false;\n\t\t\t\t}else{\n\t\t\t\t\t/* Default option if no security options set */\n\t\t\t\t\tconfig->listeners[i].security_options.allow_anonymous = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(config->security_options.allow_anonymous == -1){\n\t\t\tif(config->security_options.password_file\n\t\t\t\t || config->security_options.psk_file\n\t\t\t\t || config->security_options.auth_plugin_configs){\n\n\t\t\t\t/* allow_anonymous not set explicitly, some other security options\n\t\t\t\t* have been set - so disable allow_anonymous\n\t\t\t\t*/\n\t\t\t\tconfig->security_options.allow_anonymous = false;\n\t\t\t}else{\n\t\t\t\t/* Default option if no security options set */\n\t\t\t\tconfig->security_options.allow_anonymous = true;\n\t\t\t}\n\t\t}\n\t}\n#ifdef WITH_PERSISTENCE\n\tif(config->persistence){\n\t\tif(!config->persistence_file){\n\t\t\tconfig->persistence_file = mosquitto__strdup(\"mosquitto.db\");\n\t\t\tif(!config->persistence_file) return MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmosquitto__free(config->persistence_filepath);\n\t\tif(config->persistence_location && strlen(config->persistence_location)){\n\t\t\tlen = strlen(config->persistence_location) + strlen(config->persistence_file) + 1;\n\t\t\tconfig->persistence_filepath = mosquitto__malloc(len);\n\t\t\tif(!config->persistence_filepath) return MOSQ_ERR_NOMEM;\n\t\t\tsnprintf(config->persistence_filepath, len, \"%s%s\", config->persistence_location, config->persistence_file);\n\t\t}else{\n\t\t\tconfig->persistence_filepath = mosquitto__strdup(config->persistence_file);\n\t\t\tif(!config->persistence_filepath) return MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n#endif\n\t/* Default to drop to mosquitto user if no other user specified. This must\n\t * remain here even though it is covered in config__parse_args() because this\n\t * function may be called on its own. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\n\tdb__limits_set(cr.max_inflight_messages, cr.max_inflight_bytes, cr.max_queued_messages, cr.max_queued_bytes);\n\n#ifdef WITH_BRIDGE\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tif(!config->bridges[i].name || !config->bridges[i].addresses || !config->bridges[i].topic_count){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n#ifdef WITH_TLS_PSK\n\t\tif(config->bridges[i].tls_psk && !config->bridges[i].tls_psk_identity){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration: missing bridge_identity.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\tif(config->bridges[i].tls_psk_identity && !config->bridges[i].tls_psk){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration: missing bridge_psk.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n#endif\n\t}\n#endif\n\n\tif(cr.log_dest_set){\n\t\tconfig->log_dest = cr.log_dest;\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}else if(cr.log_type_set){\n\t\tconfig->log_type = cr.log_type;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nint config__read_file_core(struct mosquitto__config *config, bool reload, struct config_recurse *cr, int level, int *lineno, FILE *fptr, char **buf, int *buflen)\n{\n\tint rc;\n\tchar *token;\n\tint tmp_int;\n\tchar *saveptr = NULL;\n#ifdef WITH_BRIDGE\n\tchar *tmp_char;\n\tstruct mosquitto__bridge *cur_bridge = NULL;\n\tstruct mosquitto__bridge_topic *cur_topic;\n#endif\n\tstruct mosquitto__auth_plugin_config *cur_auth_plugin_config = NULL;\n\n\ttime_t expiration_mult;\n\tchar *key;\n\tchar *conf_file;\n#ifdef WIN32\n\tHANDLE fh;\n\tchar dirpath[MAX_PATH];\n\tWIN32_FIND_DATA find_data;\n#else\n\tDIR *dh;\n\tstruct dirent *de;\n#endif\n\tint len;\n\tstruct mosquitto__listener *cur_listener = &config->default_listener;\n\tint i;\n\tint lineno_ext;\n\tstruct mosquitto__security_options *cur_security_options = NULL;\n\n\t*lineno = 0;\n\n\twhile(fgets_extending(buf, buflen, fptr)){\n\t\t(*lineno)++;\n\t\tif((*buf)[0] != '#' && (*buf)[0] != 10 && (*buf)[0] != 13){\n\t\t\twhile((*buf)[strlen((*buf))-1] == 10 || (*buf)[strlen((*buf))-1] == 13){\n\t\t\t\t(*buf)[strlen((*buf))-1] = 0;\n\t\t\t}\n\t\t\ttoken = strtok_r((*buf), \" \", &saveptr);\n\t\t\tif(token){\n\t\t\t\tif(!strcmp(token, \"acl_file\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->acl_file);\n\t\t\t\t\t\tcur_security_options->acl_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"acl_file\", &cur_security_options->acl_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"address\") || !strcmp(token, \"addresses\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge || cur_bridge->addresses){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\twhile((token = strtok_r(NULL, \" \", &saveptr))){\n\t\t\t\t\t\tcur_bridge->address_count++;\n\t\t\t\t\t\tcur_bridge->addresses = mosquitto__realloc(cur_bridge->addresses, sizeof(struct bridge_address)*cur_bridge->address_count);\n\t\t\t\t\t\tif(!cur_bridge->addresses){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->addresses[cur_bridge->address_count-1].address = token;\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=0; i<cur_bridge->address_count; i++){\n\t\t\t\t\t\t/* cur_bridge->addresses[i].address is now\n\t\t\t\t\t\t * \"address[:port]\". If address is an IPv6 address,\n\t\t\t\t\t\t * then port is required. We must check for the :\n\t\t\t\t\t\t * backwards. */\n\t\t\t\t\t\ttmp_char = strrchr(cur_bridge->addresses[i].address, ':');\n\t\t\t\t\t\tif(tmp_char){\n\t\t\t\t\t\t\t/* Remove ':', so cur_bridge->addresses[i].address\n\t\t\t\t\t\t\t * now just looks like the address. */\n\t\t\t\t\t\t\ttmp_char[0] = '\\0';\n\n\t\t\t\t\t\t\t/* The remainder of the string */\n\t\t\t\t\t\t\ttmp_int = atoi(&tmp_char[1]);\n\t\t\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur_bridge->addresses[i].port = tmp_int;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_bridge->addresses[i].port = 1883;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* This looks a bit weird, but isn't. Before this\n\t\t\t\t\t\t * call, cur_bridge->addresses[i].address points\n\t\t\t\t\t\t * to the tokenised part of the line, it will be\n\t\t\t\t\t\t * reused in a future parse of a config line so we\n\t\t\t\t\t\t * must duplicate it. */\n\t\t\t\t\t\tcur_bridge->addresses[i].address = mosquitto__strdup(cur_bridge->addresses[i].address);\n\t\t\t\t\t\tconf__attempt_resolve(cur_bridge->addresses[i].address, \"bridge address\", MOSQ_LOG_WARNING, \"Warning\");\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->address_count == 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty address value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"allow_anonymous\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_anonymous\", (bool *)&cur_security_options->allow_anonymous, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"allow_duplicate_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_duplicate_messages\", &config->allow_duplicate_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"allow_zero_length_clientid\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_zero_length_clientid\", &cur_security_options->allow_zero_length_clientid, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strncmp(token, \"auth_opt_\", 9)){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tif(!cur_auth_plugin_config){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: An auth_opt_ option exists in the config file without an auth_plugin.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(strlen(token) < 12){\n\t\t\t\t\t\t/* auth_opt_ == 9, + one digit key == 10, + one space == 11, + one value == 12 */\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid auth_opt_ config option.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tkey = mosquitto__strdup(&token[9]);\n\t\t\t\t\tif(!key){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t}else if(STREMPTY(key)){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid auth_opt_ config option.\");\n\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken += 9+strlen(key)+1;\n\t\t\t\t\twhile(token[0] == ' ' || token[0] == '\\t'){\n\t\t\t\t\t\ttoken++;\n\t\t\t\t\t}\n\t\t\t\t\tif(token[0]){\n\t\t\t\t\t\tcur_auth_plugin_config->option_count++;\n\t\t\t\t\t\tcur_auth_plugin_config->options = mosquitto__realloc(cur_auth_plugin_config->options, cur_auth_plugin_config->option_count*sizeof(struct mosquitto_auth_opt));\n\t\t\t\t\t\tif(!cur_auth_plugin_config->options){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].key = key;\n\t\t\t\t\t\tcur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", key);\n\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"auth_plugin\")){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tcur_security_options->auth_plugin_configs = mosquitto__realloc(cur_security_options->auth_plugin_configs, (cur_security_options->auth_plugin_config_count+1)*sizeof(struct mosquitto__auth_plugin_config));\n\t\t\t\t\tif(!cur_security_options->auth_plugin_configs){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t}\n\t\t\t\t\tcur_auth_plugin_config = &cur_security_options->auth_plugin_configs[cur_security_options->auth_plugin_config_count];\n\t\t\t\t\tmemset(cur_auth_plugin_config, 0, sizeof(struct mosquitto__auth_plugin_config));\n\t\t\t\t\tcur_auth_plugin_config->path = NULL;\n\t\t\t\t\tcur_auth_plugin_config->options = NULL;\n\t\t\t\t\tcur_auth_plugin_config->option_count = 0;\n\t\t\t\t\tcur_auth_plugin_config->deny_special_chars = true;\n\t\t\t\t\tcur_security_options->auth_plugin_config_count++;\n\t\t\t\t\tif(conf__parse_string(&token, \"auth_plugin\", &cur_auth_plugin_config->path, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"auth_plugin_deny_special_chars\")){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tif(!cur_auth_plugin_config){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: An auth_plugin_deny_special_chars option exists in the config file without an auth_plugin.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"auth_plugin_deny_special_chars\", &cur_auth_plugin_config->deny_special_chars, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"auto_id_prefix\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_string(&token, \"auto_id_prefix\", &cur_security_options->auto_id_prefix, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_security_options->auto_id_prefix){\n\t\t\t\t\t\tcur_security_options->auto_id_prefix_len = strlen(cur_security_options->auto_id_prefix);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_security_options->auto_id_prefix_len = 0;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"autosave_interval\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"autosave_interval\", &config->autosave_interval, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->autosave_interval < 0) config->autosave_interval = 0;\n\t\t\t\t}else if(!strcmp(token, \"autosave_on_changes\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"autosave_on_changes\", &config->autosave_on_changes, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"bind_address\")){\n\t\t\t\t\tif(reload) continue; // Listener not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"default listener bind_address\", &config->default_listener.host, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(conf__attempt_resolve(config->default_listener.host, \"bind_address\", MOSQ_LOG_ERR, \"Error\")){\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"bridge_attempt_unsubscribe\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"bridge_attempt_unsubscribe\", &cur_bridge->attempt_unsubscribe, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_cafile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_cafile\", &cur_bridge->tls_cafile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_capath\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_capath\", &cur_bridge->tls_capath, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_certfile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_certfile\", &cur_bridge->tls_certfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_identity\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS_PSK)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and identity encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_identity\", &cur_bridge->tls_psk_identity, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_insecure\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"bridge_insecure\", &cur_bridge->tls_insecure, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->tls_insecure){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge %s using insecure mode.\", cur_bridge->name);\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_keyfile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_keyfile\", &cur_bridge->tls_keyfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_protocol_version\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"mqttv31\")){\n\t\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt31;\n\t\t\t\t\t\t}else if(!strcmp(token, \"mqttv311\")){\n\t\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt311;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge_protocol_version value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty bridge_protocol_version value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_psk\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS_PSK)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_psk\", &cur_bridge->tls_psk, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_tls_version\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_tls_version\", &cur_bridge->tls_version, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"cafile\")){\n#if defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(cur_listener->psk_hint){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single listener.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"cafile\", &cur_listener->cafile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"capath\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"capath\", &cur_listener->capath, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"certfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(cur_listener->psk_hint){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single listener.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"certfile\", &cur_listener->certfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"ciphers\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"ciphers\", &cur_listener->ciphers, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"clientid\") || !strcmp(token, \"remote_clientid\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge remote clientid\", &cur_bridge->remote_clientid, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"cleansession\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"cleansession\", &cur_bridge->clean_session, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"clientid_prefixes\")){\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(config->clientid_prefixes);\n\t\t\t\t\t\tconfig->clientid_prefixes = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"clientid_prefixes\", &config->clientid_prefixes, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"connection\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\t/* Check for existing bridge name. */\n\t\t\t\t\t\tfor(i=0; i<config->bridge_count; i++){\n\t\t\t\t\t\t\tif(!strcmp(config->bridges[i].name, token)){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate bridge name \\\"%s\\\".\", token);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconfig->bridge_count++;\n\t\t\t\t\t\tconfig->bridges = mosquitto__realloc(config->bridges, config->bridge_count*sizeof(struct mosquitto__bridge));\n\t\t\t\t\t\tif(!config->bridges){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge = &(config->bridges[config->bridge_count-1]);\n\t\t\t\t\t\tmemset(cur_bridge, 0, sizeof(struct mosquitto__bridge));\n\t\t\t\t\t\tcur_bridge->name = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_bridge->name){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->keepalive = 60;\n\t\t\t\t\t\tcur_bridge->notifications = true;\n\t\t\t\t\t\tcur_bridge->notifications_local_only = false;\n\t\t\t\t\t\tcur_bridge->start_type = bst_automatic;\n\t\t\t\t\t\tcur_bridge->idle_timeout = 60;\n\t\t\t\t\t\tcur_bridge->restart_timeout = 30;\n\t\t\t\t\t\tcur_bridge->threshold = 10;\n\t\t\t\t\t\tcur_bridge->try_private = true;\n\t\t\t\t\t\tcur_bridge->attempt_unsubscribe = true;\n\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt311;\n\t\t\t\t\t\tcur_bridge->primary_retry_sock = INVALID_SOCKET;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty connection value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"connection_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->connection_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"crlfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"crlfile\", &cur_listener->crlfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"http_dir\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"http_dir\", &cur_listener->http_dir, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Websockets support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"idle_timeout\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"idle_timeout\", &cur_bridge->idle_timeout, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->idle_timeout < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"idle_timeout interval too low, using 1 second.\");\n\t\t\t\t\t\tcur_bridge->idle_timeout = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"include_dir\")){\n\t\t\t\t\tif(level == 0){\n\t\t\t\t\t\t/* Only process include_dir from the main config file. */\n\t\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\t\tif(!token){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty include_dir value in configuration.\");\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n#ifdef WIN32\n\t\t\t\t\t\tsnprintf(dirpath, MAX_PATH, \"%s\\\\*.conf\", token);\n\t\t\t\t\t\tfh = FindFirstFile(dirpath, &find_data);\n\t\t\t\t\t\tif(fh == INVALID_HANDLE_VALUE){\n\t\t\t\t\t\t\t/* No files found */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\tlen = strlen(token)+1+strlen(find_data.cFileName)+1;\n\t\t\t\t\t\t\tconf_file = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!conf_file){\n\t\t\t\t\t\t\t\tFindClose(fh);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(conf_file, len, \"%s\\\\%s\", token, find_data.cFileName);\n\t\t\t\t\t\t\tconf_file[len] = '\\0';\n\n\t\t\t\t\t\t\trc = config__read_file(config, reload, conf_file, cr, level+1, &lineno_ext);\n\t\t\t\t\t\t\tif(rc){\n\t\t\t\t\t\t\t\tFindClose(fh);\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", conf_file, lineno_ext);\n\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t}while(FindNextFile(fh, &find_data));\n\n\t\t\t\t\t\tFindClose(fh);\n#else\n\t\t\t\t\t\tdh = opendir(token);\n\t\t\t\t\t\tif(!dh){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open include_dir '%s'.\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((de = readdir(dh)) != NULL){\n\t\t\t\t\t\t\tif(strlen(de->d_name) > 5){\n\t\t\t\t\t\t\t\tif(!strcmp(&de->d_name[strlen(de->d_name)-5], \".conf\")){\n\t\t\t\t\t\t\t\t\tlen = strlen(token)+1+strlen(de->d_name)+1;\n\t\t\t\t\t\t\t\t\tconf_file = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\t\t\tif(!conf_file){\n\t\t\t\t\t\t\t\t\t\tclosedir(dh);\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsnprintf(conf_file, len, \"%s/%s\", token, de->d_name);\n\t\t\t\t\t\t\t\t\tconf_file[len] = '\\0';\n\n\t\t\t\t\t\t\t\t\trc = config__read_file(config, reload, conf_file, cr, level+1, &lineno_ext);\n\t\t\t\t\t\t\t\t\tif(rc){\n\t\t\t\t\t\t\t\t\t\tclosedir(dh);\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", conf_file, lineno_ext);\n\t\t\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclosedir(dh);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"keepalive_interval\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"keepalive_interval\", &cur_bridge->keepalive, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->keepalive < 5){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"keepalive interval too low, using 5 seconds.\");\n\t\t\t\t\t\tcur_bridge->keepalive = 5;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"keyfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"keyfile\", &cur_listener->keyfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"listener\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\ttmp_int = atoi(token);\n\t\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(reload){\n\t\t\t\t\t\t\t/* We reload listeners settings based on port number.\n\t\t\t\t\t\t\t * If the port number doesn't already exist, exit with a complaint. */\n\t\t\t\t\t\t\tcur_listener = NULL;\n\t\t\t\t\t\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\t\t\t\t\t\tif(config->listeners[i].port == tmp_int){\n\t\t\t\t\t\t\t\t\tcur_listener = &config->listeners[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!cur_listener){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: It is not currently possible to add/remove listeners when reloading the config file.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tconfig->listener_count++;\n\t\t\t\t\t\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\t\t\t\t\t\tif(!config->listeners){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur_listener = &config->listeners[config->listener_count-1];\n\t\t\t\t\t\t\tmemset(cur_listener, 0, sizeof(struct mosquitto__listener));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcur_listener->security_options.allow_anonymous = -1;\n\t\t\t\t\t\tcur_listener->protocol = mp_mqtt;\n\t\t\t\t\t\tcur_listener->port = tmp_int;\n\t\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\t\tmosquitto__free(cur_listener->host);\n\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\tcur_listener->host = mosquitto__strdup(token);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_listener->host = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty listener value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"local_clientid\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local clientd\", &cur_bridge->local_clientid, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"local_password\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local_password\", &cur_bridge->local_password, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"local_username\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local_username\", &cur_bridge->local_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"log_dest\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->log_dest_set = 1;\n\t\t\t\t\t\tif(!strcmp(token, \"none\")){\n\t\t\t\t\t\t\tcr->log_dest = MQTT3_LOG_NONE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"syslog\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_SYSLOG;\n\t\t\t\t\t\t}else if(!strcmp(token, \"stdout\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_STDOUT;\n\t\t\t\t\t\t}else if(!strcmp(token, \"stderr\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_STDERR;\n\t\t\t\t\t\t}else if(!strcmp(token, \"topic\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_TOPIC;\n\t\t\t\t\t\t}else if(!strcmp(token, \"file\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_FILE;\n\t\t\t\t\t\t\tif(config->log_fptr || config->log_file){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate \\\"log_dest file\\\" value.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Get remaining string. */\n\t\t\t\t\t\t\ttoken = &token[strlen(token)+1];\n\t\t\t\t\t\t\twhile(token[0] == ' ' || token[0] == '\\t'){\n\t\t\t\t\t\t\t\ttoken++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(token[0]){\n\t\t\t\t\t\t\t\tconfig->log_file = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\tif(!config->log_file){\n\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty \\\"log_dest file\\\" value in configuration.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_dest value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n#if defined(WIN32) || defined(__CYGWIN__)\n\t\t\t\t\t\tif(service_handle){\n\t\t\t\t\t\t\tif(cr->log_dest == MQTT3_LOG_STDOUT || cr->log_dest == MQTT3_LOG_STDERR){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot log to stdout/stderr when running as a Windows service.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty log_dest value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"log_facility\")){\n#if defined(WIN32) || defined(__CYGWIN__)\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: log_facility not supported on Windows.\");\n#else\n\t\t\t\t\tif(conf__parse_int(&token, \"log_facility\", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tswitch(tmp_int){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL6;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL7;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_facility value (%d).\", tmp_int);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}else if(!strcmp(token, \"log_timestamp\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->log_timestamp, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"log_type\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->log_type_set = 1;\n\t\t\t\t\t\tif(!strcmp(token, \"none\")){\n\t\t\t\t\t\t\tcr->log_type = MOSQ_LOG_NONE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"information\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_INFO;\n\t\t\t\t\t\t}else if(!strcmp(token, \"notice\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_NOTICE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"warning\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_WARNING;\n\t\t\t\t\t\t}else if(!strcmp(token, \"error\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_ERR;\n\t\t\t\t\t\t}else if(!strcmp(token, \"debug\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_DEBUG;\n\t\t\t\t\t\t}else if(!strcmp(token, \"subscribe\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_SUBSCRIBE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"unsubscribe\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_UNSUBSCRIBE;\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\t\t}else if(!strcmp(token, \"websockets\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_WEBSOCKETS;\n#endif\n\t\t\t\t\t\t}else if(!strcmp(token, \"all\")){\n\t\t\t\t\t\t\tcr->log_type = INT_MAX;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_type value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty log_type value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_connections\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcur_listener->max_connections = atoi(token);\n\t\t\t\t\t\tif(cur_listener->max_connections < 0) cur_listener->max_connections = -1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_connections value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_inflight_bytes\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_inflight_bytes = atol(token);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_inflight_bytes value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_inflight_messages\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_inflight_messages = atoi(token);\n\t\t\t\t\t\tif(cr->max_inflight_messages < 0) cr->max_inflight_messages = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_inflight_messages value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_queued_bytes\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_queued_bytes = atol(token); /* 63 bits is ok right? */\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_queued_bytes value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_queued_messages\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_queued_messages = atoi(token);\n\t\t\t\t\t\tif(cr->max_queued_messages < 0) cr->max_queued_messages = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_queued_messages value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"memory_limit\")){\n\t\t\t\t\tssize_t lim;\n\t\t\t\t\tif(conf__parse_ssize_t(&token, \"memory_limit\", &lim, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(lim < 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid memory_limit value (%ld).\", lim);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tmemory__set_limit(lim);\n\t\t\t\t}else if(!strcmp(token, \"message_size_limit\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"message_size_limit\", (int *)&config->message_size_limit, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->message_size_limit > MQTT_MAX_PAYLOAD){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid message_size_limit value (%u).\", config->message_size_limit);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"mount_point\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(config->listener_count == 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: You must use create a listener before using the mount_point option in the configuration file.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"mount_point\", &cur_listener->mount_point, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(mosquitto_pub_topic_check(cur_listener->mount_point) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR,\n\t\t\t\t\t\t\t\t\"Error: Invalid mount_point '%s'. Does it contain a wildcard character?\",\n\t\t\t\t\t\t\t\tcur_listener->mount_point);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"notifications\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"notifications\", &cur_bridge->notifications, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"notifications_local_only\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"notifications_local_only\", &cur_bridge->notifications_local_only, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"notification_topic\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"notification_topic\", &cur_bridge->notification_topic, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"password\") || !strcmp(token, \"remote_password\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge remote_password\", &cur_bridge->remote_password, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"password_file\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->password_file);\n\t\t\t\t\t\tcur_security_options->password_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"password_file\", &cur_security_options->password_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"per_listener_settings\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"per_listener_settings\", &config->per_listener_settings, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_security_options && config->per_listener_settings){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: per_listener_settings must be set before any other security settings.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"persistence\") || !strcmp(token, \"retained_persistence\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->persistence, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistence_file\")){\n\t\t\t\t\tif(conf__parse_string(&token, \"persistence_file\", &config->persistence_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistence_location\")){\n\t\t\t\t\tif(conf__parse_string(&token, \"persistence_location\", &config->persistence_location, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistent_client_expiration\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tswitch(token[strlen(token)-1]){\n\t\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\t\texpiration_mult = 3600;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\texpiration_mult = 86400;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'w':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*7;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*30;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'y':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*365;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid persistent_client_expiration duration in configuration.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken[strlen(token)-1] = '\\0';\n\t\t\t\t\t\tconfig->persistent_client_expiration = atoi(token)*expiration_mult;\n\t\t\t\t\t\tif(config->persistent_client_expiration <= 0){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid persistent_client_expiration duration in configuration.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty persistent_client_expiration value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"pid_file\")){\n\t\t\t\t\tif(reload) continue; // pid file not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"pid_file\", &config->pid_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"port\")){\n\t\t\t\t\tif(reload) continue; // Listener not valid for reloading.\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"port\", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = tmp_int;\n\t\t\t\t}else if(!strcmp(token, \"protocol\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"mqtt\")){\n\t\t\t\t\t\t\tcur_listener->protocol = mp_mqtt;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t}else if(!strcmp(token, \"mqttsn\")){\n\t\t\t\t\t\t\tcur_listener->protocol = mp_mqttsn;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t}else if(!strcmp(token, \"websockets\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\t\t\tcur_listener->protocol = mp_websockets;\n\t\t\t\t\t\t\tconfig->have_websockets_listener = true;\n#else\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Websockets support not available.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n#endif\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid protocol value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty protocol value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"psk_file\")){\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->psk_file);\n\t\t\t\t\t\tcur_security_options->psk_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"psk_file\", &cur_security_options->psk_file, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS/TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"psk_hint\")){\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"psk_hint\", &cur_listener->psk_hint, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS/TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"queue_qos0_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->queue_qos0_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"require_certificate\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"require_certificate\", &cur_listener->require_certificate, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"restart_timeout\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"restart_timeout\", &cur_bridge->restart_timeout, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->restart_timeout < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"restart_timeout interval too low, using 1 second.\");\n\t\t\t\t\t\tcur_bridge->restart_timeout = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"retry_interval\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: The retry_interval option is no longer available.\");\n\t\t\t\t}else if(!strcmp(token, \"round_robin\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"round_robin\", &cur_bridge->round_robin, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"set_tcp_nodelay\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"set_tcp_nodelay\", &config->set_tcp_nodelay, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"start_type\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"automatic\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_automatic;\n\t\t\t\t\t\t}else if(!strcmp(token, \"lazy\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_lazy;\n\t\t\t\t\t\t}else if(!strcmp(token, \"manual\")){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Manual start_type not supported.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}else if(!strcmp(token, \"once\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_once;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid start_type value in configuration (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty start_type value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"socket_domain\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"ipv4\")){\n\t\t\t\t\t\t\tcur_listener->socket_domain = AF_INET;\n\t\t\t\t\t\t}else if(!strcmp(token, \"ipv6\")){\n\t\t\t\t\t\t\tcur_listener->socket_domain = AF_INET6;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid socket_domain value \\\"%s\\\" in configuration.\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty socket_domain value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"store_clean_interval\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: store_clean_interval is no longer needed.\");\n\t\t\t\t}else if(!strcmp(token, \"sys_interval\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"sys_interval\", &config->sys_interval, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->sys_interval < 0 || config->sys_interval > 65535){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid sys_interval value (%d).\", config->sys_interval);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"threshold\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"threshold\", &cur_bridge->threshold, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->threshold < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"threshold too low, using 1 message.\");\n\t\t\t\t\t\tcur_bridge->threshold = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"tls_version\")){\n#if defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"tls_version\", &cur_listener->tls_version, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"topic\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcur_bridge->topic_count++;\n\t\t\t\t\t\tcur_bridge->topics = mosquitto__realloc(cur_bridge->topics,\n\t\t\t\t\t\t\t\tsizeof(struct mosquitto__bridge_topic)*cur_bridge->topic_count);\n\t\t\t\t\t\tif(!cur_bridge->topics){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_topic = &cur_bridge->topics[cur_bridge->topic_count-1];\n\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\tcur_topic->topic = NULL;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->topic = mosquitto__strdup(token);\n\t\t\t\t\t\t\tif(!cur_topic->topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_topic->direction = bd_out;\n\t\t\t\t\t\tcur_topic->qos = 0;\n\t\t\t\t\t\tcur_topic->local_prefix = NULL;\n\t\t\t\t\t\tcur_topic->remote_prefix = NULL;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty topic value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcasecmp(token, \"out\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_out;\n\t\t\t\t\t\t}else if(!strcasecmp(token, \"in\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_in;\n\t\t\t\t\t\t}else if(!strcasecmp(token, \"both\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_both;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic direction '%s'.\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\tcur_topic->qos = atoi(token);\n\t\t\t\t\t\t\tif(cur_topic->qos < 0 || cur_topic->qos > 2){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge QoS level '%s'.\", token);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\t\tcur_bridge->topic_remapping = true;\n\t\t\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\t\t\tcur_topic->local_prefix = NULL;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tif(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic local prefix '%s'.\", token);\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcur_topic->local_prefix = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\t\tif(!cur_topic->local_prefix){\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\t\t\t\tcur_topic->remote_prefix = NULL;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tif(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic remote prefix '%s'.\", token);\n\t\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcur_topic->remote_prefix = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\t\t\tif(!cur_topic->remote_prefix){\n\t\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->topic == NULL &&\n\t\t\t\t\t\t\t(cur_topic->local_prefix == NULL || cur_topic->remote_prefix == NULL)){\n\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge remapping.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tif(cur_topic->topic){\n\t\t\t\t\t\t\tlen = strlen(cur_topic->topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\t\tcur_topic->local_topic = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(cur_topic->local_topic, len+1, \"%s%s\", cur_topic->local_prefix, cur_topic->topic);\n\t\t\t\t\t\t\tcur_topic->local_topic[len] = '\\0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->local_topic = mosquitto__strdup(cur_topic->local_prefix);\n\t\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_topic->local_topic = mosquitto__strdup(cur_topic->topic);\n\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(cur_topic->topic){\n\t\t\t\t\t\t\tlen = strlen(cur_topic->topic) + strlen(cur_topic->remote_prefix)+1;\n\t\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(cur_topic->remote_topic, len, \"%s%s\", cur_topic->remote_prefix, cur_topic->topic);\n\t\t\t\t\t\t\tcur_topic->remote_topic[len] = '\\0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__strdup(cur_topic->remote_prefix);\n\t\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__strdup(cur_topic->topic);\n\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"try_private\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"try_private\", &cur_bridge->try_private, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"upgrade_outgoing_qos\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->upgrade_outgoing_qos, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"use_identity_as_username\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_identity_as_username\", &cur_listener->use_identity_as_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"use_subject_as_username\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_subject_as_username\", &cur_listener->use_subject_as_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"user\")){\n\t\t\t\t\tif(reload) continue; // Drop privileges user not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"user\", &config->user, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"use_username_as_clientid\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_username_as_clientid\", &cur_listener->use_username_as_clientid, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"username\") || !strcmp(token, \"remote_username\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(cur_bridge->remote_username){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate username value in bridge configuration.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->remote_username = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_bridge->remote_username){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty username value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"websockets_log_level\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\tif(conf__parse_int(&token, \"websockets_log_level\", &config->websockets_log_level, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Websockets support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"trace_level\")\n\t\t\t\t\t\t|| !strcmp(token, \"ffdc_output\")\n\t\t\t\t\t\t|| !strcmp(token, \"max_log_entries\")\n\t\t\t\t\t\t|| !strcmp(token, \"trace_output\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Unsupported rsmb configuration option \\\"%s\\\".\", token);\n\t\t\t\t}else{\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unknown configuration variable \\\"%s\\\".\", token);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nint config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file %s\\n\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc(buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__free(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}\n\n\nstatic int config__check(struct mosquitto__config *config)\n{\n\t/* Checks that are easy to make after the config has been loaded. */\n\n#ifdef WITH_BRIDGE\n\tint i, j;\n\tstruct mosquitto__bridge *bridge1, *bridge2;\n\tchar hostname[256];\n\tint len;\n\n\t/* Check for bridge duplicate local_clientid, need to generate missing IDs\n\t * first. */\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tbridge1 = &config->bridges[i];\n\n\t\tif(!bridge1->remote_clientid){\n\t\t\tif(!gethostname(hostname, 256)){\n\t\t\t\tlen = strlen(hostname) + strlen(bridge1->name) + 2;\n\t\t\t\tbridge1->remote_clientid = mosquitto__malloc(len);\n\t\t\t\tif(!bridge1->remote_clientid){\n\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t}\n\t\t\t\tsnprintf(bridge1->remote_clientid, len, \"%s.%s\", hostname, bridge1->name);\n\t\t\t}else{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif(!bridge1->local_clientid){\n\t\t\tlen = strlen(bridge1->remote_clientid) + strlen(\"local.\") + 2;\n\t\t\tbridge1->local_clientid = mosquitto__malloc(len);\n\t\t\tif(!bridge1->local_clientid){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t\tsnprintf(bridge1->local_clientid, len, \"local.%s\", bridge1->remote_clientid);\n\t\t}\n\t}\n\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tbridge1 = &config->bridges[i];\n\t\tfor(j=i+1; j<config->bridge_count; j++){\n\t\t\tbridge2 = &config->bridges[j];\n\t\t\tif(!strcmp(bridge1->local_clientid, bridge2->local_clientid)){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Bridge local_clientid \"\n\t\t\t\t\t\t\"'%s' is not unique. Try changing or setting the \"\n\t\t\t\t\t\t\"local_clientid value for one of the bridges.\",\n\t\t\t\t\t\tbridge1->local_clientid);\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nstatic int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\tif(!strcmp(*token, \"false\") || !strcmp(*token, \"0\")){\n\t\t\t*value = false;\n\t\t}else if(!strcmp(*token, \"true\") || !strcmp(*token, \"1\")){\n\t\t\t*value = true;\n\t\t}else{\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid %s value (%s).\", name, *token);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_int(char **token, const char *name, int *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\t*value = atoi(*token);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\t*value = atol(*token);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_string(char **token, const char *name, char **value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \"\", &saveptr);\n\tif(*token){\n\t\tif(*value){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate %s value in configuration.\", name);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\t/* Deal with multiple spaces at the beginning of the string. */\n\t\twhile((*token)[0] == ' ' || (*token)[0] == '\\t'){\n\t\t\t(*token)++;\n\t\t}\n\t\tif(mosquitto_validate_utf8(*token, strlen(*token))){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Malformed UTF-8 in configuration.\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\t*value = mosquitto__strdup(*token);\n\t\tif(!*value){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n"], "fixing_code": ["1.5.5 - 201812xx\n================\n\nSecurity:\n- If `per_listener_settings` is set to true, then the `acl_file` setting was\n  ignored for the \"default listener\" only. This has been fixed. This does not\n  affect any listeners defined with the `listener` option. Closes #1073.\n\nBroker:\n- Add `socket_domain` option to allow listeners to disable IPv6 support.\n  This is required to work around a problem in libwebsockets that means\n  sockets only listen on IPv6 by default if IPv6 support is compiled in.\n  Closes #1004.\n- When using ADNS, don't ask for all network protocols when connecting,\n  because this can lead to confusing \"Protocol not supported\" errors if the\n  network is down. Closes #1062.\n- Fix outgoing retained messages not being sent by bridges on initial\n  connection. Closes #1040.\n- Don't reload auth_opt_ options on reload, to match the behaviour of the\n  other plugin options. Closes #1068.\n- Print message on error when installing/uninstalling as a Windows service.\n\nLibrary:\n- Fix reconnect delay backoff behaviour. Closes #1027.\n- Don't call on_disconnect() twice if keepalive tests fail. Closes #1067.\n\nClient:\n- Always print leading zeros in mosquitto_sub when output format is hex.\n  Closes #1066.\n\n\n1.5.4 - 20181108\n================\n\nSecurity:\n- When using a TLS enabled websockets listener with \"require_certificate\"\n  enabled, the mosquitto broker does not correctly verify client certificates.\n  This is now fixed. All other security measures operate as expected, and in\n  particular non-websockets listeners are not affected by this. Closes #996.\n\nBroker:\n- Process all pending messages even when a client has disconnected. This means\n  a client that send a PUBLISH then DISCONNECT quickly, then disconnects will\n  have its DISCONNECT message processed properly and so no Will will be sent.\n  Closes #7.\n- $SYS/broker/clients/disconnected should never be negative. Closes #287.\n- Give better error message if a client sends a password without a username.\n  Closes #1015.\n- Fix bridge not honoring restart_timeout. Closes #1019.\n- Don't disconnect a client if an auth plugin denies access to SUBSCRIBE.\n  Closes #1016.\n\nLibrary:\n- Fix memory leak that occurred if mosquitto_reconnect() was used when TLS\n  errors were present. Closes #592.\n- Fix TLS connections when using an external event loop with\n  mosquitto_loop_read() and mosquitto_write(). Closes #990.\n\nBuild:\n- Fix clients not being compiled with threading support when using CMake.\n  Closes #983.\n- Header fixes for FreeBSD. Closes #977.\n- Use _GNU_SOURCE to fix build errors in websockets and getaddrinfo usage.\n  Closes #862 and #933.\n- Fix builds on QNX 7.0.0. Closes #1018.\n\n\n1.5.3 - 20180925\n================\n\nSecurity:\n- Fix CVE-2018-12543. If a message is sent to Mosquitto with a topic that\n  begins with $, but is not $SYS, then an assert that should be unreachable is\n  triggered and Mosquitto will exit.\n\nBroker:\n- Elevate log level to warning for situation when socket limit is hit.\n- Remove requirement to use `user root` in snap package config files.\n- Fix retained messages not sent by bridges on outgoing topics at the first\n  connection. Closes #701.\n- Documentation fixes. Closes #520, #600.\n- Fix duplicate clients being added to by_id hash before the old client was\n  removed. Closes #645.\n- Fix Windows version not starting if include_dir did not contain any files.\n  Closes #566.\n- When an authentication plugin denied access to a SUBSCRIBE, the client would\n  be disconnected incorrectly. This has been fixed. Closes #1016.\n\nBuild:\n- Various fixes to ease building.\n\n\n1.5.2 - 20180919\n================\n\nBroker:\n- Fix build when using WITH_ADNS=yes.\n- Fix incorrect call to setsockopt() for TCP_NODELAY. Closes #941.\n- Fix excessive CPU usage when the number of sockets exceeds the system limit.\n  Closes #948.\n- Fix for bridge connections when using WITH_ADNS=yes.\n- Fix round_robin false behaviour. Closes #481.\n- Fix segfault on HUP when bridges and security options are configured.\n  Closes #965.\n\nLibrary:\n- Fix situation where username and password is used with SOCKS5 proxy. Closes\n  #927.\n- Fix SOCKS5 behaviour when passing IP addresses. Closes #927.\n\nBuild:\n- Make it easier to build without bundled uthash.h using \"WITH_BUNDLED_DEPS=no\".\n- Fix build with OPENSSL_NO_ENGINE. Closes #932.\n\n\n1.5.1 - 20180816\n================\n\nBroker:\n- Fix plugin cleanup function not being called on exit of the broker.\n  Closes #900.\n- Print more OpenSSL errors when loading certificates/keys fail.\n- Use AF_UNSPEC etc. instead of PF_UNSPEC to comply with POSIX. Closes #863.\n- Remove use of AI_ADDRCONFIG, which means the broker can be used on systems\n  where only the loopback interface is defined. Closes #869, Closes #901.\n- Fix IPv6 addresses not being able to be used as bridge addresses.\n  Closes #886.\n- All clients now time out if they exceed their keepalive*1.5, rather than\n  just reach it. This was inconsistent in two places.\n- Fix segfault on startup if bridge CA certificates could not be read.\n  Closes #851.\n- Fix problem opening listeners on Pi caused by unsigned char being default.\n  Found via #849.\n- ACL patterns that do not contain either %c or %u now produce a warning in\n  the log. Closes #209.\n- Fix bridge publishing failing when per_listener_settings was true. Closes\n  #860.\n- Fix `use_identity_as_username true` not working. Closes #833.\n- Fix UNSUBACK messages not being logged. Closes #903.\n- Fix possible endian issue when reading the `memory_limit` option.\n- Fix building for libwebsockets < 1.6.\n- Fix accessor functions for username and client id when used in plugin auth\n  check.\n\nLibrary:\n- Fix some places where return codes were incorrect, including to the\n  on_disconnect() callback. This has resulted in two new error codes,\n  MOSQ_ERR_KEEPALIVE and MOSQ_ERR_LOOKUP.\n- Fix connection problems when mosquitto_loop_start() was called before\n  mosquitto_connect_async(). Closes #848.\n\nClients:\n- When compiled using WITH_TLS=no, the default port was incorrectly being set\n  to -1. This has been fixed.\n- Fix compiling on Mac OS X <10.12. Closes #813 and #240.\n\nBuild:\n- Fixes for building on NetBSD. Closes #258.\n- Fixes for building on FreeBSD.\n- Add support for compiling with static libwebsockets library.\n\n\n1.5 - 20180502\n==============\n\nSecurity:\n- Fix memory leak that could be caused by a malicious CONNECT packet. This\n  does not yet have a CVE assigned. Closes #533493 (on Eclipse bugtracker)\n\nBroker features:\n- Add per_listener_settings to allow authentication and access control to be\n  per listener.\n- Add limited support for reloading listener settings. This allows settings\n  for an already defined listener to be reloaded, but port numbers must not be\n  changed.\n- Add ability to deny access to SUBSCRIBE messages as well as the current\n  read/write accesses. Currently for auth plugins only.\n- Reduce calls to malloc through the use of UHPA.\n- Outgoing messages with QoS>1 are no longer retried after a timeout period.\n  Messages will be retried when a client reconnects.  This change in behaviour\n  can be justified by considering when the timeout may have occurred.\n  * If a connection is unreliable and has dropped, but without one end\n    noticing, the messages will be retried on reconnection. Sending\n    additional PUBLISH or PUBREL would not have changed anything.\n  * If a client is overloaded/unable to respond/has a slow connection then\n    sending additional PUBLISH or PUBREL would not help the client catch\n    up. Once the backlog has cleared the client will respond. If it is not\n    able to catch up, sending additional duplicates would not help either.\n- Add use_subject_as_username option for certificate based client\n  authentication to use the entire certificate subject as a username, rather\n  than just the CN. Closes #469467.\n- Change sys tree printing output. This format shouldn't be relied upon and\n  may change at any time. Closes #470246.\n- Minimum supported libwebsockets version is now 1.3.\n- Add systemd startup notification and services. Closes #471053.\n- Reduce unnecessary malloc and memcpy when receiving a message and storing\n  it. Closes #470258.\n- Support for Windows XP has been dropped.\n- Bridge connections now default to using MQTT v3.1.1.\n- mosquitto_db_dump tool can now output some stats on clients.\n- Perform utf-8 validation on incoming will, subscription and unsubscription\n  topics.\n- new $SYS/broker/store/messages/count (deprecates $SYS/broker/messages/stored)\n- new $SYS/broker/store/messages/bytes\n- max_queued_bytes feature to limit queues by real size rather than\n  than just message count. Closes Eclipse #452919 or Github #100\n- Add support for bridges to be configured to only send notifications to the\n  local broker.\n- Add set_tcp_nodelay option to allow Nagle's algorithm to be disabled on\n  client sockets. Closes #433.\n- The behaviour of allow_anonymous has changed. In the old behaviour, the\n  default if not set was to allow anonymous access. The new behaviour is to\n  default is to allow anonymous access unless another security option is set.\n  For example, if password_file is set and allow_anonymous is not set, then\n  anonymous access will be denied. It is still possible to allow anonymous\n  access by setting it explicitly.\n\nBroker fixes:\n- Fix UNSUBSCRIBE with no topic is accepted on MQTT 3.1.1. Closes #665.\n- Produce an error if two bridges share the same local_clientid.\n- Miscellaneous fixes on Windows.\n- queue_qos0_messages was not observing max_queued_** limits\n- When using the include_dir configuration option sort the files\n  alphabetically before loading them.  Closes #17.\n- IPv6 is no longer disabled for websockets listeners.\n- Remove all build timestamp information including $SYS/broker/timestamp.\n  Close #651.\n- Correctly handle incoming strings that contain a NULL byte. Closes #693.\n- Use constant time memcmp for password comparisons.\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Fix memory leak if a client provided a username/password for a listener with\n  use_identity_as_username configured.\n- Fix use_identity_as_username not working on websockets clients.\n- Don't crash if an auth plugin returns MOSQ_ERR_AUTH for a username check on\n  a websockets client. Closes #490.\n- Fix 08-ssl-bridge.py test when using async dns lookups. Closes #507.\n- Lines in the config file are no longer limited to 1024 characters long.\n  Closes #652.\n- Fix $SYS counters of messages and bytes sent when message is sent over\n  a Websockets. Closes #250.\n- Fix upgrade_outgoing_qos for retained message. Closes #534.\n- Fix CONNACK message not being sent for unauthorised connect on websockets.\n  Closes #8.\n- Maximum connections on Windows increased to 2048.\n- When a client with an in-use client-id connects, if the old client has a\n  will, send the will message. Closes #26.\n- Fix parsing of configuration options that end with a space. Closes #804.\n\nClient library features:\n- Outgoing messages with QoS>1 are no longer retried after a timeout period.\n  Messages will be retried when a client reconnects.\n- DNS-SRV support is now disabled by default.\n- Add mosquitto_subscribe_simple() This is a helper function to make\n  retrieving messages from a broker very straightforward. Examples of its use\n  are in examples/subscribe_simple.\n- Add mosquitto_subscribe_callback() This is a helper function to make\n  processing messages from a broker very straightforward. An example of its use\n  is in examples/subscribe_simple.\n- Connections now default to using MQTT v3.1.1.\n- Add mosquitto_validate_utf8() to check whether a string is valid UTF-8\n  according to the UTF-8 spec and to the additional restrictions imposed by\n  the MQTT spec.\n- Topic inputs are checked for UTF-8 validity.\n- Add mosquitto_userdata function to allow retrieving the client userdata\n  member variable. Closes #111.\n- Add mosquitto_pub_topic_check2(), mosquitto_sub_topic_check2(), and\n  mosquitto_topic_matches_sub2() which are identical to the similarly named\n  functions but also take length arguments.\n- Add mosquitto_connect_with_flags_callback_set(), which allows a second\n  connect callback to be used which also exposes the connect flags parameter.\n  Closes #738 and #128.\n- Add MOSQ_OPT_SSL_CTX option to allow a user specified SSL_CTX to be used\n  instead of the one generated by libmosquitto. This allows greater control\n  over what options can be set. Closes #715.\n- Add MOSQ_OPT_SSL_CTX_WITH_DEFAULTS to work with MOSQ_OPT_SSL_CTX and have\n  the default libmosquitto SSL_CTX configuration applied to the user provided\n  SSL_CTX. Closes #567.\n\nClient library fixes:\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Initialise \"result\" variable as soon as possible in\n  mosquitto_topic_matches_sub. Closes #654.\n- No need to close socket again if setting non-blocking failed. Closes #649.\n- Fix mosquitto_topic_matches_sub() not correctly matching foo/bar against\n  foo/+/#. Closes #670.\n- SNI host support added.\n\nClient features:\n- Add -F to mosquitto_sub to allow the user to choose the output format.\n- Add -U to mosquitto_sub for unsubscribing from topics.\n- Add -c (clean session) to mosquitto_pub.\n- Add --retained-only to mosquitto_sub to exit after receiving all retained\n  messages.\n- Add -W to allow mosquitto_sub to stop processing incoming messages after a\n  timeout.\n- Connections now default to using MQTT v3.1.1.\n- Default to using port 8883 when using TLS.\n- mosquitto_sub doesn't continue to keep connecting if CONNACK tells it the\n  connection was refused.\n\nClient fixes:\n- Correctly handle empty files with \"mosquitto_pub -l\". Closes #676.\n\nBuild:\n- Add WITH_STRIP option (defaulting to \"no\") that when set to \"yes\" will strip\n  executables and shared libraries when installing.\n- Add WITH_STATIC_LIBRARIES (defaulting to \"no\") that when set to \"yes\" will\n  build and install static versions of the client libraries.\n- Don't run TLS-PSK tests if TLS-PSK disabled at compile time. Closes #636.\n- Support for openssl versions 1.0.0 and 1.0.1 has been removed as these are\n  no longer supported by openssl.\n\nDocumentation:\n- Replace mentions of deprecated 'c_rehash' with 'openssl rehash'.\n\n1.4.15 - 20180228\n=================\n\nSecurity:\n- Fix CVE-2017-7652. If a SIGHUP is sent to the broker when there are no more\n  file descriptors, then opening the configuration file will fail and security\n  settings will be set back to their default values.\n- Fix CVE-2017-7651. Unauthenticated clients can cause excessive memory use by\n  setting \"remaining length\" to be a large value. This is now mitigated by\n  limiting the size of remaining length to valid values. A \"memory_limit\"\n  configuration option has also been added to allow the overall memory used by\n  the broker to be limited.\n\nBroker:\n- Use constant time memcmp for password comparisons.\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Fix memory leak if a client provided a username/password for a listener with\n  use_identity_as_username configured.\n- Fix use_identity_as_username not working on websockets clients.\n- Don't crash if an auth plugin returns MOSQ_ERR_AUTH for a username check on\n  a websockets client. Closes #490.\n- Fix 08-ssl-bridge.py test when using async dns lookups. Closes #507.\n- Lines in the config file are no longer limited to 1024 characters long.\n  Closes #652.\n- Fix $SYS counters of messages and bytes sent when message is sent over\n  a Websockets. Closes #250.\n- Fix upgrade_outgoing_qos for retained message. Closes #534.\n- Fix CONNACK message not being sent for unauthorised connect on websockets.\n  Closes #8.\n\nClient library:\n- Fix incorrect PSK key being used if it had leading zeroes.\n- Initialise \"result\" variable as soon as possible in\n  mosquitto_topic_matches_sub. Closes #654.\n- No need to close socket again if setting non-blocking failed. Closes #649.\n- Fix mosquitto_topic_matches_sub() not correctly matching foo/bar against\n  foo/+/#. Closes #670.\n\nClients:\n- Correctly handle empty files with \"mosquitto_pub -l\". Closes #676.\n\nBuild:\n- Don't run TLS-PSK tests if TLS-PSK disabled at compile time. Closes #636.\n\n\n1.4.14 - 20170710\n=================\n\nBroker:\n- Fix regression from 1.4.13 where persistence data was not being saved.\n\n\n1.4.13 - 20170627\n=================\n\nSecurity:\n- Fix CVE-2017-9868. The persistence file was readable by all local users,\n  potentially allowing sensitive information to be leaked.\n  This can also be fixed administratively, by restricting access to the\n  directory in which the persistence file is stored.\n\nBroker:\n- Fix for poor websockets performance.\n- Fix lazy bridges not timing out for idle_timeout. Closes #417.\n- Fix problems with large retained messages over websockets. Closes #427.\n- Set persistence file to only be readable by owner, except on Windows. Closes\n  #468.\n- Fix CONNECT check for reserved=0, as per MQTT v3.1.1 check MQTT-3.1.2-3.\n- When the broker stop, wills for any connected clients are now \"sent\". Closes\n  #477.\n- Auth plugins can be configured to disable the check for +# in\n  usernames/client ids with the auth_plugin_deny_special_chars option.\n  Partially closes #462.\n- Restrictions for CVE-2017-7650 have been relaxed - '/' is allowed in\n  usernames/client ids. Remainder of fix for #462.\n\nClients:\n- Don't use / in auto-generated client ids.\n\n\n1.4.12 - 20170528\n=================\n\nSecurity:\n- Fix CVE-2017-7650, which allows clients with username or client id set to\n  '#' or '+' to bypass pattern based ACLs or third party plugins. The fix\n  denies message sending or receiving of messages for clients with a '#' or\n  '+' in their username or client id and if the message is subject to a\n  pattern ACL check or plugin check.\n  Patches for other versions are available at\n  https://mosquitto.org/files/cve/2017-7650/\n\nBroker:\n- Fix mosquitto.db from becoming corrupted due to client messages being\n  persisted with no stored message. Closes #424.\n- Fix bridge not restarting properly. Closes #428.\n- Fix unitialized memory in gets_quiet on Windows. Closes #426.\n- Fix building with WITH_ADNS=no for systems that don't use glibc. Closes\n  #415.\n- Fixes to readme.md.\n- Fix deprecation warning for OpenSSL 1.1. PR #416.\n- Don't segfault on duplicate bridge names. Closes #446.\n- Fix CVE-2017-7650.\n\n\n1.4.11 - 20170220\n=================\n\nBroker:\n- Fix crash when \"lazy\" type bridge attempts to reconnect. Closes #259.\n- maximum_connections now applies to websockets listeners. Closes #271.\n- Allow bridges to use TLS with IPv6.\n- Don't error on zero length persistence files. Closes #316.\n- For http only websockets clients, close files served over http in all cases\n  when the client disconnects. Closes #354.\n- Fix error message when websockets http_dir directory does not exist.\n- Improve password utility error message. Closes #379.\n\nClients:\n- Use of --ciphers no longer requires you to also pass --tls-version.\n  Closes #380.\n\nClient library:\n- Clients can now use TLS with IPv6.\n- Fix potential socket leakage when reconnecting. Closes #304.\n- Fix potential negative timeout being passed to pselect. Closes #329.\n\n\n1.4.10 - 20160816\n=================\n\nBroker:\n- Fix TLS operation with websockets listeners and libwebsockts 2.x. Closes\n  #186.\n- Don't disconnect client on HUP before reading the pending data. Closes #7.\n- Fix some $SYS messages being incorrectly persisted. Closes #191.\n- Support OpenSSL 1.1.0.\n- Call fsync after persisting data to ensure it is correctly written. Closes\n  #189.\n- Fix persistence saving of subscription QoS on big-endian machines.\n- Fix will retained flag handling on Windows. Closes #222.\n- Broker now displays an error if it is unable to open the log file. Closes\n  #234.\n\nClient library:\n- Support OpenSSL 1.1.0.\n- Fixed the C++ library not allowing SOCKS support to be used. Closes #198.\n- Fix memory leak when verifying a server certificate with a subjectAltName\n  section. Closes #237.\n\nBuild:\n- Don't attempt to install docs when WITH_DOCS=no. Closes #184.\n\n\n1.4.9 - 20160603\n================\n\nBroker:\n- Ensure websockets clients that previously connected with clean session set\n  to false have their queued messages delivered immediately on reconnecting.\n  Closes #476314.\n- Reconnecting client with clean session set to false doesn't start with mid=1\n  again.\n- Will topic isn't truncated by one byte when using a mount_point any more.\n- Network errors are printed correctly on Windows.\n- Fix incorrect $SYS heap memory reporting when using ACLs.\n- Bridge config parameters couldn't contain a space, this has been fixed.\n  Closes #150.\n- Fix saving of persistence messages that start with a '/'. Closes #151.\n- Fix reconnecting for bridges that use TLS on Windows. Closes #154.\n- Broker and bridges can now cope with unknown incoming PUBACK, PUBREC,\n  PUBREL, PUBCOMP without disconnecting. Closes #57.\n- Fix websockets listeners not being able to bind to an IP address. Closes\n  #170.\n- mosquitto_passwd utility now correctly deals with unknown command line\n  arguments in all cases. Closes #169.\n- Fix publishing of $SYS/broker/clients/maximum\n- Fix order of #includes in lib/send_mosq.c to ensure struct mosquitto doesn't\n  differ between source files when websockets is being used. Closes #180.\n- Fix possible rare crash when writing out persistence file and a client has\n  incomplete messages inflight that it has been denied the right to publish.\n\nClient library:\n- Fix the case where a message received just before the keepalive timer\n  expired would cause the client to miss the keepalive timer.\n- Return value of pthread_create is now checked.\n- _mosquitto_destroy should not cancel threads that weren't created by\n  libmosquitto. Closes #166.\n- Clients can now cope with unknown incoming PUBACK, PUBREC, PUBREL, PUBCOMP\n  without disconnecting. Closes #57.\n- Fix mosquitto_topic_matches_sub() reporting matches on some invalid\n   subscriptions.\n\nClients:\n- Handle some unchecked malloc() calls. Closes #1.\n\nBuild:\n- Fix string quoting in CMakeLists.txt. Closes #4.\n- Fix building on Visual Studio 2015. Closes #136.\n\n\n1.4.8 - 20160214\n================\n\nBroker:\n- Wills published by clients connected to a listener with mount_point defined\n  now correctly obey the mount point. This was a potential security risk\n  because it allowed clients to publish messages outside of their restricted\n  mount point. This is only affects brokers where the mount_point option is in\n  use. Closes #487178.\n- Fix detection of broken connections on Windows. Closes #485143.\n- Close stdin etc. when daemonised. Closes #485589.\n- Fix incorrect detection of FreeBSD and OpenBSD. Closes #485131.\n\nClient library:\n- mosq->want_write should be cleared immediately before a call to SSL_write,\n  to allow clients using mosquitto_want_write() to get accurate results.\n\n\n1.4.7 - 20151221\n================\n\nBroker:\n- Fix support for libwebsockets 1.22.\n\n\n1.4.6 - 20151220\n================\n\nBroker:\n- Add support for libwebsockets 1.6.\n\nClient library:\n- Fix _mosquitto_socketpair() on Windows, reducing the chance of delays when\n  publishing. Closes #483979.\n\nClients:\n- Fix \"mosquitto_pub -l\" stripping the final character on a line. Closes\n  #483981.\n\n\n1.4.5 - 20151108\n================\n\nBroker:\n- Fix possible memory leak if bridge using SSL attempts to connect to a\n  host that is not up.\n- Free unused topic tree elements (fix in 1.4.3 was incomplete). Closes\n  #468987.\n\nClients:\n- \"mosquitto_pub -l\" now no longer limited to 1024 byte lines. Closes #478917.\n\n\n1.4.4 - 20150916\n================\n\nBroker:\n- Don't leak sockets when outgoing bridge with multiple addresses cannot\n  connect. Closes #477571.\n- Fix cross compiling of websockets. Closes #475807.\n- Fix memory free related crashes on openwrt. Closes #475707.\n- Fix excessive calls to message retry check.\n\n\n1.4.3 - 20150818\n================\n\nBroker:\n- Fix incorrect bridge notification on initial connection. Closes #467096.\n- Build fixes for OpenBSD.\n- Fix incorrect behaviour for autosave_interval, most noticable for\n  autosave_interval=1. Closes #465438.\n- Fix handling of outgoing QoS>0 messages for bridges that could not be sent\n  because the bridge connection was down.\n- Free unused topic tree elements. Closes #468987.\n- Fix some potential memory leaks. Closes #470253.\n- Fix potential crash on libwebsockets error.\n\nClient library:\n- Add missing error strings to mosquitto_strerror.\n- Handle fragmented TLS packets without a delay. Closes #470660.\n- Fix incorrect loop timeout being chosen when using threaded interface and\n  keepalive = 0. Closes #471334.\n- Increment inflight messages count correctly. Closes #474935.\n\nClients:\n- Report error string on connection failure rather than error code.\n\n\n1.4.2 - 20150507\n================\n\nBroker:\n- Fix bridge prefixes only working for the first outgoing message. Closes\n  #464437.\n- Fix incorrect bridge connection notifications on local broker.\n- Fix persistent db writing on Windows. Closes #464779.\n- ACLs are now checked before sending a will message.\n- Fix possible crash when using bridges on Windows. Closes #465384.\n- Fix parsing of auth_opt_ arguments with extra spaces/tabs.\n- Broker will return CONNACK rc=5 when a username/password is not authorised.\n  This was being incorrectly set as rc=4.\n- Fix handling of payload lengths>4096 with websockets.\n\nClient library:\n- Inflight message count wasn't being decreased for outgoing messages using\n  QoS 2, meaning that only up to 20 QoS 2 messages could be sent. This has\n  been fixed. Closes #464436.\n- Fix CMake dependencies for C++ wrapper building. Closes #463884.\n- Fix possibility of select() being called with a socket that is >FD_SETSIZE.\n  This is a fix for #464632 that will be followed up by removing the select()\n  call in a future version.\n- Fix calls to mosquitto_connect*_async() not completing.\n\n\n1.4.1 - 20150403\n================\n\nBroker:\n- Fix possible crash under heavy network load. Closes #463241.\n- Fix possible crash when using pattern ACLs.\n- Fix problems parsing config strings with multiple leading spaces. Closes\n  #462154.\n- Websockets clients are now periodically disconnected if they have not\n  maintained their keepalive timer. Closes #461619.\n- Fix possible minor memory leak on acl parsing.\n\nClient library:\n- Inflight limits should only apply to outgoing messages. Closes #461620.\n- Fix reconnect bug on Windows. Closes #463000.\n- Return -1 on error from mosquitto_socket(). Closes #461705.\n- Fix crash on multiple calls to mosquitto_lib_init/mosquitto_lib_cleanup.\n  Closes #462780.\n- Allow longer paths on Windows. Closes #462781.\n- Make _mosquitto_mid_generate() thread safe. Closes #463479.\n\n\n1.4 - 20150218\n==============\n\nImportant changes:\n- Websockets support in the broker.\n- Bridge behaviour on the local broker has changed due to the introduction of\n  the local_* options. This may affect you if you are using authentication\n  and/or ACLs with bridges.\n- The default TLS behaviour has changed to accept all of TLS v1.2, v1.1 and\n  v1.0, rather than only only one version of the protocol. It is still\n  possible to restrict a listener to a single version of TLS.\n- The Python client has been removed now that the Eclipse Paho Python client\n  has had a release.\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- New use_username_as_clientid option on the broker, for preventing hijacking\n  of a client id.\n- The client library and clients now have experimental SOCKS5 support.\n- Wildcard TLS certificates are now supported for bridges and clients.\n- The clients have support for config files with default options.\n- Client and client libraries have support for MQTT v3.1.1.\n- Bridge support for MQTT v3.1.1.\n\n\nBroker:\n- Websockets support in the broker.\n- Add local_clientid, local_username, local_password for bridge connections to\n  authenticate to the local broker.\n- Default TLS mode now accepts TLS v1.2, v1.1 and v1.0.\n- Support for ECDHE-ECDSA family ciphers.\n- Fix bug #1324411, which could have had unexpected consequences for delayed\n  messages in rare circumstances.\n- Add support for \"session present\" in CONNACK messages for MQTT v3.1.1.\n- Remove strict protocol #ifdefs.\n- Change $SYS/broker/clients/active -> $SYS/broker/clients/connected\n- Change $SYS/broker/clients/inactive -> $SYS/broker/clients/disconnected\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- libuuid is used to generate client ids, where it is available, when an MQTT\n  v3.1.1 client connects with a zero length client id.\n- Anonymous clients are no longer accidently disconnected from the broker\n  after a SIGHUP.\n- mosquitto_passwd now supports -b (batch mode) to allow the password to be\n  provided at the command line.\n- Removed $SYS/broker/changeset. This was intended for use with debugging, but\n  in practice is of no use.\n- Add support for use_username_as_clientid which can be used with\n  authentication to restrict ownership of client ids and hence prevent one\n  client disconnecting another by using the same client id.\n- When \"require_certificate\" was false, the broker was incorrectly asking for\n  a certificate (but not checking it). This caused problems with some clients\n  and has been fixed so the broker no longer asks.\n- When using syslog logging on non-Windows OSs, it is now possible to specify\n  the logging facility to one of local0-7 instead of the default \"daemon\".\n- The bridge_attempt_unsubscribe option has been added, to allow the sending\n  of UNSUBSCRIBE requests to be disabled for topics with \"out\" direction.\n  Closes bug #456899.\n- Wildcard TLS certificates are now supported for bridges.\n- Support for \"hour\" client expiration lengths for the\n  persistent_client_expiration option. Closes bug #425835.\n- Bridge support for MQTT v3.1.1.\n- Root privileges are now dropped after starting listeners and loading\n  certificates/private keys, to allow private keys to have their permissions\n  restricted to the root user only. Closes bug #452914.\n- Usernames and topics given in ACL files can now include a space. Closes bug\n  #431780.\n- Fix hang if pattern acl contains a %u but an anonymous client connect.\n  Closes bug #455402.\n- Fix man page installation with cmake. Closes bug #458843.\n- When using \"log_dest file\" the output file is now flushed periodically.\n\nClients:\n- Both clients can now load default configuration options from a file.\n- Add -C option to mosquitto_sub to allow the client to quit after receiving a\n  certain count of messages. Closes bug #453850.\n- Add --proxy SOCKS5 support for both clients.\n- Pub client supports setting its keepalive. Closes bug #454852.\n- Add support for config files with default options.\n- Add support for MQTT v3.1.1.\n\nClient library:\n- Add experimental SOCKS5 support.\n- mosquitto_loop_forever now quits after a fatal error, rather than blindly\n  retrying.\n- SRV support is now not compiled in by default.\n- Wildcard TLS certificates are now supported.\n- mosquittopp now has a virtual destructor. Closes bug #452915.\n- Add support for MQTT v3.1.1.\n- Don't quit mosquitto_loop_forever() if broker not available on first\n  connect. Closes bug #453293, but requires more work.\n\n\n1.3.5 - 20141008\n================\n\nBroker:\n- Fix possible memory leak when using a topic that has a leading slash. Fixes\n  bug #1360985.\n- Fix saving persistent database on Windows.\n- Temporarily disable ACL checks on subscriptions when using MQTT v3.1.1. This\n  is due to the complexity of checking wildcard ACLs against wildcard\n  subscriptions. This does not have a negative impact on security because\n  checks are still made before a message is sent to a client.\n  Fixes bug #1374291.\n- When using -v and the broker receives a SIGHUP, verbose logging was being\n  disabled. This has been fixed.\n\nClient library:\n- Fix mutex being incorrectly passed by value. Fixes bug #1373785.\n\n1.3.4 - 20140806\n================\n\nBroker:\n- Don't ask client for certificate when require_certificate is false.\n- Backout incomplete functionality that was incorrectly included in 1.3.2.\n\n1.3.3 - 20140801\n================\n\nBroker:\n- Fix incorrect handling of anonymous bridges on the local broker.\n\n1.3.2 - 20140713\n================\n\nBroker:\n- Don't allow access to clients when authenticating if a security plugin\n  returns an application error. Fixes bug #1340782.\n- Ensure that bridges verify certificates by default when using TLS.\n- Fix possible crash when using pattern ACLs that do not include a %u and\n  clients that connect without a username.\n- Fix subscriptions being deleted when clients subscribed to a topic beginning\n  with a $ but that is not $SYS.\n- When a durable client reconnects, its queued messages are now checked\n  against ACLs in case of a change in username/ACL state since it last\n  connected.\n- Fix bug #1324411, which could have had unexpected consequences for delayed\n  messages in rare circumstances.\n- Anonymous clients are no longer accidently disconnected from the broker\n  after a SIGHUP.\n\nClient library:\n- Fix topic matching edge case.\n- Fix callback deadlocks after calling mosquitto_disconnect(), when using the\n  threaded interfaces. Closes bug #1313725.\n- Fix SRV support when building with CMake.\n- Remove strict protocol #ifdefs.\n\nGeneral:\n- Use $(STRIP) for stripping binaries when installing, to allow easier cross\n  compilation.\n\n1.3.1 - 20140324\n================\n\nBroker:\n- Prevent possible crash on client reconnect. Closes bug #1294108.\n- Don't accept zero length unsubscription strings (MQTT v3.1.1 fix)\n- Don't accept QoS 3 (MQTT v3.1.1 fix)\n- Don't disconnect clients immediately on HUP to give chance for all data to\n  be read.\n- Reject invalid un/subscriptions e.g. foo/+bar #/bar.\n- Take more care not to disconnect clients that are sending large messages.\n\nClient library:\n- Fix socketpair code on the Mac.\n- Fix compilation for WITH_THREADING=no.\n- Break out of select() when calling mosquitto_loop_stop().\n- Reject invalid un/subscriptions e.g. foo/+bar #/bar.\n- Add mosquitto_threaded_set().\n\nClients:\n- Fix keepalive value on mosquitto_pub.\n- Fix possibility of mosquitto_pub not exiting after sending messages when\n  using -l.\n\n1.3 - 20140316\n==============\n\nBroker:\n- The broker no longer ignores the auth_plugin_init() return value.\n- Accept SSLv2/SSLv3 HELLOs when using TLSv1, whilst keeping SSLv2 and SSLv3\n  disabled. This increases client compatibility without sacrificing security.\n- The $SYS tree can now be disabled at runtime as well as at compile time.\n- When remapping bridged topics, only check for matches when the message\n  direction is correct. This allows two identical topics to be remapped\n  differently for both in and out.\n- Change \"$SYS/broker/heap/current size\" to \"$SYS/broker/heap/current\" for\n  easier parsing.\n- Change \"$SYS/broker/heap/maximum size\" to \"$SYS/broker/heap/maximum\" for\n  easier parsing.\n- Topics are no longer normalised from e.g a///topic to a/topic. This matches\n  the behaviour as clarified by the Oasis MQTT spec. This will lead to\n  unexpected behaviour if you were using topics of this form.\n- Log when outgoing messages for a client begin to drop off the end of the\n  queue.\n- Bridge clients are recognised as bridges even after reloading from\n  persistence.\n- Basic support for MQTT v3.1.1. This does not include being able to bridge to\n  an MQTT v3.1.1 broker.\n- Username is displayed in log if present when a client connects.\n- Support for 0 length client ids (v3.1.1 only) that result in automatically\n  generated client ids on the broker (see option allow_zero_length_clientid).\n- Ability to set the prefix of automatically generated client ids (see option\n  auto_id_prefix).\n- Add support for TLS session resumption.\n- When using TLS, the server now chooses the cipher to use when negotiating\n  with the client.\n- Weak TLS ciphers are now disabled by default.\n\nClient library:\n- Fix support for Python 2.6, 3.0, 3.1.\n- Add support for un/subscribing to multiple topics at once in un/subscribe().\n- Clients now close their socket after sending DISCONNECT.\n- Python client now contains its version number.\n- C library mosquitto_want_write() now supports TLS clients.\n- Fix possible memory leak in C/C++ library when communicating with\n  a broker that doesn't follow the spec.\n- Return strerror() through mosquitto_strerror() to make error printing\n  easier.\n- Topics are no longer normalised from e.g a///topic to a/topic. This matches\n  the behaviour as clarified by the Oasis MQTT spec. This will lead to\n  unexpected behaviour if you were using topics of this form.\n- Add support for SRV lookups.\n- Break out of select() on publish(), subscribe() etc. when using the threaded\n  interface. Fixes bug #1270062.\n- Handle incoming and outgoing messages separately. Fixes bug #1263172.\n- Don't terminate threads on mosquitto_destroy() when a client is not using\n  the threaded interface but does use their own thread. Fixes bug #1291473.\n\nClients:\n- Add --ciphers to allow specifying which TLS ciphers to support.\n- Add support for SRV lookups.\n- Add -N to sub client to suppress printing of EOL after the payload.\n- Add -T to sub client to suppress printing of a topic hierarchy.\n\n1.2.3 - 20131202\n================\n\nBroker:\n- Don't always attempt to call read() for SSL clients, irrespective of whether\n  they were ready to read or not. Reduces syscalls significantly.\n- Possible memory leak fixes.\n- Further fix for bug #1226040: multiple retained messages being delivered for\n  subscriptions ending in #.\n- Fix bridge reconnections when using multiple bridge addresses.\n\nClient library:\n- Fix possible memory leak in C/C++ library when communicating with\n  a broker that doesn't follow the spec.\n- Block in Python loop_stop() until all messages are sent, as the\n  documentation states should happen.\n- Fix for asynchronous connections on Windows. Closes bug #1249202.\n- Module version is now available in mosquitto.py.\n\nClients:\n- mosquitto_sub now uses fwrite() instead of printf() to output messages, so\n  messages with NULL characters aren't truncated.\n\n1.2.2 - 20131021\n================\n\nBroker:\n- Fix compliance with max_inflight_messages when a non-clean session client\n  reconnects. Closes one of the issues on bug #1237389.\n\nClient library:\n- Fix incorrect inflight message accounting, which caused messages to go\n  unsent. Partial fix for bug #1237351.\n- Fix potential memory corruption when sending QoS>0 messages at a high rate\n  using the threaded interface. Further fix for #1237351.\n- Fix incorrect delay scaling when exponential_backoff=true in\n  mosquitto_reconnect_delay_set().\n- Some pep8 fixes for Python.\n\n1.2.1 - 20130918\n================\n\nBroker:\n- The broker no longer ignores the auth_plugin_init() return value. Closes\n  bug #1215084.\n- Use RTLD_GLOBAL when opening authentication plugins on posix systems. Fixes\n  resolving of symbols in libraries used by authentication plugins.\n- Add/fix some config documentation.\n- Fix ACLs for topics with $SYS.\n- Clients loaded from the persistence file on startup were not being added to\n  the client hash, causing subtle problems when the client reconnected,\n  including ACLs failing. This has been fixed.\n- Add note to mosquitto-tls man page stating that certificates need to be\n  unique. Closes bug #1221285.\n- Fix incorrect retained message delivery when using wildcard subs in some\n  circumstances. Fixes bug #1226040.\n\nClient library:\n- Fix support for Python 2.6, 3.0, 3.1.\n- Fix TLS subjectAltName verification and segfaults.\n- Handle EAGAIN in Python on Windows. Closes bug #1220004.\n- Fix compilation when using WITH_TLS=no.\n- Don't fail reconnecting in Python when broker is temporarily unavailable.\n\n1.2 - 20130708\n==============\n\nBroker:\n- Replace O(n) username lookup on CONNECT with a roughly O(1) hashtable version.\n- It is now possible to disable $SYS at compile time.\n- Add dropped publish messages to load tree in $SYS. Closes bug #1183318.\n- Add support for logging SUBSCRIBE/UNSUBSCRIBE events.\n- Add \"log_dest file\" logging support.\n- Auth plugin ACL check function now passes the client id as well as username\n  and password.\n- The queue_qos0_messages option wasn't working correctly, this has now been\n  fixed. Closes bug #1125200.\n- Don't drop all messages for disconnected durable clients when\n  max_queued_messages=0.\n- Add support for \"log_type all\".\n- Add support for \"-v\" option on the command line to provide the equivalent of\n  \"log_type all\" without needing a config file.\n- Add the \"upgrade_outgoing_qos\" option, a non-standard feature.\n- Persistence data is now written to a temporary file which is atomically\n  renamed on completion, so a crash during writing will not produce a corrupt\n  file.\n- mosquitto.conf is now installed as mosquitto.conf.example\n- Configuration file errors are now reported with filename and line number.\n- The broker now uses a monotonic clock if available, to avoid changes in time\n  causing client disconnections or message retries.\n- Clean session and keepalive status are now display the log when a client\n  connects.\n- Add support for TLSv1.2 and TLSv1.1.\n- Clients that connect with zero length will topics are now rejected.\n- Add the ability to set a maximum allowed PUBLISH payload size.\n- Fix an ACL with topic \"#\" incorrectly granting access to $SYS.\n- Fix retained messages incorrectly being set on wildcard topics, leading to\n  duplicate retained messages being sent on subscription. Closes bug #1116233.\n- Don't discard listener values when no \"port\" option given. Closes bug\n  #1131406.\n- Client password check was always failing when security was being reapplied\n  after a config reload. This meant that all clients were being disconnected.\n  This has been fixed.\n- Fix build when WITH_TLS=no. Closes bug #1174971.\n- Fix single outgoing packets not being sent in a timely fashion if they were\n  not sent in one call to write(). Closes bug #1176796.\n- Fix remapping of messages for clients connected to a listener with\n  mount_point set. Closes bug #1180765.\n- Fix duplicate retained messages being sent for some wildcard patterns.\n- If a client connects with a will topic to which they do not have write\n  access, they are now disconnected with CONNACK \"not authorised\".\n- Fix retained messages on topic foo being incorrectly delivered to\n  subscriptions of /#\n- Fix handling of SSL errors on SSL_accept().\n- Fix handling of QoS 2 messages on client reconnect.\n- Drop privileges now sets supplementary groups correctly.\n- Fix load reporting interval (is now 60s).\n- Be strict with malformed PUBLISH packets - clients are now disconnected\n  rather than the packet discarded. This goes inline with future OASIS spec\n  changes and makes other changes more straightforward.\n- Process incoming messages denied by ACL properly so that clients don't keep\n  resending them.\n\n- Add support for round_robin bridge option.\n- Add bridge support for verifying remote server certificate subject against\n  the remote hostname.\n- Fix problem with out of order calls to free() when restarting a lazy bridge.\n- The broker now attempts to resolve bind_address and bridge addresses\n  immediately when parsing the config file in order to detect invalid hosts.\n- Bridges now set their notification state before attempting to connect, so if\n  they fail to connect the state can still be seen.\n- Fix bridge notification payload length - no need to send a null byte.\n\n- mosquitto_passwd utility now reports errors more clearly.\n- Fix \"mosquitto_passwd -U\".\n\nClient library:\n- Add support for TLSv1.2 and TLSv1.1, except for on the Python module.\n- Add support for verifying remote server certificate subject against the\n  remote hostname.\n- Add mosquitto_reconnect_async() support and make asynchronous connections\n  truely asynchronous rather than simply deferred. DNS lookups are still\n  blocking, so asynchronous connections require an IP address instead of\n  hostname.\n- Allow control of reconnection timeouts in mosquitto_loop_forever() and after\n  mosquitto_loop_start() by using mosquitto_reconnect_delay_set().\n- Fix building on Android NDK.\n- Re-raise unhandled errors in Python so as not to provide confusing error\n  messages later on.\n- Python module supports IPv6 connections.\n- mosquitto_sub_topic_tokenise() was behaving incorrectly if the last topic\n  hierarchy had only a single character. This has been fixed. Closes bug\n  #1163348.\n- Fix possible crash after disconnects when using the threaded interface with\n  TLS.\n- Allow build/install without Python. Closes bug #1174972.\n- Add support for binding connection to a local interface.\n- Implement maximum inflight messages handling.\n- Fix Python client not handling will_payload==None.\n- Fix potential memory leak when setting username/password.\n- Fix handling of QoS 2 messages on reconnect.\n- Improve handling of mosquitto_disconnect() with threaded mode.\n\n\nClients:\n- Add support for TLSv1.2 and TLSv1.1.\n- Sub client can now suppress printing of messages with the retain bit set.\n- Add support for binding connection to a local interface.\n- Implement maximum inflight messages handling for the pub client.\n\n1.1.3 - 20130211\n================\n\nBroker:\n- mosquitto_passwd utility now uses tmpfile() to generate its temporary data\n  storage file. It also creates a backup file that can be used to recover data\n  if an errors occur.\n\nOther:\n- Build script fixes to help packaging on Debian.\n\n1.1.2 - 20130130\n================\n\nClient library:\n- Fix tls_cert_reqs not being set to SSL_VERIFY_PEER by default. This meant\n  that clients were not verifying the server certificate when connecting over\n  TLS. This affects the C, C++ and Python libraries.\n\n1.1.1 - 20130116\n================\n\nBroker:\n- Fix crash on reload if using acl patterns.\n\nClient library:\n- Fix static C++ functions not being exported on Windows. Fixes bug #1098256.\n\n1.1 - 20121219\n==============\n\nBroker:\n- Add $SYS/broker/messages/dropped\n- Add $SYS/broker/clients/expired\n- Replace $SYS/broker/+/per second/+ with moving average versions published at\n  $SYS/broker/load/#\n- Add $SYS/broker/load/sockets/+ and $SYS/broker/load/connections/+\n- Documentation on password file format has been fixed.\n- Disable SSL compression. This reduces memory usage significantly and removes\n  the possibility of CRIME type attacks.\n- Enable SSL_MODE_RELEASE_BUFFERS mode to reduce SSL memory usage further.\n- Add allow_duplicate_messages option.\n- ACL files can now have comment lines with # as the first character.\n- Display message on startup about which config is being loaded.\n- Fix max_inflight_messages and max_queued_messages not being applied.\n- Fix documentation error in mosquitto.conf.\n- Ensure that QoS 2 queued messages are sent out in a timely manner.\n- Local bridges now act on clean_session correctly.\n- Local bridges with clean_session==false now remove unused subscriptions on\n  broker restart.\n- The $SYS/broker/heap/# messages now no longer include \"bytes\" as part of the\n  string for ease of use.\n\nClient library:\n- Free memory used by OpenSSL in mosquitto_lib_cleanup() where possible.\n- Change WebSocket subprotocol name to mqttv3.1 to make future changes easier\n  and for compatibility with other implementations.\n- mosquitto_loop_read() and mosquitto_loop_write() now handle errors\n  themselves rather than having mosquitto_loop() handle their errors. This\n  makes using them in a separate event loop more straightforward.\n- Add mosquitto_loop_forever() / loop_forever() function call to make simple\n  clients easier.\n- Disable SSL compression. This reduces memory usage significantly and removes\n  the possibility of CRIME type attacks.\n- Enable SSL_MODE_RELEASE_BUFFERS mode to reduce SSL memory usage further.\n- mosquitto_tls_set() will now return an error or raise an exception\n  immediately if the CA certificate or client certificate/key cannot be\n  accessed.\n- Fix potential memory leaks on connection failures.\n- Don't produce return error from mosquitto_loop() if a system call is\n  interrupted. This prevents disconnects/reconnects in threaded mode and\n  simplifies non-threaded client handling.\n- Ignore SIGPIPE to prevent unnecessary client quits in threaded mode.\n- Fix document error for mosquitto_message_retry_set().\n- Fix mosquitto_topic_matches_sub() for subscriptions with + as the final\n  character. Fixes bug #1085797.\n- Rename all \"obj\" parameters to \"userdata\" for consistency with other\n  libraries.\n- Reset errno before network read/write to ensure EAGAIN isn't mistakenly\n  returned.\n- The message queue length is now tracked and used to determine the maximum\n  number of packets to process at once. This removes the need for the\n  max_packets parameter which is now unused.\n- Fix incorrect error value in Python error_string() function. Fixes bug\n  #1086777.\n- Reset last message in/out timer in Python module when we send a PINGREQ.\n  Fixes too-early disconnects.\n\nClients:\n- Clients now display their own version number and library version number in\n  their help messages.\n- Fix \"mosquitto_pub -l -q 2\" disconnecting before all messages were\n  transmitted.\n- Fix potential out-of-bounds array access with client ids. Fixes bug\n  #1083182.\n\nOther:\n- mosquitto_passwd can now convert password files with plain text files to\n  hashed versions.\n\n1.0.5 - 20121103\n================\n\nBroker:\n- Fix crash when the broker has use_identity_as_username set to true but a\n  client connects without a certificate.\n- mosquitto_passwd should only be installed if WITH_TLS=yes.\n\nLibrary:\n- Use symbolic errno values rather than numbers in Python module to avoid\n  cross platform issues (incorrect errno on Mac OS).\n\nOther:\n- Build script fixes for FreeBSD.\n\n1.0.4 - 20121017\n================\n\nBroker:\n- Deal with poll() POLLIN/POLLOUT before POLL[RD]HUP to correctly handle the\n  case where a client sends data and immediately closes its socket.\n\nLibrary:\n- Fix memory leak with messages of QoS=2. Fixes bug #1064981.\n- Fix potential thread synchronisation problem with outgoing packets in the\n  Python module. Fixes bug #1064977.\n\nClients:\n- Fix \"mosquitto_sub -l\" incorrectly only sending one message per second.\n\n1.0.3 - 20120927\n================\n\nBroker:\n- Fix loading of psk files.\n- Don't return an error when reloading config if an ACL file isn't defined.\n  This was preventing psk files being reloaded.\n- Clarify meaning of $SYS/broker/clients/total in mosquitto(8) man page.\n- Clarify meaning of $SYS/broker/messages/stored in mosquitto(8) man page.\n- Fix non-retained message delivery when subscribing to #.\n- Fix retained message delivery for subs to foo/# with retained messages at\n  foo.\n- Include the filename in password/acl file loading errors.\n\nLibrary:\n- Fix possible AttributeError when self._sock == None in Python module.\n- Fix reconnecting after a timeout in Python module.\n- Fix reconnecting when there were outgoing packets in the queue in the Python\n  module.\n- Fix problem with mutex initialisation causing crashes on some Windows\n  installations.\n\n1.0.2 - 20120919\n================\n\nBroker:\n- If the broker was configured for persistence, a durable client had a\n  subscription to topics in $SYS/# and had messages in its queue when the\n  broker restarted, then the persistent database would have messages missing\n  and so the broker would not restart properly. This has been fixed.\n\nLibrary:\n- Fix threading problem on some systems.\n\nTests:\n- Close socket after 08-ssl-connect-no-auth-wrong-ca.py test to prevent\n  subsequent tests having problems.\n\nBuild scripts:\n- Install pskfile.example in CMake. Fixes bug #1037504.\n\nOther:\n- Fix db_dump parameter printing message store and sub chunks.\n\n1.0.1 - 20120815\n================\n\nBroker:\n- Fix default log_dest when running as a Windows service.\n\nClient library:\n- Fix incorrect parameters in Python on_log() callback call. Fixes bug\n  #1036818.\n\nClients:\n- Clients now don't display TLS/TLS-PSK usage help if they don't support it.\n\nBuild scripts:\n- Fix TLS-PSK support in the CMake build files.\n- Fix man page installation in the CMake build files.\n- Fix SYSCONFDIR in cmake on *nix when installing to /usr. Fixes bug #1036908.\n\nDocumentation:\n- Fix mqtt/MQTT capitalisation in man pages.\n- Update compiling.txt.\n- Fix incorrect callback docs in mosquitto.py. Fixes bug #1036607.\n- Fix various doc typos and remove obsolete script. Fixes bug #1037088.\n\n1.0 - 20120814\n==============\n\nBroker:\n\n- Add SSL/TLS support.\n- Add TLS-PSK support, providing a simpler encryption method for constrained\n  devices.\n- Passwords are now salted+hashed if compiled with WITH_TLS (recommended).\n- Add mosquitto_passwd for handling password files.\n- Add $SYS/broker/publish/messages/{sent|received} to show the number of\n  PUBLISH messages sent/received.\n- Add $SYS/broker/publish/bytes/{sent|received} to show the number of\n  PUBLISH bytes sent/received.\n- Add reload parameter for security init/cleanup functions.\n- Add option for expiring disconnected persistent clients.\n- Add option for queueing of QoS 0 messages when persistent clients are\n  disconnected.\n- Enforce client id limits in the broker (only when WITH_STRICT_PROTOCOL is\n  defined).\n- Fix reloading of log configuration.\n- Add support for try_private config option for bridge connections.\n- Add support for autosave_on_changes config option.\n- Add support for include_dir config option.\n- Add support for topic remapping.\n- Usernames were being lost when a non clean-session client reconnected,\n  potentially causing problems with ACLs. This has been fixed.\n- Significant improvement to memory handling on Windows.\n- Bridges with outgoing topics will now set the retain flag correctly so that\n  messages will be retained on the remote broker.\n- Incoming bridge connections are now detected by checking if bit 8 of the\n  protocol version number is set. This requires support from the remote broker.\n- Add support for notification_topic option.\n- Add $SYS/broker/subscriptions/count and $SYS/broker/retained messages/count.\n- Add restart_timeout to control the amount of time an automatic bridge will\n  wait before reconnecting.\n- Overlapping subscriptions are now handled properly. Fixes bug #928538.\n- Fix reloading of persistence_file and persistence_location.\n- Fix broker crash on incorrect protocol number.\n- Fix missing COMPAT_ECONNRESET define on Windows.\n- Clients that had disconnected were not always being detected immediately on\n  Linux. This has been fixed.\n- Don't save $SYS messages to the on-disk persistent db. All $SYS messages\n  should be reconstructed on a restart. This means bridge connection\n  notifications will now be correct on a restart.\n- Fix reloading of bridge clients from the persistent db. This means that\n  outgoing bridged topics should always work.\n- Local bridges are now no longer restricted by local ACLs.\n- Discard publish messages with zero length topics.\n- Drop to \"mosquitto\" user even if no config file specified.\n- Don't incorrectly allow topic access if ACL patterns but no normal ACL rules\n  are defined.\n\nClient library:\n\n- Add SSL/TLS support.\n- Add TLS-PSK support, providing a simpler encryption method for constrained\n  devices.\n- Add javascript/websockets client library.\n- Add \"struct mosquitto *mosq\" parameter for all callbacks in the client\n  library. This is a binary incompatible change so the soversion of the\n  libraries has been incremented. The new parameter should make it easier to\n  use callbacks in practice.\n- Add mosquitto_want_write() for use when using own select() loop with\n  mosquitto_socket().\n- Add mosquitto_connect_async() to provide a non-blocking connect client call.\n- Add mosquitto_user_data_set() to allow user data pointer to be updated.\n- Add \"int rc\" parameter to disconnect callback to indicate whether disconnect\n  was unexpected or the result of calling mosquitto_disconnect().\n- Add mosquitto_strerror() for obtaining a string description of error numbers.\n- Add mosquitto_connack_string() for obtaining a string description of MQTT\n  connection results.\n- Add mosquitto_will_clear() and change mosquitto_will_set() to only set the\n  will.\n- Add mosquitto_sub_topic_tokenise() and mosquitto_sub_topic_tokens_free()\n  utility functions to tokenise a subscription/topic string into a string\n  array.\n- Add mosquitto_topic_matches_sub() to check whether a topic matches a\n  subscription.\n- Replaced mosquitto_log_init() with mosquitto_log_callback_set() to allow\n  clients to decide what to do with log messages.\n- Client will now disconnect itself from the broker if it doesn't receive a\n  PINGRESP in the keepalive period after sending a PINGREQ.\n- Client will now send a PINGREQ if it has not received a message from the\n  broker in keepalive seconds.\n- mosquitto_new() will now generate a random client id if the id parameter is\n  NULL.\n- Added max_packets to mosquitto_loop(), mosquitto_loop_read() and\n  mosquitto_loop_write() to control the maximum number of packets that are\n  handled per call.\n- Payload parameters are now void * instead of uint8_t *.\n- The clean_session parameter has been moved from mosquitto_connect() to\n  mosquitto_new() because it is a client parameter rather than a connection\n  parameter.\n- Functions now use int instead of uint*_t where possible.\n- mosquitto_new() now sets errno to indicate failure type.\n- Return MOSQ_ERR_INVAL on zero length topic.\n- Fix automatic client id generation on Windows.\n- mosquitto_loop_misq() can now return MOSQ_ERR_NO_CONN.\n- Compile static library as well as dynamic library with default makefiles.\n- Rename C++ namespace from mosquittopp to mosqpp to remove ambiguity.\n- C++ lib_init(), lib_version() and lib_cleanup() are now in the mosqpp\n  namespace directly, not mosquittopp class members.\n- The Python library is now written in pure Python and so no longer depends on\n  libmosquitto.\n- The Python library includes SSL/TLS support.\n- The Python library should now be compatible with Python 3.\n\nOther:\n\n- Fix db_dump reading of retained messages.\n- Add example of logging all messages to mysql.\n- Add C++ client example.\n- Fix potential buffer overflow in pub/sub clients.\n- Add \"make binary\" target that doesn't make documents.\n- Add \"--help\" arguments to pub/sub clients.\n- Fix building on Solaris.\n\n0.15 - 20120205\n===============\n\n- Add support for $SYS/broker/clients/maximum and $SYS/broker/clients/active\n  topics.\n- Add support for $SYS messages/byte per second received/sent topics.\n- Updated mosquitto man page - $SYS hierarchy and signal support were out of\n  date.\n- Auto generated pub/sub client ids now include the hostname.\n- Tool for dumping persistent DB contents is available in src/db_dump. It isn't\n  installed by default.\n- Enforce topic length checks in client library.\n- Implement \"once\" and \"lazy\" bridge start types.\n- Add new return type MOSQ_ERR_ERRNO to indicate that the errno variable should\n  be checked for the real error code.\n- Add support for connection_messages config option.\n- mosquitto_sub will now refuse to run if the -c option (disable clean session)\n  is given and no client id is provided.\n- mosquitto_pub now gives more useful error messages on invalid input or other\n  error conditions.\n- Fix Python will_set() true/True typo.\n- Fix messages to topic \"a/b\" incorrectly matching on a subscription \"a\" if\n  another subscription \"a/#\" exists.\n\n0.14.4 - 20120106\n=================\n\n- Fix local bridge notification messages.\n- Fix return values for more internal library calls.\n- Fix incorrect out of memory checks in library and broker.\n- Never time out local bridge connections.\n\n0.14.3 - 20111210\n=================\n\n- Fix potential crash when client connects with an invalid CONNECT packet.\n- Fix incorrect invalid socket comparison on Windows.\n- Server shouldn't crash when a message is published to foo/ when a\n  subscription to foo/# exists (bug #901697).\n- SO_REUSEADDR doesn't work the same on Windows, so don't use it.\n- Cygwin builds now support Windows service features.\n- Fix $SYS/broker/bytes/sent reporting.\n\n0.14.2 - 20111123\n=================\n\n- Add uninstall target for libs.\n- Don't try to write packet whilst in a callback.\n\n0.14.1 - 20111117\n=================\n\n- Fix Python sytax errors (bug #891673).\n\n0.14 - 20111116\n===============\n\n- Add support for matching ACLs based on client id and username.\n- Add a Windows installer file (NSIS based).\n- Add native support for running the broker as a Windows service. This is the\n  default when installed using the new installer.\n- Fix client count for listeners. When clients disconnect, decrement the\n  count. Allow max_connections to work again.\n- Attempt to send all packets immediately upon being queued. This will result\n  in more immediate network communication in many cases.\n- Log IP address when reporting CONNACK packets if the client id isn't yet\n  known.\n- Fix payload length calculation in python will_set function.\n- Fix Python publish and will_set functions for payload=None.\n- Fix keepalive value being lost when reconnecting a client (bug #880863).\n- Persistence file writing now uses portable file functions, so the Cygwin\n  broker build should no longer be necessary.\n- Duplicate code between the client and broker side has been reduced.\n- Queued messages for clients reconnecting with clean_session=false set were\n  not being sent until the next message for that client was received. This has\n  been fixed (bug #890724).\n- Fix subscriptions to # incorrectly matching against topics beginning with /\n\n0.13 - 20110920\n===============\n\n- Implement bridge state notification messages.\n- Save client last used mid in persistent database (DB version number bumped).\n- Expose message id in Python MosquittoMessage.\n- It is now possible to set the topic QoS level for bridges.\n- Python MosquittoMessage payload parameter is now a Python string, not a\n  ctypes object which makes it much easier to use.\n- Fix queueing of messages for disconnected clients. The max_queued_messages\n  option is now obeyed.\n- C++ library is now in its own namespace, mosquittopp.\n- Add support for adding log message timestamps in the broker.\n- Fix missing mosquitto_username_pw_set() python binding.\n- Fix keepalive timeout for reconnecting non clean-session clients. Prevents\n  immediate disconnection on reconnection.\n- Fix subscription wildcard matching - a subscription of +/+ will now match\n  against /foo\n- Fix subscription wildcard matching - a subscription of foo/# will now match\n  against foo\n- When restoring persistent database, clients should be set to non\n  clean-session or their subscriptions will be immediately removed.\n- Fix SUBACK payload for multiple topic subscriptions.\n- Don't send retained messages when a client subscribes to a topic it is\n  already subscribed to.\n\n0.12 - 20110725\n===============\n\n- Reload (most) configuration on SIGHUP.\n- Memory tracking is no longer compiled in the client library.\n- Add --help option to mosquitto to display usage.\n- Add --id-prefix option to clients to allow easier use with brokers that are\n  using the clientid_prefix option.\n- Fix compilation on QNX.\n- Add -P as a synonym argument for --pw in the clients.\n- Fix python MosquittoMessage payload parameter. This is now returned as a\n  pointer to an array of c_uint8 values so binary data is handled correctly.\n  If a string is needed, use msg.payload_str\n- Fix memory leaks on client authentication.\n- If password_file is not defined then clients can now connect even if they\n  use a username/password.\n- Add mosquitto_reconnect() to the client library.\n- Add option for compiling with liberal protocol compliance support (enabled\n  by default).\n- Fix problems with clients reconnecting and old messages remaining in the\n  message store.\n- Display both ip and client id in the log message when a client connects.\n  Change the socket connection message to make it more obvious that it is just\n  a socket connection being made (bug #801135).\n- Fix retained message delivery where a subscription contains a +.\n- Be more lenient when reloading persistent database to reduce errors with\n  empty retained messages.\n\n0.11.3 - 20110707\n=================\n\n- Don't complain and quit if persistence_file option is given (bug #802423).\n- Initialise listeners correctly when clients with duplicate client ids\n  connect. Bug #801678.\n- Memory tracking is now disabled for Symbian builds due to lack of malloc.h.\n- Fix memory tracking compilation for kFreeBSD.\n- Python callbacks can now be used with class member functions.\n- Fix persistent database writing of client message chunks which caused\n  errors when restoring (bug #798164).\n\n0.11.2 - 20110626\n=================\n\n- Don't free contexts in mqtt3_context_disconnect() (bug #799688 / #801678).\n- Only free will if present when freeing a client context.\n\n0.11.1 - 20110620\n=================\n\n- Fix buffer overrun when checking for + and # in topics (bug #799688).\n- Pub client now quits if publish fails.\n\n0.11 - 20110619\n===============\n\n- Removed all old sqlite code.\n- Remove client id limit in clients.\n- Implemented $SYS/broker/heap/maximum size\n- Implemented $SYS/broker/clients/inactive to show the number of disconnected\n  non-clean session clients.\n- $SYS/broker/heap/current size and maximum size messages now include \"bytes\"\n  to match rsmb message format.\n- Implemented the retained_persistence config file option - a synonym of the\n  \"persistence\" option.\n- Added security_external.c to broker source to make it easier for third\n  parties to add support for their existing username/password and ACL database\n  for security checks. See external_security_checks.txt.\n- $SYS messages are now only republished when their value changes.\n- Windows native broker now responds to command line arguments.\n- Simplify client disconnecting so wills gets sent in all cases (bug #792468).\n- Clients now have a --quiet option.\n- The on_disconnect() callback will always be called now, even if the client\n  has disconnected unexpectedly.\n- Always close persistent DB file after restoring.\n- Return error code when exiting the clients.\n- mosquitto_publish() now returns MOSQ_ERR_INVAL if the topic contains + or #\n- mosquitto now silently rejects published messages with + or # in the topic.\n- max_connections is now a per-listener setting instead of global.\n- Connection count is now reduced when clients disconnect (bug #797983).\n\n0.10.2 - 20110106\n=================\n\n- Don't abort when connecting if the first connection fails. This is important\n  on e.g. Windows 7, where IPV6 is offered as the first choice but may not be\n  available.\n- Deal with long logging messages properly (bug #785882).\n- Fix library compilation on Symbian - no pselect() available.\n- Don't stop processing subscriptions on received messages after a\n  subscription with # matches. (bug #791206).\n\n0.10.1 - 20110512\n=================\n\n- Fix Windows compilation.\n- Fix mosquitto.py on Windows - call lib init/cleanup.\n- Don't abort when connecting if given an unknown address type (assuming an\n  IPv4 or IPv6 address is given).\n\n0.10 - 20110429\n===============\n\n- Implement support for the password_file option and accompanying\n  authentication requirements in the broker.\n- Implement topic Access Control Lists.\n- mosquitto_will_set() and mosquitto_publish() now return\n  MOSQ_ERR_PAYLOAD_SIZE if the payload is too large (>268,435,455 bytes).\n- Bridge support can now be disabled at compile time.\n- Group together network writes for outgoing packets - don't send single byte\n  writes!\n- Add support for clientid_prefixes variable.\n- Add support for the clientid config variable for controlling bridge client\n  ids.\n- Remove 32-bit database ID support because htobe64() no longer used.\n- Multiple client subscriptions to the same topic result in only a single\n  subscription. Bug #744077.\n\n0.9.3 - 20110310\n================\n\n- Set retained message status for QoS 2 messages (bug #726535).\n- Only abort with an error when opening listening sockets if no address family\n  is available, rather than aborting when any address family is not available.\n- Don't clean queued messages when a non clean session client reconnects.\n- Make mosquitto.py compatible with Python <2.6.\n- Fix mosquitto.h header includes for Windows.\n\n0.9.2 - 20110208\n================\n\n- Only send a single DISCONNECT command when using -l in the pub client.\n- Set QoS=1 on PUBREL commands to meet protocol spec.\n- Don't leak sockets on connection failure in the library.\n- Install man pages when building under cmake.\n- Fix crash bug on malformed CONNECT message.\n- Clients are now rejected if their socket peer name cannot be obtained on\n  connection.\n- Fix a number of potential problems caused when a client with a duplicate id\n  connects.\n- Install mosquitto.conf under cmake.\n\n0.9.1 - 20101203\n================\n\n- Add missing code for parsing the \"bind_address\" configuration option.\n- Fix missing include when compiling with tcp-wrappers support.\n- Add linker version script for C library to control exported functions.\n\n0.9 - 20101114\n==============\n\n- Client and message data is now stored in memory with custom routines rather\n  than a sqlite database. This removes the dependencies on sqlite, pcre and\n  sqlite3-pcre. It also means that the persistent database format has had to\n  be reimplemented in a custom format. Optional support for importing old\n  sqlite databases is provided.\n- Added IPv6 support for mosquitto and the clients.\n- Provide username and password support for the clients and client libraries.\n  This is part of the new MQTT v3.1 spec.\n- The broker supports the username and password connection flags, but will not\n  do anything with the username and password.\n- Python callback functions now optionally take an extra argument which will\n  return the user object passed to the Mosquitto() constructor, or the calling\n  python object itself if nothing was given to Mosquitto().\n- Remove the mosquitto command line option \"-i interface\".\n- Remove the mosquitto.conf \"interface\" variable.\n- Add support for the listener config variable (replaces the interface\n  variable)\n- Add support for the bind_address config variable.\n- Change the port config variable behaviour to match that of rsmb (applies to\n  the default listener only, can be given just once).\n- Fix QoS 2 protocol compliance - stop sending duplicate messages and handle\n  timeouts correctly. Fixes bug #598290.\n- Set retain flag correctly for outgoing messages. It should only be set for\n  messages sent in response to a subscribe command (ie. stale data).\n- Fix bug in returning correct CONNACK result to on_connect client callback.\n- Don't send client will if it is disconnected for exceeding its keepalive\n  timer.\n- Fix client library unsubscribe function incorrectly sending a SUBSCRIBE\n  command when it should be UNSUBSCRIBE.\n- Fix max_inflight_messages and max_queued_messages operation. These\n  parameters now apply only to QoS 1 and 2 messages and are used regardless of\n  the client connection state.\n- mosquitto.conf now installed to /etc/mosquitto/mosquitto.conf instead of\n  /etc/mosquitto.conf. The /etc/mosquitto/ directory will be used for password\n  and access control files in the future.\n- Give the compile time option of using 32-bit integers for the database IDs\n  instead of 64-bit integers. This is useful where htobe64()/be64toh() are not\n  available or for embedded systems for example.\n- The DUP bit is now set correctly when resending PUBREL messages.\n- A port to Windows native has been partially completed. This currently drops a\n  number of features, including the ability to change configuration parameters\n  and persistent storage.\n\n0.8.3 - 20101004\n================\n\n- Fix QoS 2 protocol compliance - stop sending duplicate messages and handle\n  timeouts correctly. Fixes bug #598290. (backported from future 0.9 code)\n\n0.8.2 - 20100815\n================\n\n- Fix default loop() timeout value in mosquitto.py. Previous value was 0,\n  causing high cpu load.\n- Fix message handling problem in client library when more than one message was\n  in the client queue.\n- Fix the logic used to determine whether a QoS>0 message needs to be retried.\n- Fix the Python sub.py example so that it quits on error.\n\n0.8.1 - 20100812\n================\n\n- Improve python interface\n- Fix incorrect return value from message delete function\n- Use logging function to print error messages in clients.\n- Fix python installation script DESTDIR.\n- Fix library destination path for 64-bit machines.\n\n0.8 - 20100807\n==============\n\n- Topics starting with a / are treated as distinct to those not starting with\n  a /. For example, /topic/path is different to topic/path. This matches the\n  behaviour of rsmb.\n- Correctly calculate the will QoS on a new client connection (bug #597451).\n- Add \"addresses\" configuration file variable as an alias of \"address\", for\n  better rsmb compatibility.\n- Bridge clean_session setting is now false, to give more sensible behaviour\n  and be more compatible with rsmb.\n- Add cleansession variable for configuring bridges.\n- Add keepalive_interval variable for bridges.\n- Remove default topic subscription for mosquitto_sub because the old\n  behaviour was too confusing.\n- Added a C client library, which the pub and sub clients now use.\n- Added a C++ client library (bound to the C library).\n- Added a Python client library (bound to the C library).\n- Added CMake build scripts to allow the library and clients (not the broker)\n  to be compiled natively on Windows.\n\n0.7 - 20100615\n==============\n\n- mosquitto_pub can now send null (zero length) messages.\n- Don't store QoS=0 messages for disconnected clients with subscriptions of\n  QoS>0.\n- accept() all available sockets when new clients are connecting, rather than\n  just one.\n- Add option to print debug messages in pub and sub clients.\n- hg revision is now exported via $SYS/broker/changeset\n- Send Will when client exceeds keepalive timer and is disconnected.\n- Check to see if a client has a will before sending it.\n- Correctly deal with clients connecting with the same id multiple times.\n- Add compile time option to disable heap memory tracking.\n- Use poll() instead of select() to allow >1024 clients.\n- Implement max_connections.\n- Run VACUUM on in-memory database on receiving SIGUSR2.\n- Fix bridge keepalive timeouts and reconnects.\n- Don't attempt to drop root privileges when running on Windows as this isn't\n  well supported (bug #586231).\n\n0.6.1 - 20100506\n================\n\n- Fix DB auto upgrade for messages table.\n\n0.6 - 20100505\n==============\n\n- Basic support for connecting multiple MQTT brokers together (bridging).\n- mosquitto_sub can now subscribe to multiple topics (limited to a global QoS).\n- mosquitto_pub can now send a file as a message.\n- mosquitto_pub can now read all of stdin and send it as a message.\n- mosquitto_pub can now read stdin and send each line as a message.\n- mosquitto will now correctly run VACUUM on the persistent database on exit.\n- Implement a more efficient database design, so that only one copy of each\n  message is held in the database, rather than one per subscribed client.\n- Add the store_cleanup_interval config option for dealing with the internal\n  message store.\n- Add support for disabling \"clean session\" for the sub client.\n- Add support for automatic upgrading of the mosquitto DB from v1 to v2.\n- Add persistence_file config option to allow changing the filename of the\n  persistence database. This allows multiple mosquitto DBs to be stored in the\n  same location whilst keeping persistence_location compatible with rsmb.\n- Don't store QoS=0 messages for disconnected clients. Fixes bug #572608. This\n  wasn't correctly fixed in version 0.5.\n- Don't disconnect clients if they send a PUBLISH with zero length payload\n  (bug #573610).\n- If a retained message is received with a zero length payload, the retained\n  message for that topic is deleted.\n- Send through zero length messages.\n- Produce a warning on unsupported rsmb options instead of quitting.\n- Describe clean session flag in the mqtt man page.\n- Implement the max_inflight_messages and max_queued_messages features in the\n  broker.\n\n0.5.4 - 20100311\n================\n\n- Fix memory allocation in mqtt3_fix_sub_topic() (bug #531861).\n- Remove accidental limit of 100 client connections.\n- Fix mosquitto_pub handling of messages with QoS>0 (bug #537061).\n\n0.5.3 - 20100303\n================\n\n- Will messages are now only sent when a client disconnects unexpectedly.\n- Fix all incoming topics/subscriptions that start with a / or contain\n  multiple / in a row (//).\n- Do actually disconnect client when it sends an empty subscription/topic string.\n- Add missing $SYS/broker/clients/total to man page.\n\n0.5.2 - 20100302\n================\n\n- Always update last backup time, so that the backup doesn't run every time\n  through the main loop once autosave_interval has been reached.\n- Report $SYS/broker/uptime in the same format as rsmb.\n- Make mandatory options obvious in usage output and man page of mosquitto_pub.\n  Fixes bug #529990.\n- Treat subscriptions with a trailing slash correctly. This should fix bugs\n  #530369 and #530099.\n\n0.5.1 - 20100227\n================\n\n- Must daemonise before pid file is written.\n\n0.5 - 20100227\n==============\n\n- No longer store QoS=0 messages for disconnected clients that do not have\n  clean start set.\n- Rename msg_timeout option to retry_interval for better rsmb compatibility.\n- Change persistence behaviour. The database is now stored in memory even if\n  persistence is enabled. It is written to disk when mosquitto exits and also at\n  periodic intervals as defined by the new autosave_interval option.\n- The writing of the persistence database may be forced by sending mosquitto\n  the SIGUSR1 signal.\n- Clients that do not send CONNECT as their first command are now\n  disconnected.\n- Boolean configuration values may now be specified with true/false as well as\n  1/0.\n- Log message on CONNECT with invalid protocol or protocol version.\n- Default sqlite3-pcre path on Linux is now /usr/lib/sqlite3/pcre.so to match\n  future sqlite3-pcre packages.\n- Add mosquitto_sub and mosquitto_pub, simple clients for subscribe/publish.\n- Add man pages for clients.\n- Add general man page on mqtt.\n- Root privileges are now dropped only after attempting to write a pid file\n  (if configured). This means that the pid file can be written to /var/run/\n  directly and should fix bug #523183.\n\n0.4.2 - 20100203\n================\n\n- Fix segfault on client connect with invalid protocol name/version.\n\n0.4.1 - 20100112\n===============\n\n- Fix regex used for finding retained messages to send on new subscription.\n\n0.4 - 20100105\n==============\n\n- Added support for wildcard subscriptions using + and #.\n- All network operations are now non-blocking and can cope with partial\n  packets, meaning that networking should be a lot more reliable.\n- Total messsages/bytes sent/received are now available in $SYS.\n- Improved logging information - use client ip address and id instead of\n  socket number.\n- Broker build timestamp is available in $SYS.\n- Keepalive==0 is now correctly treated as \"never disconnect\".\n- Fixed manpage installation.\n- Fixed incorrect $SYS hierarchy locations in documentation and code.\n- Debug type log messages are no longer sent to \"topics\".\n- Default logging destination no longer includes \"topics\" to prevent possible\n  error logging to the db before it is initialised.\n- Periodic $SYS messages can now be disabled.\n- stdout and stderr are flushed when logging to them to give more timely\n  updates.\n- dup is now set correctly when resending messages.\n- Database format bumped due to topic column naming fix.\n\n0.3 - 20091217\n==============\n\n- The port option in the configuration file and --port command line argument\n  may now be given any number of times to make mosquitto listen on multiple\n  sockets.\n- Add new config file and command line option \"interface\" to specify an\n  interface to listen on, rather than all interfaces.\n- Added host access control through tcp-wrappers support.\n- Set SO_REUSEADDR on the listening socket so restart is much quicker.\n- Added support for tracking current heap memory usage - this is published on\n  the topic \"$SYS/broker/heap/current size\"\n- Added code for logging to stderr, stdout, syslog and topics.\n- Added logging to numerous places - still plenty of scope for more.\n\n0.2 - 20091204\n==============\n\n- Replaced the command line option --foreground with --daemon, swapping the\n  default behaviour.\n- Added the command line option --config-file, to specify a config file to\n  load.  If this is not given, no config file is load and the default options\n  are used.\n- Added the command line option --port for specifying the port to listen on.\n  This overrides values in the config file.\n- Don't use persistence by default.\n- Default behaviour is now more sane when run by a normal user with no command\n  line options (combination of above changes).\n- Added option user to config file, defaulting to a value of mosquitto. If\n  this value isn't blank and mosquitto is started by root, then it will drop\n  privileges by changing to the user and its primary group. This replaces the\n  current behaviour of refusing to start if run by root.\n- Fix non-persistent mode, which would never work in the previous release.\n- Added information on default values of msg_timeout and sys_interval to the\n  mosquitto.conf man page. (closes bug #492045).\n", "/*\nCopyright (c) 2009-2018 Roger Light <roger@atchoo.org>\n\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nand Eclipse Distribution License v1.0 which accompany this distribution.\n\nThe Eclipse Public License is available at\n   http://www.eclipse.org/legal/epl-v10.html\nand the Eclipse Distribution License is available at\n  http://www.eclipse.org/org/documents/edl-v10.php.\n\nContributors:\n   Roger Light - initial implementation and documentation.\n*/\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef WIN32\n#else\n#  include <dirent.h>\n#  include <strings.h>\n#endif\n\n#ifndef WIN32\n#  include <netdb.h>\n#  include <sys/socket.h>\n#else\n#  include <winsock2.h>\n#  include <ws2tcpip.h>\n#endif\n\n#if !defined(WIN32) && !defined(__CYGWIN__)\n#  include <syslog.h>\n#endif\n\n#include \"mosquitto_broker_internal.h\"\n#include \"memory_mosq.h\"\n#include \"tls_mosq.h\"\n#include \"util_mosq.h\"\n#include \"mqtt3_protocol.h\"\n\nstruct config_recurse {\n\tint log_dest;\n\tint log_dest_set;\n\tint log_type;\n\tint log_type_set;\n\tunsigned long max_inflight_bytes;\n\tunsigned long max_queued_bytes;\n\tint max_inflight_messages;\n\tint max_queued_messages;\n};\n\n#if defined(WIN32) || defined(__CYGWIN__)\n#include <windows.h>\nextern SERVICE_STATUS_HANDLE service_handle;\n#endif\n\nstatic int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr);\nstatic int conf__parse_int(char **token, const char *name, int *value, char *saveptr);\nstatic int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr);\nstatic int conf__parse_string(char **token, const char *name, char **value, char *saveptr);\nstatic int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *config_tmp, int level, int *lineno);\nstatic int config__check(struct mosquitto__config *config);\nstatic void config__cleanup_plugins(struct mosquitto__config *config);\n\nstatic char *fgets_extending(char **buf, int *buflen, FILE *stream)\n{\n\tchar *rc;\n\tchar endchar;\n\tint offset = 0;\n\tchar *newbuf;\n\n\tdo{\n\t\trc = fgets(&((*buf)[offset]), *buflen-offset, stream);\n\t\tif(feof(stream)){\n\t\t\treturn rc;\n\t\t}\n\n\t\tendchar = (*buf)[strlen(*buf)-1];\n\t\tif(endchar == '\\n'){\n\t\t\treturn rc;\n\t\t}\n\t\t/* No EOL char found, so extend buffer */\n\t\toffset = *buflen-1;\n\t\t*buflen += 1000;\n\t\tnewbuf = realloc(*buf, *buflen);\n\t\tif(!newbuf){\n\t\t\treturn NULL;\n\t\t}\n\t\t*buf = newbuf;\n\t}while(1);\n}\n\n\nstatic void conf__set_cur_security_options(struct mosquitto__config *config, struct mosquitto__listener *cur_listener, struct mosquitto__security_options **security_options)\n{\n\tif(config->per_listener_settings){\n\t\t(*security_options) = &cur_listener->security_options;\n\t}else{\n\t\t(*security_options) = &config->security_options;\n\t}\n}\n\nstatic int conf__attempt_resolve(const char *host, const char *text, int log, const char *msg)\n{\n\tstruct addrinfo gai_hints;\n\tstruct addrinfo *gai_res;\n\tint rc;\n\n\tmemset(&gai_hints, 0, sizeof(struct addrinfo));\n\tgai_hints.ai_family = AF_UNSPEC;\n\tgai_hints.ai_socktype = SOCK_STREAM;\n\tgai_res = NULL;\n\trc = getaddrinfo(host, NULL, &gai_hints, &gai_res);\n\tif(gai_res){\n\t\tfreeaddrinfo(gai_res);\n\t}\n\tif(rc != 0){\n#ifndef WIN32\n\t\tif(rc == EAI_SYSTEM){\n\t\t\tif(errno == ENOENT){\n\t\t\t\tlog__printf(NULL, log, \"%s: Unable to resolve %s %s.\", msg, text, host);\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s: %s.\", msg, text, strerror(errno));\n\t\t\t}\n\t\t}else{\n\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s: %s.\", msg, text, gai_strerror(rc));\n\t\t}\n#else\n\t\tif(rc == WSAHOST_NOT_FOUND){\n\t\t\tlog__printf(NULL, log, \"%s: Error resolving %s.\", msg, text);\n\t\t}\n#endif\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nstatic void config__init_reload(struct mosquitto_db *db, struct mosquitto__config *config)\n{\n\tint i;\n\t/* Set defaults */\n\tfor(i=0; i<config->listener_count; i++){\n\t\tmosquitto__free(config->listeners[i].security_options.acl_file);\n\t\tconfig->listeners[i].security_options.acl_file = NULL;\n\n\t\tmosquitto__free(config->listeners[i].security_options.password_file);\n\t\tconfig->listeners[i].security_options.password_file = NULL;\n\n\t\tmosquitto__free(config->listeners[i].security_options.psk_file);\n\t\tconfig->listeners[i].security_options.psk_file = NULL;\n\n\t\tconfig->listeners[i].security_options.allow_anonymous = -1;\n\t\tconfig->listeners[i].security_options.allow_zero_length_clientid = true;\n\t\tconfig->listeners[i].security_options.auto_id_prefix = NULL;\n\t\tconfig->listeners[i].security_options.auto_id_prefix_len = 0;\n\t}\n\n\tconfig->allow_duplicate_messages = false;\n\n\tmosquitto__free(config->security_options.acl_file);\n\tconfig->security_options.acl_file = NULL;\n\n\tconfig->security_options.allow_anonymous = -1;\n\tconfig->security_options.allow_zero_length_clientid = true;\n\tconfig->security_options.auto_id_prefix = NULL;\n\tconfig->security_options.auto_id_prefix_len = 0;\n\n\tmosquitto__free(config->security_options.password_file);\n\tconfig->security_options.password_file = NULL;\n\n\tmosquitto__free(config->security_options.psk_file);\n\tconfig->security_options.psk_file = NULL;\n\n\tconfig->autosave_interval = 1800;\n\tconfig->autosave_on_changes = false;\n\tmosquitto__free(config->clientid_prefixes);\n\tconfig->connection_messages = true;\n\tconfig->clientid_prefixes = NULL;\n\tconfig->per_listener_settings = false;\n\tif(config->log_fptr){\n\t\tfclose(config->log_fptr);\n\t\tconfig->log_fptr = NULL;\n\t}\n\tmosquitto__free(config->log_file);\n\tconfig->log_file = NULL;\n\n#if defined(WIN32) || defined(__CYGWIN__)\n\tif(service_handle){\n\t\t/* This is running as a Windows service. Default to no logging. Using\n\t\t * stdout/stderr is forbidden because the first clients to connect will\n\t\t * get log information sent to them for some reason. */\n\t\tconfig->log_dest = MQTT3_LOG_NONE;\n\t}else{\n\t\tconfig->log_dest = MQTT3_LOG_STDERR;\n\t}\n#else\n\tconfig->log_facility = LOG_DAEMON;\n\tconfig->log_dest = MQTT3_LOG_STDERR;\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}else{\n\t\tconfig->log_type = MOSQ_LOG_ERR | MOSQ_LOG_WARNING | MOSQ_LOG_NOTICE | MOSQ_LOG_INFO;\n\t}\n#endif\n\tconfig->log_timestamp = true;\n\tconfig->persistence = false;\n\tmosquitto__free(config->persistence_location);\n\tconfig->persistence_location = NULL;\n\tmosquitto__free(config->persistence_file);\n\tconfig->persistence_file = NULL;\n\tconfig->persistent_client_expiration = 0;\n\tconfig->queue_qos0_messages = false;\n\tconfig->set_tcp_nodelay = false;\n\tconfig->sys_interval = 10;\n\tconfig->upgrade_outgoing_qos = false;\n\n\tconfig__cleanup_plugins(config);\n}\n\n\nstatic void config__cleanup_plugins(struct mosquitto__config *config)\n{\n\tint i, j;\n\tstruct mosquitto__auth_plugin_config *plug;\n\n\tif(config->security_options.auth_plugin_configs){\n\t\tfor(i=0; i<config->security_options.auth_plugin_config_count; i++){\n\t\t\tplug = &config->security_options.auth_plugin_configs[i];\n\t\t\tmosquitto__free(plug->path);\n\t\t\tplug->path = NULL;\n\n\t\t\tif(plug->options){\n\t\t\t\tfor(j=0; j<plug->option_count; j++){\n\t\t\t\t\tmosquitto__free(plug->options[j].key);\n\t\t\t\t\tmosquitto__free(plug->options[j].value);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(plug->options);\n\t\t\t\tplug->options = NULL;\n\t\t\t\tplug->option_count = 0;\n\t\t\t}\n\t\t}\n\t\tmosquitto__free(config->security_options.auth_plugin_configs);\n\t\tconfig->security_options.auth_plugin_configs = NULL;\n\t}\n}\n\n\nvoid config__init(struct mosquitto_db *db, struct mosquitto__config *config)\n{\n\tmemset(config, 0, sizeof(struct mosquitto__config));\n\tconfig__init_reload(db, config);\n\n\tconfig->daemon = false;\n\tmemset(&config->default_listener, 0, sizeof(struct mosquitto__listener));\n\tconfig->default_listener.max_connections = -1;\n\tconfig->default_listener.protocol = mp_mqtt;\n\tconfig->default_listener.security_options.allow_anonymous = -1;\n}\n\nvoid config__cleanup(struct mosquitto__config *config)\n{\n\tint i;\n\tint j;\n\n\tmosquitto__free(config->clientid_prefixes);\n\tmosquitto__free(config->persistence_location);\n\tmosquitto__free(config->persistence_file);\n\tmosquitto__free(config->persistence_filepath);\n\tmosquitto__free(config->security_options.auto_id_prefix);\n\tmosquitto__free(config->security_options.acl_file);\n\tmosquitto__free(config->security_options.password_file);\n\tmosquitto__free(config->security_options.psk_file);\n\tmosquitto__free(config->pid_file);\n\tif(config->listeners){\n\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\tmosquitto__free(config->listeners[i].host);\n\t\t\tmosquitto__free(config->listeners[i].mount_point);\n\t\t\tmosquitto__free(config->listeners[i].socks);\n\t\t\tmosquitto__free(config->listeners[i].security_options.auto_id_prefix);\n\t\t\tmosquitto__free(config->listeners[i].security_options.acl_file);\n\t\t\tmosquitto__free(config->listeners[i].security_options.password_file);\n\t\t\tmosquitto__free(config->listeners[i].security_options.psk_file);\n#ifdef WITH_TLS\n\t\t\tmosquitto__free(config->listeners[i].cafile);\n\t\t\tmosquitto__free(config->listeners[i].capath);\n\t\t\tmosquitto__free(config->listeners[i].certfile);\n\t\t\tmosquitto__free(config->listeners[i].keyfile);\n\t\t\tmosquitto__free(config->listeners[i].ciphers);\n\t\t\tmosquitto__free(config->listeners[i].psk_hint);\n\t\t\tmosquitto__free(config->listeners[i].crlfile);\n\t\t\tmosquitto__free(config->listeners[i].tls_version);\n#ifdef WITH_WEBSOCKETS\n\t\t\tif(!config->listeners[i].ws_context) /* libwebsockets frees its own SSL_CTX */\n#endif\n\t\t\t{\n\t\t\t\tSSL_CTX_free(config->listeners[i].ssl_ctx);\n\t\t\t}\n#endif\n#ifdef WITH_WEBSOCKETS\n\t\t\tmosquitto__free(config->listeners[i].http_dir);\n#endif\n\t\t}\n\t\tmosquitto__free(config->listeners);\n\t}\n#ifdef WITH_BRIDGE\n\tif(config->bridges){\n\t\tfor(i=0; i<config->bridge_count; i++){\n\t\t\tmosquitto__free(config->bridges[i].name);\n\t\t\tif(config->bridges[i].addresses){\n\t\t\t\tfor(j=0; j<config->bridges[i].address_count; j++){\n\t\t\t\t\tmosquitto__free(config->bridges[i].addresses[j].address);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(config->bridges[i].addresses);\n\t\t\t}\n\t\t\tmosquitto__free(config->bridges[i].remote_clientid);\n\t\t\tmosquitto__free(config->bridges[i].remote_username);\n\t\t\tmosquitto__free(config->bridges[i].remote_password);\n\t\t\tmosquitto__free(config->bridges[i].local_clientid);\n\t\t\tmosquitto__free(config->bridges[i].local_username);\n\t\t\tmosquitto__free(config->bridges[i].local_password);\n\t\t\tif(config->bridges[i].topics){\n\t\t\t\tfor(j=0; j<config->bridges[i].topic_count; j++){\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].topic);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].local_prefix);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].remote_prefix);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].local_topic);\n\t\t\t\t\tmosquitto__free(config->bridges[i].topics[j].remote_topic);\n\t\t\t\t}\n\t\t\t\tmosquitto__free(config->bridges[i].topics);\n\t\t\t}\n\t\t\tmosquitto__free(config->bridges[i].notification_topic);\n#ifdef WITH_TLS\n\t\t\tmosquitto__free(config->bridges[i].tls_version);\n\t\t\tmosquitto__free(config->bridges[i].tls_cafile);\n#ifdef WITH_TLS_PSK\n\t\t\tmosquitto__free(config->bridges[i].tls_psk_identity);\n\t\t\tmosquitto__free(config->bridges[i].tls_psk);\n#endif\n#endif\n\t\t}\n\t\tmosquitto__free(config->bridges);\n\t}\n#endif\n\tconfig__cleanup_plugins(config);\n\n\tif(config->log_fptr){\n\t\tfclose(config->log_fptr);\n\t\tconfig->log_fptr = NULL;\n\t}\n\tif(config->log_file){\n\t\tmosquitto__free(config->log_file);\n\t\tconfig->log_file = NULL;\n\t}\n}\n\nstatic void print_usage(void)\n{\n\tprintf(\"mosquitto version %s\\n\\n\", VERSION);\n\tprintf(\"mosquitto is an MQTT v3.1.1 broker.\\n\\n\");\n\tprintf(\"Usage: mosquitto [-c config_file] [-d] [-h] [-p port]\\n\\n\");\n\tprintf(\" -c : specify the broker config file.\\n\");\n\tprintf(\" -d : put the broker into the background after starting.\\n\");\n\tprintf(\" -h : display this help.\\n\");\n\tprintf(\" -p : start the broker listening on the specified port.\\n\");\n\tprintf(\"      Not recommended in conjunction with the -c option.\\n\");\n\tprintf(\" -v : verbose mode - enable all logging types. This overrides\\n\");\n\tprintf(\"      any logging options given in the config file.\\n\");\n\tprintf(\"\\nSee http://mosquitto.org/ for more information.\\n\\n\");\n}\n\nint config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n\t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n\t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n#endif\n\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}\n\nvoid config__copy(struct mosquitto__config *src, struct mosquitto__config *dest)\n{\n\tmosquitto__free(dest->security_options.acl_file);\n\tdest->security_options.acl_file = src->security_options.acl_file;\n\n\tdest->security_options.allow_anonymous = src->security_options.allow_anonymous;\n\tdest->security_options.allow_zero_length_clientid = src->security_options.allow_zero_length_clientid;\n\n\tmosquitto__free(dest->security_options.auto_id_prefix);\n\tdest->security_options.auto_id_prefix = src->security_options.auto_id_prefix;\n\tdest->security_options.auto_id_prefix_len = src->security_options.auto_id_prefix_len;\n\n\tmosquitto__free(dest->security_options.password_file);\n\tdest->security_options.password_file = src->security_options.password_file;\n\n\tmosquitto__free(dest->security_options.psk_file);\n\tdest->security_options.psk_file = src->security_options.psk_file;\n\n\n\tdest->allow_duplicate_messages = src->allow_duplicate_messages;\n\n\n\tdest->autosave_interval = src->autosave_interval;\n\tdest->autosave_on_changes = src->autosave_on_changes;\n\n\tmosquitto__free(dest->clientid_prefixes);\n\tdest->clientid_prefixes = src->clientid_prefixes;\n\n\tdest->connection_messages = src->connection_messages;\n\tdest->log_dest = src->log_dest;\n\tdest->log_facility = src->log_facility;\n\tdest->log_type = src->log_type;\n\tdest->log_timestamp = src->log_timestamp;\n\n\tmosquitto__free(dest->log_file);\n\tdest->log_file = src->log_file;\n\n\tdest->message_size_limit = src->message_size_limit;\n\n\tdest->persistence = src->persistence;\n\n\tmosquitto__free(dest->persistence_location);\n\tdest->persistence_location = src->persistence_location;\n\n\tmosquitto__free(dest->persistence_file);\n\tdest->persistence_file = src->persistence_file;\n\n\tmosquitto__free(dest->persistence_filepath);\n\tdest->persistence_filepath = src->persistence_filepath;\n\n\tdest->persistent_client_expiration = src->persistent_client_expiration;\n\n\n\tdest->queue_qos0_messages = src->queue_qos0_messages;\n\tdest->sys_interval = src->sys_interval;\n\tdest->upgrade_outgoing_qos = src->upgrade_outgoing_qos;\n\n#ifdef WITH_WEBSOCKETS\n\tdest->websockets_log_level = src->websockets_log_level;\n#endif\n}\n\n\nint config__read(struct mosquitto_db *db, struct mosquitto__config *config, bool reload)\n{\n\tint rc = MOSQ_ERR_SUCCESS;\n\tstruct config_recurse cr;\n\tint lineno = 0;\n\tint len;\n\tstruct mosquitto__config config_reload;\n\tint i;\n\n\tif(reload){\n\t\tmemset(&config_reload, 0, sizeof(struct mosquitto__config));\n\t}\n\n\tcr.log_dest = MQTT3_LOG_NONE;\n\tcr.log_dest_set = 0;\n\tcr.log_type = MOSQ_LOG_NONE;\n\tcr.log_type_set = 0;\n\tcr.max_inflight_bytes = 0;\n\tcr.max_inflight_messages = 20;\n\tcr.max_queued_bytes = 0;\n\tcr.max_queued_messages = 100;\n\n\tif(!db->config_file) return 0;\n\n\tif(reload){\n\t\t/* Re-initialise appropriate config vars to default for reload. */\n\t\tconfig__init_reload(db, &config_reload);\n\t\tconfig_reload.listeners = config->listeners;\n\t\tconfig_reload.listener_count = config->listener_count;\n\t\trc = config__read_file(&config_reload, reload, db->config_file, &cr, 0, &lineno);\n\t}else{\n\t\trc = config__read_file(config, reload, db->config_file, &cr, 0, &lineno);\n\t}\n\tif(rc){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", db->config_file, lineno);\n\t\treturn rc;\n\t}\n\n\tif(reload){\n\t\tconfig__copy(&config_reload, config);\n\t}\n\n\t/* If auth/access options are set and allow_anonymous not explicitly set, disallow anon. */\n\tif(config->per_listener_settings){\n\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\tif(config->listeners[i].security_options.allow_anonymous == -1){\n\t\t\t\tif(config->listeners[i].security_options.password_file\n\t\t\t\t\t|| config->listeners[i].security_options.psk_file\n\t\t\t\t\t|| config->listeners[i].security_options.auth_plugin_configs){\n\n\t\t\t\t\t/* allow_anonymous not set explicitly, some other security options\n\t\t\t\t\t* have been set - so disable allow_anonymous\n\t\t\t\t\t*/\n\t\t\t\t\tconfig->listeners[i].security_options.allow_anonymous = false;\n\t\t\t\t}else{\n\t\t\t\t\t/* Default option if no security options set */\n\t\t\t\t\tconfig->listeners[i].security_options.allow_anonymous = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(config->security_options.allow_anonymous == -1){\n\t\t\tif(config->security_options.password_file\n\t\t\t\t || config->security_options.psk_file\n\t\t\t\t || config->security_options.auth_plugin_configs){\n\n\t\t\t\t/* allow_anonymous not set explicitly, some other security options\n\t\t\t\t* have been set - so disable allow_anonymous\n\t\t\t\t*/\n\t\t\t\tconfig->security_options.allow_anonymous = false;\n\t\t\t}else{\n\t\t\t\t/* Default option if no security options set */\n\t\t\t\tconfig->security_options.allow_anonymous = true;\n\t\t\t}\n\t\t}\n\t}\n#ifdef WITH_PERSISTENCE\n\tif(config->persistence){\n\t\tif(!config->persistence_file){\n\t\t\tconfig->persistence_file = mosquitto__strdup(\"mosquitto.db\");\n\t\t\tif(!config->persistence_file) return MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmosquitto__free(config->persistence_filepath);\n\t\tif(config->persistence_location && strlen(config->persistence_location)){\n\t\t\tlen = strlen(config->persistence_location) + strlen(config->persistence_file) + 1;\n\t\t\tconfig->persistence_filepath = mosquitto__malloc(len);\n\t\t\tif(!config->persistence_filepath) return MOSQ_ERR_NOMEM;\n\t\t\tsnprintf(config->persistence_filepath, len, \"%s%s\", config->persistence_location, config->persistence_file);\n\t\t}else{\n\t\t\tconfig->persistence_filepath = mosquitto__strdup(config->persistence_file);\n\t\t\tif(!config->persistence_filepath) return MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n#endif\n\t/* Default to drop to mosquitto user if no other user specified. This must\n\t * remain here even though it is covered in config__parse_args() because this\n\t * function may be called on its own. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\n\tdb__limits_set(cr.max_inflight_messages, cr.max_inflight_bytes, cr.max_queued_messages, cr.max_queued_bytes);\n\n#ifdef WITH_BRIDGE\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tif(!config->bridges[i].name || !config->bridges[i].addresses || !config->bridges[i].topic_count){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n#ifdef WITH_TLS_PSK\n\t\tif(config->bridges[i].tls_psk && !config->bridges[i].tls_psk_identity){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration: missing bridge_identity.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\tif(config->bridges[i].tls_psk_identity && !config->bridges[i].tls_psk){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration: missing bridge_psk.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n#endif\n\t}\n#endif\n\n\tif(cr.log_dest_set){\n\t\tconfig->log_dest = cr.log_dest;\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}else if(cr.log_type_set){\n\t\tconfig->log_type = cr.log_type;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nint config__read_file_core(struct mosquitto__config *config, bool reload, struct config_recurse *cr, int level, int *lineno, FILE *fptr, char **buf, int *buflen)\n{\n\tint rc;\n\tchar *token;\n\tint tmp_int;\n\tchar *saveptr = NULL;\n#ifdef WITH_BRIDGE\n\tchar *tmp_char;\n\tstruct mosquitto__bridge *cur_bridge = NULL;\n\tstruct mosquitto__bridge_topic *cur_topic;\n#endif\n\tstruct mosquitto__auth_plugin_config *cur_auth_plugin_config = NULL;\n\n\ttime_t expiration_mult;\n\tchar *key;\n\tchar *conf_file;\n#ifdef WIN32\n\tHANDLE fh;\n\tchar dirpath[MAX_PATH];\n\tWIN32_FIND_DATA find_data;\n#else\n\tDIR *dh;\n\tstruct dirent *de;\n#endif\n\tint len;\n\tstruct mosquitto__listener *cur_listener = &config->default_listener;\n\tint i;\n\tint lineno_ext;\n\tstruct mosquitto__security_options *cur_security_options = NULL;\n\n\t*lineno = 0;\n\n\twhile(fgets_extending(buf, buflen, fptr)){\n\t\t(*lineno)++;\n\t\tif((*buf)[0] != '#' && (*buf)[0] != 10 && (*buf)[0] != 13){\n\t\t\twhile((*buf)[strlen((*buf))-1] == 10 || (*buf)[strlen((*buf))-1] == 13){\n\t\t\t\t(*buf)[strlen((*buf))-1] = 0;\n\t\t\t}\n\t\t\ttoken = strtok_r((*buf), \" \", &saveptr);\n\t\t\tif(token){\n\t\t\t\tif(!strcmp(token, \"acl_file\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->acl_file);\n\t\t\t\t\t\tcur_security_options->acl_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"acl_file\", &cur_security_options->acl_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"address\") || !strcmp(token, \"addresses\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge || cur_bridge->addresses){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\twhile((token = strtok_r(NULL, \" \", &saveptr))){\n\t\t\t\t\t\tcur_bridge->address_count++;\n\t\t\t\t\t\tcur_bridge->addresses = mosquitto__realloc(cur_bridge->addresses, sizeof(struct bridge_address)*cur_bridge->address_count);\n\t\t\t\t\t\tif(!cur_bridge->addresses){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->addresses[cur_bridge->address_count-1].address = token;\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=0; i<cur_bridge->address_count; i++){\n\t\t\t\t\t\t/* cur_bridge->addresses[i].address is now\n\t\t\t\t\t\t * \"address[:port]\". If address is an IPv6 address,\n\t\t\t\t\t\t * then port is required. We must check for the :\n\t\t\t\t\t\t * backwards. */\n\t\t\t\t\t\ttmp_char = strrchr(cur_bridge->addresses[i].address, ':');\n\t\t\t\t\t\tif(tmp_char){\n\t\t\t\t\t\t\t/* Remove ':', so cur_bridge->addresses[i].address\n\t\t\t\t\t\t\t * now just looks like the address. */\n\t\t\t\t\t\t\ttmp_char[0] = '\\0';\n\n\t\t\t\t\t\t\t/* The remainder of the string */\n\t\t\t\t\t\t\ttmp_int = atoi(&tmp_char[1]);\n\t\t\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur_bridge->addresses[i].port = tmp_int;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_bridge->addresses[i].port = 1883;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* This looks a bit weird, but isn't. Before this\n\t\t\t\t\t\t * call, cur_bridge->addresses[i].address points\n\t\t\t\t\t\t * to the tokenised part of the line, it will be\n\t\t\t\t\t\t * reused in a future parse of a config line so we\n\t\t\t\t\t\t * must duplicate it. */\n\t\t\t\t\t\tcur_bridge->addresses[i].address = mosquitto__strdup(cur_bridge->addresses[i].address);\n\t\t\t\t\t\tconf__attempt_resolve(cur_bridge->addresses[i].address, \"bridge address\", MOSQ_LOG_WARNING, \"Warning\");\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->address_count == 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty address value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"allow_anonymous\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_anonymous\", (bool *)&cur_security_options->allow_anonymous, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"allow_duplicate_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_duplicate_messages\", &config->allow_duplicate_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"allow_zero_length_clientid\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_bool(&token, \"allow_zero_length_clientid\", &cur_security_options->allow_zero_length_clientid, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strncmp(token, \"auth_opt_\", 9)){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tif(!cur_auth_plugin_config){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: An auth_opt_ option exists in the config file without an auth_plugin.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(strlen(token) < 12){\n\t\t\t\t\t\t/* auth_opt_ == 9, + one digit key == 10, + one space == 11, + one value == 12 */\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid auth_opt_ config option.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tkey = mosquitto__strdup(&token[9]);\n\t\t\t\t\tif(!key){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t}else if(STREMPTY(key)){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid auth_opt_ config option.\");\n\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken += 9+strlen(key)+1;\n\t\t\t\t\twhile(token[0] == ' ' || token[0] == '\\t'){\n\t\t\t\t\t\ttoken++;\n\t\t\t\t\t}\n\t\t\t\t\tif(token[0]){\n\t\t\t\t\t\tcur_auth_plugin_config->option_count++;\n\t\t\t\t\t\tcur_auth_plugin_config->options = mosquitto__realloc(cur_auth_plugin_config->options, cur_auth_plugin_config->option_count*sizeof(struct mosquitto_auth_opt));\n\t\t\t\t\t\tif(!cur_auth_plugin_config->options){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].key = key;\n\t\t\t\t\t\tcur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", key);\n\t\t\t\t\t\tmosquitto__free(key);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"auth_plugin\")){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tcur_security_options->auth_plugin_configs = mosquitto__realloc(cur_security_options->auth_plugin_configs, (cur_security_options->auth_plugin_config_count+1)*sizeof(struct mosquitto__auth_plugin_config));\n\t\t\t\t\tif(!cur_security_options->auth_plugin_configs){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t}\n\t\t\t\t\tcur_auth_plugin_config = &cur_security_options->auth_plugin_configs[cur_security_options->auth_plugin_config_count];\n\t\t\t\t\tmemset(cur_auth_plugin_config, 0, sizeof(struct mosquitto__auth_plugin_config));\n\t\t\t\t\tcur_auth_plugin_config->path = NULL;\n\t\t\t\t\tcur_auth_plugin_config->options = NULL;\n\t\t\t\t\tcur_auth_plugin_config->option_count = 0;\n\t\t\t\t\tcur_auth_plugin_config->deny_special_chars = true;\n\t\t\t\t\tcur_security_options->auth_plugin_config_count++;\n\t\t\t\t\tif(conf__parse_string(&token, \"auth_plugin\", &cur_auth_plugin_config->path, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"auth_plugin_deny_special_chars\")){\n\t\t\t\t\tif(reload) continue; // Auth plugin not currently valid for reloading.\n\t\t\t\t\tif(!cur_auth_plugin_config){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: An auth_plugin_deny_special_chars option exists in the config file without an auth_plugin.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"auth_plugin_deny_special_chars\", &cur_auth_plugin_config->deny_special_chars, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"auto_id_prefix\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(conf__parse_string(&token, \"auto_id_prefix\", &cur_security_options->auto_id_prefix, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_security_options->auto_id_prefix){\n\t\t\t\t\t\tcur_security_options->auto_id_prefix_len = strlen(cur_security_options->auto_id_prefix);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_security_options->auto_id_prefix_len = 0;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"autosave_interval\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"autosave_interval\", &config->autosave_interval, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->autosave_interval < 0) config->autosave_interval = 0;\n\t\t\t\t}else if(!strcmp(token, \"autosave_on_changes\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"autosave_on_changes\", &config->autosave_on_changes, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"bind_address\")){\n\t\t\t\t\tif(reload) continue; // Listener not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"default listener bind_address\", &config->default_listener.host, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(conf__attempt_resolve(config->default_listener.host, \"bind_address\", MOSQ_LOG_ERR, \"Error\")){\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"bridge_attempt_unsubscribe\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"bridge_attempt_unsubscribe\", &cur_bridge->attempt_unsubscribe, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_cafile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_cafile\", &cur_bridge->tls_cafile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_capath\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_capath\", &cur_bridge->tls_capath, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_certfile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_certfile\", &cur_bridge->tls_certfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_identity\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS_PSK)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and identity encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_identity\", &cur_bridge->tls_psk_identity, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_insecure\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"bridge_insecure\", &cur_bridge->tls_insecure, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->tls_insecure){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge %s using insecure mode.\", cur_bridge->name);\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_keyfile\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_keyfile\", &cur_bridge->tls_keyfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_protocol_version\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"mqttv31\")){\n\t\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt31;\n\t\t\t\t\t\t}else if(!strcmp(token, \"mqttv311\")){\n\t\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt311;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge_protocol_version value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty bridge_protocol_version value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_psk\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS_PSK)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single bridge.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_psk\", &cur_bridge->tls_psk, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"bridge_tls_version\")){\n#if defined(WITH_BRIDGE) && defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge_tls_version\", &cur_bridge->tls_version, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge and/or TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"cafile\")){\n#if defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(cur_listener->psk_hint){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single listener.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"cafile\", &cur_listener->cafile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"capath\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"capath\", &cur_listener->capath, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"certfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(cur_listener->psk_hint){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot use both certificate and psk encryption in a single listener.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"certfile\", &cur_listener->certfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"ciphers\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"ciphers\", &cur_listener->ciphers, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"clientid\") || !strcmp(token, \"remote_clientid\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge remote clientid\", &cur_bridge->remote_clientid, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"cleansession\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"cleansession\", &cur_bridge->clean_session, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"clientid_prefixes\")){\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(config->clientid_prefixes);\n\t\t\t\t\t\tconfig->clientid_prefixes = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"clientid_prefixes\", &config->clientid_prefixes, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"connection\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\t/* Check for existing bridge name. */\n\t\t\t\t\t\tfor(i=0; i<config->bridge_count; i++){\n\t\t\t\t\t\t\tif(!strcmp(config->bridges[i].name, token)){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate bridge name \\\"%s\\\".\", token);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconfig->bridge_count++;\n\t\t\t\t\t\tconfig->bridges = mosquitto__realloc(config->bridges, config->bridge_count*sizeof(struct mosquitto__bridge));\n\t\t\t\t\t\tif(!config->bridges){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge = &(config->bridges[config->bridge_count-1]);\n\t\t\t\t\t\tmemset(cur_bridge, 0, sizeof(struct mosquitto__bridge));\n\t\t\t\t\t\tcur_bridge->name = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_bridge->name){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->keepalive = 60;\n\t\t\t\t\t\tcur_bridge->notifications = true;\n\t\t\t\t\t\tcur_bridge->notifications_local_only = false;\n\t\t\t\t\t\tcur_bridge->start_type = bst_automatic;\n\t\t\t\t\t\tcur_bridge->idle_timeout = 60;\n\t\t\t\t\t\tcur_bridge->restart_timeout = 30;\n\t\t\t\t\t\tcur_bridge->threshold = 10;\n\t\t\t\t\t\tcur_bridge->try_private = true;\n\t\t\t\t\t\tcur_bridge->attempt_unsubscribe = true;\n\t\t\t\t\t\tcur_bridge->protocol_version = mosq_p_mqtt311;\n\t\t\t\t\t\tcur_bridge->primary_retry_sock = INVALID_SOCKET;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty connection value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"connection_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->connection_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"crlfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"crlfile\", &cur_listener->crlfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"http_dir\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"http_dir\", &cur_listener->http_dir, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Websockets support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"idle_timeout\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"idle_timeout\", &cur_bridge->idle_timeout, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->idle_timeout < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"idle_timeout interval too low, using 1 second.\");\n\t\t\t\t\t\tcur_bridge->idle_timeout = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"include_dir\")){\n\t\t\t\t\tif(level == 0){\n\t\t\t\t\t\t/* Only process include_dir from the main config file. */\n\t\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\t\tif(!token){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty include_dir value in configuration.\");\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n#ifdef WIN32\n\t\t\t\t\t\tsnprintf(dirpath, MAX_PATH, \"%s\\\\*.conf\", token);\n\t\t\t\t\t\tfh = FindFirstFile(dirpath, &find_data);\n\t\t\t\t\t\tif(fh == INVALID_HANDLE_VALUE){\n\t\t\t\t\t\t\t/* No files found */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\tlen = strlen(token)+1+strlen(find_data.cFileName)+1;\n\t\t\t\t\t\t\tconf_file = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!conf_file){\n\t\t\t\t\t\t\t\tFindClose(fh);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(conf_file, len, \"%s\\\\%s\", token, find_data.cFileName);\n\t\t\t\t\t\t\tconf_file[len] = '\\0';\n\n\t\t\t\t\t\t\trc = config__read_file(config, reload, conf_file, cr, level+1, &lineno_ext);\n\t\t\t\t\t\t\tif(rc){\n\t\t\t\t\t\t\t\tFindClose(fh);\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", conf_file, lineno_ext);\n\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t}while(FindNextFile(fh, &find_data));\n\n\t\t\t\t\t\tFindClose(fh);\n#else\n\t\t\t\t\t\tdh = opendir(token);\n\t\t\t\t\t\tif(!dh){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open include_dir '%s'.\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((de = readdir(dh)) != NULL){\n\t\t\t\t\t\t\tif(strlen(de->d_name) > 5){\n\t\t\t\t\t\t\t\tif(!strcmp(&de->d_name[strlen(de->d_name)-5], \".conf\")){\n\t\t\t\t\t\t\t\t\tlen = strlen(token)+1+strlen(de->d_name)+1;\n\t\t\t\t\t\t\t\t\tconf_file = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\t\t\tif(!conf_file){\n\t\t\t\t\t\t\t\t\t\tclosedir(dh);\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsnprintf(conf_file, len, \"%s/%s\", token, de->d_name);\n\t\t\t\t\t\t\t\t\tconf_file[len] = '\\0';\n\n\t\t\t\t\t\t\t\t\trc = config__read_file(config, reload, conf_file, cr, level+1, &lineno_ext);\n\t\t\t\t\t\t\t\t\tif(rc){\n\t\t\t\t\t\t\t\t\t\tclosedir(dh);\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error found at %s:%d.\", conf_file, lineno_ext);\n\t\t\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmosquitto__free(conf_file);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclosedir(dh);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"keepalive_interval\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"keepalive_interval\", &cur_bridge->keepalive, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->keepalive < 5){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"keepalive interval too low, using 5 seconds.\");\n\t\t\t\t\t\tcur_bridge->keepalive = 5;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"keyfile\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"keyfile\", &cur_listener->keyfile, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"listener\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\ttmp_int = atoi(token);\n\t\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(reload){\n\t\t\t\t\t\t\t/* We reload listeners settings based on port number.\n\t\t\t\t\t\t\t * If the port number doesn't already exist, exit with a complaint. */\n\t\t\t\t\t\t\tcur_listener = NULL;\n\t\t\t\t\t\t\tfor(i=0; i<config->listener_count; i++){\n\t\t\t\t\t\t\t\tif(config->listeners[i].port == tmp_int){\n\t\t\t\t\t\t\t\t\tcur_listener = &config->listeners[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!cur_listener){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: It is not currently possible to add/remove listeners when reloading the config file.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tconfig->listener_count++;\n\t\t\t\t\t\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\t\t\t\t\t\tif(!config->listeners){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur_listener = &config->listeners[config->listener_count-1];\n\t\t\t\t\t\t\tmemset(cur_listener, 0, sizeof(struct mosquitto__listener));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcur_listener->security_options.allow_anonymous = -1;\n\t\t\t\t\t\tcur_listener->protocol = mp_mqtt;\n\t\t\t\t\t\tcur_listener->port = tmp_int;\n\t\t\t\t\t\ttoken = strtok_r(NULL, \"\", &saveptr);\n\t\t\t\t\t\tmosquitto__free(cur_listener->host);\n\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\tcur_listener->host = mosquitto__strdup(token);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_listener->host = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty listener value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"local_clientid\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local clientd\", &cur_bridge->local_clientid, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"local_password\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local_password\", &cur_bridge->local_password, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"local_username\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge local_username\", &cur_bridge->local_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"log_dest\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->log_dest_set = 1;\n\t\t\t\t\t\tif(!strcmp(token, \"none\")){\n\t\t\t\t\t\t\tcr->log_dest = MQTT3_LOG_NONE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"syslog\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_SYSLOG;\n\t\t\t\t\t\t}else if(!strcmp(token, \"stdout\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_STDOUT;\n\t\t\t\t\t\t}else if(!strcmp(token, \"stderr\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_STDERR;\n\t\t\t\t\t\t}else if(!strcmp(token, \"topic\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_TOPIC;\n\t\t\t\t\t\t}else if(!strcmp(token, \"file\")){\n\t\t\t\t\t\t\tcr->log_dest |= MQTT3_LOG_FILE;\n\t\t\t\t\t\t\tif(config->log_fptr || config->log_file){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate \\\"log_dest file\\\" value.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Get remaining string. */\n\t\t\t\t\t\t\ttoken = &token[strlen(token)+1];\n\t\t\t\t\t\t\twhile(token[0] == ' ' || token[0] == '\\t'){\n\t\t\t\t\t\t\t\ttoken++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(token[0]){\n\t\t\t\t\t\t\t\tconfig->log_file = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\tif(!config->log_file){\n\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty \\\"log_dest file\\\" value in configuration.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_dest value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n#if defined(WIN32) || defined(__CYGWIN__)\n\t\t\t\t\t\tif(service_handle){\n\t\t\t\t\t\t\tif(cr->log_dest == MQTT3_LOG_STDOUT || cr->log_dest == MQTT3_LOG_STDERR){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Cannot log to stdout/stderr when running as a Windows service.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty log_dest value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"log_facility\")){\n#if defined(WIN32) || defined(__CYGWIN__)\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: log_facility not supported on Windows.\");\n#else\n\t\t\t\t\tif(conf__parse_int(&token, \"log_facility\", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tswitch(tmp_int){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL6;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tconfig->log_facility = LOG_LOCAL7;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_facility value (%d).\", tmp_int);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}else if(!strcmp(token, \"log_timestamp\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->log_timestamp, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"log_type\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->log_type_set = 1;\n\t\t\t\t\t\tif(!strcmp(token, \"none\")){\n\t\t\t\t\t\t\tcr->log_type = MOSQ_LOG_NONE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"information\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_INFO;\n\t\t\t\t\t\t}else if(!strcmp(token, \"notice\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_NOTICE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"warning\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_WARNING;\n\t\t\t\t\t\t}else if(!strcmp(token, \"error\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_ERR;\n\t\t\t\t\t\t}else if(!strcmp(token, \"debug\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_DEBUG;\n\t\t\t\t\t\t}else if(!strcmp(token, \"subscribe\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_SUBSCRIBE;\n\t\t\t\t\t\t}else if(!strcmp(token, \"unsubscribe\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_UNSUBSCRIBE;\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\t\t}else if(!strcmp(token, \"websockets\")){\n\t\t\t\t\t\t\tcr->log_type |= MOSQ_LOG_WEBSOCKETS;\n#endif\n\t\t\t\t\t\t}else if(!strcmp(token, \"all\")){\n\t\t\t\t\t\t\tcr->log_type = INT_MAX;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid log_type value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty log_type value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_connections\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcur_listener->max_connections = atoi(token);\n\t\t\t\t\t\tif(cur_listener->max_connections < 0) cur_listener->max_connections = -1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_connections value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_inflight_bytes\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_inflight_bytes = atol(token);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_inflight_bytes value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_inflight_messages\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_inflight_messages = atoi(token);\n\t\t\t\t\t\tif(cr->max_inflight_messages < 0) cr->max_inflight_messages = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_inflight_messages value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_queued_bytes\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_queued_bytes = atol(token); /* 63 bits is ok right? */\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_queued_bytes value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"max_queued_messages\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcr->max_queued_messages = atoi(token);\n\t\t\t\t\t\tif(cr->max_queued_messages < 0) cr->max_queued_messages = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty max_queued_messages value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"memory_limit\")){\n\t\t\t\t\tssize_t lim;\n\t\t\t\t\tif(conf__parse_ssize_t(&token, \"memory_limit\", &lim, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(lim < 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid memory_limit value (%ld).\", lim);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tmemory__set_limit(lim);\n\t\t\t\t}else if(!strcmp(token, \"message_size_limit\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"message_size_limit\", (int *)&config->message_size_limit, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->message_size_limit > MQTT_MAX_PAYLOAD){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid message_size_limit value (%u).\", config->message_size_limit);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"mount_point\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(config->listener_count == 0){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: You must use create a listener before using the mount_point option in the configuration file.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"mount_point\", &cur_listener->mount_point, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(mosquitto_pub_topic_check(cur_listener->mount_point) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR,\n\t\t\t\t\t\t\t\t\"Error: Invalid mount_point '%s'. Does it contain a wildcard character?\",\n\t\t\t\t\t\t\t\tcur_listener->mount_point);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"notifications\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"notifications\", &cur_bridge->notifications, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"notifications_local_only\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"notifications_local_only\", &cur_bridge->notifications_local_only, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"notification_topic\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"notification_topic\", &cur_bridge->notification_topic, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"password\") || !strcmp(token, \"remote_password\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"bridge remote_password\", &cur_bridge->remote_password, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"password_file\")){\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->password_file);\n\t\t\t\t\t\tcur_security_options->password_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"password_file\", &cur_security_options->password_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"per_listener_settings\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"per_listener_settings\", &config->per_listener_settings, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_security_options && config->per_listener_settings){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: per_listener_settings must be set before any other security settings.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"persistence\") || !strcmp(token, \"retained_persistence\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->persistence, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistence_file\")){\n\t\t\t\t\tif(conf__parse_string(&token, \"persistence_file\", &config->persistence_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistence_location\")){\n\t\t\t\t\tif(conf__parse_string(&token, \"persistence_location\", &config->persistence_location, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"persistent_client_expiration\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tswitch(token[strlen(token)-1]){\n\t\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\t\texpiration_mult = 3600;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\texpiration_mult = 86400;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'w':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*7;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*30;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'y':\n\t\t\t\t\t\t\t\texpiration_mult = 86400*365;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid persistent_client_expiration duration in configuration.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken[strlen(token)-1] = '\\0';\n\t\t\t\t\t\tconfig->persistent_client_expiration = atoi(token)*expiration_mult;\n\t\t\t\t\t\tif(config->persistent_client_expiration <= 0){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid persistent_client_expiration duration in configuration.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty persistent_client_expiration value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"pid_file\")){\n\t\t\t\t\tif(reload) continue; // pid file not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"pid_file\", &config->pid_file, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"port\")){\n\t\t\t\t\tif(reload) continue; // Listener not valid for reloading.\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"port\", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(tmp_int < 1 || tmp_int > 65535){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port value (%d).\", tmp_int);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = tmp_int;\n\t\t\t\t}else if(!strcmp(token, \"protocol\")){\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"mqtt\")){\n\t\t\t\t\t\t\tcur_listener->protocol = mp_mqtt;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t}else if(!strcmp(token, \"mqttsn\")){\n\t\t\t\t\t\t\tcur_listener->protocol = mp_mqttsn;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t}else if(!strcmp(token, \"websockets\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\t\t\tcur_listener->protocol = mp_websockets;\n\t\t\t\t\t\t\tconfig->have_websockets_listener = true;\n#else\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Websockets support not available.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n#endif\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid protocol value (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty protocol value in configuration.\");\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"psk_file\")){\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tconf__set_cur_security_options(config, cur_listener, &cur_security_options);\n\t\t\t\t\tif(reload){\n\t\t\t\t\t\tmosquitto__free(cur_security_options->psk_file);\n\t\t\t\t\t\tcur_security_options->psk_file = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_string(&token, \"psk_file\", &cur_security_options->psk_file, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS/TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"psk_hint\")){\n#ifdef WITH_TLS_PSK\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"psk_hint\", &cur_listener->psk_hint, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS/TLS-PSK support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"queue_qos0_messages\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->queue_qos0_messages, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"require_certificate\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"require_certificate\", &cur_listener->require_certificate, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"restart_timeout\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"restart_timeout\", &cur_bridge->restart_timeout, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->restart_timeout < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"restart_timeout interval too low, using 1 second.\");\n\t\t\t\t\t\tcur_bridge->restart_timeout = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"retry_interval\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: The retry_interval option is no longer available.\");\n\t\t\t\t}else if(!strcmp(token, \"round_robin\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"round_robin\", &cur_bridge->round_robin, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"set_tcp_nodelay\")){\n\t\t\t\t\tif(conf__parse_bool(&token, \"set_tcp_nodelay\", &config->set_tcp_nodelay, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"start_type\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"automatic\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_automatic;\n\t\t\t\t\t\t}else if(!strcmp(token, \"lazy\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_lazy;\n\t\t\t\t\t\t}else if(!strcmp(token, \"manual\")){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Manual start_type not supported.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}else if(!strcmp(token, \"once\")){\n\t\t\t\t\t\t\tcur_bridge->start_type = bst_once;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid start_type value in configuration (%s).\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty start_type value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"socket_domain\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcmp(token, \"ipv4\")){\n\t\t\t\t\t\t\tcur_listener->socket_domain = AF_INET;\n\t\t\t\t\t\t}else if(!strcmp(token, \"ipv6\")){\n\t\t\t\t\t\t\tcur_listener->socket_domain = AF_INET6;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid socket_domain value \\\"%s\\\" in configuration.\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty socket_domain value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"store_clean_interval\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: store_clean_interval is no longer needed.\");\n\t\t\t\t}else if(!strcmp(token, \"sys_interval\")){\n\t\t\t\t\tif(conf__parse_int(&token, \"sys_interval\", &config->sys_interval, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(config->sys_interval < 0 || config->sys_interval > 65535){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid sys_interval value (%d).\", config->sys_interval);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t}else if(!strcmp(token, \"threshold\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_int(&token, \"threshold\", &cur_bridge->threshold, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t\tif(cur_bridge->threshold < 1){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"threshold too low, using 1 message.\");\n\t\t\t\t\t\tcur_bridge->threshold = 1;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"tls_version\")){\n#if defined(WITH_TLS)\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"tls_version\", &cur_listener->tls_version, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"topic\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tcur_bridge->topic_count++;\n\t\t\t\t\t\tcur_bridge->topics = mosquitto__realloc(cur_bridge->topics,\n\t\t\t\t\t\t\t\tsizeof(struct mosquitto__bridge_topic)*cur_bridge->topic_count);\n\t\t\t\t\t\tif(!cur_bridge->topics){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_topic = &cur_bridge->topics[cur_bridge->topic_count-1];\n\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\tcur_topic->topic = NULL;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->topic = mosquitto__strdup(token);\n\t\t\t\t\t\t\tif(!cur_topic->topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_topic->direction = bd_out;\n\t\t\t\t\t\tcur_topic->qos = 0;\n\t\t\t\t\t\tcur_topic->local_prefix = NULL;\n\t\t\t\t\t\tcur_topic->remote_prefix = NULL;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty topic value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(!strcasecmp(token, \"out\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_out;\n\t\t\t\t\t\t}else if(!strcasecmp(token, \"in\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_in;\n\t\t\t\t\t\t}else if(!strcasecmp(token, \"both\")){\n\t\t\t\t\t\t\tcur_topic->direction = bd_both;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic direction '%s'.\", token);\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\tcur_topic->qos = atoi(token);\n\t\t\t\t\t\t\tif(cur_topic->qos < 0 || cur_topic->qos > 2){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge QoS level '%s'.\", token);\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\t\tcur_bridge->topic_remapping = true;\n\t\t\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\t\t\tcur_topic->local_prefix = NULL;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tif(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic local prefix '%s'.\", token);\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcur_topic->local_prefix = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\t\tif(!cur_topic->local_prefix){\n\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\t\t\t\tif(token){\n\t\t\t\t\t\t\t\t\tif(!strcmp(token, \"\\\"\\\"\")){\n\t\t\t\t\t\t\t\t\t\tcur_topic->remote_prefix = NULL;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tif(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){\n\t\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge topic remote prefix '%s'.\", token);\n\t\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcur_topic->remote_prefix = mosquitto__strdup(token);\n\t\t\t\t\t\t\t\t\t\tif(!cur_topic->remote_prefix){\n\t\t\t\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->topic == NULL &&\n\t\t\t\t\t\t\t(cur_topic->local_prefix == NULL || cur_topic->remote_prefix == NULL)){\n\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge remapping.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tif(cur_topic->topic){\n\t\t\t\t\t\t\tlen = strlen(cur_topic->topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\t\tcur_topic->local_topic = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(cur_topic->local_topic, len+1, \"%s%s\", cur_topic->local_prefix, cur_topic->topic);\n\t\t\t\t\t\t\tcur_topic->local_topic[len] = '\\0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->local_topic = mosquitto__strdup(cur_topic->local_prefix);\n\t\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_topic->local_topic = mosquitto__strdup(cur_topic->topic);\n\t\t\t\t\t\tif(!cur_topic->local_topic){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(cur_topic->topic){\n\t\t\t\t\t\t\tlen = strlen(cur_topic->topic) + strlen(cur_topic->remote_prefix)+1;\n\t\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__malloc(len+1);\n\t\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(cur_topic->remote_topic, len, \"%s%s\", cur_topic->remote_prefix, cur_topic->topic);\n\t\t\t\t\t\t\tcur_topic->remote_topic[len] = '\\0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__strdup(cur_topic->remote_prefix);\n\t\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur_topic->remote_topic = mosquitto__strdup(cur_topic->topic);\n\t\t\t\t\t\tif(!cur_topic->remote_topic){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"try_private\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tif(conf__parse_bool(&token, \"try_private\", &cur_bridge->try_private, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"upgrade_outgoing_qos\")){\n\t\t\t\t\tif(conf__parse_bool(&token, token, &config->upgrade_outgoing_qos, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"use_identity_as_username\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_identity_as_username\", &cur_listener->use_identity_as_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"use_subject_as_username\")){\n#ifdef WITH_TLS\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_subject_as_username\", &cur_listener->use_subject_as_username, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: TLS support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"user\")){\n\t\t\t\t\tif(reload) continue; // Drop privileges user not valid for reloading.\n\t\t\t\t\tif(conf__parse_string(&token, \"user\", &config->user, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"use_username_as_clientid\")){\n\t\t\t\t\tif(reload) continue; // Listeners not valid for reloading.\n\t\t\t\t\tif(conf__parse_bool(&token, \"use_username_as_clientid\", &cur_listener->use_username_as_clientid, saveptr)) return MOSQ_ERR_INVAL;\n\t\t\t\t}else if(!strcmp(token, \"username\") || !strcmp(token, \"remote_username\")){\n#ifdef WITH_BRIDGE\n\t\t\t\t\tif(reload) continue; // FIXME\n\t\t\t\t\tif(!cur_bridge){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid bridge configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = strtok_r(NULL, \" \", &saveptr);\n\t\t\t\t\tif(token){\n\t\t\t\t\t\tif(cur_bridge->remote_username){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate username value in bridge configuration.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_bridge->remote_username = mosquitto__strdup(token);\n\t\t\t\t\t\tif(!cur_bridge->remote_username){\n\t\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty username value in configuration.\");\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Bridge support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"websockets_log_level\")){\n#ifdef WITH_WEBSOCKETS\n\t\t\t\t\tif(conf__parse_int(&token, \"websockets_log_level\", &config->websockets_log_level, saveptr)) return MOSQ_ERR_INVAL;\n#else\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Websockets support not available.\");\n#endif\n\t\t\t\t}else if(!strcmp(token, \"trace_level\")\n\t\t\t\t\t\t|| !strcmp(token, \"ffdc_output\")\n\t\t\t\t\t\t|| !strcmp(token, \"max_log_entries\")\n\t\t\t\t\t\t|| !strcmp(token, \"trace_output\")){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Unsupported rsmb configuration option \\\"%s\\\".\", token);\n\t\t\t\t}else{\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unknown configuration variable \\\"%s\\\".\", token);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nint config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file %s\\n\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc(buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__free(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}\n\n\nstatic int config__check(struct mosquitto__config *config)\n{\n\t/* Checks that are easy to make after the config has been loaded. */\n\n#ifdef WITH_BRIDGE\n\tint i, j;\n\tstruct mosquitto__bridge *bridge1, *bridge2;\n\tchar hostname[256];\n\tint len;\n\n\t/* Check for bridge duplicate local_clientid, need to generate missing IDs\n\t * first. */\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tbridge1 = &config->bridges[i];\n\n\t\tif(!bridge1->remote_clientid){\n\t\t\tif(!gethostname(hostname, 256)){\n\t\t\t\tlen = strlen(hostname) + strlen(bridge1->name) + 2;\n\t\t\t\tbridge1->remote_clientid = mosquitto__malloc(len);\n\t\t\t\tif(!bridge1->remote_clientid){\n\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t}\n\t\t\t\tsnprintf(bridge1->remote_clientid, len, \"%s.%s\", hostname, bridge1->name);\n\t\t\t}else{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif(!bridge1->local_clientid){\n\t\t\tlen = strlen(bridge1->remote_clientid) + strlen(\"local.\") + 2;\n\t\t\tbridge1->local_clientid = mosquitto__malloc(len);\n\t\t\tif(!bridge1->local_clientid){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t\tsnprintf(bridge1->local_clientid, len, \"local.%s\", bridge1->remote_clientid);\n\t\t}\n\t}\n\n\tfor(i=0; i<config->bridge_count; i++){\n\t\tbridge1 = &config->bridges[i];\n\t\tfor(j=i+1; j<config->bridge_count; j++){\n\t\t\tbridge2 = &config->bridges[j];\n\t\t\tif(!strcmp(bridge1->local_clientid, bridge2->local_clientid)){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Bridge local_clientid \"\n\t\t\t\t\t\t\"'%s' is not unique. Try changing or setting the \"\n\t\t\t\t\t\t\"local_clientid value for one of the bridges.\",\n\t\t\t\t\t\tbridge1->local_clientid);\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nstatic int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\tif(!strcmp(*token, \"false\") || !strcmp(*token, \"0\")){\n\t\t\t*value = false;\n\t\t}else if(!strcmp(*token, \"true\") || !strcmp(*token, \"1\")){\n\t\t\t*value = true;\n\t\t}else{\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid %s value (%s).\", name, *token);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_int(char **token, const char *name, int *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\t*value = atoi(*token);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \" \", &saveptr);\n\tif(*token){\n\t\t*value = atol(*token);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nstatic int conf__parse_string(char **token, const char *name, char **value, char *saveptr)\n{\n\t*token = strtok_r(NULL, \"\", &saveptr);\n\tif(*token){\n\t\tif(*value){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Duplicate %s value in configuration.\", name);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\t/* Deal with multiple spaces at the beginning of the string. */\n\t\twhile((*token)[0] == ' ' || (*token)[0] == '\\t'){\n\t\t\t(*token)++;\n\t\t}\n\t\tif(mosquitto_validate_utf8(*token, strlen(*token))){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Malformed UTF-8 in configuration.\");\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t\t*value = mosquitto__strdup(*token);\n\t\tif(!*value){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Empty %s value in configuration.\", name);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}\n"], "filenames": ["ChangeLog.txt", "src/conf.c"], "buggy_code_start_loc": [2, 499], "buggy_code_end_loc": [2, 499], "fixing_code_start_loc": [3, 500], "fixing_code_end_loc": [8, 501], "type": "CWE-732", "message": "Eclipse Mosquitto 1.5.x before 1.5.5 allows ACL bypass: if the option per_listener_settings was set to true, and the default listener was in use, and the default listener specified an acl_file, then the acl file was being ignored.", "other": {"cve": {"id": "CVE-2018-20145", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-13T20:29:00.240", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Eclipse Mosquitto 1.5.x before 1.5.5 allows ACL bypass: if the option per_listener_settings was set to true, and the default listener was in use, and the default listener specified an acl_file, then the acl file was being ignored."}, {"lang": "es", "value": "Eclipse Mosquitto en versiones 1.5.x anteriores a la 1.5.5 permite la omisi\u00f3n de las listas de control de acceso: si la opci\u00f3n per_listener_settings est\u00e1 establecida como True, el escuchador por defecto se est\u00e1 empleando y el escuchador por defecto especifica un acl_file, el archivo acl se ignora."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.5", "versionEndExcluding": "1.5.5", "matchCriteriaId": "EF470C82-ACC6-4DFF-BA16-6011B70FD1E4"}]}]}], "references": [{"url": "https://github.com/eclipse/mosquitto/blob/master/ChangeLog.txt", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse/mosquitto/issues/1073", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4"}}