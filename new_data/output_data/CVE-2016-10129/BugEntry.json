{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n", "/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n#include \"git2.h\"\n#include \"git2/odb_backend.h\"\n\n#include \"smart.h\"\n#include \"refs.h\"\n#include \"repository.h\"\n#include \"push.h\"\n#include \"pack-objects.h\"\n#include \"remote.h\"\n#include \"util.h\"\n\n#define NETWORK_XFER_THRESHOLD (100*1024)\n/* The minimal interval between progress updates (in seconds). */\n#define MIN_PROGRESS_UPDATE_INTERVAL 0.5\n\nint git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}\n\nstatic int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}\n\nint git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\treturn GIT_EEOF;\n\t\t}\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}\n\nstatic int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}\n\nstatic int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}\n\nint git_smart__negotiate_fetch(git_transport *transport, git_repository *repo, const git_remote_head * const *wants, size_t count)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_buf data = GIT_BUF_INIT;\n\tgit_revwalk *walk = NULL;\n\tint error = -1, pkt_type;\n\tunsigned int i;\n\tgit_oid oid;\n\n\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\treturn error;\n\n\tif ((error = fetch_setup_walk(&walk, repo)) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Our support for ACK extensions is simply to parse them. On\n\t * the first ACK we will accept that as enough common\n\t * objects. We give up if we haven't found an answer in the\n\t * first 256 we send.\n\t */\n\ti = 0;\n\twhile (i < 256) {\n\t\terror = git_revwalk_next(&oid, walk);\n\n\t\tif (error < 0) {\n\t\t\tif (GIT_ITEROVER == error)\n\t\t\t\tbreak;\n\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_pkt_buffer_have(&oid, &data);\n\t\ti++;\n\t\tif (i % 20 == 0) {\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\t\terror = GIT_EUSER;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tgit_pkt_buffer_flush(&data);\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_buf_clear(&data);\n\t\t\tif (t->caps.multi_ack || t->caps.multi_ack_detailed) {\n\t\t\t\tif ((error = store_common(t)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\t\t\tif (pkt_type == GIT_PKT_ACK) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pkt_type == GIT_PKT_NAK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pkt_type < 0) {\n\t\t\t\t\t/* recv_pkt returned an error */\n\t\t\t\t\terror = pkt_type;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t} else {\n\t\t\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->common.length > 0)\n\t\t\tbreak;\n\n\t\tif (i % 20 == 0 && t->rpc) {\n\t\t\tgit_pkt_ack *pkt;\n\t\t\tunsigned int j;\n\n\t\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_vector_foreach(&t->common, j, pkt) {\n\t\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Tell the other end that we're done negotiating */\n\tif (t->rpc && t->common.length > 0) {\n\t\tgit_pkt_ack *pkt;\n\t\tunsigned int j;\n\n\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_foreach(&t->common, j, pkt) {\n\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (git_buf_oom(&data)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif ((error = git_pkt_buffer_done(&data)) < 0)\n\t\tgoto on_error;\n\n\tif (t->cancelled.val) {\n\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\terror = GIT_EUSER;\n\t\tgoto on_error;\n\t}\n\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&data);\n\tgit_revwalk_free(walk);\n\n\t/* Now let's eat up whatever the server gives us */\n\tif (!t->caps.multi_ack && !t->caps.multi_ack_detailed) {\n\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\tif (pkt_type < 0) {\n\t\t\treturn pkt_type;\n\t\t} else if (pkt_type != GIT_PKT_ACK && pkt_type != GIT_PKT_NAK) {\n\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\terror = wait_while_ack(buf);\n\t}\n\n\treturn error;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_buf_free(&data);\n\treturn error;\n}\n\nstatic int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct network_packetsize_payload\n{\n\tgit_transfer_progress_cb callback;\n\tvoid *payload;\n\tgit_transfer_progress *stats;\n\tsize_t last_fired_bytes;\n};\n\nstatic int network_packetsize(size_t received, void *payload)\n{\n\tstruct network_packetsize_payload *npp = (struct network_packetsize_payload*)payload;\n\n\t/* Accumulate bytes */\n\tnpp->stats->received_bytes += received;\n\n\t/* Fire notification if the threshold is reached */\n\tif ((npp->stats->received_bytes - npp->last_fired_bytes) > NETWORK_XFER_THRESHOLD) {\n\t\tnpp->last_fired_bytes = npp->stats->received_bytes;\n\n\t\tif (npp->callback(npp->stats, npp->payload))\n\t\t\treturn GIT_EUSER;\n\t}\n\n\treturn 0;\n}\n\nint git_smart__download_pack(\n\tgit_transport *transport,\n\tgit_repository *repo,\n\tgit_transfer_progress *stats,\n\tgit_transfer_progress_cb transfer_progress_cb,\n\tvoid *progress_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_odb *odb;\n\tstruct git_odb_writepack *writepack = NULL;\n\tint error = 0;\n\tstruct network_packetsize_payload npp = {0};\n\n\tmemset(stats, 0, sizeof(git_transfer_progress));\n\n\tif (transfer_progress_cb) {\n\t\tnpp.callback = transfer_progress_cb;\n\t\tnpp.payload = progress_payload;\n\t\tnpp.stats = stats;\n\t\tt->packetsize_cb = &network_packetsize;\n\t\tt->packetsize_payload = &npp;\n\n\t\t/* We might have something in the buffer already from negotiate_fetch */\n\t\tif (t->buffer.offset > 0 && !t->cancelled.val)\n\t\t\tif (t->packetsize_cb(t->buffer.offset, t->packetsize_payload))\n\t\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t}\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t((error = git_odb_write_pack(&writepack, odb, transfer_progress_cb, progress_payload)) != 0))\n\t\tgoto done;\n\n\t/*\n\t * If the remote doesn't support the side-band, we can feed\n\t * the data directly to the pack writer. Otherwise, we need to\n\t * check which one belongs there.\n\t */\n\tif (!t->caps.side_band && !t->caps.side_band_64k) {\n\t\terror = no_sideband(t, writepack, buf, stats);\n\t\tgoto done;\n\t}\n\n\tdo {\n\t\tgit_pkt *pkt = NULL;\n\n\t\t/* Check cancellation before network call */\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_clear();\n\t\t\terror = GIT_EUSER;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = recv_pkt(&pkt, buf)) >= 0) {\n\t\t\t/* Check cancellation after network call */\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = GIT_EUSER;\n\t\t\t} else if (pkt->type == GIT_PKT_PROGRESS) {\n\t\t\t\tif (t->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = t->progress_cb(p->data, p->len, t->message_cb_payload);\n\t\t\t\t}\n\t\t\t} else if (pkt->type == GIT_PKT_DATA) {\n\t\t\t\tgit_pkt_data *p = (git_pkt_data *) pkt;\n\n\t\t\t\tif (p->len)\n\t\t\t\t\terror = writepack->append(writepack, p->data, p->len, stats);\n\t\t\t} else if (pkt->type == GIT_PKT_FLUSH) {\n\t\t\t\t/* A flush indicates the end of the packfile */\n\t\t\t\tgit__free(pkt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgit__free(pkt);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t} while (1);\n\n\t/*\n\t * Trailing execution of transfer_progress_cb, if necessary...\n\t * Only the callback through the npp datastructure currently\n\t * updates the last_fired_bytes value. It is possible that\n\t * progress has already been reported with the correct\n\t * \"received_bytes\" value, but until (if?) this is unified\n\t * then we will report progress again to be sure that the\n\t * correct last received_bytes value is reported.\n\t */\n\tif (npp.callback && npp.stats->received_bytes > npp.last_fired_bytes) {\n\t\terror = npp.callback(npp.stats, npp.payload);\n\t\tif (error != 0)\n\t\t\tgoto done;\n\t}\n\n\terror = writepack->commit(writepack, stats);\n\ndone:\n\tif (writepack)\n\t\twritepack->free(writepack);\n\tif (transfer_progress_cb) {\n\t\tt->packetsize_cb = NULL;\n\t\tt->packetsize_payload = NULL;\n\t}\n\n\treturn error;\n}\n\nstatic int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}\n\nstatic int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}\n\nstatic int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}\n\nstatic int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}\n\nstruct push_packbuilder_payload\n{\n\tgit_smart_subtransport_stream *stream;\n\tgit_packbuilder *pb;\n\tgit_push_transfer_progress cb;\n\tvoid *cb_payload;\n\tsize_t last_bytes;\n\tdouble last_progress_report_time;\n};\n\nstatic int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nint git_smart__push(git_transport *transport, git_push *push, const git_remote_callbacks *cbs)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tstruct push_packbuilder_payload packbuilder_payload = {0};\n\tgit_buf pktline = GIT_BUF_INIT;\n\tint error = 0, need_pack = 0;\n\tpush_spec *spec;\n\tunsigned int i;\n\n\tpackbuilder_payload.pb = push->pb;\n\n\tif (cbs && cbs->push_transfer_progress) {\n\t\tpackbuilder_payload.cb = cbs->push_transfer_progress;\n\t\tpackbuilder_payload.cb_payload = cbs->payload;\n\t}\n\n#ifdef PUSH_DEBUG\n{\n\tgit_remote_head *head;\n\tchar hex[GIT_OID_HEXSZ+1]; hex[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tgit_oid_fmt(hex, &head->oid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, head->name);\n\t}\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_oid_fmt(hex, &spec->roid);\n\t\tfprintf(stderr, \"%s (%s) -> \", hex, spec->lref);\n\t\tgit_oid_fmt(hex, &spec->loid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, spec->rref ?\n\t\t\tspec->rref : spec->lref);\n\t}\n}\n#endif\n\n\t/*\n\t * Figure out if we need to send a packfile; which is in all\n\t * cases except when we only send delete commands\n\t */\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0] != '\\0') {\n\t\t\tneed_pack = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((error = git_smart__get_push_stream(t, &packbuilder_payload.stream)) < 0 ||\n\t\t(error = gen_pktline(&pktline, push)) < 0 ||\n\t\t(error = packbuilder_payload.stream->write(packbuilder_payload.stream, git_buf_cstr(&pktline), git_buf_len(&pktline))) < 0)\n\t\tgoto done;\n\n\tif (need_pack &&\n\t\t(error = git_packbuilder_foreach(push->pb, &stream_thunk, &packbuilder_payload)) < 0)\n\t\tgoto done;\n\n\t/* If we sent nothing or the server doesn't support report-status, then\n\t * we consider the pack to have been unpacked successfully */\n\tif (!push->specs.length || !push->report_status)\n\t\tpush->unpack_ok = 1;\n\telse if ((error = parse_report(t, push)) < 0)\n\t\tgoto done;\n\n\t/* If progress is being reported write the final report */\n\tif (cbs && cbs->push_transfer_progress) {\n\t\terror = cbs->push_transfer_progress(\n\t\t\t\t\tpush->pb->nr_written,\n\t\t\t\t\tpush->pb->nr_objects,\n\t\t\t\t\tpackbuilder_payload.last_bytes,\n\t\t\t\t\tcbs->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (push->status.length) {\n\t\terror = update_refs_from_report(&t->refs, &push->specs, &push->status);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\terror = git_smart__update_heads(t, NULL);\n\t}\n\ndone:\n\tgit_buf_free(&pktline);\n\treturn error;\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n", "/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n#include \"git2.h\"\n#include \"git2/odb_backend.h\"\n\n#include \"smart.h\"\n#include \"refs.h\"\n#include \"repository.h\"\n#include \"push.h\"\n#include \"pack-objects.h\"\n#include \"remote.h\"\n#include \"util.h\"\n\n#define NETWORK_XFER_THRESHOLD (100*1024)\n/* The minimal interval between progress updates (in seconds). */\n#define MIN_PROGRESS_UPDATE_INTERVAL 0.5\n\nint git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}\n\nstatic int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}\n\nint git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\treturn GIT_EEOF;\n\t\t}\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}\n\nstatic int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}\n\nstatic int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}\n\nint git_smart__negotiate_fetch(git_transport *transport, git_repository *repo, const git_remote_head * const *wants, size_t count)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_buf data = GIT_BUF_INIT;\n\tgit_revwalk *walk = NULL;\n\tint error = -1, pkt_type;\n\tunsigned int i;\n\tgit_oid oid;\n\n\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\treturn error;\n\n\tif ((error = fetch_setup_walk(&walk, repo)) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Our support for ACK extensions is simply to parse them. On\n\t * the first ACK we will accept that as enough common\n\t * objects. We give up if we haven't found an answer in the\n\t * first 256 we send.\n\t */\n\ti = 0;\n\twhile (i < 256) {\n\t\terror = git_revwalk_next(&oid, walk);\n\n\t\tif (error < 0) {\n\t\t\tif (GIT_ITEROVER == error)\n\t\t\t\tbreak;\n\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_pkt_buffer_have(&oid, &data);\n\t\ti++;\n\t\tif (i % 20 == 0) {\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\t\terror = GIT_EUSER;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tgit_pkt_buffer_flush(&data);\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_buf_clear(&data);\n\t\t\tif (t->caps.multi_ack || t->caps.multi_ack_detailed) {\n\t\t\t\tif ((error = store_common(t)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\t\t\tif (pkt_type == GIT_PKT_ACK) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pkt_type == GIT_PKT_NAK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pkt_type < 0) {\n\t\t\t\t\t/* recv_pkt returned an error */\n\t\t\t\t\terror = pkt_type;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t} else {\n\t\t\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->common.length > 0)\n\t\t\tbreak;\n\n\t\tif (i % 20 == 0 && t->rpc) {\n\t\t\tgit_pkt_ack *pkt;\n\t\t\tunsigned int j;\n\n\t\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_vector_foreach(&t->common, j, pkt) {\n\t\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Tell the other end that we're done negotiating */\n\tif (t->rpc && t->common.length > 0) {\n\t\tgit_pkt_ack *pkt;\n\t\tunsigned int j;\n\n\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_foreach(&t->common, j, pkt) {\n\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (git_buf_oom(&data)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif ((error = git_pkt_buffer_done(&data)) < 0)\n\t\tgoto on_error;\n\n\tif (t->cancelled.val) {\n\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\terror = GIT_EUSER;\n\t\tgoto on_error;\n\t}\n\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&data);\n\tgit_revwalk_free(walk);\n\n\t/* Now let's eat up whatever the server gives us */\n\tif (!t->caps.multi_ack && !t->caps.multi_ack_detailed) {\n\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\tif (pkt_type < 0) {\n\t\t\treturn pkt_type;\n\t\t} else if (pkt_type != GIT_PKT_ACK && pkt_type != GIT_PKT_NAK) {\n\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\terror = wait_while_ack(buf);\n\t}\n\n\treturn error;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_buf_free(&data);\n\treturn error;\n}\n\nstatic int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct network_packetsize_payload\n{\n\tgit_transfer_progress_cb callback;\n\tvoid *payload;\n\tgit_transfer_progress *stats;\n\tsize_t last_fired_bytes;\n};\n\nstatic int network_packetsize(size_t received, void *payload)\n{\n\tstruct network_packetsize_payload *npp = (struct network_packetsize_payload*)payload;\n\n\t/* Accumulate bytes */\n\tnpp->stats->received_bytes += received;\n\n\t/* Fire notification if the threshold is reached */\n\tif ((npp->stats->received_bytes - npp->last_fired_bytes) > NETWORK_XFER_THRESHOLD) {\n\t\tnpp->last_fired_bytes = npp->stats->received_bytes;\n\n\t\tif (npp->callback(npp->stats, npp->payload))\n\t\t\treturn GIT_EUSER;\n\t}\n\n\treturn 0;\n}\n\nint git_smart__download_pack(\n\tgit_transport *transport,\n\tgit_repository *repo,\n\tgit_transfer_progress *stats,\n\tgit_transfer_progress_cb transfer_progress_cb,\n\tvoid *progress_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_odb *odb;\n\tstruct git_odb_writepack *writepack = NULL;\n\tint error = 0;\n\tstruct network_packetsize_payload npp = {0};\n\n\tmemset(stats, 0, sizeof(git_transfer_progress));\n\n\tif (transfer_progress_cb) {\n\t\tnpp.callback = transfer_progress_cb;\n\t\tnpp.payload = progress_payload;\n\t\tnpp.stats = stats;\n\t\tt->packetsize_cb = &network_packetsize;\n\t\tt->packetsize_payload = &npp;\n\n\t\t/* We might have something in the buffer already from negotiate_fetch */\n\t\tif (t->buffer.offset > 0 && !t->cancelled.val)\n\t\t\tif (t->packetsize_cb(t->buffer.offset, t->packetsize_payload))\n\t\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t}\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t((error = git_odb_write_pack(&writepack, odb, transfer_progress_cb, progress_payload)) != 0))\n\t\tgoto done;\n\n\t/*\n\t * If the remote doesn't support the side-band, we can feed\n\t * the data directly to the pack writer. Otherwise, we need to\n\t * check which one belongs there.\n\t */\n\tif (!t->caps.side_band && !t->caps.side_band_64k) {\n\t\terror = no_sideband(t, writepack, buf, stats);\n\t\tgoto done;\n\t}\n\n\tdo {\n\t\tgit_pkt *pkt = NULL;\n\n\t\t/* Check cancellation before network call */\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_clear();\n\t\t\terror = GIT_EUSER;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = recv_pkt(&pkt, buf)) >= 0) {\n\t\t\t/* Check cancellation after network call */\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = GIT_EUSER;\n\t\t\t} else if (pkt->type == GIT_PKT_PROGRESS) {\n\t\t\t\tif (t->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = t->progress_cb(p->data, p->len, t->message_cb_payload);\n\t\t\t\t}\n\t\t\t} else if (pkt->type == GIT_PKT_DATA) {\n\t\t\t\tgit_pkt_data *p = (git_pkt_data *) pkt;\n\n\t\t\t\tif (p->len)\n\t\t\t\t\terror = writepack->append(writepack, p->data, p->len, stats);\n\t\t\t} else if (pkt->type == GIT_PKT_FLUSH) {\n\t\t\t\t/* A flush indicates the end of the packfile */\n\t\t\t\tgit__free(pkt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgit__free(pkt);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t} while (1);\n\n\t/*\n\t * Trailing execution of transfer_progress_cb, if necessary...\n\t * Only the callback through the npp datastructure currently\n\t * updates the last_fired_bytes value. It is possible that\n\t * progress has already been reported with the correct\n\t * \"received_bytes\" value, but until (if?) this is unified\n\t * then we will report progress again to be sure that the\n\t * correct last received_bytes value is reported.\n\t */\n\tif (npp.callback && npp.stats->received_bytes > npp.last_fired_bytes) {\n\t\terror = npp.callback(npp.stats, npp.payload);\n\t\tif (error != 0)\n\t\t\tgoto done;\n\t}\n\n\terror = writepack->commit(writepack, stats);\n\ndone:\n\tif (writepack)\n\t\twritepack->free(writepack);\n\tif (transfer_progress_cb) {\n\t\tt->packetsize_cb = NULL;\n\t\tt->packetsize_payload = NULL;\n\t}\n\n\treturn error;\n}\n\nstatic int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}\n\nstatic int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}\n\nstatic int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}\n\nstatic int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}\n\nstruct push_packbuilder_payload\n{\n\tgit_smart_subtransport_stream *stream;\n\tgit_packbuilder *pb;\n\tgit_push_transfer_progress cb;\n\tvoid *cb_payload;\n\tsize_t last_bytes;\n\tdouble last_progress_report_time;\n};\n\nstatic int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nint git_smart__push(git_transport *transport, git_push *push, const git_remote_callbacks *cbs)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tstruct push_packbuilder_payload packbuilder_payload = {0};\n\tgit_buf pktline = GIT_BUF_INIT;\n\tint error = 0, need_pack = 0;\n\tpush_spec *spec;\n\tunsigned int i;\n\n\tpackbuilder_payload.pb = push->pb;\n\n\tif (cbs && cbs->push_transfer_progress) {\n\t\tpackbuilder_payload.cb = cbs->push_transfer_progress;\n\t\tpackbuilder_payload.cb_payload = cbs->payload;\n\t}\n\n#ifdef PUSH_DEBUG\n{\n\tgit_remote_head *head;\n\tchar hex[GIT_OID_HEXSZ+1]; hex[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tgit_oid_fmt(hex, &head->oid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, head->name);\n\t}\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_oid_fmt(hex, &spec->roid);\n\t\tfprintf(stderr, \"%s (%s) -> \", hex, spec->lref);\n\t\tgit_oid_fmt(hex, &spec->loid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, spec->rref ?\n\t\t\tspec->rref : spec->lref);\n\t}\n}\n#endif\n\n\t/*\n\t * Figure out if we need to send a packfile; which is in all\n\t * cases except when we only send delete commands\n\t */\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0] != '\\0') {\n\t\t\tneed_pack = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((error = git_smart__get_push_stream(t, &packbuilder_payload.stream)) < 0 ||\n\t\t(error = gen_pktline(&pktline, push)) < 0 ||\n\t\t(error = packbuilder_payload.stream->write(packbuilder_payload.stream, git_buf_cstr(&pktline), git_buf_len(&pktline))) < 0)\n\t\tgoto done;\n\n\tif (need_pack &&\n\t\t(error = git_packbuilder_foreach(push->pb, &stream_thunk, &packbuilder_payload)) < 0)\n\t\tgoto done;\n\n\t/* If we sent nothing or the server doesn't support report-status, then\n\t * we consider the pack to have been unpacked successfully */\n\tif (!push->specs.length || !push->report_status)\n\t\tpush->unpack_ok = 1;\n\telse if ((error = parse_report(t, push)) < 0)\n\t\tgoto done;\n\n\t/* If progress is being reported write the final report */\n\tif (cbs && cbs->push_transfer_progress) {\n\t\terror = cbs->push_transfer_progress(\n\t\t\t\t\tpush->pb->nr_written,\n\t\t\t\t\tpush->pb->nr_objects,\n\t\t\t\t\tpackbuilder_payload.last_bytes,\n\t\t\t\t\tcbs->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (push->status.length) {\n\t\terror = update_refs_from_report(&t->refs, &push->specs, &push->status);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\terror = git_smart__update_heads(t, NULL);\n\t}\n\ndone:\n\tgit_buf_free(&pktline);\n\treturn error;\n}\n"], "filenames": ["src/transports/smart_pkt.c", "src/transports/smart_protocol.c"], "buggy_code_start_loc": [440, 766], "buggy_code_end_loc": [447, 830], "fixing_code_start_loc": [440, 765], "fixing_code_end_loc": [447, 818], "type": "CWE-476", "message": "The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.", "other": {"cve": {"id": "CVE-2016-10129", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:00.230", "lastModified": "2017-03-28T01:59:00.490", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line."}, {"lang": "es", "value": "El soporte Git Smart Protocol en libgit2 en versiones anteriores a 0.24.6 y 0.25.x en versiones anteriores a 0.25.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) a trav\u00e9s de una linea de paquete vac\u00eda."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.24.5", "matchCriteriaId": "6747DEC6-17F3-45F9-B98B-5161469D89F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:*:*:*:*:*:*:*", "matchCriteriaId": "157A6552-8A3B-42B7-8BA3-24B03BD7812E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EB081C3A-79B4-48A9-B6C2-46641293244B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D0A1B2E8-B0EC-41B9-A8B2-DD6A0A8DF14C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00030.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00036.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00072.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/10/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/11/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95339", "source": "security@debian.org"}, {"url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/84d30d569ada986f3eef527cbdb932643c2dd037", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://libgit2.github.com/security/", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a"}}