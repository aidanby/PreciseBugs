{"buggy_code": ["'use strict';\n\nconst path = require('path');\nconst execa = require('execa');\nconst chalk = require('chalk');\nconst stopProcess = require('./stop-process');\n\n/**\n * Gets the package version on npm. Will fail if the package does not exist\n * @param {string} packageName Name to look up on npm, may include a specific version\n * @param {Object} options\n * @param {boolean} options.useYarn Yarn instead of npm\n * @returns {Object}\n */\nasync function getPackageInfo(packageName, { useYarn } = {}) {\n  // Use yarn if possible because it's faster\n  if (useYarn) {\n    const { stdout } = await execa.command(`yarn info ${packageName} --json`);\n    const yarnInfo = JSON.parse(stdout);\n    return {\n      name: yarnInfo.data.name,\n      version: yarnInfo.data.version,\n    };\n  }\n\n  // Fallback to npm\n  const { stdout } = await execa.command(`npm view ${packageName} name version --silent`);\n  // Use regex to parse name and version from CLI result\n  const [name, version] = stdout.match(/(?<=')(.*?)(?=')/gm);\n  return { name, version };\n}\n\n/**\n * Get the version and full package name of the starter\n * @param {string} starter - The name of the starter as provided by the user\n * @param {Object} options\n * @param {boolean} options.useYarn - Use yarn instead of npm\n * @returns {Object} - Full name and version of the starter package on npm\n */\nasync function getStarterPackageInfo(starter, { useYarn } = {}) {\n  // Check if starter is a shorthand\n  try {\n    const longhand = `@strapi/starter-${starter}`;\n    const packageInfo = await getPackageInfo(longhand, { useYarn });\n    // Hasn't crashed so it is indeed a shorthand\n    return packageInfo;\n  } catch (error) {\n    // Ignore error, we now know it's not a shorthand\n  }\n  // Fetch version of the non-shorthand package\n  try {\n    return getPackageInfo(starter, { useYarn });\n  } catch (error) {\n    stopProcess(`Could not find package ${chalk.yellow(starter)} on npm`);\n  }\n}\n\n/**\n * Download a starter package from the npm registry\n * @param {Object} packageInfo - Starter's npm package information\n * @param {string} packageInfo.name\n * @param {string} packageInfo.version\n * @param {string} parentDir - Path inside of which we install the starter\n * @param {Object} options\n * @param {boolean} options.useYarn - Use yarn instead of npm\n */\nasync function downloadNpmStarter({ name, version }, parentDir, { useYarn } = {}) {\n  // Download from npm, using yarn if possible\n  if (useYarn) {\n    await execa.command(`yarn add ${name}@${version} --no-lockfile --silent`, {\n      cwd: parentDir,\n    });\n  } else {\n    await execa.command(`npm install ${name}@${version} --no-save --silent`, {\n      cwd: parentDir,\n    });\n  }\n\n  // Return the path of the actual starter\n  const exactStarterPath = path.dirname(\n    require.resolve(`${name}/package.json`, { paths: [parentDir] })\n  );\n  return exactStarterPath;\n}\n\nmodule.exports = { getStarterPackageInfo, downloadNpmStarter };\n", "'use strict';\n\nconst path = require('path');\nconst execa = require('execa');\nconst chalk = require('chalk');\n\n/**\n * Gets the package version on npm. Will fail if the package does not exist\n * @param {string} packageName - Name to look up on npm, may include a specific version\n * @returns {Object}\n */\nasync function getPackageInfo(packageName) {\n  const { stdout } = await execa.shell(`npm view ${packageName} name version --silent`);\n  // Use regex to parse name and version from CLI result\n  const [name, version] = stdout.match(/(?<=')(.*?)(?=')/gm);\n  return { name, version };\n}\n\n/**\n * @param {string} template - The name of the template as provided by the user.\n * @returns {Object} - The full name of the template package's name on npm\n */\nasync function getTemplatePackageInfo(template) {\n  // Check if template is a shorthand\n  try {\n    const longhand = `@strapi/template-${template}`;\n    const packageInfo = await getPackageInfo(longhand);\n    // Hasn't crashed so it is indeed a shorthand\n    return packageInfo;\n  } catch (error) {\n    // Ignore error, we now know it's not a shorthand\n  }\n  // Fetch version of the non-shorthand package\n  try {\n    return getPackageInfo(template);\n  } catch (error) {\n    throw new Error(`Could not find package ${chalk.yellow(template)} on npm`);\n  }\n}\n\n/**\n * @param {Object} packageInfo - Template's npm package information\n * @param {string} packageInfo.name\n * @param {string} packageInfo.version\n * @param {string} parentDir - Path inside of which we install the template.\n */\nasync function downloadNpmTemplate({ name, version }, parentDir) {\n  // Download from npm\n  await execa.shell(`npm install ${name}@${version} --no-save --silent`, {\n    cwd: parentDir,\n  });\n\n  // Return the path of the actual template\n  const exactTemplatePath = path.dirname(\n    require.resolve(`${name}/package.json`, { paths: [parentDir] })\n  );\n  return exactTemplatePath;\n}\n\nmodule.exports = { getTemplatePackageInfo, downloadNpmTemplate };\n"], "fixing_code": ["'use strict';\n\nconst path = require('path');\nconst execa = require('execa');\nconst chalk = require('chalk');\nconst stopProcess = require('./stop-process');\n\n/**\n * Gets the package version on npm. Will fail if the package does not exist\n * @param {string} packageName Name to look up on npm, may include a specific version\n * @param {Object} options\n * @param {boolean} options.useYarn Yarn instead of npm\n * @returns {Object}\n */\nasync function getPackageInfo(packageName, { useYarn } = {}) {\n  // Use yarn if possible because it's faster\n  if (useYarn) {\n    const { stdout } = await execa('yarn', ['info', packageName, '--json']);\n    const yarnInfo = JSON.parse(stdout);\n    return {\n      name: yarnInfo.data.name,\n      version: yarnInfo.data.version,\n    };\n  }\n\n  // Fallback to npm\n  const { stdout } = await execa('npm', ['view', packageName, 'name', 'version', '--silent']);\n  // Use regex to parse name and version from CLI result\n  const [name, version] = stdout.match(/(?<=')(.*?)(?=')/gm);\n  return { name, version };\n}\n\n/**\n * Get the version and full package name of the starter\n * @param {string} starter - The name of the starter as provided by the user\n * @param {Object} options\n * @param {boolean} options.useYarn - Use yarn instead of npm\n * @returns {Object} - Full name and version of the starter package on npm\n */\nasync function getStarterPackageInfo(starter, { useYarn } = {}) {\n  // Check if starter is a shorthand\n  try {\n    const longhand = `@strapi/starter-${starter}`;\n    const packageInfo = await getPackageInfo(longhand, { useYarn });\n    // Hasn't crashed so it is indeed a shorthand\n    return packageInfo;\n  } catch (error) {\n    // Ignore error, we now know it's not a shorthand\n  }\n  // Fetch version of the non-shorthand package\n  try {\n    return getPackageInfo(starter, { useYarn });\n  } catch (error) {\n    stopProcess(`Could not find package ${chalk.yellow(starter)} on npm`);\n  }\n}\n\n/**\n * Download a starter package from the npm registry\n * @param {Object} packageInfo - Starter's npm package information\n * @param {string} packageInfo.name\n * @param {string} packageInfo.version\n * @param {string} parentDir - Path inside of which we install the starter\n * @param {Object} options\n * @param {boolean} options.useYarn - Use yarn instead of npm\n */\nasync function downloadNpmStarter({ name, version }, parentDir, { useYarn } = {}) {\n  // Download from npm, using yarn if possible\n  if (useYarn) {\n    await execa('yarn', ['add', `${name}@${version}`, '--no-lockfile', '--silent'], {\n      cwd: parentDir,\n    });\n  } else {\n    await execa('npm', ['install', `${name}@${version}`, '--no-save', '--silent'], {\n      cwd: parentDir,\n    });\n  }\n\n  // Return the path of the actual starter\n  const exactStarterPath = path.dirname(\n    require.resolve(`${name}/package.json`, { paths: [parentDir] })\n  );\n  return exactStarterPath;\n}\n\nmodule.exports = { getStarterPackageInfo, downloadNpmStarter };\n", "'use strict';\n\nconst path = require('path');\nconst execa = require('execa');\nconst chalk = require('chalk');\n\n/**\n * Gets the package version on npm. Will fail if the package does not exist\n * @param {string} packageName - Name to look up on npm, may include a specific version\n * @returns {Object}\n */\nasync function getPackageInfo(packageName) {\n  const { stdout } = await execa('npm', ['view', packageName, 'name', 'version', '--silent']);\n  // Use regex to parse name and version from CLI result\n  const [name, version] = stdout.match(/(?<=')(.*?)(?=')/gm);\n  return { name, version };\n}\n\n/**\n * @param {string} template - The name of the template as provided by the user.\n * @returns {Object} - The full name of the template package's name on npm\n */\nasync function getTemplatePackageInfo(template) {\n  // Check if template is a shorthand\n  try {\n    const longhand = `@strapi/template-${template}`;\n    const packageInfo = await getPackageInfo(longhand);\n    // Hasn't crashed so it is indeed a shorthand\n    return packageInfo;\n  } catch (error) {\n    // Ignore error, we now know it's not a shorthand\n  }\n  // Fetch version of the non-shorthand package\n  try {\n    return getPackageInfo(template);\n  } catch (error) {\n    throw new Error(`Could not find package ${chalk.yellow(template)} on npm`);\n  }\n}\n\n/**\n * @param {Object} packageInfo - Template's npm package information\n * @param {string} packageInfo.name\n * @param {string} packageInfo.version\n * @param {string} parentDir - Path inside of which we install the template.\n */\nasync function downloadNpmTemplate({ name, version }, parentDir) {\n  // Download from npm\n  await execa('npm', ['install', `${name}@${version}`, '--no-save', '--silent'], {\n    cwd: parentDir,\n  });\n\n  // Return the path of the actual template\n  const exactTemplatePath = path.dirname(\n    require.resolve(`${name}/package.json`, { paths: [parentDir] })\n  );\n  return exactTemplatePath;\n}\n\nmodule.exports = { getTemplatePackageInfo, downloadNpmTemplate };\n"], "filenames": ["packages/cli/create-strapi-starter/utils/fetch-npm-starter.js", "packages/generators/app/lib/utils/fetch-npm-template.js"], "buggy_code_start_loc": [18, 13], "buggy_code_end_loc": [75, 50], "fixing_code_start_loc": [18, 13], "fixing_code_end_loc": [75, 50], "type": "CWE-77", "message": "Arbitrary Command Injection in GitHub repository strapi/strapi prior to 4.1.0.", "other": {"cve": {"id": "CVE-2022-0764", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-26T15:15:07.910", "lastModified": "2022-07-22T10:28:23.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Arbitrary Command Injection in GitHub repository strapi/strapi prior to 4.1.0."}, {"lang": "es", "value": "Una Inyecci\u00f3n Arbitraria de Comandos en el repositorio de GitHub strapi/strapi versiones anteriores a 4.1.0.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.6, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:strapi:strapi:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "412D3B41-C0FD-4ED9-AD6B-00C83BEBC0C7"}]}]}], "references": [{"url": "https://github.com/strapi/strapi/commit/2a3f5e988be6a2c7dae5ac22b9e86d579b462f4c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/strapi/strapi/issues/12879", "source": "security@huntr.dev", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/001d1c29-805a-4035-93bb-71a0e81da3e5", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/strapi/strapi/commit/2a3f5e988be6a2c7dae5ac22b9e86d579b462f4c"}}