{"buggy_code": ["= WeeChat ChangeLog\n:author: S\u00e9bastien Helleu\n:email: flashcode@flashtux.org\n:lang: en\n:toc: left\n:docinfo1:\n\n\nThis document lists all changes for each version\n(the latest formatted version of this document can be found\nhttps://weechat.org/files/changelog/ChangeLog-devel.html[here]).\n\nFor a list of important changes that require manual action, please look at\nhttps://weechat.org/files/releasenotes/ReleaseNotes-devel.html[release notes]\n(file _ReleaseNotes.adoc_ in sources).\n\n\n[[v2.8]]\n== Version 2.8 (under dev)\n\nNew features::\n\n  * core: add variable \"old_full_name\" in buffer, set during buffer renaming (issue #1428)\n  * core: add debug option \"-d\" in command /eval (issue #1434)\n  * api: add info \"weechat_headless\" (issue #1433)\n  * buflist: add pointer \"window\" in bar item evaluation\n  * relay: reject client with weechat protocol if password or totp is received in init command but not set in WeeChat (issue #1435)\n\nBug fixes::\n\n  * core: fix memory leak in completion\n  * core: flush stdout/stderr before forking in hook_process function (issue #1441)\n  * core: fix evaluation of condition with nested \"if\" (issue #1434)\n  * irc: fix crash when receiving a malformed message 324 (channel mode)\n  * irc: add nick changes in the hotlist (except self nick change)\n  * irc: case-insensitive comparison on incoming CTCP command, force upper case on CTCP replies (issue #1439)\n  * irc: fix memory leak when the channel topic is changed\n  * logger: fix crash when logging is disabled on a buffer and the log file was deleted in the meanwhile, when option logger.file.info_lines is on (issue #1444)\n  * relay: update buffers synchronization when buffers are renamed (issue #1428)\n  * xfer: send signal \"xfer_ended\" after the received file has been renamed (issue #1438)\n\nTests::\n\n  * unit: add tests on functions util_get_time_diff and util_file_get_content\n\nBuild::\n\n  * guile: add detection of Guile 3.0.0 (issue #1442)\n  * irc: fix build with GnuTLS < 3.1.0 (issue #1431)\n  * php: add detection of PHP 7.4\n\n[[v2.7]]\n== Version 2.7 (2019-12-08)\n\nNew features::\n\n  * core: add option weechat.look.nick_color_hash_salt to shuffle nick colors (issue #635)\n  * core: add different icons sizes (16x16 to 512x512) (issue #1347)\n  * core: add file weechat.desktop\n  * core: add reverse of string for screen in evaluation of expressions with \"revscr:\"\n  * core: add length of string (number of chars and on screen) in evaluation of expressions with \"length:xxx\" and \"lengthscr:xxx\"\n  * core: add calculation of expression in evaluation of expressions with \"calc:xxx\" (issue #997)\n  * core: add optional default path (evaluated) in completion \"filename\"\n  * core: add support of modifiers in evaluation of expressions with \"modifier:name,data,string\"\n  * api: add modifier \"color_encode_ansi\" (issue #528)\n  * api: add modifier \"eval_path_home\"\n  * irc: add filters on raw buffer (issue #1000)\n  * irc: add option irc.look.display_pv_warning_address to display a warning in private buffer if the remote nick address has changed (issue #892)\n  * irc: add server option \"ssl_password\" (issue #115, issue #1416)\n  * irc: add \"user\" in output of irc_message_parse (issue #136)\n  * irc: add options irc.color.message_kick and irc.color.reason_kick (issue #683, issue #684)\n  * logger: add option logger.file.color_lines (issue #528, issue #621)\n  * script: add options \"-ol\" and \"-il\" in command \"/script list\" to send translated string with list of scripts loaded, display \"No scripts loaded\" if no scripts are loaded\n  * xfer: add option xfer.file.download_temporary_suffix with default value \".part\" (issue #1237)\n\nBug fixes::\n\n  * core: set buffer name, short name and title only if the value has changed\n  * core: fix scrolling up in bare mode when switched to bare mode at the top of the buffer (issue #899, issue #978)\n  * core: optimize load of configuration files\n  * core: fix window separators not respecting window splits (issue #630)\n  * core: fix cursor mode info when prefix_align is none and with words split across lines (issue #610, issue #617, issue #619)\n  * core: add support of reverse video in ANSI color codes\n  * core: fixed segfault during excessive evaluation in function string_repeat (issue #1400)\n  * buflist: fix extra spaces between buffers when conditions are used to hide buffers (regression introduced in version 2.6) (issue #1403)\n  * irc: do not automatically open a channel with name \"0\" (issue #1429)\n  * irc: remove option irc.network.channel_encode, add server option \"charset_message\" to control which part of the IRC message is decoded/encoded to the target charset (issue #832)\n  * irc: use path from option xfer.file.upload_path to complete filename in command \"/dcc send\" (issue #60)\n  * logger: fix write in log file if it has been deleted or renamed (issue #123)\n  * python: send \"bytes\" instead of \"str\" to callbacks in Python 3 when the string is not UTF-8 valid (issue #1389)\n  * relay: send message \"_buffer_title_changed\" to clients only when the title is changed\n  * xfer: fix memory leak when a xfer is freed and when the plugin is unloaded\n\nTests::\n\n  * unit: add tests on GUI color functions\n\nBuild::\n\n  * core: fix build on Haiku (issue #1420)\n  * core: fix build on Alpine\n  * core: remove file FindTCL.cmake\n  * core: display an error on missing dependency in CMake (issue #916, issue #956)\n  * debian: disable Javascript plugin on Debian Sid and Ubuntu Eoan\n  * debian: build with Guile 2.2\n  * guile: add support of Guile 2.2, disable /guile eval (issue #1098)\n  * python: add detection of Python 3.8\n\n[[v2.6]]\n== Version 2.6 (2019-09-08)\n\nNew features::\n\n  * core: add support of 32767 color pairs (issue #1343, issue #1345)\n  * core: add option \"close\" in command /window (issue #853)\n  * api: add infos \"term_colors\" and \"term_color_pairs\"\n  * api: add function list_user_data (issue #666)\n  * api: add argument \"strip_items\" in function string_split\n  * buflist: add infolist \"buflist\" with list of buffer pointers (issue #1375)\n  * exec: evaluate option exec.command.shell, change default value to \"${env:SHELL}\" (issue #1356)\n  * fset: add filters \"h=xxx\" and \"he=xxx\" to filter options by description (translated or in English)\n  * irc: make command char optional in server option \"command\" (issue #615)\n  * irc: add variables \"user_max_length\" and \"host_max_length\" in server structure (issue #1387)\n\nBug fixes::\n\n  * core: use fixed-width integer for computing nick and hashtable DJB2 key hashes, add values \"djb2_32\" and \"sum_32\" for option weechat.look.nick_color_hash (issue #1394)\n  * core: create or update option weechat.notify.xxx when function buffer_set is called with \"notify\" property (issue #1390)\n  * core: fix memory leak in case of error when building content of bar item for display (issue #1384)\n  * core: send command line parameter to plugins only if the name starts with the plugin name followed by a colon\n  * core: auto disable upgrade process (command line option \"--upgrade\") if the file weechat.upgrade is not found\n  * core: replace newlines by spaces in argument \"completion\" of function hook_command (issue #538)\n  * core: replace char \",\" by \"~\" in color codes to separate foreground from background (issue #1264)\n  * alias: remove default aliases /AME and /AMSG (issue #1355)\n  * buflist: use extra variables in option buflist.look.display_conditions (issue #1393)\n  * irc: fix parsing of messages 346 (invite list), 348 (exception list), 367 (ban list) and 728 (quiet list) when there is a colon before the timestamp (issue #1396)\n  * irc: fix memory leak when removing a server\n  * irc: fix length of user/nick/host in split of messages (issue #1387)\n  * irc: quote NICK command argument sent to the server only if there's a \":\" in the nick (issue #1376, issue #1319)\n  * irc: return all arguments in the PONG response to a PING (issue #1369)\n  * irc: disable server reconnection when the server buffer is closed (issue #236)\n  * irc: strip spaces at beginning/end of addresses in server option \"addresses\" (issue #195)\n  * irc: fix display of enabled/disabled client capabilities received in command CAP ACK (issue #151)\n  * ruby: fix conversion of big integers on 32bit architecture (issue #1395)\n\nTests::\n\n  * unit: add tests on IRC ignore, message and nick functions\n\nBuild::\n\n  * core: fix compilation with autotools on FreeBSD 12.0\n  * debian: disable Javascript plugin on Debian Buster/Bullseye (issue #1374)\n  * python: compile with Python 3 by default\n  * python: use pkg-config to detect Python (issue #1382)\n\n[[v2.5]]\n== Version 2.5 (2019-06-06)\n\nNew features::\n\n  * core: use getopt to parse command line arguments\n  * core: add option weechat.look.prefix_same_nick_middle (issue #930, issue #931)\n  * core: add option weechat.look.buffer_time_same (issue #1127)\n  * core: use seconds by default in /repeat interval, allow unit for the interval\n  * core: allow text in addition to a command in command /repeat\n  * core: add option \"addreplace\" in command /filter (issue #1055, issue #1312)\n  * api: return allocated string in hook_info callback and function info_get\n  * api: replace argument \"keep_eol\" by \"flags\" in function string_split (issue #1322)\n  * api: add function command_options (issue #928)\n  * api: add function string_match_list\n  * irc: add bar items \"irc_nick\", \"irc_host\" and \"irc_nick_host\"\n  * irc: add variable \"host\" in server structure\n  * relay: add support of UNIX socket (issue #733, issue #1333)\n  * relay: add option relay.weechat.commands (issue #928)\n  * script: use SHA-512 instead of MD5 for script checksum\n  * spell: rename aspell plugin to spell (issue #1299)\n  * trigger: add hooks \"info\" and \"info_hashtable\"\n  * xfer: rename option xfer.network.speed_limit to xfer.network.speed_limit_send, add option xfer.network.speed_limit_recv (issue #269)\n\nBug fixes::\n\n  * core: don't execute command scheduled by /repeat and /wait if the buffer does not exist any more\n  * core: set max length to 4096 for /secure passphrase (issue #1323)\n  * core: refilter only affected buffers on filter change (issue #1309, issue #1311)\n  * fset: fix slow refresh of fset buffer during /reload (issue #1313)\n  * irc: fix parsing of MODE command when there are colons after the first mode argument (issue #1296)\n  * irc: fix memory leak in infos \"irc_server_isupport\" and \"irc_server_isupport_value\"\n  * irc: fix length of string for SHA-512, SHA-256 and SHA-1 in help on ssl_fingerprint option\n  * irc: display an error with /allchan -current or /allpv -current if the current buffer is not an irc buffer (issue #1325)\n  * irc: fix update of channels modes with arguments when joining a channel (issue #1324)\n  * irc: quote NICK command argument sent to the server (issue #1319)\n  * php: fix memory leak in functions string_eval_expression, string_eval_path_home, key_bind, hook_process_hashtable, hook_hsignal_send, info_get_hashtable, hdata_update\n  * relay: fix crash when a weechat relay client reloads the relay plugin with /plugin reload relay (issue #1327)\n  * spell: fix detection of nick followed by the nick completer (issue #1306, issue #1307)\n  * trigger: fix split of hook arguments (issue #1322)\n\nTests::\n\n  * unit: add tests on function util_signal_search\n\nBuild::\n\n  * core: fix value of libdir in file weechat.pc (issue #1341, issue #1342)\n  * core: fix generation of man page weechat-headless with autotools\n  * core: add CMake option \"ENABLE_CODE_COVERAGE\" to compile with code coverage options (CMake \u2265 3.0 is now required)\n  * core: fix compilation on Mac OS (issue #1308)\n  * lua: add detection of Lua 5.3 with autotools\n  * ruby: add detection of Ruby 2.6 (issue #1346)\n  * tests: fix compilation of tests on FreeBSD\n\n[[v2.4]]\n== Version 2.4 (2019-02-17)\n\nNew features::\n\n  * core: do not automatically add a space when completing \"nick:\" at the beginning of command line (the space can be added in option weechat.completion.nick_completer)\n  * core: add default keys kbd:[Ctrl+F11]/kbd:[Ctrl+F12] to scroll up/down one page in nicklist (same action as kbd:[F11]/kbd:[F12])\n  * core: add command line option \"-t\" (or \"--temp-dir\") to create a temporary WeeChat home (deleted on exit)\n  * api: add functions string_base_encode and string_base_decode, remove functions string_encode_base64 and string_decode_base64\n  * api: add support of Time-based One-Time Password (TOTP), add infos \"totp_generate\" and \"totp_validate\"\n  * buflist: add default keys kbd:[Ctrl+F1]/kbd:[Ctrl+F2] to scroll up/down one page in buflist (same action as kbd:[F1]/kbd:[F2])\n  * buflist: add variable ${number2}, always set with the indented buffer number\n  * exec: add option exec.command.shell to customize the shell used with /exec -sh\n  * relay: add support of close frame in websocket connection (issue #1281)\n  * relay: add support of Time-based One-Time Password (TOTP) as second authentication factor in weechat protocol\n\nBug fixes::\n\n  * core: fix compilation of empty regular expression (not allowed on FreeBSD)\n  * core: fix forced highlight on messages sent to other buffers (issue #1277)\n  * aspell: look for suggestions only if the misspelled word has changed (issue #1175)\n  * buflist: add alternate key codes for kbd:[F1]/kbd:[F2] and kbd:[Alt+F1]/kbd:[Alt+F2] (compatibility with terminals)\n  * buflist: fix warning displayed when script buffers.pl is loaded (issue #1274)\n  * irc: fix parsing of whois messages in notify\n  * irc: fix parsing of MODE, 341 (invite) and CHGHOST commands when there are colons (issue #1296)\n  * irc: return IRC color code instead of WeeChat color code when decoding a too short ANSI color sequence\n  * irc: fix encoding of italic attribute when colors are removed\n  * irc: fix parsing of \"time\" message tag on FreeBSD (issue #1289)\n  * relay: fix crash on /upgrade when the real IP is not set (issue #1294)\n  * relay: fix memory leak in connection of client\n\nTests::\n\n  * unit: fix UTF-8 and evaluation tests on FreeBSD\n  * unit: add tests on IRC configuration and protocol functions\n\nBuild::\n\n  * core: add C compiler flag \"-fsigned--char\" to force \"char\" data type to be always signed (issue #1277)\n\n[[v2.3]]\n== Version 2.3 (2018-10-21)\n\nNew features::\n\n  * core: add repeat of string in evaluation of expressions with \"repeat:count,string\" (issue #958)\n  * core: allow specifying buffer number/name for /buffer localvar (issue #1259)\n  * core: allow multiple arguments in command \"/buffer close\"\n  * core: allow multiple options \"-r\" (or \"--run-command\") in command line arguments (issue #1248)\n  * core: add command line option \"-P\" (or \"--plugins\") to customize the plugins to load at startup\n  * core: allow partial buffer name in command \"/buffer close\" (issue #1226)\n  * api: add function hook_line (issue #66)\n  * irc: display a warning when the value of option irc.server.xxx.autojoin is set to an invalid value\n  * relay: add real IP in client description (issue #1256)\n  * trigger: allow creation of temporary variables with the regex\n  * trigger: add hook \"line\"\n\nBug fixes::\n\n  * core: fix evaluation of nested ternary operators (issue #1263)\n  * core: fix evaluation of condition when the left operand is an empty string\n  * core: fix string evaluation with regex replacement when the string is empty\n  * core: fix check of tags in lines (command /filter and hook_print)\n  * core: fix clear of completion item in case of partial completion (issue #1162)\n  * core: send signal \"key_pressed\" for mouse code only if the string is UTF-8 valid (issue #1220)\n  * api: fix memory leak in function string_split\n  * lua: fix return code of mkdir functions in case of error (issue #1267)\n  * scripts: fix duplicated lines in output of script eval (python, perl, ruby, lua and guile)\n\nTests::\n\n  * unit: add tests on line and hook functions\n\nBuild::\n\n  * php: add detection of PHP 7.3\n\n[[v2.2]]\n== Version 2.2 (2018-07-14)\n\nNew features::\n\n  * core: change default value of option weechat.look.hotlist_add_conditions to check connected relay clients via weechat protocol (issue #1206)\n  * core: add reverse of string in evaluation of expressions with \"rev:\" (issue #1200)\n  * core: send buffer pointer (when possible) in signal \"hotlist_changed\" (issue #1133)\n  * core: add support of list options in curl (issue #826, issue #219)\n  * core: allow merge of buffers by name in command /buffer (issue #1108, issue #1159)\n  * api: add function hashtable_add_from_infolist\n  * api: add function string_format_size in scripting API\n  * irc: add nick, host and log tags in message displayed in private buffer when the nick comes back on the server (issue #1221)\n  * irc: add support for IRCv3.2 chghost, add options irc.look.smart_filter_chghost and irc.color.message_chghost (issue #640)\n  * irc: add support for IRCv3.2 invite-notify (issue #639)\n  * irc: add support for IRCv3.2 Client Capability Negotiation (issue #586, issue #623)\n  * irc: display current nick on connected servers in output of /server list|listfull (issue #1193)\n  * irc: add option \"-server\" in command /list (issue #1165)\n  * irc: add indexed ban list, add completion for /unban and /unquiet (issue #597, task #11374, task #10876)\n  * relay: add filtering on protocol in info \"relay_client_count\"\n  * trigger: hide password in command \"/msg nickserv set password\"\n  * xfer: add option xfer.network.send_ack (issue #1171)\n\nBug fixes::\n\n  * core: fix TLS handshake failure on server connection when there are multiple addresses in the server (issue #1196)\n  * core: count number of chars instead of bytes for suffix in function string_cut\n  * core: fix delete of previous/next word (keys kbd:[Ctrl+w] and kbd:[Alt+d]) (issue #1195)\n  * core: fix infinite loop in evaluation of strings (issue #1183)\n  * core: change default value of option weechat.look.window_title from \"WeeChat ${info:version}\" to empty string (issue #1182)\n  * buflist: fix crash when setting the option buflist.look.signals_refresh with a list of signals\n  * fset: fix memory leak when switching the format with kbd:[Ctrl+x]\n  * fset: fix truncation of option values when the length is greater than 4096 (issue #1218)\n  * fset: fix crash when applying filters after closing the fset buffer (issue #1204)\n  * irc: display message 354 (WHOX) received with missing parameters (issue #1212)\n  * irc: always set nick away status on WHO response (sent manually or automatically with server option \"away_check\")\n  * irc: fix a crash when calling the function hdata_string on the \"prefix\" variable in the nick\n  * irc: fix split of messages when server option \"split_msg_max_length\" is set to 0 (no split) (issue #1173)\n  * irc: send whole IRC message including IRCv3 tags in the signals irc_in, irc_in2, irc_raw_in and irc_raw_in2 (issue #787)\n  * irc: fix memory leak when receiving a message with IRCv3 tags\n  * guile: fix memory leak in 7 functions returning allocated strings\n  * lua: fix macros used to return values\n  * php: fix return code of functions config_write_option and config_write_line\n  * php: fix memory leak in 72 functions returning allocated strings\n  * python: fix crash when loading a script with Python >= 3.7 (issue #1219)\n  * relay: fix socket creation for relay server on OpenBSD (issue #1213)\n  * ruby: fix memory leak in 7 functions returning allocated strings\n  * script: fix memory leak in case of invalid XML content in list of scripts\n  * scripts: fix memory leak in hook_info callback\n  * scripts: fix return value of hook_infolist callback (pointer instead of string)\n  * scripts: return long integer instead of string in function infolist_time\n  * xfer: set option TCP_NODELAY on socket when receiving a file via DCC (issue #1171)\n\nDocumentation::\n\n  * core: split man pages weechat and weechat-headless\n\nTests::\n\n  * unit, scripts: add tests on infolists\n\nBuild::\n\n  * core: fix build with CMake and Ninja\n  * debian: add package weechat-headless with the headless binary and its man page\n  * javascript: fix compilation of javascript plugin with autotools on some Linux distributions (issue #1208)\n  * python: add detection of Python 3.7\n\n[[v2.1]]\n== Version 2.1 (2018-03-18)\n\nNew features::\n\n  * core: add binary weechat-headless to run WeeChat without interface, with optional daemon mode (command line option \"--daemon\") (issue #1120)\n  * core: add options \"-newbuffer\", \"-free\" and \"-switch\" in command /print (issue #1113)\n  * core: add option \"-y\" in command /print, add support of buffers with free content\n  * core: add option \"add\" in command /buffer (issue #1113)\n  * core: add option weechat.completion.partial_completion_templates to force partial completion on specific templates\n  * api: add hashtable with variables in plugin structure\n  * api: add time in info \"date\" (WeeChat compilation date/time) (issue #1138)\n  * irc: add server option \"split_msg_max_length\"\n  * irc: allow ${irc_server.xxx} and ${server} in server evaluated options (issue #1144)\n  * logger: add option logger.file.fsync (issue #1145)\n  * logger: add option logger.look.backlog_conditions (issue #1132)\n  * script: change default value of option script.look.sort from \"p,n\" to \"i,p,n\"\n  * scripts: add configuration file for each script plugin (_python.conf_, _perl.conf_, ...)\n  * scripts: add \"eval\" option in script commands and info \"xxx_eval\" (python, perl, ruby, lua and guile) (issue #128)\n  * scripts: add infos \"xxx_interpreter\" and \"xxx_version\" in script plugins (issue #1075)\n  * scripts: add option \"version\" in script commands (issue #1075)\n  * scripts: display the script name in stdout/stderr output from scripts\n\nBug fixes::\n\n  * core: fix regression on execution of hook_print callbacks (introduced in version 2.0)\n\nBuild::\n\n  * ruby: add detection of Ruby 2.5 (issue #1122)\n\n[[v2.0.1]]\n== Version 2.0.1 (2017-12-20)\n\nBug fixes::\n\n  * python: fix arguments status/gnutls_rc/sock in hook_connect callback\n  * python: fix argument fd in hook_fd callback\n\n[[v2.0]]\n== Version 2.0 (2017-12-03)\n\nNew features::\n\n  * core: add flag \"input_get_empty\" in buffer\n  * core: add signals \"buffer_filters_enabled\" and \"buffer_filters_disabled\"\n  * core: support loading of plugins from path in environment variable \"WEECHAT_EXTRA_LIBDIR\" (issue #971, issue #979)\n  * core: make value optional in command \"/buffer set\" (issue #746, issue #1088)\n  * core: allow floating point and hexadecimal numbers in comparison of evaluated values\n  * core: add option weechat.look.save_config_with_fsync (issue #1083)\n  * api: add support of prefix \"quiet:\" in function key_unbind to quietly remove keys\n  * api: add argument \"recurse_subdirs\" in function exec_on_files\n  * alias: add infolist \"alias_default\" (list of default aliases)\n  * buflist: add two new bar items (\"buflist2\" and \"buflist3\") using the same format configuration options (issue #990)\n  * buflist: add option buflist.look.add_newline (issue #1027)\n  * fset: new plugin \"fset\" (fast set of WeeChat and plugins options) (issue #584)\n  * php: new plugin \"php\" (issue #909)\n  * script: add local variable \"filter\" in the script buffer (issue #1037)\n\nBug fixes::\n\n  * core: do not change the chat prefix size when a filtered line is added (issue #1092)\n  * core: fix display of nicks in nicklist when they are in a group with sub-groups (issue #1079)\n  * core, plugins: check return code of strftime function\n  * core: fix cast of time_t (to \"long long\" instead of \"long\") (issue #1051)\n  * core: call the config hook when options are renamed or removed\n  * api: change type of arguments status/gnutls_rc/sock in hook_connect callback from string to integer (in scripts)\n  * api: change type of argument fd in hook_fd callback from string to integer (in scripts)\n  * buflist: remove recursive evaluation of extra variables (issue #1060)\n  * guile: return integer (0/1) instead of boolean in API functions\n  * guile: fix return value of static strings in API functions\n  * irc: do not clear nicklist when joining an already joined channel if the option irc.look.buffer_open_before_join is on (issue #1081)\n  * irc: fix CTCP PING reply when the option irc.ctcp.ping is set to non-empty value\n  * lua: fix boolean return value (as integer) in API functions\n  * relay: fix parsing of CAP command without arguments in irc protocol, send ACK only if all capabilities received are OK and NAK otherwise (issue #1040)\n\nTests::\n\n  * scripts: add scripting API tests (issue #104)\n  * unit: display an error if the required locale en_US.UTF-8 is not installed\n\nBuild::\n\n  * core: fix build with ncurses and separate tinfo (bug #41245, issue #1090)\n  * javascript: fix detection of libv8 with autotools on Ubuntu Trusty\n\n[[v1.9.1]]\n== Version 1.9.1 (2017-09-23)\n\nBug fixes::\n\n  * buflist: fix crash in auto-scroll of bar when the buflist item is not the first item in the bar\n  * logger: call strftime before replacing buffer local variables (CVE-2017-14727)\n  * relay: fix send of \"PART\" command in backlog (irc protocol)\n\n[[v1.9]]\n== Version 1.9 (2017-06-25)\n\nNew features::\n\n  * core: improve speed of nicklist bar item callback\n  * core: allow index for hdata arrays in evaluation of expressions\n  * api: allow update of variables \"scroll_x\" and \"scroll_y\" in bar_window with function hdata_update\n  * api: add functions config_option_get_string and hdata_compare\n  * buflist: add option buflist.look.auto_scroll (issue #332)\n  * buflist: add keys kbd:[F1]/kbd:[F2], kbd:[Alt+F1]/kbd:[Alt+F2] to scroll the buflist bar\n  * buflist: display a warning when the script \"buffers.pl\" is loaded\n  * buflist: add support of char \"~\" in option buflist.look.sort for case insensitive comparison\n  * buflist: add variable `${format_name}` in bar item evaluation and option buflist.format.name (issue #1020)\n  * buflist: add variables `${current_buffer}` and `${merged}` (booleans \"0\" / \"1\") in bar item evaluation\n  * relay: add option \"start\" in command /relay\n  * trigger: add \"irc_server\" and \"irc_channel\" pointers in data for IRC signal/modifier hooks\n\nBug fixes::\n\n  * core: fix bind of keys with space key, like kbd:[Alt+Space] (bug #32133)\n  * core: fix infinite loop when the terminal is closed on the secure password prompt (issue #1010)\n  * buflist: fix long mouse gestures\n  * buflist: fix slow switch of buffer when there are a lot of buffers opened (issue #998)\n  * buflist: add option \"bar\" in command /buflist, do not automatically add the \"buflist\" bar when the option buflist.look.enabled is off (issue #994)\n  * buflist: fix crash on drag & drop of buffers\n  * irc: don't reset nick properties (prefixes/away/account/realname) on /names when the nick already exists (issue #1019)\n  * irc: fix memory leak in case of error in \"ecdsa-nist256p-challenge\" SASL mechanism\n  * relay: rebind on address after option relay.network.bind_address is changed\n  * relay: fix parsing of CAP command arguments in irc protocol (issue #995)\n\n[[v1.8]]\n== Version 1.8 (2017-05-13)\n\nNew features::\n\n  * core: add option weechat.completion.nick_case_sensitive (issue #981)\n  * core: add wildcard matching operator (`+=*+` and `+!*+`) in evaluation of expressions (issue #611)\n  * core: add cut of string in evaluation of expressions with \"cut:\" (number of chars) and \"cutscr:\" (number of chars displayed on screen)\n  * core: add ternary operator (condition) in evaluation of expressions (`${if:condition?value_if_true:value_if_false}`)\n  * core: add resize of window parents with /window resize [h/v]size (task #11461, issue #893)\n  * core: add hotlist pointer in buffer structure\n  * core: add last start date in output of command /version after at least one /upgrade (issue #903)\n  * api: add arraylist functions: arraylist_new, arraylist_size, arraylist_get, arraylist_search, arraylist_insert, arraylist_add, arraylist_remove, arraylist_clear, arraylist_free\n  * api: add dynamic string functions: string_dyn_alloc, string_dyn_copy, string_dyn_concat, string_dyn_free\n  * api: add special key \"__quiet\" in hashtable for function key_bind\n  * api: add `${re:#}` to get the index of last group captured in function string_eval_expression\n  * aspell: add options to control delimiters in suggestions: aspell.color.suggestion_delimiter_{dict|word} and aspell.look.suggestion_delimiter_{dict|word} (issue #940)\n  * buflist: new plugin \"buflist\" (bar item with list of buffers)\n  * irc: add option \"open\" in command /server (issue #966)\n  * irc: send signal \"irc_server_lag_changed\" and store the lag in the server buffer (local variable)\n  * irc: send multiple masks by message in commands /ban, /unban, /quiet and /unquiet, use ban mask default for nicks in /quiet and /unquiet, display an error if /quiet and /unquiet are not supported by server (issue #579, issue #15, issue #577)\n  * irc: add option \"-include\" in commands /allchan, /allpv and /allserv (issue #572)\n  * irc: don't smart filter modes given to you (issue #530, issue #897)\n  * script: remove option script.scripts.url_force_https, use HTTPS by default in option script.scripts.url\n\nBug fixes::\n\n  * core: fix memory leak in display of mouse event debug info\n  * core: fix command /cursor stop (do not toggle cursor mode) (issue #964)\n  * core: fix delayed refresh when the signal SIGWINCH is received (terminal resized), send signal \"signal_sigwinch\" after refreshes (issue #902)\n  * irc: fix update of server addresses on reconnection when the evaluated content has changed (issue #925)\n  * irc: fix crash in case of invalid server reply during SASL authentication with dh-blowfish or dh-aes mechanism\n  * irc: fix double decoding of IRC colors in messages sent/displayed by commands /msg and /query (issue #943)\n  * irc: fix parsing of message 324 (modes) when there is a colon before the modes (issue #913)\n  * relay: check buffer pointer received in \"sync\" and \"desync\" commands (weechat protocol) (issue #936)\n  * relay: remove buffer from synchronized buffers when it is closed (fix memory leak)\n\nBuild::\n\n  * core: fix compilation on FreeBSD with autotools (issue #276)\n  * python: add detection of Python 3.6\n  * ruby: add detection of Ruby 2.4 (issue #895)\n\n[[v1.7.1]]\n== Version 1.7.1 (2017-04-22)\n\nBug fixes::\n\n  * irc: fix parsing of DCC filename (CVE-2017-8073)\n\n[[v1.7]]\n== Version 1.7 (2017-01-15)\n\nNew features::\n\n  * core: add option weechat.look.align_multiline_words (issue #411, issue #802)\n  * core: add optional command prefix in completion templates \"commands\", \"plugins_commands\" and \"weechat_commands\"\n  * core: add optional arguments in completion template, sent to the callback\n  * core: add option \"time\" in command /debug\n  * core, xfer: display more information on fork errors (issue #573)\n  * core: add a slash before commands completed in arguments of /command, /debug time, /key bind, /key bindctxt, /mute, /repeat, /wait\n  * core: add a warning in header of configuration files to not edit by hand (issue #851)\n  * api: add info \"uptime\" (WeeChat uptime)\n  * api: add info \"pid\" (WeeChat PID) (issue #850)\n  * alias: add a slash before commands completed in arguments of /alias\n  * exec: add option \"-oc\" in command /exec to execute commands in process output, don't execute commands by default with \"-o\" (issue #877)\n  * fifo: add file fifo.conf and option fifo.file.path to customize FIFO pipe path/filename (issue #850, issue #122)\n  * irc: add server option \"usermode\" (issue #377, issue #820)\n  * irc: add tag \"self_msg\" on self messages (issue #840)\n  * irc: evaluate content of server option \"ssl_fingerprint\" (issue #858)\n  * irc: change default value of option irc.network.lag_reconnect from 0 to 300 (issue #818)\n  * trigger: do not hide email in command \"/msg nickserv register password email\" (issue #849)\n\nBug fixes::\n\n  * core: fix deadlock when quitting after a signal SIGHUP/SIGQUIT/SIGTERM is received (issue #32)\n  * core: fix display of empty lines in search mode (issue #829)\n  * api: fix crash in function string_expand_home when the HOME environment variable is not set (issue #827)\n  * exec: fix memory leak in display of process output\n  * irc: fix option \"-temp\" in command /server (issue #880)\n  * irc: fix close of server channels which are waiting for the JOIN when the server buffer is closed (issue #873)\n  * irc: fix buffer switching on manual join for forwarded channels (issue #876)\n  * irc: add missing tags on CTCP message sent\n  * lua: fix integers returned in Lua >= 5.3 (issue #834)\n  * relay: make HTTP headers case-insensitive for WebSocket connections (issue #888)\n  * relay: set status to \"authentication failed\" and close immediately connection in case of authentication failure in weechat and irc protocols (issue #825)\n  * script: reload a script after upgrade only if it was loaded, set autoload only if the script was auto-loaded (issue #855)\n\nBuild::\n\n  * core, irc, xfer: fix compilation on macOS (add link with resolv) (issue #276)\n  * core: add build of xz package with make dist (CMake)\n  * tests: fix compilation of tests on FreeBSD 11.0\n\n[[v1.6]]\n== Version 1.6 (2016-10-02)\n\nNew features::\n\n  * core: add optional argument \"lowest\", \"highest\" or level mask in command \"/input hotlist_clear\"\n  * core: add option \"cycle\" in command /buffer\n  * core, irc, xfer: display more information on memory allocation errors (issue #573)\n  * api: add \"extra\" argument to evaluate extra variables in function string_eval_expression (issue #534)\n  * api: remove functions printf_date and printf_tags\n  * irc: rename server options \"default_msg_{kick|part|quit}\" to \"msg_{kick|part|quit}\", evaluate them\n  * relay: add option relay.network.allow_empty_password (issue #735)\n  * relay: allow escape of comma in command \"init\" (weechat protocol) (issue #730)\n  * trigger: add support for one-time triggers (issue #399, issue #509)\n\nBug fixes::\n\n  * core, irc, xfer: refresh domain name and name server addresses before connection to servers (fix connection to servers after suspend mode) (issue #771)\n  * api: fix return of function string_match when there are multiple masks in the string (issue #812)\n  * api: fix crash in function network_connect_to if address is NULL\n  * api: fix connection to servers with hook_connect on Windows 10 with Windows subsystem for Linux (issue #770)\n  * api: fix crash in function string_split_command when the separator is not a semicolon (issue #731)\n  * irc: fix socket leak in connection to server (issue #358, issue #801)\n  * irc: fix display of service notice mask (message 008) (issue #429)\n  * irc: fix NULL pointer dereference in 734 command callback (issue #738)\n  * relay: return an empty hdata when the requested hdata or pointer is not found (issue #767)\n  * xfer: fix crash on DCC send if option xfer.file.auto_accept_nicks is set (issue #781)\n\nDocumentation::\n\n  * switch to asciidoctor to build docs and man page (issue #722)\n\nBuild::\n\n  * python: add detection of Python 3.5\n\n[[v1.5]]\n== Version 1.5 (2016-05-01)\n\nNew features::\n\n  * core: evaluate content of option \"weechat.look.item_time_format\" (issue #791)\n  * core: change default value of option weechat.look.nick_color_hash to \"djb2\"\n  * core: move nick coloring from irc plugin to core, move options irc.look.nick_color_force, irc.look.nick_color_hash and irc.look.nick_color_stop_chars to core, add info \"nick_color\" and \"nick_color_name\", deprecate info \"irc_nick_color\" and \"irc_color_name\" (issue #262)\n  * core: move irc bar item \"away\" to core, move options irc.look.item_away_message and irc.color.item_away to core (issue #692)\n  * api: add support of functions in hook_process\n  * api: add pointer in callbacks used in scripting API (issue #406)\n  * irc: add option irc.network.sasl_fail_unavailable (issue #600, issue #697)\n  * irc: add multiple targets and support of \"-server\" in command /ctcp (issue #204, issue #493)\n  * trigger: add \"recover\" in default triggers cmd_pass/msg_auth, and \"regain\" in default trigger \"msg_auth\" (issue #511)\n\nInternationalization::\n\n  * add Portuguese translations\n\nBug fixes::\n\n  * core: fix nick coloring when stop chars and a forced color are used: first remove chars then look for forced color\n  * core: check that pointers received in arguments are not NULL in buffers and windows functions\n  * core: fix truncation of buffer names in hotlist (issue #668)\n  * core: fix update of window title under Tmux (issue #685)\n  * api: fix number of arguments returned by function string_split when keep_eol is 2 and the string ends with separators\n  * irc: fix first message displayed in raw buffer when the message is modified by a modifier (issue #719)\n  * irc: add missing completion \"*\" for target in command /msg\n  * irc: fix /msg command with multiple targets including \"*\"\n  * lua: fix crash when a lua function doesn't return a value and a string was expected (issue #718)\n  * relay: do not execute any command received in a PRIVMSG message from an irc relay client (issue #699)\n  * relay: fix the max number of clients connected on a port, allow value 0 for \"no limit\" (issue #669)\n  * relay: fix decoding of multiple frames in a single websocket message, send PONG on PING received in a websocket frame (issue #675)\n  * relay: fix command \"input\" received from clients with only spaces in content of message (weechat protocol) (issue #663)\n  * script: force refresh of scripts buffer after download of scripts list (issue #693)\n  * xfer: fix DCC file received when the terminal is resized (issue #677, issue #680)\n\nBuild::\n\n  * python: fix detection of Python shared libraries (issue #676)\n  * ruby: add detection of Ruby 2.3 (issue #698)\n\n[[v1.4]]\n== Version 1.4 (2016-01-10)\n\nNew features::\n\n  * core: add a parent name in options, display inherited values if null in /set output, add option weechat.color.chat_value_null (issue #629)\n  * core: add tag \"term_warning\" in warnings about wrong $TERM on startup\n  * core: add option weechat.look.paste_auto_add_newline (issue #543)\n  * core: display a more explicit error when a filter fails to be added (issue #522)\n  * api: add function string_hex_dump\n  * api: add argument \"length\" in function utf8_is_valid\n  * alias: display completion in /alias list (issue #518)\n  * fifo: add /fifo command\n  * irc: track real names using extended-join and WHO (issue #351)\n  * irc: add support of SNI (Server Name Indication) in SSL connection to IRC server (issue #620)\n  * irc: add support of \"cap-notify\" capability (issue #182, issue #477)\n  * irc: add command /cap (issue #8)\n  * irc: add hex dump of messages in raw buffer when debug is enabled for irc plugin (level 2 or more)\n  * irc: evaluate content of server option \"addresses\"\n  * irc: move option irc.network.alternate_nick into servers (irc.server.xxx.nicks_alternate) (issue #633)\n  * irc: use current channel and current server channels first in completions \"irc_server_channels\" and \"irc_channels\" (task #12923, issue #260, issue #392)\n  * logger: display system error when the log file can not be written (issue #541)\n  * relay: add option relay.irc.backlog_since_last_message (issue #347)\n  * script: add option script.scripts.download_timeout\n  * script: add completion with languages and extensions, support search by language/extension in /script search\n\nBug fixes::\n\n  * core: fix execution of empty command name (\"/\" and \"/ \" are not valid commands)\n  * core: fix memory leak when using multiple \"-d\" or \"-r\" in command line arguments\n  * core: don't complain any more about \"tmux\" and \"tmux-256color\" $TERM values when WeeChat is running under Tmux (issue #519)\n  * core: fix truncated messages after a word with a length of zero on screen (for example a zero width space: U+200B) (bug #40985, issue #502)\n  * api: fix handle of invalid escape in function string_convert_escaped_chars\n  * alias: do not allow slashes and spaces in alias name (issue #646)\n  * irc: fix channel forwarding when option irc.look.buffer_open_before_{autojoin|join} is on (issue #643)\n  * irc: add a missing colon before the password in PASS message, if the password has spaces or begins with a colon (issue #602)\n  * irc: fix charset decoding in incoming private messages (issue #520)\n  * irc: display the arrow before server name in raw buffer\n  * irc: fix display of messages sent to server in raw buffer\n  * irc: fix display of invalid UTF-8 chars in raw buffer\n  * relay: display the arrow before client id and protocol in raw buffer\n  * ruby: fix load of scripts requiring \"uri\" (issue #433)\n\nDocumentation::\n\n  * add Czech man page and quickstart guide (issue #490)\n\nTests::\n\n  * unit: add a test to check if all plugins are loaded\n  * unit: fix locale used to execute tests (issue #631)\n\nBuild::\n\n  * core: add scripts version.sh and build-debian.sh, separate stable from devel Debian packaging\n  * ruby: fix Ruby detection when pkg-config is not installed\n\n[[v1.3]]\n== Version 1.3 (2015-08-16)\n\nNew features::\n\n  * core: add completion \"colors\" (issue #481)\n  * core: start/stop search in buffer at current scroll position by default, add key kbd:[Ctrl+q] to stop search and reset scroll (issue #76, issue #393)\n  * core: add option weechat.look.key_grab_delay to set the default delay when grabbing a key with kbd:[Alt+k]\n  * core: add option weechat.look.confirm_upgrade (issue #463)\n  * core: add signal \"signal_sighup\"\n  * core: allow kbd:[Ctrl+c] to exit WeeChat when the passphrase is asked on startup (issue #452)\n  * core: allow pointer as list name in evaluation of hdata (issue #450)\n  * api: add support of evaluated sub-strings and current date/time in function string_eval_expression and command /eval\n  * api: add function string_eval_path_home\n  * alias: add options \"add\", \"addcompletion\" and \"del\" in command /alias, remove command /unalias (issue #458)\n  * irc: add option irc.network.channel_encode (issue #218, issue #482)\n  * irc: add option irc.color.topic_current (issue #475)\n  * irc: evaluate content of server option \"nicks\"\n  * logger: evaluate content of option logger.file.path (issue #388)\n  * script: rename option script.scripts.dir to script.scripts.path, evaluate content of option (issue #388)\n  * relay: display value of HTTP header \"X-Real-IP\" for websocket connections (issue #440)\n  * xfer: evaluate content of options xfer.file.download_path and xfer.file.upload_path (issue #388)\n\nBug fixes::\n\n  * core: flush stdout/stderr after sending text directly on them (fix corrupted data sent to hook_process callback) (issue #442)\n  * core: allow execution of command \"/input return\" on a buffer which is not displayed in a window\n  * core: allow jump from current to previous buffer with default keys kbd:[Alt+j], kbd:[01..99] (issue #466)\n  * core: fix crash if a file descriptor used in hook_fd is too high (> 1024 on Linux/BSD) (issue #465)\n  * core: fix display of invalid UTF-8 chars in bars\n  * core: fix bar item \"scroll\" after /buffer clear (issue #448)\n  * core: fix display of time in bare display when option weechat.look.buffer_time_format is set to empty string (issue #441)\n  * api: add missing function infolist_search_var in script API (issue #484)\n  * api: add missing function hook_completion_get_string in script API (issue #484)\n  * api: fix type of value returned by functions strcasestr, utf8_prev_char, utf8_next_char, utf8_add_offset and util_get_time_string\n  * api: fix type of value returned by function strcasestr\n  * fifo: fix send error on Cygwin when something is received in the pipe (issue #436)\n  * irc: fix update of lag item when the server lag changes\n  * irc: do not allow command /query with a channel name (issue #459)\n  * irc: decode/encode only text in IRC messages and not the headers (bug #29886, issue #218, issue #451)\n  * irc: fix crash with commands /allchan, /allpv and /allserv if the executed command closes buffers (issue #445)\n  * irc: do not open auto-joined channels buffers when option \"-nojoin\" is used in command /connect (even if the option irc.look.buffer_open_before_autojoin is on)\n  * irc: fix errors displayed on WHOX messages received (issue #376)\n  * xfer: fix crash if the DCC file socket number is too high (> 1024 on Linux/BSD) (issue #465)\n  * xfer: fix parsing of DCC chat messages (handle \"\\r\\n\" at the end of messages) (issue #425, issue #426)\n\nDocumentation::\n\n  * replace PREFIX with CMAKE_INSTALL_PREFIX in CMake instructions (issue #354)\n\nBuild::\n\n  * lua: add detection of Lua 5.3\n  * ruby: add detection of Ruby 2.2\n\n[[v1.2]]\n== Version 1.2 (2015-05-10)\n\nNew features::\n\n  * core: add signals \"signal_sigterm\" and \"signal_sigquit\" (issue #114)\n  * core: use environment variable WEECHAT_HOME on startup (issue #391)\n  * core: add options weechat.look.quote_{nick_prefix|nick_suffix|time_format} to customize quoted messages in cursor mode (issue #403)\n  * core: add a welcome message on first WeeChat run (issue #318)\n  * core: add options weechat.look.word_chars_{highlight|input} (issue #55, task #9459)\n  * core: remove WeeChat version from config files (issue #407)\n  * core: display a warning on startup if the locale can not be set (issue #373)\n  * core: allow \"*\" as plugin name in command \"/plugin reload\" to reload all plugins with options\n  * core: add option \"-s\" in command /eval to split expression before evaluating it (no more split by default) (issue #324)\n  * core: add priority in plugins to initialize them in order\n  * api: add support of environment variables in function string_eval_expression and command /eval\n  * api: add support of full color option name in functions color and string_eval_expression and in command /eval\n  * api: add \"_chat_line\" (line pointer) in hashtable of hook_focus\n  * irc: add support of \"account-notify\" capability (issue #11, issue #246)\n  * irc: add support of \"ecdsa-nist256p-challenge\" SASL mechanism (issue #251)\n  * irc: display a warning when the option irc.look.display_away is set to \"channel\"\n  * irc: optimize search of a nick in nicklist (up to 3x faster)\n  * irc: add support of SHA-256 and SHA-512 algorithms in server option \"ssl_fingerprint\" (issue #281)\n  * irc: add option \"-noswitch\" in command /query (issue #394)\n  * irc: format message 008 (RPL_SNOMASK) (issue #144)\n  * irc: remove server \"freenode\" from default config file (issue #309)\n  * javascript: new script plugin for JavaScript\n\nBug fixes::\n\n  * core: add missing completions in command /input\n  * guile: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, hook_command, buffer_string_replace_local_var, command\n  * irc: fix color of new nick in nick changes messages when option irc.look.color_nicks_in_server_messages is off\n  * irc: fix crash when setting an invalid regex with \"/list -re\" during a /list server response (issue #412)\n  * irc: fix display of PART messages on channels with +a (anonymous flag) (issue #396)\n  * irc: remove useless rename of channel buffer on JOIN received with different case (issue #336)\n  * irc: fix completion of commands /allchan and /allpv\n  * lua: fix wrong argument usage in functions nicklist_remove_group, nicklist_remove_nick and nicklist_remove_all (issue #346)\n  * lua: fix value returned in case of error in functions: config_option_reset, config_string, config_string_default, config_color, config_color_default, config_write, config_read, config_reload, hook_modifier_exec, buffer_string_replace_local_var, nicklist_group_set, nicklist_nick_set, command, upgrade_read, upgrade_close\n  * relay: fix up/down keys on relay buffer (issue #335)\n  * relay: remove v4-mapped addresses in /help relay.network.allowed_ips (issue #325)\n  * perl: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, buffer_string_replace_local_var, command\n  * python: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, config_is_set_plugin, buffer_get_string, buffer_string_replace_local_var, nicklist_group_get_string, nicklist_nick_get_string, command, hdata_time\n  * python: fix name of function \"bar_update\" in case of error\n  * python: fix restore of old interpreter when a function is not found in the script\n  * ruby: fix crash on /plugin reload (issue #364)\n  * ruby: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, buffer_string_replace_local_var, command\n  * script: fix state of script plugins when list of scripts has not been downloaded\n  * scripts: reset current script pointer when load of script fails in python/perl/ruby/lua/tcl plugins\n  * scripts: fix return code of function bar_set in python/perl/ruby/lua/tcl/guile plugins\n  * scripts: fix type of value returned by function hdata_time (from string to long integer) in perl/ruby/lua/tcl/guile plugins\n  * tcl: fix value returned in case of error in functions: mkdir_home, mkdir, mkdir_parents, config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, print_date_tags, buffer_string_replace_local_var, command, infolist_new_item, infolist_new_var_integer, infolist_new_var_string, infolist_new_var_pointer, infolist_new_var_time, upgrade_write_object, upgrade_read, upgrade_close\n  * trigger: do not hook anything if the trigger is disabled (issue #405)\n\nDocumentation::\n\n  * add Russian man page\n\n[[v1.1.1]]\n== Version 1.1.1 (2015-01-25)\n\nBug fixes::\n\n  * core: fix crash when a root bar has conditions different from active/inactive/nicklist (issue #317)\n  * irc: don't close channel buffer on second /part when option irc.look.part_closes_buffer is off (issue #313)\n  * irc: fix /join on a channel buffer opened with autojoin but which failed to join\n  * irc: send QUIT to server and no PART for channels when the server buffer is closed (issue #294)\n  * irc: fix order of channel buffers opened when option irc.look.server_buffer is set to \"independent\", irc.look.buffer_open_before_autojoin to \"on\" and irc.look.new_channel_position to \"near_server\" (issue #303)\n  * irc: fix crash in buffer close when server name is the same as a channel name (issue #305)\n\nBuild::\n\n  * core: fix random error when creating symbolic link weechat-curses on make install with CMake (bug #40313)\n\n[[v1.1]]\n== Version 1.1 (2015-01-11)\n\nNew features::\n\n  * core: add option weechat.completion.command_inline (task #12491)\n  * core: add bar item \"mouse_status\", new options weechat.look.item_mouse_status and weechat.color.status_mouse (issue #247)\n  * core: add signals \"mouse_enabled\" and \"mouse_disabled\" (issue #244)\n  * core: add hide of chars in string in evaluation of expressions\n  * core: add arraylists, improve speed of completions (about 50x faster)\n  * core: allow incomplete commands if unambiguous, new option weechat.look.command_incomplete (task #5419)\n  * core: check bar conditions in root bars and on each update of a bar item\n  * core: fully evaluate commands bound to keys in cursor and mouse contexts\n  * core: move bar item \"scroll\" between buffer name and lag in default bar items of status bar\n  * api: add regex replace feature in function string_eval_expression\n  * api: send value returned by command callback in function command, remove WeeChat error after command callback if return code is WEECHAT_RC_ERROR\n  * api: use microseconds instead of milliseconds in functions util_timeval_diff and util_timeval_add\n  * irc: add option \"reorder\" in command /server (issue #229)\n  * irc: open channel buffers before the JOIN is received from server (autojoin and manual joins), new options irc.look.buffer_open_before_{autojoin|join} (issue #216)\n  * irc: add server option \"sasl_fail\" (continue/reconnect/disconnect if SASL fails) (issue #265, task #12204)\n  * irc: add support for color codes 16-99 in IRC messages (issue #228), add infolist \"irc_color_weechat\"\n  * irc: add support of \"extended-join\" capability (issue #143, issue #212)\n  * irc: display own nick changes in server buffer (issue #188)\n  * irc: disable creation of temporary servers by default with command /connect, new option irc.look.temporary_servers\n  * irc: disable SSLv3 by default in server option \"ssl_priorities\" (issue #248)\n  * irc: automatically add current channel in command /samode (issue #241)\n  * irc: add tag \"nick_xxx\" in invite messages\n  * relay: add options \"stop\" and \"restart\" in command /relay\n  * relay: add option relay.network.ssl_priorities (issue #234)\n  * relay: add host in sender for IRC backlog PRIVMSG messages sent to clients\n  * script: add option script.scripts.url_force_https (issue #253)\n  * trigger: evaluate and replace regex groups at same time, new format for regex option in triggers (incompatible with version 1.0) (issue #224)\n  * trigger: add option \"restore\" in command /trigger\n  * trigger: add `${tg_displayed}` in conditions of default trigger \"beep\"\n\nBug fixes::\n\n  * core: fix display bug when scrolling in buffer on a filtered line (issue #240)\n  * core: send mouse code only one time to terminal with command /mouse enable|disable|toggle\n  * core: fix buffer property \"lines_hidden\" when merging buffers or when a line is removed from a buffer (issue #226)\n  * core: display time in bare display only if option weechat.look.buffer_time_format is not an empty string\n  * core: fix translation of message displayed after /upgrade\n  * api: fix truncated process output in hook_process (issue #266)\n  * api: fix crash when reading config options with NULL value (issue #238)\n  * irc: defer the auto-connection to servers with a timer (issue #279, task #13038)\n  * irc: add missing server options \"sasl_timeout\" and \"notify\" in output of /server listfull\n  * irc: use option irc.look.nick_mode_empty to display nick prefix in bar item \"input_prompt\"\n  * irc: remove IRC color codes from buffer title in channels (issue #237)\n  * irc: fix completion of commands /msg, /notice and /query\n  * irc: fix translation of CTCP PING reply (issue #137)\n  * relay: wait for message CAP END before sending join of channels and backlog to the client (issue #223)\n  * relay: send messages \"_buffer_localvar_*\" and \"_buffer_type_changed\" with sync \"buffers\" (issue #191)\n  * relay: don't remove relay from config when the binding fails (issue #225)\n  * relay: use comma separator in option relay.irc.backlog_tags, check the value of option when it is changed with /set\n  * relay: remove \"::ffff:\" from IPv4-mapped IPv6 client address (issue #111)\n  * trigger: fix memory leak when allocating a new trigger with several regex\n  * xfer: fix freeze when accepting DCC (issue #160, issue #174)\n  * xfer: bind to wildcard address when sending (issue #173)\n\nBuild::\n\n  * core: fix compilation of man pages with autotools in source directory\n  * core: fix compilation of plugins with CMake >= 3.1 (issue #287)\n  * lua: add detection of Lua 5.2\n  * python: fix Python detection with Homebrew (issue #217)\n  * tests: fix compilation of tests with clang (issue #275)\n\n[[v1.0.1]]\n== Version 1.0.1 (2014-09-28)\n\nBug fixes::\n\n  * core: fix crash on buffer close when option weechat.look.hotlist_remove is set to \"merged\" (issue #199)\n  * core: fix highlight of IRC action messages when option irc.look.nick_mode is set to \"action\" or \"both\" (issue #206)\n  * core: fix compilation of plugin API functions (macros) when compiler optimizations are enabled (issue #200)\n  * core: fix window/buffer pointers used in command /eval\n  * core: fix modifier \"weechat_print\": discard only one line when several lines are displayed in same message (issue #171)\n  * api: fix bug in function hdata_move when absolute value of count is greater than 1\n  * aspell: fix crash with command \"/aspell addword\" if no word is given (issue #164, issue #165)\n  * irc: fix display of channel exception list (348) with 6 arguments (date missing)\n  * irc: fix type of value stored in hashtable when joining a channel (issue #211)\n  * relay: fix send of signals \"relay_client_xxx\" (issue #214)\n  * script: fix crash on \"/script update\" if a script detail is displayed in buffer (issue #177)\n  * trigger: do not allow any changes on a trigger when it is currently running (issue #189)\n  * trigger: fix regex used in default triggers to hide passwords (\"\\S\" is not supported on *BSD) (issue #172)\n\nTests::\n\n  * unit: fix memory leak in tests launcher\n\nBuild::\n\n  * aspell: fix compilation with Enchant < 1.6.0 (issue #192)\n  * guile: fix compilation with Guile < 2.0.4 (issue #198)\n  * perl: fix detection of Perl >= 5.20 with autotools\n  * tests: fix build of tests when the build directory is outside source tree (issue #178)\n\n[[v1.0]]\n== Version 1.0 (2014-08-15)\n\nNew features::\n\n  * core: display a warning on startup if $TERM does not start with \"screen\" under Screen/Tmux\n  * core: add option weechat.color.status_nicklist_count (issue #109, issue #110)\n  * core: add option \"env\" in command /set (manage environment variables)\n  * core: add bar item \"buffer_short_name\" (task #10882)\n  * core: add option \"send\" in command /input (send text to a buffer)\n  * core: add support of negated tags in filters (with \"!\") (issue #72, issue #74)\n  * core: add hidden buffers, add options hide/unhide in command /buffer\n  * core: add default key kbd:[Alt+-] (toggle filters in current buffer) (issue #17)\n  * core: add non-active merged buffers with activity in hotlist (if another merged buffer is zoomed) (task #12845)\n  * core: add text search in buffers with free content (task #13051)\n  * core: add buffer property \"clear\"\n  * core: add option weechat.look.hotlist_add_conditions, remove option weechat.look.hotlist_add_buffer_if_away\n  * core: add option weechat.look.hotlist_remove (issue #99)\n  * core: add options \"-beep\" and \"-current\" in command /print\n  * core: add bare display mode for easy text selection and click on URLs, new key: kbd:[Alt+l] (`L`), new option \"bare\" in command /window, new options: weechat.look.bare_display_exit_on_input and weechat.look.bare_display_time_format\n  * core: add signals \"key_combo_{default|search|cursor}\"\n  * core: add terabyte unit for size displayed\n  * core: display a warning in case of inconsistency between the options weechat.look.save_{config|layout}_on_exit\n  * core: add option \"-mask\" in command /unset (issue #112)\n  * core: set option weechat.look.buffer_search_where to prefix_message by default\n  * core: mute all buffers by default in command /mute (replace option -all by -core)\n  * api: allow value \"-1\" for property \"hotlist\" in function buffer_set (to remove a buffer from hotlist)\n  * api: add option \"buffer_flush\" in function hook_process_hashtable\n  * api: add support of case insensitive search and search by buffer full name in function buffer_search (bug #34318)\n  * api: add option \"detached\" in function hook_process_hashtable\n  * api: add option \"signal\" in function hook_set to send a signal to the child process\n  * api: add support of nested variables in function string_eval_expression and command /eval (issue #35)\n  * api: add support of escaped strings with format `${esc:xxx}` or `${\\xxx}` in function string_eval_expression and command /eval\n  * api: add functions hashtable_dup, string_replace_regex, string_split_shell, string_convert_escaped_chars\n  * api: add integer return code for functions hook_{signal|hsignal}_send\n  * api: add argument \"flags\" in function hdata_new_list\n  * api: allow wildcard \"*\" inside the mask in function string_match\n  * api: allow negative value for y in function printf_y\n  * alias: add default alias \"msgbuf\" (send text to a buffer)\n  * exec: add exec plugin: new command /exec and file exec.conf\n  * irc: add bar item \"irc_nick_modes\" (issue #71)\n  * irc: add support of message 324 (channel modes) in option irc.look.display_join_message (issue #75)\n  * irc: add option irc.look.join_auto_add_chantype (issue #65)\n  * irc: add tag with host (\"host_xxx\") in IRC messages displayed (task #12018)\n  * irc: add option irc.color.item_nick_modes (issue #47)\n  * irc: add support of \"away-notify\" capability (issue #12)\n  * irc: add command /remove (issue #91)\n  * irc: add command /unquiet (issue #36)\n  * irc: add command /allpv (task #13111)\n  * irc: display locally away status changes in private buffers (in addition to channels) (issue #117)\n  * irc: allow many fingerprints in server option ssl_fingerprint (issue #49)\n  * irc: rename option irc.look.item_channel_modes_hide_key to irc.look.item_channel_modes_hide_args, value is now a string (task #12070, task #12163, issue #48)\n  * irc: add value \"+\" for option irc.look.smart_filter_mode to use modes from server prefixes (this is now the default value) (issue #90)\n  * irc: allow \"$ident\" in option irc.network.ban_mask_default (issue #18)\n  * irc: evaluate content of server options \"username\" and \"realname\"\n  * irc: set option irc.network.autoreconnect_delay_max to 600 by default, increase max value to 604800 seconds (7 days)\n  * irc: set option irc.network.whois_double_nick to \"off\" by default\n  * relay: add messages \"_buffer_cleared\", \"_buffer_hidden\" and \"_buffer_unhidden\"\n  * relay: add info \"relay_client_count\" with optional status name as argument\n  * relay: add signals \"relay_client_xxx\" for client status changes (issue #2)\n  * relay: add option relay.network.clients_purge_delay\n  * rmodifier: remove plugin (replaced by trigger)\n  * script: set option script.scripts.cache_expire to 1440 by default\n  * trigger: add trigger plugin: new command /trigger and file trigger.conf\n\nBug fixes::\n\n  * core: fix zero-length malloc of an hashtable item with type \"buffer\"\n  * core: fix memory leak on /upgrade when file signature in upgrade file is invalid\n  * core: fix memory leak in completion of config options values\n  * core: fix memory leak when removing script files\n  * core: fix result of hash function (in hashtables) on 32-bit systems\n  * core: fix insert of mouse code in input line after a partial key combo (issue #130)\n  * core: check code point value in UTF-8 check function (issue #108)\n  * core: fix socks5 proxy for curl downloads (issue #119)\n  * core: display curl error after a failed download\n  * core: do not display content of passphrase on /secure buffer\n  * core: fix potential memory leak with infolists not freed in plugins (debian #751108)\n  * core: fix color display of last terminal color number + 1 (issue #101)\n  * core: add option \"-buffer\" in command /command (issue #67)\n  * core: fix restoration of core buffer properties after /upgrade\n  * core: fix \"/buffer clear\" with a name (don't clear all merged buffers with same number)\n  * core: fix evaluation of expression with regex: when a comparison char is in the regex and don't evaluate the regex itself (issue #63)\n  * core: close .upgrade files before deleting them after /upgrade\n  * core: fix refresh of bar item \"buffer_zoom\" on buffer switch\n  * core: fix reset of attributes in bars when \"resetcolor\" is used (issue #41)\n  * core: fix alignment of lines in merged buffers when options weechat.look.prefix_align and weechat.look.prefix_buffer_align are set to \"none\" (issue #43)\n  * core: quit WeeChat on signal SIGHUP, remove signal \"signal_sighup\"\n  * core: fix add of filter on macOS when regex for message is empty (filter regex ending with \"\\t\")\n  * core: check validity of buffer pointer when data is sent to a buffer (command/text from user and API function command)\n  * core: fix crash when buffer is closed during execution of multiple commands (issue #27)\n  * core: fix compilation on SmartOS (bug #40981, issue #23)\n  * core: add missing \\0 at the end of stderr buffer in function hook_process\n  * core: fix highlight problem with \"(?-i)\" and upper case letters in option weechat.look.highlight (issue #24)\n  * core: fix detection of terminated process in function hook_process\n  * core: fix \"/window scroll -N\" on a buffer with free content\n  * core: fix recursive calls to function eval_expression\n  * core: save and restore mute state in command /mute (bug #41748)\n  * core: fix memory leak when removing a hdata\n  * core: fix memory leak in evaluation of sub-conditions\n  * core: fix memory leak in function gui_key_add_to_infolist (in case of insufficient memory)\n  * core: fix use of invalid pointer in function gui_bar_window_content_alloc (in case of insufficient memory)\n  * core: fix uninitialized value in function string_decode_base64\n  * core: fix memory leak and use of invalid pointer in split of string (in case of insufficient memory)\n  * core: fix potential NULL pointer in function gui_color_emphasize\n  * core: use same return code and message in all commands when arguments are wrong/missing\n  * core: allow empty arguments for command /print\n  * core: fix freeze/crash in GnuTLS (bug #41576)\n  * api: fix function string_decode_base64\n  * api: fix function string_format_size on 32-bit systems\n  * api: change type of arguments displayed/highlight in hook_print callback from string to integer (in scripts)\n  * alias: change default command for alias /beep to \"/print -beep\"\n  * guile: fix module used after unload of a script\n  * irc: fix memory leak in CTCP answer\n  * irc: fix duplicate sender name in display of wallops (issue #142, issue #145)\n  * irc: fix extract of channel in parser for JOIN/PART messages when there is a colon before the channel name (issue #83)\n  * irc: fix duplicate sender name in display of notice (issue #87)\n  * irc: fix refresh of buffer name in bar items after join/part/kick/kill (issue #86)\n  * irc: display message 936 (censored word) on channel instead of server buffer\n  * irc: make reason optional in command /kill\n  * irc: add alias \"whois\" for target buffer of messages 401/402 (issue #54)\n  * irc: fix truncated read on socket with SSL (bug #41558)\n  * irc: display output of CAP LIST in server buffer\n  * irc: fix colors in message with CTCP reply sent to another user\n  * irc: fix read of MODES server value when in commands /op, /deop, /voice, /devoice, /halfop, /dehalfop\n  * irc: fix parsing of nick in host when \"!\" is not found (bug #41640)\n  * lua: fix interpreter used after unload of a script\n  * perl: fix context used after unload of a script\n  * python: fix read of return value for callbacks returning an integer in Python 2.x (issue #125)\n  * python: fix interpreter used after unload of a script\n  * relay: fix memory leak during handshake on websocket\n  * relay: fix memory leak when receiving commands from client (weechat protocol)\n  * relay: fix crash when an IRC \"MODE\" command is received from client without arguments\n  * relay: fix number of bytes sent/received on 32-bit systems\n  * relay: fix crash when closing relay buffers (issue #57, issue #78)\n  * relay: check pointers received in hdata command to prevent crashes with bad pointers (WeeChat protocol)\n  * relay: remove warning on /reload of relay.conf when ports are defined\n  * relay: fix client disconnection on empty websocket frames received (PONG)\n  * relay: add support of Internet Explorer websocket (issue #73)\n  * relay: fix crash on /upgrade received from a client (weechat protocol)\n  * relay: fix freeze after /upgrade when many disconnected clients still exist\n  * relay: fix NULL pointer when reading buffer lines for irc backlog\n  * ruby: fix crash when trying to load a directory with /ruby load\n  * script: fix display of curl errors\n  * script: fix scroll on script buffer in the detailed view of script (issue #6)\n  * scripts: fix crash when a signal is received with type \"int\" and NULL pointer in signal_data\n  * xfer: fix problem with option xfer.file.auto_accept_nicks when the server name contains dots\n  * xfer: fix freeze/problems when sending empty files with DCC (issue #53)\n  * xfer: fix connection to remote host in DCC receive on macOS (issue #25)\n  * xfer: remove bind on xfer.network.own_ip (issue #5)\n\nBuild::\n\n  * core: fix CMake warning CMP0007 on \"make uninstall\" (bug #41528)\n  * core: use glibtoolize on macOS (autotools) (issue #22)\n  * ruby: add detection of Ruby 2.1\n\nTests::\n\n  * unit: add unit tests using CppUTest (issue #104)\n\n[[v0.4.3]]\n== Version 0.4.3 (2014-02-09)\n\nNew features::\n\n  * core: add signals \"signal_sighup\" and \"signal_sigwinch\" (terminal resized)\n  * core: add command /print, add support of more escaped chars in command \"/input insert\"\n  * core: add option weechat.look.tab_width\n  * core: add completion \"plugins_installed\"\n  * core: add option weechat.look.window_auto_zoom, disable automatic zoom by default when terminal becomes too small for windows\n  * core: use \"+\" separator to make a logical \"and\" between tags in command /filter, option weechat.look.highlight_tags and buffer property \"highlight_tags\"\n  * core: add options weechat.look.buffer_auto_renumber and weechat.look.buffer_position, add option \"renumber\" in command /buffer, add bar item \"buffer_last_number\" (task #12766)\n  * core: add signal \"buffer_cleared\"\n  * core: add buffer property \"day_change\" to hide messages for the day change in specific buffers\n  * core: add option \"libs\" in command /debug\n  * core: add infos \"term_width\" and \"term_height\"\n  * core: add bar item \"buffer_zoom\", add signals \"buffer_{zoomed|unzoomed}\" (patch #8204)\n  * core: add default keys kbd:[Alt+Home] / kbd:[Alt+End] (`meta2-1;3H` / `meta2-1;3F`) and kbd:[Alt+F11] / kbd:[Alt+F12] (`meta2-23;3~` / `meta2-24;3~`) for xterm\n  * core: add support of italic text (requires ncurses >= 5.9 patch 20130831)\n  * core: add options to customize default text search in buffers: weechat.look.buffer_search_{case_sensitive|force_default|regex|where}\n  * core: add support of UTF-8 chars in horizontal/vertical separators (options weechat.look.separator_{horizontal|vertical})\n  * core: add support of logical and/or for argument \"tags\" in function hook_print\n  * core: rename buffer property \"highlight_tags\" to \"highlight_tags_restrict\", new behavior for buffer property \"highlight_tags\" (force highlight on tags), rename option irc.look.highlight_tags to irc.look.highlight_tags_restrict\n  * core: rename options save/reset to store/del in command /layout\n  * core: replace default key kbd:[Ctrl+c], kbd:[r] by kbd:[Ctrl+c], kbd:[v] for reverse video in messages\n  * core: replace default key kbd:[Ctrl+c], kbd:[u] by kbd:[Ctrl+c], kbd:[_] for underlined text in messages\n  * core: rename option weechat.look.set_title to weechat.look.window_title, value is now a string (evaluated)\n  * core: set option weechat.look.paste_bracketed to \"on\" by default\n  * core: use one date format when day changes from day to day+1\n  * api: add function infolist_search_var\n  * api: add stdin options in functions hook_process_hashtable and hook_set to send data on stdin of child process, add function hook_set in script API (task #10847, task #13031)\n  * api: add hdata \"buffer_visited\"\n  * api: add support of infos with format `${info:name,arguments}` in function string_eval_expression and command /eval\n  * api: add support for C++ plugins\n  * alias: add default alias /beep => /print -stderr \\a\n  * irc: add server option \"ssl_fingerprint\" (task #12724)\n  * irc: add option irc.look.smart_filter_mode (task #12499)\n  * irc: add option irc.network.ban_mask_default (bug #26571)\n  * irc: add option irc.network.lag_max\n  * irc: add option irc.look.notice_welcome_tags\n  * irc: add server option \"default_msg_kick\" to customize default kick/kickban message (task #12777)\n  * irc: use MONITOR instead of ISON for /notify when it is available on server (task #11477)\n  * relay: send backlog for irc private buffers\n  * xfer: add support of IPv6 for DCC chat/file (patch #7992)\n  * xfer: add option xfer.file.auto_check_crc32 (patch #7963)\n\nBug fixes::\n\n  * core: fix hotlist problems after apply of a layout (bug #41481)\n  * core: fix crash when creating two bars with same name but different case (bug #41418)\n  * core: fix display of read marker when all buffer lines are unread and that option weechat.look.read_marker_always_show is on\n  * core: fix memory leak in regex matching when evaluating expression\n  * core: fix crash in /eval when config option has a NULL value\n  * core: fix crash with hdata_update on shared strings, add hdata type \"shared_string\" (bug #41104)\n  * core: fix text emphasis with wide chars on screen like Japanese (patch #8253)\n  * core: remove option on /unset of plugin description option (plugins.desc.xxx) (bug #40768)\n  * core: fix random crash when closing a buffer\n  * core: fix crash on /buffer close core.weechat\n  * core: apply color attributes when clearing a window (patch #8236)\n  * core: fix truncated text when pasting several long lines (bug #40210)\n  * core: create .conf file with default options only if the file does not exist (and not on read error with existing file)\n  * core: fix highlight on action messages: skip the nick at beginning to prevent highlight on it (bug #40516)\n  * core: fix bind of keys in cursor/mouse context when key starts with \"@\" (remove the warning about unsafe key)\n  * core: fix truncated prefix when filters are toggled (bug #40204)\n  * api: fix read of arrays in hdata functions hdata_<type> (bug #40354)\n  * aspell: fix detection of nicks with non-alphanumeric chars\n  * guile: disable guile gmp allocator (fix crash on unload of relay plugin) (bug #40628)\n  * irc: clear the GnuTLS session in all cases after SSL connection error\n  * irc: do not display names by default when joining a channel (task #13045)\n  * irc: display PONG answer when resulting from manual /ping command\n  * irc: fix time parsed in tag of messages on Cygwin\n  * irc: use statusmsg from message 005 to check prefix char in status notices/messages\n  * irc: remove display of channel in channel notices, display \"PvNotice\" for channel welcome notices\n  * irc: fix ignore on a host without nick\n  * irc: use color code 0x1F (`ctrl-_`) for underlined text in input line (same code as messages) (bug #40756)\n  * irc: use color code 0x16 (`ctrl-v`) for reverse video in messages\n  * irc: use option irc.network.colors_send instead of irc.network.colors_receive when displaying messages sent by commands /away, /me, /msg, /notice, /query\n  * irc: fix memory leak when checking the value of ssl_priorities option in servers\n  * irc: fix memory leak when a channel is deleted\n  * irc: fix groups in channel nicklist when reconnecting to a server that supports more nick prefixes than the previously connected server\n  * irc: fix auto-switch to channel buffer when doing /join channel (without \"#\")\n  * logger: fix memory leaks in backlog\n  * logger: replace backslashs in name by logger replacement char under Cygwin (bug #41207)\n  * lua: fix crash on calls to callbacks during load of script\n  * python: fix load of scripts with Python >= 3.3\n  * relay: fix memory leak on unload of relay plugin\n  * ruby: fix ruby init with Ruby >= 2.0 (bug #41115)\n  * scripts: fix script interpreter used after register during load of script in python/perl/ruby/lua/guile plugins (bug #41345)\n  * xfer: use same infolist for hook and signals (patch #7974)\n\nDocumentation::\n\n  * add French developer's guide and relay protocol\n  * add Japanese plugin API reference and developer's guide\n  * add Polish man page and user's guide\n\nBuild::\n\n  * core: fix installation of weechat-plugin.h with autotools (patch #8305)\n  * core: fix compilation on Android (bug #41420, patch #8301, bug #41434)\n  * lua: fix detection of Lua 5.2 in autotools (patch #8270)\n  * ruby: add detection and fix compilation with Ruby 2.0 (patch #8209)\n\n[[v0.4.2]]\n== Version 0.4.2 (2013-10-06)\n\nNew features::\n\n  * core: display day change message dynamically (do not store it as a line in buffer), split option weechat.look.day_change_time_format into two options weechat.look.day_change_message_{1date|2dates}, new option weechat.color.chat_day_change (task #12775)\n  * core: add syntax \"@buffer:item\" in bar items to force the buffer used when displaying the bar item (task #12717)\n  * core: add search of regular expression in buffer, don't reset search type on a new search, select where to search (messages/prefixes), add keys in search context: kbd:[Alt+c] (case (in)sensitive search), kbd:[Tab] (search in messages/prefixes)\n  * core: add text emphasis in messages when searching text in buffer, new options: weechat.look.emphasized_attributes, weechat.color.emphasized, weechat.color.emphasized_bg\n  * core: add secured data (encryption of passwords or private data): add new command /secure and new file sec.conf (task #7395)\n  * core: rename binary and man page from \"weechat-curses\" to \"weechat\" (task #11027)\n  * core: add option \"-o\" in command /color\n  * core: add option \"scroll_beyond_end\" for command /window (task #6745)\n  * core: add options weechat.look.hotlist_prefix and weechat.look.hotlist_suffix (task #12730)\n  * core: add option weechat.look.key_bind_safe\n  * core: add option weechat.network.proxy_curl (task #12651)\n  * core: add \"proxy\" infolist and hdata\n  * core: add infolist \"layout\" and hdata \"layout\", \"layout_buffer\" and \"layout_window\"\n  * core: reduce memory used by using shared strings for nicklist and lines in buffers\n  * core: change color format for options weechat.look.buffer_time_format and weechat.look.prefix_{action|error|join|network|quit} from `${xxx}` to `${color:xxx}`\n  * core: optimize the removal of lines in buffers (a lot faster to clear/close buffers with lot of lines)\n  * core: set options weechat.look.color_inactive_{buffer|window} to \"on\" by default\n  * api: return hashtable item pointer in functions hashtable_set and hashtable_set_with_size\n  * api: add \"callback_free_key\" in hashtable\n  * api: add support of colors with format `${color:xxx}` in function string_eval_expression and command /eval\n  * api: add argument \"options\" in function string_eval_expression, add option \"-c\" in command /eval (to evaluate a condition)\n  * api: add new function strlen_screen\n  * aspell: rename option aspell.look.color to aspell.color.misspelled, add option aspell.color.suggestions\n  * aspell: add support of enchant library (patch #6858)\n  * irc: add option irc.look.notice_welcome_redirect to automatically redirect channel welcome notices to the channel buffer\n  * irc: add support of wildcards in commands (de)op/halfop/voice, split IRC message sent if number of nicks is greater than server MODES (from message 005) (task #9221)\n  * irc: add option irc.look.pv_tags\n  * irc: add support of special variables $nick/$channel/$server in commands /allchan and /allserv\n  * irc: add option irc.look.nick_color_hash: hash algorithm to find nick color (patch #8062)\n  * logger: add option \"flush\" in command /logger\n  * plugins: remove the demo plugin\n  * relay: add command \"ping\" in weechat protocol (task #12689)\n  * rmodifier: add option \"missing\" in command /rmodifier\n  * script: add info about things defined by script (like commands, options, ...) in the detailed view of script (/script show)\n  * scripts: add hdata with script callback\n  * xfer: add option xfer.look.pv_tags\n\nBug fixes::\n\n  * core: clear whole line before displaying content instead of clearing after the end of content (bug #40115)\n  * core: fix time displayed in status bar (it was one second late) (bug #40097)\n  * core: fix memory leak on unhook of a print hook (if using tags)\n  * core: fix computation of columns in output of /help (take care about size of time/buffer/prefix)\n  * core: fix random crash on \"/buffer close\" with a buffer number (or a range of buffers)\n  * core: fix priority of logical operators in evaluation of expression (AND takes precedence over the OR) and first evaluate sub-expressions between parentheses\n  * core: remove gap after read marker line when there is no bar on the right (bug #39548)\n  * core: use \"/dev/null\" for stdin in hook_process instead of closing stdin (bug #39538)\n  * core: fix char displayed at the intersection of three windows (bug #39331)\n  * core: fix crash in evaluation of expression when reading a string in hdata with a NULL value (bug #39419)\n  * core: fix display bugs with some UTF-8 chars that truncates messages displayed (for example U+26C4) (bug #39201)\n  * core: remove extra space after empty prefix (when prefix for action, error, join, network or quit is set to empty string) (bug #39218)\n  * core: fix random crash on mouse actions (bug #39094)\n  * core: fix line alignment when option weechat.look.buffer_time_format is set to empty string\n  * api: change type of hashtable key hash to unsigned long\n  * api: use pointer for infolist \"hook\" to return only one hook\n  * aspell: fix detection of word start/end when there are apostrophes or minus chars before/after word\n  * irc: fix reconnection to server using IPv6 (bug #38819, bug #40166)\n  * irc: replace default prefix modes \"qaohvu\" by the standard ones \"ov\" when PREFIX is not sent by server (bug #39802)\n  * irc: use 6697 as default port for SSL servers created with URL \"ircs://\" (bug #39621)\n  * irc: display number of ops/halfops/voices on channel join only for supported modes on server (bug #39582)\n  * irc: fix self nick color in server messages after nick is changed with /nick (bug #39415)\n  * irc: fix error message on /invite without arguments (bug #39272)\n  * irc: fix multiple nicks in command /query (separated by commas): open one buffer per nick\n  * lua: fix interpreter used in API functions (bug #39470)\n  * relay: fix decoding of websocket frames when there are multiple frames in a single message received (only the first one was decoded)\n  * relay: fix binding to an IP address (bug #39119)\n\nDocumentation::\n\n  * update man page and add translations (in French, German, Italian, and Japanese)\n\nBuild::\n\n  * core: add CA_FILE option in CMake and configure to setup default value of option weechat.network.gnutls_ca_file (default is \"/etc/ssl/certs/ca-certificates.crt\") (task #12725)\n  * core: disable build of doc by default, add CMake option ENABLE_MAN to compile man page (off by default)\n  * xfer: fix compilation on OpenBSD (bug #39071)\n\n[[v0.4.1]]\n== Version 0.4.1 (2013-05-20)\n\nNew features::\n\n  * core: make nick prefix/suffix dynamic (not stored in the line): move options irc.look.nick_{prefix|suffix} to weechat.look.nick_{prefix|suffix} and options irc.color.nick_{prefix|suffix} to weechat.color.chat_nick_{prefix|suffix}, add new options weechat.look.prefix_align_more_after, weechat.look.prefix_buffer_align_more_after, logger.file.nick_{prefix|suffix} (bug #37531)\n  * core: add support of multiple layouts (task #11274)\n  * core: add signals nicklist_{group|nick}_removing and hsignals nicklist_{group|nick}_{added|removing|changed}\n  * core: add count for groups, nicks, and total in nicklist\n  * core: add option \"dirs\" in command /debug\n  * core: add signal \"window_opened\" (task #12464)\n  * core: allow read of array in hdata without using index\n  * api: add new function hdata_search\n  * api: add property \"completion_freeze\" for function buffer_set: do not stop completion when command line is updated\n  * aspell: add completion \"aspell_dicts\" (list of aspell installed dictionaries)\n  * aspell: add info \"aspell_dict\" (dictionaries used on a buffer)\n  * aspell: optimization on spellers to improve speed (save state by buffer)\n  * irc: add support of \"dh-aes\" SASL mechanism (patch #8020)\n  * irc: add support of UHNAMES (capability \"userhost-in-names\") (task #9353)\n  * irc: add tag \"irc_nick_back\" for messages displayed in private buffer when a nick is back on server (task #12576)\n  * irc: add option irc.look.display_join_message (task #10895)\n  * irc: add option irc.look.pv_buffer: automatically merge private buffers (optionally by server) (task #11924)\n  * irc: hide passwords in commands or messages sent to nickserv (/msg nickserv) with new modifiers \"irc_command_auth\" and \"irc_message_auth\", remove option irc.look.hide_nickserv_pwd, add option irc.look.nicks_hide_password (bug #38346)\n  * irc: unmask smart filtered join if nick speaks in channel some minutes after the join, new option irc.look.smart_filter_join_unmask (task #12405)\n  * irc: rename option irc.network.lag_disconnect to irc.network.lag_reconnect, value is now a number of seconds\n  * relay: add message \"_nicklist_diff\" (differences between old and current nicklist)\n  * relay: add support of multiple servers on same port for irc protocol (the client must send the server in the \"PASS\" command)\n  * relay: add WebSocket server support (RFC 6455) for irc and weechat protocols, new option relay.network.websocket_allowed_origins\n  * relay: add options \"buffers\" and \"upgrade\" in commands sync/desync (weechat protocol)\n  * rmodifier: rename default rmodifier \"nickserv\" to \"command_auth\" (with new modifier \"irc_command_auth\"), add default rmodifier \"message_auth\" (modifier \"irc_message_auth\")\n  * script: add option script.scripts.autoload, add options \"autoload\", \"noautoload\" and \"toggleautoload\" for command /script, add action \"A\" (kbd:[Alt+a]) on script buffer (toggle autoload) (task #12393)\n  * xfer: add option xfer.file.auto_accept_nicks (patch #7962)\n\nBug fixes::\n\n  * core: fix display of long lines without time (message beginning with two tabs)\n  * core: reset scroll in window before zooming on a merged buffer (bug #38207)\n  * core: fix refresh of item \"completion\": clear it after any action that is changing content of command line and after switch of buffer (bug #38214)\n  * core: fix structures before buffer data when a buffer is closed\n  * core: fix refresh of line after changes with hdata_update (update flag \"displayed\" according to filters)\n  * core: fix hidden lines for messages without date when option weechat.history.max_buffer_lines_minutes is set (bug #38197)\n  * core: use default hash/comparison callback for keys of type integer/pointer/time in hashtable\n  * api: do not display a warning by default when loading a script with a license different from GPL\n  * api: fix connection to servers with hook_connect on macOS (bug #38496)\n  * api: fix bug in function string_match when mask begins and ends with \"*\"\n  * api: allow hashtable with keys that are not strings in function hashtable_add_to_infolist\n  * api: fix function string_mask_to_regex: escape all special chars used in regex (bug #38398)\n  * guile: fix crash in function hdata_move\n  * guile: fix arguments given to callbacks (separate arguments instead of one list with arguments inside), Guile >= 2.0 is now required (bug #38350)\n  * guile: fix crash on calls to callbacks during load of script (bug #38343)\n  * irc: fix name of server buffer after /server rename (set name \"server.name\" instead of \"name\")\n  * irc: fix uncontrolled format string when sending unknown irc commands (if option irc.network.send_unknown_commands is on)\n  * irc: fix uncontrolled format string when sending ison command (for nicks monitored by /notify)\n  * irc: fix refresh of nick in input bar when joining a new channel with op status (bug #38969)\n  * irc: fix display of CTCP messages that contain bold attribute (bug #38895)\n  * irc: fix duplicate nick completion when someone rejoins the channel with same nick but a different case (bug #38841)\n  * irc: fix crash on command \"/allchan /close\"\n  * irc: fix default completion (like nicks) in commands /msg, /notice, /query and /topic\n  * irc: fix prefix color for nick when the prefix is not in irc.color.nick_prefixes: use default color (key \"*\")\n  * irc: fix display of malformed CTCP (without closing char) (bug #38347)\n  * irc: fix memory leak in purge of hashtables with joins (it was done only for the first server in the list)\n  * irc: add color in output of /names when result is on server buffer (channel not joined) (bug #38070)\n  * lua: remove use of functions for API constants\n  * lua: fix crash on stack overflow: call lua_pop for values returned by lua functions (bug #38510)\n  * perl: simplify code to load scripts\n  * python: fix crash when loading scripts with Python 3.x (patch #8044)\n  * relay: fix uncontrolled format string in redirection of irc commands\n  * relay: rename compression \"gzip\" to \"zlib\" (compression is zlib, not gzip)\n  * relay: fix commands sync/desync in weechat protocol (bug #38215)\n  * ruby: fix crash in function hdata_move\n  * ruby: fix crash with Ruby 2.0: use one array for the last 6 arguments of function config_new_option (bug #31050)\n  * script: create \"script\" directory on each action, just in case it has been removed (bug #38472)\n  * scripts: create directories (language and language/autoload) on each action (install/remove/autoload), just in case they have been removed (bug #38473)\n  * scripts: do not allow empty script name in function register\n  * xfer: fix freeze of DCC file received: use non-blocking socket after connection to sender and ensure the ACK is properly sent (bug #38340)\n\nBuild::\n\n  * core: install icon file (patch #7972)\n  * core: fix detection of iconv with CMake on macOS (bug #38321)\n  * guile: fix compilation with Guile 2.0\n  * python: fix detection of Python on Ubuntu Raring\n  * script: fix compilation on GNU/Hurd (patch #7977)\n\n[[v0.4.0]]\n== Version 0.4.0 (2013-01-20)\n\nNew features::\n\n  * core: add buffer pointer in arguments for signals \"input_search\", \"input_text_changed\" and \"input_text_cursor_moved\"\n  * core: add option \"diff\" in command /set (list options with changed value)\n  * core: add color support in options weechat.look.prefix_{action|error|join|network|quit} (task #9555)\n  * core: display default values for changed config options in output of /set\n  * core: add command /eval, use expression in conditions for bars\n  * core: add option \"-quit\" in command /upgrade (save session and quit without restarting WeeChat, for delayed restoration)\n  * core: add incomplete mouse events \"event-down\" and \"event-drag\" (task #11840)\n  * api: allow return code WEECHAT_RC_OK_EAT in callbacks of hook_signal and hook_hsignal (stop sending the signal immediately)\n  * api: allow creation of structure with hdata_update (allowed for hdata \"history\")\n  * api: use hashtable \"options\" for command arguments in function hook_process_hashtable (optional, default is a split of string with command)\n  * api: add new function string_eval_expression\n  * api: connect with IPv6 by default in hook_connect (with fallback to IPv4), shuffle list of hosts for a same address, add argument \"retry\" for hook_connect, move \"sock\" from hook_connect arguments to callback of hook_connect (task #11205)\n  * aspell: add signal \"aspell_suggest\" (sent when new suggestions are displayed)\n  * aspell: add bar items \"aspell_dict\" (dictionary used on current buffer) and \"aspell_suggest\" (suggestions for misspelled word at cursor), add option aspell.check.suggestions (task #12061)\n  * irc: add tags \"irc_nick1_xxx\" and \"irc_nick2_yyy\" in message displayed for command \"NICK\"\n  * irc: return git version in CTCP VERSION and FINGER by default, add \"$git\" and \"$versiongit\" in format of CTCP replies\n  * irc: read local variable \"autorejoin\" in buffer to override server option \"autorejoin\" (task #12256)\n  * irc: add option \"-auto\" in command /connect (task #9340)\n  * irc: add support of \"server-time\" capability (task #12255)\n  * irc: add support of tags in messages\n  * irc: add command /quiet, fix display of messages 728/729 (quiet list, end of quiet list) (task #12278)\n  * irc: add option irc.network.alternate_nick to disable dynamic nick generation when all nicks are already in use on server (task #12281)\n  * irc: add option irc.network.whois_double_nick to double nick in command /whois\n  * irc: add option \"-noswitch\" in command /join (task #12275)\n  * perl: display script filename in error messages\n  * relay: add backlog and server capability \"server-time\" for irc protocol, add new options relay.irc.backlog_max_minutes, relay.irc.backlog_max_number, relay.irc.backlog_since_last_disconnect, relay.irc.backlog_tags, relay.irc.backlog_time_format (task #12076)\n  * relay: add support of IPv6, new option relay.network.ipv6, add support of \"ipv4.\" and/or \"ipv6.\" before protocol name, to force IPv4/IPv6 (task #12270)\n  * xfer: display remote IP address for DCC chat/file (task #12289)\n\nBug fixes::\n\n  * core: fix infinite loop when a regex gives an empty match (bug #38112)\n  * core: fix click in item \"buffer_nicklist\" when nicklist is a root bar (bug #38080)\n  * core: fix line returned when clicking on a bar (according to position and filling) (bug #38069)\n  * core: fix refresh of bars when applying layout (bug #37944, bug #37952)\n  * core: fix scroll to bottom of window (default key: kbd:[Alt+End]) when line displayed is bigger than chat area\n  * core: fix scroll in buffer after enabling/disabling some filters (if scroll is on a hidden line) (bug #37885)\n  * core: fix memory leak in case of error when building content of bar item for display\n  * core: fix detection of command in input: a single command char is considered as a command (API function string_input_for_buffer)\n  * core: search for a fallback template when a no template is matching command arguments\n  * core: fix refresh of windows after split (fix bug with horizontal separator between windows) (bug #37874)\n  * core: fix stuck mouse (bug #36533)\n  * core: fix default mouse buttons actions for script buffer (focus the window before executing action)\n  * core: fix scroll of one page down when weechat.look.scroll_page_percent is less than 100 (bug #37875)\n  * core: disable paste detection and confirmation if bar item \"input_paste\" is not used in a visible bar (task #12327)\n  * core: use high priority (50000) for commands /command and /input so that an alias will not take precedence over these commands (bug #36353)\n  * core: execute command with higher priority when many commands with same name are found with different priorities\n  * core: fix display of combining chars (bug #37775)\n  * core: fix display of zoomed/merged buffer (with number >= 2) after switching to it (bug #37593)\n  * core: fix display problem when option weechat.look.prefix_same_nick is set (problem with nick displayed in first line of screen) (bug #37556)\n  * core: fix wrapping of words with wide chars (the break was made before the correct position)\n  * api: do not call shell to execute command in hook_process (fix security problem when a plugin/script gives untrusted command) (bug #37764)\n  * alias: give higher priority to aliases (2000) so that they take precedence over an existing command\n  * aspell: ignore self and remote nicks in private buffers\n  * aspell: fix creation of spellers when number of dictionaries is different between two buffers\n  * guile: fix bad conversion of shared strings (replace calls to scm_i_string_chars by scm_to_locale_string) (bug #38067)\n  * irc: fix display of actions (/me) when they are received from a relay client (in channel and private buffers) (bug #38027)\n  * irc: fix memory leak when updating modes of channel\n  * irc: fix crash on /upgrade (free channels before server data when a server is destroyed) (bug #37736)\n  * irc: fix crash when decoding IRC colors in strings (bug #37704)\n  * irc: fix refresh of bar item \"away\" after command /away or /disconnect\n  * irc: send whois on self nick when /whois is done without argument on a channel (task #12273)\n  * irc: remove local variable \"away\" in server/channels buffers after server disconnection (bug #37582)\n  * irc: fix crash when message 352 has too few arguments (bug #37513)\n  * irc: remove unneeded server disconnect when server buffer is closed and server is already disconnected\n  * perl: fix calls to callbacks during load of script when multiplicity is disabled (bug #38044)\n  * relay: fix duplicated messages sent to irc clients (when messages are redirected) (bug #37870)\n  * relay: fix memory leak when adding hdata to a message (weechat protocol)\n  * relay: fix crash after /upgrade when a client is connected\n  * relay: add missing \"ssl.\" in output of /relay listrelay\n  * script: fix scroll with mouse when window with script buffer is not the current window (do not force a switch to script buffer in current window)\n  * xfer: fix memory leak when refreshing xfer buffer\n  * xfer: add missing tags in DCC chat messages: nick_xxx, prefix_nick_ccc, logN\n  * xfer: limit bytes received to file size (for DCC file received), fix crash when displaying a xfer file with pos greater than size\n\nBuild::\n\n  * core: add git version in build, display it in \"weechat-curses --help\" and /version\n  * core: stop CMake if gcrypt lib is not found (bug #37671)\n  * guile: fix detection of Guile in configure\n  * script: fix compilation on macOS\n\n[[v0.3.9.2]]\n== Version 0.3.9.2 (2012-11-18)\n\nBug fixes::\n\n  * core: do not call shell to execute command in hook_process (fix security problem when a plugin/script gives untrusted command) (bug #37764, CVE-2012-5534)\n\n[[v0.3.9.1]]\n== Version 0.3.9.1 (2012-11-09)\n\nBug fixes::\n\n  * irc: fix crash when decoding IRC colors in strings (bug #37704, CVE-2012-5854)\n\n[[v0.3.9]]\n== Version 0.3.9 (2012-09-29)\n\nNew features::\n\n  * core: add signals for plugins loaded/unloaded\n  * core: add default key kbd:[Alt+x] (zoom on merged buffer) (task #11029)\n  * core: add mouse bindings kbd:[Ctrl] + wheel up/down to scroll horizontally buffers with free content\n  * core: add option weechat.startup.sys_rlimit to set system resource limits for WeeChat process\n  * core: add option \"swap\" in command /buffer (task #11373)\n  * core: add hdata \"hotlist\"\n  * core: add support of arrays in hdata variables\n  * core: add command line option \"-r\" (or \"--run-command\") to run command(s) after startup of WeeChat\n  * core: add function hook_set in plugin API, add \"subplugin\" in hooks (set by script plugins), display subplugin in /help on commands (task #12049)\n  * core: add option weechat.look.jump_smart_back_to_buffer (jump back to initial buffer after reaching end of hotlist, on by default, which is old behavior)\n  * core: add default key kbd:[Alt+s] (toggle aspell)\n  * core: add callback \"nickcmp\" in buffers\n  * core: add horizontal separator between windows, new options weechat.look.window_separator_{horizontal|vertical}\n  * core: add options weechat.look.color_nick_offline and weechat.color.chat_nick_offline{_highlight|_highlight_bg} to use different color for offline nicks in prefix (task #11109)\n  * api: allow update for some variables of hdata, add new functions hdata_update and hdata_set\n  * api: add info \"locale\" for info_get (locale used to translate messages)\n  * api: add new function util_version_number\n  * aspell: add option aspell.check.enabled, add options enable/disable/toggle for command /aspell (rename options enable/disable/dictlist to setdict/deldict/listdict), display aspell status with /aspell (task #11988)\n  * irc: generate alternate nicks dynamically when all nicks are already in use (task #12209)\n  * irc: add bar item \"buffer_modes\", remove option irc.look.item_channel_modes (task #12022)\n  * irc: add option irc.look.ctcp_time_format to customize reply to CTCP TIME (task #12150)\n  * irc: move options from core to irc plugin: weechat.look.nickmode to irc.look.nick_mode (new type: integer with values: none/prefix/action/both) and weechat.look.nickmode_empty to irc.look.nick_mode_empty\n  * logger: add tags in backlog lines displayed when opening buffer\n  * logger: add messages \"Day changed to\" in backlog (task #12187)\n  * relay: add support of SSL (for irc and weechat protocols), new option relay.network.ssl_cert_key (task #12044)\n  * relay: add option relay.color.client\n  * relay: add object type \"arr\" (array) in WeeChat protocol\n  * script: new plugin \"script\" (script manager, replacing scripts weeget.py and script.pl)\n  * scripts: add signals for scripts loaded/unloaded/installed/removed\n  * scripts: add hdata with list of scripts for each language\n\nBug fixes::\n\n  * core: fix display bug when end of a line is displayed on top of chat (last line truncated and MORE(0) in status bar) (bug #37203)\n  * core: fix IP address returned by hook_connect (return IP really used, not first IP for hostname)\n  * core: display spaces at the end of messages in chat area (bug #37024)\n  * core: fix infinite loop in display when chat area has width of 1 with a bar displayed on the right (nicklist by default) (bug #37089)\n  * core: fix display of \"bar more down\" char when text is truncated by size_max in bars with vertical filling (bug #37054)\n  * core: fix color of long lines (displayed on more than one line on screen) under FreeBSD (bug #36999)\n  * core: return error string to callback of hook_connect if getaddrinfo fails in child process\n  * core: scroll to bottom of window after reaching first or last highlight with keys kbd:[Alt+p] / kbd:[Alt+n]\n  * core: fix refresh of bar items when switching window\n  * core: fix refresh of bar items \"buffer_filter\" and \"scroll\" in root bars (bug #36816)\n  * core: allow again names beginning with \"#\" for bars, proxies and filters\n  * core: escape special chars (`#[\\`) in configuration files for name of options (bug #36584)\n  * aspell: add missing dictionaries (ast/grc/hus/kn/ky)\n  * charset: do not allow \"UTF-8\" in charset decoding options (useless because UTF-8 is the internal WeeChat charset)\n  * fifo: ignore read failing with error EAGAIN (bug #37019)\n  * guile: fix crash when unloading a script without pointer to interpreter\n  * irc: fix rejoin of channels with a key, ignore value \"*\" sent by server for key (bug #24131)\n  * irc: fix SASL mechanism \"external\" (bug #37274)\n  * irc: fix parsing of message 346 when no nick/time are given (bug #37266)\n  * irc: switch to next address after a timeout when connecting to server (bug #37216)\n  * irc: fix bug when changing server option \"addresses\" with less addresses (bug #37215)\n  * irc: add network prefix in irc (dis)connection messages\n  * irc: fix split of received IRC message: keep spaces at the end of message\n  * irc: fix bug with prefix chars which are in chanmodes with a type different from \"B\" (bug #36996)\n  * irc: fix format of message \"USER\" (according to RFC 2812) (bug #36825)\n  * irc: fix parsing of user modes (ignore everything after first space) (bug #36756, bug #31572)\n  * irc: fix freeze when reading on socket with SSL enabled (use non-blocking sockets) (bug #35097)\n  * irc: allow again names beginning with \"#\" for servers\n  * lua: fix crash when unloading a script without pointer to interpreter\n  * python: fix crash when unloading a script without pointer to interpreter\n  * relay: fix freeze when writing on relay socket (use non-blocking sockets in relay for irc and weechat protocols) (bug #36655)\n  * scripts: fix deletion of configuration files when script is unloaded (bug #36977)\n  * scripts: fix function unhook_all: delete only callbacks of hooks and add missing call to unhook\n  * scripts: ignore call to register (with a warning) if script is already registered\n  * xfer: fix DCC transfer error (bug #37432)\n\nDocumentation::\n\n  * add Japanese user's guide (patch #7827), scripting guide and tester's guide\n\nBuild::\n\n  * core: move the set of CMake policy CMP0003 in directory src (so it applies to all plugins) (bug #37311)\n  * core: fix names of cache variables in configure.in (bug #36971)\n  * core: add CMake option \"MANDIR\" (bug #36776)\n  * guile: fix path of Guile include dirs in CMake build (patch #7790)\n  * lua: add support of Lua 5.2\n  * python: fix detection of Python (first try \"python2.x\" and then \"python\") (bug #36835)\n  * ruby: add detection of Ruby 1.9.3\n\n[[v0.3.8]]\n== Version 0.3.8 (2012-06-03)\n\nNew features::\n\n  * core: add option weechat.look.prefix_same_nick (hide or change prefix on messages whose nick is the same as previous message) (task #11965)\n  * core: convert tabs to spaces in text pasted (bug #25028)\n  * core: add a connection timeout for child process in hook_connect (bug #35966)\n  * core: add support of terminal \"bracketed paste mode\", new options weechat.look.paste_bracketed and weechat.look.paste_bracketed_timer_delay (task #11316)\n  * core: support lines of 16 Kb long in configuration files (instead of 1 Kb)\n  * core: convert options weechat.look.prefix_align_more and weechat.look.prefix_buffer_align_more from boolean to string (task #11197)\n  * core: follow symbolic links when writing configuration files (.conf) (task #11779)\n  * api: add list \"gui_buffer_last_displayed\" in hdata \"buffer\"\n  * irc: add option \"fakerecv\" in command /server to simulate a received IRC message (not documented, for debug only)\n  * irc: add option \"-pending\" in command /disconnect (cancel auto-reconnection on servers currently reconnecting) (task #11985)\n  * irc: add signals and tags in messages for irc notify (task #11887)\n  * irc: add support of \"external\" SASL mechanism (task #11864)\n  * irc: allow more than one nick in command /invite\n  * logger: add colors for backlog lines and end of backlog, new options: logger.color.backlog_line and logger.color.backlog_end (task #11966)\n  * relay: add signals \"upgrade\" and \"upgrade_ended\" in WeeChat protocol\n  * relay: add \"date_printed\" and \"highlight\" in signal \"_buffer_line_added\" (WeeChat protocol)\n  * rmodifier: add default rmodifier \"quote_pass\" to hide password in command \"/quote pass\" (bug #36250)\n  * rmodifier: add default rmodifier \"server\" to hide passwords in commands /server and /connect (task #11993)\n  * rmodifier: add option \"release\" in default rmodifier \"nickserv\" (used to hide passwords in command \"/msg nickserv\") (bug #35705)\n\nBug fixes::\n\n  * core: fix crash in focus hook for nicklist (bug #36271)\n  * core: fix truncated configuration files (zero-length) after system crash (bug #36383)\n  * core: fix display bugs and crashes with small windows (bug #36107)\n  * core: fix display bug with prefix when length is greater than max and prefix is ending with a wide char (bug #36032)\n  * core: fix lost scroll when switching to a buffer with a pending search\n  * core: fix display of wide chars on last column of chat area (patch #7733)\n  * api: display warning in scripts when invalid pointers (malformed strings) are given to plugin API functions (warning displayed if debug for plugin is >= 1)\n  * scripts: fix type of argument \"rc\" in callback of hook_process (from string to integer)\n  * guile: fix crash on ARM when loading guile plugin (bug #36479)\n  * guile: add missing function hook_process_hashtable in API\n  * irc: update channel modes by using chanmodes from message 005 (do not send extra command \"MODE\" to server), fix parsing of modes (bug #36215)\n  * irc: hide everything after \"identify\" or \"register\" in messages to nickserv when option irc.look.hide_nickserv_pwd is on (bug #36362)\n  * irc: set user modes only if target nick is self nick in message 221 (patch #7754)\n  * irc: force the clear of nicklist when joining a channel (nicklist was not sync after znc reconnection) (bug #36008)\n  * irc: do not send command \"MODE #channel\" on manual /names (do it only when names are received on join of channel) (bug #35930)\n  * irc: do not allow the creation of two servers with same name but different case (fix error when writing file irc.conf) (bug #35840)\n  * irc: update away flag for nicks on manual /who\n  * irc: display privmsg messages to \"@#channel\" and \"+#channel\" in channel buffer (bug #35331)\n  * irc: fix redirection of message when message is queued for sending on server\n  * irc: check notify immediately when adding a nick to notify list, improve first notify message for a nick (bug #35731)\n  * irc: fix display of color in hostname (join/part/quit messages)\n  * irc: compute hash to find nick color for nick in server message when nick is not in nicklist\n  * irc: close server buffer when server is deleted\n  * irc: add search for lower case nicks in option irc.look.nick_color_force\n  * logger: fix charset of lines displayed in backlog when terminal charset is different from UTF-8 (bug #36379)\n  * perl: fix crash on quit on macOS\n  * relay: keep spaces in beginning of \"input\" received from client (WeeChat protocol)\n  * relay: fix crash on /upgrade when client is connected using WeeChat protocol\n  * relay: redirect some irc messages from clients to hide output (messages: mode, ison, list, names, topic, who, whois, whowas, time, userhost) (bug #33516)\n  * tcl: add missing function hdata_char in API\n  * tcl: fix pointer sent to function hook_signal_send when type of data is a pointer\n\nDocumentation::\n\n  * add Japanese FAQ (patch #7781)\n\nBuild::\n\n  * perl: fix compilation on macOS (bug #30701)\n\n[[v0.3.7]]\n== Version 0.3.7 (2012-02-26)\n\nNew features::\n\n  * core: add support of flags in regular expressions and highlight options\n  * core: add type \"hashtable\" for hdata\n  * core: add signals \"buffer_line_added\" and \"window_switch\"\n  * core: add default keys kbd:[Ctrl+Left] / kbd:[Ctrl+Right] (`meta2-1;5D` / `meta2-1;5C`) for gnome-terminal\n  * core: add option \"hooks\" in command /debug\n  * core: add option weechat.look.scroll_bottom_after_switch (if enabled, restore old behavior before fix of bug #25555 in version 0.3.5)\n  * core: add new option weechat.completion.base_word_until_cursor: allow completion in middle of words (enabled by default) (task #9771)\n  * core: add option \"jump_last_buffer_displayed\" in command /input (key: kbd:[Alt+/]) (task #11553)\n  * core: add option weechat.history.max_buffer_lines_minutes: maximum number of minutes in history per buffer (task #10900), rename option weechat.history.max_lines to weechat.history.max_buffer_lines_number\n  * core: add optional arguments for command /plugin load/reload/autoload\n  * core: use extended regex in filters (task #9497, patch #7616)\n  * api: add modifier \"input_text_for_buffer\" (bug #35317)\n  * api: add support of URL in hook_process / hook_process_hashtable (task #10247)\n  * api: add new functions strcasecmp_range, strncasecmp_range, string_regex_flags, string_regcomp, hashtable_map_string, hook_process_hashtable, hdata_check_pointer, hdata_char, hdata_hashtable and nicklist_get_next_item\n  * alias: add default alias /umode => /mode $nick\n  * irc: add option \"capabilities\" in servers to enable client capabilities on connection\n  * irc: add signal \"irc_server_opened\"\n  * irc: add signal \"xxx,irc_out1_yyy\" and modifier \"irc_out1_xxx\" (outgoing message before automatic split to fit in 512 bytes)\n  * irc: add alias \"ctcp\" for target buffer of CTCP messages\n  * irc: add options irc.look.highlight_{server|channel|pv} to customize or disable default nick highlight (task #11128)\n  * irc: use redirection to get channel modes after update of modes on channel, display output of /mode #channel, allow /mode without argument (display modes of current channel or user modes on server buffer)\n  * irc: add optional server in info \"irc_is_channel\" (before channel name) (bug #35124), add optional server in info_hashtable \"irc_message_parse\"\n  * irc: add case insensitive string comparison based on casemapping of server (rfc1459, strict-rfc1459, ascii) (bug #34239)\n  * irc: add option irc.color.mirc_remap to remap mirc colors in messages to WeeChat colors\n  * irc: allow URL \"irc://\" in command /connect\n  * irc: use extended regex in commands /ignore and /list\n  * guile: new script plugin for scheme (task #7289)\n  * python: add support of Python 3.x (task #11704)\n  * relay: add WeeChat protocol for remote GUI\n  * xfer: display origin of xfer in core and xfer buffers (task #10956)\n\nInternationalization::\n\n  * add Japanese translations\n\nBug fixes::\n\n  * core: fix expand of path `~` to home of user in function string_expand_home (`~/xxx` was OK, but not `~`)\n  * core: fix memory leak when closing buffer\n  * core: fix memory leak in function util_search_full_lib_name\n  * core: automatically add newline char after last pasted line (when pasting many lines with confirmation) (task #10703)\n  * core: fix bug with layout: assign layout number in buffers when doing /layout save\n  * core: do not auto add space after nick completer if option weechat.completion.nick_add_space is off\n  * core: fix signal \"buffer_switch\": send it only once when switching buffer (bug #31158)\n  * core: move option \"scroll_unread\" from command /input to /window\n  * core: save current mouse state in option weechat.look.mouse (set option when mouse state is changed with command /mouse)\n  * core: apply filters after full reload of configuration files (with /reload) (bug #31182)\n  * core: allow list for option weechat.plugin.extension (makes weechat.conf portable across Un*x and Windows) (task #11479)\n  * core: display error in command /buffer if arguments are wrong (bug #34180)\n  * core: fix help on plugin option when config_set_desc_plugin is called to set help on newly created option\n  * core: enable background process under Cygwin to connect to servers, fix reconnection problem (bug #34626)\n  * aspell: fix URL detection (do not check spelling of URLs) (bug #34040)\n  * irc: fix memory leak in SASL/blowfish authentication\n  * irc: fix memory leak when a server is deleted\n  * irc: fix self-highlight when using /me with an IRC bouncer like znc (bug #35123)\n  * irc: use low priority for MODE sent automatically by WeeChat (when joining channel)\n  * irc: do not use option irc.look.nick_color_stop_chars for forced nick colors (bug #33480)\n  * irc: reset read marker of current buffer on manual /join\n  * irc: fix crash when signon time in message 317 (whois, idle) is invalid (too large) (bug #34905)\n  * irc: do not delete servers added in irc.conf on /reload (bug #34872)\n  * irc: remove autorejoin on channels when disconnected from server (bug #32207)\n  * irc: display messages kick/kill/mode/topic even if nick is ignored (bug #34853)\n  * irc: display channel voice notices received in channel buffer (bug #34762), display channel/op notices sent in channel buffer\n  * irc: auto-connect to servers created with \"irc://\" on command line but not other servers if \"-a\" (\"--no-connect\") is given\n  * perl: increment count of hash returned by API (fix crash when script tries to read hash without making a copy)\n  * relay: do not create relay if there is a problem with socket creation (bug #35345)\n  * ruby: fix crash when reloading ruby plugin (bug #34474)\n\nDocumentation::\n\n  * add developer's guide (task #5416)\n\nBuild::\n\n  * core: add library \"pthread\" in CMake file for link on OpenBSD\n  * core: add WEECHAT_HOME option in CMake and configure to setup default WeeChat home (default is \"~/.weechat\") (task #11266)\n  * core: fix compilation under OpenBSD 5.0 (lib utf8 not needed any more) (bug #34727)\n  * core: fix compilation error with \"pid_t\" on macOS (bug #34639)\n\n[[v0.3.6]]\n== Version 0.3.6 (2011-10-22)\n\nNew features::\n\n  * core: add color attribute \"|\" (keep attributes) and value \"resetcolor\" for function color in plugin API (used by irc plugin to keep bold/reverse/underlined in message when changing color) (bug #34550)\n  * core: add new option weechat.look.color_basic_force_bold, off by default: bold is used only if terminal has less than 16 colors (patch #7621)\n  * core: add default key kbd:[F5] (`meta2-[E`) for Linux console\n  * core: add \"inactive\" colors for inactive windows and lines in merged buffers, new options: weechat.look.color_inactive_window, weechat.look.color_inactive_buffer, weechat.look.color_inactive_message, weechat.look.color_inactive_prefix, weechat.look.color_inactive_prefix_buffer, weechat.look.color_inactive_time, weechat.color.chat_inactive_line, weechat.color.chat_inactive_window, weechat.color.chat_prefix_buffer_inactive_line\n  * core: do automatic zoom on current window when terminal becomes too small for windows\n  * core: add new options weechat.look.bar_more_left/right/up/down\n  * core: add new option weechat.look.item_buffer_filter\n  * core: allow name of buffer for command /buffer clear (task #11269)\n  * core: add new command /repeat (execute a command several times)\n  * core: save and restore layout for buffers and windows on /upgrade\n  * core: add option \"-all\" in command \"/buffer unmerge\"\n  * core: add number in windows (add optional argument \"-window\" so some actions for command /window)\n  * core: allow buffer name in /buffer close\n  * core: add support of mouse: new command /mouse, new key context \"mouse\", new options weechat.look.mouse and weechat.look.mouse_timer_delay (task #5435)\n  * core: add command /cursor (free movement of cursor on screen), with key context \"cursor\"\n  * core: automatic scroll direction in /bar scroll (x/y is now optional)\n  * core: add optional delay for key grab (commands /input grab_key and /input grab_key_command, default is 500 milliseconds)\n  * core: allow plugin name in command \"/buffer name\"\n  * core: add context \"search\" for keys (to define keys used during search in buffer with kbd:[Ctrl+r])\n  * core: add new option weechat.look.separator_vertical, rename option weechat.look.hline_char to weechat.look.separator_horizontal\n  * core: add local variable \"highlight_regex\" in buffers\n  * core: add \"hdata\" (direct access to WeeChat/plugin data)\n  * core: add option weechat.look.eat_newline_glitch (do not add new line at end of each line displayed)\n  * core: add options \"infolists\", \"hdata\" and \"tags\" for command /debug\n  * core: add horizontal scrolling for buffers with free content (command /window scroll_horiz) (task #11112)\n  * core: change default value of option weechat.network.gnutls_ca_file to \"/etc/ssl/certs/ca-certificates.crt\"\n  * api: add info \"cursor_mode\"\n  * api: add new functions key_bind, key_unbind, hook_focus, hdata_new, hdata_new_var, hdata_new_list, hdata_get, hdata_get_var_offset, hdata_get_var_type, hdata_get_var_type_string, hdata_get_var_hdata, hdata_get_var, hdata_get_var_at_offset, hdata_get_list, hdata_move, hdata_integer, hdata_string, hdata_pointer, hdata_time, hdata_get_string\n  * irc: allow reason for command /disconnect\n  * irc: allow server name for commands /die and /restart\n  * irc: add new info_hashtable \"irc_message_split\"\n  * irc: add prefix \"#\" for all channels on join (if no prefix given)\n  * irc: improve split of privmsg message (keep ctcp), add split of ison, join, notice, wallops, 005, 353 (bug #29879, bug #33448, bug #33592)\n  * logger: add option logger.file.flush_delay (task #11118)\n\nBug fixes::\n\n  * core: fix freeze when calling function util_file_get_content with a directory instead of a filename\n  * core: display timeout for hook_process command only if debug for core is enabled (task #11401)\n  * core: bufferize lines displayed before core buffer is created, to display them in buffer when it is created\n  * core: fix display of background color in chat area after line feed\n  * core: fix paste detection (problem with end of lines)\n  * core: fix display of paste multi-line prompt with a root input bar (bug #34305)\n  * core: replace deprecated GnuTLS function gnutls_certificate_client_set_retrieve_function by new function gnutls_certificate_set_retrieve_function (GnuTLS >= 2.11.0)\n  * core: use dynamic buffer size for calls to vsnprintf\n  * core: fix memory leak in unhook of hook_connect\n  * core: fix memory leak in display of empty bar items\n  * core: fix input of wide UTF-8 chars under Cygwin (bug #34061)\n  * core: fix bugs with automatic layout (bug #26110), add support of merged buffers in layout (task #10893)\n  * core: fix crash when invalid UTF-8 chars are inserted in command line (bug #33471)\n  * core: stop horizontal bar scroll at the end of content (for bars with horizontal filling) (bug #27908)\n  * core: fix crash when building hashtable string with keys and values\n  * core: replace buffer name by window number in /bar scroll\n  * core: fix bugs with key \"^\" (bug #32072, bug #21381)\n  * core: fix bugs with bar windows: do not create bar windows for hidden bars\n  * core: fix completion bug when two words for completion are equal but with different case\n  * core: fix completion for command arguments when same command exists in many plugins (bug #33753)\n  * core: fix freeze when hook_fd is called with a bad file/socket (bug #33619)\n  * core: fix bug with option weechat.look.hotlist_count_max (value+1 was used)\n  * api: use arguments for infolist \"window\" to return only one window by number\n  * api: fix bug with function config_set_desc_plugin (use immediately description for option when function is called)\n  * scripts: fix crash with scripts not auto-loaded having a buffer opened after /upgrade (input/close callbacks for buffer not set properly)\n  * irc: fix display of items \"away\" and \"lag\" in root bars, refresh all irc bar items on signal \"buffer_switch\" (bug #34466)\n  * irc: fix crash on malformed irc notice received (without message after target)\n  * irc: add missing messages for whois: 223, 264, 343\n  * irc: use high priority queue for sending modes and wallchops messages\n  * irc: rename info_hashtable \"irc_parse_message\" to \"irc_message_parse\"\n  * irc: use color \"default\" for any invalid color in option weechat.color.chat_nick_colors\n  * irc: send WHO command to check away nicks only if channel was not parted\n  * irc: fix crash when malformed IRC message 352 (WHO) is received (bug #33790)\n  * irc: fix crash when command \"/buffer close\" is used in a server command to close server buffer during connection (bug #33763)\n  * irc: fix crash when /join command is executed on a non-irc buffer (bug #33742)\n  * irc: fix bug with comma in irc color code: do not strip comma if it is not followed by a digit (bug #33662)\n  * irc: switch to buffer on /join #channel if channel buffer already exists\n  * irc: set host for nick on each channel message and nick change (if not already set)\n  * irc: update host of nicks on manual /who\n  * irc: fix memory leak on plugin unload (free ignores)\n  * irc: fix memory leak in message parser (when called from other plugins like relay) (bug #33387)\n  * relay: fix bug with self nick when someone changes its nick on channel (bug #33739)\n  * relay: fix memory leak (free some parsed messages) (bug #33387)\n  * relay: fix memory leak on plugin load (free raw messages)\n  * perl: replace calls to SvPV by SvPV_nolen (patch #7436)\n\nBuild::\n\n  * core: fix compilation error (INSTALLPREFIX undeclared) on macOS and when compiling with included gettext (bug #26690)\n\n[[v0.3.5]]\n== Version 0.3.5 (2011-05-15)\n\nNew features::\n\n  * core: add buffer to hotlist if away is set on buffer (even if buffer is displayed), new option weechat.look.hotlist_add_buffer_if_away (task #10948)\n  * core: add option \"balance\" in command /window (key: kbd:[Alt+w], kbd:[Alt+b])\n  * core: add option \"swap\" in command /window (key: kbd:[Alt+w], kbd:[Alt+s]) (task #11001)\n  * core: add option weechat.look.hotlist_buffer_separator\n  * core: add messages counts in hotlist for each buffer, new options: weechat.look.hotlist_count_max, weechat.look.hotlist_count_min_msg and weechat.color.status_count_{msg|private|highlight|other}\n  * core: add tag \"notify_none\" (line with this tag will not update hotlist)\n  * core: add optional bar name in command \"/bar default\"\n  * core: add new option weechat.look.highlight_tags (force highlight on tags)\n  * core: allow list of buffers in command /filter (exclusion with prefix \"!\") (task #10880)\n  * core: allow relative size for command /window resize\n  * core: add some default keys for gnome-terminal (kbd:[Home] / kbd:[End], kbd:[Ctrl+Up] / kbd:[Ctrl+Down], kbd:[Alt+PgUp] / kbd:[Alt+PgDn])\n  * core: add option \"memory\" in command /debug\n  * core: add option weechat.look.read_marker_string\n  * core: add some chars after cursor when scrolling input line: new option weechat.look.input_cursor_scroll (bug #21391)\n  * core: add color \"gray\"\n  * core: add attributes for colors (\"*\": bold, \"!\": reverse, \"_\": underline)\n  * core: dynamically allocate color pairs (extended colors can be used without being added with command \"/color\"), auto reset of color pairs with option weechat.look.color_pairs_auto_reset\n  * core: allow background for nick colors (using \":\")\n  * core: remember scroll position for all buffers in windows (bug #25555)\n  * core: improve display of commands lists in /help (add arguments -list and -listfull) (task #10299)\n  * core: improve arguments displayed in /help of commands\n  * api: add new function config_set_desc_plugin (task #10925)\n  * api: add new functions buffer_match_list and window_search_with_buffer\n  * aspell: add section \"option\" in aspell.conf for speller options (task #11083)\n  * irc: add new options irc.color.topic_old and irc.color.topic_new\n  * irc: add option \"ssl_priorities\" in servers (task #10106, debian #624055)\n  * irc: add modifier \"irc_in2_xxx\" (called after charset decoding)\n  * irc: add new options irc.look.buffer_switch_autojoin and irc.look.buffer_switch_join (task #8542, task #10506)\n  * irc: add new option irc.look.smart_filter_nick\n  * irc: add new options irc.look.color_nicks_in_nicklist and irc.look.color_nicks_in_names\n  * irc: replace options irc.color.nick_prefix_{op|halfop|voice|user} by a single option irc.color.nick_prefixes (task #10888)\n\nBug fixes::\n\n  * core: fix scroll in windows with /window scroll (skip lines \"Day changed to\")\n  * core: recalculate buffer_max_length when buffer short name is changed (patch #7441)\n  * core: do not update hotlist during upgrade\n  * core: apply new value of option weechat.look.buffer_notify_default to all opened buffers\n  * core: prohibit names beginning with \"#\" for bars, proxies, filters and IRC servers (bug #33020)\n  * core: create default bars only if no bar is defined in configuration file\n  * core: fix bug with repeat of last completion (\"%*\"), which failed when many templates are used in completion\n  * core: reload file with certificate authorities when option weechat.network.gnutls_ca_file is changed\n  * core: rebuild bar content when items are changed in an hidden bar\n  * core: fix verification of SSL certificates by calling GnuTLS verify callback (patch #7459, CVE-2011-1428)\n  * core: fix crash when using column filling in bars with some empty items (bug #32565)\n  * core: fix terminal title when $TERM starts with \"screen\"\n  * plugins: fix memory leaks when setting buffer callbacks after /upgrade (plugins: irc, relay, xfer, scripts)\n  * aspell: fix spellers used after switch of window (bug #32811)\n  * irc: fix parsing of message 332 when no topic neither colon are found (bug with bip proxy)\n  * irc: fix nick color in private when option irc.look.nick_color_force is changed\n  * irc: fix tags for messages sent with /msg command (bug #33169)\n  * irc: fix memory leak when copying or renaming server\n  * irc: do not rejoin channels where /part has been issued before reconnection to server (bug #33029)\n  * irc: use nick color for users outside the channel\n  * irc: update short name of server buffer when server is renamed\n  * irc: fix local variable \"away\" on server buffer (set/delete it each time away is set or removed on server)\n  * irc: ignore join if nick is not self nick and if channel buffer does not exist (bug #32667)\n  * irc: fix crash when setting wrong value in option irc.server.xxx.sasl_mechanism (bug #32670)\n  * irc: fix crash when completing /part command on a non-irc buffer (bug #32402)\n  * irc: add many missing commands for target buffer (options irc.msgbuffer.xxx) (bug #32216)\n  * lua: fix crash when many scripts are executing callbacks at same time\n  * perl: fix memory leak when calling Perl functions (bug #32895)\n  * relay: fix crash on /upgrade when nick in irc client is not yet set\n  * relay: allow colon in server password received from client\n  * relay: do not send join for private buffers to client\n  * rmodifier: fix reload of file rmodifier.conf\n  * rmodifier: fix crash when adding rmodifier with invalid regex\n  * xfer: do not close chat buffers when removing xfer from list (bug #32271)\n\nBuild::\n\n  * tcl: fix Tcl detection on some 64-bits systems (bug #32915)\n\n[[v0.3.4]]\n== Version 0.3.4 (2011-01-16)\n\nNew features::\n\n  * core: add 256 colors support, new command /color, new section \"palette\" in weechat.conf (task #6834)\n  * core: add info \"weechat_upgrading\", signal \"upgrade_ended\", display duration of upgrade\n  * core: add new option weechat.look.highlight_regex and function string_has_highlight_regex in plugin API (task #10321)\n  * core: add new option weechat.look.hotlist_unique_numbers (task #10691)\n  * core: add property \"hotlist_max_level_nicks\" in buffers to set max hotlist level for some nicks in buffer\n  * core: add new options weechat.look.input_share and weechat.look.input_share_overwrite (task #9228)\n  * core: add new option weechat.look.prefix_align_min (task #10650)\n  * core: replace the 10 nick color options and number of nick colors by a single option weechat.color.chat_nick_colors (comma separated list of colors)\n  * core: add color support in option weechat.look.buffer_time_format\n  * api: add priority for hooks (task #10550)\n  * api: add new functions: list_search_pos, list_casesearch_pos, hashtable_get_string, hashtable_set_pointer, hook_info_hashtable, info_get_hashtable, hook_hsignal, hook_hsignal_send, hook_completion_get_string, nicklist_group_get_integer, nicklist_group_get_string, nicklist_group_get_pointer, nicklist_group_set, nicklist_nick_get_integer, nicklist_nick_get_string, nicklist_nick_get_pointer, nicklist_nick_set\n  * irc: add option \"-server\" in command /join (task #10837)\n  * irc: add option \"-switch\" in commands /connect and /reconnect\n  * irc: add command /notify, new options irc.look.notify_tags_ison, irc.look.notify_tags_whois, irc.network.notify_check_ison, irc.network.notify_check_whois, new option \"notify\" in servers, new infolist \"irc_notify\" (task #5441)\n  * irc: add new option irc.look.nick_color_force (task #7374)\n  * irc: add command redirection with hsignals irc_redirect_pattern and irc_redirect_command (task #6703)\n  * irc: add new options irc.color.nick_prefix and irc.color.nick_suffix\n  * irc: add new option irc.look.item_away_message\n  * irc: add tag \"nick_xxx\" in user messages\n  * irc: move options from network section to server section: connection_timeout, anti_flood_prio_high, anti_flood_prio_low, away_check, away_check_max_nicks, default_msg_part, default_msg_quit (task #10664, task #10668)\n  * irc: display old channel topic when topic is unset (task #9780)\n  * irc: add new info_hashtable \"irc_parse_message\"\n  * irc: add signal \"irc_input_send\"\n  * irc: rename options irc.look.open_channel_near_server and irc.look.open_pv_near_server to irc.look.new_channel_position and irc.look.new_pv_position with new values (none, next or near_server)\n  * rmodifier: new plugin \"rmodifier\": alter modifier strings with regular expressions (bug #26964)\n  * relay: beta version of IRC proxy, now relay plugin is compiled by default\n  * python: add info \"python2_bin\" (path to Python 2.x interpreter)\n\nBug fixes::\n\n  * core: fix scroll problem on buffers with free content and non-allocated lines (bug #32039)\n  * core: call to function hook_config when config option is created\n  * core: fix infinite loop on GnuTLS handshake when connecting with SSL to server on wrong port or server with SSL problems (bug #27487)\n  * core: fix data sent to callback of hook_process (some data was sometimes missing), use a 64KB buffer for child output and send data to callback only when buffer is full\n  * core: fix crash when displaying groups in buffer nicklist\n  * core: fix bug with message \"day changed to\", sometimes displayed several times wrongly\n  * core: fix default value of bar items options (bug #31422)\n  * core: fix bug with buffer name in \"/bar scroll\" command\n  * core: optimize incremental search in buffer: do not search any more when chars are added to a text not found (bug #31167)\n  * core: fix memory leaks when removing item in hashtable and when setting highlight words in buffer\n  * core: use similar behavior for keys bound to local or global history (bug #30759)\n  * alias: complete with alias value for second argument of command /alias\n  * irc: differentiate notices from messages in private buffer (bug #31980)\n  * irc: update nick modes with message 221 (bug #32038)\n  * irc: fix bug with charset decoding on private buffers (decoding was made for local nick instead of remote nick) (bug #31890)\n  * irc: allow command /reconnect on servers that are not currently connected (bug #30726)\n  * irc: fix topic completion in command /topic when channel topic starts with channel name\n  * irc: improve nick prefixes, all modes (even unknown) are used with PREFIX value from message 005\n  * irc: fix crash/bug when option \"addresses\" for a server is unset or changed when WeeChat is connected to this server (bug #31268)\n  * irc: switch to next server address when IRC error is received after TCP connection but before message 001 (bug #30884)\n  * irc: fix bug with hostmasks in command /ignore (bug #30716)\n  * relay: split of messages sent to clients of irc proxy\n  * scripts: add missing function infolist_reset_item_cursor in API (bug #31057)\n  * lua: fix crash when unloading script\n  * xfer: fix dcc chat buffer name (use irc server in name) (bug #29925)\n  * xfer: fix dcc file transfer for large files (more than 4 GB) on 32-bit systems (bug #31531)\n  * xfer: fix bug at end of file sent, sometimes transfer is still active although file was successfully sent\n\nBuild::\n\n  * core: add support of Python 2.7 in CMake and configure (debian #606989)\n  * ruby: fix compilation with Ruby 1.9.2 (patch #7316)\n\n[[v0.3.3]]\n== Version 0.3.3 (2010-08-07)\n\nNew features::\n\n  * core: use \"!\" to reverse a regex in a filter (to keep lines matching regex and hide other lines) (task #10032)\n  * core: add keys for undo/redo changes on command line (default: kbd:[Ctrl+pass:none[_]] and kbd:[Alt+pass:none[_]]) (task #9483)\n  * core: add new option weechat.look.align_end_of_lines\n  * core: add new option weechat.look.confirm_quit\n  * core: add new option weechat.color.status_name_ssl (task #10339)\n  * core: add hashtables with new functions in plugin API\n  * api: add function string_expand_home, fix bug with replacement of home in paths\n  * irc: add new option irc.look.nick_color_stop_chars\n  * irc: add new options irc.look.display_host_join/join_local/quit and irc.color.reason_quit\n  * irc: add command /wallchops, fix bug with display of notice for ops (task #10021, bug #29932)\n  * irc: add isupport value in servers (content of IRC message 005), with new infos: irc_server_isupport and irc_server_isupport_value\n  * irc: add message in private buffer when nick is back on server after a /quit\n  * irc: add new options irc.network.autoreconnect_delay_growing and irc.network.autoreconnect_delay_max (task #10338)\n  * irc: add missing commands 346, 347 (channel invite list)\n  * irc: improve lag indicator: two colors (counting and finished), update item even when pong has not been received, lag_min_show is now in milliseconds\n  * irc: move options weechat.color.nicklist_prefix to irc plugin\n  * logger: use tag \"no_log\" to prevent a line from being written in log file\n\nBug fixes::\n\n  * core: fix bug with scroll_unread: do not scroll to a filtered line (bug #29991)\n  * core: fix crash with hook_process (when timer is called on a deleted hook process)\n  * core: fix display bug with special chars (ascii value below 32) (bug #30602)\n  * core: fix display bug with attributes like underlined in bars (bug #29889)\n  * api: fix bug with replacement char in function string_remove_color (bug #30296)\n  * irc: fix bug in parser when no argument is received after command, no callback was called, and message was silently ignored (bug #30640)\n  * irc: fix import of certificates created by OpenSSL >= 1.0.0 (bug #30316)\n  * irc: fix display of local SSL certificate when it is sent to server (patch #7218)\n  * irc: use empty real name by default in config, instead of reading real name in /etc/passwd (bug #30111)\n  * irc: fix bug with command line option \"irc://\" (bug #29990), new format for port and channels\n  * irc: fix display of messages 330 and 333 on some servers\n  * irc: fix bug with nick prefix \"*\" (chan founder) on some IRC servers (bug #29890)\n  * irc: fix bug with option irc.network.lag_check when value is 0 (zero)\n  * irc: try other nick when connecting to server and receiving message 437 (nick unavailable)\n  * irc: set buffer local variable \"away\" when opening new channel (bug #29618)\n  * fifo: fix bug with fifo pipe when setting fifo option to \"on\"\n  * xfer: fix bug with double quotes in DCC filenames (bug #30471)\n\n[[v0.3.2]]\n== Version 0.3.2 (2010-04-18)\n\nNew features::\n\n  * core: add new options for command /key: listdefault, listdiff and reset\n  * core: add new command /mute\n  * core: add command line option \"-s\" (or \"--no-script\") to start WeeChat without loading any script\n  * core: improve plugins autoload (option weechat.plugin.autoload): allow to use \"*\" as wildcard and \"!\" to prevent a plugin from being autoloaded (task #6361)\n  * core: add option \"switch_active_buffer_previous\" in command /input (task #10141)\n  * core: add new option weechat.look.time_format to customize default format for date/time displayed (localized date by default), add function util_get_time_string in plugin API (patch #6914)\n  * core: add new option weechat.look.command_chars, add functions string_is_command_char and string_input_for_buffer in plugin and script API\n  * core: add new option weechat.look.read_marker_always_show\n  * api: add \"version_number\" for function info_get to get WeeChat version as number\n  * api: add \"irc_is_nick\" for function info_get to check if a string is a valid IRC nick name (patch #7133)\n  * api: add functions string_encode_base64 and string_decode_base64, fix bug with base64 encoding\n  * api: add functions string_match, string_has_highlight and string_mask_to_regex in script plugin API\n  * api: add description of arguments for functions hook_info and hook_infolist\n  * api: add signals \"day_changed\", \"nicklist_group_added/removed\", \"nicklist_nick_added/removed\"\n  * alias: add custom completion for aliases (task #9479)\n  * scripts: allow script commands to reload only one script\n  * irc: add SASL authentication, with PLAIN and DH-BLOWFISH mechanisms (task #8829)\n  * irc: add new option irc.look.part_closes_buffer to close buffer when /part is issued on channel (task #10295)\n  * irc: add option \"-open\" in command /connect\n  * irc: add option irc.network.connection_timeout (timeout between TCP connection to server and reception of message 001)\n  * irc: add options irc.look.smart_filter_join and irc.look.smart_filter_quit\n  * irc: add option irc.look.item_channel_modes_hide_key to hide channel key in channel modes (bug #23961)\n  * irc: add option irc.look.item_nick_prefix\n  * irc: add command /map\n  * irc: add missing commands 276, 343\n  * logger: allow date format in logger options path and mask (task #9430)\n  * xfer: add signal \"xfer_ended\" (patch #7081)\n\nBug fixes::\n\n  * core: remove unneeded space after time on each line if option weechat.look.buffer_time_format is set to empty value (bug #28751)\n  * core: use arguments for infolist \"nicklist\" to return only one nick or group\n  * core: fix bug with writing of configuration files when disk is full (bug #29331)\n  * core: fix infinite loop with /layout apply and bug when applying layout, sometimes many /layout apply were needed (bug #26110)\n  * gui: refresh screen when exiting WeeChat (to display messages printed after /quit)\n  * gui: fix bug with global history, reset pointer to last entry after each user input (bug #28754)\n  * gui: fix bug with bar background after text with background color (bug #28157)\n  * gui: fix bug with cursor when position is last char of terminal\n  * api: add missing infos in functions buffer_get_{integer|string} and in buffer infolist\n  * api: fix function color in Lua script API\n  * api: fix \"inactivity\" value when no key has been pressed since WeeChat started (bug #28930)\n  * api: return absolute path for info_get of \"weechat_dir\" (bug #27936)\n  * scripts: fix bug with callbacks when loading a script already loaded\n  * perl: fix crash when multiplicity is disabled\n  * perl: fix crash when callbacks are called during script initialization (bug #29018)\n  * perl: fix crash on /quit or unload of plugin under FreeBSD and Cygwin (bug #29467)\n  * perl: fix bug with script filename when multiplicity is disabled (bug #29530)\n  * irc: fix crash with SSL connection if option ssl_cert is set (bug #28752)\n  * irc: fix bug with SSL connection (fails sometimes when ssl_verify is on) (bug #28741)\n  * irc: fix bug with nicks on reconnection: try all nicks in list, even if nick used was not the first in list of nicks\n  * irc: fix command /list: send channel and server name given as argument, and use separate option \"-re\" to allow a regex\n  * irc: fix PART message received on Undernet server (bug #28825)\n  * irc: fix bug with /away -all: set or unset future away for disconnected servers (bug #29022)\n  * irc: fix bug with prefix \"!\" for mode \"a\" (channel admin) (bug #29109)\n  * irc: do not send signals \"irc_in\" and \"irc_in2\" when messages are ignored, add new signals \"irc_raw_in\" and \"irc_raw_in2\"\n  * irc: apply smart filter only on channels, not private buffers (bug #28841)\n  * xfer: fix crash when purging old xfer chats (bug #28764)\n\nBuild::\n\n  * irc: fix compilation with old GnuTLS versions (bug #28723)\n\n[[v0.3.1.1]]\n== Version 0.3.1.1 (2010-01-31)\n\nBug fixes::\n\n  * irc: fix crash with SSL connection if option ssl_cert is set (bug #28752)\n  * irc: fix bug with SSL connection (fails sometimes when ssl_verify is on) (bug #28741)\n  * xfer: fix crash when purging old xfer chats (bug #28764)\n\nBuild::\n\n  * irc: fix compilation with old GnuTLS versions (bug #28723)\n\n[[v0.3.1]]\n== Version 0.3.1 (2010-01-23)\n\nNew features::\n\n  * core: add option \"grab_key_command\" in command /input (bound by default to kbd:[Alt+k])\n  * alias: new expansions for alias arguments ($n, $-m, $n-, $n-m, $*, $~) (patch #6917)\n  * alias: allow use of wildcards for /alias list (patch #6925)\n  * alias: allow /unalias to remove multiple aliases (patch #6926)\n  * irc: add new commands /allchan and /allserv with excluding option, commands /ame and /amsg are now aliases, new aliases /aaway and /anick\n  * irc: add options to customize target buffer for messages (task #7381)\n  * irc: add new output queue for messages with low priority (like automatic CTCP replies), high priority is given to user messages or commands\n  * irc: use self-signed certificate to auto identify on IRC server (CertFP) (task #7492, debian #453348)\n  * irc: check SSL certificates (task #7492)\n  * irc: add option \"autorejoin_delay\" for servers (task #8771)\n  * irc: add option to use same nick color in channel and private (task #9870)\n  * irc: add missing command 275 (patch #6952)\n  * irc: add commands /sajoin, /samode, /sanick, /sapart, /saquit (task #9770)\n  * irc: add options for CTCP, to block/customize CTCP reply (task #9693)\n  * irc: add missing CTCP: clientinfo, finger, source, time, userinfo (task #7270)\n  * irc: add all server options for commands /server and /connect\n  * irc: add arguments for command /rehash\n  * irc: improve mask used by command /kickban\n  * xfer: add color for nicks in chat\n  * xfer: add missing command /me (bug #28658)\n  * gui: add color \"darkgray\", add support for background with light color\n\nBug fixes::\n\n  * core: fix bug with script installation on BSD/macOS (patch #6980)\n  * core: fix compilation under Cygwin (patch #6916)\n  * core: fix plural form in translation files (bug #27430)\n  * core: fix terminal title bug: do not reset it when option weechat.look.set_title is off (bug #27399)\n  * core: fix buffer used by some input functions called via plugin API with buffer pointer (bug #28152)\n  * alias: fix bug with buffer for execution of alias, when called from plugin API with function command (bug #27697)\n  * alias: fix bug with arguments (bug #27440)\n  * irc: improve error management on socket error (recv/send)\n  * irc: fix nick color for nicks with wide chars (bug #28547)\n  * irc: fix autorejoin on channels with key\n  * irc: fix command /connect (options -ssl, -ipv6 and -port) (bug #27486)\n  * xfer: add missing charset decoding/encoding for IRC DCC chat (bug #27482)\n  * fifo: remove old pipes before creating new pipe\n  * gui: fix color \"black\" (bug #23882, debian #512957)\n  * gui: fix message \"Day changed to\", sometimes displayed at wrong time (bug #26959)\n  * gui: fix bug with URL selection in some terminals (caused by horizontal lines) (bug #27700)\n  * gui: use default auto completion for arguments of unknown commands\n  * gui: fix alignment problem for buffer name when a merged buffer is closed (bug #27617)\n  * gui: update hotlist when a buffer is closed (bug #27470), remove buffer from hotlist when buffer is cleared (bug #27530)\n  * gui: fix /input history_global_next: reset input content when last command in history is reached\n  * api: fix function bar_set for python/lua/ruby (patch #6912)\n\nBuild::\n\n  * core: fix CMake directories: let user customize lib, share, locale and include directories (patch #6922)\n  * ruby: add support of Ruby >= 1.9.1 (patch #6989)\n\n[[v0.3.0]]\n== Version 0.3.0 (2009-09-06)\n\nNew features::\n\n  * core: add group support in nicklist\n  * core: add /reload command to reload WeeChat and plugins config files (signal SIGHUP is caught to reload config files)\n  * core: add new /layout command and save_layout_on_exit config option, to save/restore windows and buffers order (task #5453)\n  * core: add new options for completion, optional stop instead of cycling with words found (task #5909)\n  * core: new name for configuration files (*.conf instead of *.rc)\n  * core: improve /set command, new command /unset (task #6085)\n  * core: add new input action \"set_unread_current_buffer\" to set unread marker for current buffer only (task #7286)\n  * core: remove key functions, replaced by /input command\n  * core: add argument with buffer number/range for command \"/buffer close\" (task #9390, task #7239)\n  * core: add new command /wait (schedule a command execution in future)\n  * core: improve main loop: higher timeout in select, less CPU usage\n  * gui: new display engine, with prefix and message for each line\n  * gui: add new type of buffer, with free content\n  * gui: add tags for lines and custom filtering by tags or regex (task #7674)\n  * gui: add buffer merging (task #7404)\n  * gui: add custom bars, with custom items\n  * gui: add key to zoom a window (task #7470)\n  * gui: add keys to move into last visited buffers: kbd:[Alt+<] and kbd:[Alt+>]\n  * gui: come back to last visited buffer when closing a buffer\n  * gui: add new option scroll_page_percent to choose percent of height to scroll with kbd:[PgUp] and kbd:[PgDn] keys (task #8702)\n  * gui: add number of lines remaining after last line displayed in \"-MORE-\" indicator (task #6702)\n  * network: add support for more than one proxy, with proxy selection for each IRC server (task #6859)\n  * aspell: improve plugin: use of many dictionaries, global dictionary, real time checking (optional), fix bugs with utf-8\n  * irc: add irc plugin (replaces old IRC code in core) (task #6217)\n  * irc: add smart join/part/quit message filter (task #8503)\n  * irc: use of many addresses for servers (auto-switch when a connection fails), nicks are now set with one option \"nicks\" (task #6088)\n  * irc: add some colors in messages from server (for text and nicks) (task #8926)\n  * irc: add color decoding in title for IRC channels (task #6030)\n  * irc: add missing commands (328, 369)\n  * logger: add logger plugin with new features: backlog, level for messages to log (task #8592), level by buffer (task #6687), filename mask by buffer, option \"name_lower_case\" (bug #19522)\n  * relay: add relay plugin (network communication between WeeChat and remote application)\n  * xfer: add speed limit for DCC files sending (task #6178)\n  * xfer: add new option xfer.file.use_nick_in_filename for Xfer files (task #7140)\n  * plugins: add some other plugins: alias, demo, fifo, tcl, xfer\n  * scripts: new scripts: weeget.py (script manager), jabber.py (jabber/XMPP protocol), go.py (quick jump to buffers), buffers.pl (sidebar with list of buffers), iset.pl (set options interactively), weetris.pl (tetris-like game), mastermind.pl, ...\n  * api: add hooks: command, timer, file descriptor, process, connection, print, signal, config, completion, modifier, info, infolist\n  * api: new plugin API with many new functions: hooks, buffer management and nicklist, bars, configuration files, network, infos/infolists, lists, upgrade\n\nInternationalization::\n\n  * add Polish translations\n\nBug fixes::\n\n  * core: fix nick completion bug (missing space after nick)\n  * gui: fix completion with non-latin nicks (bug #18993)\n  * gui: fix display bug with some weird UTF-8 chars (bug #19687)\n  * gui: fix bug with wide chars in input (bug #16356)\n  * gui: fix bug when switching window, scrollback is now preserved (task #7680)\n  * network: fix network connection for hostnames resolving to several IPs: try all IPs in list until one succeeds (bug #21473, debian #498610)\n  * alias: fix bug with alias, use current buffer to run commands (bug #22876)\n  * irc: fix lock with SSL servers when connection fails, and when disconnecting during connection problem (bug #17584)\n  * irc: command /whois is now authorized in private without argument (task #7482)\n  * irc: fix private buffer name with Irssi proxy (bug #26589)\n  * irc: remove kernel info in CTCP VERSION reply (task #7494)\n  * irc: fix mode parsing when receiving modes with arguments (bug #26793)\n  * scripts: do not auto-load hidden files (bug #21390)\n\n[[v0.2.6.3]]\n== Version 0.2.6.3 (2009-06-13)\n\nBug fixes::\n\n  * fix GnuTLS detection (use pkg-config instead of libgnutls-config) (bug #26790)\n\n[[v0.2.6.2]]\n== Version 0.2.6.2 (2009-04-18)\n\nBug fixes::\n\n  * fix bug with charset decoding (for example with iso2022jp) (bug #26228)\n\n[[v0.2.6.1]]\n== Version 0.2.6.1 (2009-03-14)\n\nBug fixes::\n\n  * fix crash with some special chars in IRC messages (bug #25862, CVE-2009-0661)\n\n[[v0.2.6]]\n== Version 0.2.6 (2007-09-06)\n\nNew features::\n\n  * add new option \"deloutq\" to /server command to delete all servers messages out queues (task #7221)\n  * add string length limit for setup file options\n  * add option to align text of messages (except first lines) (task #7246)\n  * add paste detection, new options look_paste_max_lines and col_input_actions (task #5442)\n  * add support of channel mode +u (channel user) (bug #20717)\n  * improve /connect command to connect to a host by creating a temporary server, add option to /server to create temporary server (task #7095)\n  * add \"copy\", \"rename\" and \"keep\" options to /server command\n  * allow clear of multiple selected buffers with /clear (patch #6112)\n  * add key for setting unread marker on all buffers (default: kbd:[Ctrl+s], kbd:[Ctrl+u]) (task #7180)\n  * improve command /server ant its output\n  * add 3 default new keys: kbd:[Ctrl+b] (left), kbd:[Ctrl+f] (right), kbd:[Ctrl+d] (delete)\n  * add \"buffer_move\" event handler to plugins API (task #6708)\n  * add key function \"jump_previous_buffer\" to jump to buffer previously displayed (new key: kbd:[Alt+j], kbd:[Alt+p]) (task #7085)\n  * add \"%*\" to completion template, to repeat last completion\n  * add \"-nojoin\" option for /connect and /reconnect commands (task #7074)\n  * add \"scroll\" option to /buffer command\n  * down key now saves input to history and clears input line (task #7049)\n  * command /away allowed when not connected to server (internally stored and AWAY command is sent when connecting to server) (task #7003)\n  * add argument for /upgrade command (path to binary)\n  * add hotlist sort with new option \"look_hotlist_sort\" (task #5870)\n\nBug fixes::\n\n  * fix bug with log of plugin messages (option log_plugin_msg)\n  * fix display bug with some special chars in messages (some words were truncated on screen) (bug #20944)\n  * fix UTF-8 bug with color encoding/decoding\n  * fix crash when searching text in buffer with kbd:[Ctrl+r] (bug #20938)\n  * fix bug with flock when home is on NFS filesystem (bug #20913)\n  * fix user modes in nicklist when ban and nick mode are received in the same MODE message (bug #20870)\n  * fix IRC message 333: silently ignore message if error when parsing it\n  * fix server option \"command_delay\": does not freeze WeeChat any more\n  * fix bug with highlight and UTF-8 chars around word (bug #20753)\n  * fix nick prefix display on servers that doesn't support all prefixes (bug #20025)\n  * fix terminal encoding detection when NLS is disabled (bug #20646)\n  * fix crash when sending data to channel or pv on disconnected server (bug #20524)\n  * fix bugs with IRC color in messages, now color codes are inserted in command line with kbd:[Ctrl+c], kbd:[Ctrl+b].. instead of %C,%B,.. (bug #20222, task #7060)\n  * fix bug with smart nick completion (last speakers first) when a nick is changed\n  * fix charset bug with channel names in status bar (bug #20400)\n  * fix log file when channel name contains \"/\" (bug #20072)\n  * fix bug with /topic when channel not open and topic not defined (bug #20141)\n\nDocumentation::\n\n  * add Swedish quickstart guide\n\n[[v0.2.5]]\n== Version 0.2.5 (2007-06-07)\n\nNew features::\n\n  * add missing IRC commands (327, 378, 379) (bug #20091)\n  * add \"%M\" for completion with nicks of current server (nicks on open channels) (task #6931)\n  * improve key bindings: now possible to bind a key on many commands, separated by semicolon (task #5444)\n  * improve IRC long message split: use word boundary (task #6685)\n  * add protocol priority for GnuTLS (patch #5915)\n  * add channel admin mode \"!\" for some IRC servers\n  * add /reconnect command (task #5448)\n  * add \"-all\" option for /connect and /disconnect commands (task #6232)\n  * improve nick completion: completion with last speakers first and self nick at the end; add option look_nick_completion_smart, enabled by default (task #5896)\n  * add color for input text not found in buffer history\n\nBug fixes::\n\n  * fix /quote command: now allowed when socket is OK (even if IRC connection to server is not OK) (bug #20113)\n  * fix hotlist when exiting search mode: current buffer is removed from hotlist\n  * remove \":\" for unknown IRC commands before arguments (bug #19929)\n  * fix \"%C\" completion: now completes with all channels of all servers\n  * fix bug with \"/buffer query_name\", add server and channel completion for /buffer command (bug #19928)\n  * fix IRC mode parsing when receiving modes with arguments (bug #19902)\n  * fix crash with IRC JOIN malformed message (bug #19891)\n  * fix bug with nick prefixes on some IRC servers (bug #19854)\n  * improve setup file save: now writes temporary file, then rename it (task #6847)\n  * fix bug with $nick/$channel/$server variables in commands\n  * forget current nick when user manually disconnects from server\n  * fix nick display in input window\n  * fix bug with erroneous nickname when connecting to server (bug #19812)\n  * fix display bugs in IRC error messages\n  * fix bug with iso2022jp locale (bug #18719)\n  * fix string format bug when displaying string through plugin script API\n  * fix nick completion in command arguments (bug #19590)\n  * fix possible crash with nick completion when a nick leaves channel (bug #19589)\n  * fix USER message when connecting to IRC server (patch #5835)\n\nBuild::\n\n  * add CMake for weechat compilation (patch #5943)\n\n[[v0.2.4]]\n== Version 0.2.4 (2007-03-29)\n\nNew features::\n\n  * rename log file for DCC chat (now <server>.dcc.<nick>.weechatlog)\n  * add current buffer in hotlist when scrolling up in buffer (task #6664)\n  * improve password hiding, code cleanup (bug #19229)\n  * add new return code in plugin API to force highlight (for message handlers only)\n  * add \"call\" option to /key command, add new key function \"insert\" to insert text on command line (task #6468)\n  * add event handler to plugin API\n  * add numeric argument for /clear command (buffer number) (patch #5372)\n  * add new key (kbd:[Ctrl+r]) for interactive and incremental search in buffer history (task #6628)\n\nBug fixes::\n\n  * fix color bug with IRC messages displayed by plugins (bug #19442)\n  * fix topic charset, now using channel charset if defined (bug #19386)\n  * fix crash when closing a pv if a DCC chat is open on same nick (bug #19147)\n  * fix bug with channel topic after reconnection (not erased) (bug #19384)\n  * fix bug with explode_string / free_exploded_string when max_items > 0\n  * fix /topic completion when no topic set on current channel (bug #19322)\n  * fix bug with server buffer when \"look_one_server_buffer\" is ON and server buffer is moved to any number > 1 (bug #19219)\n  * fix /help command: displays plugin help for redefined commands (bug #19166)\n  * prefix \"/\" disabled in commands (patch #5769)\n  * fix completion of redefined commands removed by plugins (bug #19176)\n  * fix memory leaks in perl and python plugins (bug #19163)\n  * fix permissions on \"dcc\" and \"logs\" directories (bug #18978)\n  * fix crash when /away command is issued with no server connection (bug #18839)\n  * fix crash when closing a buffer opened on many windows\n  * fix freeze with SSL server when disconnecting after connection loss (bug #18735)\n\nDocumentation::\n\n  * add Scots quickstart guide\n\n[[v0.2.3]]\n== Version 0.2.3 (2007-01-10)\n\nBug fixes::\n\n  * fix display bugs with nicklist at top/bottom when look_nicklist_separator is OFF (bug #18737)\n  * fix iconv problem, causing truncated words when using iso locale\n  * fix topic scroll when topic has multi-bytes chars\n  * fix bugs with charset: now decodes/encodes nicks and channels in IRC messages (bug #18716)\n\nBuild::\n\n  * fix compilation problem with iconv under FreeBSD\n\n[[v0.2.2]]\n== Version 0.2.2 (2007-01-06)\n\nNew features::\n\n  * add anti-flood option (irc_anti_flood) (task #5442)\n  * plugins: \"add_message_handler\" now accepts \"*\" for all IRC messages\n  * add keys (kbd:[F9] / kbd:[F10]) to scroll topic (task #6030)\n  * add auto completion with channels and filenames (task #5423)\n  * add option \"look_nicklist_separator\" (task #5437)\n  * add \"irc_send_unknown_commands\" option to send unknown commands to IRC server (OFF by default) (task #5947)\n  * /charset command and charset conversions now made by \"charset\" plugin\n  * add filename completion (task #5425)\n  * add \"modifier\" in plugins API\n  * improve /plugin command\n  * add date in plugin function get_buffer_data\n  * add more values for config boolean values: y/true/t/1 and n/false/f/0\n\nBug fixes::\n\n  * fix bug with status bar (missing refresh) when closing a buffer\n  * fix bug with use of first buffer for a channel if not connected to server (now allowed only for a server buffer)\n  * fix refresh bug with private buffer title\n  * fix bug with nick completion in command arguments (now uses option look_nick_completion_ignore)\n  * fix display bug with color for first line on screen (bug #17719)\n  * fix bug with set_config function in plugins API (bug #18448)\n  * fix memory leak in keyboard input\n  * fix refresh bug when changing config options if window is split\n  * add space between chat and nicklist when position is \"right\" (bug #17852)\n  * fix bug with DCC SEND when filename begins with \"~\"\n  * fix display bug in status bar, wrong length when using UTF-8\n  * fix bug with ignore: now any IRC command is allowed\n  * fix crash with kbd:[Ctrl+t] (transpose) and one char on line (bug #18153)\n  * fix bug on ignore with \"mode\" IRC command (bug #18058)\n  * fix crash when loading ruby script if file does not exist, with Ruby >= 1.9 only (bug #18064)\n  * mode changes with /op, /deop, /voice, /devoice, /halfop, /dehalfop are now sent in one mode command to server (task #5968)\n  * fix bug with /alias and arguments (like $1), now text after argument(s) is used (bug #17944)\n  * fix minor display bug with special chars on some arch like PPC\n\nBuild::\n\n  * fix some portability bugs (patch #5271)\n  * fix iconv detection for BSD (patch #5456)\n  * fix typo in configure.in (bash specific test) (patch #5450)\n\n[[v0.2.1]]\n== Version 0.2.1 (2006-10-01)\n\nNew features::\n\n  * command \"/away -all\" now allowed when not connected to current server\n  * new signals handled: SIGTERM and SIGHUP (received when terminal is closed): clean WeeChat quit (send quit to irc servers then quit WeeChat)\n  * add some new default key bindings for existing keys (for some OS)\n  * command /key now OK with one argument (key name): display key if found\n  * add current channel completion for /ctcp command\n  * values yes/no accepted (as on/off) for config boolean values (task #5454)\n  * add server default notify level (set by /buffer notify on server buffer) (task #5634)\n  * add special vars $nick/$channel/$server for server_command, alias and plugin command handlers\n  * add arguments $1,$2,..,$9 and $* for alias (task #5831)\n  * add hotlist in session file when using /upgrade command (task #5449)\n\nBug fixes::\n\n  * fix crash for DCC receiver when resuming a file (bug #17885)\n  * fix DCC error for sender when receiver cancels DCC (bug #17838)\n  * fix random crash with /upgrade command (error when loading buffers)\n  * fix buffer search by server/channel: now if only channel is specified, a channel of another server can be found\n  * fix highlight for DCC, invite and notice: when a window is displaying buffer, there's no highlight\n  * fix bug with CTCP VERSION sent on channels (bug #17547)\n  * fix bugs in get_buffer_data which breaks the retrieval of buffer content (perl, lua)\n  * fix nicklist display bug when top/bottom (not enough lines) (bug #17537)\n  * fix bug with auto-rejoin of keyed channels (bug #17534)\n  * add default nick completion when line starts with \"//\" (bug #17535)\n  * fix crashes with /buffer and /charset commands when not connected to any server (bug #17525)\n  * fix nick refresh problem with unrealircd specific modes: chan owner (~) and chan admin (&) (bug #17340)\n\n[[v0.2.0]]\n== Version 0.2.0 (2006-08-19)\n\nNew features::\n\n  * add \"C\"lear option on IRC raw buffer\n  * IRC raw buffer now uses join/part prefix with color to display messages\n  * add send of \"quit\" message to server when using /disconnect\n  * add \"%m\" for completion with self nick (on current server)\n  * add missing IRC commands (310, 326, 329, 338)\n  * improve DCC speed (up to x5 on LAN) by forking for DCC files and a new option \"dcc_fast_send\" (does not wait for ACK) (task #5758)\n  * add \"look_save_on_exit\" option (patch from Emanuele Giaquinta)\n  * add new functions in plugin/script API: get window info, get buffer info, get buffer content\n  * add color encoding for some commands like /me\n  * add aspell plugin\n\nBug fixes::\n\n  * fix \"wallops\" command when received, now displayed by WeeChat (bug #17441)\n  * fix /wallops command (now many words are correctly sent)\n  * fix command 348 (channel exception list, received by /mode #chan e)\n  * add missing modes (channel & user), now all modes are allowed (bug #16606)\n  * fix DCC restore after /upgrade (order is now correctly saved)\n  * fix away after server disconnection (now away is set again when reconnecting) (bug #16359)\n  * fix DCC file connection problem (connection from receiver to sender)\n  * fix crash when purging DCC with high number of DCC (> window size)\n  * fix completion for command handlers (now empty completion_template means nick completion, \"-\" string means no completion at all)\n  * fix nick alignment problem when look_nickmode is off\n  * add generic function for incoming numeric IRC commands (bug #16611)\n  * fix crash when doing \"/part something\" on a server buffer (bug #17201)\n  * charsets are now checked when set by /charset command\n  * fix crash on DCC buffer under Darwin 8 (bug #17115)\n  * fix bug with spaces in script names (bug #16957)\n  * fix random crash when \"MODE #chan -l\" is received\n  * fix bug in IRC parser (random crash with malformed IRC messages)\n  * fix refresh bugs when terminal is resized: too many refreshes, display bug with split windows\n  * case ignored for channel names in charset options (bug #16858)\n  * fix crash when setting look_one_server_buffer to ON (bug #16932)\n  * fix display bug with special char (bug #16732)\n  * rename plugins names (remove \"lib\" prefix in name)\n  * fix crash when closing DCC/raw buffer if 2 are open (bug #16808)\n  * fix crashes with DCC chat remove/purge on DCC view (bug #16775)\n  * fix bug with connection to bnc (bug #16760)\n  * command /save now writes plugins options (~/.weechat/plugins.rc)\n  * fix crash with register function in plugin scripts (bug #16701)\n  * fix random crash at exit (/quit or /upgrade) with split windows\n\nDocumentation::\n\n  * add Polish, Russian and Czech quickstart guide\n\nBuild::\n\n  * add configure option for doc XSL prefix (bug #16991)\n\n[[v0.1.9]]\n== Version 0.1.9 (2006-05-25)\n\nNew features::\n\n  * add backtrace when WeeChat crashes, log file automatically renamed\n  * add new key to find previous completion (kbd:[Shift+Tab] by default)\n  * add missing IRC commands (006, 007, 290, 292, 310, 379, 437, 974)\n  * add new option to customize input prompt\n  * add nick modes\n  * add hostnames associated to nicks (available for /ban completion)\n  * add \"+p\" mode for channels, fix mode display in status bar\n  * add nick alignment options\n  * add keyboard handler to plugin API\n  * improve script plugin loader\n  * add hostname/IP option for connection to server\n  * add /setp command (set plugin options)\n  * aliases are executed before WeeChat/IRC commands, add /builtin command\n  * add /cycle command, /part command does close buffer any more\n\nInternationalization::\n\n  * add Russian translations (thanks to Pavel Shevchuk)\n\nBug fixes::\n\n  * fix /squery command (message sent to server, now OK with more than two arguments)\n  * fix /alias command (with an alias name, display content)\n  * add lock for log file (~/.weechat/weechat.log), only one WeeChat process can use this file (bug #16382)\n  * fix crash with malformed UTF-8 strings\n  * fix crash with ncurses color when too many colors defined in ncurses (bug #16556)\n  * fix bug with long outgoing IRC messages (> 512 bytes) (bug #16358)\n  * fix Ruby crash when handler does not return OK or KO (bug #16552)\n  * fix UTF-8 display bug with chars using more than one cell on screen (bug #16356)\n  * fix display bug with DCC file size when > 1 GB\n  * fix refresh bug (deadlock in curses) when terminal is resized (bug #16542)\n  * fix nicklist sort bug\n  * fix crash when multiple pv have same name: now it's forbidden and pv buffer is not renamed (when a nick changes) if another exists with same name (bug #16369)\n  * command /clear [-all] now clears hotlist\n  * fix crash after /upgrade if a line in history is empty (bug #16379)\n  * fix many crashes with DCC chat (bug #16416)\n  * fix commands 332, 333 (/topic now OK when channel is not opened)\n  * remove color encoding and charset conversion for commands (only allowed in text sent to channel/private)\n  * fix /names command: now displays result when not on a channel\n  * fix refresh bug (too many refresh) when terminal is resized\n  * fix nicklist display bugs when on top or bottom of chat window\n  * fix high CPU usage when running under a Screen that has been killed\n\nDocumentation::\n\n  * add German doc (thanks to Frank Zacharias)\n\nBuild::\n\n  * fix --disable-plugins option in configure script\n  * improve Lua detection (bug #16574)\n\n[[v0.1.8]]\n== Version 0.1.8 (2006-03-18)\n\nNew features::\n\n  * improve alias completion (now uses target command for completion)\n  * add missing IRC command (487)\n  * add inactivity time, available for plugins via get_info(\"inactivity\")\n  * add keys kbd:[Alt+Home] / kbd:[Alt+End] to scroll top/bottom, kbd:[Alt+F11] / kbd:[Alt+F12] to scroll nicklist top/bottom\n  * add special names for plugin message handlers: weechat_pv, weechat_highlight, weechat_ctcp, weechat_dcc\n  * add IRC raw data buffer (new key: kbd:[Alt+j], kbd:[Alt+r])\n  * add new plugins functions: add_timer_handler, remove_timer_handler, remove_infobar\n  * plugin messages handlers now called when message is ignored (by /ignore)\n  * new behavior for messages ignored by a message handler: now WeeChat executes standard handler, treating message as \"ignored\"\n  * many commands allowed for aliases\n  * many commands allowed when connecting to server\n  * add Lua script plugin\n  * add functions in plugins API: get_server_info, free_server_info, get_channel_info, free_channel_info, get_nick_info, free_nick_info\n  * add option \"look_nick_complete_first\" (patch from Gwenn)\n  * add option \"look_open_near_server\" (patch from Gwenn)\n  * add new scroll keys for a few lines up/down (default: kbd:[Alt+PgUp] / kbd:[Alt+PgDn]) (patch from Pistos)\n  * add new option \"irc_away_check_max_nicks\" to disable away check on channels with high number of nicks (patch from Gwenn)\n  * add new command line argument for setting WeeChat home dir (-d or --dir) (patch from Gwenn)\n  * add option \"irc_show_away_once\", to show away message only once in pv\n\nInternationalization::\n\n  * add partial Hungarian translations\n\nBug fixes::\n\n  * improve Ruby plugin\n  * fix /set command when internal server name contains one or many dots\n  * fix get_info plugin API function when no server at all is opened\n  * fix display bug when top of buffer is displayed and first line is removed (according to \"history_max_lines\" setting)\n  * fix /mode command output\n  * fix completion problem in private with nicks\n  * script plugins now load scripts in WeeChat system share directory\n  * /msg command does not open any buffer any more\n  * fix crash when using global history (when older entry is removed)\n  * fix display bug with /kill command\n  * fix bug with /upgrade and servers buffer\n  * fix bug with get_dcc_info plugin interface function\n  * fix bug with charset in infobar highlights\n  * fix bug with buffer detection in plugins/scripts commands\n  * fix bug with /history command\n\n[[v0.1.7]]\n== Version 0.1.7 (2006-01-14)\n\nNew features::\n\n  * remove \"irc_default_msg_away\" setting, for RFC 2812 conformity (/away command without argument only removes away status), new values for \"irc_display_away\" (off, local, channel)\n  * add color for window separators (when split)\n  * add completion system for plugins/scripts commands\n  * add charset by server and channel, new command: /charset\n  * add Ruby script plugin\n  * add /upgrade command\n  * add ETA (Estimated Time of Arrival) for DCC files\n  * /nick command is now allowed when not connected to server\n  * add server/channel argument to /buffer command for jumping to buffer\n  * add new keys for switching to other windows: kbd:[Alt+w], kbd:[Alt+Arrow]\n  * add new keys for scrolling to previous/next highlight: kbd:[Alt+p] / kbd:[Alt+n]\n  * add \"read marker\": an indicator for first unread line in a server or channel buffer (new key kbd:[Alt+u] to scroll to marker)\n  * new window management: custom size for windows, auto resize when terminal is resized\n  * add /history command\n\nBug fixes::\n\n  * fix msg command (now allowed in private buffer with \"*\" as target)\n  * fix refresh bug with Solaris when term size is changed\n  * fix plugins autoload\n  * fix display bug in chat window when a message length equals to window width\n  * fix infinite loop when resizing term to small size\n\nBuild::\n\n  * replace Texinfo doc by XML Docbook\n\n[[v0.1.6]]\n== Version 0.1.6 (2005-11-11)\n\nNew features::\n\n  * new color management system, IRC colors are now correctly displayed and can be removed by new options irc_colors_receive and irc_colors_send\n  * add setting for having one server buffer for all servers (look_one_server_buffer)\n  * add setting for ignoring some chars when completing nicks\n  * signal SIGPIPE is now ignored\n  * add partial match for highlights\n  * add dcc_own_ip and dcc_port_range settings\n  * full UTF-8 support, auto-detection of UTF-8 usage (locale)\n  * add \"Day changed to [date]\" message when day changes\n  * new plugin interface, rewritten from scratch: now loads dynamic C library, and perl/python are script plugins\n  * log options (for server/channel/private) can now be set while WeeChat is running\n  * add channel modes +e and +f\n  * add some missing IRC commands, fix command 367\n  * add colors for input buffer and current channel of status bar\n  * add online help for config options (with /set full_option_name)\n  * enhanced \"smart\" hotlist, with names (new options: look_hotlist_names_{count|level|length})\n\nBug fixes::\n\n  * fix scroll problem when one line is bigger than screen size\n  * fix IRC message parser bug\n\n[[v0.1.5]]\n== Version 0.1.5 (2005-09-24)\n\nNew features::\n\n  * add /ame command (send CTCP action to all channels of all connected servers)\n  * add setting \"irc_notice_as_pv\" to see notices as pv\n  * add nicks colors in setup file\n  * add some missing IRC commands\n  * add /ignore and /unignore commands\n  * signal SIGQUIT is now ignored\n  * jump to next server now saves current channel buffer for each server\n  * add keys kbd:[Ctrl+Up] / kbd:[Ctrl+Down] to call previous/next command in global history (common to all buffers)\n\nBug fixes::\n\n  * fix DCC bug: delete failed file only if really empty (on disk)\n  * fix IRC message parser bug\n  * fix scroll problem (screen moving when scrolling and new line displayed)\n  * fix infinite loop when scrolling back and displaying long lines\n  * fix crash when closing a buffer used by more than one window\n  * fix DCC display bug (now decodes string according to charset)\n  * fix bug with strings comparison (str[n]casecmp) and some locales (like Turkish), now using ASCII comparison (thanks to roktas)\n  * fix refresh bug when one line is bigger than screen size\n  * fix look_nicklist_min_size and look_nicklist_max_size options\n  * fix refresh bug when changing channel modes\n\n[[v0.1.4]]\n== Version 0.1.4 (2005-07-30)\n\nNew features::\n\n  * join and part/quit prefixes (arrows) now displayed with different colors\n  * add \"irc_highlight\" setting, to get highlight with any word\n  * add /amsg command (send text to all channels of all connected servers)\n  * add color for private in hotlist (different than color for highlight)\n  * add DCC resume and timeout\n  * add function for Perl/Python to get DCC list\n  * new keyboard management: keys are setup in config file, add new command /key, add some new default keys, kbd:[Alt+k] is used to grab key (useful for /key command)\n  * add seconds in infobar time (optional thanks to new setting)\n  * add auto-prefix with \"#\" for channels (if no prefix found), with /join command\n\nBug fixes::\n\n  * fix auto-rejoin for channels with key\n  * fix /ctcp command (now any command/data allowed)\n  * fix SIGSEGV handler (now write a core file by aborting program)\n  * fix statusbar & infobar background refresh problem with some systems\n  * fix FIFO pipe (command now authorized on a buffer not connected to an IRC server)\n  * topic completion now decodes UTF-8 string\n  * fix bug with IRC URL on command line (irc://)\n  * fix some curses refreshes\n\n[[v0.1.3]]\n== Version 0.1.3 (2005-07-02)\n\nNew features::\n\n  * proxy support (http, socks4, socks5) with authentication (http, socks5) and ipv6 support (client to proxy)\n  * add completion for config option (with /set command)\n  * commands from users outside channel now authorized (if special user or channel without \"n\" flag)\n  * add IPv6 support\n  * kill command now received and displayed\n  * add SSL support\n  * channel notify levels are saved in config file (new option \"server_notify_levels\" for server sections)\n  * part message now accepts %v (replaced by WeeChat version), like quit message\n\nBug fixes::\n\n  * errors while loading perl scripts are now displayed in server buffer (instead of current buffer)\n  * in python scripts, all messages written in stdin and stderr are redirected in server buffer\n  * fix a filename error while loading a python script manually\n  * fix plugins print and prnt functions: now OK for writing on server buffers\n  * fix color problem with new libcurses version\n  * fix crash when using kbd:[Alt+s] or kbd:[Alt+x] on DCC buffer (kbd:[Alt+d])\n  * fix startup crash when config file (~/.weechat/weechat.rc) is not found\n\nBuild::\n\n  * improve Perl/Python libs detection for ./configure script\n\n[[v0.1.2]]\n== Version 0.1.2 (2005-05-21)\n\nNew features::\n\n  * add Python plugin support, improve Perl interface (and now Perl/Python libraries are checked by configure script)\n  * add nicklist scroll keys (kbd:[Alt+Home] / kbd:[Alt+End] / kbd:[Alt+PgUp] / kbd:[Alt+PgDn] or kbd:[F11] / kbd:[F12])\n  * add transfer rate for DCC files\n  * add \"-all\" option for /nick command\n  * buffers timestamp can now be changed (new option in config file)\n  * add missing IRC commands (307, 341, 485, 671)\n\nBug fixes::\n\n  * fix nicklist sort\n  * fix crash when purging old DCC\n  * fix crash with 64-bits arch (like AMD64) when converting UTF-8\n\nBuild::\n\n  * WeeChat now OK under *BSD and macOS\n\n[[v0.1.1]]\n== Version 0.1.1 (2005-03-20)\n\nNew features::\n\n  * add nicks count for channel buffers\n  * add FIFO pipe for remote control\n  * add crash dump when WeeChat receives SIGSEGV (Segmentation fault)\n  * add new display engine: doesn't cut words at end of lines\n  * add DCC send and DCC chat\n  * add /halfop & /dehalfop commands, fix halfop display bug in nicklist\n  * add /ban, /unban and /kickban commands\n  * add --irc-commands and --weechat-commands command line options\n  * connection to IRC server is now made by child process (non blocking)\n  * add support for UnrealIrcd (\"~\" for chan owner, \"&\" for chan admin)\n  * new key for window switch (now: kbd:[F5] / kbd:[F6] = switch buffer, kbd:[F7] / kbd:[F8] = switch window)\n  * on server buffer, only server messages are logged\n  * improve /help command output\n  * plugins messages are logged with new config option (log_plugin_msg)\n\nInternationalization::\n\n  * add Spanish translations\n\nBug fixes::\n\n  * fix /kick command\n  * fix /invite command (and now invite requests are displayed)\n  * fix /buffer close command (now OK when disconnected from server)\n  * fix display bugs when many windows are opened\n\n[[v0.1.0]]\n== Version 0.1.0 (2005-02-12)\n\nNew features::\n\n  * improve /window command: now split and merge are OK\n  * away nicks are now displayed with another color (new option: \"irc_away_check\")\n  * add away indicator in status bar\n  * add lag indicator (and auto-disconnect after a delay if important lag)\n  * improve completion: now completes commands arguments (IRC and internal), when only one completion matches, completion mechanism is stopped (to complete command argument for example)\n  * improve /set command: empty strings are allowed, new colors, server options can be changed while WeeChat is running\n  * add default away/part/quit messages in config file\n  * new [irc] section in config file, move option \"look_display_away\" to \"irc_display_away\"\n  * server messages & errors are all prefixed (by 3 chars, like \"-@-\")\n  * add new options for charset (UTF-8 support): look_charset_decode, look_charset_encode and look_charset_internal\n\nBug fixes::\n\n  * fix many memory leaks\n  * fix colors bug: remove \"gray\" color (replaced by \"default\"), colors are OK when terminal has white (or light) background\n  * fix crash when resizing terminal to small size\n  * fix crash when multiple servers and big messages received from server\n  * fix crash when closing some private buffers\n  * fix crash when unknown section with option(s) in config file\n  * fix /op, /deop, /voice, /devoice (now OK with many nicks)\n  * fix /me command (now OK without parameter)\n  * fix /away command (now OK if not away)\n  * logs are now disabled by default (server/channel/private)\n\n[[v0.0.9]]\n== Version 0.0.9 (2005-01-01)\n\nNew features::\n\n  * auto-reconnection to server (new options: server_autoreconnect (on/off), server_autoreconnect_delay (in seconds))\n  * new command \"/buffer close\" (close any server/channel/private buffer)\n  * new keys: kbd:[Ctrl+a] (home), kbd:[Ctrl+e] (end), kbd:[Ctrl+w] (same as kbd:[Ctrl+Backspace]), kbd:[Alt+s] (switch to server buffer), kbd:[Alt+x] (switch to first channel of next server)\n  * add new config option: \"server_command_delay\" (delay in seconds after startup command for each server)\n\nBug fixes::\n\n  * fix major bug when socket is closed by server (100% CPU usage), and disconnections are now OK (all channels are \"closed\", history is still visible, and buffer will be used again if reconnection to server)\n  * option \"look_remove_colors_from_msgs\" is now working\n  * fix display of nick mode changes\n  * fix /notice command (and display when received from server)\n\n[[v0.0.8]]\n== Version 0.0.8 (2004-10-30)\n\nNew features::\n\n  * nickserv passwords hidden (new config option: log_hide_nickserv_pwd on/off)\n  * auto-rejoin channels when kicked (new config option: server_autorejoin on/off)\n  * add IRC::command function for Perl scripts\n  * /buffer command developed (buffers list, move and notify)\n  * logging buffers to disk (server/channel/private according to user preferences)\n  * add config option \"look_display_away\" to announce away in channels\n  * DCC file receive OK (kbd:[Alt+d] for DCC view)\n  * add key kbd:[Ctrl+l] (`L`) for redrawing terminal\n  * add key kbd:[Alt+r] for clearing hotlist\n\nBug fixes::\n\n  * fix /kick command: now OK with many words as reason\n  * fix bug when adding alias with same name as other\n  * fix crash when resizing terminal to very small size\n  * \"-MORE-\" message is now erased when switching to another buffer\n  * /query command now reopens private buffer if already opened\n\n[[v0.0.7]]\n== Version 0.0.7 (2004-08-08)\n\nNew features::\n\n  * new \"col_status_delimiters\" config option\n  * add command /buffer , buffers ordered by number, auto-jump to active buffers (kbd:[Alt+a]), jump to buffers by number (kbd:[Alt+0...9])\n  * add command /window, split terminal horizontally/vertically\n  * unique color for each nick (based on nickname)\n  * add history limit (text buffer and commands)\n\nBug fixes::\n\n  * action messages are now considered as messages, not crappy joins/parts\n  * fix display bug when nicklist is displayed at bottom of screen\n\nBuild::\n\n  * replace --enable-debug with --with-debug option for ./configure\n\n[[v0.0.6]]\n== Version 0.0.6 (2004-06-05)\n\nNew features::\n\n  * improve channel highlight (priority to message vs join/part)\n  * add command /query (starts private conversation)\n  * add IRC messages 476, 477\n\nBug fixes::\n\n  * fix bug when opened private win and remote user changes his nick\n  * /mode command is now OK and channel flags are displayed in status bar\n  * fix display bug (text was blinking when scrolling)\n  * CTCP Version reply is now in English only and doesn't show host (security reason)\n\n[[v0.0.5]]\n== Version 0.0.5 (2004-02-07)\n\nNew features::\n\n  * /set command to modify config options when WeeChat is running\n  * URL command line parameter to connect to server(s)\n  * new Perl script function to display message in info bar (\"IRC::print_infobar\")\n  * info bar highlight notifications\n  * add info bar timestamp in config (\"look_infobar_timestamp\")\n  * add info bar (optional, \"look_infobar\" to enable it, \"on\" by default)\n  * add -c (or --config) command line parameter to see config file options\n\nBug fixes::\n\n  * fix look_nicklist config option, now enables/disables nicklist\n  * secure code to prevent buffer overflows and memory leaks\n  * fix QUIT IRC command: now sent to all connected servers (not only current)\n  * fix crash with /oper command\n  * for default config file, nick is now based on un*x username\n  * fix crash when config file cannot be written\n  * add highlight on action messages\n\n[[v0.0.4]]\n== Version 0.0.4 (2004-01-01)\n\nNew features::\n\n  * add Perl plugin\n\nBug fixes::\n\n  * fix switch to private buffer\n  * add highlight when our nick is written in a channel/private window\n  * catch kbd:[Ctrl+c] (ignored)\n\nBuild::\n\n  * debug messages can be enabled via ./configure --enable-debug option\n\n[[v0.0.3]]\n== Version 0.0.3 (2003-11-03)\n\nNew features::\n\n  * add new IRC commands: stats, service, squit, motd, lusers, links, time, trace, admin, info, servlist, squery, who, whowas, die, summon, users, wallops, userhost, ison, ctcp ping\n\nInternationalization::\n\n  * add French translations\n\nBug fixes::\n\n  * for sort of nicks (op, halfop, voice, other)\n  * fix problem with \"353\" IRC message (nicklist)\n  * fix problem when nick is truncated by server\n  * fix crash when entering text without any server connection\n  * fix crash when /set command is executed\n  * fix display bug (text was blinking when scrolling)\n  * code cleanup\n\nBuild::\n\n  * add ./configure script to build WeeChat\n\n[[v0.0.2]]\n== Version 0.0.2 (2003-10-05)\n\nNew features::\n\n  * add commands /rehash and /restart\n  * and command and auto-join channels when connected to server\n  * new commands for alias: /alias, /unalias (new section in config file)\n  * config is now saved automatically when quitting WeeChat, add /save command\n  * new commands for servers: /server, /connect, /disconnect\n  * add autoconnect flag for each server in config file\n  * add \"look_set_title\" option in config file\n  * term window title is modified with WeeChat name and version\n  * CTCP version returns more info (about OS)\n\nBug fixes::\n\n  * fix nicklist display bug\n  * fix crash when sending command which can only be received\n\n[[v0.0.1]]\n== Version 0.0.1 (2003-09-27)\n\nNew features::\n\n  * ncurses GUI with color output\n  * multi-servers\n  * channel windows, with nicklist (position: top, bottom, left or right)\n  * private windows\n  * IRC commands: away, ctcp, deop, devoice, invite, join, kick, kill, list, me, mode, msg, names, nick, notice, op, oper, part, ping, pong, quit, quote, topic, version, voice, whois\n  * WeeChat commands: clear, help, set (partial)\n  * many config options\n  * log file (~/.weechat/weechat.log)\n  * nicklist can be moved on top, bottom, left or right of window\n", "/*\n * irc-nick.c - nick management for IRC plugin\n *\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-nick.h\"\n#include \"irc-color.h\"\n#include \"irc-config.h\"\n#include \"irc-mode.h\"\n#include \"irc-server.h\"\n#include \"irc-channel.h\"\n\n\n/*\n * Checks if a nick pointer is valid.\n *\n * Returns:\n *   1: nick exists in channel\n *   0: nick does not exist in channel\n */\n\nint\nirc_nick_valid (struct t_irc_channel *channel, struct t_irc_nick *nick)\n{\n    struct t_irc_nick *ptr_nick;\n\n    if (!channel || !nick)\n        return 0;\n\n    for (ptr_nick = channel->nicks; ptr_nick; ptr_nick = ptr_nick->next_nick)\n    {\n        if (ptr_nick == nick)\n            return 1;\n    }\n\n    /* nick not found */\n    return 0;\n}\n\n/*\n * Checks if string is a valid nick string (RFC 1459).\n *\n * Returns:\n *   1: string is a valid nick\n *   0: string is not a valid nick\n */\n\nint\nirc_nick_is_nick (const char *string)\n{\n    const char *ptr;\n\n    if (!string || !string[0])\n        return 0;\n\n    /* first char must not be a number or hyphen */\n    ptr = string;\n    if (strchr (\"0123456789-\", *ptr))\n        return 0;\n\n    while (ptr && ptr[0])\n    {\n        if (!strchr (IRC_NICK_VALID_CHARS, *ptr))\n            return 0;\n        ptr++;\n    }\n\n    return 1;\n}\n\n/*\n * Finds a color code for a nick (according to nick letters).\n *\n * Returns a WeeChat color code (that can be used for display).\n */\n\nchar *\nirc_nick_find_color (const char *nickname)\n{\n    return weechat_info_get (\"nick_color\", nickname);\n}\n\n/*\n * Finds a color name for a nick (according to nick letters).\n *\n * Returns the name of a color (for example: \"green\").\n */\n\nchar *\nirc_nick_find_color_name (const char *nickname)\n{\n    return weechat_info_get (\"nick_color_name\", nickname);\n}\n\n/*\n * Sets current prefix, using higher prefix set in prefixes.\n */\n\nvoid\nirc_nick_set_current_prefix (struct t_irc_nick *nick)\n{\n    char *ptr_prefixes;\n\n    if (!nick)\n        return;\n\n    nick->prefix[0] = ' ';\n    for (ptr_prefixes = nick->prefixes; ptr_prefixes[0]; ptr_prefixes++)\n    {\n        if (ptr_prefixes[0] != ' ')\n        {\n            nick->prefix[0] = ptr_prefixes[0];\n            break;\n        }\n    }\n}\n\n/*\n * Sets/unsets a prefix in prefixes.\n *\n * If set == 1, sets prefix (prefix is used).\n * If set == 0, unsets prefix (space is used).\n */\n\nvoid\nirc_nick_set_prefix (struct t_irc_server *server, struct t_irc_nick *nick,\n                     int set, char prefix)\n{\n    int index;\n\n    if (!nick)\n        return;\n\n    index = irc_server_get_prefix_char_index (server, prefix);\n    if (index >= 0)\n    {\n        nick->prefixes[index] = (set) ? prefix : ' ';\n        irc_nick_set_current_prefix (nick);\n    }\n}\n\n/*\n * Sets prefixes for nick.\n */\n\nvoid\nirc_nick_set_prefixes (struct t_irc_server *server, struct t_irc_nick *nick,\n                       const char *prefixes)\n{\n    const char *ptr_prefixes;\n\n    if (!nick)\n        return;\n\n    /* reset all prefixes in nick */\n    memset (nick->prefixes, ' ', strlen (nick->prefixes));\n\n    /* add prefixes in nick */\n    if (prefixes)\n    {\n        for (ptr_prefixes = prefixes; ptr_prefixes[0]; ptr_prefixes++)\n        {\n            irc_nick_set_prefix (server, nick, 1, ptr_prefixes[0]);\n        }\n    }\n\n    /* set current prefix */\n    irc_nick_set_current_prefix (nick);\n}\n\n/*\n * Sets host for nick.\n */\n\nvoid\nirc_nick_set_host (struct t_irc_nick *nick, const char *host)\n{\n    if (!nick)\n        return;\n\n    /* if host is the same, just return */\n    if ((!nick->host && !host)\n        || (nick->host && host && strcmp (nick->host, host) == 0))\n    {\n        return;\n    }\n\n    /* update the host in nick */\n    if (nick->host)\n        free (nick->host);\n    nick->host = (host) ? strdup (host) : NULL;\n}\n\n/*\n * Checks if nick is \"op\" (or better than \"op\", for example channel admin or\n * channel owner).\n *\n * Returns:\n *   1: nick is \"op\" (or better)\n *   0: nick is not op\n */\n\nint\nirc_nick_is_op (struct t_irc_server *server, struct t_irc_nick *nick)\n{\n    int index;\n\n    if (nick->prefix[0] == ' ')\n        return 0;\n\n    index = irc_server_get_prefix_char_index (server, nick->prefix[0]);\n    if (index < 0)\n        return 0;\n\n    return (index <= irc_server_get_prefix_mode_index (server, 'o')) ? 1 : 0;\n}\n\n/*\n * Checks if nick prefixes contains prefix for a given mode.\n *\n * For example if prefix_mode is 'o', searches for '@' in nick prefixes.\n *\n * Returns:\n *   1: prefixes contains prefix for the given mode\n *   0: prefixes does not contain prefix for the given mode.\n */\n\nint\nirc_nick_has_prefix_mode (struct t_irc_server *server, struct t_irc_nick *nick,\n                          char prefix_mode)\n{\n    char prefix_char;\n\n    prefix_char = irc_server_get_prefix_char_for_mode (server, prefix_mode);\n    if (prefix_char == ' ')\n        return 0;\n\n    return (strchr (nick->prefixes, prefix_char)) ? 1 : 0;\n}\n\n/*\n * Gets nicklist group for a nick.\n */\n\nstruct t_gui_nick_group *\nirc_nick_get_nicklist_group (struct t_irc_server *server,\n                             struct t_gui_buffer *buffer,\n                             struct t_irc_nick *nick)\n{\n    int index;\n    char str_group[2];\n    const char *prefix_modes;\n    struct t_gui_nick_group *ptr_group;\n\n    if (!server || !buffer || !nick)\n        return NULL;\n\n    ptr_group = NULL;\n    index = irc_server_get_prefix_char_index (server, nick->prefix[0]);\n    if (index < 0)\n    {\n        ptr_group = weechat_nicklist_search_group (buffer, NULL,\n                                                   IRC_NICK_GROUP_OTHER_NAME);\n    }\n    else\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        str_group[0] = prefix_modes[index];\n        str_group[1] = '\\0';\n        ptr_group = weechat_nicklist_search_group (buffer, NULL, str_group);\n    }\n\n    return ptr_group;\n}\n\n/*\n * Gets name of prefix color for a nick.\n */\n\nconst char *\nirc_nick_get_prefix_color_name (struct t_irc_server *server, char prefix)\n{\n    static char *default_color = \"\";\n    const char *prefix_modes, *color;\n    char mode[2];\n    int index;\n\n    if (irc_config_hashtable_nick_prefixes)\n    {\n        mode[0] = ' ';\n        mode[1] = '\\0';\n\n        index = irc_server_get_prefix_char_index (server, prefix);\n        if (index >= 0)\n        {\n            prefix_modes = irc_server_get_prefix_modes (server);\n            mode[0] = prefix_modes[index];\n            color = weechat_hashtable_get (irc_config_hashtable_nick_prefixes,\n                                           mode);\n            if (color)\n                return color;\n        }\n\n        /* fallback to \"*\" if no color is found with mode */\n        mode[0] = '*';\n        color = weechat_hashtable_get (irc_config_hashtable_nick_prefixes,\n                                       mode);\n        if (color)\n            return color;\n    }\n\n    /* no color by default */\n    return default_color;\n}\n\n/*\n * Gets nick color for nicklist.\n */\n\nchar *\nirc_nick_get_color_for_nicklist (struct t_irc_server *server,\n                                 struct t_irc_nick *nick)\n{\n    static char *nick_color_bar_fg = \"bar_fg\";\n    static char *nick_color_self = \"weechat.color.chat_nick_self\";\n    static char *nick_color_away = \"weechat.color.nicklist_away\";\n\n    if (nick->away)\n        return strdup (nick_color_away);\n\n    if (weechat_config_boolean (irc_config_look_color_nicks_in_nicklist))\n    {\n        if (irc_server_strcasecmp (server, nick->name, server->nick) == 0)\n            return strdup (nick_color_self);\n        else\n            return irc_nick_find_color_name (nick->name);\n    }\n\n    return strdup (nick_color_bar_fg);\n}\n\n/*\n * Adds a nick to buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_add (struct t_irc_server *server,\n                       struct t_irc_channel *channel,\n                       struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n    char *color;\n\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    color = irc_nick_get_color_for_nicklist (server, nick);\n    weechat_nicklist_add_nick (channel->buffer, ptr_group,\n                               nick->name,\n                               color,\n                               nick->prefix,\n                               irc_nick_get_prefix_color_name (server, nick->prefix[0]),\n                               1);\n    if (color)\n        free (color);\n}\n\n/*\n * Removes a nick from buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_remove (struct t_irc_server *server,\n                          struct t_irc_channel *channel,\n                          struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    weechat_nicklist_remove_nick (channel->buffer,\n                                  weechat_nicklist_search_nick (channel->buffer,\n                                                                ptr_group,\n                                                                nick->name));\n}\n\n/*\n * Sets a property for nick in buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_set (struct t_irc_channel *channel,\n                       struct t_irc_nick *nick,\n                       const char *property, const char *value)\n{\n    struct t_gui_nick *ptr_nick;\n\n    ptr_nick = weechat_nicklist_search_nick (channel->buffer, NULL, nick->name);\n    if (ptr_nick)\n    {\n        weechat_nicklist_nick_set (channel->buffer, ptr_nick, property, value);\n    }\n}\n\n/*\n * Sets nick prefix colors in nicklist for all servers/channels.\n */\n\nvoid\nirc_nick_nicklist_set_prefix_color_all ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            for (ptr_nick = ptr_channel->nicks; ptr_nick;\n                 ptr_nick = ptr_nick->next_nick)\n            {\n                irc_nick_nicklist_set (ptr_channel, ptr_nick, \"prefix_color\",\n                                       irc_nick_get_prefix_color_name (ptr_server,\n                                                                       ptr_nick->prefix[0]));\n            }\n        }\n    }\n}\n\n/*\n * Sets nick colors in nicklist for all servers/channels.\n */\n\nvoid\nirc_nick_nicklist_set_color_all ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *color;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            for (ptr_nick = ptr_channel->nicks; ptr_nick;\n                 ptr_nick = ptr_nick->next_nick)\n            {\n                color = irc_nick_get_color_for_nicklist (ptr_server, ptr_nick);\n                irc_nick_nicklist_set (ptr_channel, ptr_nick, \"color\", color);\n                if (color)\n                    free (color);\n            }\n        }\n    }\n}\n\n/*\n * Adds a new nick in channel.\n *\n * Returns pointer to new nick, NULL if error.\n */\n\nstruct t_irc_nick *\nirc_nick_new (struct t_irc_server *server, struct t_irc_channel *channel,\n              const char *nickname, const char *host, const char *prefixes,\n              int away, const char *account, const char *realname)\n{\n    struct t_irc_nick *new_nick, *ptr_nick;\n    int length;\n\n    if (!nickname || !nickname[0])\n        return NULL;\n\n    if (!channel->nicks)\n        irc_channel_add_nicklist_groups (server, channel);\n\n    /* nick already exists on this channel? */\n    ptr_nick = irc_nick_search (server, channel, nickname);\n    if (ptr_nick)\n    {\n        /* remove old nick from nicklist */\n        irc_nick_nicklist_remove (server, channel, ptr_nick);\n\n        /* update nick prefixes */\n        irc_nick_set_prefixes (server, ptr_nick, prefixes);\n\n        /* add new nick in nicklist */\n        irc_nick_nicklist_add (server, channel, ptr_nick);\n\n        return ptr_nick;\n    }\n\n    /* alloc memory for new nick */\n    if ((new_nick = malloc (sizeof (*new_nick))) == NULL)\n        return NULL;\n\n    /* initialize new nick */\n    new_nick->name = strdup (nickname);\n    new_nick->host = (host) ? strdup (host) : NULL;\n    new_nick->account = (account) ? strdup (account) : NULL;\n    new_nick->realname = (realname) ? strdup (realname) : NULL;\n    length = strlen (irc_server_get_prefix_chars (server));\n    new_nick->prefixes = malloc (length + 1);\n    new_nick->prefix = malloc (2);\n    if (!new_nick->name || !new_nick->prefixes || !new_nick->prefix)\n    {\n        if (new_nick->name)\n            free (new_nick->name);\n        if (new_nick->host)\n            free (new_nick->host);\n        if (new_nick->account)\n            free (new_nick->account);\n        if (new_nick->realname)\n            free (new_nick->realname);\n        if (new_nick->prefixes)\n            free (new_nick->prefixes);\n        if (new_nick->prefix)\n            free (new_nick->prefix);\n        free (new_nick);\n        return NULL;\n    }\n    memset (new_nick->prefixes, ' ', length);\n    new_nick->prefixes[length] = '\\0';\n    new_nick->prefix[0] = ' ';\n    new_nick->prefix[1] = '\\0';\n    irc_nick_set_prefixes (server, new_nick, prefixes);\n    new_nick->away = away;\n    if (irc_server_strcasecmp (server, new_nick->name, server->nick) == 0)\n        new_nick->color = strdup (IRC_COLOR_CHAT_NICK_SELF);\n    else\n        new_nick->color = irc_nick_find_color (new_nick->name);\n\n    /* add nick to end of list */\n    new_nick->prev_nick = channel->last_nick;\n    if (channel->last_nick)\n        channel->last_nick->next_nick = new_nick;\n    else\n        channel->nicks = new_nick;\n    channel->last_nick = new_nick;\n    new_nick->next_nick = NULL;\n\n    channel->nicks_count++;\n\n    channel->nick_completion_reset = 1;\n\n    /* add nick to buffer nicklist */\n    irc_nick_nicklist_add (server, channel, new_nick);\n\n    /* all is OK, return address of new nick */\n    return new_nick;\n}\n\n/*\n * Changes nickname.\n */\n\nvoid\nirc_nick_change (struct t_irc_server *server, struct t_irc_channel *channel,\n                 struct t_irc_nick *nick, const char *new_nick)\n{\n    int nick_is_me;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* update nicks speaking */\n    nick_is_me = (irc_server_strcasecmp (server, new_nick, server->nick) == 0) ? 1 : 0;\n    if (!nick_is_me)\n        irc_channel_nick_speaking_rename (channel, nick->name, new_nick);\n\n    /* change nickname */\n    if (nick->name)\n        free (nick->name);\n    nick->name = strdup (new_nick);\n    if (nick->color)\n        free (nick->color);\n    if (nick_is_me)\n        nick->color = strdup (IRC_COLOR_CHAT_NICK_SELF);\n    else\n        nick->color = irc_nick_find_color (nick->name);\n\n    /* add nick in nicklist */\n    irc_nick_nicklist_add (server, channel, nick);\n}\n\n/*\n * Sets a mode for a nick.\n */\n\nvoid\nirc_nick_set_mode (struct t_irc_server *server, struct t_irc_channel *channel,\n                   struct t_irc_nick *nick, int set, char mode)\n{\n    int index;\n    const char *prefix_chars;\n\n    index = irc_server_get_prefix_mode_index (server, mode);\n    if (index < 0)\n        return;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* set flag */\n    prefix_chars = irc_server_get_prefix_chars (server);\n    irc_nick_set_prefix (server, nick, set, prefix_chars[index]);\n\n    /* add nick in nicklist */\n    irc_nick_nicklist_add (server, channel, nick);\n\n    if (irc_server_strcasecmp (server, nick->name, server->nick) == 0)\n    {\n        weechat_bar_item_update (\"input_prompt\");\n        weechat_bar_item_update (\"irc_nick\");\n        weechat_bar_item_update (\"irc_nick_host\");\n    }\n}\n\n/*\n * Removes a nick from a channel.\n */\n\nvoid\nirc_nick_free (struct t_irc_server *server, struct t_irc_channel *channel,\n               struct t_irc_nick *nick)\n{\n    struct t_irc_nick *new_nicks;\n\n    if (!channel || !nick)\n        return;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* remove nick */\n    if (channel->last_nick == nick)\n        channel->last_nick = nick->prev_nick;\n    if (nick->prev_nick)\n    {\n        (nick->prev_nick)->next_nick = nick->next_nick;\n        new_nicks = channel->nicks;\n    }\n    else\n        new_nicks = nick->next_nick;\n\n    if (nick->next_nick)\n        (nick->next_nick)->prev_nick = nick->prev_nick;\n\n    channel->nicks_count--;\n\n    /* free data */\n    if (nick->name)\n        free (nick->name);\n    if (nick->host)\n        free (nick->host);\n    if (nick->prefixes)\n        free (nick->prefixes);\n    if (nick->prefix)\n        free (nick->prefix);\n    if (nick->account)\n        free (nick->account);\n    if (nick->realname)\n        free (nick->realname);\n    if (nick->color)\n        free (nick->color);\n\n    free (nick);\n\n    channel->nicks = new_nicks;\n    channel->nick_completion_reset = 1;\n}\n\n/*\n * Removes all nicks from a channel.\n */\n\nvoid\nirc_nick_free_all (struct t_irc_server *server, struct t_irc_channel *channel)\n{\n    if (!channel)\n        return;\n\n    /* remove all nicks for the channel */\n    while (channel->nicks)\n    {\n        irc_nick_free (server, channel, channel->nicks);\n    }\n\n    /* remove all groups in nicklist */\n    weechat_nicklist_remove_all (channel->buffer);\n\n    /* should be zero, but prevent any bug :D */\n    channel->nicks_count = 0;\n}\n\n/*\n * Searches for a nick in a channel.\n *\n * Returns pointer to nick found, NULL if error.\n */\n\nstruct t_irc_nick *\nirc_nick_search (struct t_irc_server *server, struct t_irc_channel *channel,\n                 const char *nickname)\n{\n    struct t_irc_nick *ptr_nick;\n\n    if (!channel || !nickname)\n        return NULL;\n\n    for (ptr_nick = channel->nicks; ptr_nick;\n         ptr_nick = ptr_nick->next_nick)\n    {\n        if (irc_server_strcasecmp (server, ptr_nick->name, nickname) == 0)\n            return ptr_nick;\n    }\n\n    /* nick not found */\n    return NULL;\n}\n\n/*\n * Returns number of nicks (total, op, halfop, voice, normal) on a channel.\n */\n\nvoid\nirc_nick_count (struct t_irc_server *server, struct t_irc_channel *channel,\n                int *total, int *count_op, int *count_halfop, int *count_voice,\n                int *count_normal)\n{\n    struct t_irc_nick *ptr_nick;\n\n    (*total) = 0;\n    (*count_op) = 0;\n    (*count_halfop) = 0;\n    (*count_voice) = 0;\n    (*count_normal) = 0;\n    for (ptr_nick = channel->nicks; ptr_nick;\n         ptr_nick = ptr_nick->next_nick)\n    {\n        (*total)++;\n        if (irc_nick_is_op (server, ptr_nick))\n            (*count_op)++;\n        else\n        {\n            if (irc_nick_has_prefix_mode (server, ptr_nick, 'h'))\n                (*count_halfop)++;\n            else\n            {\n                if (irc_nick_has_prefix_mode (server, ptr_nick, 'v'))\n                    (*count_voice)++;\n                else\n                    (*count_normal)++;\n            }\n        }\n    }\n}\n\n/*\n * Sets/unsets away status for a nick.\n */\n\nvoid\nirc_nick_set_away (struct t_irc_server *server, struct t_irc_channel *channel,\n                   struct t_irc_nick *nick, int is_away)\n{\n    char *color;\n\n    if (is_away != nick->away)\n    {\n        nick->away = is_away;\n        color = irc_nick_get_color_for_nicklist (server, nick);\n        irc_nick_nicklist_set (channel, nick, \"color\", color);\n        if (color)\n            free (color);\n    }\n}\n\n/*\n * Gets nick mode for display (color + mode).\n *\n * If prefix == 1, returns string for display in prefix, otherwise returns\n * string for display in action message (/me).\n */\n\nconst char *\nirc_nick_mode_for_display (struct t_irc_server *server, struct t_irc_nick *nick,\n                           int prefix)\n{\n    static char result[32];\n    char str_prefix[2];\n    int nick_mode;\n    const char *str_prefix_color;\n\n    str_prefix[0] = (nick) ? nick->prefix[0] : '\\0';\n    str_prefix[1] = '\\0';\n\n    nick_mode = weechat_config_integer (irc_config_look_nick_mode);\n    if ((nick_mode == IRC_CONFIG_LOOK_NICK_MODE_BOTH)\n        || (prefix && (nick_mode == IRC_CONFIG_LOOK_NICK_MODE_PREFIX))\n        || (!prefix && (nick_mode == IRC_CONFIG_LOOK_NICK_MODE_ACTION)))\n    {\n        if (nick)\n        {\n            if ((str_prefix[0] == ' ')\n                && (!prefix || !weechat_config_boolean (irc_config_look_nick_mode_empty)))\n            {\n                str_prefix[0] = '\\0';\n            }\n            str_prefix_color = weechat_color (\n                irc_nick_get_prefix_color_name (server, nick->prefix[0]));\n        }\n        else\n        {\n            str_prefix[0] = (prefix\n                             && weechat_config_boolean (irc_config_look_nick_mode_empty)) ?\n                ' ' : '\\0';\n            str_prefix_color = IRC_COLOR_RESET;\n        }\n    }\n    else\n    {\n        str_prefix[0] = '\\0';\n        str_prefix_color = IRC_COLOR_RESET;\n    }\n\n    snprintf (result, sizeof (result), \"%s%s\", str_prefix_color, str_prefix);\n\n    return result;\n}\n\n/*\n * Returns string with nick to display as prefix on buffer (returned string ends\n * by a tab).\n */\n\nconst char *\nirc_nick_as_prefix (struct t_irc_server *server, struct t_irc_nick *nick,\n                    const char *nickname, const char *force_color)\n{\n    static char result[256];\n    char *color;\n\n    if (force_color)\n        color = strdup (force_color);\n    else if (nick)\n        color = strdup (nick->color);\n    else if (nickname)\n        color = irc_nick_find_color (nickname);\n    else\n        color = strdup (IRC_COLOR_CHAT_NICK);\n\n    snprintf (result, sizeof (result), \"%s%s%s\\t\",\n              irc_nick_mode_for_display (server, nick, 1),\n              color,\n              (nick) ? nick->name : nickname);\n\n    if (color)\n        free (color);\n\n    return result;\n}\n\n/*\n * Returns WeeChat color code for a nick.\n */\n\nconst char *\nirc_nick_color_for_msg (struct t_irc_server *server, int server_message,\n                        struct t_irc_nick *nick, const char *nickname)\n{\n    static char color[16][64];\n    static int index_color = 0;\n    char *color_found;\n\n    if (server_message\n        && !weechat_config_boolean (irc_config_look_color_nicks_in_server_messages))\n    {\n        return IRC_COLOR_CHAT_NICK;\n    }\n\n    if (nick)\n        return nick->color;\n\n    if (nickname)\n    {\n        if (server\n            && (irc_server_strcasecmp (server, nickname, server->nick) == 0))\n        {\n            return IRC_COLOR_CHAT_NICK_SELF;\n        }\n        color_found = irc_nick_find_color (nickname);\n        index_color = (index_color + 1) % 16;\n        snprintf (color[index_color], sizeof (color[index_color]),\n                  \"%s\",\n                  color_found);\n        if (color_found)\n            free (color_found);\n        return color[index_color];\n    }\n\n    return IRC_COLOR_CHAT_NICK;\n}\n\n/*\n * Returns string with color of nick for private.\n */\n\nconst char *\nirc_nick_color_for_pv (struct t_irc_channel *channel, const char *nickname)\n{\n    if (weechat_config_boolean (irc_config_look_color_pv_nick_like_channel))\n    {\n        if (!channel->pv_remote_nick_color)\n            channel->pv_remote_nick_color = irc_nick_find_color (nickname);\n        if (channel->pv_remote_nick_color)\n            return channel->pv_remote_nick_color;\n    }\n\n    return IRC_COLOR_CHAT_NICK_OTHER;\n}\n\n/*\n * Returns default ban mask for the nick.\n *\n * Note: result must be freed after use (if not NULL).\n */\n\nchar *\nirc_nick_default_ban_mask (struct t_irc_nick *nick)\n{\n    const char *ptr_ban_mask;\n    char *pos_hostname, user[128], ident[128], *res, *temp;\n\n    if (!nick)\n        return NULL;\n\n    ptr_ban_mask = weechat_config_string (irc_config_network_ban_mask_default);\n\n    pos_hostname = (nick->host) ? strchr (nick->host, '@') : NULL;\n\n    if (!nick->host || !pos_hostname || !ptr_ban_mask || !ptr_ban_mask[0])\n        return NULL;\n\n    if (pos_hostname - nick->host > (int)sizeof (user) - 1)\n        return NULL;\n\n    strncpy (user, nick->host, pos_hostname - nick->host);\n    user[pos_hostname - nick->host] = '\\0';\n    strcpy (ident, (user[0] != '~') ? user : \"*\");\n    pos_hostname++;\n\n    /* replace nick */\n    temp = weechat_string_replace (ptr_ban_mask, \"$nick\", nick->name);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace user */\n    temp = weechat_string_replace (res, \"$user\", user);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace ident */\n    temp = weechat_string_replace (res, \"$ident\", ident);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace hostname */\n    temp = weechat_string_replace (res, \"$host\", pos_hostname);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    return res;\n}\n\n/*\n * Returns hdata for nick.\n */\n\nstruct t_hdata *\nirc_nick_hdata_nick_cb (const void *pointer, void *data,\n                        const char *hdata_name)\n{\n    struct t_hdata *hdata;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n\n    hdata = weechat_hdata_new (hdata_name, \"prev_nick\", \"next_nick\",\n                               0, 0, NULL, NULL);\n    if (hdata)\n    {\n        WEECHAT_HDATA_VAR(struct t_irc_nick, name, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, host, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prefixes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prefix, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, away, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, account, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, realname, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, color, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prev_nick, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, next_nick, POINTER, 0, NULL, hdata_name);\n    }\n    return hdata;\n}\n\n/*\n * Adds a nick in an infolist.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_nick_add_to_infolist (struct t_infolist *infolist,\n                          struct t_irc_nick *nick)\n{\n    struct t_infolist_item *ptr_item;\n\n    if (!infolist || !nick)\n        return 0;\n\n    ptr_item = weechat_infolist_new_item (infolist);\n    if (!ptr_item)\n        return 0;\n\n    if (!weechat_infolist_new_var_string (ptr_item, \"name\", nick->name))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"host\", nick->host))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefixes\", nick->prefixes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix\", nick->prefix))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away\", nick->away))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"account\", nick->account))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"realname\", nick->realname))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"color\", nick->color))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Prints nick infos in WeeChat log file (usually for crash dump).\n */\n\nvoid\nirc_nick_print_log (struct t_irc_nick *nick)\n{\n    weechat_log_printf (\"\");\n    weechat_log_printf (\"    => nick %s (addr:0x%lx):\",    nick->name, nick);\n    weechat_log_printf (\"         host . . . . . : '%s'\",  nick->host);\n    weechat_log_printf (\"         prefixes . . . : '%s'\",  nick->prefixes);\n    weechat_log_printf (\"         prefix . . . . : '%s'\",  nick->prefix);\n    weechat_log_printf (\"         away . . . . . : %d\",    nick->away);\n    weechat_log_printf (\"         account. . . . : '%s'\",  nick->account);\n    weechat_log_printf (\"         realname . . . : '%s'\",  nick->realname);\n    weechat_log_printf (\"         color. . . . . : '%s'\",  nick->color);\n    weechat_log_printf (\"         prev_nick. . . : 0x%lx\", nick->prev_nick);\n    weechat_log_printf (\"         next_nick. . . : 0x%lx\", nick->next_nick);\n}\n", "/*\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#ifndef WEECHAT_PLUGIN_IRC_NICK_H\n#define WEECHAT_PLUGIN_IRC_NICK_H\n\n#define IRC_NICK_VALID_CHARS \"abcdefghijklmnopqrstuvwxyzABCDEFGHI\"      \\\n    \"JKLMNOPQRSTUVWXYZ0123456789-[]\\\\`_^{|}\"\n\n/* nicklist group for nicks without prefix is \"999|...\" */\n#define IRC_NICK_GROUP_OTHER_NUMBER 999\n#define IRC_NICK_GROUP_OTHER_NAME   \"...\"\n\nstruct t_irc_server;\nstruct t_irc_channel;\n\nstruct t_irc_nick\n{\n    char *name;                     /* nickname                              */\n    char *host;                     /* full hostname                         */\n    char *prefixes;                 /* string with prefixes enabled for nick */\n    char *prefix;                   /* current prefix (higher prefix set in  */\n                                    /* prefixes); string with just one char  */\n    int away;                       /* 1 if nick is away                     */\n    char *account;                  /* account name of the user              */\n    char *realname;                 /* realname (aka gecos) of the user      */\n    char *color;                    /* color for nickname                    */\n    struct t_irc_nick *prev_nick;   /* link to previous nick on channel      */\n    struct t_irc_nick *next_nick;   /* link to next nick on channel          */\n};\n\nextern int irc_nick_valid (struct t_irc_channel *channel,\n                           struct t_irc_nick *nick);\nextern int irc_nick_is_nick (const char *string);\nextern char *irc_nick_find_color (const char *nickname);\nextern char *irc_nick_find_color_name (const char *nickname);\nextern void irc_nick_set_host (struct t_irc_nick *nick, const char *host);\nextern int irc_nick_is_op (struct t_irc_server *server,\n                           struct t_irc_nick *nick);\nextern int irc_nick_has_prefix_mode (struct t_irc_server *server,\n                                     struct t_irc_nick *nick,\n                                     char prefix_mode);\nextern const char *irc_nick_get_prefix_color_name (struct t_irc_server *server,\n                                                   char prefix);\nextern void irc_nick_nicklist_set_prefix_color_all ();\nextern void irc_nick_nicklist_set_color_all ();\nextern struct t_irc_nick *irc_nick_new (struct t_irc_server *server,\n                                        struct t_irc_channel *channel,\n                                        const char *nickname,\n                                        const char *host,\n                                        const char *prefixes,\n                                        int away,\n                                        const char *account,\n                                        const char *realname);\nextern void irc_nick_change (struct t_irc_server *server,\n                             struct t_irc_channel *channel,\n                             struct t_irc_nick *nick, const char *new_nick);\nextern void irc_nick_set_mode (struct t_irc_server *server,\n                               struct t_irc_channel *channel,\n                               struct t_irc_nick *nick, int set, char mode);\nextern void irc_nick_free (struct t_irc_server *server,\n                           struct t_irc_channel *channel,\n                           struct t_irc_nick *nick);\nextern void irc_nick_free_all (struct t_irc_server *server,\n                               struct t_irc_channel *channel);\nextern struct t_irc_nick *irc_nick_search (struct t_irc_server *server,\n                                           struct t_irc_channel *channel,\n                                           const char *nickname);\nextern void irc_nick_count (struct t_irc_server *server,\n                            struct t_irc_channel *channel, int *total,\n                            int *count_op, int *count_halfop, int *count_voice,\n                            int *count_normal);\nextern void irc_nick_set_away (struct t_irc_server *server,\n                               struct t_irc_channel *channel,\n                               struct t_irc_nick *nick, int is_away);\nextern const char *irc_nick_mode_for_display (struct t_irc_server *server,\n                                              struct t_irc_nick *nick,\n                                              int prefix);\nextern const char *irc_nick_as_prefix (struct t_irc_server *server,\n                                       struct t_irc_nick *nick,\n                                       const char *nickname,\n                                       const char *force_color);\nextern const char *irc_nick_color_for_msg (struct t_irc_server *server,\n                                           int server_message,\n                                           struct t_irc_nick *nick,\n                                           const char *nickname);\nextern const char * irc_nick_color_for_pv (struct t_irc_channel *channel,\n                                           const char *nickname);\nextern char *irc_nick_default_ban_mask (struct t_irc_nick *nick);\nextern struct t_hdata *irc_nick_hdata_nick_cb (const void *pointer,\n                                               void *data,\n                                               const char *hdata_name);\nextern int irc_nick_add_to_infolist (struct t_infolist *infolist,\n                                     struct t_irc_nick *nick);\nextern void irc_nick_print_log (struct t_irc_nick *nick);\n\n#endif /* WEECHAT_PLUGIN_IRC_NICK_H */\n", "/*\n * irc-server.c - I/O communication with IRC servers\n *\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n * Copyright (C) 2005-2010 Emmanuel Bouthenot <kolter@openics.org>\n * Copyright (C) 2012 Simon Arlott\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#ifdef _WIN32\n#include <winsock.h>\n#else\n#include <sys/socket.h>\n#include <sys/time.h>\n#endif /* _WIN32 */\n#include <sys/types.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\n\n#ifdef HAVE_GNUTLS\n#include <gnutls/gnutls.h>\n#include <gnutls/x509.h>\n#endif /* HAVE_GNUTLS */\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-server.h\"\n#include \"irc-bar-item.h\"\n#include \"irc-buffer.h\"\n#include \"irc-channel.h\"\n#include \"irc-color.h\"\n#include \"irc-command.h\"\n#include \"irc-config.h\"\n#include \"irc-input.h\"\n#include \"irc-message.h\"\n#include \"irc-nick.h\"\n#include \"irc-notify.h\"\n#include \"irc-protocol.h\"\n#include \"irc-raw.h\"\n#include \"irc-redirect.h\"\n#include \"irc-sasl.h\"\n\n\nstruct t_irc_server *irc_servers = NULL;\nstruct t_irc_server *last_irc_server = NULL;\n\nstruct t_irc_message *irc_recv_msgq = NULL;\nstruct t_irc_message *irc_msgq_last_msg = NULL;\n\nchar *irc_server_sasl_fail_string[IRC_SERVER_NUM_SASL_FAIL] =\n{ \"continue\", \"reconnect\", \"disconnect\" };\n\nchar *irc_server_options[IRC_SERVER_NUM_OPTIONS][2] =\n{ { \"addresses\",            \"\"                        },\n  { \"proxy\",                \"\"                        },\n  { \"ipv6\",                 \"on\"                      },\n  { \"ssl\",                  \"off\"                     },\n  { \"ssl_cert\",             \"\"                        },\n  { \"ssl_password\",         \"\"                        },\n  { \"ssl_priorities\",       \"NORMAL:-VERS-SSL3.0\"     },\n  { \"ssl_dhkey_size\",       \"2048\"                    },\n  { \"ssl_fingerprint\",      \"\"                        },\n  { \"ssl_verify\",           \"on\"                      },\n  { \"password\",             \"\"                        },\n  { \"capabilities\",         \"\"                        },\n  { \"sasl_mechanism\",       \"plain\"                   },\n  { \"sasl_username\",        \"\"                        },\n  { \"sasl_password\",        \"\"                        },\n  { \"sasl_key\",             \"\",                       },\n  { \"sasl_timeout\",         \"15\"                      },\n  { \"sasl_fail\",            \"continue\"                },\n  { \"autoconnect\",          \"off\"                     },\n  { \"autoreconnect\",        \"on\"                      },\n  { \"autoreconnect_delay\",  \"10\"                      },\n  { \"nicks\",                \"\"                        },\n  { \"nicks_alternate\",      \"on\"                      },\n  { \"username\",             \"\"                        },\n  { \"realname\",             \"\"                        },\n  { \"local_hostname\",       \"\"                        },\n  { \"usermode\",             \"\"                        },\n  { \"command\",              \"\"                        },\n  { \"command_delay\",        \"0\"                       },\n  { \"autojoin\",             \"\"                        },\n  { \"autorejoin\",           \"off\"                     },\n  { \"autorejoin_delay\",     \"30\"                      },\n  { \"connection_timeout\",   \"60\"                      },\n  { \"anti_flood_prio_high\", \"2\"                       },\n  { \"anti_flood_prio_low\",  \"2\"                       },\n  { \"away_check\",           \"0\"                       },\n  { \"away_check_max_nicks\", \"25\"                      },\n  { \"msg_kick\",             \"\"                        },\n  { \"msg_part\",             \"WeeChat ${info:version}\" },\n  { \"msg_quit\",             \"WeeChat ${info:version}\" },\n  { \"notify\",               \"\"                        },\n  { \"split_msg_max_length\", \"512\"                     },\n  { \"charset_message\",      \"message\"                 },\n};\n\nchar *irc_server_casemapping_string[IRC_SERVER_NUM_CASEMAPPING] =\n{ \"rfc1459\", \"strict-rfc1459\", \"ascii\" };\n\nchar *irc_server_prefix_modes_default = \"ov\";\nchar *irc_server_prefix_chars_default = \"@+\";\nchar *irc_server_chanmodes_default    = \"beI,k,l\";\n\nconst char *irc_server_send_default_tags = NULL;  /* default tags when       */\n                                                  /* sending a message       */\n\n#ifdef HAVE_GNUTLS\ngnutls_digest_algorithm_t irc_fingerprint_digest_algos[IRC_FINGERPRINT_NUM_ALGOS] =\n{ GNUTLS_DIG_SHA1, GNUTLS_DIG_SHA256, GNUTLS_DIG_SHA512 };\nchar *irc_fingerprint_digest_algos_name[IRC_FINGERPRINT_NUM_ALGOS] =\n{ \"SHA-1\", \"SHA-256\", \"SHA-512\" };\nint irc_fingerprint_digest_algos_size[IRC_FINGERPRINT_NUM_ALGOS] =\n{ 160, 256, 512 };\n#endif /* HAVE_GNUTLS */\n\n\nvoid irc_server_reconnect (struct t_irc_server *server);\nvoid irc_server_free_data (struct t_irc_server *server);\nvoid irc_server_autojoin_create_buffers (struct t_irc_server *server);\n\n\n/*\n * Checks if a server pointer is valid.\n *\n * Returns:\n *   1: server exists\n *   0: server does not exist\n */\n\nint\nirc_server_valid (struct t_irc_server *server)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server)\n        return 0;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (ptr_server == server)\n            return 1;\n    }\n\n    /* server not found */\n    return 0;\n}\n\n/*\n * Searches for a server by name.\n *\n * Returns pointer to server found, NULL if not found.\n */\n\nstruct t_irc_server *\nirc_server_search (const char *server_name)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server_name)\n        return NULL;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (strcmp (ptr_server->name, server_name) == 0)\n            return ptr_server;\n    }\n\n    /* server not found */\n    return NULL;\n}\n\n/*\n * Searches for a server by name (case insensitive).\n *\n * Returns pointer to server found, NULL if not found.\n */\n\nstruct t_irc_server *\nirc_server_casesearch (const char *server_name)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server_name)\n        return NULL;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (weechat_strcasecmp (ptr_server->name, server_name) == 0)\n            return ptr_server;\n    }\n\n    /* server not found */\n    return NULL;\n}\n\n/*\n * Searches for a server option name.\n *\n * Returns index of option in array \"irc_server_option_string\", -1 if not found.\n */\n\nint\nirc_server_search_option (const char *option_name)\n{\n    int i;\n\n    if (!option_name)\n        return -1;\n\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        if (weechat_strcasecmp (irc_server_options[i][0], option_name) == 0)\n            return i;\n    }\n\n    /* server option not found */\n    return -1;\n}\n\n/*\n * Searches for a casemapping.\n *\n * Returns index of casemapping in array \"irc_server_casemapping_string\", -1 if\n * not found.\n */\n\nint\nirc_server_search_casemapping (const char *casemapping)\n{\n    int i;\n\n    for (i = 0; i < IRC_SERVER_NUM_CASEMAPPING; i++)\n    {\n        if (weechat_strcasecmp (irc_server_casemapping_string[i], casemapping) == 0)\n            return i;\n    }\n\n    /* casemapping not found */\n    return -1;\n}\n\n/*\n * Compares two strings on server (case insensitive, depends on casemapping).\n *\n * Returns:\n *   < 0: string1 < string2\n *     0: string1 == string2\n *   > 0: string1 > string2\n */\n\nint\nirc_server_strcasecmp (struct t_irc_server *server,\n                       const char *string1, const char *string2)\n{\n    int casemapping, rc;\n\n    casemapping = (server) ? server->casemapping : IRC_SERVER_CASEMAPPING_RFC1459;\n    switch (casemapping)\n    {\n        case IRC_SERVER_CASEMAPPING_RFC1459:\n            rc = weechat_strcasecmp_range (string1, string2, 30);\n            break;\n        case IRC_SERVER_CASEMAPPING_STRICT_RFC1459:\n            rc = weechat_strcasecmp_range (string1, string2, 29);\n            break;\n        case IRC_SERVER_CASEMAPPING_ASCII:\n            rc = weechat_strcasecmp (string1, string2);\n            break;\n        default:\n            rc = weechat_strcasecmp_range (string1, string2, 30);\n            break;\n    }\n    return rc;\n}\n\n/*\n * Compares two strings on server (case insensitive, depends on casemapping) for\n * max chars.\n *\n * Returns:\n *   < 0: string1 < string2\n *     0: string1 == string2\n *   > 0: string1 > string2\n */\n\nint\nirc_server_strncasecmp (struct t_irc_server *server,\n                        const char *string1, const char *string2, int max)\n{\n    int casemapping, rc;\n\n    casemapping = (server) ? server->casemapping : IRC_SERVER_CASEMAPPING_RFC1459;\n    switch (casemapping)\n    {\n        case IRC_SERVER_CASEMAPPING_RFC1459:\n            rc = weechat_strncasecmp_range (string1, string2, max, 30);\n            break;\n        case IRC_SERVER_CASEMAPPING_STRICT_RFC1459:\n            rc = weechat_strncasecmp_range (string1, string2, max, 29);\n            break;\n        case IRC_SERVER_CASEMAPPING_ASCII:\n            rc = weechat_strncasecmp (string1, string2, max);\n            break;\n        default:\n            rc = weechat_strncasecmp_range (string1, string2, max, 30);\n            break;\n    }\n    return rc;\n}\n\n/*\n * Evaluates a string using the server as context:\n * ${irc_server.xxx} and ${server} are replaced by a server option and the\n * server name.\n *\n * Returns the evaluated string.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_eval_expression (struct t_irc_server *server, const char *string)\n{\n    struct t_hashtable *pointers, *extra_vars;\n    char *value;\n\n    pointers = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_POINTER,\n        NULL, NULL);\n    extra_vars = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_STRING,\n        NULL, NULL);\n\n    if (server)\n    {\n        if (pointers)\n            weechat_hashtable_set (pointers, \"irc_server\", server);\n        if (extra_vars)\n            weechat_hashtable_set (extra_vars, \"server\", server->name);\n    }\n\n    value = weechat_string_eval_expression (string,\n                                            pointers, extra_vars, NULL);\n\n    if (pointers)\n        weechat_hashtable_free (pointers);\n    if (extra_vars)\n        weechat_hashtable_free (extra_vars);\n\n    return value;\n}\n\n/*\n * Evaluates and returns the fingerprint.\n *\n * Returns the evaluated fingerprint, NULL if the fingerprint option is\n * invalid.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_eval_fingerprint (struct t_irc_server *server)\n{\n#ifdef HAVE_GNUTLS\n    const char *ptr_fingerprint;\n    char *fingerprint_eval, **fingerprints, *str_sizes;\n    int i, j, rc, algo, length;\n\n    ptr_fingerprint = IRC_SERVER_OPTION_STRING(server,\n                                               IRC_SERVER_OPTION_SSL_FINGERPRINT);\n\n    /* empty fingerprint is just ignored (considered OK) */\n    if (!ptr_fingerprint || !ptr_fingerprint[0])\n        return strdup (\"\");\n\n    /* evaluate fingerprint */\n    fingerprint_eval = irc_server_eval_expression (server, ptr_fingerprint);\n    if (!fingerprint_eval || !fingerprint_eval[0])\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: the evaluated fingerprint for server \\\"%s\\\" must not be \"\n              \"empty\"),\n            weechat_prefix (\"error\"),\n            IRC_PLUGIN_NAME,\n            server->name);\n        if (fingerprint_eval)\n            free (fingerprint_eval);\n        return NULL;\n    }\n\n    /* split fingerprint */\n    fingerprints = weechat_string_split (fingerprint_eval, \",\", NULL,\n                                         WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                         | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                         | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                         0, NULL);\n    if (!fingerprints)\n        return fingerprint_eval;\n\n    rc = 0;\n    for (i = 0; fingerprints[i]; i++)\n    {\n        length = strlen (fingerprints[i]);\n        algo = irc_server_fingerprint_search_algo_with_size (length * 4);\n        if (algo < 0)\n        {\n            rc = -1;\n            break;\n        }\n        for (j = 0; j < length; j++)\n        {\n            if (!isxdigit ((unsigned char)fingerprints[i][j]))\n            {\n                rc = -2;\n                break;\n            }\n        }\n        if (rc < 0)\n            break;\n    }\n    weechat_string_free_split (fingerprints);\n    switch (rc)\n    {\n        case -1:  /* invalid size */\n            str_sizes = irc_server_fingerprint_str_sizes ();\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: invalid fingerprint size for server \\\"%s\\\", the \"\n                  \"number of hexadecimal digits must be \"\n                  \"one of: %s\"),\n                weechat_prefix (\"error\"),\n                IRC_PLUGIN_NAME,\n                server->name,\n                (str_sizes) ? str_sizes : \"?\");\n            if (str_sizes)\n                free (str_sizes);\n            free (fingerprint_eval);\n            return NULL;\n        case -2:  /* invalid content */\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: invalid fingerprint for server \\\"%s\\\", it must \"\n                  \"contain only hexadecimal digits (0-9, \"\n                  \"a-f)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n            free (fingerprint_eval);\n            return NULL;\n    }\n    return fingerprint_eval;\n#else\n    /* make C compiler happy */\n    (void) server;\n\n    return strdup (\"\");\n#endif /* HAVE_GNUTLS */\n}\n\n/*\n * Checks if SASL is enabled on server.\n *\n * Returns:\n *   1: SASL is enabled\n *   0: SASL is disabled\n */\n\nint\nirc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n\n    /*\n     * SASL is enabled if one of these conditions is true:\n     * - mechanism is \"external\"\n     * - mechanism is \"ecdsa-nist256p-challenge\" with username/key set\n     * - another mechanism with username/password set\n     */\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n\n    return rc;\n}\n\n/*\n * Gets name of server without port (ends before first '/' if found).\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n\n    if (!name)\n        return NULL;\n\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n\n    return strdup (name);\n}\n\n/*\n * Sets addresses for server.\n *\n * Returns:\n *   1: addresses have been set (changed)\n *   0: nothing set (addresses unchanged)\n */\n\nint\nirc_server_set_addresses (struct t_irc_server *server, const char *addresses)\n{\n    int i;\n    char *pos, *error, *addresses_eval;\n    long number;\n\n    addresses_eval = NULL;\n\n    if (addresses && addresses[0])\n    {\n        addresses_eval = irc_server_eval_expression (server, addresses);\n        if (server->addresses_eval\n            && (strcmp (server->addresses_eval, addresses_eval) == 0))\n        {\n            free (addresses_eval);\n            return 0;\n        }\n    }\n\n    /* free data */\n    if (server->addresses_eval)\n    {\n        free (server->addresses_eval);\n        server->addresses_eval = NULL;\n    }\n    server->addresses_count = 0;\n    if (server->addresses_array)\n    {\n        weechat_string_free_split (server->addresses_array);\n        server->addresses_array = NULL;\n    }\n    if (server->ports_array)\n    {\n        free (server->ports_array);\n        server->ports_array = NULL;\n    }\n    if (server->retry_array)\n    {\n        free (server->retry_array);\n        server->retry_array = NULL;\n    }\n\n    /* set new addresses/ports */\n    server->addresses_eval = addresses_eval;\n    if (!addresses_eval)\n        return 1;\n    server->addresses_array = weechat_string_split (\n        addresses_eval,\n        \",\",\n        \" \",\n        WEECHAT_STRING_SPLIT_STRIP_LEFT\n        | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n        | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n        0,\n        &server->addresses_count);\n    server->ports_array = malloc (\n        server->addresses_count * sizeof (server->ports_array[0]));\n    server->retry_array = malloc (\n        server->addresses_count * sizeof (server->retry_array[0]));\n    for (i = 0; i < server->addresses_count; i++)\n    {\n        pos = strchr (server->addresses_array[i], '/');\n        if (pos)\n        {\n            pos[0] = 0;\n            pos++;\n            error = NULL;\n            number = strtol (pos, &error, 10);\n            server->ports_array[i] = (error && !error[0]) ?\n                number : IRC_SERVER_DEFAULT_PORT;\n        }\n        else\n        {\n            server->ports_array[i] = IRC_SERVER_DEFAULT_PORT;\n        }\n        server->retry_array[i] = 0;\n    }\n\n    return 1;\n}\n\n\n/*\n * Sets index of current address for server.\n */\n\nvoid\nirc_server_set_index_current_address (struct t_irc_server *server, int index)\n{\n    int addresses_changed;\n\n    addresses_changed = irc_server_set_addresses (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_ADDRESSES));\n\n    if (addresses_changed)\n    {\n        /* if the addresses have changed, reset the index to 0 */\n        index = 0;\n    }\n\n    if (server->current_address)\n    {\n        free (server->current_address);\n        server->current_address = NULL;\n\n        /* copy current retry value before loading next server */\n        if (!addresses_changed\n            && server->index_current_address < server->addresses_count)\n        {\n            server->retry_array[server->index_current_address] = server->current_retry;\n        }\n    }\n    server->current_port = 0;\n    server->current_retry = 0;\n\n    if (server->addresses_count > 0)\n    {\n        index %= server->addresses_count;\n        server->index_current_address = index;\n        server->current_address = strdup (server->addresses_array[index]);\n        server->current_port = server->ports_array[index];\n        server->current_retry = server->retry_array[index];\n    }\n}\n\n/*\n * Sets nicks for server.\n */\n\nvoid\nirc_server_set_nicks (struct t_irc_server *server, const char *nicks)\n{\n    char *nicks2;\n\n    /* free data */\n    server->nicks_count = 0;\n    if (server->nicks_array)\n    {\n        weechat_string_free_split (server->nicks_array);\n        server->nicks_array = NULL;\n    }\n\n    /* evaluate value */\n    nicks2 = irc_server_eval_expression (server, nicks);\n\n    /* set new nicks */\n    server->nicks_array = weechat_string_split (\n        (nicks2) ? nicks2 : IRC_SERVER_DEFAULT_NICKS,\n        \",\",\n        NULL,\n        WEECHAT_STRING_SPLIT_STRIP_LEFT\n        | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n        | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n        0,\n        &server->nicks_count);\n\n    if (nicks2)\n        free (nicks2);\n}\n\n/*\n * Sets nickname for server.\n */\n\nvoid\nirc_server_set_nick (struct t_irc_server *server, const char *nick)\n{\n    struct t_irc_channel *ptr_channel;\n\n    /* if nick is the same, just return */\n    if ((!server->nick && !nick)\n        || (server->nick && nick && strcmp (server->nick, nick) == 0))\n    {\n        return;\n    }\n\n    /* update the nick in server */\n    if (server->nick)\n        free (server->nick);\n    server->nick = (nick) ? strdup (nick) : NULL;\n\n    /* set local variable \"nick\" for server and all channels/pv */\n    weechat_buffer_set (server->buffer, \"localvar_set_nick\", nick);\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        weechat_buffer_set (ptr_channel->buffer, \"localvar_set_nick\", nick);\n    }\n\n    weechat_bar_item_update (\"input_prompt\");\n    weechat_bar_item_update (\"irc_nick\");\n    weechat_bar_item_update (\"irc_nick_host\");\n}\n\n/*\n * Sets host for server.\n */\n\nvoid\nirc_server_set_host (struct t_irc_server *server, const char *host)\n{\n    struct t_irc_channel *ptr_channel;\n\n    /* if host is the same, just return */\n    if ((!server->host && !host)\n        || (server->host && host && strcmp (server->host, host) == 0))\n    {\n        return;\n    }\n\n    /* update the nick host in server */\n    if (server->host)\n        free (server->host);\n    server->host = (host) ? strdup (host) : NULL;\n\n    /* set local variable \"host\" for server and all channels/pv */\n    weechat_buffer_set (server->buffer, \"localvar_set_host\", host);\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        weechat_buffer_set (ptr_channel->buffer,\n                            \"localvar_set_host\", host);\n    }\n\n    weechat_bar_item_update (\"irc_host\");\n    weechat_bar_item_update (\"irc_nick_host\");\n}\n\n/*\n * Gets index of nick in array \"nicks_array\".\n *\n * Returns index of nick in array, -1 if nick is not set or not found in\n * \"nicks_array\".\n */\n\nint\nirc_server_get_nick_index (struct t_irc_server *server)\n{\n    int i;\n\n    if (!server->nick)\n        return -1;\n\n    for (i = 0; i < server->nicks_count; i++)\n    {\n        if (strcmp (server->nick, server->nicks_array[i]) == 0)\n        {\n            return i;\n        }\n    }\n\n    /* nick not found */\n    return -1;\n}\n\n/*\n * Gets an alternate nick when the nick is already used on server.\n *\n * First tries all declared nicks, then builds nicks by adding \"_\", until\n * length of 9.\n *\n * If all nicks are still used, builds 99 alternate nicks by using number at the\n * end.\n *\n * Example: nicks = \"abcde,fghi,jkl\"\n *          => nicks tried:  abcde\n *                          fghi\n *                          jkl\n *                          abcde_\n *                          abcde__\n *                          abcde___\n *                          abcde____\n *                          abcde___1\n *                          abcde___2\n *                          ...\n *                          abcde__99\n *\n * Returns NULL if no more alternate nick is available.\n */\n\nconst char *\nirc_server_get_alternate_nick (struct t_irc_server *server)\n{\n    static char nick[64];\n    char str_number[64];\n    int nick_index, length_nick, length_number;\n\n    nick[0] = '\\0';\n\n    /* we are still trying nicks from option \"nicks\" */\n    if (server->nick_alternate_number < 0)\n    {\n        nick_index = irc_server_get_nick_index (server);\n        if (nick_index < 0)\n            nick_index = 0;\n        else\n        {\n            nick_index = (nick_index + 1) % server->nicks_count;\n            /* stop loop if first nick tried was not in the list of nicks */\n            if ((nick_index == 0) && (server->nick_first_tried < 0))\n                server->nick_first_tried = 0;\n        }\n\n        if (nick_index != server->nick_first_tried)\n        {\n            snprintf (nick, sizeof (nick),\n                      \"%s\", server->nicks_array[nick_index]);\n            return nick;\n        }\n\n        /* now we have tried all nicks in list */\n\n        /* if alternate nicks are disabled, just return NULL */\n        if (!IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_NICKS_ALTERNATE))\n            return NULL;\n\n        /* use main nick and we will add \"_\" and then number if needed */\n        server->nick_alternate_number = 0;\n        snprintf (nick, sizeof (nick), \"%s\", server->nicks_array[0]);\n    }\n    else\n        snprintf (nick, sizeof (nick), \"%s\", server->nick);\n\n    /* if length is < 9, just add a \"_\" */\n    if (strlen (nick) < 9)\n    {\n        strcat (nick, \"_\");\n        return nick;\n    }\n\n    server->nick_alternate_number++;\n\n    /* number is max 99 */\n    if (server->nick_alternate_number > 99)\n        return NULL;\n\n    /* be sure the nick has 9 chars max */\n    nick[9] = '\\0';\n\n    /* generate number */\n    snprintf (str_number, sizeof (str_number),\n              \"%d\", server->nick_alternate_number);\n\n    /* copy number in nick */\n    length_nick = strlen (nick);\n    length_number = strlen (str_number);\n    if (length_number > length_nick)\n        return NULL;\n    memcpy (nick + length_nick - length_number, str_number, length_number);\n\n    /* return alternate nick */\n    return nick;\n}\n\n/*\n * Gets value of a feature item in \"isupport\" (copy of IRC message 005).\n *\n * Returns value of feature (empty string if feature has no value, NULL if\n * feature is not found).\n */\n\nconst char *\nirc_server_get_isupport_value (struct t_irc_server *server, const char *feature)\n{\n    char feature2[64], *pos_feature, *pos_equal, *pos_space;\n    int length;\n    static char value[256];\n\n    if (!server || !server->isupport || !feature)\n        return NULL;\n\n    /* search feature with value */\n    snprintf (feature2, sizeof (feature2), \" %s=\", feature);\n    pos_feature = strstr (server->isupport, feature2);\n    if (pos_feature)\n    {\n        /* feature found with value, return value */\n        pos_feature++;\n        pos_equal = strchr (pos_feature, '=');\n        pos_space = strchr (pos_feature, ' ');\n        if (pos_space)\n            length = pos_space - pos_equal - 1;\n        else\n            length = strlen (pos_equal) + 1;\n        if (length > (int)sizeof (value) - 1)\n            length = (int)sizeof (value) - 1;\n        memcpy (value, pos_equal + 1, length);\n        value[length] = '\\0';\n        return value;\n    }\n\n    /* search feature without value */\n    feature2[strlen (feature2) - 1] = ' ';\n    pos_feature = strstr (server->isupport, feature2);\n    if (pos_feature)\n    {\n        value[0] = '\\0';\n        return value;\n    }\n\n    /* feature not found in isupport */\n    return NULL;\n}\n\n/*\n * Sets \"prefix_modes\" and \"prefix_chars\" in server using value of PREFIX in IRC\n * message 005.\n *\n * For example, if prefix is \"(ohv)@%+\":\n *   prefix_modes is set to \"ohv\"\n *   prefix_chars is set to \"@%+\".\n */\n\nvoid\nirc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n\n    if (!server || !prefix)\n        return;\n\n    /* free previous values */\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    /* assign new values */\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}\n\n/*\n * Sets lag in server buffer (local variable), update bar item \"lag\"\n * and send signal \"irc_server_lag_changed\" for the server.\n */\n\nvoid\nirc_server_set_lag (struct t_irc_server *server)\n{\n    char str_lag[32];\n\n    if (server->lag >= weechat_config_integer (irc_config_network_lag_min_show))\n    {\n        snprintf (str_lag, sizeof (str_lag),\n                  ((server->lag_check_time.tv_sec == 0) || (server->lag < 1000)) ?\n                  \"%.3f\" : \"%.0f\",\n                  ((float)(server->lag)) / 1000);\n        weechat_buffer_set (server->buffer, \"localvar_set_lag\", str_lag);\n    }\n    else\n    {\n        weechat_buffer_set (server->buffer, \"localvar_del_lag\", \"\");\n    }\n    weechat_hook_signal_send (\"irc_server_lag_changed\",\n                              WEECHAT_HOOK_SIGNAL_STRING,\n                              server->name);\n    weechat_bar_item_update (\"lag\");\n}\n\n/*\n * Gets prefix_modes for server (for example: \"ohv\").\n *\n * Returns default modes if prefix_modes is not set in server.\n */\n\nconst char *\nirc_server_get_prefix_modes (struct t_irc_server *server)\n{\n    return (server && server->prefix_modes) ?\n        server->prefix_modes : irc_server_prefix_modes_default;\n}\n\n/*\n * Gets prefix_chars for server (for example: \"@%+\").\n *\n * Returns default chars if prefix_chars is not set in server.\n */\n\nconst char *\nirc_server_get_prefix_chars (struct t_irc_server *server)\n{\n    return (server && server->prefix_chars) ?\n        server->prefix_chars : irc_server_prefix_chars_default;\n}\n\n/*\n * Gets index of mode in prefix_modes.\n *\n * The mode is for example 'o' or 'v'.\n *\n * Returns -1 if mode does not exist in server.\n */\n\nint\nirc_server_get_prefix_mode_index (struct t_irc_server *server, char mode)\n{\n    const char *prefix_modes;\n    char *pos;\n\n    if (server)\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        pos = strchr (prefix_modes, mode);\n        if (pos)\n            return pos - prefix_modes;\n    }\n\n    return -1;\n}\n\n/*\n * Gets index of prefix_char in prefix_chars.\n *\n * The prefix char is for example '@' or '+'.\n *\n * Returns -1 if prefix_char does not exist in server.\n */\n\nint\nirc_server_get_prefix_char_index (struct t_irc_server *server,\n                                  char prefix_char)\n{\n    const char *prefix_chars;\n    char *pos;\n\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        pos = strchr (prefix_chars, prefix_char);\n        if (pos)\n            return pos - prefix_chars;\n    }\n\n    return -1;\n}\n\n/*\n * Gets mode for prefix char.\n *\n * For example prefix_char '@' can return 'o'.\n *\n * Returns ' ' (space) if prefix char is not found.\n */\n\nchar\nirc_server_get_prefix_mode_for_char (struct t_irc_server *server,\n                                     char prefix_char)\n{\n    const char *prefix_modes;\n    int index;\n\n    if (server)\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        index = irc_server_get_prefix_char_index (server, prefix_char);\n        if (index >= 0)\n            return prefix_modes[index];\n    }\n\n    return ' ';\n}\n\n/*\n * Gets prefix char for mode.\n *\n * For example mode 'o' can return '@'.\n *\n * Returns a space if mode is not found.\n */\n\nchar\nirc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n\n    return ' ';\n}\n\n/*\n * Gets chanmodes for server (for example: \"eIb,k,l,imnpstS\").\n *\n * Returns default chanmodes if chanmodes is not set in server.\n */\n\nconst char *\nirc_server_get_chanmodes (struct t_irc_server *server)\n{\n    return (server && server->chanmodes) ?\n        server->chanmodes : irc_server_chanmodes_default;\n}\n\n/*\n * Checks if a prefix char is valid for a status message\n * (message sent for example to ops/voiced).\n *\n * The prefix (for example '@' or '+') must be in STATUSMSG,\n * or in \"prefix_chars\" if STATUSMSG is not defined.\n *\n * Returns:\n *   1: prefix is valid for a status message\n *   0: prefix is NOT valid for a status message\n */\n\nint\nirc_server_prefix_char_statusmsg (struct t_irc_server *server,\n                                  char prefix_char)\n{\n    const char *support_statusmsg;\n\n    support_statusmsg = irc_server_get_isupport_value (server, \"STATUSMSG\");\n    if (support_statusmsg)\n        return (strchr (support_statusmsg, prefix_char)) ? 1 : 0;\n\n    return (irc_server_get_prefix_char_index (server, prefix_char) >= 0) ?\n        1 : 0;\n}\n\n/*\n * Get max modes supported in one command by the server\n * (in isupport value, with the format: \"MODES=4\").\n *\n * Default is 4 if the info is not given by the server.\n */\n\nint\nirc_server_get_max_modes (struct t_irc_server *server)\n{\n    const char *support_modes;\n    char *error;\n    long number;\n    int max_modes;\n\n    max_modes = 4;\n\n    support_modes = irc_server_get_isupport_value (server, \"MODES\");\n    if (support_modes)\n    {\n        error = NULL;\n        number = strtol (support_modes, &error, 10);\n        if (error && !error[0])\n        {\n            max_modes = number;\n            if (max_modes < 1)\n                max_modes = 1;\n            if (max_modes > 128)\n                max_modes = 128;\n        }\n    }\n\n    return max_modes;\n}\n\n/*\n * Gets an evaluated default_msg server option: replaces \"%v\" by WeeChat\n * version if there's no ${...} in string, or just evaluates the string.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_default_msg (const char *default_msg,\n                            struct t_irc_server *server,\n                            const char *channel_name)\n{\n    char *version;\n    struct t_hashtable *extra_vars;\n    char *msg, *res;\n\n    /*\n     * \"%v\" for version is deprecated since WeeChat 1.6, where\n     * an expression ${info:version} is preferred, so we replace\n     * the \"%v\" with version only if there's no \"${...}\" in string\n     */\n    if (strstr (default_msg, \"%v\") && !strstr (default_msg, \"${\"))\n    {\n        version = weechat_info_get (\"version\", \"\");\n        res = weechat_string_replace (default_msg, \"%v\",\n                                      (version) ? version : \"\");\n        if (version)\n            free (version);\n        return res;\n    }\n\n    extra_vars = weechat_hashtable_new (32,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        NULL,\n                                        NULL);\n    if (extra_vars)\n    {\n        weechat_hashtable_set (extra_vars, \"server\", server->name);\n        weechat_hashtable_set (extra_vars, \"channel\",\n                               (channel_name) ? channel_name : \"\");\n        weechat_hashtable_set (extra_vars, \"nick\", server->nick);\n    }\n\n    msg = weechat_string_eval_expression (default_msg, NULL, extra_vars, NULL);\n\n    if (extra_vars)\n        weechat_hashtable_free (extra_vars);\n\n    return msg;\n}\n\n/*\n * Allocates a new server and adds it to the servers queue.\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_alloc (const char *name)\n{\n    struct t_irc_server *new_server;\n    int i, length;\n    char *option_name;\n\n    if (irc_server_casesearch (name))\n        return NULL;\n\n    /* alloc memory for new server */\n    new_server = malloc (sizeof (*new_server));\n    if (!new_server)\n    {\n        weechat_printf (NULL,\n                        _(\"%s%s: error when allocating new server\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return NULL;\n    }\n\n    /* add new server to queue */\n    new_server->prev_server = last_irc_server;\n    new_server->next_server = NULL;\n    if (last_irc_server)\n        last_irc_server->next_server = new_server;\n    else\n        irc_servers = new_server;\n    last_irc_server = new_server;\n\n    /* set name */\n    new_server->name = strdup (name);\n\n    /* internal vars */\n    new_server->temp_server = 0;\n    new_server->reloading_from_config = 0;\n    new_server->reloaded_from_config = 0;\n    new_server->addresses_eval = NULL;\n    new_server->addresses_count = 0;\n    new_server->addresses_array = NULL;\n    new_server->ports_array = NULL;\n    new_server->retry_array = NULL;\n    new_server->index_current_address = 0;\n    new_server->current_address = NULL;\n    new_server->current_ip = NULL;\n    new_server->current_port = 0;\n    new_server->current_retry = 0;\n    new_server->sock = -1;\n    new_server->hook_connect = NULL;\n    new_server->hook_fd = NULL;\n    new_server->hook_timer_connection = NULL;\n    new_server->hook_timer_sasl = NULL;\n    new_server->is_connected = 0;\n    new_server->ssl_connected = 0;\n    new_server->disconnected = 0;\n    new_server->unterminated_message = NULL;\n    new_server->nicks_count = 0;\n    new_server->nicks_array = NULL;\n    new_server->nick_first_tried = 0;\n    new_server->nick_alternate_number = -1;\n    new_server->nick = NULL;\n    new_server->nick_modes = NULL;\n    new_server->host = NULL;\n    new_server->checking_cap_ls = 0;\n    new_server->cap_ls = weechat_hashtable_new (32,\n                                                WEECHAT_HASHTABLE_STRING,\n                                                WEECHAT_HASHTABLE_STRING,\n                                                NULL,\n                                                NULL);\n    new_server->checking_cap_list = 0;\n    new_server->cap_list = weechat_hashtable_new (32,\n                                                  WEECHAT_HASHTABLE_STRING,\n                                                  WEECHAT_HASHTABLE_STRING,\n                                                  NULL,\n                                                  NULL);\n    new_server->isupport = NULL;\n    new_server->prefix_modes = NULL;\n    new_server->prefix_chars = NULL;\n    new_server->nick_max_length = 0;\n    new_server->user_max_length = 0;\n    new_server->host_max_length = 0;\n    new_server->casemapping = IRC_SERVER_CASEMAPPING_RFC1459;\n    new_server->chantypes = NULL;\n    new_server->chanmodes = NULL;\n    new_server->monitor = 0;\n    new_server->monitor_time = 0;\n    new_server->reconnect_delay = 0;\n    new_server->reconnect_start = 0;\n    new_server->command_time = 0;\n    new_server->reconnect_join = 0;\n    new_server->disable_autojoin = 0;\n    new_server->is_away = 0;\n    new_server->away_message = NULL;\n    new_server->away_time = 0;\n    new_server->lag = 0;\n    new_server->lag_displayed = -1;\n    new_server->lag_check_time.tv_sec = 0;\n    new_server->lag_check_time.tv_usec = 0;\n    new_server->lag_next_check = time (NULL) +\n        weechat_config_integer (irc_config_network_lag_check);\n    new_server->lag_last_refresh = 0;\n    new_server->cmd_list_regexp = NULL;\n    new_server->last_user_message = 0;\n    new_server->last_away_check = 0;\n    new_server->last_data_purge = 0;\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        new_server->outqueue[i] = NULL;\n        new_server->last_outqueue[i] = NULL;\n    }\n    new_server->redirects = NULL;\n    new_server->last_redirect = NULL;\n    new_server->notify_list = NULL;\n    new_server->last_notify = NULL;\n    new_server->notify_count = 0;\n    new_server->join_manual = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_TIME,\n        NULL, NULL);\n    new_server->join_channel_key = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_STRING,\n        NULL, NULL);\n    new_server->join_noswitch = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_TIME,\n        NULL, NULL);\n    new_server->buffer = NULL;\n    new_server->buffer_as_string = NULL;\n    new_server->channels = NULL;\n    new_server->last_channel = NULL;\n\n    /* create options with null value */\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        length = strlen (new_server->name) + 1 +\n            strlen (irc_server_options[i][0]) +\n            512 +  /* inherited option name (irc.server_default.xxx) */\n            1;\n        option_name = malloc (length);\n        if (option_name)\n        {\n            snprintf (option_name, length, \"%s.%s << irc.server_default.%s\",\n                      new_server->name,\n                      irc_server_options[i][0],\n                      irc_server_options[i][0]);\n            new_server->options[i] = irc_config_server_new_option (\n                irc_config_file,\n                irc_config_section_server,\n                i,\n                option_name,\n                NULL,\n                NULL,\n                1,\n                &irc_config_server_check_value_cb,\n                irc_server_options[i][0],\n                NULL,\n                &irc_config_server_change_cb,\n                irc_server_options[i][0],\n                NULL);\n            irc_config_server_change_cb (irc_server_options[i][0], NULL,\n                                         new_server->options[i]);\n            free (option_name);\n        }\n    }\n\n    return new_server;\n}\n\n/*\n * Initializes a server with URL of this form: irc://nick:pass@irc.toto.org:6667\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_alloc_with_url (const char *irc_url)\n{\n    char *irc_url2, *pos_server, *pos_nick, *pos_password;\n    char *pos_address, *pos_port, *pos_channel, *pos;\n    char *server_address, *server_nicks, *server_autojoin;\n    char default_port[16];\n    int ipv6, ssl, length;\n    struct t_irc_server *ptr_server;\n\n    irc_url2 = strdup (irc_url);\n    if (!irc_url2)\n        return NULL;\n\n    pos_server = NULL;\n    pos_nick = NULL;\n    pos_password = NULL;\n    pos_address = NULL;\n    pos_port = NULL;\n    pos_channel = NULL;\n\n    ipv6 = 0;\n    ssl = 0;\n    snprintf (default_port, sizeof (default_port),\n              \"%d\", IRC_SERVER_DEFAULT_PORT);\n\n    pos_server = strstr (irc_url2, \"://\");\n    if (!pos_server || !pos_server[3])\n    {\n        free (irc_url2);\n        return NULL;\n    }\n    pos_server[0] = '\\0';\n    pos_server += 3;\n\n    pos_channel = strstr (pos_server, \"/\");\n    if (pos_channel)\n    {\n        pos_channel[0] = '\\0';\n        pos_channel++;\n        while (pos_channel[0] == '/')\n        {\n            pos_channel++;\n        }\n    }\n\n    /* check for SSL / IPv6 */\n    if (weechat_strcasecmp (irc_url2, \"irc6\") == 0)\n    {\n        ipv6 = 1;\n    }\n    else if (weechat_strcasecmp (irc_url2, \"ircs\") == 0)\n    {\n        ssl = 1;\n    }\n    else if ((weechat_strcasecmp (irc_url2, \"irc6s\") == 0)\n             || (weechat_strcasecmp (irc_url2, \"ircs6\") == 0))\n    {\n        ipv6 = 1;\n        ssl = 1;\n    }\n\n    if (ssl)\n    {\n        snprintf (default_port, sizeof (default_port),\n                  \"%d\", IRC_SERVER_DEFAULT_PORT_SSL);\n    }\n\n    /* search for nick, password, address+port */\n    pos_address = strchr (pos_server, '@');\n    if (pos_address)\n    {\n        pos_address[0] = '\\0';\n        pos_address++;\n        pos_nick = pos_server;\n        pos_password = strchr (pos_server, ':');\n        if (pos_password)\n        {\n            pos_password[0] = '\\0';\n            pos_password++;\n        }\n    }\n    else\n        pos_address = pos_server;\n\n    /*\n     * search for port in address, and skip optional [ ] around address\n     * (can be used to indicate IPv6 port, after ']')\n     */\n    if (pos_address[0] == '[')\n    {\n        pos_address++;\n        pos = strchr (pos_address, ']');\n        if (!pos)\n        {\n            free (irc_url2);\n            return NULL;\n        }\n        pos[0] = '\\0';\n        pos++;\n        pos_port = strchr (pos, ':');\n        if (pos_port)\n        {\n            pos_port[0] = '\\0';\n            pos_port++;\n        }\n    }\n    else\n    {\n        pos_port = strchr (pos_address, ':');\n        if (pos_port)\n        {\n            pos_port[0] = '\\0';\n            pos_port++;\n        }\n    }\n\n    ptr_server = irc_server_alloc (pos_address);\n    if (ptr_server)\n    {\n        ptr_server->temp_server = 1;\n        if (pos_address && pos_address[0])\n        {\n            length = strlen (pos_address) + 1 +\n                ((pos_port) ? strlen (pos_port) : 16) + 1;\n            server_address = malloc (length);\n            if (server_address)\n            {\n                snprintf (server_address, length,\n                          \"%s/%s\",\n                          pos_address,\n                          (pos_port && pos_port[0]) ? pos_port : default_port);\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_ADDRESSES],\n                    server_address,\n                    1);\n                free (server_address);\n            }\n        }\n        weechat_config_option_set (ptr_server->options[IRC_SERVER_OPTION_IPV6],\n                                   (ipv6) ? \"on\" : \"off\",\n                                   1);\n        weechat_config_option_set (ptr_server->options[IRC_SERVER_OPTION_SSL],\n                                   (ssl) ? \"on\" : \"off\",\n                                   1);\n        if (pos_nick && pos_nick[0])\n        {\n            length = ((strlen (pos_nick) + 2) * 5) + 1;\n            server_nicks = malloc (length);\n            if (server_nicks)\n            {\n                snprintf (server_nicks, length,\n                          \"%s,%s1,%s2,%s3,%s4\",\n                          pos_nick, pos_nick, pos_nick, pos_nick, pos_nick);\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_NICKS],\n                    server_nicks,\n                    1);\n                free (server_nicks);\n            }\n        }\n        if (pos_password && pos_password[0])\n        {\n            weechat_config_option_set (\n                ptr_server->options[IRC_SERVER_OPTION_PASSWORD],\n                pos_password,\n                1);\n        }\n        weechat_config_option_set (\n            ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT],\n            \"on\",\n            1);\n        /* autojoin */\n        if (pos_channel && pos_channel[0])\n        {\n            if (irc_channel_is_channel (ptr_server, pos_channel))\n                server_autojoin = strdup (pos_channel);\n            else\n            {\n                server_autojoin = malloc (strlen (pos_channel) + 2);\n                if (server_autojoin)\n                {\n                    strcpy (server_autojoin, \"#\");\n                    strcat (server_autojoin, pos_channel);\n                }\n            }\n            if (server_autojoin)\n            {\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN],\n                    server_autojoin,\n                    1);\n                free (server_autojoin);\n            }\n        }\n    }\n\n    free (irc_url2);\n\n    return ptr_server;\n}\n\n/*\n * Applies command line options to a server.\n *\n * For example: -ssl -nossl -password=test -proxy=myproxy\n */\n\nvoid\nirc_server_apply_command_line_options (struct t_irc_server *server,\n                                       int argc, char **argv)\n{\n    int i, index_option;\n    char *pos, *option_name, *ptr_value, *value_boolean[2] = { \"off\", \"on\" };\n\n    for (i = 0; i < argc; i++)\n    {\n        if (argv[i][0] == '-')\n        {\n            pos = strchr (argv[i], '=');\n            if (pos)\n            {\n                option_name = weechat_strndup (argv[i] + 1, pos - argv[i] - 1);\n                ptr_value = pos + 1;\n            }\n            else\n            {\n                option_name = strdup (argv[i] + 1);\n                ptr_value = value_boolean[1];\n            }\n            if (option_name)\n            {\n                if (weechat_strcasecmp (option_name, \"temp\") == 0)\n                {\n                    /* temporary server, not saved */\n                    server->temp_server = 1;\n                }\n                else\n                {\n                    index_option = irc_server_search_option (option_name);\n                    if (index_option < 0)\n                    {\n                        /* look if option is negative, like \"-noxxx\" */\n                        if (weechat_strncasecmp (argv[i], \"-no\", 3) == 0)\n                        {\n                            free (option_name);\n                            option_name = strdup (argv[i] + 3);\n                            index_option = irc_server_search_option (option_name);\n                            ptr_value = value_boolean[0];\n                        }\n                    }\n                    if (index_option >= 0)\n                    {\n                        weechat_config_option_set (server->options[index_option],\n                                                   ptr_value, 1);\n                    }\n                }\n                free (option_name);\n            }\n        }\n    }\n}\n\n/*\n * Adds a message in out queue.\n */\n\nvoid\nirc_server_outqueue_add (struct t_irc_server *server, int priority,\n                         const char *command, const char *msg1,\n                         const char *msg2, int modified, const char *tags,\n                         struct t_irc_redirect *redirect)\n{\n    struct t_irc_outqueue *new_outqueue;\n\n    new_outqueue = malloc (sizeof (*new_outqueue));\n    if (new_outqueue)\n    {\n        new_outqueue->command = (command) ? strdup (command) : strdup (\"unknown\");\n        new_outqueue->message_before_mod = (msg1) ? strdup (msg1) : NULL;\n        new_outqueue->message_after_mod = (msg2) ? strdup (msg2) : NULL;\n        new_outqueue->modified = modified;\n        new_outqueue->tags = (tags) ? strdup (tags) : NULL;\n        new_outqueue->redirect = redirect;\n\n        new_outqueue->prev_outqueue = server->last_outqueue[priority];\n        new_outqueue->next_outqueue = NULL;\n        if (server->last_outqueue[priority])\n            server->last_outqueue[priority]->next_outqueue = new_outqueue;\n        else\n            server->outqueue[priority] = new_outqueue;\n        server->last_outqueue[priority] = new_outqueue;\n    }\n}\n\n/*\n * Frees a message in out queue.\n */\n\nvoid\nirc_server_outqueue_free (struct t_irc_server *server,\n                          int priority,\n                          struct t_irc_outqueue *outqueue)\n{\n    struct t_irc_outqueue *new_outqueue;\n\n    if (!server || !outqueue)\n        return;\n\n    /* remove outqueue message */\n    if (server->last_outqueue[priority] == outqueue)\n        server->last_outqueue[priority] = outqueue->prev_outqueue;\n    if (outqueue->prev_outqueue)\n    {\n        (outqueue->prev_outqueue)->next_outqueue = outqueue->next_outqueue;\n        new_outqueue = server->outqueue[priority];\n    }\n    else\n        new_outqueue = outqueue->next_outqueue;\n\n    if (outqueue->next_outqueue)\n        (outqueue->next_outqueue)->prev_outqueue = outqueue->prev_outqueue;\n\n    /* free data */\n    if (outqueue->command)\n        free (outqueue->command);\n    if (outqueue->message_before_mod)\n        free (outqueue->message_before_mod);\n    if (outqueue->message_after_mod)\n        free (outqueue->message_after_mod);\n    if (outqueue->tags)\n        free (outqueue->tags);\n    free (outqueue);\n\n    /* set new head */\n    server->outqueue[priority] = new_outqueue;\n}\n\n/*\n * Frees all messages in out queue.\n */\n\nvoid\nirc_server_outqueue_free_all (struct t_irc_server *server, int priority)\n{\n    while (server->outqueue[priority])\n    {\n        irc_server_outqueue_free (server, priority,\n                                  server->outqueue[priority]);\n    }\n}\n\n/*\n * Frees server data.\n */\n\nvoid\nirc_server_free_data (struct t_irc_server *server)\n{\n    int i;\n\n    if (!server)\n        return;\n\n    /* free linked lists */\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        irc_server_outqueue_free_all (server, i);\n    }\n    irc_redirect_free_all (server);\n    irc_notify_free_all (server);\n    irc_channel_free_all (server);\n\n    /* free hashtables */\n    weechat_hashtable_free (server->join_manual);\n    weechat_hashtable_free (server->join_channel_key);\n    weechat_hashtable_free (server->join_noswitch);\n\n    /* free server data */\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        if (server->options[i])\n            weechat_config_option_free (server->options[i]);\n    }\n    if (server->name)\n        free (server->name);\n    if (server->addresses_eval)\n        free (server->addresses_eval);\n    if (server->addresses_array)\n        weechat_string_free_split (server->addresses_array);\n    if (server->ports_array)\n        free (server->ports_array);\n    if (server->retry_array)\n        free (server->retry_array);\n    if (server->current_address)\n        free (server->current_address);\n    if (server->current_ip)\n        free (server->current_ip);\n    if (server->hook_connect)\n        weechat_unhook (server->hook_connect);\n    if (server->hook_fd)\n        weechat_unhook (server->hook_fd);\n    if (server->hook_timer_connection)\n        weechat_unhook (server->hook_timer_connection);\n    if (server->hook_timer_sasl)\n        weechat_unhook (server->hook_timer_sasl);\n    if (server->unterminated_message)\n        free (server->unterminated_message);\n    if (server->nicks_array)\n        weechat_string_free_split (server->nicks_array);\n    if (server->nick)\n        free (server->nick);\n    if (server->nick_modes)\n        free (server->nick_modes);\n    if (server->host)\n        free (server->host);\n    if (server->cap_ls)\n        weechat_hashtable_free (server->cap_ls);\n    if (server->cap_list)\n        weechat_hashtable_free (server->cap_list);\n    if (server->isupport)\n        free (server->isupport);\n    if (server->prefix_modes)\n        free (server->prefix_modes);\n    if (server->prefix_chars)\n        free (server->prefix_chars);\n    if (server->chantypes)\n        free (server->chantypes);\n    if (server->chanmodes)\n        free (server->chanmodes);\n    if (server->away_message)\n        free (server->away_message);\n    if (server->cmd_list_regexp)\n    {\n        regfree (server->cmd_list_regexp);\n        free (server->cmd_list_regexp);\n    }\n    if (server->buffer_as_string)\n        free (server->buffer_as_string);\n}\n\n/*\n * Frees a server and remove it from list of servers.\n */\n\nvoid\nirc_server_free (struct t_irc_server *server)\n{\n    struct t_irc_server *new_irc_servers;\n\n    if (!server)\n        return;\n\n    /*\n     * close server buffer (and all channels/privates)\n     * (only if we are not in a /upgrade, because during upgrade we want to\n     * keep connections and closing server buffer would disconnect from server)\n     */\n    if (server->buffer && !irc_signal_upgrade_received)\n        weechat_buffer_close (server->buffer);\n\n    /* remove server from queue */\n    if (last_irc_server == server)\n        last_irc_server = server->prev_server;\n    if (server->prev_server)\n    {\n        (server->prev_server)->next_server = server->next_server;\n        new_irc_servers = irc_servers;\n    }\n    else\n        new_irc_servers = server->next_server;\n\n    if (server->next_server)\n        (server->next_server)->prev_server = server->prev_server;\n\n    irc_server_free_data (server);\n    free (server);\n    irc_servers = new_irc_servers;\n}\n\n/*\n * Frees all servers.\n */\n\nvoid\nirc_server_free_all ()\n{\n    /* for each server in memory, remove it */\n    while (irc_servers)\n    {\n        irc_server_free (irc_servers);\n    }\n}\n\n/*\n * Copies a server.\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_copy (struct t_irc_server *server, const char *new_name)\n{\n    struct t_irc_server *new_server;\n    struct t_infolist *infolist;\n    char *mask, *pos;\n    const char *option_name;\n    int length, index_option;\n\n    /* check if another server exists with this name */\n    if (irc_server_casesearch (new_name))\n        return NULL;\n\n    new_server = irc_server_alloc (new_name);\n    if (new_server)\n    {\n        /* duplicate options */\n        length = 32 + strlen (server->name) + 1;\n        mask = malloc (length);\n        if (!mask)\n            return 0;\n        snprintf (mask, length, \"irc.server.%s.*\", server->name);\n        infolist = weechat_infolist_get (\"option\", NULL, mask);\n        free (mask);\n        if (infolist)\n        {\n            while (weechat_infolist_next (infolist))\n            {\n                if (!weechat_infolist_integer (infolist, \"value_is_null\"))\n                {\n                    option_name = weechat_infolist_string (infolist,\n                                                           \"option_name\");\n                    pos = strrchr (option_name, '.');\n                    if (pos)\n                    {\n                        index_option = irc_server_search_option (pos + 1);\n                        if (index_option >= 0)\n                        {\n                            weechat_config_option_set (\n                                new_server->options[index_option],\n                                weechat_infolist_string (infolist, \"value\"),\n                                1);\n                        }\n                    }\n                }\n            }\n            weechat_infolist_free (infolist);\n        }\n    }\n\n    return new_server;\n}\n\n/*\n * Renames a server (internal name).\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_rename (struct t_irc_server *server, const char *new_name)\n{\n    int length;\n    char *mask, *pos_option, *new_option_name, charset_modifier[256];\n    const char *buffer_name, *option_name;\n    struct t_infolist *infolist;\n    struct t_config_option *ptr_option;\n    struct t_irc_channel *ptr_channel;\n\n    /* check if another server exists with this name */\n    if (irc_server_casesearch (new_name))\n        return 0;\n\n    /* rename options */\n    length = 32 + strlen (server->name) + 1;\n    mask = malloc (length);\n    if (!mask)\n        return 0;\n    snprintf (mask, length, \"irc.server.%s.*\", server->name);\n    infolist = weechat_infolist_get (\"option\", NULL, mask);\n    free (mask);\n    if (infolist)\n    {\n        while (weechat_infolist_next (infolist))\n        {\n            ptr_option = weechat_config_get (\n                weechat_infolist_string (infolist, \"full_name\"));\n            if (ptr_option)\n            {\n                option_name = weechat_infolist_string (infolist, \"option_name\");\n                if (option_name)\n                {\n                    pos_option = strrchr (option_name, '.');\n                    if (pos_option)\n                    {\n                        pos_option++;\n                        length = strlen (new_name) + 1 + strlen (pos_option) + 1;\n                        new_option_name = malloc (length);\n                        if (new_option_name)\n                        {\n                            snprintf (new_option_name, length,\n                                      \"%s.%s\", new_name, pos_option);\n                            weechat_config_option_rename (ptr_option, new_option_name);\n                            free (new_option_name);\n                        }\n                    }\n                }\n            }\n        }\n        weechat_infolist_free (infolist);\n    }\n\n    /* rename server */\n    if (server->name)\n        free (server->name);\n    server->name = strdup (new_name);\n\n    /* change name and local variables on buffers */\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->buffer)\n        {\n            buffer_name = irc_buffer_build_name (server->name,\n                                                 ptr_channel->name);\n            weechat_buffer_set (ptr_channel->buffer, \"name\", buffer_name);\n            weechat_buffer_set (ptr_channel->buffer, \"localvar_set_server\",\n                                server->name);\n        }\n    }\n    if (server->buffer)\n    {\n        buffer_name = irc_buffer_build_name (server->name, NULL);\n        weechat_buffer_set (server->buffer, \"name\", buffer_name);\n        weechat_buffer_set (server->buffer, \"short_name\", server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_server\",\n                            server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_channel\",\n                            server->name);\n        snprintf (charset_modifier, sizeof (charset_modifier),\n                  \"irc.%s\", server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_charset_modifier\",\n                            charset_modifier);\n    }\n\n    return 1;\n}\n\n/*\n * Reorders list of servers.\n *\n * Returns the number of servers moved in the list (>= 0).\n */\n\nint\nirc_server_reorder (const char **servers, int num_servers)\n{\n    struct t_irc_server *ptr_server, *ptr_server2;\n    int i, num_moved;\n\n    ptr_server = irc_servers;\n    num_moved = 0;\n\n    for (i = 0; ptr_server && (i < num_servers); i++)\n    {\n        for (ptr_server2 = ptr_server; ptr_server2;\n             ptr_server2 = ptr_server2->next_server)\n        {\n            if (strcmp (ptr_server2->name, servers[i]) == 0)\n                break;\n        }\n        if (ptr_server2 == ptr_server)\n        {\n            ptr_server = ptr_server->next_server;\n        }\n        else  if (ptr_server2)\n        {\n            /* extract server from list */\n            if (ptr_server2 == irc_servers)\n                irc_servers = ptr_server2->next_server;\n            if (ptr_server2 == last_irc_server)\n                last_irc_server = ptr_server2->prev_server;\n            if (ptr_server2->prev_server)\n                (ptr_server2->prev_server)->next_server = ptr_server2->next_server;\n            if (ptr_server2->next_server)\n                (ptr_server2->next_server)->prev_server = ptr_server2->prev_server;\n\n            /* set pointers in ptr_server2 */\n            ptr_server2->prev_server = ptr_server->prev_server;\n            ptr_server2->next_server = ptr_server;\n\n            /* insert ptr_server2 before ptr_server */\n            if (ptr_server->prev_server)\n                (ptr_server->prev_server)->next_server = ptr_server2;\n            ptr_server->prev_server = ptr_server2;\n\n            /* adjust list of servers if needed */\n            if (ptr_server == irc_servers)\n                irc_servers = ptr_server2;\n\n            num_moved++;\n        }\n    }\n\n    return num_moved;\n}\n\n/*\n * Sends a signal for an IRC message (received or sent).\n */\n\nvoid\nirc_server_send_signal (struct t_irc_server *server, const char *signal,\n                        const char *command, const char *full_message,\n                        const char *tags)\n{\n    int length;\n    char *str_signal, *full_message_tags;\n\n    length = strlen (server->name) + 1 + strlen (signal) + 1 + strlen (command) + 1;\n    str_signal = malloc (length);\n    if (str_signal)\n    {\n        snprintf (str_signal, length,\n                  \"%s,%s_%s\", server->name, signal, command);\n        if (tags)\n        {\n            length = strlen (tags) + 1 + strlen (full_message) + 1;\n            full_message_tags = malloc (length);\n            if (full_message_tags)\n            {\n                snprintf (full_message_tags, length,\n                          \"%s;%s\", tags, full_message);\n                (void) weechat_hook_signal_send (str_signal,\n                                                 WEECHAT_HOOK_SIGNAL_STRING,\n                                                 (void *)full_message_tags);\n                free (full_message_tags);\n            }\n        }\n        else\n        {\n            (void) weechat_hook_signal_send (str_signal,\n                                             WEECHAT_HOOK_SIGNAL_STRING,\n                                             (void *)full_message);\n        }\n        free (str_signal);\n    }\n}\n\n/*\n * Sends data to IRC server.\n *\n * Returns number of bytes sent, -1 if error.\n */\n\nint\nirc_server_send (struct t_irc_server *server, const char *buffer, int size_buf)\n{\n    int rc;\n\n    if (!server)\n    {\n        weechat_printf (\n            NULL,\n            _(\"%s%s: sending data to server: null pointer (please report \"\n              \"problem to developers)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n\n    if (size_buf <= 0)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: sending data to server: empty buffer (please report \"\n              \"problem to developers)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n\n#ifdef HAVE_GNUTLS\n    if (server->ssl_connected)\n        rc = gnutls_record_send (server->gnutls_sess, buffer, size_buf);\n    else\n#endif /* HAVE_GNUTLS */\n        rc = send (server->sock, buffer, size_buf, 0);\n\n    if (rc < 0)\n    {\n#ifdef HAVE_GNUTLS\n        if (server->ssl_connected)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: sending data to server: error %d %s\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                rc, gnutls_strerror (rc));\n        }\n        else\n#endif /* HAVE_GNUTLS */\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: sending data to server: error %d %s\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                errno, strerror (errno));\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Sets default tags used when sending message.\n */\n\nvoid\nirc_server_set_send_default_tags (const char *tags)\n{\n    irc_server_send_default_tags = tags;\n}\n\n/*\n * Gets tags to send by concatenation of tags and irc_server_send_default_tags\n * (if set).\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_tags_to_send (const char *tags)\n{\n    int length;\n    char *buf;\n\n    if (!tags && !irc_server_send_default_tags)\n        return NULL;\n\n    if (!tags)\n        return strdup (irc_server_send_default_tags);\n\n    if (!irc_server_send_default_tags)\n        return strdup (tags);\n\n    /* concatenate tags and irc_server_send_default_tags */\n    length = strlen (tags) + 1 + strlen (irc_server_send_default_tags) + 1;\n    buf = malloc (length);\n    if (buf)\n        snprintf (buf, length, \"%s,%s\", tags, irc_server_send_default_tags);\n    return buf;\n}\n\n/*\n * Sends a message from out queue.\n */\n\nvoid\nirc_server_outqueue_send (struct t_irc_server *server)\n{\n    time_t time_now;\n    char *pos, *tags_to_send;\n    int priority, anti_flood;\n\n    time_now = time (NULL);\n\n    /* detect if system clock has been changed (now lower than before) */\n    if (server->last_user_message > time_now)\n        server->last_user_message = time_now;\n\n    for (priority = 0; priority < IRC_SERVER_NUM_OUTQUEUES_PRIO; priority++)\n    {\n        switch (priority)\n        {\n            case 0:\n                anti_flood = IRC_SERVER_OPTION_INTEGER(\n                    server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH);\n                break;\n            default:\n                anti_flood = IRC_SERVER_OPTION_INTEGER(\n                    server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW);\n                break;\n        }\n        if (server->outqueue[priority]\n            && (time_now >= server->last_user_message + anti_flood))\n        {\n            if (server->outqueue[priority]->message_before_mod)\n            {\n                pos = strchr (server->outqueue[priority]->message_before_mod,\n                              '\\r');\n                if (pos)\n                    pos[0] = '\\0';\n                irc_raw_print (server, IRC_RAW_FLAG_SEND,\n                               server->outqueue[priority]->message_before_mod);\n                if (pos)\n                    pos[0] = '\\r';\n            }\n            if (server->outqueue[priority]->message_after_mod)\n            {\n                pos = strchr (server->outqueue[priority]->message_after_mod,\n                              '\\r');\n                if (pos)\n                    pos[0] = '\\0';\n                irc_raw_print (server, IRC_RAW_FLAG_SEND |\n                               ((server->outqueue[priority]->modified) ? IRC_RAW_FLAG_MODIFIED : 0),\n                               server->outqueue[priority]->message_after_mod);\n                if (pos)\n                    pos[0] = '\\r';\n\n                /* send signal with command that will be sent to server */\n                irc_server_send_signal (\n                    server, \"irc_out\",\n                    server->outqueue[priority]->command,\n                    server->outqueue[priority]->message_after_mod,\n                    NULL);\n                tags_to_send = irc_server_get_tags_to_send (\n                    server->outqueue[priority]->tags);\n                irc_server_send_signal (\n                    server, \"irc_outtags\",\n                    server->outqueue[priority]->command,\n                    server->outqueue[priority]->message_after_mod,\n                    (tags_to_send) ? tags_to_send : \"\");\n                if (tags_to_send)\n                    free (tags_to_send);\n\n                /* send command */\n                irc_server_send (\n                    server, server->outqueue[priority]->message_after_mod,\n                    strlen (server->outqueue[priority]->message_after_mod));\n                server->last_user_message = time_now;\n\n                /* start redirection if redirect is set */\n                if (server->outqueue[priority]->redirect)\n                {\n                    irc_redirect_init_command (\n                        server->outqueue[priority]->redirect,\n                        server->outqueue[priority]->message_after_mod);\n                }\n            }\n            irc_server_outqueue_free (server, priority,\n                                      server->outqueue[priority]);\n            break;\n        }\n    }\n}\n\n/*\n * Sends one message to IRC server.\n *\n * If flag contains outqueue priority value, then messages are in a queue and\n * sent slowly (to be sure there will not be any \"excess flood\"), value of\n * queue_msg is priority:\n *   1 = higher priority, for user messages\n *   2 = lower priority, for other messages (like auto reply to CTCP queries)\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_send_one_msg (struct t_irc_server *server, int flags,\n                         const char *message, const char *nick,\n                         const char *command, const char *channel,\n                         const char *tags)\n{\n    static char buffer[4096];\n    const char *ptr_msg, *ptr_chan_nick;\n    char *new_msg, *pos, *tags_to_send, *msg_encoded;\n    char str_modifier[128], modifier_data[256];\n    int rc, queue_msg, add_to_queue, first_message, anti_flood;\n    int pos_channel, pos_text, pos_encode;\n    time_t time_now;\n    struct t_irc_redirect *ptr_redirect;\n\n    rc = 1;\n\n    /* run modifier \"irc_out_xxx\" */\n    snprintf (str_modifier, sizeof (str_modifier),\n              \"irc_out_%s\",\n              (command) ? command : \"unknown\");\n    new_msg = weechat_hook_modifier_exec (str_modifier,\n                                          server->name,\n                                          message);\n\n    /* no changes in new message */\n    if (new_msg && (strcmp (message, new_msg) == 0))\n    {\n        free (new_msg);\n        new_msg = NULL;\n    }\n\n    /* message not dropped? */\n    if (!new_msg || new_msg[0])\n    {\n        first_message = 1;\n        ptr_msg = (new_msg) ? new_msg : message;\n\n        msg_encoded = NULL;\n        irc_message_parse (server, ptr_msg, NULL, NULL, NULL, NULL, NULL, NULL,\n                           NULL, NULL, NULL, NULL, NULL, &pos_channel,\n                           &pos_text);\n        switch (IRC_SERVER_OPTION_INTEGER(server,\n                                          IRC_SERVER_OPTION_CHARSET_MESSAGE))\n        {\n            case IRC_SERVER_CHARSET_MESSAGE_MESSAGE:\n                pos_encode = 0;\n                break;\n            case IRC_SERVER_CHARSET_MESSAGE_CHANNEL:\n                pos_encode = (pos_channel >= 0) ? pos_channel : pos_text;\n                break;\n            case IRC_SERVER_CHARSET_MESSAGE_TEXT:\n                pos_encode = pos_text;\n                break;\n            default:\n                pos_encode = 0;\n                break;\n        }\n        if (pos_encode >= 0)\n        {\n            ptr_chan_nick = (channel) ? channel : nick;\n            if (ptr_chan_nick)\n            {\n                snprintf (modifier_data, sizeof (modifier_data),\n                          \"%s.%s.%s\",\n                          weechat_plugin->name,\n                          server->name,\n                          ptr_chan_nick);\n            }\n            else\n            {\n                snprintf (modifier_data, sizeof (modifier_data),\n                          \"%s.%s\",\n                          weechat_plugin->name,\n                          server->name);\n            }\n            msg_encoded = irc_message_convert_charset (ptr_msg, pos_encode,\n                                                       \"charset_encode\",\n                                                       modifier_data);\n        }\n\n        if (msg_encoded)\n            ptr_msg = msg_encoded;\n\n        while (rc && ptr_msg && ptr_msg[0])\n        {\n            pos = strchr (ptr_msg, '\\n');\n            if (pos)\n                pos[0] = '\\0';\n\n            snprintf (buffer, sizeof (buffer), \"%s\\r\\n\", ptr_msg);\n\n            /* anti-flood: look whether we should queue outgoing message or not */\n            time_now = time (NULL);\n\n            /* detect if system clock has been changed (now lower than before) */\n            if (server->last_user_message > time_now)\n                server->last_user_message = time_now;\n\n            /* get queue from flags */\n            queue_msg = 0;\n            if (flags & IRC_SERVER_SEND_OUTQ_PRIO_HIGH)\n                queue_msg = 1;\n            else if (flags & IRC_SERVER_SEND_OUTQ_PRIO_LOW)\n                queue_msg = 2;\n\n            switch (queue_msg - 1)\n            {\n                case 0:\n                    anti_flood = IRC_SERVER_OPTION_INTEGER(\n                        server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH);\n                    break;\n                default:\n                    anti_flood = IRC_SERVER_OPTION_INTEGER(\n                        server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW);\n                    break;\n            }\n\n            add_to_queue = 0;\n            if ((queue_msg > 0)\n                && (server->outqueue[queue_msg - 1]\n                    || ((anti_flood > 0)\n                        && (time_now - server->last_user_message < anti_flood))))\n            {\n                add_to_queue = queue_msg;\n            }\n\n            tags_to_send = irc_server_get_tags_to_send (tags);\n\n            ptr_redirect = irc_redirect_search_available (server);\n\n            if (add_to_queue > 0)\n            {\n                /* queue message (do not send anything now) */\n                irc_server_outqueue_add (server, add_to_queue - 1, command,\n                                         (new_msg && first_message) ? message : NULL,\n                                         buffer,\n                                         (new_msg) ? 1 : 0,\n                                         tags_to_send,\n                                         ptr_redirect);\n                /* mark redirect as \"used\" */\n                if (ptr_redirect)\n                    ptr_redirect->assigned_to_command = 1;\n            }\n            else\n            {\n                if (first_message)\n                {\n                    irc_raw_print (server, IRC_RAW_FLAG_SEND, message);\n                }\n                if (new_msg)\n                {\n                    irc_raw_print (server,\n                                   IRC_RAW_FLAG_SEND | IRC_RAW_FLAG_MODIFIED,\n                                   ptr_msg);\n                }\n\n                /* send signal with command that will be sent to server */\n                irc_server_send_signal (server, \"irc_out\",\n                                        (command) ? command : \"unknown\",\n                                        ptr_msg,\n                                        NULL);\n                irc_server_send_signal (server, \"irc_outtags\",\n                                        (command) ? command : \"unknown\",\n                                        ptr_msg,\n                                        (tags_to_send) ? tags_to_send : \"\");\n\n                if (irc_server_send (server, buffer, strlen (buffer)) <= 0)\n                    rc = 0;\n                else\n                {\n                    if (queue_msg > 0)\n                        server->last_user_message = time_now;\n                }\n                if (ptr_redirect)\n                    irc_redirect_init_command (ptr_redirect, buffer);\n            }\n\n            if (tags_to_send)\n                    free (tags_to_send);\n\n            if (pos)\n            {\n                pos[0] = '\\n';\n                ptr_msg = pos + 1;\n            }\n            else\n                ptr_msg = NULL;\n\n            first_message = 0;\n        }\n        if (msg_encoded)\n            free (msg_encoded);\n    }\n    else\n    {\n        irc_raw_print (server, IRC_RAW_FLAG_SEND | IRC_RAW_FLAG_MODIFIED,\n                       _(\"(message dropped)\"));\n    }\n\n    if (new_msg)\n        free (new_msg);\n\n    return rc;\n}\n\n/*\n * Sends formatted data to IRC server.\n *\n * Many messages may be sent, separated by '\\n'.\n *\n * If flags contains \"IRC_SERVER_SEND_RETURN_HASHTABLE\", then a hashtable with\n * split of message is returned (see function irc_message_split() in\n * irc-message.c)\n *\n * Note: hashtable must be freed after use.\n */\n\nstruct t_hashtable *\nirc_server_sendf (struct t_irc_server *server, int flags, const char *tags,\n                  const char *format, ...)\n{\n    char **items, hash_key[32], value[32], *nick, *command, *channel, *new_msg;\n    char str_modifier[128];\n    const char *str_message, *str_args;\n    int i, items_count, number, ret_number, rc;\n    struct t_hashtable *hashtable, *ret_hashtable;\n\n    if (!server)\n        return NULL;\n\n    weechat_va_format (format);\n    if (!vbuffer)\n        return NULL;\n\n    ret_hashtable = NULL;\n    ret_number = 1;\n    if (flags & IRC_SERVER_SEND_RETURN_HASHTABLE)\n    {\n        ret_hashtable = weechat_hashtable_new (32,\n                                               WEECHAT_HASHTABLE_STRING,\n                                               WEECHAT_HASHTABLE_STRING,\n                                               NULL, NULL);\n    }\n\n    rc = 1;\n    items = weechat_string_split (vbuffer, \"\\n\", NULL,\n                                  WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                  | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                  | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                  0, &items_count);\n    for (i = 0; i < items_count; i++)\n    {\n        /* run modifier \"irc_out1_xxx\" (like \"irc_out_xxx\", but before split) */\n        irc_message_parse (server, items[i], NULL, NULL,\n                           &nick, NULL, NULL, &command, &channel, NULL, NULL,\n                           NULL, NULL, NULL, NULL);\n        snprintf (str_modifier, sizeof (str_modifier),\n                  \"irc_out1_%s\",\n                  (command) ? command : \"unknown\");\n        new_msg = weechat_hook_modifier_exec (str_modifier,\n                                              server->name,\n                                              items[i]);\n\n        /* no changes in new message */\n        if (new_msg && (strcmp (items[i], new_msg) == 0))\n        {\n            free (new_msg);\n            new_msg = NULL;\n        }\n\n        /* message not dropped? */\n        if (!new_msg || new_msg[0])\n        {\n            /* send signal with command that will be sent to server (before split) */\n            irc_server_send_signal (server, \"irc_out1\",\n                                    (command) ? command : \"unknown\",\n                                    (new_msg) ? new_msg : items[i],\n                                    NULL);\n\n            /*\n             * split message if needed (max is 512 bytes by default,\n             * including the final \"\\r\\n\")\n             */\n            hashtable = irc_message_split (server,\n                                           (new_msg) ? new_msg : items[i]);\n            if (hashtable)\n            {\n                number = 1;\n                while (1)\n                {\n                    snprintf (hash_key, sizeof (hash_key), \"msg%d\", number);\n                    str_message = weechat_hashtable_get (hashtable, hash_key);\n                    if (!str_message)\n                        break;\n                    snprintf (hash_key, sizeof (hash_key), \"args%d\", number);\n                    str_args = weechat_hashtable_get (hashtable, hash_key);\n\n                    rc = irc_server_send_one_msg (server, flags, str_message,\n                                                  nick, command, channel, tags);\n                    if (!rc)\n                        break;\n\n                    if (ret_hashtable)\n                    {\n                        snprintf (hash_key, sizeof (hash_key),\n                                  \"msg%d\", ret_number);\n                        weechat_hashtable_set (ret_hashtable,\n                                               hash_key, str_message);\n                        if (str_args)\n                        {\n                            snprintf (hash_key, sizeof (hash_key),\n                                      \"args%d\", ret_number);\n                            weechat_hashtable_set (ret_hashtable,\n                                                   hash_key, str_args);\n                        }\n                        ret_number++;\n                    }\n                    number++;\n                }\n                if (ret_hashtable)\n                {\n                    snprintf (value, sizeof (value), \"%d\", ret_number - 1);\n                    weechat_hashtable_set (ret_hashtable, \"count\", value);\n                }\n                weechat_hashtable_free (hashtable);\n                if (!rc)\n                    break;\n            }\n        }\n        if (nick)\n            free (nick);\n        if (command)\n            free (command);\n        if (channel)\n            free (channel);\n        if (new_msg)\n            free (new_msg);\n    }\n    if (items)\n        weechat_string_free_split (items);\n\n    free (vbuffer);\n\n    return ret_hashtable;\n}\n\n/*\n * Adds a message to received messages queue (at the end).\n */\n\nvoid\nirc_server_msgq_add_msg (struct t_irc_server *server, const char *msg)\n{\n    struct t_irc_message *message;\n\n    if (!server->unterminated_message && !msg[0])\n        return;\n\n    message = malloc (sizeof (*message));\n    if (!message)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: not enough memory for received message\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return;\n    }\n    message->server = server;\n    if (server->unterminated_message)\n    {\n        message->data = malloc (strlen (server->unterminated_message) +\n                                strlen (msg) + 1);\n        if (!message->data)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n        else\n        {\n            strcpy (message->data, server->unterminated_message);\n            strcat (message->data, msg);\n        }\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    else\n        message->data = strdup (msg);\n\n    message->next_message = NULL;\n\n    if (irc_msgq_last_msg)\n    {\n        irc_msgq_last_msg->next_message = message;\n        irc_msgq_last_msg = message;\n    }\n    else\n    {\n        irc_recv_msgq = message;\n        irc_msgq_last_msg = message;\n    }\n}\n\n/*\n * Adds an unterminated message to queue.\n */\n\nvoid\nirc_server_msgq_add_unterminated (struct t_irc_server *server,\n                                  const char *string)\n{\n    char *unterminated_message2;\n\n    if (!string[0])\n        return;\n\n    if (server->unterminated_message)\n    {\n        unterminated_message2 =\n            realloc (server->unterminated_message,\n                     (strlen (server->unterminated_message) +\n                      strlen (string) + 1));\n        if (!unterminated_message2)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            free (server->unterminated_message);\n            server->unterminated_message = NULL;\n            return;\n        }\n        server->unterminated_message = unterminated_message2;\n        strcat (server->unterminated_message, string);\n    }\n    else\n    {\n        server->unterminated_message = strdup (string);\n        if (!server->unterminated_message)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n    }\n}\n\n/*\n * Splits received buffer, creating queued messages.\n */\n\nvoid\nirc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)\n{\n    char *pos_cr, *pos_lf;\n\n    while (buffer[0])\n    {\n        pos_cr = strchr (buffer, '\\r');\n        pos_lf = strchr (buffer, '\\n');\n\n        if (!pos_cr && !pos_lf)\n        {\n            /* no CR/LF found => add to unterminated and return */\n            irc_server_msgq_add_unterminated (server, buffer);\n            return;\n        }\n\n        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))\n        {\n            /* found '\\r' first => ignore this char */\n            pos_cr[0] = '\\0';\n            irc_server_msgq_add_unterminated (server, buffer);\n            buffer = pos_cr + 1;\n        }\n        else\n        {\n            /* found: '\\n' first => terminate message */\n            pos_lf[0] = '\\0';\n            irc_server_msgq_add_msg (server, buffer);\n            buffer = pos_lf + 1;\n        }\n    }\n}\n\n/*\n * Flushes message queue.\n */\n\nvoid\nirc_server_msgq_flush ()\n{\n    struct t_irc_message *next;\n    char *ptr_data, *new_msg, *new_msg2, *ptr_msg, *ptr_msg2, *pos;\n    char *nick, *host, *command, *channel, *arguments;\n    char *msg_decoded, *msg_decoded_without_color;\n    char str_modifier[128], modifier_data[256];\n    int pos_channel, pos_text, pos_decode;\n\n    while (irc_recv_msgq)\n    {\n        if (irc_recv_msgq->data)\n        {\n            /* read message only if connection was not lost */\n            if (irc_recv_msgq->server->sock != -1)\n            {\n                ptr_data = irc_recv_msgq->data;\n                while (ptr_data[0] == ' ')\n                {\n                    ptr_data++;\n                }\n\n                if (ptr_data[0])\n                {\n                    irc_raw_print (irc_recv_msgq->server, IRC_RAW_FLAG_RECV,\n                                   ptr_data);\n\n                    irc_message_parse (irc_recv_msgq->server,\n                                       ptr_data, NULL, NULL, NULL, NULL, NULL,\n                                       &command, NULL, NULL, NULL, NULL, NULL,\n                                       NULL, NULL);\n                    snprintf (str_modifier, sizeof (str_modifier),\n                              \"irc_in_%s\",\n                              (command) ? command : \"unknown\");\n                    new_msg = weechat_hook_modifier_exec (\n                        str_modifier,\n                        irc_recv_msgq->server->name,\n                        ptr_data);\n                    if (command)\n                        free (command);\n\n                    /* no changes in new message */\n                    if (new_msg && (strcmp (ptr_data, new_msg) == 0))\n                    {\n                        free (new_msg);\n                        new_msg = NULL;\n                    }\n\n                    /* message not dropped? */\n                    if (!new_msg || new_msg[0])\n                    {\n                        /* use new message (returned by plugin) */\n                        ptr_msg = (new_msg) ? new_msg : ptr_data;\n\n                        while (ptr_msg && ptr_msg[0])\n                        {\n                            pos = strchr (ptr_msg, '\\n');\n                            if (pos)\n                                pos[0] = '\\0';\n\n                            if (new_msg)\n                            {\n                                irc_raw_print (\n                                    irc_recv_msgq->server,\n                                    IRC_RAW_FLAG_RECV | IRC_RAW_FLAG_MODIFIED,\n                                    ptr_msg);\n                            }\n\n                            irc_message_parse (irc_recv_msgq->server, ptr_msg,\n                                               NULL, NULL, &nick, NULL, &host,\n                                               &command, &channel, &arguments,\n                                               NULL, NULL, NULL,\n                                               &pos_channel, &pos_text);\n\n                            msg_decoded = NULL;\n\n\n                            switch (IRC_SERVER_OPTION_INTEGER(irc_recv_msgq->server,\n                                                              IRC_SERVER_OPTION_CHARSET_MESSAGE))\n                            {\n                                case IRC_SERVER_CHARSET_MESSAGE_MESSAGE:\n                                    pos_decode = 0;\n                                    break;\n                                case IRC_SERVER_CHARSET_MESSAGE_CHANNEL:\n                                    pos_decode = (pos_channel >= 0) ? pos_channel : pos_text;\n                                    break;\n                                case IRC_SERVER_CHARSET_MESSAGE_TEXT:\n                                    pos_decode = pos_text;\n                                    break;\n                                default:\n                                    pos_decode = 0;\n                                    break;\n                            }\n                            if (pos_decode >= 0)\n                            {\n                                /* convert charset for message */\n                                if (channel\n                                    && irc_channel_is_channel (irc_recv_msgq->server,\n                                                               channel))\n                                {\n                                    snprintf (modifier_data, sizeof (modifier_data),\n                                              \"%s.%s.%s\",\n                                              weechat_plugin->name,\n                                              irc_recv_msgq->server->name,\n                                              channel);\n                                }\n                                else\n                                {\n                                    if (nick && (!host || (strcmp (nick, host) != 0)))\n                                    {\n                                        snprintf (modifier_data,\n                                                  sizeof (modifier_data),\n                                                  \"%s.%s.%s\",\n                                                  weechat_plugin->name,\n                                                  irc_recv_msgq->server->name,\n                                                  nick);\n                                    }\n                                    else\n                                    {\n                                        snprintf (modifier_data,\n                                                  sizeof (modifier_data),\n                                                  \"%s.%s\",\n                                                  weechat_plugin->name,\n                                                  irc_recv_msgq->server->name);\n                                    }\n                                }\n                                msg_decoded = irc_message_convert_charset (\n                                    ptr_msg, pos_decode,\n                                    \"charset_decode\", modifier_data);\n                            }\n\n                            /* replace WeeChat internal color codes by \"?\" */\n                            msg_decoded_without_color =\n                                weechat_string_remove_color (\n                                    (msg_decoded) ? msg_decoded : ptr_msg,\n                                    \"?\");\n\n                            /* call modifier after charset */\n                            ptr_msg2 = (msg_decoded_without_color) ?\n                                msg_decoded_without_color : ((msg_decoded) ? msg_decoded : ptr_msg);\n                            snprintf (str_modifier, sizeof (str_modifier),\n                                      \"irc_in2_%s\",\n                                      (command) ? command : \"unknown\");\n                            new_msg2 = weechat_hook_modifier_exec (\n                                str_modifier,\n                                irc_recv_msgq->server->name,\n                                ptr_msg2);\n                            if (new_msg2 && (strcmp (ptr_msg2, new_msg2) == 0))\n                            {\n                                free (new_msg2);\n                                new_msg2 = NULL;\n                            }\n\n                            /* message not dropped? */\n                            if (!new_msg2 || new_msg2[0])\n                            {\n                                /* use new message (returned by plugin) */\n                                if (new_msg2)\n                                    ptr_msg2 = new_msg2;\n\n                                /* parse and execute command */\n                                if (irc_redirect_message (irc_recv_msgq->server,\n                                                          ptr_msg2, command,\n                                                          arguments))\n                                {\n                                    /* message redirected, we'll not display it! */\n                                }\n                                else\n                                {\n                                    /* message not redirected, display it */\n                                    irc_protocol_recv_command (\n                                        irc_recv_msgq->server,\n                                        ptr_msg2,\n                                        command,\n                                        channel);\n                                }\n                            }\n\n                            if (new_msg2)\n                                free (new_msg2);\n                            if (nick)\n                                free (nick);\n                            if (host)\n                                free (host);\n                            if (command)\n                                free (command);\n                            if (channel)\n                                free (channel);\n                            if (arguments)\n                                free (arguments);\n                            if (msg_decoded)\n                                free (msg_decoded);\n                            if (msg_decoded_without_color)\n                                free (msg_decoded_without_color);\n\n                            if (pos)\n                            {\n                                pos[0] = '\\n';\n                                ptr_msg = pos + 1;\n                            }\n                            else\n                                ptr_msg = NULL;\n                        }\n                    }\n                    else\n                    {\n                        irc_raw_print (irc_recv_msgq->server,\n                                       IRC_RAW_FLAG_RECV | IRC_RAW_FLAG_MODIFIED,\n                                       _(\"(message dropped)\"));\n                    }\n                    if (new_msg)\n                        free (new_msg);\n                }\n            }\n            free (irc_recv_msgq->data);\n        }\n\n        next = irc_recv_msgq->next_message;\n        free (irc_recv_msgq);\n        irc_recv_msgq = next;\n        if (!irc_recv_msgq)\n            irc_msgq_last_msg = NULL;\n    }\n}\n\n/*\n * Receives data from a server.\n */\n\nint\nirc_server_recv_cb (const void *pointer, void *data, int fd)\n{\n    struct t_irc_server *server;\n    static char buffer[4096 + 2];\n    int num_read, msgq_flush, end_recv;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) fd;\n\n    server = (struct t_irc_server *)pointer;\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    msgq_flush = 0;\n    end_recv = 0;\n\n    while (!end_recv)\n    {\n        end_recv = 1;\n\n#ifdef HAVE_GNUTLS\n        if (server->ssl_connected)\n            num_read = gnutls_record_recv (server->gnutls_sess, buffer,\n                                           sizeof (buffer) - 2);\n        else\n#endif /* HAVE_GNUTLS */\n            num_read = recv (server->sock, buffer, sizeof (buffer) - 2, 0);\n\n        if (num_read > 0)\n        {\n            buffer[num_read] = '\\0';\n            irc_server_msgq_add_buffer (server, buffer);\n            msgq_flush = 1;  /* the flush will be done after the loop */\n#ifdef HAVE_GNUTLS\n            if (server->ssl_connected\n                && (gnutls_record_check_pending (server->gnutls_sess) > 0))\n            {\n                /*\n                 * if there are unread data in the gnutls buffers,\n                 * go on with recv\n                 */\n                end_recv = 0;\n            }\n#endif /* HAVE_GNUTLS */\n        }\n        else\n        {\n#ifdef HAVE_GNUTLS\n            if (server->ssl_connected)\n            {\n                if ((num_read == 0)\n                    || ((num_read != GNUTLS_E_AGAIN)\n                        && (num_read != GNUTLS_E_INTERRUPTED)))\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: reading data on socket: error %d %s\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                        num_read,\n                        (num_read == 0) ? _(\"(connection closed by peer)\") :\n                        gnutls_strerror (num_read));\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: disconnecting from server...\"),\n                        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n                    irc_server_disconnect (server, !server->is_connected, 1);\n                }\n            }\n            else\n#endif /* HAVE_GNUTLS */\n            {\n                if ((num_read == 0)\n                    || ((errno != EAGAIN) && (errno != EWOULDBLOCK)))\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: reading data on socket: error %d %s\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                        errno,\n                        (num_read == 0) ? _(\"(connection closed by peer)\") :\n                        strerror (errno));\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: disconnecting from server...\"),\n                        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n                    irc_server_disconnect (server, !server->is_connected, 1);\n                }\n            }\n        }\n    }\n\n    if (msgq_flush)\n        irc_server_msgq_flush ();\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback for server connection: it is called if WeeChat is TCP-connected to\n * server, but did not receive message 001.\n */\n\nint\nirc_server_timer_connection_cb (const void *pointer, void *data,\n                                int remaining_calls)\n{\n    struct t_irc_server *server;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    server = (struct t_irc_server *)pointer;\n\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    server->hook_timer_connection = NULL;\n\n    if (!server->is_connected)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connection timeout (message 001 not received)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        irc_server_disconnect (server, !server->is_connected, 1);\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback for SASL authentication timer: it is called if there is a timeout\n * with SASL authentication (if SASL authentication is OK or failed, then hook\n * timer is removed before this callback is called).\n */\n\nint\nirc_server_timer_sasl_cb (const void *pointer, void *data, int remaining_calls)\n{\n    struct t_irc_server *server;\n    int sasl_fail;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    server = (struct t_irc_server *)pointer;\n\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    server->hook_timer_sasl = NULL;\n\n    if (!server->is_connected)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: SASL authentication timeout\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        sasl_fail = IRC_SERVER_OPTION_INTEGER(server,\n                                              IRC_SERVER_OPTION_SASL_FAIL);\n        if ((sasl_fail == IRC_SERVER_SASL_FAIL_RECONNECT)\n            || (sasl_fail == IRC_SERVER_SASL_FAIL_DISCONNECT))\n        {\n            irc_server_disconnect (\n                server, 0,\n                (sasl_fail == IRC_SERVER_SASL_FAIL_RECONNECT) ? 1 : 0);\n        }\n        else\n            irc_server_sendf (server, 0, NULL, \"CAP END\");\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called for each manual join of a server: deletes old channels in the\n * hashtable.\n */\n\nvoid\nirc_server_check_join_manual_cb (void *data,\n                                 struct t_hashtable *hashtable,\n                                 const void *key, const void *value)\n{\n    /* make C compiler happy */\n    (void) data;\n\n    if (*((time_t *)value) + (60 * 10) < time (NULL))\n        weechat_hashtable_remove (hashtable, key);\n}\n\n/*\n * Callback called for each join without switch of a server: deletes old channel\n * in the hashtable.\n */\n\nvoid\nirc_server_check_join_noswitch_cb (void *data,\n                                   struct t_hashtable *hashtable,\n                                   const void *key, const void *value)\n{\n    /* make C compiler happy */\n    (void) data;\n\n    if (*((time_t *)value) + (60 * 10) < time (NULL))\n        weechat_hashtable_remove (hashtable, key);\n}\n\n/*\n * Callback called for each smart filtered join of a channel: deletes old\n * entries in the hashtable.\n */\n\nvoid\nirc_server_check_join_smart_filtered_cb (void *data,\n                                         struct t_hashtable *hashtable,\n                                         const void *key, const void *value)\n{\n    int unmask_delay;\n\n    /* make C compiler happy */\n    (void) data;\n\n    unmask_delay = weechat_config_integer (irc_config_look_smart_filter_join_unmask);\n    if ((unmask_delay == 0)\n        || (*((time_t *)value) < time (NULL) - (unmask_delay * 60)))\n    {\n        weechat_hashtable_remove (hashtable, key);\n    }\n}\n\n/*\n * Timer called each second to perform some operations on servers.\n */\n\nint\nirc_server_timer_cb (const void *pointer, void *data, int remaining_calls)\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_redirect *ptr_redirect, *ptr_next_redirect;\n    time_t current_time;\n    static struct timeval tv;\n    int away_check, refresh_lag;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) remaining_calls;\n\n    current_time = time (NULL);\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        /* check if reconnection is pending */\n        if ((!ptr_server->is_connected)\n            && (ptr_server->reconnect_start > 0)\n            && (current_time >= (ptr_server->reconnect_start + ptr_server->reconnect_delay)))\n        {\n            irc_server_reconnect (ptr_server);\n        }\n        else\n        {\n            if (!ptr_server->is_connected)\n                continue;\n\n            /* send queued messages */\n            irc_server_outqueue_send (ptr_server);\n\n            /* check for lag */\n            if ((weechat_config_integer (irc_config_network_lag_check) > 0)\n                && (ptr_server->lag_check_time.tv_sec == 0)\n                && (current_time >= ptr_server->lag_next_check))\n            {\n                irc_server_sendf (ptr_server, 0, NULL, \"PING %s\",\n                                  (ptr_server->current_address) ?\n                                  ptr_server->current_address : \"weechat\");\n                gettimeofday (&(ptr_server->lag_check_time), NULL);\n                ptr_server->lag = 0;\n                ptr_server->lag_last_refresh = 0;\n            }\n            else\n            {\n                /* check away (only if lag check was not done) */\n                away_check = IRC_SERVER_OPTION_INTEGER(\n                    ptr_server, IRC_SERVER_OPTION_AWAY_CHECK);\n                if (!weechat_hashtable_has_key (ptr_server->cap_list,\n                                                \"away-notify\")\n                    && (away_check > 0)\n                    && ((ptr_server->last_away_check == 0)\n                        || (current_time >= ptr_server->last_away_check + (away_check * 60))))\n                {\n                    irc_server_check_away (ptr_server);\n                }\n            }\n\n            /* check if it's time to autojoin channels (after command delay) */\n            if ((ptr_server->command_time != 0)\n                && (current_time >= ptr_server->command_time +\n                    IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_COMMAND_DELAY)))\n            {\n                irc_server_autojoin_channels (ptr_server);\n                ptr_server->command_time = 0;\n            }\n\n            /* check if it's time to send MONITOR command */\n            if ((ptr_server->monitor_time != 0)\n                && (current_time >= ptr_server->monitor_time))\n            {\n                if (ptr_server->monitor > 0)\n                    irc_notify_send_monitor (ptr_server);\n                ptr_server->monitor_time = 0;\n            }\n\n            /* compute lag */\n            if (ptr_server->lag_check_time.tv_sec != 0)\n            {\n                refresh_lag = 0;\n                gettimeofday (&tv, NULL);\n                ptr_server->lag = (int)(weechat_util_timeval_diff (&(ptr_server->lag_check_time),\n                                                                   &tv) / 1000);\n                /* refresh lag item if needed */\n                if (((ptr_server->lag_last_refresh == 0)\n                     || (current_time >= ptr_server->lag_last_refresh + weechat_config_integer (irc_config_network_lag_refresh_interval)))\n                    && (ptr_server->lag >= weechat_config_integer (irc_config_network_lag_min_show)))\n                {\n                    ptr_server->lag_last_refresh = current_time;\n                    if (ptr_server->lag != ptr_server->lag_displayed)\n                    {\n                        ptr_server->lag_displayed = ptr_server->lag;\n                        refresh_lag = 1;\n                    }\n                }\n                /* lag timeout? => disconnect */\n                if ((weechat_config_integer (irc_config_network_lag_reconnect) > 0)\n                    && (ptr_server->lag >= weechat_config_integer (irc_config_network_lag_reconnect) * 1000))\n                {\n                    weechat_printf (\n                        ptr_server->buffer,\n                        _(\"%s%s: lag is high, reconnecting to server %s%s%s\"),\n                        weechat_prefix (\"network\"),\n                        IRC_PLUGIN_NAME,\n                        IRC_COLOR_CHAT_SERVER,\n                        ptr_server->name,\n                        IRC_COLOR_RESET);\n                    irc_server_disconnect (ptr_server, 0, 1);\n                }\n                else\n                {\n                    /* stop lag counting if max lag is reached */\n                    if ((weechat_config_integer (irc_config_network_lag_max) > 0)\n                        && (ptr_server->lag >= (weechat_config_integer (irc_config_network_lag_max) * 1000)))\n                    {\n                        /* refresh lag item */\n                        ptr_server->lag_last_refresh = current_time;\n                        if (ptr_server->lag != ptr_server->lag_displayed)\n                        {\n                            ptr_server->lag_displayed = ptr_server->lag;\n                            refresh_lag = 1;\n                        }\n\n                        /* schedule next lag check in 5 seconds */\n                        ptr_server->lag_check_time.tv_sec = 0;\n                        ptr_server->lag_check_time.tv_usec = 0;\n                        ptr_server->lag_next_check = time (NULL) +\n                            weechat_config_integer (irc_config_network_lag_check);\n                    }\n                }\n                if (refresh_lag)\n                    irc_server_set_lag (ptr_server);\n            }\n\n            /* remove redirects if timeout occurs */\n            ptr_redirect = ptr_server->redirects;\n            while (ptr_redirect)\n            {\n                ptr_next_redirect = ptr_redirect->next_redirect;\n\n                if ((ptr_redirect->start_time > 0)\n                    && (ptr_redirect->start_time + ptr_redirect->timeout < current_time))\n                {\n                    irc_redirect_stop (ptr_redirect, \"timeout\");\n                }\n\n                ptr_redirect = ptr_next_redirect;\n            }\n\n            /* purge some data (every 10 minutes) */\n            if (current_time > ptr_server->last_data_purge + (60 * 10))\n            {\n                weechat_hashtable_map (ptr_server->join_manual,\n                                       &irc_server_check_join_manual_cb,\n                                       NULL);\n                weechat_hashtable_map (ptr_server->join_noswitch,\n                                       &irc_server_check_join_noswitch_cb,\n                                       NULL);\n                for (ptr_channel = ptr_server->channels; ptr_channel;\n                     ptr_channel = ptr_channel->next_channel)\n                {\n                    if (ptr_channel->join_smart_filtered)\n                    {\n                        weechat_hashtable_map (ptr_channel->join_smart_filtered,\n                                               &irc_server_check_join_smart_filtered_cb,\n                                               NULL);\n                    }\n                }\n                ptr_server->last_data_purge = current_time;\n            }\n        }\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Closes server connection.\n */\n\nvoid\nirc_server_close_connection (struct t_irc_server *server)\n{\n    int i;\n\n    if (server->hook_timer_connection)\n    {\n        weechat_unhook (server->hook_timer_connection);\n        server->hook_timer_connection = NULL;\n    }\n\n    if (server->hook_timer_sasl)\n    {\n        weechat_unhook (server->hook_timer_sasl);\n        server->hook_timer_sasl = NULL;\n    }\n\n    if (server->hook_fd)\n    {\n        weechat_unhook (server->hook_fd);\n        server->hook_fd = NULL;\n    }\n\n    if (server->hook_connect)\n    {\n        weechat_unhook (server->hook_connect);\n        server->hook_connect = NULL;\n    }\n    else\n    {\n#ifdef HAVE_GNUTLS\n        /* close SSL connection */\n        if (server->ssl_connected)\n        {\n            if (server->sock != -1)\n                gnutls_bye (server->gnutls_sess, GNUTLS_SHUT_WR);\n            gnutls_deinit (server->gnutls_sess);\n        }\n#endif /* HAVE_GNUTLS */\n    }\n    if (server->sock != -1)\n    {\n#ifdef _WIN32\n        closesocket (server->sock);\n#else\n        close (server->sock);\n#endif /* _WIN32 */\n        server->sock = -1;\n    }\n\n    /* free any pending message */\n    if (server->unterminated_message)\n    {\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        irc_server_outqueue_free_all (server, i);\n    }\n\n    /* remove all redirects */\n    irc_redirect_free_all (server);\n\n    /* remove all manual joins */\n    weechat_hashtable_remove_all (server->join_manual);\n\n    /* remove all keys for pending joins */\n    weechat_hashtable_remove_all (server->join_channel_key);\n\n    /* remove all keys for joins without switch */\n    weechat_hashtable_remove_all (server->join_noswitch);\n\n    /* server is now disconnected */\n    server->is_connected = 0;\n    server->ssl_connected = 0;\n}\n\n/*\n * Schedules reconnection on server.\n */\n\nvoid\nirc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        /* growing reconnect delay */\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n\n        server->reconnect_start = time (NULL);\n\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}\n\n/*\n * Logins to server.\n */\n\nvoid\nirc_server_login (struct t_irc_server *server)\n{\n    const char *capabilities;\n    char *password, *username, *realname, *username2;\n\n    password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PASSWORD));\n    username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME));\n    realname = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME));\n\n    capabilities = IRC_SERVER_OPTION_STRING(\n        server, IRC_SERVER_OPTION_CAPABILITIES);\n\n    if (password && password[0])\n    {\n        irc_server_sendf (\n            server, 0, NULL,\n            \"PASS %s%s\",\n            ((password[0] == ':') || (strchr (password, ' '))) ? \":\" : \"\",\n            password);\n    }\n\n    if (!server->nick)\n    {\n        irc_server_set_nick (server,\n                             (server->nicks_array) ?\n                             server->nicks_array[0] : \"weechat\");\n        server->nick_first_tried = 0;\n    }\n    else\n        server->nick_first_tried = irc_server_get_nick_index (server);\n\n    server->nick_alternate_number = -1;\n\n    if (irc_server_sasl_enabled (server) || (capabilities && capabilities[0]))\n    {\n        irc_server_sendf (server, 0, NULL, \"CAP LS \" IRC_SERVER_VERSION_CAP);\n    }\n\n    username2 = (username && username[0]) ?\n        weechat_string_replace (username, \" \", \"_\") : strdup (\"weechat\");\n    irc_server_sendf (\n        server, 0, NULL,\n        \"NICK %s%s\\n\"\n        \"USER %s 0 * :%s\",\n        (server->nick && strchr (server->nick, ':')) ? \":\" : \"\",\n        server->nick,\n        (username2) ? username2 : \"weechat\",\n        (realname && realname[0]) ? realname : ((username2) ? username2 : \"weechat\"));\n    if (username2)\n        free (username2);\n\n    if (server->hook_timer_connection)\n        weechat_unhook (server->hook_timer_connection);\n    server->hook_timer_connection = weechat_hook_timer (\n        IRC_SERVER_OPTION_INTEGER (server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT) * 1000,\n        0, 1,\n        &irc_server_timer_connection_cb,\n        server, NULL);\n\n    if (password)\n        free (password);\n    if (username)\n        free (username);\n    if (realname)\n        free (realname);\n}\n\n/*\n * Switches address and tries another (called if connection failed with an\n * address/port).\n */\n\nvoid\nirc_server_switch_address (struct t_irc_server *server, int connection)\n{\n    if (server->addresses_count > 1)\n    {\n        irc_server_set_index_current_address (\n            server,\n            (server->index_current_address + 1) % server->addresses_count);\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: switching address to %s/%d\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port);\n        if (connection)\n        {\n            if (server->index_current_address == 0)\n                irc_server_reconnect_schedule (server);\n            else\n                irc_server_connect (server);\n        }\n    }\n    else\n    {\n        if (connection)\n            irc_server_reconnect_schedule (server);\n    }\n}\n\n/*\n * Reads connection status.\n */\n\nint\nirc_server_connect_cb (const void *pointer, void *data,\n                       int status, int gnutls_rc, int sock,\n                       const char *error, const char *ip_address)\n{\n    struct t_irc_server *server;\n    const char *proxy;\n\n    /* make C compiler happy */\n    (void) data;\n\n    server = (struct t_irc_server *)pointer;\n\n    proxy = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY);\n\n    server->hook_connect = NULL;\n\n    server->sock = sock;\n\n    switch (status)\n    {\n        case WEECHAT_HOOK_CONNECT_OK:\n            /* set IP */\n            if (server->current_ip)\n                free (server->current_ip);\n            server->current_ip = (ip_address) ? strdup (ip_address) : NULL;\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: connected to %s/%d (%s)\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                server->current_address,\n                server->current_port,\n                (server->current_ip) ? server->current_ip : \"?\");\n            server->hook_fd = weechat_hook_fd (server->sock,\n                                               1, 0, 0,\n                                               &irc_server_recv_cb,\n                                               server, NULL);\n            /* login to server */\n            irc_server_login (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy address \\\"%s\\\" not found\") :\n                _(\"%s%s: address \\\"%s\\\" not found\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                server->current_address);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy IP address not found\") :\n                _(\"%s%s: IP address not found\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy connection refused\") :\n                _(\"%s%s: connection refused\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: proxy fails to establish connection to server (check \"\n                  \"username/password if used and if server address/port is \"\n                  \"allowed by proxy)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unable to set local hostname/IP\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: TLS init error\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: TLS handshake failed\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n#ifdef HAVE_GNUTLS\n            if (gnutls_rc == GNUTLS_E_DH_PRIME_UNACCEPTABLE)\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: you should play with option \"\n                      \"irc.server.%s.ssl_dhkey_size (current value is %d, try \"\n                      \"a lower value like %d or %d)\"),\n                    weechat_prefix (\"error\"),\n                    IRC_PLUGIN_NAME,\n                    server->name,\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE),\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE) / 2,\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE) / 4);\n            }\n#else\n            (void) gnutls_rc;\n#endif /* HAVE_GNUTLS */\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory (%s)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                (error) ? error : \"-\");\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_TIMEOUT:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: timeout\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unable to create socket\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_reconnect_schedule (server);\n            break;\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Sets the title for a server buffer.\n */\n\nvoid\nirc_server_set_buffer_title (struct t_irc_server *server)\n{\n    char *title;\n    int length;\n\n    if (server && server->buffer)\n    {\n        if (server->is_connected)\n        {\n            length = 16 +\n                ((server->current_address) ? strlen (server->current_address) : 16) +\n                16 + ((server->current_ip) ? strlen (server->current_ip) : 16) + 1;\n            title = malloc (length);\n            if (title)\n            {\n                snprintf (title, length, \"IRC: %s/%d (%s)\",\n                          server->current_address,\n                          server->current_port,\n                          (server->current_ip) ? server->current_ip : \"\");\n                weechat_buffer_set (server->buffer, \"title\", title);\n                free (title);\n            }\n        }\n        else\n        {\n            weechat_buffer_set (server->buffer, \"title\", \"\");\n        }\n    }\n}\n\n/*\n * Creates a buffer for a server.\n *\n * Returns pointer to buffer, NULL if error.\n */\n\nstruct t_gui_buffer *\nirc_server_create_buffer (struct t_irc_server *server)\n{\n    char buffer_name[256], charset_modifier[256];\n    struct t_gui_buffer *ptr_buffer_for_merge;\n\n    ptr_buffer_for_merge = NULL;\n    switch (weechat_config_integer (irc_config_look_server_buffer))\n    {\n        case IRC_CONFIG_LOOK_SERVER_BUFFER_MERGE_WITH_CORE:\n            /* merge with WeeChat core buffer */\n            ptr_buffer_for_merge = weechat_buffer_search_main ();\n            break;\n        case IRC_CONFIG_LOOK_SERVER_BUFFER_MERGE_WITHOUT_CORE:\n            /* find buffer used to merge all IRC server buffers */\n            ptr_buffer_for_merge = irc_buffer_search_server_lowest_number ();\n            break;\n    }\n\n    snprintf (buffer_name, sizeof (buffer_name),\n              \"server.%s\", server->name);\n    server->buffer = weechat_buffer_new (buffer_name,\n                                         &irc_input_data_cb, NULL, NULL,\n                                         &irc_buffer_close_cb, NULL, NULL);\n    if (!server->buffer)\n        return NULL;\n\n    if (!weechat_buffer_get_integer (server->buffer, \"short_name_is_set\"))\n        weechat_buffer_set (server->buffer, \"short_name\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_type\", \"server\");\n    weechat_buffer_set (server->buffer, \"localvar_set_server\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_channel\", server->name);\n    snprintf (charset_modifier, sizeof (charset_modifier),\n              \"irc.%s\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_charset_modifier\",\n                        charset_modifier);\n\n    (void) weechat_hook_signal_send (\"logger_backlog\",\n                                     WEECHAT_HOOK_SIGNAL_POINTER,\n                                     server->buffer);\n\n    if (weechat_config_boolean (irc_config_network_send_unknown_commands))\n        weechat_buffer_set (server->buffer, \"input_get_unknown_commands\", \"1\");\n\n    /* set highlights settings on server buffer */\n    weechat_buffer_set (server->buffer, \"highlight_words_add\",\n                        weechat_config_string (irc_config_look_highlight_server));\n    if (weechat_config_string (irc_config_look_highlight_tags_restrict)\n        && weechat_config_string (irc_config_look_highlight_tags_restrict)[0])\n    {\n        weechat_buffer_set (\n            server->buffer, \"highlight_tags_restrict\",\n            weechat_config_string (irc_config_look_highlight_tags_restrict));\n    }\n\n    irc_server_set_buffer_title (server);\n\n    /*\n     * merge buffer if needed: if merge with(out) core set, and if no layout\n     * number is assigned for this buffer (if layout number is assigned, then\n     * buffer was already moved/merged by WeeChat core)\n     */\n    if (ptr_buffer_for_merge\n        && (weechat_buffer_get_integer (server->buffer, \"layout_number\") < 1))\n    {\n        weechat_buffer_merge (server->buffer, ptr_buffer_for_merge);\n    }\n\n    (void) weechat_hook_signal_send (\"irc_server_opened\",\n                                     WEECHAT_HOOK_SIGNAL_POINTER,\n                                     server->buffer);\n\n    return server->buffer;\n}\n\n/*\n * Searches for a fingerprint digest algorithm with the size (in bits).\n *\n * Returns index of algo in enum t_irc_fingerprint_digest_algo,\n * -1 if not found.\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_fingerprint_search_algo_with_size (int size)\n{\n    int i;\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        if (irc_fingerprint_digest_algos_size[i] == size)\n            return i;\n    }\n\n    /* digest algorithm not found */\n    return -1;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Returns a string with sizes of allowed fingerprint,\n * in number of hexadecimal digits (== bits / 4).\n *\n * Example of output: \"128=SHA-512, 64=SHA-256, 40=SHA-1\".\n *\n * Note: result must be freed after use.\n */\n\n#ifdef HAVE_GNUTLS\nchar *\nirc_server_fingerprint_str_sizes ()\n{\n    char str_sizes[1024], str_one_size[128];\n    int i;\n\n    str_sizes[0] = '\\0';\n\n    for (i = IRC_FINGERPRINT_NUM_ALGOS - 1; i >= 0; i--)\n    {\n        snprintf (str_one_size, sizeof (str_one_size),\n                  \"%d=%s%s\",\n                  irc_fingerprint_digest_algos_size[i] / 4,\n                  irc_fingerprint_digest_algos_name[i],\n                  (i > 0) ? \", \" : \"\");\n        strcat (str_sizes, str_one_size);\n    }\n\n    return strdup (str_sizes);\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Compares two fingerprints: one hexadecimal (given by user), the second binary\n * (received from IRC server).\n *\n * Returns:\n *    0: fingerprints are the same\n *   -1: fingerprints are different\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_compare_fingerprints (const char *fingerprint,\n                                 const unsigned char *fingerprint_server,\n                                 ssize_t fingerprint_size)\n{\n    ssize_t i;\n    unsigned int value;\n\n    if ((ssize_t)strlen (fingerprint) != fingerprint_size * 2)\n        return -1;\n\n    for (i = 0; i < fingerprint_size; i++)\n    {\n        if (sscanf (&fingerprint[i * 2], \"%02x\", &value) != 1)\n            return -1;\n        if (value != fingerprint_server[i])\n            return -1;\n    }\n\n    /* fingerprints are the same */\n    return 0;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Checks if a GnuTLS session uses the certificate with a given fingerprint.\n *\n * Returns:\n *   1: certificate has the good fingerprint\n *   0: certificate does NOT have the good fingerprint\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_check_certificate_fingerprint (struct t_irc_server *server,\n                                          gnutls_x509_crt_t certificate,\n                                          const char *good_fingerprints)\n{\n    unsigned char *fingerprint_server[IRC_FINGERPRINT_NUM_ALGOS];\n    char **fingerprints;\n    int i, rc, algo;\n    size_t size_bits, size_bytes;\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        fingerprint_server[i] = NULL;\n    }\n\n    /* split good_fingerprints */\n    fingerprints = weechat_string_split (good_fingerprints, \",\", NULL,\n                                         WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                         | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                         | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                         0, NULL);\n    if (!fingerprints)\n        return 0;\n\n    rc = 0;\n\n    for (i = 0; fingerprints[i]; i++)\n    {\n        size_bits = strlen (fingerprints[i]) * 4;\n        size_bytes = size_bits / 8;\n\n        algo = irc_server_fingerprint_search_algo_with_size (size_bits);\n        if (algo < 0)\n            continue;\n\n        if (!fingerprint_server[algo])\n        {\n            fingerprint_server[algo] = malloc (size_bytes);\n            if (fingerprint_server[algo])\n            {\n                /* calculate the fingerprint for the certificate */\n                if (gnutls_x509_crt_get_fingerprint (\n                        certificate,\n                        irc_fingerprint_digest_algos[algo],\n                        fingerprint_server[algo],\n                        &size_bytes) != GNUTLS_E_SUCCESS)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: failed to calculate certificate \"\n                          \"fingerprint (%s)\"),\n                        weechat_prefix (\"error\"),\n                        irc_fingerprint_digest_algos_name[algo]);\n                    free (fingerprint_server[algo]);\n                    fingerprint_server[algo] = NULL;\n                }\n            }\n            else\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: not enough memory (%s)\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                    \"fingerprint\");\n            }\n        }\n\n        if (fingerprint_server[algo])\n        {\n            /* check if the fingerprint matches */\n            if (irc_server_compare_fingerprints (fingerprints[i],\n                                                 fingerprint_server[algo],\n                                                 size_bytes) == 0)\n            {\n                rc = 1;\n                break;\n            }\n        }\n    }\n\n    weechat_string_free_split (fingerprints);\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        if (fingerprint_server[i])\n            free (fingerprint_server[i]);\n    }\n\n    return rc;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * GnuTLS callback called during handshake.\n *\n * Returns:\n *    0: certificate OK\n *   -1: error in certificate\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_gnutls_callback (const void *pointer, void *data,\n                            gnutls_session_t tls_session,\n                            const gnutls_datum_t *req_ca, int nreq,\n                            const gnutls_pk_algorithm_t *pk_algos,\n                            int pk_algos_len,\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n                            gnutls_retr2_st *answer,\n#else\n                            gnutls_retr_st *answer,\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n                            int action)\n{\n    struct t_irc_server *server;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n    gnutls_retr2_st tls_struct;\n#else\n    gnutls_retr_st tls_struct;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n    gnutls_x509_crt_t cert_temp;\n    const gnutls_datum_t *cert_list;\n    gnutls_datum_t filedatum;\n    unsigned int i, cert_list_len, status;\n    time_t cert_time;\n    char *cert_path0, *cert_path1, *cert_path2, *cert_str, *fingerprint_eval;\n    char *weechat_dir, *ssl_password;\n    const char *ptr_fingerprint;\n    int rc, ret, fingerprint_match, hostname_match, cert_temp_init;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n    gnutls_datum_t cinfo;\n    int rinfo;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n\n    /* make C compiler happy */\n    (void) data;\n    (void) req_ca;\n    (void) nreq;\n    (void) pk_algos;\n    (void) pk_algos_len;\n\n    rc = 0;\n\n    if (!pointer)\n        return -1;\n\n    server = (struct t_irc_server *) pointer;\n    cert_temp_init = 0;\n    cert_list = NULL;\n    cert_list_len = 0;\n    fingerprint_eval = NULL;\n    weechat_dir = NULL;\n\n    if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_VERIFY_CERT)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%sgnutls: connected using %d-bit Diffie-Hellman shared secret \"\n              \"exchange\"),\n            weechat_prefix (\"network\"),\n            IRC_SERVER_OPTION_INTEGER (server,\n                                       IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n\n        /* initialize the certificate structure */\n        if (gnutls_x509_crt_init (&cert_temp) != GNUTLS_E_SUCCESS)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: failed to initialize certificate structure\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n            goto end;\n        }\n\n        /* flag to do the \"deinit\" (at the end of function) */\n        cert_temp_init = 1;\n\n        /* get fingerprint option in server */\n        ptr_fingerprint = IRC_SERVER_OPTION_STRING(server,\n                                                   IRC_SERVER_OPTION_SSL_FINGERPRINT);\n        fingerprint_eval = irc_server_eval_fingerprint (server);\n        if (!fingerprint_eval)\n        {\n            rc = -1;\n            goto end;\n        }\n\n        /* set match options */\n        fingerprint_match = (ptr_fingerprint && ptr_fingerprint[0]) ? 0 : 1;\n        hostname_match = 0;\n\n        /* get the peer's raw certificate (chain) as sent by the peer */\n        cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n        if (cert_list)\n        {\n            weechat_printf (\n                server->buffer,\n                NG_(\"%sgnutls: receiving %d certificate\",\n                    \"%sgnutls: receiving %d certificates\",\n                    cert_list_len),\n                weechat_prefix (\"network\"),\n                cert_list_len);\n\n            for (i = 0; i < cert_list_len; i++)\n            {\n                if (gnutls_x509_crt_import (cert_temp,\n                                            &cert_list[i],\n                                            GNUTLS_X509_FMT_DER) != GNUTLS_E_SUCCESS)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: failed to import certificate[%d]\"),\n                        weechat_prefix (\"error\"), i + 1);\n                    rc = -1;\n                    goto end;\n                }\n\n                /* checks on first certificate received */\n                if (i == 0)\n                {\n                    /* check if fingerprint matches the first certificate */\n                    if (fingerprint_eval && fingerprint_eval[0])\n                    {\n                        fingerprint_match = irc_server_check_certificate_fingerprint (\n                            server, cert_temp, fingerprint_eval);\n                    }\n                    /* check if hostname matches in the first certificate */\n                    if (gnutls_x509_crt_check_hostname (cert_temp,\n                                                        server->current_address) != 0)\n                    {\n                        hostname_match = 1;\n                    }\n                }\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n                /* display infos about certificate */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400 /* 2.4.0 */\n                rinfo = gnutls_x509_crt_print (cert_temp,\n                                               GNUTLS_X509_CRT_ONELINE, &cinfo);\n#else\n                rinfo = gnutls_x509_crt_print (cert_temp,\n                                               GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n#endif /*  LIBGNUTLS_VERSION_NUMBER < 0x020400 */\n                if (rinfo == 0)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s - certificate[%d] info:\"),\n                        weechat_prefix (\"network\"), i + 1);\n                    weechat_printf (\n                        server->buffer,\n                        \"%s   - %s\",\n                        weechat_prefix (\"network\"), cinfo.data);\n                    gnutls_free (cinfo.data);\n                }\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n                /* check dates, only if fingerprint is not set */\n                if (!ptr_fingerprint || !ptr_fingerprint[0])\n                {\n                    /* check expiration date */\n                    cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n                    if (cert_time < time (NULL))\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: certificate has expired\"),\n                            weechat_prefix (\"error\"));\n                        rc = -1;\n                    }\n                    /* check activation date */\n                    cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n                    if (cert_time > time (NULL))\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: certificate is not yet activated\"),\n                            weechat_prefix (\"error\"));\n                        rc = -1;\n                    }\n                }\n            }\n\n            /*\n             * if fingerprint is set, display if matches, and don't check\n             * anything else\n             */\n            if (ptr_fingerprint && ptr_fingerprint[0])\n            {\n                if (fingerprint_match)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: certificate fingerprint matches\"),\n                        weechat_prefix (\"network\"));\n                }\n                else\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: certificate fingerprint does NOT match \"\n                          \"(check value of option \"\n                          \"irc.server.%s.ssl_fingerprint)\"),\n                        weechat_prefix (\"error\"), server->name);\n                    rc = -1;\n                }\n                goto end;\n            }\n\n            if (!hostname_match)\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%sgnutls: the hostname in the certificate does NOT \"\n                      \"match \\\"%s\\\"\"),\n                    weechat_prefix (\"error\"), server->current_address);\n                rc = -1;\n            }\n        }\n\n        /* verify the peer\u2019s certificate */\n        if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: error while checking peer's certificate\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n            goto end;\n        }\n\n        /* check if certificate is trusted */\n        if (status & GNUTLS_CERT_INVALID)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate is NOT trusted\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate is trusted\"),\n                weechat_prefix (\"network\"));\n        }\n\n        /* check if certificate issuer is known */\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate issuer is unknown\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n\n        /* check that certificate is not revoked */\n        if (status & GNUTLS_CERT_REVOKED)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: the certificate has been revoked\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n    }\n    else if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_SET_CERT)\n    {\n        /* using client certificate if it exists */\n        cert_path0 = (char *) IRC_SERVER_OPTION_STRING(\n            server, IRC_SERVER_OPTION_SSL_CERT);\n        if (cert_path0 && cert_path0[0])\n        {\n            weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n            cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n            cert_path2 = (cert_path1) ?\n                weechat_string_expand_home (cert_path1) : NULL;\n\n            if (cert_path2)\n            {\n                cert_str = weechat_file_get_content (cert_path2);\n                if (cert_str)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: sending one certificate\"),\n                        weechat_prefix (\"network\"));\n\n                    filedatum.data = (unsigned char *) cert_str;\n                    filedatum.size = strlen (cert_str);\n\n                    /* certificate */\n                    gnutls_x509_crt_init (&server->tls_cert);\n                    gnutls_x509_crt_import (server->tls_cert, &filedatum,\n                                            GNUTLS_X509_FMT_PEM);\n\n                    /* key password */\n                    ssl_password = irc_server_eval_expression (\n                        server,\n                        IRC_SERVER_OPTION_STRING(server,\n                                                 IRC_SERVER_OPTION_SSL_PASSWORD));\n\n                    /* key */\n                    gnutls_x509_privkey_init (&server->tls_cert_key);\n\n/*\n * gnutls_x509_privkey_import2 has no \"Since: ...\" in GnuTLS manual but\n * GnuTLS NEWS file lists it being added in 3.1.0:\n * https://gitlab.com/gnutls/gnutls/blob/2b715b9564681acb3008a5574dcf25464de8b038/NEWS#L2552\n */\n#if LIBGNUTLS_VERSION_NUMBER >= 0x030100 /* 3.1.0 */\n                    ret = gnutls_x509_privkey_import2 (server->tls_cert_key,\n                                                       &filedatum,\n                                                       GNUTLS_X509_FMT_PEM,\n                                                       ssl_password,\n                                                       0);\n#else\n                    ret = gnutls_x509_privkey_import (server->tls_cert_key,\n                                                      &filedatum,\n                                                      GNUTLS_X509_FMT_PEM);\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x0301000 */\n\n                    if (ret < 0)\n                    {\n                        ret = gnutls_x509_privkey_import_pkcs8 (\n                            server->tls_cert_key,\n                            &filedatum,\n                            GNUTLS_X509_FMT_PEM,\n                            ssl_password,\n                            GNUTLS_PKCS_PLAIN);\n                    }\n                    if (ret < 0)\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: invalid certificate \\\"%s\\\", error: \"\n                              \"%s\"),\n                            weechat_prefix (\"error\"), cert_path2,\n                            gnutls_strerror (ret));\n                        rc = -1;\n                    }\n                    else\n                    {\n\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n                        tls_struct.cert_type = GNUTLS_CRT_X509;\n                        tls_struct.key_type = GNUTLS_PRIVKEY_X509;\n#else\n                        tls_struct.type = GNUTLS_CRT_X509;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n                        tls_struct.ncerts = 1;\n                        tls_struct.deinit_all = 0;\n                        tls_struct.cert.x509 = &server->tls_cert;\n                        tls_struct.key.x509 = server->tls_cert_key;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n                        /* client certificate info */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400 /* 2.4.0 */\n                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                       GNUTLS_X509_CRT_ONELINE,\n                                                       &cinfo);\n#else\n                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                       GNUTLS_CRT_PRINT_ONELINE,\n                                                       &cinfo);\n#endif /* LIBGNUTLS_VERSION_NUMBER < 0x020400 */\n                        if (rinfo == 0)\n                        {\n                            weechat_printf (\n                                server->buffer,\n                                _(\"%s - client certificate info (%s):\"),\n                                weechat_prefix (\"network\"), cert_path2);\n                            weechat_printf (\n                                server->buffer, \"%s  - %s\",\n                                weechat_prefix (\"network\"), cinfo.data);\n                            gnutls_free (cinfo.data);\n                        }\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n                        memcpy (answer, &tls_struct, sizeof (tls_struct));\n                        free (cert_str);\n                    }\n\n                    if (ssl_password)\n                        free (ssl_password);\n                }\n                else\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: unable to read certificate \\\"%s\\\"\"),\n                        weechat_prefix (\"error\"), cert_path2);\n                }\n            }\n\n            if (cert_path1)\n                free (cert_path1);\n            if (cert_path2)\n                free (cert_path2);\n        }\n    }\n\nend:\n    /* an error should stop the handshake unless the user doesn't care */\n    if ((rc == -1)\n        && (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY) == 0))\n    {\n        rc = 0;\n    }\n\n    if (cert_temp_init)\n        gnutls_x509_crt_deinit (cert_temp);\n    if (weechat_dir)\n        free (weechat_dir);\n    if (fingerprint_eval)\n        free (fingerprint_eval);\n\n    return rc;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Connects to a server.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_connect (struct t_irc_server *server)\n{\n    int length;\n    char *option_name;\n    struct t_config_option *proxy_type, *proxy_ipv6, *proxy_address;\n    struct t_config_option *proxy_port;\n    const char *proxy, *str_proxy_type, *str_proxy_address;\n\n    server->disconnected = 0;\n\n    if (!server->buffer)\n    {\n        if (!irc_server_create_buffer (server))\n            return 0;\n        weechat_buffer_set (server->buffer, \"display\", \"auto\");\n    }\n\n    irc_bar_item_update_channel ();\n\n    irc_server_set_index_current_address (server,\n                                          server->index_current_address);\n\n    if (!server->current_address)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: unknown address for server \\\"%s\\\", cannot connect\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n        return 0;\n    }\n\n    /* free some old values (from a previous connection to server) */\n    if (server->isupport)\n    {\n        free (server->isupport);\n        server->isupport = NULL;\n    }\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    proxy_type = NULL;\n    proxy_ipv6 = NULL;\n    proxy_address = NULL;\n    proxy_port = NULL;\n    str_proxy_type = NULL;\n    str_proxy_address = NULL;\n\n    proxy = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY);\n    if (proxy && proxy[0])\n    {\n        length = 32 + strlen (proxy) + 1;\n        option_name = malloc (length);\n        if (!option_name)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory (%s)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                \"proxy\");\n            return 0;\n        }\n        snprintf (option_name, length, \"weechat.proxy.%s.type\", proxy);\n        proxy_type = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.ipv6\", proxy);\n        proxy_ipv6 = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.address\", proxy);\n        proxy_address = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.port\", proxy);\n        proxy_port = weechat_config_get (option_name);\n        free (option_name);\n        if (!proxy_type || !proxy_address)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: proxy \\\"%s\\\" not found for server \\\"%s\\\", cannot \"\n                  \"connect\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, proxy, server->name);\n            return 0;\n        }\n        str_proxy_type = weechat_config_string (proxy_type);\n        str_proxy_address = weechat_config_string (proxy_address);\n        if (!str_proxy_type[0] || !proxy_ipv6 || !str_proxy_address[0]\n            || !proxy_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: missing proxy settings, check options for proxy \"\n                  \"\\\"%s\\\"\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, proxy);\n            return 0;\n        }\n    }\n\n    if (!server->nicks_array)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: nicks not defined for server \\\"%s\\\", cannot connect\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n        return 0;\n    }\n\n#ifndef HAVE_GNUTLS\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL))\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: cannot connect with SSL because WeeChat was not built \"\n              \"with GnuTLS support\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n#endif /* HAVE_GNUTLS */\n    if (proxy_type)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connecting to server %s/%d%s via %s proxy %s/%d%s...\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\",\n            str_proxy_type,\n            str_proxy_address,\n            weechat_config_integer (proxy_port),\n            (weechat_config_boolean (proxy_ipv6)) ? \" (IPv6)\" : \"\");\n        weechat_log_printf (\n            _(\"Connecting to server %s/%d%s via %s proxy %s/%d%s...\"),\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\",\n            str_proxy_type,\n            str_proxy_address,\n            weechat_config_integer (proxy_port),\n            (weechat_config_boolean (proxy_ipv6)) ? \" (IPv6)\" : \"\");\n    }\n    else\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connecting to server %s/%d%s...\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\");\n        weechat_log_printf (\n            _(\"%s%s: connecting to server %s/%d%s...\"),\n            \"\",\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\");\n    }\n\n    /* close connection if opened */\n    irc_server_close_connection (server);\n\n    /* open auto-joined channels now (if needed) */\n    if (weechat_config_boolean (irc_config_look_buffer_open_before_autojoin)\n        && !server->disable_autojoin)\n    {\n        irc_server_autojoin_create_buffers (server);\n    }\n\n    /* init SSL if asked and connect */\n    server->ssl_connected = 0;\n#ifdef HAVE_GNUTLS\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL))\n        server->ssl_connected = 1;\n    server->hook_connect = weechat_hook_connect (\n        proxy,\n        server->current_address,\n        server->current_port,\n        proxy_type ? weechat_config_integer (proxy_ipv6) : IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6),\n        server->current_retry,\n        (server->ssl_connected) ? &server->gnutls_sess : NULL,\n        (server->ssl_connected) ? &irc_server_gnutls_callback : NULL,\n        IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE),\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PRIORITIES),\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME),\n        &irc_server_connect_cb,\n        server,\n        NULL);\n#else\n    server->hook_connect = weechat_hook_connect (\n        proxy,\n        server->current_address,\n        server->current_port,\n        proxy_type ? weechat_config_integer (proxy_ipv6) : IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6),\n        server->current_retry,\n        NULL, NULL, 0, NULL,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME),\n        &irc_server_connect_cb,\n        server,\n        NULL);\n#endif /* HAVE_GNUTLS */\n\n    /* send signal \"irc_server_connecting\" with server name */\n    (void) weechat_hook_signal_send (\"irc_server_connecting\",\n                                     WEECHAT_HOOK_SIGNAL_STRING, server->name);\n\n    return 1;\n}\n\n/*\n * Reconnects to a server (after disconnection).\n */\n\nvoid\nirc_server_reconnect (struct t_irc_server *server)\n{\n    weechat_printf (\n        server->buffer,\n        _(\"%s%s: reconnecting to server...\"),\n        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n\n    server->reconnect_start = 0;\n\n    if (irc_server_connect (server))\n        server->reconnect_join = 1;\n    else\n        irc_server_reconnect_schedule (server);\n}\n\n/*\n * Callback for auto-connect to servers (called at startup).\n */\n\nint\nirc_server_auto_connect_timer_cb (const void *pointer, void *data,\n                                  int remaining_calls)\n{\n    struct t_irc_server *ptr_server;\n    int auto_connect;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    auto_connect = (pointer) ? 1 : 0;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if ((auto_connect || ptr_server->temp_server)\n            && (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOCONNECT)))\n        {\n            if (!irc_server_connect (ptr_server))\n                irc_server_reconnect_schedule (ptr_server);\n        }\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Auto-connects to servers (called at startup).\n *\n * If auto_connect == 1, auto-connects to all servers with flag \"autoconnect\".\n * If auto_connect == 0, auto-connect to temporary servers only.\n */\n\nvoid\nirc_server_auto_connect (int auto_connect)\n{\n    weechat_hook_timer (1, 0, 1,\n                        &irc_server_auto_connect_timer_cb,\n                        (auto_connect) ? (void *)1 : (void *)0,\n                        NULL);\n}\n\n/*\n * Disconnects from a server.\n */\n\nvoid\nirc_server_disconnect (struct t_irc_server *server, int switch_address,\n                       int reconnect)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        /*\n         * remove all nicks and write disconnection message on each\n         * channel/private buffer\n         */\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            irc_nick_free_all (server, ptr_channel);\n            if (ptr_channel->hook_autorejoin)\n            {\n                weechat_unhook (ptr_channel->hook_autorejoin);\n                ptr_channel->hook_autorejoin = NULL;\n            }\n            weechat_buffer_set (ptr_channel->buffer, \"localvar_del_away\", \"\");\n            weechat_printf (\n                ptr_channel->buffer,\n                _(\"%s%s: disconnected from server\"),\n                weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n        }\n        /* remove away status on server buffer */\n        weechat_buffer_set (server->buffer, \"localvar_del_away\", \"\");\n    }\n\n    irc_server_close_connection (server);\n\n    if (server->buffer)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: disconnected from server\"),\n            weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n    }\n\n    server->current_retry = 0;\n\n    if (switch_address)\n        irc_server_switch_address (server, 0);\n    else\n        irc_server_set_index_current_address (server, 0);\n\n    if (server->nick_modes)\n    {\n        free (server->nick_modes);\n        server->nick_modes = NULL;\n        weechat_bar_item_update (\"input_prompt\");\n        weechat_bar_item_update (\"irc_nick_modes\");\n    }\n    if (server->host)\n    {\n        free (server->host);\n        server->host = NULL;\n        weechat_bar_item_update (\"irc_host\");\n        weechat_bar_item_update (\"irc_nick_host\");\n    }\n    server->checking_cap_ls = 0;\n    weechat_hashtable_remove_all (server->cap_ls);\n    server->checking_cap_list = 0;\n    weechat_hashtable_remove_all (server->cap_list);\n    server->is_away = 0;\n    server->away_time = 0;\n    server->lag = 0;\n    server->lag_displayed = -1;\n    server->lag_check_time.tv_sec = 0;\n    server->lag_check_time.tv_usec = 0;\n    server->lag_next_check = time (NULL) +\n        weechat_config_integer (irc_config_network_lag_check);\n    server->lag_last_refresh = 0;\n    irc_server_set_lag (server);\n    server->monitor = 0;\n    server->monitor_time = 0;\n\n    if (reconnect\n        && IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n        irc_server_reconnect_schedule (server);\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n\n    /* discard current nick if no reconnection asked */\n    if (!reconnect && server->nick)\n        irc_server_set_nick (server, NULL);\n\n    irc_server_set_buffer_title (server);\n\n    server->disconnected = 1;\n\n    /* send signal \"irc_server_disconnected\" with server name */\n    (void) weechat_hook_signal_send (\"irc_server_disconnected\",\n                                     WEECHAT_HOOK_SIGNAL_STRING, server->name);\n}\n\n/*\n * Disconnects from all servers.\n */\n\nvoid\nirc_server_disconnect_all ()\n{\n    struct t_irc_server *ptr_server;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        irc_server_disconnect (ptr_server, 0, 0);\n    }\n}\n\n/*\n * Creates buffers for auto-joined channels on a server.\n */\n\nvoid\nirc_server_autojoin_create_buffers (struct t_irc_server *server)\n{\n    const char *pos_space;\n    char *autojoin, *autojoin2, **channels;\n    int num_channels, i;\n\n    /* buffers are opened only if no channels are currently opened */\n    if (server->channels)\n        return;\n\n    /* evaluate server option \"autojoin\" */\n    autojoin = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN));\n\n    /* extract channel names from autojoin option */\n    if (autojoin && autojoin[0])\n    {\n        pos_space = strchr (autojoin, ' ');\n        autojoin2 = (pos_space) ?\n            weechat_strndup (autojoin, pos_space - autojoin) :\n            strdup (autojoin);\n        if (autojoin2)\n        {\n            channels = weechat_string_split (\n                autojoin2,\n                \",\",\n                NULL,\n                WEECHAT_STRING_SPLIT_STRIP_LEFT\n                | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                0,\n                &num_channels);\n            if (channels)\n            {\n                for (i = 0; i < num_channels; i++)\n                {\n                    irc_channel_create_buffer (\n                        server, IRC_CHANNEL_TYPE_CHANNEL, channels[i],\n                        1, 1);\n                }\n                weechat_string_free_split (channels);\n            }\n            free (autojoin2);\n        }\n    }\n\n    if (autojoin)\n        free (autojoin);\n}\n\n/*\n * Autojoins (or auto-rejoins) channels.\n */\n\nvoid\nirc_server_autojoin_channels (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n    char *autojoin;\n\n    /* auto-join after disconnection (only rejoins opened channels) */\n    if (!server->disable_autojoin && server->reconnect_join && server->channels)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if ((ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                && !ptr_channel->part)\n            {\n                if (ptr_channel->key)\n                {\n                    irc_server_sendf (server,\n                                      IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                                      \"JOIN %s %s\",\n                                      ptr_channel->name, ptr_channel->key);\n                }\n                else\n                {\n                    irc_server_sendf (server,\n                                      IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                                      \"JOIN %s\",\n                                      ptr_channel->name);\n                }\n            }\n        }\n        server->reconnect_join = 0;\n    }\n    else\n    {\n        /* auto-join when connecting to server for first time */\n        autojoin = irc_server_eval_expression (\n            server,\n            IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN));\n        if (!server->disable_autojoin && autojoin && autojoin[0])\n            irc_command_join_server (server, autojoin, 0, 0);\n        if (autojoin)\n            free (autojoin);\n    }\n\n    server->disable_autojoin = 0;\n}\n\n/*\n * Returns number of channels for server.\n */\n\nint\nirc_server_get_channel_count (struct t_irc_server *server)\n{\n    int count;\n    struct t_irc_channel *ptr_channel;\n\n    count = 0;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n        count++;\n    }\n    return count;\n}\n\n/*\n * Returns number of pv for server.\n */\n\nint\nirc_server_get_pv_count (struct t_irc_server *server)\n{\n    int count;\n    struct t_irc_channel *ptr_channel;\n\n    count = 0;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->type == IRC_CHANNEL_TYPE_PRIVATE)\n            count++;\n    }\n    return count;\n}\n\n/*\n * Removes away for all channels/nicks (for all servers).\n */\n\nvoid\nirc_server_remove_away (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_remove_away (server, ptr_channel);\n        }\n        server->last_away_check = 0;\n    }\n}\n\n/*\n * Checks for away on all channels of a server.\n */\n\nvoid\nirc_server_check_away (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_check_whox (server, ptr_channel);\n        }\n        server->last_away_check = time (NULL);\n    }\n}\n\n/*\n * Sets/unsets away status for a server (all channels).\n */\n\nvoid\nirc_server_set_away (struct t_irc_server *server, const char *nick, int is_away)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        /* set/del \"away\" local variable on server buffer */\n        if (is_away)\n        {\n            weechat_buffer_set (server->buffer,\n                                \"localvar_set_away\", server->away_message);\n        }\n        else\n        {\n            weechat_buffer_set (server->buffer,\n                                \"localvar_del_away\", \"\");\n        }\n\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            /* set away flag for nick on channel */\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_set_away (server, ptr_channel, nick, is_away);\n\n            /* set/del \"away\" local variable on channel buffer */\n            if (is_away)\n            {\n                weechat_buffer_set (ptr_channel->buffer,\n                                    \"localvar_set_away\", server->away_message);\n            }\n            else\n            {\n                weechat_buffer_set (ptr_channel->buffer,\n                                    \"localvar_del_away\", \"\");\n            }\n        }\n    }\n}\n\n/*\n * Callback called when user sends (file or chat) to someone and that xfer\n * plugin successfully initialized xfer and is ready for sending.\n *\n * In that case, irc plugin sends message to remote nick and wait for \"accept\"\n * reply.\n */\n\nint\nirc_server_xfer_send_ready_cb (const void *pointer, void *data,\n                               const char *signal,\n                               const char *type_data, void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *type, *filename, *local_address;\n    char converted_addr[NI_MAXHOST];\n    struct addrinfo *ainfo;\n    struct sockaddr_in *saddr;\n    int spaces_in_name, rc;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0)\n            && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                converted_addr[0] = '\\0';\n                local_address = weechat_infolist_string (infolist,\n                                                         \"local_address\");\n                if (local_address)\n                {\n                    res_init ();\n                    rc = getaddrinfo (local_address, NULL, NULL, &ainfo);\n                    if ((rc == 0) && ainfo && ainfo->ai_addr)\n                    {\n                        if (ainfo->ai_family == AF_INET)\n                        {\n                            /* transform dotted 4 IP address to ulong string */\n                            saddr = (struct sockaddr_in *)ainfo->ai_addr;\n                            snprintf (converted_addr, sizeof (converted_addr),\n                                      \"%lu\",\n                                      (unsigned long)ntohl (saddr->sin_addr.s_addr));\n                        }\n                        else\n                        {\n                            snprintf (converted_addr, sizeof (converted_addr),\n                                      \"%s\", local_address);\n                        }\n                    }\n                }\n\n                type = weechat_infolist_string (infolist, \"type_string\");\n                if (type && converted_addr[0])\n                {\n                    /* send DCC PRIVMSG */\n                    if (strcmp (type, \"file_send\") == 0)\n                    {\n                        filename = weechat_infolist_string (infolist, \"filename\");\n                        spaces_in_name = (strchr (filename, ' ') != NULL);\n                        irc_server_sendf (\n                            ptr_server,\n                            IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                            \"PRIVMSG %s :\\01DCC SEND %s%s%s \"\n                            \"%s %d %s\\01\",\n                            weechat_infolist_string (infolist, \"remote_nick\"),\n                            (spaces_in_name) ? \"\\\"\" : \"\",\n                            filename,\n                            (spaces_in_name) ? \"\\\"\" : \"\",\n                            converted_addr,\n                            weechat_infolist_integer (infolist, \"port\"),\n                            weechat_infolist_string (infolist, \"size\"));\n                    }\n                    else if (strcmp (type, \"chat_send\") == 0)\n                    {\n                        irc_server_sendf (\n                            ptr_server,\n                            IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                            \"PRIVMSG %s :\\01DCC CHAT chat %s %d\\01\",\n                            weechat_infolist_string (infolist, \"remote_nick\"),\n                            converted_addr,\n                            weechat_infolist_integer (infolist, \"port\"));\n                    }\n                }\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called when user receives a file and that resume is possible (file\n * is partially received).\n *\n * In that case, irc plugin sends message to remote nick with resume position.\n */\n\nint\nirc_server_xfer_resume_ready_cb (const void *pointer, void *data,\n                                 const char *signal,\n                                 const char *type_data, void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *filename;\n    int spaces_in_name;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0) && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                filename = weechat_infolist_string (infolist, \"filename\");\n                spaces_in_name = (strchr (filename, ' ') != NULL);\n                irc_server_sendf (\n                    ptr_server,\n                    IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                    \"PRIVMSG %s :\\01DCC RESUME %s%s%s %d %s\\01\",\n                    weechat_infolist_string (infolist, \"remote_nick\"),\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    filename,\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    weechat_infolist_integer (infolist, \"port\"),\n                    weechat_infolist_string (infolist, \"start_resume\"));\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called when xfer plugin accepted resume request from receiver.\n *\n * In that case, irc plugin sends accept message to remote nick with resume\n * position.\n */\n\nint\nirc_server_xfer_send_accept_resume_cb (const void *pointer, void *data,\n                                       const char *signal,\n                                       const char *type_data,\n                                       void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *filename;\n    int spaces_in_name;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0) && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                filename = weechat_infolist_string (infolist, \"filename\");\n                spaces_in_name = (strchr (filename, ' ') != NULL);\n                irc_server_sendf (\n                    ptr_server,\n                    IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                    \"PRIVMSG %s :\\01DCC ACCEPT %s%s%s %d %s\\01\",\n                    weechat_infolist_string (infolist, \"remote_nick\"),\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    filename,\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    weechat_infolist_integer (infolist, \"port\"),\n                    weechat_infolist_string (infolist, \"start_resume\"));\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Returns hdata for server.\n */\n\nstruct t_hdata *\nirc_server_hdata_server_cb (const void *pointer, void *data,\n                            const char *hdata_name)\n{\n    struct t_hdata *hdata;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n\n    hdata = weechat_hdata_new (hdata_name, \"prev_server\", \"next_server\",\n                               0, 0, NULL, NULL);\n    if (hdata)\n    {\n        WEECHAT_HDATA_VAR(struct t_irc_server, name, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, options, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, temp_server, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reloading_from_config, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reloaded_from_config, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_eval, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_array, STRING, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, ports_array, INTEGER, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, retry_array, INTEGER, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, index_current_address, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_address, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_ip, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_port, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_retry, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, sock, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_connect, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_fd, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_timer_connection, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_timer_sasl, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, is_connected, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, ssl_connected, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, disconnected, INTEGER, 0, NULL, NULL);\n#ifdef HAVE_GNUTLS\n        WEECHAT_HDATA_VAR(struct t_irc_server, gnutls_sess, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, tls_cert, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, tls_cert_key, OTHER, 0, NULL, NULL);\n#endif /* HAVE_GNUTLS */\n        WEECHAT_HDATA_VAR(struct t_irc_server, unterminated_message, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nicks_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nicks_array, STRING, 0, \"nicks_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_first_tried, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_alternate_number, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_modes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, host, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, checking_cap_ls, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cap_ls, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, checking_cap_list, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cap_list, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, isupport, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, prefix_modes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, prefix_chars, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, user_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, host_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, casemapping, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, chantypes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, chanmodes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, monitor, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, monitor_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_delay, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_start, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, command_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_join, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, disable_autojoin, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, is_away, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, away_message, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, away_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_displayed, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_check_time, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_next_check, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_last_refresh, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cmd_list_regexp, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_user_message, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_away_check, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_data_purge, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, outqueue, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_outqueue, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, redirects, POINTER, 0, NULL, \"irc_redirect\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_redirect, POINTER, 0, NULL, \"irc_redirect\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, notify_list, POINTER, 0, NULL, \"irc_notify\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_notify, POINTER, 0, NULL, \"irc_notify\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, notify_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_manual, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_channel_key, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_noswitch, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, buffer, POINTER, 0, NULL, \"buffer\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, buffer_as_string, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, channels, POINTER, 0, NULL, \"irc_channel\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_channel, POINTER, 0, NULL, \"irc_channel\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, prev_server, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_VAR(struct t_irc_server, next_server, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_LIST(irc_servers, WEECHAT_HDATA_LIST_CHECK_POINTERS);\n        WEECHAT_HDATA_LIST(last_irc_server, 0);\n    }\n    return hdata;\n}\n\n/*\n * Adds a server in an infolist.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_add_to_infolist (struct t_infolist *infolist,\n                            struct t_irc_server *server)\n{\n    struct t_infolist_item *ptr_item;\n\n    if (!infolist || !server)\n        return 0;\n\n    ptr_item = weechat_infolist_new_item (infolist);\n    if (!ptr_item)\n        return 0;\n\n    if (!weechat_infolist_new_var_string (ptr_item, \"name\", server->name))\n        return 0;\n    if (!weechat_infolist_new_var_pointer (ptr_item, \"buffer\", server->buffer))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"buffer_name\",\n                                          (server->buffer) ?\n                                          weechat_buffer_get_string (server->buffer, \"name\") : \"\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"buffer_short_name\",\n                                          (server->buffer) ?\n                                          weechat_buffer_get_string (server->buffer, \"short_name\") : \"\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"addresses\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_ADDRESSES)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"proxy\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ipv6\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_cert\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_CERT)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_priorities\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PRIORITIES)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_dhkey_size\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_fingerprint\",\n                                           IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_FINGERPRINT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_verify\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"capabilities\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_CAPABILITIES)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sasl_mechanism\",\n                                          IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SASL_MECHANISM)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_username\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_key\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sasl_fail\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SASL_FAIL)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoconnect\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTOCONNECT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoreconnect\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoreconnect_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nicks\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_NICKS)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"nicks_alternate\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_NICKS_ALTERNATE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"username\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"realname\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"local_hostname\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"usermode\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERMODE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"command\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_COMMAND)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"command_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_COMMAND_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"autojoin\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autorejoin\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTOREJOIN)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autorejoin_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTOREJOIN_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"connection_timeout\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"anti_flood_prio_high\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"anti_flood_prio_low\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away_check\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AWAY_CHECK)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away_check_max_nicks\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_kick\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_KICK)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_part\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_PART)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_quit\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_QUIT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"temp_server\", server->temp_server))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"index_current_address\", server->index_current_address))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"current_address\", server->current_address))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"current_ip\", server->current_ip))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"current_port\", server->current_port))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"current_retry\", server->current_retry))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sock\", server->sock))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"is_connected\", server->is_connected))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_connected\", server->ssl_connected))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"disconnected\", server->disconnected))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"unterminated_message\", server->unterminated_message))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nick\", server->nick))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nick_modes\", server->nick_modes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"host\", server->host))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"checking_cap_ls\", server->checking_cap_ls))\n        return 0;\n    if (!weechat_hashtable_add_to_infolist (server->cap_ls, ptr_item, \"cap_ls\"))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"checking_cap_list\", server->checking_cap_list))\n        return 0;\n    if (!weechat_hashtable_add_to_infolist (server->cap_list, ptr_item, \"cap_list\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"isupport\", server->isupport))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix_modes\", server->prefix_modes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix_chars\", server->prefix_chars))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"nick_max_length\", server->nick_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"user_max_length\", server->user_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"host_max_length\", server->host_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"casemapping\", server->casemapping))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"casemapping_string\", irc_server_casemapping_string[server->casemapping]))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"chantypes\", server->chantypes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"chanmodes\", server->chanmodes))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"monitor\", server->monitor))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"monitor_time\", server->monitor_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"reconnect_delay\", server->reconnect_delay))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"reconnect_start\", server->reconnect_start))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"command_time\", server->command_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"reconnect_join\", server->reconnect_join))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"disable_autojoin\", server->disable_autojoin))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"is_away\", server->is_away))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"away_message\", server->away_message))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"away_time\", server->away_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"lag\", server->lag))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"lag_displayed\", server->lag_displayed))\n        return 0;\n    if (!weechat_infolist_new_var_buffer (ptr_item, \"lag_check_time\", &(server->lag_check_time), sizeof (struct timeval)))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"lag_next_check\", server->lag_next_check))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"lag_last_refresh\", server->lag_last_refresh))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_user_message\", server->last_user_message))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_away_check\", server->last_away_check))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_data_purge\", server->last_data_purge))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Prints server infos in WeeChat log file (usually for crash dump).\n */\n\nvoid\nirc_server_print_log ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    int i;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        weechat_log_printf (\"\");\n        weechat_log_printf (\"[server %s (addr:0x%lx)]\", ptr_server->name, ptr_server);\n        /* addresses */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]))\n            weechat_log_printf (\"  addresses. . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_ADDRESSES));\n        else\n            weechat_log_printf (\"  addresses. . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]));\n        /* proxy */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PROXY]))\n            weechat_log_printf (\"  proxy. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_PROXY));\n        else\n            weechat_log_printf (\"  proxy. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_PROXY]));\n        /* ipv6 */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_IPV6]))\n            weechat_log_printf (\"  ipv6 . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_IPV6)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ipv6 . . . . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_IPV6])) ?\n                                \"on\" : \"off\");\n        /* ssl */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL]))\n            weechat_log_printf (\"  ssl. . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl. . . . . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL])) ?\n                                \"on\" : \"off\");\n        /* ssl_cert */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]))\n            weechat_log_printf (\"  ssl_cert . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_CERT));\n        else\n            weechat_log_printf (\"  ssl_cert . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]));\n        /* ssl_password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_PASSWORD]))\n            weechat_log_printf (\"  ssl_password . . . . : null\");\n        else\n            weechat_log_printf (\"  ssl_password . . . . : (hidden)\");\n        /* ssl_priorities */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_PRIORITIES]))\n            weechat_log_printf (\"  ssl_priorities . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_PRIORITIES));\n        else\n            weechat_log_printf (\"  ssl_priorities . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_PRIORITIES]));\n        /* ssl_dhkey_size */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]))\n            weechat_log_printf (\"  ssl_dhkey_size . . . : null ('%d')\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n        else\n            weechat_log_printf (\"  ssl_dhkey_size . . . : '%d'\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]));\n        /* ssl_fingerprint */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_FINGERPRINT]))\n            weechat_log_printf (\"  ssl_fingerprint. . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_FINGERPRINT));\n        else\n            weechat_log_printf (\"  ssl_fingerprint. . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_FINGERPRINT]));\n        /* ssl_verify */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY]))\n            weechat_log_printf (\"  ssl_verify . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL_VERIFY)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl_verify . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY])) ?\n                                \"on\" : \"off\");\n        /* password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PASSWORD]))\n            weechat_log_printf (\"  password . . . . . . : null\");\n        else\n            weechat_log_printf (\"  password . . . . . . : (hidden)\");\n        /* client capabilities */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_CAPABILITIES]))\n            weechat_log_printf (\"  capabilities . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_CAPABILITIES));\n        else\n            weechat_log_printf (\"  capabilities . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_CAPABILITIES]));\n        /* sasl_mechanism */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM]))\n            weechat_log_printf (\"  sasl_mechanism . . . : null ('%s')\",\n                                irc_sasl_mechanism_string[IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SASL_MECHANISM)]);\n        else\n            weechat_log_printf (\"  sasl_mechanism . . . : '%s'\",\n                                irc_sasl_mechanism_string[weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM])]);\n        /* sasl_username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_USERNAME]))\n            weechat_log_printf (\"  sasl_username. . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SASL_USERNAME));\n        else\n            weechat_log_printf (\"  sasl_username. . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SASL_USERNAME]));\n        /* sasl_password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_PASSWORD]))\n            weechat_log_printf (\"  sasl_password. . . . : null\");\n        else\n            weechat_log_printf (\"  sasl_password. . . . : (hidden)\");\n        /* sasl_key */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_KEY]))\n            weechat_log_printf (\"  sasl_key. .  . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SASL_KEY));\n        else\n            weechat_log_printf (\"  sasl_key. .  . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SASL_KEY]));\n        /* sasl_fail */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_FAIL]))\n            weechat_log_printf (\"  sasl_fail. . . . . . : null ('%s')\",\n                                irc_server_sasl_fail_string[IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SASL_FAIL)]);\n        else\n            weechat_log_printf (\"  sasl_fail. . . . . . : '%s'\",\n                                irc_server_sasl_fail_string[weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SASL_FAIL])]);\n        /* autoconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT]))\n            weechat_log_printf (\"  autoconnect. . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOCONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoconnect. . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT])) ?\n                                \"on\" : \"off\");\n        /* autoreconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT]))\n            weechat_log_printf (\"  autoreconnect. . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoreconnect. . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT])) ?\n                                \"on\" : \"off\");\n        /* autoreconnect_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]))\n            weechat_log_printf (\"  autoreconnect_delay. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY));\n        else\n            weechat_log_printf (\"  autoreconnect_delay. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]));\n        /* nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_NICKS]))\n            weechat_log_printf (\"  nicks. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_NICKS));\n        else\n            weechat_log_printf (\"  nicks. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_NICKS]));\n        /* nicks_alternate */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_NICKS_ALTERNATE]))\n            weechat_log_printf (\"  nicks_alternate. . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_NICKS_ALTERNATE)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  nicks_alternate. . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_NICKS_ALTERNATE])) ?\n                                \"on\" : \"off\");\n        /* username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_USERNAME]))\n            weechat_log_printf (\"  username . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_USERNAME));\n        else\n            weechat_log_printf (\"  username . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERNAME]));\n        /* realname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_REALNAME]))\n            weechat_log_printf (\"  realname . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_REALNAME));\n        else\n            weechat_log_printf (\"  realname . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_REALNAME]));\n        /* local_hostname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]))\n            weechat_log_printf (\"  local_hostname . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_LOCAL_HOSTNAME));\n        else\n            weechat_log_printf (\"  local_hostname . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]));\n        /* usermode */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_USERMODE]))\n            weechat_log_printf (\"  usermode . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_USERMODE));\n        else\n            weechat_log_printf (\"  usermode . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERMODE]));\n        /* command */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND]))\n            weechat_log_printf (\"  command. . . . . . . : null\");\n        else\n            weechat_log_printf (\"  command. . . . . . . : (hidden)\");\n        /* command_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]))\n            weechat_log_printf (\"  command_delay. . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_COMMAND_DELAY));\n        else\n            weechat_log_printf (\"  command_delay. . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]));\n        /* autojoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]))\n            weechat_log_printf (\"  autojoin . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_AUTOJOIN));\n        else\n            weechat_log_printf (\"  autojoin . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]));\n        /* autorejoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN]))\n            weechat_log_printf (\"  autorejoin . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autorejoin . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN])) ?\n                                \"on\" : \"off\");\n        /* autorejoin_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]))\n            weechat_log_printf (\"  autorejoin_delay . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN_DELAY));\n        else\n            weechat_log_printf (\"  autorejoin_delay . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]));\n        /* connection_timeout */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]))\n            weechat_log_printf (\"  connection_timeout . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT));\n        else\n            weechat_log_printf (\"  connection_timeout . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]));\n        /* anti_flood_prio_high */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]))\n            weechat_log_printf (\"  anti_flood_prio_high : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH));\n        else\n            weechat_log_printf (\"  anti_flood_prio_high : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]));\n        /* anti_flood_prio_low */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]))\n            weechat_log_printf (\"  anti_flood_prio_low. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW));\n        else\n            weechat_log_printf (\"  anti_flood_prio_low. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]));\n        /* away_check */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]))\n            weechat_log_printf (\"  away_check . . . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK));\n        else\n            weechat_log_printf (\"  away_check . . . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]));\n        /* away_check_max_nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]))\n            weechat_log_printf (\"  away_check_max_nicks : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS));\n        else\n            weechat_log_printf (\"  away_check_max_nicks : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]));\n        /* msg_kick */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_KICK]))\n            weechat_log_printf (\"  msg_kick . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_KICK));\n        else\n            weechat_log_printf (\"  msg_kick . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_KICK]));\n        /* msg_part */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_PART]))\n            weechat_log_printf (\"  msg_part . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_PART));\n        else\n            weechat_log_printf (\"  msg_part . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_PART]));\n        /* msg_quit */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_QUIT]))\n            weechat_log_printf (\"  msg_quit . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_QUIT));\n        else\n            weechat_log_printf (\"  msg_quit . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_QUIT]));\n        /* other server variables */\n        weechat_log_printf (\"  temp_server. . . . . : %d\",    ptr_server->temp_server);\n        weechat_log_printf (\"  reloading_from_config: %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  reloaded_from_config : %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  addresses_eval . . . : '%s'\",  ptr_server->addresses_eval);\n        weechat_log_printf (\"  addresses_count. . . : %d\",    ptr_server->addresses_count);\n        weechat_log_printf (\"  addresses_array. . . : 0x%lx\", ptr_server->addresses_array);\n        weechat_log_printf (\"  ports_array. . . . . : 0x%lx\", ptr_server->ports_array);\n        weechat_log_printf (\"  retry_array. . . . . : 0x%lx\", ptr_server->retry_array);\n        weechat_log_printf (\"  index_current_address: %d\",    ptr_server->index_current_address);\n        weechat_log_printf (\"  current_address. . . : '%s'\",  ptr_server->current_address);\n        weechat_log_printf (\"  current_ip . . . . . : '%s'\",  ptr_server->current_ip);\n        weechat_log_printf (\"  current_port . . . . : %d\",    ptr_server->current_port);\n        weechat_log_printf (\"  current_retry. . . . : %d\",    ptr_server->current_retry);\n        weechat_log_printf (\"  sock . . . . . . . . : %d\",    ptr_server->sock);\n        weechat_log_printf (\"  hook_connect . . . . : 0x%lx\", ptr_server->hook_connect);\n        weechat_log_printf (\"  hook_fd. . . . . . . : 0x%lx\", ptr_server->hook_fd);\n        weechat_log_printf (\"  hook_timer_connection: 0x%lx\", ptr_server->hook_timer_connection);\n        weechat_log_printf (\"  hook_timer_sasl. . . : 0x%lx\", ptr_server->hook_timer_sasl);\n        weechat_log_printf (\"  is_connected . . . . : %d\",    ptr_server->is_connected);\n        weechat_log_printf (\"  ssl_connected. . . . : %d\",    ptr_server->ssl_connected);\n        weechat_log_printf (\"  disconnected . . . . : %d\",    ptr_server->disconnected);\n#ifdef HAVE_GNUTLS\n        weechat_log_printf (\"  gnutls_sess. . . . . : 0x%lx\", ptr_server->gnutls_sess);\n#endif /* HAVE_GNUTLS */\n        weechat_log_printf (\"  unterminated_message : '%s'\",  ptr_server->unterminated_message);\n        weechat_log_printf (\"  nicks_count. . . . . : %d\",    ptr_server->nicks_count);\n        weechat_log_printf (\"  nicks_array. . . . . : 0x%lx\", ptr_server->nicks_array);\n        weechat_log_printf (\"  nick_first_tried . . : %d\",    ptr_server->nick_first_tried);\n        weechat_log_printf (\"  nick_alternate_number: %d\",    ptr_server->nick_alternate_number);\n        weechat_log_printf (\"  nick . . . . . . . . : '%s'\",  ptr_server->nick);\n        weechat_log_printf (\"  nick_modes . . . . . : '%s'\",  ptr_server->nick_modes);\n        weechat_log_printf (\"  host . . . . . . . . : '%s'\",  ptr_server->host);\n        weechat_log_printf (\"  checking_cap_ls. . . : %d\",    ptr_server->checking_cap_ls);\n        weechat_log_printf (\"  cap_ls . . . . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->cap_ls,\n                            weechat_hashtable_get_string (ptr_server->cap_ls, \"keys_values\"));\n        weechat_log_printf (\"  checking_cap_list. . : %d\",    ptr_server->checking_cap_list);\n        weechat_log_printf (\"  cap_list . . . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->cap_list,\n                            weechat_hashtable_get_string (ptr_server->cap_list, \"keys_values\"));\n        weechat_log_printf (\"  isupport . . . . . . : '%s'\",  ptr_server->isupport);\n        weechat_log_printf (\"  prefix_modes . . . . : '%s'\",  ptr_server->prefix_modes);\n        weechat_log_printf (\"  prefix_chars . . . . : '%s'\",  ptr_server->prefix_chars);\n        weechat_log_printf (\"  nick_max_length. . . : %d\",    ptr_server->nick_max_length);\n        weechat_log_printf (\"  user_max_length. . . : %d\",    ptr_server->user_max_length);\n        weechat_log_printf (\"  host_max_length. . . : %d\",    ptr_server->host_max_length);\n        weechat_log_printf (\"  casemapping. . . . . : %d (%s)\",\n                            ptr_server->casemapping,\n                            irc_server_casemapping_string[ptr_server->casemapping]);\n        weechat_log_printf (\"  chantypes. . . . . . : '%s'\",  ptr_server->chantypes);\n        weechat_log_printf (\"  chanmodes. . . . . . : '%s'\",  ptr_server->chanmodes);\n        weechat_log_printf (\"  monitor. . . . . . . : %d\",    ptr_server->monitor);\n        weechat_log_printf (\"  monitor_time . . . . : %lld\",  (long long)ptr_server->monitor_time);\n        weechat_log_printf (\"  reconnect_delay. . . : %d\",    ptr_server->reconnect_delay);\n        weechat_log_printf (\"  reconnect_start. . . : %lld\",  (long long)ptr_server->reconnect_start);\n        weechat_log_printf (\"  command_time . . . . : %lld\",  (long long)ptr_server->command_time);\n        weechat_log_printf (\"  reconnect_join . . . : %d\",    ptr_server->reconnect_join);\n        weechat_log_printf (\"  disable_autojoin . . : %d\",    ptr_server->disable_autojoin);\n        weechat_log_printf (\"  is_away. . . . . . . : %d\",    ptr_server->is_away);\n        weechat_log_printf (\"  away_message . . . . : '%s'\",  ptr_server->away_message);\n        weechat_log_printf (\"  away_time. . . . . . : %lld\",  (long long)ptr_server->away_time);\n        weechat_log_printf (\"  lag. . . . . . . . . : %d\",    ptr_server->lag);\n        weechat_log_printf (\"  lag_displayed. . . . : %d\",    ptr_server->lag_displayed);\n        weechat_log_printf (\"  lag_check_time . . . : tv_sec:%d, tv_usec:%d\",\n                            ptr_server->lag_check_time.tv_sec,\n                            ptr_server->lag_check_time.tv_usec);\n        weechat_log_printf (\"  lag_next_check . . . : %lld\",  (long long)ptr_server->lag_next_check);\n        weechat_log_printf (\"  lag_last_refresh . . : %lld\",  (long long)ptr_server->lag_last_refresh);\n        weechat_log_printf (\"  cmd_list_regexp. . . : 0x%lx\", ptr_server->cmd_list_regexp);\n        weechat_log_printf (\"  last_user_message. . : %lld\",  (long long)ptr_server->last_user_message);\n        weechat_log_printf (\"  last_away_check. . . : %lld\",  (long long)ptr_server->last_away_check);\n        weechat_log_printf (\"  last_data_purge. . . : %lld\",  (long long)ptr_server->last_data_purge);\n        for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n        {\n            weechat_log_printf (\"  outqueue[%02d] . . . . : 0x%lx\", i, ptr_server->outqueue[i]);\n            weechat_log_printf (\"  last_outqueue[%02d]. . : 0x%lx\", i, ptr_server->last_outqueue[i]);\n        }\n        weechat_log_printf (\"  redirects. . . . . . : 0x%lx\", ptr_server->redirects);\n        weechat_log_printf (\"  last_redirect. . . . : 0x%lx\", ptr_server->last_redirect);\n        weechat_log_printf (\"  notify_list. . . . . : 0x%lx\", ptr_server->notify_list);\n        weechat_log_printf (\"  last_notify. . . . . : 0x%lx\", ptr_server->last_notify);\n        weechat_log_printf (\"  notify_count . . . . : %d\",    ptr_server->notify_count);\n        weechat_log_printf (\"  join_manual. . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_manual,\n                            weechat_hashtable_get_string (ptr_server->join_manual, \"keys_values\"));\n        weechat_log_printf (\"  join_channel_key . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_channel_key,\n                            weechat_hashtable_get_string (ptr_server->join_channel_key, \"keys_values\"));\n        weechat_log_printf (\"  join_noswitch. . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_noswitch,\n                            weechat_hashtable_get_string (ptr_server->join_noswitch, \"keys_values\"));\n        weechat_log_printf (\"  buffer . . . . . . . : 0x%lx\", ptr_server->buffer);\n        weechat_log_printf (\"  buffer_as_string . . : 0x%lx\", ptr_server->buffer_as_string);\n        weechat_log_printf (\"  channels . . . . . . : 0x%lx\", ptr_server->channels);\n        weechat_log_printf (\"  last_channel . . . . : 0x%lx\", ptr_server->last_channel);\n        weechat_log_printf (\"  prev_server. . . . . : 0x%lx\", ptr_server->prev_server);\n        weechat_log_printf (\"  next_server. . . . . : 0x%lx\", ptr_server->next_server);\n\n        irc_redirect_print_log (ptr_server);\n\n        irc_notify_print_log (ptr_server);\n\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            irc_channel_print_log (ptr_channel);\n        }\n    }\n}\n"], "fixing_code": ["= WeeChat ChangeLog\n:author: S\u00e9bastien Helleu\n:email: flashcode@flashtux.org\n:lang: en\n:toc: left\n:docinfo1:\n\n\nThis document lists all changes for each version\n(the latest formatted version of this document can be found\nhttps://weechat.org/files/changelog/ChangeLog-devel.html[here]).\n\nFor a list of important changes that require manual action, please look at\nhttps://weechat.org/files/releasenotes/ReleaseNotes-devel.html[release notes]\n(file _ReleaseNotes.adoc_ in sources).\n\n\n[[v2.8]]\n== Version 2.8 (under dev)\n\nNew features::\n\n  * core: add variable \"old_full_name\" in buffer, set during buffer renaming (issue #1428)\n  * core: add debug option \"-d\" in command /eval (issue #1434)\n  * api: add info \"weechat_headless\" (issue #1433)\n  * buflist: add pointer \"window\" in bar item evaluation\n  * relay: reject client with weechat protocol if password or totp is received in init command but not set in WeeChat (issue #1435)\n\nBug fixes::\n\n  * core: fix memory leak in completion\n  * core: flush stdout/stderr before forking in hook_process function (issue #1441)\n  * core: fix evaluation of condition with nested \"if\" (issue #1434)\n  * irc: fix crash when a new message 005 is received with longer nick prefixes\n  * irc: fix crash when receiving a malformed message 324 (channel mode)\n  * irc: add nick changes in the hotlist (except self nick change)\n  * irc: case-insensitive comparison on incoming CTCP command, force upper case on CTCP replies (issue #1439)\n  * irc: fix memory leak when the channel topic is changed\n  * logger: fix crash when logging is disabled on a buffer and the log file was deleted in the meanwhile, when option logger.file.info_lines is on (issue #1444)\n  * relay: update buffers synchronization when buffers are renamed (issue #1428)\n  * xfer: send signal \"xfer_ended\" after the received file has been renamed (issue #1438)\n\nTests::\n\n  * unit: add tests on functions util_get_time_diff and util_file_get_content\n\nBuild::\n\n  * guile: add detection of Guile 3.0.0 (issue #1442)\n  * irc: fix build with GnuTLS < 3.1.0 (issue #1431)\n  * php: add detection of PHP 7.4\n\n[[v2.7]]\n== Version 2.7 (2019-12-08)\n\nNew features::\n\n  * core: add option weechat.look.nick_color_hash_salt to shuffle nick colors (issue #635)\n  * core: add different icons sizes (16x16 to 512x512) (issue #1347)\n  * core: add file weechat.desktop\n  * core: add reverse of string for screen in evaluation of expressions with \"revscr:\"\n  * core: add length of string (number of chars and on screen) in evaluation of expressions with \"length:xxx\" and \"lengthscr:xxx\"\n  * core: add calculation of expression in evaluation of expressions with \"calc:xxx\" (issue #997)\n  * core: add optional default path (evaluated) in completion \"filename\"\n  * core: add support of modifiers in evaluation of expressions with \"modifier:name,data,string\"\n  * api: add modifier \"color_encode_ansi\" (issue #528)\n  * api: add modifier \"eval_path_home\"\n  * irc: add filters on raw buffer (issue #1000)\n  * irc: add option irc.look.display_pv_warning_address to display a warning in private buffer if the remote nick address has changed (issue #892)\n  * irc: add server option \"ssl_password\" (issue #115, issue #1416)\n  * irc: add \"user\" in output of irc_message_parse (issue #136)\n  * irc: add options irc.color.message_kick and irc.color.reason_kick (issue #683, issue #684)\n  * logger: add option logger.file.color_lines (issue #528, issue #621)\n  * script: add options \"-ol\" and \"-il\" in command \"/script list\" to send translated string with list of scripts loaded, display \"No scripts loaded\" if no scripts are loaded\n  * xfer: add option xfer.file.download_temporary_suffix with default value \".part\" (issue #1237)\n\nBug fixes::\n\n  * core: set buffer name, short name and title only if the value has changed\n  * core: fix scrolling up in bare mode when switched to bare mode at the top of the buffer (issue #899, issue #978)\n  * core: optimize load of configuration files\n  * core: fix window separators not respecting window splits (issue #630)\n  * core: fix cursor mode info when prefix_align is none and with words split across lines (issue #610, issue #617, issue #619)\n  * core: add support of reverse video in ANSI color codes\n  * core: fixed segfault during excessive evaluation in function string_repeat (issue #1400)\n  * buflist: fix extra spaces between buffers when conditions are used to hide buffers (regression introduced in version 2.6) (issue #1403)\n  * irc: do not automatically open a channel with name \"0\" (issue #1429)\n  * irc: remove option irc.network.channel_encode, add server option \"charset_message\" to control which part of the IRC message is decoded/encoded to the target charset (issue #832)\n  * irc: use path from option xfer.file.upload_path to complete filename in command \"/dcc send\" (issue #60)\n  * logger: fix write in log file if it has been deleted or renamed (issue #123)\n  * python: send \"bytes\" instead of \"str\" to callbacks in Python 3 when the string is not UTF-8 valid (issue #1389)\n  * relay: send message \"_buffer_title_changed\" to clients only when the title is changed\n  * xfer: fix memory leak when a xfer is freed and when the plugin is unloaded\n\nTests::\n\n  * unit: add tests on GUI color functions\n\nBuild::\n\n  * core: fix build on Haiku (issue #1420)\n  * core: fix build on Alpine\n  * core: remove file FindTCL.cmake\n  * core: display an error on missing dependency in CMake (issue #916, issue #956)\n  * debian: disable Javascript plugin on Debian Sid and Ubuntu Eoan\n  * debian: build with Guile 2.2\n  * guile: add support of Guile 2.2, disable /guile eval (issue #1098)\n  * python: add detection of Python 3.8\n\n[[v2.6]]\n== Version 2.6 (2019-09-08)\n\nNew features::\n\n  * core: add support of 32767 color pairs (issue #1343, issue #1345)\n  * core: add option \"close\" in command /window (issue #853)\n  * api: add infos \"term_colors\" and \"term_color_pairs\"\n  * api: add function list_user_data (issue #666)\n  * api: add argument \"strip_items\" in function string_split\n  * buflist: add infolist \"buflist\" with list of buffer pointers (issue #1375)\n  * exec: evaluate option exec.command.shell, change default value to \"${env:SHELL}\" (issue #1356)\n  * fset: add filters \"h=xxx\" and \"he=xxx\" to filter options by description (translated or in English)\n  * irc: make command char optional in server option \"command\" (issue #615)\n  * irc: add variables \"user_max_length\" and \"host_max_length\" in server structure (issue #1387)\n\nBug fixes::\n\n  * core: use fixed-width integer for computing nick and hashtable DJB2 key hashes, add values \"djb2_32\" and \"sum_32\" for option weechat.look.nick_color_hash (issue #1394)\n  * core: create or update option weechat.notify.xxx when function buffer_set is called with \"notify\" property (issue #1390)\n  * core: fix memory leak in case of error when building content of bar item for display (issue #1384)\n  * core: send command line parameter to plugins only if the name starts with the plugin name followed by a colon\n  * core: auto disable upgrade process (command line option \"--upgrade\") if the file weechat.upgrade is not found\n  * core: replace newlines by spaces in argument \"completion\" of function hook_command (issue #538)\n  * core: replace char \",\" by \"~\" in color codes to separate foreground from background (issue #1264)\n  * alias: remove default aliases /AME and /AMSG (issue #1355)\n  * buflist: use extra variables in option buflist.look.display_conditions (issue #1393)\n  * irc: fix parsing of messages 346 (invite list), 348 (exception list), 367 (ban list) and 728 (quiet list) when there is a colon before the timestamp (issue #1396)\n  * irc: fix memory leak when removing a server\n  * irc: fix length of user/nick/host in split of messages (issue #1387)\n  * irc: quote NICK command argument sent to the server only if there's a \":\" in the nick (issue #1376, issue #1319)\n  * irc: return all arguments in the PONG response to a PING (issue #1369)\n  * irc: disable server reconnection when the server buffer is closed (issue #236)\n  * irc: strip spaces at beginning/end of addresses in server option \"addresses\" (issue #195)\n  * irc: fix display of enabled/disabled client capabilities received in command CAP ACK (issue #151)\n  * ruby: fix conversion of big integers on 32bit architecture (issue #1395)\n\nTests::\n\n  * unit: add tests on IRC ignore, message and nick functions\n\nBuild::\n\n  * core: fix compilation with autotools on FreeBSD 12.0\n  * debian: disable Javascript plugin on Debian Buster/Bullseye (issue #1374)\n  * python: compile with Python 3 by default\n  * python: use pkg-config to detect Python (issue #1382)\n\n[[v2.5]]\n== Version 2.5 (2019-06-06)\n\nNew features::\n\n  * core: use getopt to parse command line arguments\n  * core: add option weechat.look.prefix_same_nick_middle (issue #930, issue #931)\n  * core: add option weechat.look.buffer_time_same (issue #1127)\n  * core: use seconds by default in /repeat interval, allow unit for the interval\n  * core: allow text in addition to a command in command /repeat\n  * core: add option \"addreplace\" in command /filter (issue #1055, issue #1312)\n  * api: return allocated string in hook_info callback and function info_get\n  * api: replace argument \"keep_eol\" by \"flags\" in function string_split (issue #1322)\n  * api: add function command_options (issue #928)\n  * api: add function string_match_list\n  * irc: add bar items \"irc_nick\", \"irc_host\" and \"irc_nick_host\"\n  * irc: add variable \"host\" in server structure\n  * relay: add support of UNIX socket (issue #733, issue #1333)\n  * relay: add option relay.weechat.commands (issue #928)\n  * script: use SHA-512 instead of MD5 for script checksum\n  * spell: rename aspell plugin to spell (issue #1299)\n  * trigger: add hooks \"info\" and \"info_hashtable\"\n  * xfer: rename option xfer.network.speed_limit to xfer.network.speed_limit_send, add option xfer.network.speed_limit_recv (issue #269)\n\nBug fixes::\n\n  * core: don't execute command scheduled by /repeat and /wait if the buffer does not exist any more\n  * core: set max length to 4096 for /secure passphrase (issue #1323)\n  * core: refilter only affected buffers on filter change (issue #1309, issue #1311)\n  * fset: fix slow refresh of fset buffer during /reload (issue #1313)\n  * irc: fix parsing of MODE command when there are colons after the first mode argument (issue #1296)\n  * irc: fix memory leak in infos \"irc_server_isupport\" and \"irc_server_isupport_value\"\n  * irc: fix length of string for SHA-512, SHA-256 and SHA-1 in help on ssl_fingerprint option\n  * irc: display an error with /allchan -current or /allpv -current if the current buffer is not an irc buffer (issue #1325)\n  * irc: fix update of channels modes with arguments when joining a channel (issue #1324)\n  * irc: quote NICK command argument sent to the server (issue #1319)\n  * php: fix memory leak in functions string_eval_expression, string_eval_path_home, key_bind, hook_process_hashtable, hook_hsignal_send, info_get_hashtable, hdata_update\n  * relay: fix crash when a weechat relay client reloads the relay plugin with /plugin reload relay (issue #1327)\n  * spell: fix detection of nick followed by the nick completer (issue #1306, issue #1307)\n  * trigger: fix split of hook arguments (issue #1322)\n\nTests::\n\n  * unit: add tests on function util_signal_search\n\nBuild::\n\n  * core: fix value of libdir in file weechat.pc (issue #1341, issue #1342)\n  * core: fix generation of man page weechat-headless with autotools\n  * core: add CMake option \"ENABLE_CODE_COVERAGE\" to compile with code coverage options (CMake \u2265 3.0 is now required)\n  * core: fix compilation on Mac OS (issue #1308)\n  * lua: add detection of Lua 5.3 with autotools\n  * ruby: add detection of Ruby 2.6 (issue #1346)\n  * tests: fix compilation of tests on FreeBSD\n\n[[v2.4]]\n== Version 2.4 (2019-02-17)\n\nNew features::\n\n  * core: do not automatically add a space when completing \"nick:\" at the beginning of command line (the space can be added in option weechat.completion.nick_completer)\n  * core: add default keys kbd:[Ctrl+F11]/kbd:[Ctrl+F12] to scroll up/down one page in nicklist (same action as kbd:[F11]/kbd:[F12])\n  * core: add command line option \"-t\" (or \"--temp-dir\") to create a temporary WeeChat home (deleted on exit)\n  * api: add functions string_base_encode and string_base_decode, remove functions string_encode_base64 and string_decode_base64\n  * api: add support of Time-based One-Time Password (TOTP), add infos \"totp_generate\" and \"totp_validate\"\n  * buflist: add default keys kbd:[Ctrl+F1]/kbd:[Ctrl+F2] to scroll up/down one page in buflist (same action as kbd:[F1]/kbd:[F2])\n  * buflist: add variable ${number2}, always set with the indented buffer number\n  * exec: add option exec.command.shell to customize the shell used with /exec -sh\n  * relay: add support of close frame in websocket connection (issue #1281)\n  * relay: add support of Time-based One-Time Password (TOTP) as second authentication factor in weechat protocol\n\nBug fixes::\n\n  * core: fix compilation of empty regular expression (not allowed on FreeBSD)\n  * core: fix forced highlight on messages sent to other buffers (issue #1277)\n  * aspell: look for suggestions only if the misspelled word has changed (issue #1175)\n  * buflist: add alternate key codes for kbd:[F1]/kbd:[F2] and kbd:[Alt+F1]/kbd:[Alt+F2] (compatibility with terminals)\n  * buflist: fix warning displayed when script buffers.pl is loaded (issue #1274)\n  * irc: fix parsing of whois messages in notify\n  * irc: fix parsing of MODE, 341 (invite) and CHGHOST commands when there are colons (issue #1296)\n  * irc: return IRC color code instead of WeeChat color code when decoding a too short ANSI color sequence\n  * irc: fix encoding of italic attribute when colors are removed\n  * irc: fix parsing of \"time\" message tag on FreeBSD (issue #1289)\n  * relay: fix crash on /upgrade when the real IP is not set (issue #1294)\n  * relay: fix memory leak in connection of client\n\nTests::\n\n  * unit: fix UTF-8 and evaluation tests on FreeBSD\n  * unit: add tests on IRC configuration and protocol functions\n\nBuild::\n\n  * core: add C compiler flag \"-fsigned--char\" to force \"char\" data type to be always signed (issue #1277)\n\n[[v2.3]]\n== Version 2.3 (2018-10-21)\n\nNew features::\n\n  * core: add repeat of string in evaluation of expressions with \"repeat:count,string\" (issue #958)\n  * core: allow specifying buffer number/name for /buffer localvar (issue #1259)\n  * core: allow multiple arguments in command \"/buffer close\"\n  * core: allow multiple options \"-r\" (or \"--run-command\") in command line arguments (issue #1248)\n  * core: add command line option \"-P\" (or \"--plugins\") to customize the plugins to load at startup\n  * core: allow partial buffer name in command \"/buffer close\" (issue #1226)\n  * api: add function hook_line (issue #66)\n  * irc: display a warning when the value of option irc.server.xxx.autojoin is set to an invalid value\n  * relay: add real IP in client description (issue #1256)\n  * trigger: allow creation of temporary variables with the regex\n  * trigger: add hook \"line\"\n\nBug fixes::\n\n  * core: fix evaluation of nested ternary operators (issue #1263)\n  * core: fix evaluation of condition when the left operand is an empty string\n  * core: fix string evaluation with regex replacement when the string is empty\n  * core: fix check of tags in lines (command /filter and hook_print)\n  * core: fix clear of completion item in case of partial completion (issue #1162)\n  * core: send signal \"key_pressed\" for mouse code only if the string is UTF-8 valid (issue #1220)\n  * api: fix memory leak in function string_split\n  * lua: fix return code of mkdir functions in case of error (issue #1267)\n  * scripts: fix duplicated lines in output of script eval (python, perl, ruby, lua and guile)\n\nTests::\n\n  * unit: add tests on line and hook functions\n\nBuild::\n\n  * php: add detection of PHP 7.3\n\n[[v2.2]]\n== Version 2.2 (2018-07-14)\n\nNew features::\n\n  * core: change default value of option weechat.look.hotlist_add_conditions to check connected relay clients via weechat protocol (issue #1206)\n  * core: add reverse of string in evaluation of expressions with \"rev:\" (issue #1200)\n  * core: send buffer pointer (when possible) in signal \"hotlist_changed\" (issue #1133)\n  * core: add support of list options in curl (issue #826, issue #219)\n  * core: allow merge of buffers by name in command /buffer (issue #1108, issue #1159)\n  * api: add function hashtable_add_from_infolist\n  * api: add function string_format_size in scripting API\n  * irc: add nick, host and log tags in message displayed in private buffer when the nick comes back on the server (issue #1221)\n  * irc: add support for IRCv3.2 chghost, add options irc.look.smart_filter_chghost and irc.color.message_chghost (issue #640)\n  * irc: add support for IRCv3.2 invite-notify (issue #639)\n  * irc: add support for IRCv3.2 Client Capability Negotiation (issue #586, issue #623)\n  * irc: display current nick on connected servers in output of /server list|listfull (issue #1193)\n  * irc: add option \"-server\" in command /list (issue #1165)\n  * irc: add indexed ban list, add completion for /unban and /unquiet (issue #597, task #11374, task #10876)\n  * relay: add filtering on protocol in info \"relay_client_count\"\n  * trigger: hide password in command \"/msg nickserv set password\"\n  * xfer: add option xfer.network.send_ack (issue #1171)\n\nBug fixes::\n\n  * core: fix TLS handshake failure on server connection when there are multiple addresses in the server (issue #1196)\n  * core: count number of chars instead of bytes for suffix in function string_cut\n  * core: fix delete of previous/next word (keys kbd:[Ctrl+w] and kbd:[Alt+d]) (issue #1195)\n  * core: fix infinite loop in evaluation of strings (issue #1183)\n  * core: change default value of option weechat.look.window_title from \"WeeChat ${info:version}\" to empty string (issue #1182)\n  * buflist: fix crash when setting the option buflist.look.signals_refresh with a list of signals\n  * fset: fix memory leak when switching the format with kbd:[Ctrl+x]\n  * fset: fix truncation of option values when the length is greater than 4096 (issue #1218)\n  * fset: fix crash when applying filters after closing the fset buffer (issue #1204)\n  * irc: display message 354 (WHOX) received with missing parameters (issue #1212)\n  * irc: always set nick away status on WHO response (sent manually or automatically with server option \"away_check\")\n  * irc: fix a crash when calling the function hdata_string on the \"prefix\" variable in the nick\n  * irc: fix split of messages when server option \"split_msg_max_length\" is set to 0 (no split) (issue #1173)\n  * irc: send whole IRC message including IRCv3 tags in the signals irc_in, irc_in2, irc_raw_in and irc_raw_in2 (issue #787)\n  * irc: fix memory leak when receiving a message with IRCv3 tags\n  * guile: fix memory leak in 7 functions returning allocated strings\n  * lua: fix macros used to return values\n  * php: fix return code of functions config_write_option and config_write_line\n  * php: fix memory leak in 72 functions returning allocated strings\n  * python: fix crash when loading a script with Python >= 3.7 (issue #1219)\n  * relay: fix socket creation for relay server on OpenBSD (issue #1213)\n  * ruby: fix memory leak in 7 functions returning allocated strings\n  * script: fix memory leak in case of invalid XML content in list of scripts\n  * scripts: fix memory leak in hook_info callback\n  * scripts: fix return value of hook_infolist callback (pointer instead of string)\n  * scripts: return long integer instead of string in function infolist_time\n  * xfer: set option TCP_NODELAY on socket when receiving a file via DCC (issue #1171)\n\nDocumentation::\n\n  * core: split man pages weechat and weechat-headless\n\nTests::\n\n  * unit, scripts: add tests on infolists\n\nBuild::\n\n  * core: fix build with CMake and Ninja\n  * debian: add package weechat-headless with the headless binary and its man page\n  * javascript: fix compilation of javascript plugin with autotools on some Linux distributions (issue #1208)\n  * python: add detection of Python 3.7\n\n[[v2.1]]\n== Version 2.1 (2018-03-18)\n\nNew features::\n\n  * core: add binary weechat-headless to run WeeChat without interface, with optional daemon mode (command line option \"--daemon\") (issue #1120)\n  * core: add options \"-newbuffer\", \"-free\" and \"-switch\" in command /print (issue #1113)\n  * core: add option \"-y\" in command /print, add support of buffers with free content\n  * core: add option \"add\" in command /buffer (issue #1113)\n  * core: add option weechat.completion.partial_completion_templates to force partial completion on specific templates\n  * api: add hashtable with variables in plugin structure\n  * api: add time in info \"date\" (WeeChat compilation date/time) (issue #1138)\n  * irc: add server option \"split_msg_max_length\"\n  * irc: allow ${irc_server.xxx} and ${server} in server evaluated options (issue #1144)\n  * logger: add option logger.file.fsync (issue #1145)\n  * logger: add option logger.look.backlog_conditions (issue #1132)\n  * script: change default value of option script.look.sort from \"p,n\" to \"i,p,n\"\n  * scripts: add configuration file for each script plugin (_python.conf_, _perl.conf_, ...)\n  * scripts: add \"eval\" option in script commands and info \"xxx_eval\" (python, perl, ruby, lua and guile) (issue #128)\n  * scripts: add infos \"xxx_interpreter\" and \"xxx_version\" in script plugins (issue #1075)\n  * scripts: add option \"version\" in script commands (issue #1075)\n  * scripts: display the script name in stdout/stderr output from scripts\n\nBug fixes::\n\n  * core: fix regression on execution of hook_print callbacks (introduced in version 2.0)\n\nBuild::\n\n  * ruby: add detection of Ruby 2.5 (issue #1122)\n\n[[v2.0.1]]\n== Version 2.0.1 (2017-12-20)\n\nBug fixes::\n\n  * python: fix arguments status/gnutls_rc/sock in hook_connect callback\n  * python: fix argument fd in hook_fd callback\n\n[[v2.0]]\n== Version 2.0 (2017-12-03)\n\nNew features::\n\n  * core: add flag \"input_get_empty\" in buffer\n  * core: add signals \"buffer_filters_enabled\" and \"buffer_filters_disabled\"\n  * core: support loading of plugins from path in environment variable \"WEECHAT_EXTRA_LIBDIR\" (issue #971, issue #979)\n  * core: make value optional in command \"/buffer set\" (issue #746, issue #1088)\n  * core: allow floating point and hexadecimal numbers in comparison of evaluated values\n  * core: add option weechat.look.save_config_with_fsync (issue #1083)\n  * api: add support of prefix \"quiet:\" in function key_unbind to quietly remove keys\n  * api: add argument \"recurse_subdirs\" in function exec_on_files\n  * alias: add infolist \"alias_default\" (list of default aliases)\n  * buflist: add two new bar items (\"buflist2\" and \"buflist3\") using the same format configuration options (issue #990)\n  * buflist: add option buflist.look.add_newline (issue #1027)\n  * fset: new plugin \"fset\" (fast set of WeeChat and plugins options) (issue #584)\n  * php: new plugin \"php\" (issue #909)\n  * script: add local variable \"filter\" in the script buffer (issue #1037)\n\nBug fixes::\n\n  * core: do not change the chat prefix size when a filtered line is added (issue #1092)\n  * core: fix display of nicks in nicklist when they are in a group with sub-groups (issue #1079)\n  * core, plugins: check return code of strftime function\n  * core: fix cast of time_t (to \"long long\" instead of \"long\") (issue #1051)\n  * core: call the config hook when options are renamed or removed\n  * api: change type of arguments status/gnutls_rc/sock in hook_connect callback from string to integer (in scripts)\n  * api: change type of argument fd in hook_fd callback from string to integer (in scripts)\n  * buflist: remove recursive evaluation of extra variables (issue #1060)\n  * guile: return integer (0/1) instead of boolean in API functions\n  * guile: fix return value of static strings in API functions\n  * irc: do not clear nicklist when joining an already joined channel if the option irc.look.buffer_open_before_join is on (issue #1081)\n  * irc: fix CTCP PING reply when the option irc.ctcp.ping is set to non-empty value\n  * lua: fix boolean return value (as integer) in API functions\n  * relay: fix parsing of CAP command without arguments in irc protocol, send ACK only if all capabilities received are OK and NAK otherwise (issue #1040)\n\nTests::\n\n  * scripts: add scripting API tests (issue #104)\n  * unit: display an error if the required locale en_US.UTF-8 is not installed\n\nBuild::\n\n  * core: fix build with ncurses and separate tinfo (bug #41245, issue #1090)\n  * javascript: fix detection of libv8 with autotools on Ubuntu Trusty\n\n[[v1.9.1]]\n== Version 1.9.1 (2017-09-23)\n\nBug fixes::\n\n  * buflist: fix crash in auto-scroll of bar when the buflist item is not the first item in the bar\n  * logger: call strftime before replacing buffer local variables (CVE-2017-14727)\n  * relay: fix send of \"PART\" command in backlog (irc protocol)\n\n[[v1.9]]\n== Version 1.9 (2017-06-25)\n\nNew features::\n\n  * core: improve speed of nicklist bar item callback\n  * core: allow index for hdata arrays in evaluation of expressions\n  * api: allow update of variables \"scroll_x\" and \"scroll_y\" in bar_window with function hdata_update\n  * api: add functions config_option_get_string and hdata_compare\n  * buflist: add option buflist.look.auto_scroll (issue #332)\n  * buflist: add keys kbd:[F1]/kbd:[F2], kbd:[Alt+F1]/kbd:[Alt+F2] to scroll the buflist bar\n  * buflist: display a warning when the script \"buffers.pl\" is loaded\n  * buflist: add support of char \"~\" in option buflist.look.sort for case insensitive comparison\n  * buflist: add variable `${format_name}` in bar item evaluation and option buflist.format.name (issue #1020)\n  * buflist: add variables `${current_buffer}` and `${merged}` (booleans \"0\" / \"1\") in bar item evaluation\n  * relay: add option \"start\" in command /relay\n  * trigger: add \"irc_server\" and \"irc_channel\" pointers in data for IRC signal/modifier hooks\n\nBug fixes::\n\n  * core: fix bind of keys with space key, like kbd:[Alt+Space] (bug #32133)\n  * core: fix infinite loop when the terminal is closed on the secure password prompt (issue #1010)\n  * buflist: fix long mouse gestures\n  * buflist: fix slow switch of buffer when there are a lot of buffers opened (issue #998)\n  * buflist: add option \"bar\" in command /buflist, do not automatically add the \"buflist\" bar when the option buflist.look.enabled is off (issue #994)\n  * buflist: fix crash on drag & drop of buffers\n  * irc: don't reset nick properties (prefixes/away/account/realname) on /names when the nick already exists (issue #1019)\n  * irc: fix memory leak in case of error in \"ecdsa-nist256p-challenge\" SASL mechanism\n  * relay: rebind on address after option relay.network.bind_address is changed\n  * relay: fix parsing of CAP command arguments in irc protocol (issue #995)\n\n[[v1.8]]\n== Version 1.8 (2017-05-13)\n\nNew features::\n\n  * core: add option weechat.completion.nick_case_sensitive (issue #981)\n  * core: add wildcard matching operator (`+=*+` and `+!*+`) in evaluation of expressions (issue #611)\n  * core: add cut of string in evaluation of expressions with \"cut:\" (number of chars) and \"cutscr:\" (number of chars displayed on screen)\n  * core: add ternary operator (condition) in evaluation of expressions (`${if:condition?value_if_true:value_if_false}`)\n  * core: add resize of window parents with /window resize [h/v]size (task #11461, issue #893)\n  * core: add hotlist pointer in buffer structure\n  * core: add last start date in output of command /version after at least one /upgrade (issue #903)\n  * api: add arraylist functions: arraylist_new, arraylist_size, arraylist_get, arraylist_search, arraylist_insert, arraylist_add, arraylist_remove, arraylist_clear, arraylist_free\n  * api: add dynamic string functions: string_dyn_alloc, string_dyn_copy, string_dyn_concat, string_dyn_free\n  * api: add special key \"__quiet\" in hashtable for function key_bind\n  * api: add `${re:#}` to get the index of last group captured in function string_eval_expression\n  * aspell: add options to control delimiters in suggestions: aspell.color.suggestion_delimiter_{dict|word} and aspell.look.suggestion_delimiter_{dict|word} (issue #940)\n  * buflist: new plugin \"buflist\" (bar item with list of buffers)\n  * irc: add option \"open\" in command /server (issue #966)\n  * irc: send signal \"irc_server_lag_changed\" and store the lag in the server buffer (local variable)\n  * irc: send multiple masks by message in commands /ban, /unban, /quiet and /unquiet, use ban mask default for nicks in /quiet and /unquiet, display an error if /quiet and /unquiet are not supported by server (issue #579, issue #15, issue #577)\n  * irc: add option \"-include\" in commands /allchan, /allpv and /allserv (issue #572)\n  * irc: don't smart filter modes given to you (issue #530, issue #897)\n  * script: remove option script.scripts.url_force_https, use HTTPS by default in option script.scripts.url\n\nBug fixes::\n\n  * core: fix memory leak in display of mouse event debug info\n  * core: fix command /cursor stop (do not toggle cursor mode) (issue #964)\n  * core: fix delayed refresh when the signal SIGWINCH is received (terminal resized), send signal \"signal_sigwinch\" after refreshes (issue #902)\n  * irc: fix update of server addresses on reconnection when the evaluated content has changed (issue #925)\n  * irc: fix crash in case of invalid server reply during SASL authentication with dh-blowfish or dh-aes mechanism\n  * irc: fix double decoding of IRC colors in messages sent/displayed by commands /msg and /query (issue #943)\n  * irc: fix parsing of message 324 (modes) when there is a colon before the modes (issue #913)\n  * relay: check buffer pointer received in \"sync\" and \"desync\" commands (weechat protocol) (issue #936)\n  * relay: remove buffer from synchronized buffers when it is closed (fix memory leak)\n\nBuild::\n\n  * core: fix compilation on FreeBSD with autotools (issue #276)\n  * python: add detection of Python 3.6\n  * ruby: add detection of Ruby 2.4 (issue #895)\n\n[[v1.7.1]]\n== Version 1.7.1 (2017-04-22)\n\nBug fixes::\n\n  * irc: fix parsing of DCC filename (CVE-2017-8073)\n\n[[v1.7]]\n== Version 1.7 (2017-01-15)\n\nNew features::\n\n  * core: add option weechat.look.align_multiline_words (issue #411, issue #802)\n  * core: add optional command prefix in completion templates \"commands\", \"plugins_commands\" and \"weechat_commands\"\n  * core: add optional arguments in completion template, sent to the callback\n  * core: add option \"time\" in command /debug\n  * core, xfer: display more information on fork errors (issue #573)\n  * core: add a slash before commands completed in arguments of /command, /debug time, /key bind, /key bindctxt, /mute, /repeat, /wait\n  * core: add a warning in header of configuration files to not edit by hand (issue #851)\n  * api: add info \"uptime\" (WeeChat uptime)\n  * api: add info \"pid\" (WeeChat PID) (issue #850)\n  * alias: add a slash before commands completed in arguments of /alias\n  * exec: add option \"-oc\" in command /exec to execute commands in process output, don't execute commands by default with \"-o\" (issue #877)\n  * fifo: add file fifo.conf and option fifo.file.path to customize FIFO pipe path/filename (issue #850, issue #122)\n  * irc: add server option \"usermode\" (issue #377, issue #820)\n  * irc: add tag \"self_msg\" on self messages (issue #840)\n  * irc: evaluate content of server option \"ssl_fingerprint\" (issue #858)\n  * irc: change default value of option irc.network.lag_reconnect from 0 to 300 (issue #818)\n  * trigger: do not hide email in command \"/msg nickserv register password email\" (issue #849)\n\nBug fixes::\n\n  * core: fix deadlock when quitting after a signal SIGHUP/SIGQUIT/SIGTERM is received (issue #32)\n  * core: fix display of empty lines in search mode (issue #829)\n  * api: fix crash in function string_expand_home when the HOME environment variable is not set (issue #827)\n  * exec: fix memory leak in display of process output\n  * irc: fix option \"-temp\" in command /server (issue #880)\n  * irc: fix close of server channels which are waiting for the JOIN when the server buffer is closed (issue #873)\n  * irc: fix buffer switching on manual join for forwarded channels (issue #876)\n  * irc: add missing tags on CTCP message sent\n  * lua: fix integers returned in Lua >= 5.3 (issue #834)\n  * relay: make HTTP headers case-insensitive for WebSocket connections (issue #888)\n  * relay: set status to \"authentication failed\" and close immediately connection in case of authentication failure in weechat and irc protocols (issue #825)\n  * script: reload a script after upgrade only if it was loaded, set autoload only if the script was auto-loaded (issue #855)\n\nBuild::\n\n  * core, irc, xfer: fix compilation on macOS (add link with resolv) (issue #276)\n  * core: add build of xz package with make dist (CMake)\n  * tests: fix compilation of tests on FreeBSD 11.0\n\n[[v1.6]]\n== Version 1.6 (2016-10-02)\n\nNew features::\n\n  * core: add optional argument \"lowest\", \"highest\" or level mask in command \"/input hotlist_clear\"\n  * core: add option \"cycle\" in command /buffer\n  * core, irc, xfer: display more information on memory allocation errors (issue #573)\n  * api: add \"extra\" argument to evaluate extra variables in function string_eval_expression (issue #534)\n  * api: remove functions printf_date and printf_tags\n  * irc: rename server options \"default_msg_{kick|part|quit}\" to \"msg_{kick|part|quit}\", evaluate them\n  * relay: add option relay.network.allow_empty_password (issue #735)\n  * relay: allow escape of comma in command \"init\" (weechat protocol) (issue #730)\n  * trigger: add support for one-time triggers (issue #399, issue #509)\n\nBug fixes::\n\n  * core, irc, xfer: refresh domain name and name server addresses before connection to servers (fix connection to servers after suspend mode) (issue #771)\n  * api: fix return of function string_match when there are multiple masks in the string (issue #812)\n  * api: fix crash in function network_connect_to if address is NULL\n  * api: fix connection to servers with hook_connect on Windows 10 with Windows subsystem for Linux (issue #770)\n  * api: fix crash in function string_split_command when the separator is not a semicolon (issue #731)\n  * irc: fix socket leak in connection to server (issue #358, issue #801)\n  * irc: fix display of service notice mask (message 008) (issue #429)\n  * irc: fix NULL pointer dereference in 734 command callback (issue #738)\n  * relay: return an empty hdata when the requested hdata or pointer is not found (issue #767)\n  * xfer: fix crash on DCC send if option xfer.file.auto_accept_nicks is set (issue #781)\n\nDocumentation::\n\n  * switch to asciidoctor to build docs and man page (issue #722)\n\nBuild::\n\n  * python: add detection of Python 3.5\n\n[[v1.5]]\n== Version 1.5 (2016-05-01)\n\nNew features::\n\n  * core: evaluate content of option \"weechat.look.item_time_format\" (issue #791)\n  * core: change default value of option weechat.look.nick_color_hash to \"djb2\"\n  * core: move nick coloring from irc plugin to core, move options irc.look.nick_color_force, irc.look.nick_color_hash and irc.look.nick_color_stop_chars to core, add info \"nick_color\" and \"nick_color_name\", deprecate info \"irc_nick_color\" and \"irc_color_name\" (issue #262)\n  * core: move irc bar item \"away\" to core, move options irc.look.item_away_message and irc.color.item_away to core (issue #692)\n  * api: add support of functions in hook_process\n  * api: add pointer in callbacks used in scripting API (issue #406)\n  * irc: add option irc.network.sasl_fail_unavailable (issue #600, issue #697)\n  * irc: add multiple targets and support of \"-server\" in command /ctcp (issue #204, issue #493)\n  * trigger: add \"recover\" in default triggers cmd_pass/msg_auth, and \"regain\" in default trigger \"msg_auth\" (issue #511)\n\nInternationalization::\n\n  * add Portuguese translations\n\nBug fixes::\n\n  * core: fix nick coloring when stop chars and a forced color are used: first remove chars then look for forced color\n  * core: check that pointers received in arguments are not NULL in buffers and windows functions\n  * core: fix truncation of buffer names in hotlist (issue #668)\n  * core: fix update of window title under Tmux (issue #685)\n  * api: fix number of arguments returned by function string_split when keep_eol is 2 and the string ends with separators\n  * irc: fix first message displayed in raw buffer when the message is modified by a modifier (issue #719)\n  * irc: add missing completion \"*\" for target in command /msg\n  * irc: fix /msg command with multiple targets including \"*\"\n  * lua: fix crash when a lua function doesn't return a value and a string was expected (issue #718)\n  * relay: do not execute any command received in a PRIVMSG message from an irc relay client (issue #699)\n  * relay: fix the max number of clients connected on a port, allow value 0 for \"no limit\" (issue #669)\n  * relay: fix decoding of multiple frames in a single websocket message, send PONG on PING received in a websocket frame (issue #675)\n  * relay: fix command \"input\" received from clients with only spaces in content of message (weechat protocol) (issue #663)\n  * script: force refresh of scripts buffer after download of scripts list (issue #693)\n  * xfer: fix DCC file received when the terminal is resized (issue #677, issue #680)\n\nBuild::\n\n  * python: fix detection of Python shared libraries (issue #676)\n  * ruby: add detection of Ruby 2.3 (issue #698)\n\n[[v1.4]]\n== Version 1.4 (2016-01-10)\n\nNew features::\n\n  * core: add a parent name in options, display inherited values if null in /set output, add option weechat.color.chat_value_null (issue #629)\n  * core: add tag \"term_warning\" in warnings about wrong $TERM on startup\n  * core: add option weechat.look.paste_auto_add_newline (issue #543)\n  * core: display a more explicit error when a filter fails to be added (issue #522)\n  * api: add function string_hex_dump\n  * api: add argument \"length\" in function utf8_is_valid\n  * alias: display completion in /alias list (issue #518)\n  * fifo: add /fifo command\n  * irc: track real names using extended-join and WHO (issue #351)\n  * irc: add support of SNI (Server Name Indication) in SSL connection to IRC server (issue #620)\n  * irc: add support of \"cap-notify\" capability (issue #182, issue #477)\n  * irc: add command /cap (issue #8)\n  * irc: add hex dump of messages in raw buffer when debug is enabled for irc plugin (level 2 or more)\n  * irc: evaluate content of server option \"addresses\"\n  * irc: move option irc.network.alternate_nick into servers (irc.server.xxx.nicks_alternate) (issue #633)\n  * irc: use current channel and current server channels first in completions \"irc_server_channels\" and \"irc_channels\" (task #12923, issue #260, issue #392)\n  * logger: display system error when the log file can not be written (issue #541)\n  * relay: add option relay.irc.backlog_since_last_message (issue #347)\n  * script: add option script.scripts.download_timeout\n  * script: add completion with languages and extensions, support search by language/extension in /script search\n\nBug fixes::\n\n  * core: fix execution of empty command name (\"/\" and \"/ \" are not valid commands)\n  * core: fix memory leak when using multiple \"-d\" or \"-r\" in command line arguments\n  * core: don't complain any more about \"tmux\" and \"tmux-256color\" $TERM values when WeeChat is running under Tmux (issue #519)\n  * core: fix truncated messages after a word with a length of zero on screen (for example a zero width space: U+200B) (bug #40985, issue #502)\n  * api: fix handle of invalid escape in function string_convert_escaped_chars\n  * alias: do not allow slashes and spaces in alias name (issue #646)\n  * irc: fix channel forwarding when option irc.look.buffer_open_before_{autojoin|join} is on (issue #643)\n  * irc: add a missing colon before the password in PASS message, if the password has spaces or begins with a colon (issue #602)\n  * irc: fix charset decoding in incoming private messages (issue #520)\n  * irc: display the arrow before server name in raw buffer\n  * irc: fix display of messages sent to server in raw buffer\n  * irc: fix display of invalid UTF-8 chars in raw buffer\n  * relay: display the arrow before client id and protocol in raw buffer\n  * ruby: fix load of scripts requiring \"uri\" (issue #433)\n\nDocumentation::\n\n  * add Czech man page and quickstart guide (issue #490)\n\nTests::\n\n  * unit: add a test to check if all plugins are loaded\n  * unit: fix locale used to execute tests (issue #631)\n\nBuild::\n\n  * core: add scripts version.sh and build-debian.sh, separate stable from devel Debian packaging\n  * ruby: fix Ruby detection when pkg-config is not installed\n\n[[v1.3]]\n== Version 1.3 (2015-08-16)\n\nNew features::\n\n  * core: add completion \"colors\" (issue #481)\n  * core: start/stop search in buffer at current scroll position by default, add key kbd:[Ctrl+q] to stop search and reset scroll (issue #76, issue #393)\n  * core: add option weechat.look.key_grab_delay to set the default delay when grabbing a key with kbd:[Alt+k]\n  * core: add option weechat.look.confirm_upgrade (issue #463)\n  * core: add signal \"signal_sighup\"\n  * core: allow kbd:[Ctrl+c] to exit WeeChat when the passphrase is asked on startup (issue #452)\n  * core: allow pointer as list name in evaluation of hdata (issue #450)\n  * api: add support of evaluated sub-strings and current date/time in function string_eval_expression and command /eval\n  * api: add function string_eval_path_home\n  * alias: add options \"add\", \"addcompletion\" and \"del\" in command /alias, remove command /unalias (issue #458)\n  * irc: add option irc.network.channel_encode (issue #218, issue #482)\n  * irc: add option irc.color.topic_current (issue #475)\n  * irc: evaluate content of server option \"nicks\"\n  * logger: evaluate content of option logger.file.path (issue #388)\n  * script: rename option script.scripts.dir to script.scripts.path, evaluate content of option (issue #388)\n  * relay: display value of HTTP header \"X-Real-IP\" for websocket connections (issue #440)\n  * xfer: evaluate content of options xfer.file.download_path and xfer.file.upload_path (issue #388)\n\nBug fixes::\n\n  * core: flush stdout/stderr after sending text directly on them (fix corrupted data sent to hook_process callback) (issue #442)\n  * core: allow execution of command \"/input return\" on a buffer which is not displayed in a window\n  * core: allow jump from current to previous buffer with default keys kbd:[Alt+j], kbd:[01..99] (issue #466)\n  * core: fix crash if a file descriptor used in hook_fd is too high (> 1024 on Linux/BSD) (issue #465)\n  * core: fix display of invalid UTF-8 chars in bars\n  * core: fix bar item \"scroll\" after /buffer clear (issue #448)\n  * core: fix display of time in bare display when option weechat.look.buffer_time_format is set to empty string (issue #441)\n  * api: add missing function infolist_search_var in script API (issue #484)\n  * api: add missing function hook_completion_get_string in script API (issue #484)\n  * api: fix type of value returned by functions strcasestr, utf8_prev_char, utf8_next_char, utf8_add_offset and util_get_time_string\n  * api: fix type of value returned by function strcasestr\n  * fifo: fix send error on Cygwin when something is received in the pipe (issue #436)\n  * irc: fix update of lag item when the server lag changes\n  * irc: do not allow command /query with a channel name (issue #459)\n  * irc: decode/encode only text in IRC messages and not the headers (bug #29886, issue #218, issue #451)\n  * irc: fix crash with commands /allchan, /allpv and /allserv if the executed command closes buffers (issue #445)\n  * irc: do not open auto-joined channels buffers when option \"-nojoin\" is used in command /connect (even if the option irc.look.buffer_open_before_autojoin is on)\n  * irc: fix errors displayed on WHOX messages received (issue #376)\n  * xfer: fix crash if the DCC file socket number is too high (> 1024 on Linux/BSD) (issue #465)\n  * xfer: fix parsing of DCC chat messages (handle \"\\r\\n\" at the end of messages) (issue #425, issue #426)\n\nDocumentation::\n\n  * replace PREFIX with CMAKE_INSTALL_PREFIX in CMake instructions (issue #354)\n\nBuild::\n\n  * lua: add detection of Lua 5.3\n  * ruby: add detection of Ruby 2.2\n\n[[v1.2]]\n== Version 1.2 (2015-05-10)\n\nNew features::\n\n  * core: add signals \"signal_sigterm\" and \"signal_sigquit\" (issue #114)\n  * core: use environment variable WEECHAT_HOME on startup (issue #391)\n  * core: add options weechat.look.quote_{nick_prefix|nick_suffix|time_format} to customize quoted messages in cursor mode (issue #403)\n  * core: add a welcome message on first WeeChat run (issue #318)\n  * core: add options weechat.look.word_chars_{highlight|input} (issue #55, task #9459)\n  * core: remove WeeChat version from config files (issue #407)\n  * core: display a warning on startup if the locale can not be set (issue #373)\n  * core: allow \"*\" as plugin name in command \"/plugin reload\" to reload all plugins with options\n  * core: add option \"-s\" in command /eval to split expression before evaluating it (no more split by default) (issue #324)\n  * core: add priority in plugins to initialize them in order\n  * api: add support of environment variables in function string_eval_expression and command /eval\n  * api: add support of full color option name in functions color and string_eval_expression and in command /eval\n  * api: add \"_chat_line\" (line pointer) in hashtable of hook_focus\n  * irc: add support of \"account-notify\" capability (issue #11, issue #246)\n  * irc: add support of \"ecdsa-nist256p-challenge\" SASL mechanism (issue #251)\n  * irc: display a warning when the option irc.look.display_away is set to \"channel\"\n  * irc: optimize search of a nick in nicklist (up to 3x faster)\n  * irc: add support of SHA-256 and SHA-512 algorithms in server option \"ssl_fingerprint\" (issue #281)\n  * irc: add option \"-noswitch\" in command /query (issue #394)\n  * irc: format message 008 (RPL_SNOMASK) (issue #144)\n  * irc: remove server \"freenode\" from default config file (issue #309)\n  * javascript: new script plugin for JavaScript\n\nBug fixes::\n\n  * core: add missing completions in command /input\n  * guile: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, hook_command, buffer_string_replace_local_var, command\n  * irc: fix color of new nick in nick changes messages when option irc.look.color_nicks_in_server_messages is off\n  * irc: fix crash when setting an invalid regex with \"/list -re\" during a /list server response (issue #412)\n  * irc: fix display of PART messages on channels with +a (anonymous flag) (issue #396)\n  * irc: remove useless rename of channel buffer on JOIN received with different case (issue #336)\n  * irc: fix completion of commands /allchan and /allpv\n  * lua: fix wrong argument usage in functions nicklist_remove_group, nicklist_remove_nick and nicklist_remove_all (issue #346)\n  * lua: fix value returned in case of error in functions: config_option_reset, config_string, config_string_default, config_color, config_color_default, config_write, config_read, config_reload, hook_modifier_exec, buffer_string_replace_local_var, nicklist_group_set, nicklist_nick_set, command, upgrade_read, upgrade_close\n  * relay: fix up/down keys on relay buffer (issue #335)\n  * relay: remove v4-mapped addresses in /help relay.network.allowed_ips (issue #325)\n  * perl: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, buffer_string_replace_local_var, command\n  * python: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, config_is_set_plugin, buffer_get_string, buffer_string_replace_local_var, nicklist_group_get_string, nicklist_nick_get_string, command, hdata_time\n  * python: fix name of function \"bar_update\" in case of error\n  * python: fix restore of old interpreter when a function is not found in the script\n  * ruby: fix crash on /plugin reload (issue #364)\n  * ruby: fix value returned in case of error in functions: config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, buffer_string_replace_local_var, command\n  * script: fix state of script plugins when list of scripts has not been downloaded\n  * scripts: reset current script pointer when load of script fails in python/perl/ruby/lua/tcl plugins\n  * scripts: fix return code of function bar_set in python/perl/ruby/lua/tcl/guile plugins\n  * scripts: fix type of value returned by function hdata_time (from string to long integer) in perl/ruby/lua/tcl/guile plugins\n  * tcl: fix value returned in case of error in functions: mkdir_home, mkdir, mkdir_parents, config_option_reset, config_color, config_color_default, config_write, config_read, config_reload, print_date_tags, buffer_string_replace_local_var, command, infolist_new_item, infolist_new_var_integer, infolist_new_var_string, infolist_new_var_pointer, infolist_new_var_time, upgrade_write_object, upgrade_read, upgrade_close\n  * trigger: do not hook anything if the trigger is disabled (issue #405)\n\nDocumentation::\n\n  * add Russian man page\n\n[[v1.1.1]]\n== Version 1.1.1 (2015-01-25)\n\nBug fixes::\n\n  * core: fix crash when a root bar has conditions different from active/inactive/nicklist (issue #317)\n  * irc: don't close channel buffer on second /part when option irc.look.part_closes_buffer is off (issue #313)\n  * irc: fix /join on a channel buffer opened with autojoin but which failed to join\n  * irc: send QUIT to server and no PART for channels when the server buffer is closed (issue #294)\n  * irc: fix order of channel buffers opened when option irc.look.server_buffer is set to \"independent\", irc.look.buffer_open_before_autojoin to \"on\" and irc.look.new_channel_position to \"near_server\" (issue #303)\n  * irc: fix crash in buffer close when server name is the same as a channel name (issue #305)\n\nBuild::\n\n  * core: fix random error when creating symbolic link weechat-curses on make install with CMake (bug #40313)\n\n[[v1.1]]\n== Version 1.1 (2015-01-11)\n\nNew features::\n\n  * core: add option weechat.completion.command_inline (task #12491)\n  * core: add bar item \"mouse_status\", new options weechat.look.item_mouse_status and weechat.color.status_mouse (issue #247)\n  * core: add signals \"mouse_enabled\" and \"mouse_disabled\" (issue #244)\n  * core: add hide of chars in string in evaluation of expressions\n  * core: add arraylists, improve speed of completions (about 50x faster)\n  * core: allow incomplete commands if unambiguous, new option weechat.look.command_incomplete (task #5419)\n  * core: check bar conditions in root bars and on each update of a bar item\n  * core: fully evaluate commands bound to keys in cursor and mouse contexts\n  * core: move bar item \"scroll\" between buffer name and lag in default bar items of status bar\n  * api: add regex replace feature in function string_eval_expression\n  * api: send value returned by command callback in function command, remove WeeChat error after command callback if return code is WEECHAT_RC_ERROR\n  * api: use microseconds instead of milliseconds in functions util_timeval_diff and util_timeval_add\n  * irc: add option \"reorder\" in command /server (issue #229)\n  * irc: open channel buffers before the JOIN is received from server (autojoin and manual joins), new options irc.look.buffer_open_before_{autojoin|join} (issue #216)\n  * irc: add server option \"sasl_fail\" (continue/reconnect/disconnect if SASL fails) (issue #265, task #12204)\n  * irc: add support for color codes 16-99 in IRC messages (issue #228), add infolist \"irc_color_weechat\"\n  * irc: add support of \"extended-join\" capability (issue #143, issue #212)\n  * irc: display own nick changes in server buffer (issue #188)\n  * irc: disable creation of temporary servers by default with command /connect, new option irc.look.temporary_servers\n  * irc: disable SSLv3 by default in server option \"ssl_priorities\" (issue #248)\n  * irc: automatically add current channel in command /samode (issue #241)\n  * irc: add tag \"nick_xxx\" in invite messages\n  * relay: add options \"stop\" and \"restart\" in command /relay\n  * relay: add option relay.network.ssl_priorities (issue #234)\n  * relay: add host in sender for IRC backlog PRIVMSG messages sent to clients\n  * script: add option script.scripts.url_force_https (issue #253)\n  * trigger: evaluate and replace regex groups at same time, new format for regex option in triggers (incompatible with version 1.0) (issue #224)\n  * trigger: add option \"restore\" in command /trigger\n  * trigger: add `${tg_displayed}` in conditions of default trigger \"beep\"\n\nBug fixes::\n\n  * core: fix display bug when scrolling in buffer on a filtered line (issue #240)\n  * core: send mouse code only one time to terminal with command /mouse enable|disable|toggle\n  * core: fix buffer property \"lines_hidden\" when merging buffers or when a line is removed from a buffer (issue #226)\n  * core: display time in bare display only if option weechat.look.buffer_time_format is not an empty string\n  * core: fix translation of message displayed after /upgrade\n  * api: fix truncated process output in hook_process (issue #266)\n  * api: fix crash when reading config options with NULL value (issue #238)\n  * irc: defer the auto-connection to servers with a timer (issue #279, task #13038)\n  * irc: add missing server options \"sasl_timeout\" and \"notify\" in output of /server listfull\n  * irc: use option irc.look.nick_mode_empty to display nick prefix in bar item \"input_prompt\"\n  * irc: remove IRC color codes from buffer title in channels (issue #237)\n  * irc: fix completion of commands /msg, /notice and /query\n  * irc: fix translation of CTCP PING reply (issue #137)\n  * relay: wait for message CAP END before sending join of channels and backlog to the client (issue #223)\n  * relay: send messages \"_buffer_localvar_*\" and \"_buffer_type_changed\" with sync \"buffers\" (issue #191)\n  * relay: don't remove relay from config when the binding fails (issue #225)\n  * relay: use comma separator in option relay.irc.backlog_tags, check the value of option when it is changed with /set\n  * relay: remove \"::ffff:\" from IPv4-mapped IPv6 client address (issue #111)\n  * trigger: fix memory leak when allocating a new trigger with several regex\n  * xfer: fix freeze when accepting DCC (issue #160, issue #174)\n  * xfer: bind to wildcard address when sending (issue #173)\n\nBuild::\n\n  * core: fix compilation of man pages with autotools in source directory\n  * core: fix compilation of plugins with CMake >= 3.1 (issue #287)\n  * lua: add detection of Lua 5.2\n  * python: fix Python detection with Homebrew (issue #217)\n  * tests: fix compilation of tests with clang (issue #275)\n\n[[v1.0.1]]\n== Version 1.0.1 (2014-09-28)\n\nBug fixes::\n\n  * core: fix crash on buffer close when option weechat.look.hotlist_remove is set to \"merged\" (issue #199)\n  * core: fix highlight of IRC action messages when option irc.look.nick_mode is set to \"action\" or \"both\" (issue #206)\n  * core: fix compilation of plugin API functions (macros) when compiler optimizations are enabled (issue #200)\n  * core: fix window/buffer pointers used in command /eval\n  * core: fix modifier \"weechat_print\": discard only one line when several lines are displayed in same message (issue #171)\n  * api: fix bug in function hdata_move when absolute value of count is greater than 1\n  * aspell: fix crash with command \"/aspell addword\" if no word is given (issue #164, issue #165)\n  * irc: fix display of channel exception list (348) with 6 arguments (date missing)\n  * irc: fix type of value stored in hashtable when joining a channel (issue #211)\n  * relay: fix send of signals \"relay_client_xxx\" (issue #214)\n  * script: fix crash on \"/script update\" if a script detail is displayed in buffer (issue #177)\n  * trigger: do not allow any changes on a trigger when it is currently running (issue #189)\n  * trigger: fix regex used in default triggers to hide passwords (\"\\S\" is not supported on *BSD) (issue #172)\n\nTests::\n\n  * unit: fix memory leak in tests launcher\n\nBuild::\n\n  * aspell: fix compilation with Enchant < 1.6.0 (issue #192)\n  * guile: fix compilation with Guile < 2.0.4 (issue #198)\n  * perl: fix detection of Perl >= 5.20 with autotools\n  * tests: fix build of tests when the build directory is outside source tree (issue #178)\n\n[[v1.0]]\n== Version 1.0 (2014-08-15)\n\nNew features::\n\n  * core: display a warning on startup if $TERM does not start with \"screen\" under Screen/Tmux\n  * core: add option weechat.color.status_nicklist_count (issue #109, issue #110)\n  * core: add option \"env\" in command /set (manage environment variables)\n  * core: add bar item \"buffer_short_name\" (task #10882)\n  * core: add option \"send\" in command /input (send text to a buffer)\n  * core: add support of negated tags in filters (with \"!\") (issue #72, issue #74)\n  * core: add hidden buffers, add options hide/unhide in command /buffer\n  * core: add default key kbd:[Alt+-] (toggle filters in current buffer) (issue #17)\n  * core: add non-active merged buffers with activity in hotlist (if another merged buffer is zoomed) (task #12845)\n  * core: add text search in buffers with free content (task #13051)\n  * core: add buffer property \"clear\"\n  * core: add option weechat.look.hotlist_add_conditions, remove option weechat.look.hotlist_add_buffer_if_away\n  * core: add option weechat.look.hotlist_remove (issue #99)\n  * core: add options \"-beep\" and \"-current\" in command /print\n  * core: add bare display mode for easy text selection and click on URLs, new key: kbd:[Alt+l] (`L`), new option \"bare\" in command /window, new options: weechat.look.bare_display_exit_on_input and weechat.look.bare_display_time_format\n  * core: add signals \"key_combo_{default|search|cursor}\"\n  * core: add terabyte unit for size displayed\n  * core: display a warning in case of inconsistency between the options weechat.look.save_{config|layout}_on_exit\n  * core: add option \"-mask\" in command /unset (issue #112)\n  * core: set option weechat.look.buffer_search_where to prefix_message by default\n  * core: mute all buffers by default in command /mute (replace option -all by -core)\n  * api: allow value \"-1\" for property \"hotlist\" in function buffer_set (to remove a buffer from hotlist)\n  * api: add option \"buffer_flush\" in function hook_process_hashtable\n  * api: add support of case insensitive search and search by buffer full name in function buffer_search (bug #34318)\n  * api: add option \"detached\" in function hook_process_hashtable\n  * api: add option \"signal\" in function hook_set to send a signal to the child process\n  * api: add support of nested variables in function string_eval_expression and command /eval (issue #35)\n  * api: add support of escaped strings with format `${esc:xxx}` or `${\\xxx}` in function string_eval_expression and command /eval\n  * api: add functions hashtable_dup, string_replace_regex, string_split_shell, string_convert_escaped_chars\n  * api: add integer return code for functions hook_{signal|hsignal}_send\n  * api: add argument \"flags\" in function hdata_new_list\n  * api: allow wildcard \"*\" inside the mask in function string_match\n  * api: allow negative value for y in function printf_y\n  * alias: add default alias \"msgbuf\" (send text to a buffer)\n  * exec: add exec plugin: new command /exec and file exec.conf\n  * irc: add bar item \"irc_nick_modes\" (issue #71)\n  * irc: add support of message 324 (channel modes) in option irc.look.display_join_message (issue #75)\n  * irc: add option irc.look.join_auto_add_chantype (issue #65)\n  * irc: add tag with host (\"host_xxx\") in IRC messages displayed (task #12018)\n  * irc: add option irc.color.item_nick_modes (issue #47)\n  * irc: add support of \"away-notify\" capability (issue #12)\n  * irc: add command /remove (issue #91)\n  * irc: add command /unquiet (issue #36)\n  * irc: add command /allpv (task #13111)\n  * irc: display locally away status changes in private buffers (in addition to channels) (issue #117)\n  * irc: allow many fingerprints in server option ssl_fingerprint (issue #49)\n  * irc: rename option irc.look.item_channel_modes_hide_key to irc.look.item_channel_modes_hide_args, value is now a string (task #12070, task #12163, issue #48)\n  * irc: add value \"+\" for option irc.look.smart_filter_mode to use modes from server prefixes (this is now the default value) (issue #90)\n  * irc: allow \"$ident\" in option irc.network.ban_mask_default (issue #18)\n  * irc: evaluate content of server options \"username\" and \"realname\"\n  * irc: set option irc.network.autoreconnect_delay_max to 600 by default, increase max value to 604800 seconds (7 days)\n  * irc: set option irc.network.whois_double_nick to \"off\" by default\n  * relay: add messages \"_buffer_cleared\", \"_buffer_hidden\" and \"_buffer_unhidden\"\n  * relay: add info \"relay_client_count\" with optional status name as argument\n  * relay: add signals \"relay_client_xxx\" for client status changes (issue #2)\n  * relay: add option relay.network.clients_purge_delay\n  * rmodifier: remove plugin (replaced by trigger)\n  * script: set option script.scripts.cache_expire to 1440 by default\n  * trigger: add trigger plugin: new command /trigger and file trigger.conf\n\nBug fixes::\n\n  * core: fix zero-length malloc of an hashtable item with type \"buffer\"\n  * core: fix memory leak on /upgrade when file signature in upgrade file is invalid\n  * core: fix memory leak in completion of config options values\n  * core: fix memory leak when removing script files\n  * core: fix result of hash function (in hashtables) on 32-bit systems\n  * core: fix insert of mouse code in input line after a partial key combo (issue #130)\n  * core: check code point value in UTF-8 check function (issue #108)\n  * core: fix socks5 proxy for curl downloads (issue #119)\n  * core: display curl error after a failed download\n  * core: do not display content of passphrase on /secure buffer\n  * core: fix potential memory leak with infolists not freed in plugins (debian #751108)\n  * core: fix color display of last terminal color number + 1 (issue #101)\n  * core: add option \"-buffer\" in command /command (issue #67)\n  * core: fix restoration of core buffer properties after /upgrade\n  * core: fix \"/buffer clear\" with a name (don't clear all merged buffers with same number)\n  * core: fix evaluation of expression with regex: when a comparison char is in the regex and don't evaluate the regex itself (issue #63)\n  * core: close .upgrade files before deleting them after /upgrade\n  * core: fix refresh of bar item \"buffer_zoom\" on buffer switch\n  * core: fix reset of attributes in bars when \"resetcolor\" is used (issue #41)\n  * core: fix alignment of lines in merged buffers when options weechat.look.prefix_align and weechat.look.prefix_buffer_align are set to \"none\" (issue #43)\n  * core: quit WeeChat on signal SIGHUP, remove signal \"signal_sighup\"\n  * core: fix add of filter on macOS when regex for message is empty (filter regex ending with \"\\t\")\n  * core: check validity of buffer pointer when data is sent to a buffer (command/text from user and API function command)\n  * core: fix crash when buffer is closed during execution of multiple commands (issue #27)\n  * core: fix compilation on SmartOS (bug #40981, issue #23)\n  * core: add missing \\0 at the end of stderr buffer in function hook_process\n  * core: fix highlight problem with \"(?-i)\" and upper case letters in option weechat.look.highlight (issue #24)\n  * core: fix detection of terminated process in function hook_process\n  * core: fix \"/window scroll -N\" on a buffer with free content\n  * core: fix recursive calls to function eval_expression\n  * core: save and restore mute state in command /mute (bug #41748)\n  * core: fix memory leak when removing a hdata\n  * core: fix memory leak in evaluation of sub-conditions\n  * core: fix memory leak in function gui_key_add_to_infolist (in case of insufficient memory)\n  * core: fix use of invalid pointer in function gui_bar_window_content_alloc (in case of insufficient memory)\n  * core: fix uninitialized value in function string_decode_base64\n  * core: fix memory leak and use of invalid pointer in split of string (in case of insufficient memory)\n  * core: fix potential NULL pointer in function gui_color_emphasize\n  * core: use same return code and message in all commands when arguments are wrong/missing\n  * core: allow empty arguments for command /print\n  * core: fix freeze/crash in GnuTLS (bug #41576)\n  * api: fix function string_decode_base64\n  * api: fix function string_format_size on 32-bit systems\n  * api: change type of arguments displayed/highlight in hook_print callback from string to integer (in scripts)\n  * alias: change default command for alias /beep to \"/print -beep\"\n  * guile: fix module used after unload of a script\n  * irc: fix memory leak in CTCP answer\n  * irc: fix duplicate sender name in display of wallops (issue #142, issue #145)\n  * irc: fix extract of channel in parser for JOIN/PART messages when there is a colon before the channel name (issue #83)\n  * irc: fix duplicate sender name in display of notice (issue #87)\n  * irc: fix refresh of buffer name in bar items after join/part/kick/kill (issue #86)\n  * irc: display message 936 (censored word) on channel instead of server buffer\n  * irc: make reason optional in command /kill\n  * irc: add alias \"whois\" for target buffer of messages 401/402 (issue #54)\n  * irc: fix truncated read on socket with SSL (bug #41558)\n  * irc: display output of CAP LIST in server buffer\n  * irc: fix colors in message with CTCP reply sent to another user\n  * irc: fix read of MODES server value when in commands /op, /deop, /voice, /devoice, /halfop, /dehalfop\n  * irc: fix parsing of nick in host when \"!\" is not found (bug #41640)\n  * lua: fix interpreter used after unload of a script\n  * perl: fix context used after unload of a script\n  * python: fix read of return value for callbacks returning an integer in Python 2.x (issue #125)\n  * python: fix interpreter used after unload of a script\n  * relay: fix memory leak during handshake on websocket\n  * relay: fix memory leak when receiving commands from client (weechat protocol)\n  * relay: fix crash when an IRC \"MODE\" command is received from client without arguments\n  * relay: fix number of bytes sent/received on 32-bit systems\n  * relay: fix crash when closing relay buffers (issue #57, issue #78)\n  * relay: check pointers received in hdata command to prevent crashes with bad pointers (WeeChat protocol)\n  * relay: remove warning on /reload of relay.conf when ports are defined\n  * relay: fix client disconnection on empty websocket frames received (PONG)\n  * relay: add support of Internet Explorer websocket (issue #73)\n  * relay: fix crash on /upgrade received from a client (weechat protocol)\n  * relay: fix freeze after /upgrade when many disconnected clients still exist\n  * relay: fix NULL pointer when reading buffer lines for irc backlog\n  * ruby: fix crash when trying to load a directory with /ruby load\n  * script: fix display of curl errors\n  * script: fix scroll on script buffer in the detailed view of script (issue #6)\n  * scripts: fix crash when a signal is received with type \"int\" and NULL pointer in signal_data\n  * xfer: fix problem with option xfer.file.auto_accept_nicks when the server name contains dots\n  * xfer: fix freeze/problems when sending empty files with DCC (issue #53)\n  * xfer: fix connection to remote host in DCC receive on macOS (issue #25)\n  * xfer: remove bind on xfer.network.own_ip (issue #5)\n\nBuild::\n\n  * core: fix CMake warning CMP0007 on \"make uninstall\" (bug #41528)\n  * core: use glibtoolize on macOS (autotools) (issue #22)\n  * ruby: add detection of Ruby 2.1\n\nTests::\n\n  * unit: add unit tests using CppUTest (issue #104)\n\n[[v0.4.3]]\n== Version 0.4.3 (2014-02-09)\n\nNew features::\n\n  * core: add signals \"signal_sighup\" and \"signal_sigwinch\" (terminal resized)\n  * core: add command /print, add support of more escaped chars in command \"/input insert\"\n  * core: add option weechat.look.tab_width\n  * core: add completion \"plugins_installed\"\n  * core: add option weechat.look.window_auto_zoom, disable automatic zoom by default when terminal becomes too small for windows\n  * core: use \"+\" separator to make a logical \"and\" between tags in command /filter, option weechat.look.highlight_tags and buffer property \"highlight_tags\"\n  * core: add options weechat.look.buffer_auto_renumber and weechat.look.buffer_position, add option \"renumber\" in command /buffer, add bar item \"buffer_last_number\" (task #12766)\n  * core: add signal \"buffer_cleared\"\n  * core: add buffer property \"day_change\" to hide messages for the day change in specific buffers\n  * core: add option \"libs\" in command /debug\n  * core: add infos \"term_width\" and \"term_height\"\n  * core: add bar item \"buffer_zoom\", add signals \"buffer_{zoomed|unzoomed}\" (patch #8204)\n  * core: add default keys kbd:[Alt+Home] / kbd:[Alt+End] (`meta2-1;3H` / `meta2-1;3F`) and kbd:[Alt+F11] / kbd:[Alt+F12] (`meta2-23;3~` / `meta2-24;3~`) for xterm\n  * core: add support of italic text (requires ncurses >= 5.9 patch 20130831)\n  * core: add options to customize default text search in buffers: weechat.look.buffer_search_{case_sensitive|force_default|regex|where}\n  * core: add support of UTF-8 chars in horizontal/vertical separators (options weechat.look.separator_{horizontal|vertical})\n  * core: add support of logical and/or for argument \"tags\" in function hook_print\n  * core: rename buffer property \"highlight_tags\" to \"highlight_tags_restrict\", new behavior for buffer property \"highlight_tags\" (force highlight on tags), rename option irc.look.highlight_tags to irc.look.highlight_tags_restrict\n  * core: rename options save/reset to store/del in command /layout\n  * core: replace default key kbd:[Ctrl+c], kbd:[r] by kbd:[Ctrl+c], kbd:[v] for reverse video in messages\n  * core: replace default key kbd:[Ctrl+c], kbd:[u] by kbd:[Ctrl+c], kbd:[_] for underlined text in messages\n  * core: rename option weechat.look.set_title to weechat.look.window_title, value is now a string (evaluated)\n  * core: set option weechat.look.paste_bracketed to \"on\" by default\n  * core: use one date format when day changes from day to day+1\n  * api: add function infolist_search_var\n  * api: add stdin options in functions hook_process_hashtable and hook_set to send data on stdin of child process, add function hook_set in script API (task #10847, task #13031)\n  * api: add hdata \"buffer_visited\"\n  * api: add support of infos with format `${info:name,arguments}` in function string_eval_expression and command /eval\n  * api: add support for C++ plugins\n  * alias: add default alias /beep => /print -stderr \\a\n  * irc: add server option \"ssl_fingerprint\" (task #12724)\n  * irc: add option irc.look.smart_filter_mode (task #12499)\n  * irc: add option irc.network.ban_mask_default (bug #26571)\n  * irc: add option irc.network.lag_max\n  * irc: add option irc.look.notice_welcome_tags\n  * irc: add server option \"default_msg_kick\" to customize default kick/kickban message (task #12777)\n  * irc: use MONITOR instead of ISON for /notify when it is available on server (task #11477)\n  * relay: send backlog for irc private buffers\n  * xfer: add support of IPv6 for DCC chat/file (patch #7992)\n  * xfer: add option xfer.file.auto_check_crc32 (patch #7963)\n\nBug fixes::\n\n  * core: fix hotlist problems after apply of a layout (bug #41481)\n  * core: fix crash when creating two bars with same name but different case (bug #41418)\n  * core: fix display of read marker when all buffer lines are unread and that option weechat.look.read_marker_always_show is on\n  * core: fix memory leak in regex matching when evaluating expression\n  * core: fix crash in /eval when config option has a NULL value\n  * core: fix crash with hdata_update on shared strings, add hdata type \"shared_string\" (bug #41104)\n  * core: fix text emphasis with wide chars on screen like Japanese (patch #8253)\n  * core: remove option on /unset of plugin description option (plugins.desc.xxx) (bug #40768)\n  * core: fix random crash when closing a buffer\n  * core: fix crash on /buffer close core.weechat\n  * core: apply color attributes when clearing a window (patch #8236)\n  * core: fix truncated text when pasting several long lines (bug #40210)\n  * core: create .conf file with default options only if the file does not exist (and not on read error with existing file)\n  * core: fix highlight on action messages: skip the nick at beginning to prevent highlight on it (bug #40516)\n  * core: fix bind of keys in cursor/mouse context when key starts with \"@\" (remove the warning about unsafe key)\n  * core: fix truncated prefix when filters are toggled (bug #40204)\n  * api: fix read of arrays in hdata functions hdata_<type> (bug #40354)\n  * aspell: fix detection of nicks with non-alphanumeric chars\n  * guile: disable guile gmp allocator (fix crash on unload of relay plugin) (bug #40628)\n  * irc: clear the GnuTLS session in all cases after SSL connection error\n  * irc: do not display names by default when joining a channel (task #13045)\n  * irc: display PONG answer when resulting from manual /ping command\n  * irc: fix time parsed in tag of messages on Cygwin\n  * irc: use statusmsg from message 005 to check prefix char in status notices/messages\n  * irc: remove display of channel in channel notices, display \"PvNotice\" for channel welcome notices\n  * irc: fix ignore on a host without nick\n  * irc: use color code 0x1F (`ctrl-_`) for underlined text in input line (same code as messages) (bug #40756)\n  * irc: use color code 0x16 (`ctrl-v`) for reverse video in messages\n  * irc: use option irc.network.colors_send instead of irc.network.colors_receive when displaying messages sent by commands /away, /me, /msg, /notice, /query\n  * irc: fix memory leak when checking the value of ssl_priorities option in servers\n  * irc: fix memory leak when a channel is deleted\n  * irc: fix groups in channel nicklist when reconnecting to a server that supports more nick prefixes than the previously connected server\n  * irc: fix auto-switch to channel buffer when doing /join channel (without \"#\")\n  * logger: fix memory leaks in backlog\n  * logger: replace backslashs in name by logger replacement char under Cygwin (bug #41207)\n  * lua: fix crash on calls to callbacks during load of script\n  * python: fix load of scripts with Python >= 3.3\n  * relay: fix memory leak on unload of relay plugin\n  * ruby: fix ruby init with Ruby >= 2.0 (bug #41115)\n  * scripts: fix script interpreter used after register during load of script in python/perl/ruby/lua/guile plugins (bug #41345)\n  * xfer: use same infolist for hook and signals (patch #7974)\n\nDocumentation::\n\n  * add French developer's guide and relay protocol\n  * add Japanese plugin API reference and developer's guide\n  * add Polish man page and user's guide\n\nBuild::\n\n  * core: fix installation of weechat-plugin.h with autotools (patch #8305)\n  * core: fix compilation on Android (bug #41420, patch #8301, bug #41434)\n  * lua: fix detection of Lua 5.2 in autotools (patch #8270)\n  * ruby: add detection and fix compilation with Ruby 2.0 (patch #8209)\n\n[[v0.4.2]]\n== Version 0.4.2 (2013-10-06)\n\nNew features::\n\n  * core: display day change message dynamically (do not store it as a line in buffer), split option weechat.look.day_change_time_format into two options weechat.look.day_change_message_{1date|2dates}, new option weechat.color.chat_day_change (task #12775)\n  * core: add syntax \"@buffer:item\" in bar items to force the buffer used when displaying the bar item (task #12717)\n  * core: add search of regular expression in buffer, don't reset search type on a new search, select where to search (messages/prefixes), add keys in search context: kbd:[Alt+c] (case (in)sensitive search), kbd:[Tab] (search in messages/prefixes)\n  * core: add text emphasis in messages when searching text in buffer, new options: weechat.look.emphasized_attributes, weechat.color.emphasized, weechat.color.emphasized_bg\n  * core: add secured data (encryption of passwords or private data): add new command /secure and new file sec.conf (task #7395)\n  * core: rename binary and man page from \"weechat-curses\" to \"weechat\" (task #11027)\n  * core: add option \"-o\" in command /color\n  * core: add option \"scroll_beyond_end\" for command /window (task #6745)\n  * core: add options weechat.look.hotlist_prefix and weechat.look.hotlist_suffix (task #12730)\n  * core: add option weechat.look.key_bind_safe\n  * core: add option weechat.network.proxy_curl (task #12651)\n  * core: add \"proxy\" infolist and hdata\n  * core: add infolist \"layout\" and hdata \"layout\", \"layout_buffer\" and \"layout_window\"\n  * core: reduce memory used by using shared strings for nicklist and lines in buffers\n  * core: change color format for options weechat.look.buffer_time_format and weechat.look.prefix_{action|error|join|network|quit} from `${xxx}` to `${color:xxx}`\n  * core: optimize the removal of lines in buffers (a lot faster to clear/close buffers with lot of lines)\n  * core: set options weechat.look.color_inactive_{buffer|window} to \"on\" by default\n  * api: return hashtable item pointer in functions hashtable_set and hashtable_set_with_size\n  * api: add \"callback_free_key\" in hashtable\n  * api: add support of colors with format `${color:xxx}` in function string_eval_expression and command /eval\n  * api: add argument \"options\" in function string_eval_expression, add option \"-c\" in command /eval (to evaluate a condition)\n  * api: add new function strlen_screen\n  * aspell: rename option aspell.look.color to aspell.color.misspelled, add option aspell.color.suggestions\n  * aspell: add support of enchant library (patch #6858)\n  * irc: add option irc.look.notice_welcome_redirect to automatically redirect channel welcome notices to the channel buffer\n  * irc: add support of wildcards in commands (de)op/halfop/voice, split IRC message sent if number of nicks is greater than server MODES (from message 005) (task #9221)\n  * irc: add option irc.look.pv_tags\n  * irc: add support of special variables $nick/$channel/$server in commands /allchan and /allserv\n  * irc: add option irc.look.nick_color_hash: hash algorithm to find nick color (patch #8062)\n  * logger: add option \"flush\" in command /logger\n  * plugins: remove the demo plugin\n  * relay: add command \"ping\" in weechat protocol (task #12689)\n  * rmodifier: add option \"missing\" in command /rmodifier\n  * script: add info about things defined by script (like commands, options, ...) in the detailed view of script (/script show)\n  * scripts: add hdata with script callback\n  * xfer: add option xfer.look.pv_tags\n\nBug fixes::\n\n  * core: clear whole line before displaying content instead of clearing after the end of content (bug #40115)\n  * core: fix time displayed in status bar (it was one second late) (bug #40097)\n  * core: fix memory leak on unhook of a print hook (if using tags)\n  * core: fix computation of columns in output of /help (take care about size of time/buffer/prefix)\n  * core: fix random crash on \"/buffer close\" with a buffer number (or a range of buffers)\n  * core: fix priority of logical operators in evaluation of expression (AND takes precedence over the OR) and first evaluate sub-expressions between parentheses\n  * core: remove gap after read marker line when there is no bar on the right (bug #39548)\n  * core: use \"/dev/null\" for stdin in hook_process instead of closing stdin (bug #39538)\n  * core: fix char displayed at the intersection of three windows (bug #39331)\n  * core: fix crash in evaluation of expression when reading a string in hdata with a NULL value (bug #39419)\n  * core: fix display bugs with some UTF-8 chars that truncates messages displayed (for example U+26C4) (bug #39201)\n  * core: remove extra space after empty prefix (when prefix for action, error, join, network or quit is set to empty string) (bug #39218)\n  * core: fix random crash on mouse actions (bug #39094)\n  * core: fix line alignment when option weechat.look.buffer_time_format is set to empty string\n  * api: change type of hashtable key hash to unsigned long\n  * api: use pointer for infolist \"hook\" to return only one hook\n  * aspell: fix detection of word start/end when there are apostrophes or minus chars before/after word\n  * irc: fix reconnection to server using IPv6 (bug #38819, bug #40166)\n  * irc: replace default prefix modes \"qaohvu\" by the standard ones \"ov\" when PREFIX is not sent by server (bug #39802)\n  * irc: use 6697 as default port for SSL servers created with URL \"ircs://\" (bug #39621)\n  * irc: display number of ops/halfops/voices on channel join only for supported modes on server (bug #39582)\n  * irc: fix self nick color in server messages after nick is changed with /nick (bug #39415)\n  * irc: fix error message on /invite without arguments (bug #39272)\n  * irc: fix multiple nicks in command /query (separated by commas): open one buffer per nick\n  * lua: fix interpreter used in API functions (bug #39470)\n  * relay: fix decoding of websocket frames when there are multiple frames in a single message received (only the first one was decoded)\n  * relay: fix binding to an IP address (bug #39119)\n\nDocumentation::\n\n  * update man page and add translations (in French, German, Italian, and Japanese)\n\nBuild::\n\n  * core: add CA_FILE option in CMake and configure to setup default value of option weechat.network.gnutls_ca_file (default is \"/etc/ssl/certs/ca-certificates.crt\") (task #12725)\n  * core: disable build of doc by default, add CMake option ENABLE_MAN to compile man page (off by default)\n  * xfer: fix compilation on OpenBSD (bug #39071)\n\n[[v0.4.1]]\n== Version 0.4.1 (2013-05-20)\n\nNew features::\n\n  * core: make nick prefix/suffix dynamic (not stored in the line): move options irc.look.nick_{prefix|suffix} to weechat.look.nick_{prefix|suffix} and options irc.color.nick_{prefix|suffix} to weechat.color.chat_nick_{prefix|suffix}, add new options weechat.look.prefix_align_more_after, weechat.look.prefix_buffer_align_more_after, logger.file.nick_{prefix|suffix} (bug #37531)\n  * core: add support of multiple layouts (task #11274)\n  * core: add signals nicklist_{group|nick}_removing and hsignals nicklist_{group|nick}_{added|removing|changed}\n  * core: add count for groups, nicks, and total in nicklist\n  * core: add option \"dirs\" in command /debug\n  * core: add signal \"window_opened\" (task #12464)\n  * core: allow read of array in hdata without using index\n  * api: add new function hdata_search\n  * api: add property \"completion_freeze\" for function buffer_set: do not stop completion when command line is updated\n  * aspell: add completion \"aspell_dicts\" (list of aspell installed dictionaries)\n  * aspell: add info \"aspell_dict\" (dictionaries used on a buffer)\n  * aspell: optimization on spellers to improve speed (save state by buffer)\n  * irc: add support of \"dh-aes\" SASL mechanism (patch #8020)\n  * irc: add support of UHNAMES (capability \"userhost-in-names\") (task #9353)\n  * irc: add tag \"irc_nick_back\" for messages displayed in private buffer when a nick is back on server (task #12576)\n  * irc: add option irc.look.display_join_message (task #10895)\n  * irc: add option irc.look.pv_buffer: automatically merge private buffers (optionally by server) (task #11924)\n  * irc: hide passwords in commands or messages sent to nickserv (/msg nickserv) with new modifiers \"irc_command_auth\" and \"irc_message_auth\", remove option irc.look.hide_nickserv_pwd, add option irc.look.nicks_hide_password (bug #38346)\n  * irc: unmask smart filtered join if nick speaks in channel some minutes after the join, new option irc.look.smart_filter_join_unmask (task #12405)\n  * irc: rename option irc.network.lag_disconnect to irc.network.lag_reconnect, value is now a number of seconds\n  * relay: add message \"_nicklist_diff\" (differences between old and current nicklist)\n  * relay: add support of multiple servers on same port for irc protocol (the client must send the server in the \"PASS\" command)\n  * relay: add WebSocket server support (RFC 6455) for irc and weechat protocols, new option relay.network.websocket_allowed_origins\n  * relay: add options \"buffers\" and \"upgrade\" in commands sync/desync (weechat protocol)\n  * rmodifier: rename default rmodifier \"nickserv\" to \"command_auth\" (with new modifier \"irc_command_auth\"), add default rmodifier \"message_auth\" (modifier \"irc_message_auth\")\n  * script: add option script.scripts.autoload, add options \"autoload\", \"noautoload\" and \"toggleautoload\" for command /script, add action \"A\" (kbd:[Alt+a]) on script buffer (toggle autoload) (task #12393)\n  * xfer: add option xfer.file.auto_accept_nicks (patch #7962)\n\nBug fixes::\n\n  * core: fix display of long lines without time (message beginning with two tabs)\n  * core: reset scroll in window before zooming on a merged buffer (bug #38207)\n  * core: fix refresh of item \"completion\": clear it after any action that is changing content of command line and after switch of buffer (bug #38214)\n  * core: fix structures before buffer data when a buffer is closed\n  * core: fix refresh of line after changes with hdata_update (update flag \"displayed\" according to filters)\n  * core: fix hidden lines for messages without date when option weechat.history.max_buffer_lines_minutes is set (bug #38197)\n  * core: use default hash/comparison callback for keys of type integer/pointer/time in hashtable\n  * api: do not display a warning by default when loading a script with a license different from GPL\n  * api: fix connection to servers with hook_connect on macOS (bug #38496)\n  * api: fix bug in function string_match when mask begins and ends with \"*\"\n  * api: allow hashtable with keys that are not strings in function hashtable_add_to_infolist\n  * api: fix function string_mask_to_regex: escape all special chars used in regex (bug #38398)\n  * guile: fix crash in function hdata_move\n  * guile: fix arguments given to callbacks (separate arguments instead of one list with arguments inside), Guile >= 2.0 is now required (bug #38350)\n  * guile: fix crash on calls to callbacks during load of script (bug #38343)\n  * irc: fix name of server buffer after /server rename (set name \"server.name\" instead of \"name\")\n  * irc: fix uncontrolled format string when sending unknown irc commands (if option irc.network.send_unknown_commands is on)\n  * irc: fix uncontrolled format string when sending ison command (for nicks monitored by /notify)\n  * irc: fix refresh of nick in input bar when joining a new channel with op status (bug #38969)\n  * irc: fix display of CTCP messages that contain bold attribute (bug #38895)\n  * irc: fix duplicate nick completion when someone rejoins the channel with same nick but a different case (bug #38841)\n  * irc: fix crash on command \"/allchan /close\"\n  * irc: fix default completion (like nicks) in commands /msg, /notice, /query and /topic\n  * irc: fix prefix color for nick when the prefix is not in irc.color.nick_prefixes: use default color (key \"*\")\n  * irc: fix display of malformed CTCP (without closing char) (bug #38347)\n  * irc: fix memory leak in purge of hashtables with joins (it was done only for the first server in the list)\n  * irc: add color in output of /names when result is on server buffer (channel not joined) (bug #38070)\n  * lua: remove use of functions for API constants\n  * lua: fix crash on stack overflow: call lua_pop for values returned by lua functions (bug #38510)\n  * perl: simplify code to load scripts\n  * python: fix crash when loading scripts with Python 3.x (patch #8044)\n  * relay: fix uncontrolled format string in redirection of irc commands\n  * relay: rename compression \"gzip\" to \"zlib\" (compression is zlib, not gzip)\n  * relay: fix commands sync/desync in weechat protocol (bug #38215)\n  * ruby: fix crash in function hdata_move\n  * ruby: fix crash with Ruby 2.0: use one array for the last 6 arguments of function config_new_option (bug #31050)\n  * script: create \"script\" directory on each action, just in case it has been removed (bug #38472)\n  * scripts: create directories (language and language/autoload) on each action (install/remove/autoload), just in case they have been removed (bug #38473)\n  * scripts: do not allow empty script name in function register\n  * xfer: fix freeze of DCC file received: use non-blocking socket after connection to sender and ensure the ACK is properly sent (bug #38340)\n\nBuild::\n\n  * core: install icon file (patch #7972)\n  * core: fix detection of iconv with CMake on macOS (bug #38321)\n  * guile: fix compilation with Guile 2.0\n  * python: fix detection of Python on Ubuntu Raring\n  * script: fix compilation on GNU/Hurd (patch #7977)\n\n[[v0.4.0]]\n== Version 0.4.0 (2013-01-20)\n\nNew features::\n\n  * core: add buffer pointer in arguments for signals \"input_search\", \"input_text_changed\" and \"input_text_cursor_moved\"\n  * core: add option \"diff\" in command /set (list options with changed value)\n  * core: add color support in options weechat.look.prefix_{action|error|join|network|quit} (task #9555)\n  * core: display default values for changed config options in output of /set\n  * core: add command /eval, use expression in conditions for bars\n  * core: add option \"-quit\" in command /upgrade (save session and quit without restarting WeeChat, for delayed restoration)\n  * core: add incomplete mouse events \"event-down\" and \"event-drag\" (task #11840)\n  * api: allow return code WEECHAT_RC_OK_EAT in callbacks of hook_signal and hook_hsignal (stop sending the signal immediately)\n  * api: allow creation of structure with hdata_update (allowed for hdata \"history\")\n  * api: use hashtable \"options\" for command arguments in function hook_process_hashtable (optional, default is a split of string with command)\n  * api: add new function string_eval_expression\n  * api: connect with IPv6 by default in hook_connect (with fallback to IPv4), shuffle list of hosts for a same address, add argument \"retry\" for hook_connect, move \"sock\" from hook_connect arguments to callback of hook_connect (task #11205)\n  * aspell: add signal \"aspell_suggest\" (sent when new suggestions are displayed)\n  * aspell: add bar items \"aspell_dict\" (dictionary used on current buffer) and \"aspell_suggest\" (suggestions for misspelled word at cursor), add option aspell.check.suggestions (task #12061)\n  * irc: add tags \"irc_nick1_xxx\" and \"irc_nick2_yyy\" in message displayed for command \"NICK\"\n  * irc: return git version in CTCP VERSION and FINGER by default, add \"$git\" and \"$versiongit\" in format of CTCP replies\n  * irc: read local variable \"autorejoin\" in buffer to override server option \"autorejoin\" (task #12256)\n  * irc: add option \"-auto\" in command /connect (task #9340)\n  * irc: add support of \"server-time\" capability (task #12255)\n  * irc: add support of tags in messages\n  * irc: add command /quiet, fix display of messages 728/729 (quiet list, end of quiet list) (task #12278)\n  * irc: add option irc.network.alternate_nick to disable dynamic nick generation when all nicks are already in use on server (task #12281)\n  * irc: add option irc.network.whois_double_nick to double nick in command /whois\n  * irc: add option \"-noswitch\" in command /join (task #12275)\n  * perl: display script filename in error messages\n  * relay: add backlog and server capability \"server-time\" for irc protocol, add new options relay.irc.backlog_max_minutes, relay.irc.backlog_max_number, relay.irc.backlog_since_last_disconnect, relay.irc.backlog_tags, relay.irc.backlog_time_format (task #12076)\n  * relay: add support of IPv6, new option relay.network.ipv6, add support of \"ipv4.\" and/or \"ipv6.\" before protocol name, to force IPv4/IPv6 (task #12270)\n  * xfer: display remote IP address for DCC chat/file (task #12289)\n\nBug fixes::\n\n  * core: fix infinite loop when a regex gives an empty match (bug #38112)\n  * core: fix click in item \"buffer_nicklist\" when nicklist is a root bar (bug #38080)\n  * core: fix line returned when clicking on a bar (according to position and filling) (bug #38069)\n  * core: fix refresh of bars when applying layout (bug #37944, bug #37952)\n  * core: fix scroll to bottom of window (default key: kbd:[Alt+End]) when line displayed is bigger than chat area\n  * core: fix scroll in buffer after enabling/disabling some filters (if scroll is on a hidden line) (bug #37885)\n  * core: fix memory leak in case of error when building content of bar item for display\n  * core: fix detection of command in input: a single command char is considered as a command (API function string_input_for_buffer)\n  * core: search for a fallback template when a no template is matching command arguments\n  * core: fix refresh of windows after split (fix bug with horizontal separator between windows) (bug #37874)\n  * core: fix stuck mouse (bug #36533)\n  * core: fix default mouse buttons actions for script buffer (focus the window before executing action)\n  * core: fix scroll of one page down when weechat.look.scroll_page_percent is less than 100 (bug #37875)\n  * core: disable paste detection and confirmation if bar item \"input_paste\" is not used in a visible bar (task #12327)\n  * core: use high priority (50000) for commands /command and /input so that an alias will not take precedence over these commands (bug #36353)\n  * core: execute command with higher priority when many commands with same name are found with different priorities\n  * core: fix display of combining chars (bug #37775)\n  * core: fix display of zoomed/merged buffer (with number >= 2) after switching to it (bug #37593)\n  * core: fix display problem when option weechat.look.prefix_same_nick is set (problem with nick displayed in first line of screen) (bug #37556)\n  * core: fix wrapping of words with wide chars (the break was made before the correct position)\n  * api: do not call shell to execute command in hook_process (fix security problem when a plugin/script gives untrusted command) (bug #37764)\n  * alias: give higher priority to aliases (2000) so that they take precedence over an existing command\n  * aspell: ignore self and remote nicks in private buffers\n  * aspell: fix creation of spellers when number of dictionaries is different between two buffers\n  * guile: fix bad conversion of shared strings (replace calls to scm_i_string_chars by scm_to_locale_string) (bug #38067)\n  * irc: fix display of actions (/me) when they are received from a relay client (in channel and private buffers) (bug #38027)\n  * irc: fix memory leak when updating modes of channel\n  * irc: fix crash on /upgrade (free channels before server data when a server is destroyed) (bug #37736)\n  * irc: fix crash when decoding IRC colors in strings (bug #37704)\n  * irc: fix refresh of bar item \"away\" after command /away or /disconnect\n  * irc: send whois on self nick when /whois is done without argument on a channel (task #12273)\n  * irc: remove local variable \"away\" in server/channels buffers after server disconnection (bug #37582)\n  * irc: fix crash when message 352 has too few arguments (bug #37513)\n  * irc: remove unneeded server disconnect when server buffer is closed and server is already disconnected\n  * perl: fix calls to callbacks during load of script when multiplicity is disabled (bug #38044)\n  * relay: fix duplicated messages sent to irc clients (when messages are redirected) (bug #37870)\n  * relay: fix memory leak when adding hdata to a message (weechat protocol)\n  * relay: fix crash after /upgrade when a client is connected\n  * relay: add missing \"ssl.\" in output of /relay listrelay\n  * script: fix scroll with mouse when window with script buffer is not the current window (do not force a switch to script buffer in current window)\n  * xfer: fix memory leak when refreshing xfer buffer\n  * xfer: add missing tags in DCC chat messages: nick_xxx, prefix_nick_ccc, logN\n  * xfer: limit bytes received to file size (for DCC file received), fix crash when displaying a xfer file with pos greater than size\n\nBuild::\n\n  * core: add git version in build, display it in \"weechat-curses --help\" and /version\n  * core: stop CMake if gcrypt lib is not found (bug #37671)\n  * guile: fix detection of Guile in configure\n  * script: fix compilation on macOS\n\n[[v0.3.9.2]]\n== Version 0.3.9.2 (2012-11-18)\n\nBug fixes::\n\n  * core: do not call shell to execute command in hook_process (fix security problem when a plugin/script gives untrusted command) (bug #37764, CVE-2012-5534)\n\n[[v0.3.9.1]]\n== Version 0.3.9.1 (2012-11-09)\n\nBug fixes::\n\n  * irc: fix crash when decoding IRC colors in strings (bug #37704, CVE-2012-5854)\n\n[[v0.3.9]]\n== Version 0.3.9 (2012-09-29)\n\nNew features::\n\n  * core: add signals for plugins loaded/unloaded\n  * core: add default key kbd:[Alt+x] (zoom on merged buffer) (task #11029)\n  * core: add mouse bindings kbd:[Ctrl] + wheel up/down to scroll horizontally buffers with free content\n  * core: add option weechat.startup.sys_rlimit to set system resource limits for WeeChat process\n  * core: add option \"swap\" in command /buffer (task #11373)\n  * core: add hdata \"hotlist\"\n  * core: add support of arrays in hdata variables\n  * core: add command line option \"-r\" (or \"--run-command\") to run command(s) after startup of WeeChat\n  * core: add function hook_set in plugin API, add \"subplugin\" in hooks (set by script plugins), display subplugin in /help on commands (task #12049)\n  * core: add option weechat.look.jump_smart_back_to_buffer (jump back to initial buffer after reaching end of hotlist, on by default, which is old behavior)\n  * core: add default key kbd:[Alt+s] (toggle aspell)\n  * core: add callback \"nickcmp\" in buffers\n  * core: add horizontal separator between windows, new options weechat.look.window_separator_{horizontal|vertical}\n  * core: add options weechat.look.color_nick_offline and weechat.color.chat_nick_offline{_highlight|_highlight_bg} to use different color for offline nicks in prefix (task #11109)\n  * api: allow update for some variables of hdata, add new functions hdata_update and hdata_set\n  * api: add info \"locale\" for info_get (locale used to translate messages)\n  * api: add new function util_version_number\n  * aspell: add option aspell.check.enabled, add options enable/disable/toggle for command /aspell (rename options enable/disable/dictlist to setdict/deldict/listdict), display aspell status with /aspell (task #11988)\n  * irc: generate alternate nicks dynamically when all nicks are already in use (task #12209)\n  * irc: add bar item \"buffer_modes\", remove option irc.look.item_channel_modes (task #12022)\n  * irc: add option irc.look.ctcp_time_format to customize reply to CTCP TIME (task #12150)\n  * irc: move options from core to irc plugin: weechat.look.nickmode to irc.look.nick_mode (new type: integer with values: none/prefix/action/both) and weechat.look.nickmode_empty to irc.look.nick_mode_empty\n  * logger: add tags in backlog lines displayed when opening buffer\n  * logger: add messages \"Day changed to\" in backlog (task #12187)\n  * relay: add support of SSL (for irc and weechat protocols), new option relay.network.ssl_cert_key (task #12044)\n  * relay: add option relay.color.client\n  * relay: add object type \"arr\" (array) in WeeChat protocol\n  * script: new plugin \"script\" (script manager, replacing scripts weeget.py and script.pl)\n  * scripts: add signals for scripts loaded/unloaded/installed/removed\n  * scripts: add hdata with list of scripts for each language\n\nBug fixes::\n\n  * core: fix display bug when end of a line is displayed on top of chat (last line truncated and MORE(0) in status bar) (bug #37203)\n  * core: fix IP address returned by hook_connect (return IP really used, not first IP for hostname)\n  * core: display spaces at the end of messages in chat area (bug #37024)\n  * core: fix infinite loop in display when chat area has width of 1 with a bar displayed on the right (nicklist by default) (bug #37089)\n  * core: fix display of \"bar more down\" char when text is truncated by size_max in bars with vertical filling (bug #37054)\n  * core: fix color of long lines (displayed on more than one line on screen) under FreeBSD (bug #36999)\n  * core: return error string to callback of hook_connect if getaddrinfo fails in child process\n  * core: scroll to bottom of window after reaching first or last highlight with keys kbd:[Alt+p] / kbd:[Alt+n]\n  * core: fix refresh of bar items when switching window\n  * core: fix refresh of bar items \"buffer_filter\" and \"scroll\" in root bars (bug #36816)\n  * core: allow again names beginning with \"#\" for bars, proxies and filters\n  * core: escape special chars (`#[\\`) in configuration files for name of options (bug #36584)\n  * aspell: add missing dictionaries (ast/grc/hus/kn/ky)\n  * charset: do not allow \"UTF-8\" in charset decoding options (useless because UTF-8 is the internal WeeChat charset)\n  * fifo: ignore read failing with error EAGAIN (bug #37019)\n  * guile: fix crash when unloading a script without pointer to interpreter\n  * irc: fix rejoin of channels with a key, ignore value \"*\" sent by server for key (bug #24131)\n  * irc: fix SASL mechanism \"external\" (bug #37274)\n  * irc: fix parsing of message 346 when no nick/time are given (bug #37266)\n  * irc: switch to next address after a timeout when connecting to server (bug #37216)\n  * irc: fix bug when changing server option \"addresses\" with less addresses (bug #37215)\n  * irc: add network prefix in irc (dis)connection messages\n  * irc: fix split of received IRC message: keep spaces at the end of message\n  * irc: fix bug with prefix chars which are in chanmodes with a type different from \"B\" (bug #36996)\n  * irc: fix format of message \"USER\" (according to RFC 2812) (bug #36825)\n  * irc: fix parsing of user modes (ignore everything after first space) (bug #36756, bug #31572)\n  * irc: fix freeze when reading on socket with SSL enabled (use non-blocking sockets) (bug #35097)\n  * irc: allow again names beginning with \"#\" for servers\n  * lua: fix crash when unloading a script without pointer to interpreter\n  * python: fix crash when unloading a script without pointer to interpreter\n  * relay: fix freeze when writing on relay socket (use non-blocking sockets in relay for irc and weechat protocols) (bug #36655)\n  * scripts: fix deletion of configuration files when script is unloaded (bug #36977)\n  * scripts: fix function unhook_all: delete only callbacks of hooks and add missing call to unhook\n  * scripts: ignore call to register (with a warning) if script is already registered\n  * xfer: fix DCC transfer error (bug #37432)\n\nDocumentation::\n\n  * add Japanese user's guide (patch #7827), scripting guide and tester's guide\n\nBuild::\n\n  * core: move the set of CMake policy CMP0003 in directory src (so it applies to all plugins) (bug #37311)\n  * core: fix names of cache variables in configure.in (bug #36971)\n  * core: add CMake option \"MANDIR\" (bug #36776)\n  * guile: fix path of Guile include dirs in CMake build (patch #7790)\n  * lua: add support of Lua 5.2\n  * python: fix detection of Python (first try \"python2.x\" and then \"python\") (bug #36835)\n  * ruby: add detection of Ruby 1.9.3\n\n[[v0.3.8]]\n== Version 0.3.8 (2012-06-03)\n\nNew features::\n\n  * core: add option weechat.look.prefix_same_nick (hide or change prefix on messages whose nick is the same as previous message) (task #11965)\n  * core: convert tabs to spaces in text pasted (bug #25028)\n  * core: add a connection timeout for child process in hook_connect (bug #35966)\n  * core: add support of terminal \"bracketed paste mode\", new options weechat.look.paste_bracketed and weechat.look.paste_bracketed_timer_delay (task #11316)\n  * core: support lines of 16 Kb long in configuration files (instead of 1 Kb)\n  * core: convert options weechat.look.prefix_align_more and weechat.look.prefix_buffer_align_more from boolean to string (task #11197)\n  * core: follow symbolic links when writing configuration files (.conf) (task #11779)\n  * api: add list \"gui_buffer_last_displayed\" in hdata \"buffer\"\n  * irc: add option \"fakerecv\" in command /server to simulate a received IRC message (not documented, for debug only)\n  * irc: add option \"-pending\" in command /disconnect (cancel auto-reconnection on servers currently reconnecting) (task #11985)\n  * irc: add signals and tags in messages for irc notify (task #11887)\n  * irc: add support of \"external\" SASL mechanism (task #11864)\n  * irc: allow more than one nick in command /invite\n  * logger: add colors for backlog lines and end of backlog, new options: logger.color.backlog_line and logger.color.backlog_end (task #11966)\n  * relay: add signals \"upgrade\" and \"upgrade_ended\" in WeeChat protocol\n  * relay: add \"date_printed\" and \"highlight\" in signal \"_buffer_line_added\" (WeeChat protocol)\n  * rmodifier: add default rmodifier \"quote_pass\" to hide password in command \"/quote pass\" (bug #36250)\n  * rmodifier: add default rmodifier \"server\" to hide passwords in commands /server and /connect (task #11993)\n  * rmodifier: add option \"release\" in default rmodifier \"nickserv\" (used to hide passwords in command \"/msg nickserv\") (bug #35705)\n\nBug fixes::\n\n  * core: fix crash in focus hook for nicklist (bug #36271)\n  * core: fix truncated configuration files (zero-length) after system crash (bug #36383)\n  * core: fix display bugs and crashes with small windows (bug #36107)\n  * core: fix display bug with prefix when length is greater than max and prefix is ending with a wide char (bug #36032)\n  * core: fix lost scroll when switching to a buffer with a pending search\n  * core: fix display of wide chars on last column of chat area (patch #7733)\n  * api: display warning in scripts when invalid pointers (malformed strings) are given to plugin API functions (warning displayed if debug for plugin is >= 1)\n  * scripts: fix type of argument \"rc\" in callback of hook_process (from string to integer)\n  * guile: fix crash on ARM when loading guile plugin (bug #36479)\n  * guile: add missing function hook_process_hashtable in API\n  * irc: update channel modes by using chanmodes from message 005 (do not send extra command \"MODE\" to server), fix parsing of modes (bug #36215)\n  * irc: hide everything after \"identify\" or \"register\" in messages to nickserv when option irc.look.hide_nickserv_pwd is on (bug #36362)\n  * irc: set user modes only if target nick is self nick in message 221 (patch #7754)\n  * irc: force the clear of nicklist when joining a channel (nicklist was not sync after znc reconnection) (bug #36008)\n  * irc: do not send command \"MODE #channel\" on manual /names (do it only when names are received on join of channel) (bug #35930)\n  * irc: do not allow the creation of two servers with same name but different case (fix error when writing file irc.conf) (bug #35840)\n  * irc: update away flag for nicks on manual /who\n  * irc: display privmsg messages to \"@#channel\" and \"+#channel\" in channel buffer (bug #35331)\n  * irc: fix redirection of message when message is queued for sending on server\n  * irc: check notify immediately when adding a nick to notify list, improve first notify message for a nick (bug #35731)\n  * irc: fix display of color in hostname (join/part/quit messages)\n  * irc: compute hash to find nick color for nick in server message when nick is not in nicklist\n  * irc: close server buffer when server is deleted\n  * irc: add search for lower case nicks in option irc.look.nick_color_force\n  * logger: fix charset of lines displayed in backlog when terminal charset is different from UTF-8 (bug #36379)\n  * perl: fix crash on quit on macOS\n  * relay: keep spaces in beginning of \"input\" received from client (WeeChat protocol)\n  * relay: fix crash on /upgrade when client is connected using WeeChat protocol\n  * relay: redirect some irc messages from clients to hide output (messages: mode, ison, list, names, topic, who, whois, whowas, time, userhost) (bug #33516)\n  * tcl: add missing function hdata_char in API\n  * tcl: fix pointer sent to function hook_signal_send when type of data is a pointer\n\nDocumentation::\n\n  * add Japanese FAQ (patch #7781)\n\nBuild::\n\n  * perl: fix compilation on macOS (bug #30701)\n\n[[v0.3.7]]\n== Version 0.3.7 (2012-02-26)\n\nNew features::\n\n  * core: add support of flags in regular expressions and highlight options\n  * core: add type \"hashtable\" for hdata\n  * core: add signals \"buffer_line_added\" and \"window_switch\"\n  * core: add default keys kbd:[Ctrl+Left] / kbd:[Ctrl+Right] (`meta2-1;5D` / `meta2-1;5C`) for gnome-terminal\n  * core: add option \"hooks\" in command /debug\n  * core: add option weechat.look.scroll_bottom_after_switch (if enabled, restore old behavior before fix of bug #25555 in version 0.3.5)\n  * core: add new option weechat.completion.base_word_until_cursor: allow completion in middle of words (enabled by default) (task #9771)\n  * core: add option \"jump_last_buffer_displayed\" in command /input (key: kbd:[Alt+/]) (task #11553)\n  * core: add option weechat.history.max_buffer_lines_minutes: maximum number of minutes in history per buffer (task #10900), rename option weechat.history.max_lines to weechat.history.max_buffer_lines_number\n  * core: add optional arguments for command /plugin load/reload/autoload\n  * core: use extended regex in filters (task #9497, patch #7616)\n  * api: add modifier \"input_text_for_buffer\" (bug #35317)\n  * api: add support of URL in hook_process / hook_process_hashtable (task #10247)\n  * api: add new functions strcasecmp_range, strncasecmp_range, string_regex_flags, string_regcomp, hashtable_map_string, hook_process_hashtable, hdata_check_pointer, hdata_char, hdata_hashtable and nicklist_get_next_item\n  * alias: add default alias /umode => /mode $nick\n  * irc: add option \"capabilities\" in servers to enable client capabilities on connection\n  * irc: add signal \"irc_server_opened\"\n  * irc: add signal \"xxx,irc_out1_yyy\" and modifier \"irc_out1_xxx\" (outgoing message before automatic split to fit in 512 bytes)\n  * irc: add alias \"ctcp\" for target buffer of CTCP messages\n  * irc: add options irc.look.highlight_{server|channel|pv} to customize or disable default nick highlight (task #11128)\n  * irc: use redirection to get channel modes after update of modes on channel, display output of /mode #channel, allow /mode without argument (display modes of current channel or user modes on server buffer)\n  * irc: add optional server in info \"irc_is_channel\" (before channel name) (bug #35124), add optional server in info_hashtable \"irc_message_parse\"\n  * irc: add case insensitive string comparison based on casemapping of server (rfc1459, strict-rfc1459, ascii) (bug #34239)\n  * irc: add option irc.color.mirc_remap to remap mirc colors in messages to WeeChat colors\n  * irc: allow URL \"irc://\" in command /connect\n  * irc: use extended regex in commands /ignore and /list\n  * guile: new script plugin for scheme (task #7289)\n  * python: add support of Python 3.x (task #11704)\n  * relay: add WeeChat protocol for remote GUI\n  * xfer: display origin of xfer in core and xfer buffers (task #10956)\n\nInternationalization::\n\n  * add Japanese translations\n\nBug fixes::\n\n  * core: fix expand of path `~` to home of user in function string_expand_home (`~/xxx` was OK, but not `~`)\n  * core: fix memory leak when closing buffer\n  * core: fix memory leak in function util_search_full_lib_name\n  * core: automatically add newline char after last pasted line (when pasting many lines with confirmation) (task #10703)\n  * core: fix bug with layout: assign layout number in buffers when doing /layout save\n  * core: do not auto add space after nick completer if option weechat.completion.nick_add_space is off\n  * core: fix signal \"buffer_switch\": send it only once when switching buffer (bug #31158)\n  * core: move option \"scroll_unread\" from command /input to /window\n  * core: save current mouse state in option weechat.look.mouse (set option when mouse state is changed with command /mouse)\n  * core: apply filters after full reload of configuration files (with /reload) (bug #31182)\n  * core: allow list for option weechat.plugin.extension (makes weechat.conf portable across Un*x and Windows) (task #11479)\n  * core: display error in command /buffer if arguments are wrong (bug #34180)\n  * core: fix help on plugin option when config_set_desc_plugin is called to set help on newly created option\n  * core: enable background process under Cygwin to connect to servers, fix reconnection problem (bug #34626)\n  * aspell: fix URL detection (do not check spelling of URLs) (bug #34040)\n  * irc: fix memory leak in SASL/blowfish authentication\n  * irc: fix memory leak when a server is deleted\n  * irc: fix self-highlight when using /me with an IRC bouncer like znc (bug #35123)\n  * irc: use low priority for MODE sent automatically by WeeChat (when joining channel)\n  * irc: do not use option irc.look.nick_color_stop_chars for forced nick colors (bug #33480)\n  * irc: reset read marker of current buffer on manual /join\n  * irc: fix crash when signon time in message 317 (whois, idle) is invalid (too large) (bug #34905)\n  * irc: do not delete servers added in irc.conf on /reload (bug #34872)\n  * irc: remove autorejoin on channels when disconnected from server (bug #32207)\n  * irc: display messages kick/kill/mode/topic even if nick is ignored (bug #34853)\n  * irc: display channel voice notices received in channel buffer (bug #34762), display channel/op notices sent in channel buffer\n  * irc: auto-connect to servers created with \"irc://\" on command line but not other servers if \"-a\" (\"--no-connect\") is given\n  * perl: increment count of hash returned by API (fix crash when script tries to read hash without making a copy)\n  * relay: do not create relay if there is a problem with socket creation (bug #35345)\n  * ruby: fix crash when reloading ruby plugin (bug #34474)\n\nDocumentation::\n\n  * add developer's guide (task #5416)\n\nBuild::\n\n  * core: add library \"pthread\" in CMake file for link on OpenBSD\n  * core: add WEECHAT_HOME option in CMake and configure to setup default WeeChat home (default is \"~/.weechat\") (task #11266)\n  * core: fix compilation under OpenBSD 5.0 (lib utf8 not needed any more) (bug #34727)\n  * core: fix compilation error with \"pid_t\" on macOS (bug #34639)\n\n[[v0.3.6]]\n== Version 0.3.6 (2011-10-22)\n\nNew features::\n\n  * core: add color attribute \"|\" (keep attributes) and value \"resetcolor\" for function color in plugin API (used by irc plugin to keep bold/reverse/underlined in message when changing color) (bug #34550)\n  * core: add new option weechat.look.color_basic_force_bold, off by default: bold is used only if terminal has less than 16 colors (patch #7621)\n  * core: add default key kbd:[F5] (`meta2-[E`) for Linux console\n  * core: add \"inactive\" colors for inactive windows and lines in merged buffers, new options: weechat.look.color_inactive_window, weechat.look.color_inactive_buffer, weechat.look.color_inactive_message, weechat.look.color_inactive_prefix, weechat.look.color_inactive_prefix_buffer, weechat.look.color_inactive_time, weechat.color.chat_inactive_line, weechat.color.chat_inactive_window, weechat.color.chat_prefix_buffer_inactive_line\n  * core: do automatic zoom on current window when terminal becomes too small for windows\n  * core: add new options weechat.look.bar_more_left/right/up/down\n  * core: add new option weechat.look.item_buffer_filter\n  * core: allow name of buffer for command /buffer clear (task #11269)\n  * core: add new command /repeat (execute a command several times)\n  * core: save and restore layout for buffers and windows on /upgrade\n  * core: add option \"-all\" in command \"/buffer unmerge\"\n  * core: add number in windows (add optional argument \"-window\" so some actions for command /window)\n  * core: allow buffer name in /buffer close\n  * core: add support of mouse: new command /mouse, new key context \"mouse\", new options weechat.look.mouse and weechat.look.mouse_timer_delay (task #5435)\n  * core: add command /cursor (free movement of cursor on screen), with key context \"cursor\"\n  * core: automatic scroll direction in /bar scroll (x/y is now optional)\n  * core: add optional delay for key grab (commands /input grab_key and /input grab_key_command, default is 500 milliseconds)\n  * core: allow plugin name in command \"/buffer name\"\n  * core: add context \"search\" for keys (to define keys used during search in buffer with kbd:[Ctrl+r])\n  * core: add new option weechat.look.separator_vertical, rename option weechat.look.hline_char to weechat.look.separator_horizontal\n  * core: add local variable \"highlight_regex\" in buffers\n  * core: add \"hdata\" (direct access to WeeChat/plugin data)\n  * core: add option weechat.look.eat_newline_glitch (do not add new line at end of each line displayed)\n  * core: add options \"infolists\", \"hdata\" and \"tags\" for command /debug\n  * core: add horizontal scrolling for buffers with free content (command /window scroll_horiz) (task #11112)\n  * core: change default value of option weechat.network.gnutls_ca_file to \"/etc/ssl/certs/ca-certificates.crt\"\n  * api: add info \"cursor_mode\"\n  * api: add new functions key_bind, key_unbind, hook_focus, hdata_new, hdata_new_var, hdata_new_list, hdata_get, hdata_get_var_offset, hdata_get_var_type, hdata_get_var_type_string, hdata_get_var_hdata, hdata_get_var, hdata_get_var_at_offset, hdata_get_list, hdata_move, hdata_integer, hdata_string, hdata_pointer, hdata_time, hdata_get_string\n  * irc: allow reason for command /disconnect\n  * irc: allow server name for commands /die and /restart\n  * irc: add new info_hashtable \"irc_message_split\"\n  * irc: add prefix \"#\" for all channels on join (if no prefix given)\n  * irc: improve split of privmsg message (keep ctcp), add split of ison, join, notice, wallops, 005, 353 (bug #29879, bug #33448, bug #33592)\n  * logger: add option logger.file.flush_delay (task #11118)\n\nBug fixes::\n\n  * core: fix freeze when calling function util_file_get_content with a directory instead of a filename\n  * core: display timeout for hook_process command only if debug for core is enabled (task #11401)\n  * core: bufferize lines displayed before core buffer is created, to display them in buffer when it is created\n  * core: fix display of background color in chat area after line feed\n  * core: fix paste detection (problem with end of lines)\n  * core: fix display of paste multi-line prompt with a root input bar (bug #34305)\n  * core: replace deprecated GnuTLS function gnutls_certificate_client_set_retrieve_function by new function gnutls_certificate_set_retrieve_function (GnuTLS >= 2.11.0)\n  * core: use dynamic buffer size for calls to vsnprintf\n  * core: fix memory leak in unhook of hook_connect\n  * core: fix memory leak in display of empty bar items\n  * core: fix input of wide UTF-8 chars under Cygwin (bug #34061)\n  * core: fix bugs with automatic layout (bug #26110), add support of merged buffers in layout (task #10893)\n  * core: fix crash when invalid UTF-8 chars are inserted in command line (bug #33471)\n  * core: stop horizontal bar scroll at the end of content (for bars with horizontal filling) (bug #27908)\n  * core: fix crash when building hashtable string with keys and values\n  * core: replace buffer name by window number in /bar scroll\n  * core: fix bugs with key \"^\" (bug #32072, bug #21381)\n  * core: fix bugs with bar windows: do not create bar windows for hidden bars\n  * core: fix completion bug when two words for completion are equal but with different case\n  * core: fix completion for command arguments when same command exists in many plugins (bug #33753)\n  * core: fix freeze when hook_fd is called with a bad file/socket (bug #33619)\n  * core: fix bug with option weechat.look.hotlist_count_max (value+1 was used)\n  * api: use arguments for infolist \"window\" to return only one window by number\n  * api: fix bug with function config_set_desc_plugin (use immediately description for option when function is called)\n  * scripts: fix crash with scripts not auto-loaded having a buffer opened after /upgrade (input/close callbacks for buffer not set properly)\n  * irc: fix display of items \"away\" and \"lag\" in root bars, refresh all irc bar items on signal \"buffer_switch\" (bug #34466)\n  * irc: fix crash on malformed irc notice received (without message after target)\n  * irc: add missing messages for whois: 223, 264, 343\n  * irc: use high priority queue for sending modes and wallchops messages\n  * irc: rename info_hashtable \"irc_parse_message\" to \"irc_message_parse\"\n  * irc: use color \"default\" for any invalid color in option weechat.color.chat_nick_colors\n  * irc: send WHO command to check away nicks only if channel was not parted\n  * irc: fix crash when malformed IRC message 352 (WHO) is received (bug #33790)\n  * irc: fix crash when command \"/buffer close\" is used in a server command to close server buffer during connection (bug #33763)\n  * irc: fix crash when /join command is executed on a non-irc buffer (bug #33742)\n  * irc: fix bug with comma in irc color code: do not strip comma if it is not followed by a digit (bug #33662)\n  * irc: switch to buffer on /join #channel if channel buffer already exists\n  * irc: set host for nick on each channel message and nick change (if not already set)\n  * irc: update host of nicks on manual /who\n  * irc: fix memory leak on plugin unload (free ignores)\n  * irc: fix memory leak in message parser (when called from other plugins like relay) (bug #33387)\n  * relay: fix bug with self nick when someone changes its nick on channel (bug #33739)\n  * relay: fix memory leak (free some parsed messages) (bug #33387)\n  * relay: fix memory leak on plugin load (free raw messages)\n  * perl: replace calls to SvPV by SvPV_nolen (patch #7436)\n\nBuild::\n\n  * core: fix compilation error (INSTALLPREFIX undeclared) on macOS and when compiling with included gettext (bug #26690)\n\n[[v0.3.5]]\n== Version 0.3.5 (2011-05-15)\n\nNew features::\n\n  * core: add buffer to hotlist if away is set on buffer (even if buffer is displayed), new option weechat.look.hotlist_add_buffer_if_away (task #10948)\n  * core: add option \"balance\" in command /window (key: kbd:[Alt+w], kbd:[Alt+b])\n  * core: add option \"swap\" in command /window (key: kbd:[Alt+w], kbd:[Alt+s]) (task #11001)\n  * core: add option weechat.look.hotlist_buffer_separator\n  * core: add messages counts in hotlist for each buffer, new options: weechat.look.hotlist_count_max, weechat.look.hotlist_count_min_msg and weechat.color.status_count_{msg|private|highlight|other}\n  * core: add tag \"notify_none\" (line with this tag will not update hotlist)\n  * core: add optional bar name in command \"/bar default\"\n  * core: add new option weechat.look.highlight_tags (force highlight on tags)\n  * core: allow list of buffers in command /filter (exclusion with prefix \"!\") (task #10880)\n  * core: allow relative size for command /window resize\n  * core: add some default keys for gnome-terminal (kbd:[Home] / kbd:[End], kbd:[Ctrl+Up] / kbd:[Ctrl+Down], kbd:[Alt+PgUp] / kbd:[Alt+PgDn])\n  * core: add option \"memory\" in command /debug\n  * core: add option weechat.look.read_marker_string\n  * core: add some chars after cursor when scrolling input line: new option weechat.look.input_cursor_scroll (bug #21391)\n  * core: add color \"gray\"\n  * core: add attributes for colors (\"*\": bold, \"!\": reverse, \"_\": underline)\n  * core: dynamically allocate color pairs (extended colors can be used without being added with command \"/color\"), auto reset of color pairs with option weechat.look.color_pairs_auto_reset\n  * core: allow background for nick colors (using \":\")\n  * core: remember scroll position for all buffers in windows (bug #25555)\n  * core: improve display of commands lists in /help (add arguments -list and -listfull) (task #10299)\n  * core: improve arguments displayed in /help of commands\n  * api: add new function config_set_desc_plugin (task #10925)\n  * api: add new functions buffer_match_list and window_search_with_buffer\n  * aspell: add section \"option\" in aspell.conf for speller options (task #11083)\n  * irc: add new options irc.color.topic_old and irc.color.topic_new\n  * irc: add option \"ssl_priorities\" in servers (task #10106, debian #624055)\n  * irc: add modifier \"irc_in2_xxx\" (called after charset decoding)\n  * irc: add new options irc.look.buffer_switch_autojoin and irc.look.buffer_switch_join (task #8542, task #10506)\n  * irc: add new option irc.look.smart_filter_nick\n  * irc: add new options irc.look.color_nicks_in_nicklist and irc.look.color_nicks_in_names\n  * irc: replace options irc.color.nick_prefix_{op|halfop|voice|user} by a single option irc.color.nick_prefixes (task #10888)\n\nBug fixes::\n\n  * core: fix scroll in windows with /window scroll (skip lines \"Day changed to\")\n  * core: recalculate buffer_max_length when buffer short name is changed (patch #7441)\n  * core: do not update hotlist during upgrade\n  * core: apply new value of option weechat.look.buffer_notify_default to all opened buffers\n  * core: prohibit names beginning with \"#\" for bars, proxies, filters and IRC servers (bug #33020)\n  * core: create default bars only if no bar is defined in configuration file\n  * core: fix bug with repeat of last completion (\"%*\"), which failed when many templates are used in completion\n  * core: reload file with certificate authorities when option weechat.network.gnutls_ca_file is changed\n  * core: rebuild bar content when items are changed in an hidden bar\n  * core: fix verification of SSL certificates by calling GnuTLS verify callback (patch #7459, CVE-2011-1428)\n  * core: fix crash when using column filling in bars with some empty items (bug #32565)\n  * core: fix terminal title when $TERM starts with \"screen\"\n  * plugins: fix memory leaks when setting buffer callbacks after /upgrade (plugins: irc, relay, xfer, scripts)\n  * aspell: fix spellers used after switch of window (bug #32811)\n  * irc: fix parsing of message 332 when no topic neither colon are found (bug with bip proxy)\n  * irc: fix nick color in private when option irc.look.nick_color_force is changed\n  * irc: fix tags for messages sent with /msg command (bug #33169)\n  * irc: fix memory leak when copying or renaming server\n  * irc: do not rejoin channels where /part has been issued before reconnection to server (bug #33029)\n  * irc: use nick color for users outside the channel\n  * irc: update short name of server buffer when server is renamed\n  * irc: fix local variable \"away\" on server buffer (set/delete it each time away is set or removed on server)\n  * irc: ignore join if nick is not self nick and if channel buffer does not exist (bug #32667)\n  * irc: fix crash when setting wrong value in option irc.server.xxx.sasl_mechanism (bug #32670)\n  * irc: fix crash when completing /part command on a non-irc buffer (bug #32402)\n  * irc: add many missing commands for target buffer (options irc.msgbuffer.xxx) (bug #32216)\n  * lua: fix crash when many scripts are executing callbacks at same time\n  * perl: fix memory leak when calling Perl functions (bug #32895)\n  * relay: fix crash on /upgrade when nick in irc client is not yet set\n  * relay: allow colon in server password received from client\n  * relay: do not send join for private buffers to client\n  * rmodifier: fix reload of file rmodifier.conf\n  * rmodifier: fix crash when adding rmodifier with invalid regex\n  * xfer: do not close chat buffers when removing xfer from list (bug #32271)\n\nBuild::\n\n  * tcl: fix Tcl detection on some 64-bits systems (bug #32915)\n\n[[v0.3.4]]\n== Version 0.3.4 (2011-01-16)\n\nNew features::\n\n  * core: add 256 colors support, new command /color, new section \"palette\" in weechat.conf (task #6834)\n  * core: add info \"weechat_upgrading\", signal \"upgrade_ended\", display duration of upgrade\n  * core: add new option weechat.look.highlight_regex and function string_has_highlight_regex in plugin API (task #10321)\n  * core: add new option weechat.look.hotlist_unique_numbers (task #10691)\n  * core: add property \"hotlist_max_level_nicks\" in buffers to set max hotlist level for some nicks in buffer\n  * core: add new options weechat.look.input_share and weechat.look.input_share_overwrite (task #9228)\n  * core: add new option weechat.look.prefix_align_min (task #10650)\n  * core: replace the 10 nick color options and number of nick colors by a single option weechat.color.chat_nick_colors (comma separated list of colors)\n  * core: add color support in option weechat.look.buffer_time_format\n  * api: add priority for hooks (task #10550)\n  * api: add new functions: list_search_pos, list_casesearch_pos, hashtable_get_string, hashtable_set_pointer, hook_info_hashtable, info_get_hashtable, hook_hsignal, hook_hsignal_send, hook_completion_get_string, nicklist_group_get_integer, nicklist_group_get_string, nicklist_group_get_pointer, nicklist_group_set, nicklist_nick_get_integer, nicklist_nick_get_string, nicklist_nick_get_pointer, nicklist_nick_set\n  * irc: add option \"-server\" in command /join (task #10837)\n  * irc: add option \"-switch\" in commands /connect and /reconnect\n  * irc: add command /notify, new options irc.look.notify_tags_ison, irc.look.notify_tags_whois, irc.network.notify_check_ison, irc.network.notify_check_whois, new option \"notify\" in servers, new infolist \"irc_notify\" (task #5441)\n  * irc: add new option irc.look.nick_color_force (task #7374)\n  * irc: add command redirection with hsignals irc_redirect_pattern and irc_redirect_command (task #6703)\n  * irc: add new options irc.color.nick_prefix and irc.color.nick_suffix\n  * irc: add new option irc.look.item_away_message\n  * irc: add tag \"nick_xxx\" in user messages\n  * irc: move options from network section to server section: connection_timeout, anti_flood_prio_high, anti_flood_prio_low, away_check, away_check_max_nicks, default_msg_part, default_msg_quit (task #10664, task #10668)\n  * irc: display old channel topic when topic is unset (task #9780)\n  * irc: add new info_hashtable \"irc_parse_message\"\n  * irc: add signal \"irc_input_send\"\n  * irc: rename options irc.look.open_channel_near_server and irc.look.open_pv_near_server to irc.look.new_channel_position and irc.look.new_pv_position with new values (none, next or near_server)\n  * rmodifier: new plugin \"rmodifier\": alter modifier strings with regular expressions (bug #26964)\n  * relay: beta version of IRC proxy, now relay plugin is compiled by default\n  * python: add info \"python2_bin\" (path to Python 2.x interpreter)\n\nBug fixes::\n\n  * core: fix scroll problem on buffers with free content and non-allocated lines (bug #32039)\n  * core: call to function hook_config when config option is created\n  * core: fix infinite loop on GnuTLS handshake when connecting with SSL to server on wrong port or server with SSL problems (bug #27487)\n  * core: fix data sent to callback of hook_process (some data was sometimes missing), use a 64KB buffer for child output and send data to callback only when buffer is full\n  * core: fix crash when displaying groups in buffer nicklist\n  * core: fix bug with message \"day changed to\", sometimes displayed several times wrongly\n  * core: fix default value of bar items options (bug #31422)\n  * core: fix bug with buffer name in \"/bar scroll\" command\n  * core: optimize incremental search in buffer: do not search any more when chars are added to a text not found (bug #31167)\n  * core: fix memory leaks when removing item in hashtable and when setting highlight words in buffer\n  * core: use similar behavior for keys bound to local or global history (bug #30759)\n  * alias: complete with alias value for second argument of command /alias\n  * irc: differentiate notices from messages in private buffer (bug #31980)\n  * irc: update nick modes with message 221 (bug #32038)\n  * irc: fix bug with charset decoding on private buffers (decoding was made for local nick instead of remote nick) (bug #31890)\n  * irc: allow command /reconnect on servers that are not currently connected (bug #30726)\n  * irc: fix topic completion in command /topic when channel topic starts with channel name\n  * irc: improve nick prefixes, all modes (even unknown) are used with PREFIX value from message 005\n  * irc: fix crash/bug when option \"addresses\" for a server is unset or changed when WeeChat is connected to this server (bug #31268)\n  * irc: switch to next server address when IRC error is received after TCP connection but before message 001 (bug #30884)\n  * irc: fix bug with hostmasks in command /ignore (bug #30716)\n  * relay: split of messages sent to clients of irc proxy\n  * scripts: add missing function infolist_reset_item_cursor in API (bug #31057)\n  * lua: fix crash when unloading script\n  * xfer: fix dcc chat buffer name (use irc server in name) (bug #29925)\n  * xfer: fix dcc file transfer for large files (more than 4 GB) on 32-bit systems (bug #31531)\n  * xfer: fix bug at end of file sent, sometimes transfer is still active although file was successfully sent\n\nBuild::\n\n  * core: add support of Python 2.7 in CMake and configure (debian #606989)\n  * ruby: fix compilation with Ruby 1.9.2 (patch #7316)\n\n[[v0.3.3]]\n== Version 0.3.3 (2010-08-07)\n\nNew features::\n\n  * core: use \"!\" to reverse a regex in a filter (to keep lines matching regex and hide other lines) (task #10032)\n  * core: add keys for undo/redo changes on command line (default: kbd:[Ctrl+pass:none[_]] and kbd:[Alt+pass:none[_]]) (task #9483)\n  * core: add new option weechat.look.align_end_of_lines\n  * core: add new option weechat.look.confirm_quit\n  * core: add new option weechat.color.status_name_ssl (task #10339)\n  * core: add hashtables with new functions in plugin API\n  * api: add function string_expand_home, fix bug with replacement of home in paths\n  * irc: add new option irc.look.nick_color_stop_chars\n  * irc: add new options irc.look.display_host_join/join_local/quit and irc.color.reason_quit\n  * irc: add command /wallchops, fix bug with display of notice for ops (task #10021, bug #29932)\n  * irc: add isupport value in servers (content of IRC message 005), with new infos: irc_server_isupport and irc_server_isupport_value\n  * irc: add message in private buffer when nick is back on server after a /quit\n  * irc: add new options irc.network.autoreconnect_delay_growing and irc.network.autoreconnect_delay_max (task #10338)\n  * irc: add missing commands 346, 347 (channel invite list)\n  * irc: improve lag indicator: two colors (counting and finished), update item even when pong has not been received, lag_min_show is now in milliseconds\n  * irc: move options weechat.color.nicklist_prefix to irc plugin\n  * logger: use tag \"no_log\" to prevent a line from being written in log file\n\nBug fixes::\n\n  * core: fix bug with scroll_unread: do not scroll to a filtered line (bug #29991)\n  * core: fix crash with hook_process (when timer is called on a deleted hook process)\n  * core: fix display bug with special chars (ascii value below 32) (bug #30602)\n  * core: fix display bug with attributes like underlined in bars (bug #29889)\n  * api: fix bug with replacement char in function string_remove_color (bug #30296)\n  * irc: fix bug in parser when no argument is received after command, no callback was called, and message was silently ignored (bug #30640)\n  * irc: fix import of certificates created by OpenSSL >= 1.0.0 (bug #30316)\n  * irc: fix display of local SSL certificate when it is sent to server (patch #7218)\n  * irc: use empty real name by default in config, instead of reading real name in /etc/passwd (bug #30111)\n  * irc: fix bug with command line option \"irc://\" (bug #29990), new format for port and channels\n  * irc: fix display of messages 330 and 333 on some servers\n  * irc: fix bug with nick prefix \"*\" (chan founder) on some IRC servers (bug #29890)\n  * irc: fix bug with option irc.network.lag_check when value is 0 (zero)\n  * irc: try other nick when connecting to server and receiving message 437 (nick unavailable)\n  * irc: set buffer local variable \"away\" when opening new channel (bug #29618)\n  * fifo: fix bug with fifo pipe when setting fifo option to \"on\"\n  * xfer: fix bug with double quotes in DCC filenames (bug #30471)\n\n[[v0.3.2]]\n== Version 0.3.2 (2010-04-18)\n\nNew features::\n\n  * core: add new options for command /key: listdefault, listdiff and reset\n  * core: add new command /mute\n  * core: add command line option \"-s\" (or \"--no-script\") to start WeeChat without loading any script\n  * core: improve plugins autoload (option weechat.plugin.autoload): allow to use \"*\" as wildcard and \"!\" to prevent a plugin from being autoloaded (task #6361)\n  * core: add option \"switch_active_buffer_previous\" in command /input (task #10141)\n  * core: add new option weechat.look.time_format to customize default format for date/time displayed (localized date by default), add function util_get_time_string in plugin API (patch #6914)\n  * core: add new option weechat.look.command_chars, add functions string_is_command_char and string_input_for_buffer in plugin and script API\n  * core: add new option weechat.look.read_marker_always_show\n  * api: add \"version_number\" for function info_get to get WeeChat version as number\n  * api: add \"irc_is_nick\" for function info_get to check if a string is a valid IRC nick name (patch #7133)\n  * api: add functions string_encode_base64 and string_decode_base64, fix bug with base64 encoding\n  * api: add functions string_match, string_has_highlight and string_mask_to_regex in script plugin API\n  * api: add description of arguments for functions hook_info and hook_infolist\n  * api: add signals \"day_changed\", \"nicklist_group_added/removed\", \"nicklist_nick_added/removed\"\n  * alias: add custom completion for aliases (task #9479)\n  * scripts: allow script commands to reload only one script\n  * irc: add SASL authentication, with PLAIN and DH-BLOWFISH mechanisms (task #8829)\n  * irc: add new option irc.look.part_closes_buffer to close buffer when /part is issued on channel (task #10295)\n  * irc: add option \"-open\" in command /connect\n  * irc: add option irc.network.connection_timeout (timeout between TCP connection to server and reception of message 001)\n  * irc: add options irc.look.smart_filter_join and irc.look.smart_filter_quit\n  * irc: add option irc.look.item_channel_modes_hide_key to hide channel key in channel modes (bug #23961)\n  * irc: add option irc.look.item_nick_prefix\n  * irc: add command /map\n  * irc: add missing commands 276, 343\n  * logger: allow date format in logger options path and mask (task #9430)\n  * xfer: add signal \"xfer_ended\" (patch #7081)\n\nBug fixes::\n\n  * core: remove unneeded space after time on each line if option weechat.look.buffer_time_format is set to empty value (bug #28751)\n  * core: use arguments for infolist \"nicklist\" to return only one nick or group\n  * core: fix bug with writing of configuration files when disk is full (bug #29331)\n  * core: fix infinite loop with /layout apply and bug when applying layout, sometimes many /layout apply were needed (bug #26110)\n  * gui: refresh screen when exiting WeeChat (to display messages printed after /quit)\n  * gui: fix bug with global history, reset pointer to last entry after each user input (bug #28754)\n  * gui: fix bug with bar background after text with background color (bug #28157)\n  * gui: fix bug with cursor when position is last char of terminal\n  * api: add missing infos in functions buffer_get_{integer|string} and in buffer infolist\n  * api: fix function color in Lua script API\n  * api: fix \"inactivity\" value when no key has been pressed since WeeChat started (bug #28930)\n  * api: return absolute path for info_get of \"weechat_dir\" (bug #27936)\n  * scripts: fix bug with callbacks when loading a script already loaded\n  * perl: fix crash when multiplicity is disabled\n  * perl: fix crash when callbacks are called during script initialization (bug #29018)\n  * perl: fix crash on /quit or unload of plugin under FreeBSD and Cygwin (bug #29467)\n  * perl: fix bug with script filename when multiplicity is disabled (bug #29530)\n  * irc: fix crash with SSL connection if option ssl_cert is set (bug #28752)\n  * irc: fix bug with SSL connection (fails sometimes when ssl_verify is on) (bug #28741)\n  * irc: fix bug with nicks on reconnection: try all nicks in list, even if nick used was not the first in list of nicks\n  * irc: fix command /list: send channel and server name given as argument, and use separate option \"-re\" to allow a regex\n  * irc: fix PART message received on Undernet server (bug #28825)\n  * irc: fix bug with /away -all: set or unset future away for disconnected servers (bug #29022)\n  * irc: fix bug with prefix \"!\" for mode \"a\" (channel admin) (bug #29109)\n  * irc: do not send signals \"irc_in\" and \"irc_in2\" when messages are ignored, add new signals \"irc_raw_in\" and \"irc_raw_in2\"\n  * irc: apply smart filter only on channels, not private buffers (bug #28841)\n  * xfer: fix crash when purging old xfer chats (bug #28764)\n\nBuild::\n\n  * irc: fix compilation with old GnuTLS versions (bug #28723)\n\n[[v0.3.1.1]]\n== Version 0.3.1.1 (2010-01-31)\n\nBug fixes::\n\n  * irc: fix crash with SSL connection if option ssl_cert is set (bug #28752)\n  * irc: fix bug with SSL connection (fails sometimes when ssl_verify is on) (bug #28741)\n  * xfer: fix crash when purging old xfer chats (bug #28764)\n\nBuild::\n\n  * irc: fix compilation with old GnuTLS versions (bug #28723)\n\n[[v0.3.1]]\n== Version 0.3.1 (2010-01-23)\n\nNew features::\n\n  * core: add option \"grab_key_command\" in command /input (bound by default to kbd:[Alt+k])\n  * alias: new expansions for alias arguments ($n, $-m, $n-, $n-m, $*, $~) (patch #6917)\n  * alias: allow use of wildcards for /alias list (patch #6925)\n  * alias: allow /unalias to remove multiple aliases (patch #6926)\n  * irc: add new commands /allchan and /allserv with excluding option, commands /ame and /amsg are now aliases, new aliases /aaway and /anick\n  * irc: add options to customize target buffer for messages (task #7381)\n  * irc: add new output queue for messages with low priority (like automatic CTCP replies), high priority is given to user messages or commands\n  * irc: use self-signed certificate to auto identify on IRC server (CertFP) (task #7492, debian #453348)\n  * irc: check SSL certificates (task #7492)\n  * irc: add option \"autorejoin_delay\" for servers (task #8771)\n  * irc: add option to use same nick color in channel and private (task #9870)\n  * irc: add missing command 275 (patch #6952)\n  * irc: add commands /sajoin, /samode, /sanick, /sapart, /saquit (task #9770)\n  * irc: add options for CTCP, to block/customize CTCP reply (task #9693)\n  * irc: add missing CTCP: clientinfo, finger, source, time, userinfo (task #7270)\n  * irc: add all server options for commands /server and /connect\n  * irc: add arguments for command /rehash\n  * irc: improve mask used by command /kickban\n  * xfer: add color for nicks in chat\n  * xfer: add missing command /me (bug #28658)\n  * gui: add color \"darkgray\", add support for background with light color\n\nBug fixes::\n\n  * core: fix bug with script installation on BSD/macOS (patch #6980)\n  * core: fix compilation under Cygwin (patch #6916)\n  * core: fix plural form in translation files (bug #27430)\n  * core: fix terminal title bug: do not reset it when option weechat.look.set_title is off (bug #27399)\n  * core: fix buffer used by some input functions called via plugin API with buffer pointer (bug #28152)\n  * alias: fix bug with buffer for execution of alias, when called from plugin API with function command (bug #27697)\n  * alias: fix bug with arguments (bug #27440)\n  * irc: improve error management on socket error (recv/send)\n  * irc: fix nick color for nicks with wide chars (bug #28547)\n  * irc: fix autorejoin on channels with key\n  * irc: fix command /connect (options -ssl, -ipv6 and -port) (bug #27486)\n  * xfer: add missing charset decoding/encoding for IRC DCC chat (bug #27482)\n  * fifo: remove old pipes before creating new pipe\n  * gui: fix color \"black\" (bug #23882, debian #512957)\n  * gui: fix message \"Day changed to\", sometimes displayed at wrong time (bug #26959)\n  * gui: fix bug with URL selection in some terminals (caused by horizontal lines) (bug #27700)\n  * gui: use default auto completion for arguments of unknown commands\n  * gui: fix alignment problem for buffer name when a merged buffer is closed (bug #27617)\n  * gui: update hotlist when a buffer is closed (bug #27470), remove buffer from hotlist when buffer is cleared (bug #27530)\n  * gui: fix /input history_global_next: reset input content when last command in history is reached\n  * api: fix function bar_set for python/lua/ruby (patch #6912)\n\nBuild::\n\n  * core: fix CMake directories: let user customize lib, share, locale and include directories (patch #6922)\n  * ruby: add support of Ruby >= 1.9.1 (patch #6989)\n\n[[v0.3.0]]\n== Version 0.3.0 (2009-09-06)\n\nNew features::\n\n  * core: add group support in nicklist\n  * core: add /reload command to reload WeeChat and plugins config files (signal SIGHUP is caught to reload config files)\n  * core: add new /layout command and save_layout_on_exit config option, to save/restore windows and buffers order (task #5453)\n  * core: add new options for completion, optional stop instead of cycling with words found (task #5909)\n  * core: new name for configuration files (*.conf instead of *.rc)\n  * core: improve /set command, new command /unset (task #6085)\n  * core: add new input action \"set_unread_current_buffer\" to set unread marker for current buffer only (task #7286)\n  * core: remove key functions, replaced by /input command\n  * core: add argument with buffer number/range for command \"/buffer close\" (task #9390, task #7239)\n  * core: add new command /wait (schedule a command execution in future)\n  * core: improve main loop: higher timeout in select, less CPU usage\n  * gui: new display engine, with prefix and message for each line\n  * gui: add new type of buffer, with free content\n  * gui: add tags for lines and custom filtering by tags or regex (task #7674)\n  * gui: add buffer merging (task #7404)\n  * gui: add custom bars, with custom items\n  * gui: add key to zoom a window (task #7470)\n  * gui: add keys to move into last visited buffers: kbd:[Alt+<] and kbd:[Alt+>]\n  * gui: come back to last visited buffer when closing a buffer\n  * gui: add new option scroll_page_percent to choose percent of height to scroll with kbd:[PgUp] and kbd:[PgDn] keys (task #8702)\n  * gui: add number of lines remaining after last line displayed in \"-MORE-\" indicator (task #6702)\n  * network: add support for more than one proxy, with proxy selection for each IRC server (task #6859)\n  * aspell: improve plugin: use of many dictionaries, global dictionary, real time checking (optional), fix bugs with utf-8\n  * irc: add irc plugin (replaces old IRC code in core) (task #6217)\n  * irc: add smart join/part/quit message filter (task #8503)\n  * irc: use of many addresses for servers (auto-switch when a connection fails), nicks are now set with one option \"nicks\" (task #6088)\n  * irc: add some colors in messages from server (for text and nicks) (task #8926)\n  * irc: add color decoding in title for IRC channels (task #6030)\n  * irc: add missing commands (328, 369)\n  * logger: add logger plugin with new features: backlog, level for messages to log (task #8592), level by buffer (task #6687), filename mask by buffer, option \"name_lower_case\" (bug #19522)\n  * relay: add relay plugin (network communication between WeeChat and remote application)\n  * xfer: add speed limit for DCC files sending (task #6178)\n  * xfer: add new option xfer.file.use_nick_in_filename for Xfer files (task #7140)\n  * plugins: add some other plugins: alias, demo, fifo, tcl, xfer\n  * scripts: new scripts: weeget.py (script manager), jabber.py (jabber/XMPP protocol), go.py (quick jump to buffers), buffers.pl (sidebar with list of buffers), iset.pl (set options interactively), weetris.pl (tetris-like game), mastermind.pl, ...\n  * api: add hooks: command, timer, file descriptor, process, connection, print, signal, config, completion, modifier, info, infolist\n  * api: new plugin API with many new functions: hooks, buffer management and nicklist, bars, configuration files, network, infos/infolists, lists, upgrade\n\nInternationalization::\n\n  * add Polish translations\n\nBug fixes::\n\n  * core: fix nick completion bug (missing space after nick)\n  * gui: fix completion with non-latin nicks (bug #18993)\n  * gui: fix display bug with some weird UTF-8 chars (bug #19687)\n  * gui: fix bug with wide chars in input (bug #16356)\n  * gui: fix bug when switching window, scrollback is now preserved (task #7680)\n  * network: fix network connection for hostnames resolving to several IPs: try all IPs in list until one succeeds (bug #21473, debian #498610)\n  * alias: fix bug with alias, use current buffer to run commands (bug #22876)\n  * irc: fix lock with SSL servers when connection fails, and when disconnecting during connection problem (bug #17584)\n  * irc: command /whois is now authorized in private without argument (task #7482)\n  * irc: fix private buffer name with Irssi proxy (bug #26589)\n  * irc: remove kernel info in CTCP VERSION reply (task #7494)\n  * irc: fix mode parsing when receiving modes with arguments (bug #26793)\n  * scripts: do not auto-load hidden files (bug #21390)\n\n[[v0.2.6.3]]\n== Version 0.2.6.3 (2009-06-13)\n\nBug fixes::\n\n  * fix GnuTLS detection (use pkg-config instead of libgnutls-config) (bug #26790)\n\n[[v0.2.6.2]]\n== Version 0.2.6.2 (2009-04-18)\n\nBug fixes::\n\n  * fix bug with charset decoding (for example with iso2022jp) (bug #26228)\n\n[[v0.2.6.1]]\n== Version 0.2.6.1 (2009-03-14)\n\nBug fixes::\n\n  * fix crash with some special chars in IRC messages (bug #25862, CVE-2009-0661)\n\n[[v0.2.6]]\n== Version 0.2.6 (2007-09-06)\n\nNew features::\n\n  * add new option \"deloutq\" to /server command to delete all servers messages out queues (task #7221)\n  * add string length limit for setup file options\n  * add option to align text of messages (except first lines) (task #7246)\n  * add paste detection, new options look_paste_max_lines and col_input_actions (task #5442)\n  * add support of channel mode +u (channel user) (bug #20717)\n  * improve /connect command to connect to a host by creating a temporary server, add option to /server to create temporary server (task #7095)\n  * add \"copy\", \"rename\" and \"keep\" options to /server command\n  * allow clear of multiple selected buffers with /clear (patch #6112)\n  * add key for setting unread marker on all buffers (default: kbd:[Ctrl+s], kbd:[Ctrl+u]) (task #7180)\n  * improve command /server ant its output\n  * add 3 default new keys: kbd:[Ctrl+b] (left), kbd:[Ctrl+f] (right), kbd:[Ctrl+d] (delete)\n  * add \"buffer_move\" event handler to plugins API (task #6708)\n  * add key function \"jump_previous_buffer\" to jump to buffer previously displayed (new key: kbd:[Alt+j], kbd:[Alt+p]) (task #7085)\n  * add \"%*\" to completion template, to repeat last completion\n  * add \"-nojoin\" option for /connect and /reconnect commands (task #7074)\n  * add \"scroll\" option to /buffer command\n  * down key now saves input to history and clears input line (task #7049)\n  * command /away allowed when not connected to server (internally stored and AWAY command is sent when connecting to server) (task #7003)\n  * add argument for /upgrade command (path to binary)\n  * add hotlist sort with new option \"look_hotlist_sort\" (task #5870)\n\nBug fixes::\n\n  * fix bug with log of plugin messages (option log_plugin_msg)\n  * fix display bug with some special chars in messages (some words were truncated on screen) (bug #20944)\n  * fix UTF-8 bug with color encoding/decoding\n  * fix crash when searching text in buffer with kbd:[Ctrl+r] (bug #20938)\n  * fix bug with flock when home is on NFS filesystem (bug #20913)\n  * fix user modes in nicklist when ban and nick mode are received in the same MODE message (bug #20870)\n  * fix IRC message 333: silently ignore message if error when parsing it\n  * fix server option \"command_delay\": does not freeze WeeChat any more\n  * fix bug with highlight and UTF-8 chars around word (bug #20753)\n  * fix nick prefix display on servers that doesn't support all prefixes (bug #20025)\n  * fix terminal encoding detection when NLS is disabled (bug #20646)\n  * fix crash when sending data to channel or pv on disconnected server (bug #20524)\n  * fix bugs with IRC color in messages, now color codes are inserted in command line with kbd:[Ctrl+c], kbd:[Ctrl+b].. instead of %C,%B,.. (bug #20222, task #7060)\n  * fix bug with smart nick completion (last speakers first) when a nick is changed\n  * fix charset bug with channel names in status bar (bug #20400)\n  * fix log file when channel name contains \"/\" (bug #20072)\n  * fix bug with /topic when channel not open and topic not defined (bug #20141)\n\nDocumentation::\n\n  * add Swedish quickstart guide\n\n[[v0.2.5]]\n== Version 0.2.5 (2007-06-07)\n\nNew features::\n\n  * add missing IRC commands (327, 378, 379) (bug #20091)\n  * add \"%M\" for completion with nicks of current server (nicks on open channels) (task #6931)\n  * improve key bindings: now possible to bind a key on many commands, separated by semicolon (task #5444)\n  * improve IRC long message split: use word boundary (task #6685)\n  * add protocol priority for GnuTLS (patch #5915)\n  * add channel admin mode \"!\" for some IRC servers\n  * add /reconnect command (task #5448)\n  * add \"-all\" option for /connect and /disconnect commands (task #6232)\n  * improve nick completion: completion with last speakers first and self nick at the end; add option look_nick_completion_smart, enabled by default (task #5896)\n  * add color for input text not found in buffer history\n\nBug fixes::\n\n  * fix /quote command: now allowed when socket is OK (even if IRC connection to server is not OK) (bug #20113)\n  * fix hotlist when exiting search mode: current buffer is removed from hotlist\n  * remove \":\" for unknown IRC commands before arguments (bug #19929)\n  * fix \"%C\" completion: now completes with all channels of all servers\n  * fix bug with \"/buffer query_name\", add server and channel completion for /buffer command (bug #19928)\n  * fix IRC mode parsing when receiving modes with arguments (bug #19902)\n  * fix crash with IRC JOIN malformed message (bug #19891)\n  * fix bug with nick prefixes on some IRC servers (bug #19854)\n  * improve setup file save: now writes temporary file, then rename it (task #6847)\n  * fix bug with $nick/$channel/$server variables in commands\n  * forget current nick when user manually disconnects from server\n  * fix nick display in input window\n  * fix bug with erroneous nickname when connecting to server (bug #19812)\n  * fix display bugs in IRC error messages\n  * fix bug with iso2022jp locale (bug #18719)\n  * fix string format bug when displaying string through plugin script API\n  * fix nick completion in command arguments (bug #19590)\n  * fix possible crash with nick completion when a nick leaves channel (bug #19589)\n  * fix USER message when connecting to IRC server (patch #5835)\n\nBuild::\n\n  * add CMake for weechat compilation (patch #5943)\n\n[[v0.2.4]]\n== Version 0.2.4 (2007-03-29)\n\nNew features::\n\n  * rename log file for DCC chat (now <server>.dcc.<nick>.weechatlog)\n  * add current buffer in hotlist when scrolling up in buffer (task #6664)\n  * improve password hiding, code cleanup (bug #19229)\n  * add new return code in plugin API to force highlight (for message handlers only)\n  * add \"call\" option to /key command, add new key function \"insert\" to insert text on command line (task #6468)\n  * add event handler to plugin API\n  * add numeric argument for /clear command (buffer number) (patch #5372)\n  * add new key (kbd:[Ctrl+r]) for interactive and incremental search in buffer history (task #6628)\n\nBug fixes::\n\n  * fix color bug with IRC messages displayed by plugins (bug #19442)\n  * fix topic charset, now using channel charset if defined (bug #19386)\n  * fix crash when closing a pv if a DCC chat is open on same nick (bug #19147)\n  * fix bug with channel topic after reconnection (not erased) (bug #19384)\n  * fix bug with explode_string / free_exploded_string when max_items > 0\n  * fix /topic completion when no topic set on current channel (bug #19322)\n  * fix bug with server buffer when \"look_one_server_buffer\" is ON and server buffer is moved to any number > 1 (bug #19219)\n  * fix /help command: displays plugin help for redefined commands (bug #19166)\n  * prefix \"/\" disabled in commands (patch #5769)\n  * fix completion of redefined commands removed by plugins (bug #19176)\n  * fix memory leaks in perl and python plugins (bug #19163)\n  * fix permissions on \"dcc\" and \"logs\" directories (bug #18978)\n  * fix crash when /away command is issued with no server connection (bug #18839)\n  * fix crash when closing a buffer opened on many windows\n  * fix freeze with SSL server when disconnecting after connection loss (bug #18735)\n\nDocumentation::\n\n  * add Scots quickstart guide\n\n[[v0.2.3]]\n== Version 0.2.3 (2007-01-10)\n\nBug fixes::\n\n  * fix display bugs with nicklist at top/bottom when look_nicklist_separator is OFF (bug #18737)\n  * fix iconv problem, causing truncated words when using iso locale\n  * fix topic scroll when topic has multi-bytes chars\n  * fix bugs with charset: now decodes/encodes nicks and channels in IRC messages (bug #18716)\n\nBuild::\n\n  * fix compilation problem with iconv under FreeBSD\n\n[[v0.2.2]]\n== Version 0.2.2 (2007-01-06)\n\nNew features::\n\n  * add anti-flood option (irc_anti_flood) (task #5442)\n  * plugins: \"add_message_handler\" now accepts \"*\" for all IRC messages\n  * add keys (kbd:[F9] / kbd:[F10]) to scroll topic (task #6030)\n  * add auto completion with channels and filenames (task #5423)\n  * add option \"look_nicklist_separator\" (task #5437)\n  * add \"irc_send_unknown_commands\" option to send unknown commands to IRC server (OFF by default) (task #5947)\n  * /charset command and charset conversions now made by \"charset\" plugin\n  * add filename completion (task #5425)\n  * add \"modifier\" in plugins API\n  * improve /plugin command\n  * add date in plugin function get_buffer_data\n  * add more values for config boolean values: y/true/t/1 and n/false/f/0\n\nBug fixes::\n\n  * fix bug with status bar (missing refresh) when closing a buffer\n  * fix bug with use of first buffer for a channel if not connected to server (now allowed only for a server buffer)\n  * fix refresh bug with private buffer title\n  * fix bug with nick completion in command arguments (now uses option look_nick_completion_ignore)\n  * fix display bug with color for first line on screen (bug #17719)\n  * fix bug with set_config function in plugins API (bug #18448)\n  * fix memory leak in keyboard input\n  * fix refresh bug when changing config options if window is split\n  * add space between chat and nicklist when position is \"right\" (bug #17852)\n  * fix bug with DCC SEND when filename begins with \"~\"\n  * fix display bug in status bar, wrong length when using UTF-8\n  * fix bug with ignore: now any IRC command is allowed\n  * fix crash with kbd:[Ctrl+t] (transpose) and one char on line (bug #18153)\n  * fix bug on ignore with \"mode\" IRC command (bug #18058)\n  * fix crash when loading ruby script if file does not exist, with Ruby >= 1.9 only (bug #18064)\n  * mode changes with /op, /deop, /voice, /devoice, /halfop, /dehalfop are now sent in one mode command to server (task #5968)\n  * fix bug with /alias and arguments (like $1), now text after argument(s) is used (bug #17944)\n  * fix minor display bug with special chars on some arch like PPC\n\nBuild::\n\n  * fix some portability bugs (patch #5271)\n  * fix iconv detection for BSD (patch #5456)\n  * fix typo in configure.in (bash specific test) (patch #5450)\n\n[[v0.2.1]]\n== Version 0.2.1 (2006-10-01)\n\nNew features::\n\n  * command \"/away -all\" now allowed when not connected to current server\n  * new signals handled: SIGTERM and SIGHUP (received when terminal is closed): clean WeeChat quit (send quit to irc servers then quit WeeChat)\n  * add some new default key bindings for existing keys (for some OS)\n  * command /key now OK with one argument (key name): display key if found\n  * add current channel completion for /ctcp command\n  * values yes/no accepted (as on/off) for config boolean values (task #5454)\n  * add server default notify level (set by /buffer notify on server buffer) (task #5634)\n  * add special vars $nick/$channel/$server for server_command, alias and plugin command handlers\n  * add arguments $1,$2,..,$9 and $* for alias (task #5831)\n  * add hotlist in session file when using /upgrade command (task #5449)\n\nBug fixes::\n\n  * fix crash for DCC receiver when resuming a file (bug #17885)\n  * fix DCC error for sender when receiver cancels DCC (bug #17838)\n  * fix random crash with /upgrade command (error when loading buffers)\n  * fix buffer search by server/channel: now if only channel is specified, a channel of another server can be found\n  * fix highlight for DCC, invite and notice: when a window is displaying buffer, there's no highlight\n  * fix bug with CTCP VERSION sent on channels (bug #17547)\n  * fix bugs in get_buffer_data which breaks the retrieval of buffer content (perl, lua)\n  * fix nicklist display bug when top/bottom (not enough lines) (bug #17537)\n  * fix bug with auto-rejoin of keyed channels (bug #17534)\n  * add default nick completion when line starts with \"//\" (bug #17535)\n  * fix crashes with /buffer and /charset commands when not connected to any server (bug #17525)\n  * fix nick refresh problem with unrealircd specific modes: chan owner (~) and chan admin (&) (bug #17340)\n\n[[v0.2.0]]\n== Version 0.2.0 (2006-08-19)\n\nNew features::\n\n  * add \"C\"lear option on IRC raw buffer\n  * IRC raw buffer now uses join/part prefix with color to display messages\n  * add send of \"quit\" message to server when using /disconnect\n  * add \"%m\" for completion with self nick (on current server)\n  * add missing IRC commands (310, 326, 329, 338)\n  * improve DCC speed (up to x5 on LAN) by forking for DCC files and a new option \"dcc_fast_send\" (does not wait for ACK) (task #5758)\n  * add \"look_save_on_exit\" option (patch from Emanuele Giaquinta)\n  * add new functions in plugin/script API: get window info, get buffer info, get buffer content\n  * add color encoding for some commands like /me\n  * add aspell plugin\n\nBug fixes::\n\n  * fix \"wallops\" command when received, now displayed by WeeChat (bug #17441)\n  * fix /wallops command (now many words are correctly sent)\n  * fix command 348 (channel exception list, received by /mode #chan e)\n  * add missing modes (channel & user), now all modes are allowed (bug #16606)\n  * fix DCC restore after /upgrade (order is now correctly saved)\n  * fix away after server disconnection (now away is set again when reconnecting) (bug #16359)\n  * fix DCC file connection problem (connection from receiver to sender)\n  * fix crash when purging DCC with high number of DCC (> window size)\n  * fix completion for command handlers (now empty completion_template means nick completion, \"-\" string means no completion at all)\n  * fix nick alignment problem when look_nickmode is off\n  * add generic function for incoming numeric IRC commands (bug #16611)\n  * fix crash when doing \"/part something\" on a server buffer (bug #17201)\n  * charsets are now checked when set by /charset command\n  * fix crash on DCC buffer under Darwin 8 (bug #17115)\n  * fix bug with spaces in script names (bug #16957)\n  * fix random crash when \"MODE #chan -l\" is received\n  * fix bug in IRC parser (random crash with malformed IRC messages)\n  * fix refresh bugs when terminal is resized: too many refreshes, display bug with split windows\n  * case ignored for channel names in charset options (bug #16858)\n  * fix crash when setting look_one_server_buffer to ON (bug #16932)\n  * fix display bug with special char (bug #16732)\n  * rename plugins names (remove \"lib\" prefix in name)\n  * fix crash when closing DCC/raw buffer if 2 are open (bug #16808)\n  * fix crashes with DCC chat remove/purge on DCC view (bug #16775)\n  * fix bug with connection to bnc (bug #16760)\n  * command /save now writes plugins options (~/.weechat/plugins.rc)\n  * fix crash with register function in plugin scripts (bug #16701)\n  * fix random crash at exit (/quit or /upgrade) with split windows\n\nDocumentation::\n\n  * add Polish, Russian and Czech quickstart guide\n\nBuild::\n\n  * add configure option for doc XSL prefix (bug #16991)\n\n[[v0.1.9]]\n== Version 0.1.9 (2006-05-25)\n\nNew features::\n\n  * add backtrace when WeeChat crashes, log file automatically renamed\n  * add new key to find previous completion (kbd:[Shift+Tab] by default)\n  * add missing IRC commands (006, 007, 290, 292, 310, 379, 437, 974)\n  * add new option to customize input prompt\n  * add nick modes\n  * add hostnames associated to nicks (available for /ban completion)\n  * add \"+p\" mode for channels, fix mode display in status bar\n  * add nick alignment options\n  * add keyboard handler to plugin API\n  * improve script plugin loader\n  * add hostname/IP option for connection to server\n  * add /setp command (set plugin options)\n  * aliases are executed before WeeChat/IRC commands, add /builtin command\n  * add /cycle command, /part command does close buffer any more\n\nInternationalization::\n\n  * add Russian translations (thanks to Pavel Shevchuk)\n\nBug fixes::\n\n  * fix /squery command (message sent to server, now OK with more than two arguments)\n  * fix /alias command (with an alias name, display content)\n  * add lock for log file (~/.weechat/weechat.log), only one WeeChat process can use this file (bug #16382)\n  * fix crash with malformed UTF-8 strings\n  * fix crash with ncurses color when too many colors defined in ncurses (bug #16556)\n  * fix bug with long outgoing IRC messages (> 512 bytes) (bug #16358)\n  * fix Ruby crash when handler does not return OK or KO (bug #16552)\n  * fix UTF-8 display bug with chars using more than one cell on screen (bug #16356)\n  * fix display bug with DCC file size when > 1 GB\n  * fix refresh bug (deadlock in curses) when terminal is resized (bug #16542)\n  * fix nicklist sort bug\n  * fix crash when multiple pv have same name: now it's forbidden and pv buffer is not renamed (when a nick changes) if another exists with same name (bug #16369)\n  * command /clear [-all] now clears hotlist\n  * fix crash after /upgrade if a line in history is empty (bug #16379)\n  * fix many crashes with DCC chat (bug #16416)\n  * fix commands 332, 333 (/topic now OK when channel is not opened)\n  * remove color encoding and charset conversion for commands (only allowed in text sent to channel/private)\n  * fix /names command: now displays result when not on a channel\n  * fix refresh bug (too many refresh) when terminal is resized\n  * fix nicklist display bugs when on top or bottom of chat window\n  * fix high CPU usage when running under a Screen that has been killed\n\nDocumentation::\n\n  * add German doc (thanks to Frank Zacharias)\n\nBuild::\n\n  * fix --disable-plugins option in configure script\n  * improve Lua detection (bug #16574)\n\n[[v0.1.8]]\n== Version 0.1.8 (2006-03-18)\n\nNew features::\n\n  * improve alias completion (now uses target command for completion)\n  * add missing IRC command (487)\n  * add inactivity time, available for plugins via get_info(\"inactivity\")\n  * add keys kbd:[Alt+Home] / kbd:[Alt+End] to scroll top/bottom, kbd:[Alt+F11] / kbd:[Alt+F12] to scroll nicklist top/bottom\n  * add special names for plugin message handlers: weechat_pv, weechat_highlight, weechat_ctcp, weechat_dcc\n  * add IRC raw data buffer (new key: kbd:[Alt+j], kbd:[Alt+r])\n  * add new plugins functions: add_timer_handler, remove_timer_handler, remove_infobar\n  * plugin messages handlers now called when message is ignored (by /ignore)\n  * new behavior for messages ignored by a message handler: now WeeChat executes standard handler, treating message as \"ignored\"\n  * many commands allowed for aliases\n  * many commands allowed when connecting to server\n  * add Lua script plugin\n  * add functions in plugins API: get_server_info, free_server_info, get_channel_info, free_channel_info, get_nick_info, free_nick_info\n  * add option \"look_nick_complete_first\" (patch from Gwenn)\n  * add option \"look_open_near_server\" (patch from Gwenn)\n  * add new scroll keys for a few lines up/down (default: kbd:[Alt+PgUp] / kbd:[Alt+PgDn]) (patch from Pistos)\n  * add new option \"irc_away_check_max_nicks\" to disable away check on channels with high number of nicks (patch from Gwenn)\n  * add new command line argument for setting WeeChat home dir (-d or --dir) (patch from Gwenn)\n  * add option \"irc_show_away_once\", to show away message only once in pv\n\nInternationalization::\n\n  * add partial Hungarian translations\n\nBug fixes::\n\n  * improve Ruby plugin\n  * fix /set command when internal server name contains one or many dots\n  * fix get_info plugin API function when no server at all is opened\n  * fix display bug when top of buffer is displayed and first line is removed (according to \"history_max_lines\" setting)\n  * fix /mode command output\n  * fix completion problem in private with nicks\n  * script plugins now load scripts in WeeChat system share directory\n  * /msg command does not open any buffer any more\n  * fix crash when using global history (when older entry is removed)\n  * fix display bug with /kill command\n  * fix bug with /upgrade and servers buffer\n  * fix bug with get_dcc_info plugin interface function\n  * fix bug with charset in infobar highlights\n  * fix bug with buffer detection in plugins/scripts commands\n  * fix bug with /history command\n\n[[v0.1.7]]\n== Version 0.1.7 (2006-01-14)\n\nNew features::\n\n  * remove \"irc_default_msg_away\" setting, for RFC 2812 conformity (/away command without argument only removes away status), new values for \"irc_display_away\" (off, local, channel)\n  * add color for window separators (when split)\n  * add completion system for plugins/scripts commands\n  * add charset by server and channel, new command: /charset\n  * add Ruby script plugin\n  * add /upgrade command\n  * add ETA (Estimated Time of Arrival) for DCC files\n  * /nick command is now allowed when not connected to server\n  * add server/channel argument to /buffer command for jumping to buffer\n  * add new keys for switching to other windows: kbd:[Alt+w], kbd:[Alt+Arrow]\n  * add new keys for scrolling to previous/next highlight: kbd:[Alt+p] / kbd:[Alt+n]\n  * add \"read marker\": an indicator for first unread line in a server or channel buffer (new key kbd:[Alt+u] to scroll to marker)\n  * new window management: custom size for windows, auto resize when terminal is resized\n  * add /history command\n\nBug fixes::\n\n  * fix msg command (now allowed in private buffer with \"*\" as target)\n  * fix refresh bug with Solaris when term size is changed\n  * fix plugins autoload\n  * fix display bug in chat window when a message length equals to window width\n  * fix infinite loop when resizing term to small size\n\nBuild::\n\n  * replace Texinfo doc by XML Docbook\n\n[[v0.1.6]]\n== Version 0.1.6 (2005-11-11)\n\nNew features::\n\n  * new color management system, IRC colors are now correctly displayed and can be removed by new options irc_colors_receive and irc_colors_send\n  * add setting for having one server buffer for all servers (look_one_server_buffer)\n  * add setting for ignoring some chars when completing nicks\n  * signal SIGPIPE is now ignored\n  * add partial match for highlights\n  * add dcc_own_ip and dcc_port_range settings\n  * full UTF-8 support, auto-detection of UTF-8 usage (locale)\n  * add \"Day changed to [date]\" message when day changes\n  * new plugin interface, rewritten from scratch: now loads dynamic C library, and perl/python are script plugins\n  * log options (for server/channel/private) can now be set while WeeChat is running\n  * add channel modes +e and +f\n  * add some missing IRC commands, fix command 367\n  * add colors for input buffer and current channel of status bar\n  * add online help for config options (with /set full_option_name)\n  * enhanced \"smart\" hotlist, with names (new options: look_hotlist_names_{count|level|length})\n\nBug fixes::\n\n  * fix scroll problem when one line is bigger than screen size\n  * fix IRC message parser bug\n\n[[v0.1.5]]\n== Version 0.1.5 (2005-09-24)\n\nNew features::\n\n  * add /ame command (send CTCP action to all channels of all connected servers)\n  * add setting \"irc_notice_as_pv\" to see notices as pv\n  * add nicks colors in setup file\n  * add some missing IRC commands\n  * add /ignore and /unignore commands\n  * signal SIGQUIT is now ignored\n  * jump to next server now saves current channel buffer for each server\n  * add keys kbd:[Ctrl+Up] / kbd:[Ctrl+Down] to call previous/next command in global history (common to all buffers)\n\nBug fixes::\n\n  * fix DCC bug: delete failed file only if really empty (on disk)\n  * fix IRC message parser bug\n  * fix scroll problem (screen moving when scrolling and new line displayed)\n  * fix infinite loop when scrolling back and displaying long lines\n  * fix crash when closing a buffer used by more than one window\n  * fix DCC display bug (now decodes string according to charset)\n  * fix bug with strings comparison (str[n]casecmp) and some locales (like Turkish), now using ASCII comparison (thanks to roktas)\n  * fix refresh bug when one line is bigger than screen size\n  * fix look_nicklist_min_size and look_nicklist_max_size options\n  * fix refresh bug when changing channel modes\n\n[[v0.1.4]]\n== Version 0.1.4 (2005-07-30)\n\nNew features::\n\n  * join and part/quit prefixes (arrows) now displayed with different colors\n  * add \"irc_highlight\" setting, to get highlight with any word\n  * add /amsg command (send text to all channels of all connected servers)\n  * add color for private in hotlist (different than color for highlight)\n  * add DCC resume and timeout\n  * add function for Perl/Python to get DCC list\n  * new keyboard management: keys are setup in config file, add new command /key, add some new default keys, kbd:[Alt+k] is used to grab key (useful for /key command)\n  * add seconds in infobar time (optional thanks to new setting)\n  * add auto-prefix with \"#\" for channels (if no prefix found), with /join command\n\nBug fixes::\n\n  * fix auto-rejoin for channels with key\n  * fix /ctcp command (now any command/data allowed)\n  * fix SIGSEGV handler (now write a core file by aborting program)\n  * fix statusbar & infobar background refresh problem with some systems\n  * fix FIFO pipe (command now authorized on a buffer not connected to an IRC server)\n  * topic completion now decodes UTF-8 string\n  * fix bug with IRC URL on command line (irc://)\n  * fix some curses refreshes\n\n[[v0.1.3]]\n== Version 0.1.3 (2005-07-02)\n\nNew features::\n\n  * proxy support (http, socks4, socks5) with authentication (http, socks5) and ipv6 support (client to proxy)\n  * add completion for config option (with /set command)\n  * commands from users outside channel now authorized (if special user or channel without \"n\" flag)\n  * add IPv6 support\n  * kill command now received and displayed\n  * add SSL support\n  * channel notify levels are saved in config file (new option \"server_notify_levels\" for server sections)\n  * part message now accepts %v (replaced by WeeChat version), like quit message\n\nBug fixes::\n\n  * errors while loading perl scripts are now displayed in server buffer (instead of current buffer)\n  * in python scripts, all messages written in stdin and stderr are redirected in server buffer\n  * fix a filename error while loading a python script manually\n  * fix plugins print and prnt functions: now OK for writing on server buffers\n  * fix color problem with new libcurses version\n  * fix crash when using kbd:[Alt+s] or kbd:[Alt+x] on DCC buffer (kbd:[Alt+d])\n  * fix startup crash when config file (~/.weechat/weechat.rc) is not found\n\nBuild::\n\n  * improve Perl/Python libs detection for ./configure script\n\n[[v0.1.2]]\n== Version 0.1.2 (2005-05-21)\n\nNew features::\n\n  * add Python plugin support, improve Perl interface (and now Perl/Python libraries are checked by configure script)\n  * add nicklist scroll keys (kbd:[Alt+Home] / kbd:[Alt+End] / kbd:[Alt+PgUp] / kbd:[Alt+PgDn] or kbd:[F11] / kbd:[F12])\n  * add transfer rate for DCC files\n  * add \"-all\" option for /nick command\n  * buffers timestamp can now be changed (new option in config file)\n  * add missing IRC commands (307, 341, 485, 671)\n\nBug fixes::\n\n  * fix nicklist sort\n  * fix crash when purging old DCC\n  * fix crash with 64-bits arch (like AMD64) when converting UTF-8\n\nBuild::\n\n  * WeeChat now OK under *BSD and macOS\n\n[[v0.1.1]]\n== Version 0.1.1 (2005-03-20)\n\nNew features::\n\n  * add nicks count for channel buffers\n  * add FIFO pipe for remote control\n  * add crash dump when WeeChat receives SIGSEGV (Segmentation fault)\n  * add new display engine: doesn't cut words at end of lines\n  * add DCC send and DCC chat\n  * add /halfop & /dehalfop commands, fix halfop display bug in nicklist\n  * add /ban, /unban and /kickban commands\n  * add --irc-commands and --weechat-commands command line options\n  * connection to IRC server is now made by child process (non blocking)\n  * add support for UnrealIrcd (\"~\" for chan owner, \"&\" for chan admin)\n  * new key for window switch (now: kbd:[F5] / kbd:[F6] = switch buffer, kbd:[F7] / kbd:[F8] = switch window)\n  * on server buffer, only server messages are logged\n  * improve /help command output\n  * plugins messages are logged with new config option (log_plugin_msg)\n\nInternationalization::\n\n  * add Spanish translations\n\nBug fixes::\n\n  * fix /kick command\n  * fix /invite command (and now invite requests are displayed)\n  * fix /buffer close command (now OK when disconnected from server)\n  * fix display bugs when many windows are opened\n\n[[v0.1.0]]\n== Version 0.1.0 (2005-02-12)\n\nNew features::\n\n  * improve /window command: now split and merge are OK\n  * away nicks are now displayed with another color (new option: \"irc_away_check\")\n  * add away indicator in status bar\n  * add lag indicator (and auto-disconnect after a delay if important lag)\n  * improve completion: now completes commands arguments (IRC and internal), when only one completion matches, completion mechanism is stopped (to complete command argument for example)\n  * improve /set command: empty strings are allowed, new colors, server options can be changed while WeeChat is running\n  * add default away/part/quit messages in config file\n  * new [irc] section in config file, move option \"look_display_away\" to \"irc_display_away\"\n  * server messages & errors are all prefixed (by 3 chars, like \"-@-\")\n  * add new options for charset (UTF-8 support): look_charset_decode, look_charset_encode and look_charset_internal\n\nBug fixes::\n\n  * fix many memory leaks\n  * fix colors bug: remove \"gray\" color (replaced by \"default\"), colors are OK when terminal has white (or light) background\n  * fix crash when resizing terminal to small size\n  * fix crash when multiple servers and big messages received from server\n  * fix crash when closing some private buffers\n  * fix crash when unknown section with option(s) in config file\n  * fix /op, /deop, /voice, /devoice (now OK with many nicks)\n  * fix /me command (now OK without parameter)\n  * fix /away command (now OK if not away)\n  * logs are now disabled by default (server/channel/private)\n\n[[v0.0.9]]\n== Version 0.0.9 (2005-01-01)\n\nNew features::\n\n  * auto-reconnection to server (new options: server_autoreconnect (on/off), server_autoreconnect_delay (in seconds))\n  * new command \"/buffer close\" (close any server/channel/private buffer)\n  * new keys: kbd:[Ctrl+a] (home), kbd:[Ctrl+e] (end), kbd:[Ctrl+w] (same as kbd:[Ctrl+Backspace]), kbd:[Alt+s] (switch to server buffer), kbd:[Alt+x] (switch to first channel of next server)\n  * add new config option: \"server_command_delay\" (delay in seconds after startup command for each server)\n\nBug fixes::\n\n  * fix major bug when socket is closed by server (100% CPU usage), and disconnections are now OK (all channels are \"closed\", history is still visible, and buffer will be used again if reconnection to server)\n  * option \"look_remove_colors_from_msgs\" is now working\n  * fix display of nick mode changes\n  * fix /notice command (and display when received from server)\n\n[[v0.0.8]]\n== Version 0.0.8 (2004-10-30)\n\nNew features::\n\n  * nickserv passwords hidden (new config option: log_hide_nickserv_pwd on/off)\n  * auto-rejoin channels when kicked (new config option: server_autorejoin on/off)\n  * add IRC::command function for Perl scripts\n  * /buffer command developed (buffers list, move and notify)\n  * logging buffers to disk (server/channel/private according to user preferences)\n  * add config option \"look_display_away\" to announce away in channels\n  * DCC file receive OK (kbd:[Alt+d] for DCC view)\n  * add key kbd:[Ctrl+l] (`L`) for redrawing terminal\n  * add key kbd:[Alt+r] for clearing hotlist\n\nBug fixes::\n\n  * fix /kick command: now OK with many words as reason\n  * fix bug when adding alias with same name as other\n  * fix crash when resizing terminal to very small size\n  * \"-MORE-\" message is now erased when switching to another buffer\n  * /query command now reopens private buffer if already opened\n\n[[v0.0.7]]\n== Version 0.0.7 (2004-08-08)\n\nNew features::\n\n  * new \"col_status_delimiters\" config option\n  * add command /buffer , buffers ordered by number, auto-jump to active buffers (kbd:[Alt+a]), jump to buffers by number (kbd:[Alt+0...9])\n  * add command /window, split terminal horizontally/vertically\n  * unique color for each nick (based on nickname)\n  * add history limit (text buffer and commands)\n\nBug fixes::\n\n  * action messages are now considered as messages, not crappy joins/parts\n  * fix display bug when nicklist is displayed at bottom of screen\n\nBuild::\n\n  * replace --enable-debug with --with-debug option for ./configure\n\n[[v0.0.6]]\n== Version 0.0.6 (2004-06-05)\n\nNew features::\n\n  * improve channel highlight (priority to message vs join/part)\n  * add command /query (starts private conversation)\n  * add IRC messages 476, 477\n\nBug fixes::\n\n  * fix bug when opened private win and remote user changes his nick\n  * /mode command is now OK and channel flags are displayed in status bar\n  * fix display bug (text was blinking when scrolling)\n  * CTCP Version reply is now in English only and doesn't show host (security reason)\n\n[[v0.0.5]]\n== Version 0.0.5 (2004-02-07)\n\nNew features::\n\n  * /set command to modify config options when WeeChat is running\n  * URL command line parameter to connect to server(s)\n  * new Perl script function to display message in info bar (\"IRC::print_infobar\")\n  * info bar highlight notifications\n  * add info bar timestamp in config (\"look_infobar_timestamp\")\n  * add info bar (optional, \"look_infobar\" to enable it, \"on\" by default)\n  * add -c (or --config) command line parameter to see config file options\n\nBug fixes::\n\n  * fix look_nicklist config option, now enables/disables nicklist\n  * secure code to prevent buffer overflows and memory leaks\n  * fix QUIT IRC command: now sent to all connected servers (not only current)\n  * fix crash with /oper command\n  * for default config file, nick is now based on un*x username\n  * fix crash when config file cannot be written\n  * add highlight on action messages\n\n[[v0.0.4]]\n== Version 0.0.4 (2004-01-01)\n\nNew features::\n\n  * add Perl plugin\n\nBug fixes::\n\n  * fix switch to private buffer\n  * add highlight when our nick is written in a channel/private window\n  * catch kbd:[Ctrl+c] (ignored)\n\nBuild::\n\n  * debug messages can be enabled via ./configure --enable-debug option\n\n[[v0.0.3]]\n== Version 0.0.3 (2003-11-03)\n\nNew features::\n\n  * add new IRC commands: stats, service, squit, motd, lusers, links, time, trace, admin, info, servlist, squery, who, whowas, die, summon, users, wallops, userhost, ison, ctcp ping\n\nInternationalization::\n\n  * add French translations\n\nBug fixes::\n\n  * for sort of nicks (op, halfop, voice, other)\n  * fix problem with \"353\" IRC message (nicklist)\n  * fix problem when nick is truncated by server\n  * fix crash when entering text without any server connection\n  * fix crash when /set command is executed\n  * fix display bug (text was blinking when scrolling)\n  * code cleanup\n\nBuild::\n\n  * add ./configure script to build WeeChat\n\n[[v0.0.2]]\n== Version 0.0.2 (2003-10-05)\n\nNew features::\n\n  * add commands /rehash and /restart\n  * and command and auto-join channels when connected to server\n  * new commands for alias: /alias, /unalias (new section in config file)\n  * config is now saved automatically when quitting WeeChat, add /save command\n  * new commands for servers: /server, /connect, /disconnect\n  * add autoconnect flag for each server in config file\n  * add \"look_set_title\" option in config file\n  * term window title is modified with WeeChat name and version\n  * CTCP version returns more info (about OS)\n\nBug fixes::\n\n  * fix nicklist display bug\n  * fix crash when sending command which can only be received\n\n[[v0.0.1]]\n== Version 0.0.1 (2003-09-27)\n\nNew features::\n\n  * ncurses GUI with color output\n  * multi-servers\n  * channel windows, with nicklist (position: top, bottom, left or right)\n  * private windows\n  * IRC commands: away, ctcp, deop, devoice, invite, join, kick, kill, list, me, mode, msg, names, nick, notice, op, oper, part, ping, pong, quit, quote, topic, version, voice, whois\n  * WeeChat commands: clear, help, set (partial)\n  * many config options\n  * log file (~/.weechat/weechat.log)\n  * nicklist can be moved on top, bottom, left or right of window\n", "/*\n * irc-nick.c - nick management for IRC plugin\n *\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-nick.h\"\n#include \"irc-color.h\"\n#include \"irc-config.h\"\n#include \"irc-mode.h\"\n#include \"irc-server.h\"\n#include \"irc-channel.h\"\n\n\n/*\n * Checks if a nick pointer is valid.\n *\n * Returns:\n *   1: nick exists in channel\n *   0: nick does not exist in channel\n */\n\nint\nirc_nick_valid (struct t_irc_channel *channel, struct t_irc_nick *nick)\n{\n    struct t_irc_nick *ptr_nick;\n\n    if (!channel || !nick)\n        return 0;\n\n    for (ptr_nick = channel->nicks; ptr_nick; ptr_nick = ptr_nick->next_nick)\n    {\n        if (ptr_nick == nick)\n            return 1;\n    }\n\n    /* nick not found */\n    return 0;\n}\n\n/*\n * Checks if string is a valid nick string (RFC 1459).\n *\n * Returns:\n *   1: string is a valid nick\n *   0: string is not a valid nick\n */\n\nint\nirc_nick_is_nick (const char *string)\n{\n    const char *ptr;\n\n    if (!string || !string[0])\n        return 0;\n\n    /* first char must not be a number or hyphen */\n    ptr = string;\n    if (strchr (\"0123456789-\", *ptr))\n        return 0;\n\n    while (ptr && ptr[0])\n    {\n        if (!strchr (IRC_NICK_VALID_CHARS, *ptr))\n            return 0;\n        ptr++;\n    }\n\n    return 1;\n}\n\n/*\n * Finds a color code for a nick (according to nick letters).\n *\n * Returns a WeeChat color code (that can be used for display).\n */\n\nchar *\nirc_nick_find_color (const char *nickname)\n{\n    return weechat_info_get (\"nick_color\", nickname);\n}\n\n/*\n * Finds a color name for a nick (according to nick letters).\n *\n * Returns the name of a color (for example: \"green\").\n */\n\nchar *\nirc_nick_find_color_name (const char *nickname)\n{\n    return weechat_info_get (\"nick_color_name\", nickname);\n}\n\n/*\n * Sets current prefix, using higher prefix set in prefixes.\n */\n\nvoid\nirc_nick_set_current_prefix (struct t_irc_nick *nick)\n{\n    char *ptr_prefixes;\n\n    if (!nick)\n        return;\n\n    nick->prefix[0] = ' ';\n    for (ptr_prefixes = nick->prefixes; ptr_prefixes[0]; ptr_prefixes++)\n    {\n        if (ptr_prefixes[0] != ' ')\n        {\n            nick->prefix[0] = ptr_prefixes[0];\n            break;\n        }\n    }\n}\n\n/*\n * Sets/unsets a prefix in prefixes.\n *\n * If set == 1, sets prefix (prefix is used).\n * If set == 0, unsets prefix (space is used).\n */\n\nvoid\nirc_nick_set_prefix (struct t_irc_server *server, struct t_irc_nick *nick,\n                     int set, char prefix)\n{\n    int index;\n\n    if (!nick)\n        return;\n\n    index = irc_server_get_prefix_char_index (server, prefix);\n    if (index >= 0)\n    {\n        nick->prefixes[index] = (set) ? prefix : ' ';\n        irc_nick_set_current_prefix (nick);\n    }\n}\n\n/*\n * Sets prefixes for nick.\n */\n\nvoid\nirc_nick_set_prefixes (struct t_irc_server *server, struct t_irc_nick *nick,\n                       const char *prefixes)\n{\n    const char *ptr_prefixes;\n\n    if (!nick)\n        return;\n\n    /* reset all prefixes in nick */\n    memset (nick->prefixes, ' ', strlen (nick->prefixes));\n\n    /* add prefixes in nick */\n    if (prefixes)\n    {\n        for (ptr_prefixes = prefixes; ptr_prefixes[0]; ptr_prefixes++)\n        {\n            irc_nick_set_prefix (server, nick, 1, ptr_prefixes[0]);\n        }\n    }\n\n    /* set current prefix */\n    irc_nick_set_current_prefix (nick);\n}\n\n/*\n * Sets host for nick.\n */\n\nvoid\nirc_nick_set_host (struct t_irc_nick *nick, const char *host)\n{\n    if (!nick)\n        return;\n\n    /* if host is the same, just return */\n    if ((!nick->host && !host)\n        || (nick->host && host && strcmp (nick->host, host) == 0))\n    {\n        return;\n    }\n\n    /* update the host in nick */\n    if (nick->host)\n        free (nick->host);\n    nick->host = (host) ? strdup (host) : NULL;\n}\n\n/*\n * Checks if nick is \"op\" (or better than \"op\", for example channel admin or\n * channel owner).\n *\n * Returns:\n *   1: nick is \"op\" (or better)\n *   0: nick is not op\n */\n\nint\nirc_nick_is_op (struct t_irc_server *server, struct t_irc_nick *nick)\n{\n    int index;\n\n    if (nick->prefix[0] == ' ')\n        return 0;\n\n    index = irc_server_get_prefix_char_index (server, nick->prefix[0]);\n    if (index < 0)\n        return 0;\n\n    return (index <= irc_server_get_prefix_mode_index (server, 'o')) ? 1 : 0;\n}\n\n/*\n * Checks if nick prefixes contains prefix for a given mode.\n *\n * For example if prefix_mode is 'o', searches for '@' in nick prefixes.\n *\n * Returns:\n *   1: prefixes contains prefix for the given mode\n *   0: prefixes does not contain prefix for the given mode.\n */\n\nint\nirc_nick_has_prefix_mode (struct t_irc_server *server, struct t_irc_nick *nick,\n                          char prefix_mode)\n{\n    char prefix_char;\n\n    prefix_char = irc_server_get_prefix_char_for_mode (server, prefix_mode);\n    if (prefix_char == ' ')\n        return 0;\n\n    return (strchr (nick->prefixes, prefix_char)) ? 1 : 0;\n}\n\n/*\n * Gets nicklist group for a nick.\n */\n\nstruct t_gui_nick_group *\nirc_nick_get_nicklist_group (struct t_irc_server *server,\n                             struct t_gui_buffer *buffer,\n                             struct t_irc_nick *nick)\n{\n    int index;\n    char str_group[2];\n    const char *prefix_modes;\n    struct t_gui_nick_group *ptr_group;\n\n    if (!server || !buffer || !nick)\n        return NULL;\n\n    ptr_group = NULL;\n    index = irc_server_get_prefix_char_index (server, nick->prefix[0]);\n    if (index < 0)\n    {\n        ptr_group = weechat_nicklist_search_group (buffer, NULL,\n                                                   IRC_NICK_GROUP_OTHER_NAME);\n    }\n    else\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        str_group[0] = prefix_modes[index];\n        str_group[1] = '\\0';\n        ptr_group = weechat_nicklist_search_group (buffer, NULL, str_group);\n    }\n\n    return ptr_group;\n}\n\n/*\n * Gets name of prefix color for a nick.\n */\n\nconst char *\nirc_nick_get_prefix_color_name (struct t_irc_server *server, char prefix)\n{\n    static char *default_color = \"\";\n    const char *prefix_modes, *color;\n    char mode[2];\n    int index;\n\n    if (irc_config_hashtable_nick_prefixes)\n    {\n        mode[0] = ' ';\n        mode[1] = '\\0';\n\n        index = irc_server_get_prefix_char_index (server, prefix);\n        if (index >= 0)\n        {\n            prefix_modes = irc_server_get_prefix_modes (server);\n            mode[0] = prefix_modes[index];\n            color = weechat_hashtable_get (irc_config_hashtable_nick_prefixes,\n                                           mode);\n            if (color)\n                return color;\n        }\n\n        /* fallback to \"*\" if no color is found with mode */\n        mode[0] = '*';\n        color = weechat_hashtable_get (irc_config_hashtable_nick_prefixes,\n                                       mode);\n        if (color)\n            return color;\n    }\n\n    /* no color by default */\n    return default_color;\n}\n\n/*\n * Gets nick color for nicklist.\n */\n\nchar *\nirc_nick_get_color_for_nicklist (struct t_irc_server *server,\n                                 struct t_irc_nick *nick)\n{\n    static char *nick_color_bar_fg = \"bar_fg\";\n    static char *nick_color_self = \"weechat.color.chat_nick_self\";\n    static char *nick_color_away = \"weechat.color.nicklist_away\";\n\n    if (nick->away)\n        return strdup (nick_color_away);\n\n    if (weechat_config_boolean (irc_config_look_color_nicks_in_nicklist))\n    {\n        if (irc_server_strcasecmp (server, nick->name, server->nick) == 0)\n            return strdup (nick_color_self);\n        else\n            return irc_nick_find_color_name (nick->name);\n    }\n\n    return strdup (nick_color_bar_fg);\n}\n\n/*\n * Adds a nick to buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_add (struct t_irc_server *server,\n                       struct t_irc_channel *channel,\n                       struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n    char *color;\n\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    color = irc_nick_get_color_for_nicklist (server, nick);\n    weechat_nicklist_add_nick (channel->buffer, ptr_group,\n                               nick->name,\n                               color,\n                               nick->prefix,\n                               irc_nick_get_prefix_color_name (server, nick->prefix[0]),\n                               1);\n    if (color)\n        free (color);\n}\n\n/*\n * Removes a nick from buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_remove (struct t_irc_server *server,\n                          struct t_irc_channel *channel,\n                          struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    weechat_nicklist_remove_nick (channel->buffer,\n                                  weechat_nicklist_search_nick (channel->buffer,\n                                                                ptr_group,\n                                                                nick->name));\n}\n\n/*\n * Sets a property for nick in buffer nicklist.\n */\n\nvoid\nirc_nick_nicklist_set (struct t_irc_channel *channel,\n                       struct t_irc_nick *nick,\n                       const char *property, const char *value)\n{\n    struct t_gui_nick *ptr_nick;\n\n    ptr_nick = weechat_nicklist_search_nick (channel->buffer, NULL, nick->name);\n    if (ptr_nick)\n    {\n        weechat_nicklist_nick_set (channel->buffer, ptr_nick, property, value);\n    }\n}\n\n/*\n * Sets nick prefix colors in nicklist for all servers/channels.\n */\n\nvoid\nirc_nick_nicklist_set_prefix_color_all ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            for (ptr_nick = ptr_channel->nicks; ptr_nick;\n                 ptr_nick = ptr_nick->next_nick)\n            {\n                irc_nick_nicklist_set (ptr_channel, ptr_nick, \"prefix_color\",\n                                       irc_nick_get_prefix_color_name (ptr_server,\n                                                                       ptr_nick->prefix[0]));\n            }\n        }\n    }\n}\n\n/*\n * Sets nick colors in nicklist for all servers/channels.\n */\n\nvoid\nirc_nick_nicklist_set_color_all ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *color;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            for (ptr_nick = ptr_channel->nicks; ptr_nick;\n                 ptr_nick = ptr_nick->next_nick)\n            {\n                color = irc_nick_get_color_for_nicklist (ptr_server, ptr_nick);\n                irc_nick_nicklist_set (ptr_channel, ptr_nick, \"color\", color);\n                if (color)\n                    free (color);\n            }\n        }\n    }\n}\n\n/*\n * Adds a new nick in channel.\n *\n * Returns pointer to new nick, NULL if error.\n */\n\nstruct t_irc_nick *\nirc_nick_new (struct t_irc_server *server, struct t_irc_channel *channel,\n              const char *nickname, const char *host, const char *prefixes,\n              int away, const char *account, const char *realname)\n{\n    struct t_irc_nick *new_nick, *ptr_nick;\n    int length;\n\n    if (!nickname || !nickname[0])\n        return NULL;\n\n    if (!channel->nicks)\n        irc_channel_add_nicklist_groups (server, channel);\n\n    /* nick already exists on this channel? */\n    ptr_nick = irc_nick_search (server, channel, nickname);\n    if (ptr_nick)\n    {\n        /* remove old nick from nicklist */\n        irc_nick_nicklist_remove (server, channel, ptr_nick);\n\n        /* update nick prefixes */\n        irc_nick_set_prefixes (server, ptr_nick, prefixes);\n\n        /* add new nick in nicklist */\n        irc_nick_nicklist_add (server, channel, ptr_nick);\n\n        return ptr_nick;\n    }\n\n    /* alloc memory for new nick */\n    if ((new_nick = malloc (sizeof (*new_nick))) == NULL)\n        return NULL;\n\n    /* initialize new nick */\n    new_nick->name = strdup (nickname);\n    new_nick->host = (host) ? strdup (host) : NULL;\n    new_nick->account = (account) ? strdup (account) : NULL;\n    new_nick->realname = (realname) ? strdup (realname) : NULL;\n    length = strlen (irc_server_get_prefix_chars (server));\n    new_nick->prefixes = malloc (length + 1);\n    new_nick->prefix = malloc (2);\n    if (!new_nick->name || !new_nick->prefixes || !new_nick->prefix)\n    {\n        if (new_nick->name)\n            free (new_nick->name);\n        if (new_nick->host)\n            free (new_nick->host);\n        if (new_nick->account)\n            free (new_nick->account);\n        if (new_nick->realname)\n            free (new_nick->realname);\n        if (new_nick->prefixes)\n            free (new_nick->prefixes);\n        if (new_nick->prefix)\n            free (new_nick->prefix);\n        free (new_nick);\n        return NULL;\n    }\n    memset (new_nick->prefixes, ' ', length);\n    new_nick->prefixes[length] = '\\0';\n    new_nick->prefix[0] = ' ';\n    new_nick->prefix[1] = '\\0';\n    irc_nick_set_prefixes (server, new_nick, prefixes);\n    new_nick->away = away;\n    if (irc_server_strcasecmp (server, new_nick->name, server->nick) == 0)\n        new_nick->color = strdup (IRC_COLOR_CHAT_NICK_SELF);\n    else\n        new_nick->color = irc_nick_find_color (new_nick->name);\n\n    /* add nick to end of list */\n    new_nick->prev_nick = channel->last_nick;\n    if (channel->last_nick)\n        channel->last_nick->next_nick = new_nick;\n    else\n        channel->nicks = new_nick;\n    channel->last_nick = new_nick;\n    new_nick->next_nick = NULL;\n\n    channel->nicks_count++;\n\n    channel->nick_completion_reset = 1;\n\n    /* add nick to buffer nicklist */\n    irc_nick_nicklist_add (server, channel, new_nick);\n\n    /* all is OK, return address of new nick */\n    return new_nick;\n}\n\n/*\n * Changes nickname.\n */\n\nvoid\nirc_nick_change (struct t_irc_server *server, struct t_irc_channel *channel,\n                 struct t_irc_nick *nick, const char *new_nick)\n{\n    int nick_is_me;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* update nicks speaking */\n    nick_is_me = (irc_server_strcasecmp (server, new_nick, server->nick) == 0) ? 1 : 0;\n    if (!nick_is_me)\n        irc_channel_nick_speaking_rename (channel, nick->name, new_nick);\n\n    /* change nickname */\n    if (nick->name)\n        free (nick->name);\n    nick->name = strdup (new_nick);\n    if (nick->color)\n        free (nick->color);\n    if (nick_is_me)\n        nick->color = strdup (IRC_COLOR_CHAT_NICK_SELF);\n    else\n        nick->color = irc_nick_find_color (nick->name);\n\n    /* add nick in nicklist */\n    irc_nick_nicklist_add (server, channel, nick);\n}\n\n/*\n * Sets a mode for a nick.\n */\n\nvoid\nirc_nick_set_mode (struct t_irc_server *server, struct t_irc_channel *channel,\n                   struct t_irc_nick *nick, int set, char mode)\n{\n    int index;\n    const char *prefix_chars;\n\n    index = irc_server_get_prefix_mode_index (server, mode);\n    if (index < 0)\n        return;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* set flag */\n    prefix_chars = irc_server_get_prefix_chars (server);\n    irc_nick_set_prefix (server, nick, set, prefix_chars[index]);\n\n    /* add nick in nicklist */\n    irc_nick_nicklist_add (server, channel, nick);\n\n    if (irc_server_strcasecmp (server, nick->name, server->nick) == 0)\n    {\n        weechat_bar_item_update (\"input_prompt\");\n        weechat_bar_item_update (\"irc_nick\");\n        weechat_bar_item_update (\"irc_nick_host\");\n    }\n}\n\n/*\n * Reallocates the \"prefixes\" string in all nicks of all channels on the server\n * (after 005 has been received).\n */\n\nvoid\nirc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}\n\n/*\n * Removes a nick from a channel.\n */\n\nvoid\nirc_nick_free (struct t_irc_server *server, struct t_irc_channel *channel,\n               struct t_irc_nick *nick)\n{\n    struct t_irc_nick *new_nicks;\n\n    if (!channel || !nick)\n        return;\n\n    /* remove nick from nicklist */\n    irc_nick_nicklist_remove (server, channel, nick);\n\n    /* remove nick */\n    if (channel->last_nick == nick)\n        channel->last_nick = nick->prev_nick;\n    if (nick->prev_nick)\n    {\n        (nick->prev_nick)->next_nick = nick->next_nick;\n        new_nicks = channel->nicks;\n    }\n    else\n        new_nicks = nick->next_nick;\n\n    if (nick->next_nick)\n        (nick->next_nick)->prev_nick = nick->prev_nick;\n\n    channel->nicks_count--;\n\n    /* free data */\n    if (nick->name)\n        free (nick->name);\n    if (nick->host)\n        free (nick->host);\n    if (nick->prefixes)\n        free (nick->prefixes);\n    if (nick->prefix)\n        free (nick->prefix);\n    if (nick->account)\n        free (nick->account);\n    if (nick->realname)\n        free (nick->realname);\n    if (nick->color)\n        free (nick->color);\n\n    free (nick);\n\n    channel->nicks = new_nicks;\n    channel->nick_completion_reset = 1;\n}\n\n/*\n * Removes all nicks from a channel.\n */\n\nvoid\nirc_nick_free_all (struct t_irc_server *server, struct t_irc_channel *channel)\n{\n    if (!channel)\n        return;\n\n    /* remove all nicks for the channel */\n    while (channel->nicks)\n    {\n        irc_nick_free (server, channel, channel->nicks);\n    }\n\n    /* remove all groups in nicklist */\n    weechat_nicklist_remove_all (channel->buffer);\n\n    /* should be zero, but prevent any bug :D */\n    channel->nicks_count = 0;\n}\n\n/*\n * Searches for a nick in a channel.\n *\n * Returns pointer to nick found, NULL if error.\n */\n\nstruct t_irc_nick *\nirc_nick_search (struct t_irc_server *server, struct t_irc_channel *channel,\n                 const char *nickname)\n{\n    struct t_irc_nick *ptr_nick;\n\n    if (!channel || !nickname)\n        return NULL;\n\n    for (ptr_nick = channel->nicks; ptr_nick;\n         ptr_nick = ptr_nick->next_nick)\n    {\n        if (irc_server_strcasecmp (server, ptr_nick->name, nickname) == 0)\n            return ptr_nick;\n    }\n\n    /* nick not found */\n    return NULL;\n}\n\n/*\n * Returns number of nicks (total, op, halfop, voice, normal) on a channel.\n */\n\nvoid\nirc_nick_count (struct t_irc_server *server, struct t_irc_channel *channel,\n                int *total, int *count_op, int *count_halfop, int *count_voice,\n                int *count_normal)\n{\n    struct t_irc_nick *ptr_nick;\n\n    (*total) = 0;\n    (*count_op) = 0;\n    (*count_halfop) = 0;\n    (*count_voice) = 0;\n    (*count_normal) = 0;\n    for (ptr_nick = channel->nicks; ptr_nick;\n         ptr_nick = ptr_nick->next_nick)\n    {\n        (*total)++;\n        if (irc_nick_is_op (server, ptr_nick))\n            (*count_op)++;\n        else\n        {\n            if (irc_nick_has_prefix_mode (server, ptr_nick, 'h'))\n                (*count_halfop)++;\n            else\n            {\n                if (irc_nick_has_prefix_mode (server, ptr_nick, 'v'))\n                    (*count_voice)++;\n                else\n                    (*count_normal)++;\n            }\n        }\n    }\n}\n\n/*\n * Sets/unsets away status for a nick.\n */\n\nvoid\nirc_nick_set_away (struct t_irc_server *server, struct t_irc_channel *channel,\n                   struct t_irc_nick *nick, int is_away)\n{\n    char *color;\n\n    if (is_away != nick->away)\n    {\n        nick->away = is_away;\n        color = irc_nick_get_color_for_nicklist (server, nick);\n        irc_nick_nicklist_set (channel, nick, \"color\", color);\n        if (color)\n            free (color);\n    }\n}\n\n/*\n * Gets nick mode for display (color + mode).\n *\n * If prefix == 1, returns string for display in prefix, otherwise returns\n * string for display in action message (/me).\n */\n\nconst char *\nirc_nick_mode_for_display (struct t_irc_server *server, struct t_irc_nick *nick,\n                           int prefix)\n{\n    static char result[32];\n    char str_prefix[2];\n    int nick_mode;\n    const char *str_prefix_color;\n\n    str_prefix[0] = (nick) ? nick->prefix[0] : '\\0';\n    str_prefix[1] = '\\0';\n\n    nick_mode = weechat_config_integer (irc_config_look_nick_mode);\n    if ((nick_mode == IRC_CONFIG_LOOK_NICK_MODE_BOTH)\n        || (prefix && (nick_mode == IRC_CONFIG_LOOK_NICK_MODE_PREFIX))\n        || (!prefix && (nick_mode == IRC_CONFIG_LOOK_NICK_MODE_ACTION)))\n    {\n        if (nick)\n        {\n            if ((str_prefix[0] == ' ')\n                && (!prefix || !weechat_config_boolean (irc_config_look_nick_mode_empty)))\n            {\n                str_prefix[0] = '\\0';\n            }\n            str_prefix_color = weechat_color (\n                irc_nick_get_prefix_color_name (server, nick->prefix[0]));\n        }\n        else\n        {\n            str_prefix[0] = (prefix\n                             && weechat_config_boolean (irc_config_look_nick_mode_empty)) ?\n                ' ' : '\\0';\n            str_prefix_color = IRC_COLOR_RESET;\n        }\n    }\n    else\n    {\n        str_prefix[0] = '\\0';\n        str_prefix_color = IRC_COLOR_RESET;\n    }\n\n    snprintf (result, sizeof (result), \"%s%s\", str_prefix_color, str_prefix);\n\n    return result;\n}\n\n/*\n * Returns string with nick to display as prefix on buffer (returned string ends\n * by a tab).\n */\n\nconst char *\nirc_nick_as_prefix (struct t_irc_server *server, struct t_irc_nick *nick,\n                    const char *nickname, const char *force_color)\n{\n    static char result[256];\n    char *color;\n\n    if (force_color)\n        color = strdup (force_color);\n    else if (nick)\n        color = strdup (nick->color);\n    else if (nickname)\n        color = irc_nick_find_color (nickname);\n    else\n        color = strdup (IRC_COLOR_CHAT_NICK);\n\n    snprintf (result, sizeof (result), \"%s%s%s\\t\",\n              irc_nick_mode_for_display (server, nick, 1),\n              color,\n              (nick) ? nick->name : nickname);\n\n    if (color)\n        free (color);\n\n    return result;\n}\n\n/*\n * Returns WeeChat color code for a nick.\n */\n\nconst char *\nirc_nick_color_for_msg (struct t_irc_server *server, int server_message,\n                        struct t_irc_nick *nick, const char *nickname)\n{\n    static char color[16][64];\n    static int index_color = 0;\n    char *color_found;\n\n    if (server_message\n        && !weechat_config_boolean (irc_config_look_color_nicks_in_server_messages))\n    {\n        return IRC_COLOR_CHAT_NICK;\n    }\n\n    if (nick)\n        return nick->color;\n\n    if (nickname)\n    {\n        if (server\n            && (irc_server_strcasecmp (server, nickname, server->nick) == 0))\n        {\n            return IRC_COLOR_CHAT_NICK_SELF;\n        }\n        color_found = irc_nick_find_color (nickname);\n        index_color = (index_color + 1) % 16;\n        snprintf (color[index_color], sizeof (color[index_color]),\n                  \"%s\",\n                  color_found);\n        if (color_found)\n            free (color_found);\n        return color[index_color];\n    }\n\n    return IRC_COLOR_CHAT_NICK;\n}\n\n/*\n * Returns string with color of nick for private.\n */\n\nconst char *\nirc_nick_color_for_pv (struct t_irc_channel *channel, const char *nickname)\n{\n    if (weechat_config_boolean (irc_config_look_color_pv_nick_like_channel))\n    {\n        if (!channel->pv_remote_nick_color)\n            channel->pv_remote_nick_color = irc_nick_find_color (nickname);\n        if (channel->pv_remote_nick_color)\n            return channel->pv_remote_nick_color;\n    }\n\n    return IRC_COLOR_CHAT_NICK_OTHER;\n}\n\n/*\n * Returns default ban mask for the nick.\n *\n * Note: result must be freed after use (if not NULL).\n */\n\nchar *\nirc_nick_default_ban_mask (struct t_irc_nick *nick)\n{\n    const char *ptr_ban_mask;\n    char *pos_hostname, user[128], ident[128], *res, *temp;\n\n    if (!nick)\n        return NULL;\n\n    ptr_ban_mask = weechat_config_string (irc_config_network_ban_mask_default);\n\n    pos_hostname = (nick->host) ? strchr (nick->host, '@') : NULL;\n\n    if (!nick->host || !pos_hostname || !ptr_ban_mask || !ptr_ban_mask[0])\n        return NULL;\n\n    if (pos_hostname - nick->host > (int)sizeof (user) - 1)\n        return NULL;\n\n    strncpy (user, nick->host, pos_hostname - nick->host);\n    user[pos_hostname - nick->host] = '\\0';\n    strcpy (ident, (user[0] != '~') ? user : \"*\");\n    pos_hostname++;\n\n    /* replace nick */\n    temp = weechat_string_replace (ptr_ban_mask, \"$nick\", nick->name);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace user */\n    temp = weechat_string_replace (res, \"$user\", user);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace ident */\n    temp = weechat_string_replace (res, \"$ident\", ident);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /* replace hostname */\n    temp = weechat_string_replace (res, \"$host\", pos_hostname);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    return res;\n}\n\n/*\n * Returns hdata for nick.\n */\n\nstruct t_hdata *\nirc_nick_hdata_nick_cb (const void *pointer, void *data,\n                        const char *hdata_name)\n{\n    struct t_hdata *hdata;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n\n    hdata = weechat_hdata_new (hdata_name, \"prev_nick\", \"next_nick\",\n                               0, 0, NULL, NULL);\n    if (hdata)\n    {\n        WEECHAT_HDATA_VAR(struct t_irc_nick, name, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, host, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prefixes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prefix, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, away, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, account, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, realname, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, color, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, prev_nick, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_VAR(struct t_irc_nick, next_nick, POINTER, 0, NULL, hdata_name);\n    }\n    return hdata;\n}\n\n/*\n * Adds a nick in an infolist.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_nick_add_to_infolist (struct t_infolist *infolist,\n                          struct t_irc_nick *nick)\n{\n    struct t_infolist_item *ptr_item;\n\n    if (!infolist || !nick)\n        return 0;\n\n    ptr_item = weechat_infolist_new_item (infolist);\n    if (!ptr_item)\n        return 0;\n\n    if (!weechat_infolist_new_var_string (ptr_item, \"name\", nick->name))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"host\", nick->host))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefixes\", nick->prefixes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix\", nick->prefix))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away\", nick->away))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"account\", nick->account))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"realname\", nick->realname))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"color\", nick->color))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Prints nick infos in WeeChat log file (usually for crash dump).\n */\n\nvoid\nirc_nick_print_log (struct t_irc_nick *nick)\n{\n    weechat_log_printf (\"\");\n    weechat_log_printf (\"    => nick %s (addr:0x%lx):\",    nick->name, nick);\n    weechat_log_printf (\"         host . . . . . : '%s'\",  nick->host);\n    weechat_log_printf (\"         prefixes . . . : '%s'\",  nick->prefixes);\n    weechat_log_printf (\"         prefix . . . . : '%s'\",  nick->prefix);\n    weechat_log_printf (\"         away . . . . . : %d\",    nick->away);\n    weechat_log_printf (\"         account. . . . : '%s'\",  nick->account);\n    weechat_log_printf (\"         realname . . . : '%s'\",  nick->realname);\n    weechat_log_printf (\"         color. . . . . : '%s'\",  nick->color);\n    weechat_log_printf (\"         prev_nick. . . : 0x%lx\", nick->prev_nick);\n    weechat_log_printf (\"         next_nick. . . : 0x%lx\", nick->next_nick);\n}\n", "/*\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#ifndef WEECHAT_PLUGIN_IRC_NICK_H\n#define WEECHAT_PLUGIN_IRC_NICK_H\n\n#define IRC_NICK_VALID_CHARS \"abcdefghijklmnopqrstuvwxyzABCDEFGHI\"      \\\n    \"JKLMNOPQRSTUVWXYZ0123456789-[]\\\\`_^{|}\"\n\n/* nicklist group for nicks without prefix is \"999|...\" */\n#define IRC_NICK_GROUP_OTHER_NUMBER 999\n#define IRC_NICK_GROUP_OTHER_NAME   \"...\"\n\nstruct t_irc_server;\nstruct t_irc_channel;\n\nstruct t_irc_nick\n{\n    char *name;                     /* nickname                              */\n    char *host;                     /* full hostname                         */\n    char *prefixes;                 /* string with prefixes enabled for nick */\n    char *prefix;                   /* current prefix (higher prefix set in  */\n                                    /* prefixes); string with just one char  */\n    int away;                       /* 1 if nick is away                     */\n    char *account;                  /* account name of the user              */\n    char *realname;                 /* realname (aka gecos) of the user      */\n    char *color;                    /* color for nickname                    */\n    struct t_irc_nick *prev_nick;   /* link to previous nick on channel      */\n    struct t_irc_nick *next_nick;   /* link to next nick on channel          */\n};\n\nextern int irc_nick_valid (struct t_irc_channel *channel,\n                           struct t_irc_nick *nick);\nextern int irc_nick_is_nick (const char *string);\nextern char *irc_nick_find_color (const char *nickname);\nextern char *irc_nick_find_color_name (const char *nickname);\nextern void irc_nick_set_host (struct t_irc_nick *nick, const char *host);\nextern int irc_nick_is_op (struct t_irc_server *server,\n                           struct t_irc_nick *nick);\nextern int irc_nick_has_prefix_mode (struct t_irc_server *server,\n                                     struct t_irc_nick *nick,\n                                     char prefix_mode);\nextern const char *irc_nick_get_prefix_color_name (struct t_irc_server *server,\n                                                   char prefix);\nextern void irc_nick_nicklist_set_prefix_color_all ();\nextern void irc_nick_nicklist_set_color_all ();\nextern struct t_irc_nick *irc_nick_new (struct t_irc_server *server,\n                                        struct t_irc_channel *channel,\n                                        const char *nickname,\n                                        const char *host,\n                                        const char *prefixes,\n                                        int away,\n                                        const char *account,\n                                        const char *realname);\nextern void irc_nick_change (struct t_irc_server *server,\n                             struct t_irc_channel *channel,\n                             struct t_irc_nick *nick, const char *new_nick);\nextern void irc_nick_set_mode (struct t_irc_server *server,\n                               struct t_irc_channel *channel,\n                               struct t_irc_nick *nick, int set, char mode);\nextern void irc_nick_realloc_prefixes (struct t_irc_server *server,\n                                       int old_length, int new_length);\nextern void irc_nick_free (struct t_irc_server *server,\n                           struct t_irc_channel *channel,\n                           struct t_irc_nick *nick);\nextern void irc_nick_free_all (struct t_irc_server *server,\n                               struct t_irc_channel *channel);\nextern struct t_irc_nick *irc_nick_search (struct t_irc_server *server,\n                                           struct t_irc_channel *channel,\n                                           const char *nickname);\nextern void irc_nick_count (struct t_irc_server *server,\n                            struct t_irc_channel *channel, int *total,\n                            int *count_op, int *count_halfop, int *count_voice,\n                            int *count_normal);\nextern void irc_nick_set_away (struct t_irc_server *server,\n                               struct t_irc_channel *channel,\n                               struct t_irc_nick *nick, int is_away);\nextern const char *irc_nick_mode_for_display (struct t_irc_server *server,\n                                              struct t_irc_nick *nick,\n                                              int prefix);\nextern const char *irc_nick_as_prefix (struct t_irc_server *server,\n                                       struct t_irc_nick *nick,\n                                       const char *nickname,\n                                       const char *force_color);\nextern const char *irc_nick_color_for_msg (struct t_irc_server *server,\n                                           int server_message,\n                                           struct t_irc_nick *nick,\n                                           const char *nickname);\nextern const char * irc_nick_color_for_pv (struct t_irc_channel *channel,\n                                           const char *nickname);\nextern char *irc_nick_default_ban_mask (struct t_irc_nick *nick);\nextern struct t_hdata *irc_nick_hdata_nick_cb (const void *pointer,\n                                               void *data,\n                                               const char *hdata_name);\nextern int irc_nick_add_to_infolist (struct t_infolist *infolist,\n                                     struct t_irc_nick *nick);\nextern void irc_nick_print_log (struct t_irc_nick *nick);\n\n#endif /* WEECHAT_PLUGIN_IRC_NICK_H */\n", "/*\n * irc-server.c - I/O communication with IRC servers\n *\n * Copyright (C) 2003-2020 S\u00e9bastien Helleu <flashcode@flashtux.org>\n * Copyright (C) 2005-2010 Emmanuel Bouthenot <kolter@openics.org>\n * Copyright (C) 2012 Simon Arlott\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#ifdef _WIN32\n#include <winsock.h>\n#else\n#include <sys/socket.h>\n#include <sys/time.h>\n#endif /* _WIN32 */\n#include <sys/types.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\n\n#ifdef HAVE_GNUTLS\n#include <gnutls/gnutls.h>\n#include <gnutls/x509.h>\n#endif /* HAVE_GNUTLS */\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-server.h\"\n#include \"irc-bar-item.h\"\n#include \"irc-buffer.h\"\n#include \"irc-channel.h\"\n#include \"irc-color.h\"\n#include \"irc-command.h\"\n#include \"irc-config.h\"\n#include \"irc-input.h\"\n#include \"irc-message.h\"\n#include \"irc-nick.h\"\n#include \"irc-notify.h\"\n#include \"irc-protocol.h\"\n#include \"irc-raw.h\"\n#include \"irc-redirect.h\"\n#include \"irc-sasl.h\"\n\n\nstruct t_irc_server *irc_servers = NULL;\nstruct t_irc_server *last_irc_server = NULL;\n\nstruct t_irc_message *irc_recv_msgq = NULL;\nstruct t_irc_message *irc_msgq_last_msg = NULL;\n\nchar *irc_server_sasl_fail_string[IRC_SERVER_NUM_SASL_FAIL] =\n{ \"continue\", \"reconnect\", \"disconnect\" };\n\nchar *irc_server_options[IRC_SERVER_NUM_OPTIONS][2] =\n{ { \"addresses\",            \"\"                        },\n  { \"proxy\",                \"\"                        },\n  { \"ipv6\",                 \"on\"                      },\n  { \"ssl\",                  \"off\"                     },\n  { \"ssl_cert\",             \"\"                        },\n  { \"ssl_password\",         \"\"                        },\n  { \"ssl_priorities\",       \"NORMAL:-VERS-SSL3.0\"     },\n  { \"ssl_dhkey_size\",       \"2048\"                    },\n  { \"ssl_fingerprint\",      \"\"                        },\n  { \"ssl_verify\",           \"on\"                      },\n  { \"password\",             \"\"                        },\n  { \"capabilities\",         \"\"                        },\n  { \"sasl_mechanism\",       \"plain\"                   },\n  { \"sasl_username\",        \"\"                        },\n  { \"sasl_password\",        \"\"                        },\n  { \"sasl_key\",             \"\",                       },\n  { \"sasl_timeout\",         \"15\"                      },\n  { \"sasl_fail\",            \"continue\"                },\n  { \"autoconnect\",          \"off\"                     },\n  { \"autoreconnect\",        \"on\"                      },\n  { \"autoreconnect_delay\",  \"10\"                      },\n  { \"nicks\",                \"\"                        },\n  { \"nicks_alternate\",      \"on\"                      },\n  { \"username\",             \"\"                        },\n  { \"realname\",             \"\"                        },\n  { \"local_hostname\",       \"\"                        },\n  { \"usermode\",             \"\"                        },\n  { \"command\",              \"\"                        },\n  { \"command_delay\",        \"0\"                       },\n  { \"autojoin\",             \"\"                        },\n  { \"autorejoin\",           \"off\"                     },\n  { \"autorejoin_delay\",     \"30\"                      },\n  { \"connection_timeout\",   \"60\"                      },\n  { \"anti_flood_prio_high\", \"2\"                       },\n  { \"anti_flood_prio_low\",  \"2\"                       },\n  { \"away_check\",           \"0\"                       },\n  { \"away_check_max_nicks\", \"25\"                      },\n  { \"msg_kick\",             \"\"                        },\n  { \"msg_part\",             \"WeeChat ${info:version}\" },\n  { \"msg_quit\",             \"WeeChat ${info:version}\" },\n  { \"notify\",               \"\"                        },\n  { \"split_msg_max_length\", \"512\"                     },\n  { \"charset_message\",      \"message\"                 },\n};\n\nchar *irc_server_casemapping_string[IRC_SERVER_NUM_CASEMAPPING] =\n{ \"rfc1459\", \"strict-rfc1459\", \"ascii\" };\n\nchar *irc_server_prefix_modes_default = \"ov\";\nchar *irc_server_prefix_chars_default = \"@+\";\nchar *irc_server_chanmodes_default    = \"beI,k,l\";\n\nconst char *irc_server_send_default_tags = NULL;  /* default tags when       */\n                                                  /* sending a message       */\n\n#ifdef HAVE_GNUTLS\ngnutls_digest_algorithm_t irc_fingerprint_digest_algos[IRC_FINGERPRINT_NUM_ALGOS] =\n{ GNUTLS_DIG_SHA1, GNUTLS_DIG_SHA256, GNUTLS_DIG_SHA512 };\nchar *irc_fingerprint_digest_algos_name[IRC_FINGERPRINT_NUM_ALGOS] =\n{ \"SHA-1\", \"SHA-256\", \"SHA-512\" };\nint irc_fingerprint_digest_algos_size[IRC_FINGERPRINT_NUM_ALGOS] =\n{ 160, 256, 512 };\n#endif /* HAVE_GNUTLS */\n\n\nvoid irc_server_reconnect (struct t_irc_server *server);\nvoid irc_server_free_data (struct t_irc_server *server);\nvoid irc_server_autojoin_create_buffers (struct t_irc_server *server);\n\n\n/*\n * Checks if a server pointer is valid.\n *\n * Returns:\n *   1: server exists\n *   0: server does not exist\n */\n\nint\nirc_server_valid (struct t_irc_server *server)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server)\n        return 0;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (ptr_server == server)\n            return 1;\n    }\n\n    /* server not found */\n    return 0;\n}\n\n/*\n * Searches for a server by name.\n *\n * Returns pointer to server found, NULL if not found.\n */\n\nstruct t_irc_server *\nirc_server_search (const char *server_name)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server_name)\n        return NULL;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (strcmp (ptr_server->name, server_name) == 0)\n            return ptr_server;\n    }\n\n    /* server not found */\n    return NULL;\n}\n\n/*\n * Searches for a server by name (case insensitive).\n *\n * Returns pointer to server found, NULL if not found.\n */\n\nstruct t_irc_server *\nirc_server_casesearch (const char *server_name)\n{\n    struct t_irc_server *ptr_server;\n\n    if (!server_name)\n        return NULL;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if (weechat_strcasecmp (ptr_server->name, server_name) == 0)\n            return ptr_server;\n    }\n\n    /* server not found */\n    return NULL;\n}\n\n/*\n * Searches for a server option name.\n *\n * Returns index of option in array \"irc_server_option_string\", -1 if not found.\n */\n\nint\nirc_server_search_option (const char *option_name)\n{\n    int i;\n\n    if (!option_name)\n        return -1;\n\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        if (weechat_strcasecmp (irc_server_options[i][0], option_name) == 0)\n            return i;\n    }\n\n    /* server option not found */\n    return -1;\n}\n\n/*\n * Searches for a casemapping.\n *\n * Returns index of casemapping in array \"irc_server_casemapping_string\", -1 if\n * not found.\n */\n\nint\nirc_server_search_casemapping (const char *casemapping)\n{\n    int i;\n\n    for (i = 0; i < IRC_SERVER_NUM_CASEMAPPING; i++)\n    {\n        if (weechat_strcasecmp (irc_server_casemapping_string[i], casemapping) == 0)\n            return i;\n    }\n\n    /* casemapping not found */\n    return -1;\n}\n\n/*\n * Compares two strings on server (case insensitive, depends on casemapping).\n *\n * Returns:\n *   < 0: string1 < string2\n *     0: string1 == string2\n *   > 0: string1 > string2\n */\n\nint\nirc_server_strcasecmp (struct t_irc_server *server,\n                       const char *string1, const char *string2)\n{\n    int casemapping, rc;\n\n    casemapping = (server) ? server->casemapping : IRC_SERVER_CASEMAPPING_RFC1459;\n    switch (casemapping)\n    {\n        case IRC_SERVER_CASEMAPPING_RFC1459:\n            rc = weechat_strcasecmp_range (string1, string2, 30);\n            break;\n        case IRC_SERVER_CASEMAPPING_STRICT_RFC1459:\n            rc = weechat_strcasecmp_range (string1, string2, 29);\n            break;\n        case IRC_SERVER_CASEMAPPING_ASCII:\n            rc = weechat_strcasecmp (string1, string2);\n            break;\n        default:\n            rc = weechat_strcasecmp_range (string1, string2, 30);\n            break;\n    }\n    return rc;\n}\n\n/*\n * Compares two strings on server (case insensitive, depends on casemapping) for\n * max chars.\n *\n * Returns:\n *   < 0: string1 < string2\n *     0: string1 == string2\n *   > 0: string1 > string2\n */\n\nint\nirc_server_strncasecmp (struct t_irc_server *server,\n                        const char *string1, const char *string2, int max)\n{\n    int casemapping, rc;\n\n    casemapping = (server) ? server->casemapping : IRC_SERVER_CASEMAPPING_RFC1459;\n    switch (casemapping)\n    {\n        case IRC_SERVER_CASEMAPPING_RFC1459:\n            rc = weechat_strncasecmp_range (string1, string2, max, 30);\n            break;\n        case IRC_SERVER_CASEMAPPING_STRICT_RFC1459:\n            rc = weechat_strncasecmp_range (string1, string2, max, 29);\n            break;\n        case IRC_SERVER_CASEMAPPING_ASCII:\n            rc = weechat_strncasecmp (string1, string2, max);\n            break;\n        default:\n            rc = weechat_strncasecmp_range (string1, string2, max, 30);\n            break;\n    }\n    return rc;\n}\n\n/*\n * Evaluates a string using the server as context:\n * ${irc_server.xxx} and ${server} are replaced by a server option and the\n * server name.\n *\n * Returns the evaluated string.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_eval_expression (struct t_irc_server *server, const char *string)\n{\n    struct t_hashtable *pointers, *extra_vars;\n    char *value;\n\n    pointers = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_POINTER,\n        NULL, NULL);\n    extra_vars = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_STRING,\n        NULL, NULL);\n\n    if (server)\n    {\n        if (pointers)\n            weechat_hashtable_set (pointers, \"irc_server\", server);\n        if (extra_vars)\n            weechat_hashtable_set (extra_vars, \"server\", server->name);\n    }\n\n    value = weechat_string_eval_expression (string,\n                                            pointers, extra_vars, NULL);\n\n    if (pointers)\n        weechat_hashtable_free (pointers);\n    if (extra_vars)\n        weechat_hashtable_free (extra_vars);\n\n    return value;\n}\n\n/*\n * Evaluates and returns the fingerprint.\n *\n * Returns the evaluated fingerprint, NULL if the fingerprint option is\n * invalid.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_eval_fingerprint (struct t_irc_server *server)\n{\n#ifdef HAVE_GNUTLS\n    const char *ptr_fingerprint;\n    char *fingerprint_eval, **fingerprints, *str_sizes;\n    int i, j, rc, algo, length;\n\n    ptr_fingerprint = IRC_SERVER_OPTION_STRING(server,\n                                               IRC_SERVER_OPTION_SSL_FINGERPRINT);\n\n    /* empty fingerprint is just ignored (considered OK) */\n    if (!ptr_fingerprint || !ptr_fingerprint[0])\n        return strdup (\"\");\n\n    /* evaluate fingerprint */\n    fingerprint_eval = irc_server_eval_expression (server, ptr_fingerprint);\n    if (!fingerprint_eval || !fingerprint_eval[0])\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: the evaluated fingerprint for server \\\"%s\\\" must not be \"\n              \"empty\"),\n            weechat_prefix (\"error\"),\n            IRC_PLUGIN_NAME,\n            server->name);\n        if (fingerprint_eval)\n            free (fingerprint_eval);\n        return NULL;\n    }\n\n    /* split fingerprint */\n    fingerprints = weechat_string_split (fingerprint_eval, \",\", NULL,\n                                         WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                         | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                         | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                         0, NULL);\n    if (!fingerprints)\n        return fingerprint_eval;\n\n    rc = 0;\n    for (i = 0; fingerprints[i]; i++)\n    {\n        length = strlen (fingerprints[i]);\n        algo = irc_server_fingerprint_search_algo_with_size (length * 4);\n        if (algo < 0)\n        {\n            rc = -1;\n            break;\n        }\n        for (j = 0; j < length; j++)\n        {\n            if (!isxdigit ((unsigned char)fingerprints[i][j]))\n            {\n                rc = -2;\n                break;\n            }\n        }\n        if (rc < 0)\n            break;\n    }\n    weechat_string_free_split (fingerprints);\n    switch (rc)\n    {\n        case -1:  /* invalid size */\n            str_sizes = irc_server_fingerprint_str_sizes ();\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: invalid fingerprint size for server \\\"%s\\\", the \"\n                  \"number of hexadecimal digits must be \"\n                  \"one of: %s\"),\n                weechat_prefix (\"error\"),\n                IRC_PLUGIN_NAME,\n                server->name,\n                (str_sizes) ? str_sizes : \"?\");\n            if (str_sizes)\n                free (str_sizes);\n            free (fingerprint_eval);\n            return NULL;\n        case -2:  /* invalid content */\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: invalid fingerprint for server \\\"%s\\\", it must \"\n                  \"contain only hexadecimal digits (0-9, \"\n                  \"a-f)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n            free (fingerprint_eval);\n            return NULL;\n    }\n    return fingerprint_eval;\n#else\n    /* make C compiler happy */\n    (void) server;\n\n    return strdup (\"\");\n#endif /* HAVE_GNUTLS */\n}\n\n/*\n * Checks if SASL is enabled on server.\n *\n * Returns:\n *   1: SASL is enabled\n *   0: SASL is disabled\n */\n\nint\nirc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n\n    /*\n     * SASL is enabled if one of these conditions is true:\n     * - mechanism is \"external\"\n     * - mechanism is \"ecdsa-nist256p-challenge\" with username/key set\n     * - another mechanism with username/password set\n     */\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n\n    return rc;\n}\n\n/*\n * Gets name of server without port (ends before first '/' if found).\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n\n    if (!name)\n        return NULL;\n\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n\n    return strdup (name);\n}\n\n/*\n * Sets addresses for server.\n *\n * Returns:\n *   1: addresses have been set (changed)\n *   0: nothing set (addresses unchanged)\n */\n\nint\nirc_server_set_addresses (struct t_irc_server *server, const char *addresses)\n{\n    int i;\n    char *pos, *error, *addresses_eval;\n    long number;\n\n    addresses_eval = NULL;\n\n    if (addresses && addresses[0])\n    {\n        addresses_eval = irc_server_eval_expression (server, addresses);\n        if (server->addresses_eval\n            && (strcmp (server->addresses_eval, addresses_eval) == 0))\n        {\n            free (addresses_eval);\n            return 0;\n        }\n    }\n\n    /* free data */\n    if (server->addresses_eval)\n    {\n        free (server->addresses_eval);\n        server->addresses_eval = NULL;\n    }\n    server->addresses_count = 0;\n    if (server->addresses_array)\n    {\n        weechat_string_free_split (server->addresses_array);\n        server->addresses_array = NULL;\n    }\n    if (server->ports_array)\n    {\n        free (server->ports_array);\n        server->ports_array = NULL;\n    }\n    if (server->retry_array)\n    {\n        free (server->retry_array);\n        server->retry_array = NULL;\n    }\n\n    /* set new addresses/ports */\n    server->addresses_eval = addresses_eval;\n    if (!addresses_eval)\n        return 1;\n    server->addresses_array = weechat_string_split (\n        addresses_eval,\n        \",\",\n        \" \",\n        WEECHAT_STRING_SPLIT_STRIP_LEFT\n        | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n        | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n        0,\n        &server->addresses_count);\n    server->ports_array = malloc (\n        server->addresses_count * sizeof (server->ports_array[0]));\n    server->retry_array = malloc (\n        server->addresses_count * sizeof (server->retry_array[0]));\n    for (i = 0; i < server->addresses_count; i++)\n    {\n        pos = strchr (server->addresses_array[i], '/');\n        if (pos)\n        {\n            pos[0] = 0;\n            pos++;\n            error = NULL;\n            number = strtol (pos, &error, 10);\n            server->ports_array[i] = (error && !error[0]) ?\n                number : IRC_SERVER_DEFAULT_PORT;\n        }\n        else\n        {\n            server->ports_array[i] = IRC_SERVER_DEFAULT_PORT;\n        }\n        server->retry_array[i] = 0;\n    }\n\n    return 1;\n}\n\n\n/*\n * Sets index of current address for server.\n */\n\nvoid\nirc_server_set_index_current_address (struct t_irc_server *server, int index)\n{\n    int addresses_changed;\n\n    addresses_changed = irc_server_set_addresses (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_ADDRESSES));\n\n    if (addresses_changed)\n    {\n        /* if the addresses have changed, reset the index to 0 */\n        index = 0;\n    }\n\n    if (server->current_address)\n    {\n        free (server->current_address);\n        server->current_address = NULL;\n\n        /* copy current retry value before loading next server */\n        if (!addresses_changed\n            && server->index_current_address < server->addresses_count)\n        {\n            server->retry_array[server->index_current_address] = server->current_retry;\n        }\n    }\n    server->current_port = 0;\n    server->current_retry = 0;\n\n    if (server->addresses_count > 0)\n    {\n        index %= server->addresses_count;\n        server->index_current_address = index;\n        server->current_address = strdup (server->addresses_array[index]);\n        server->current_port = server->ports_array[index];\n        server->current_retry = server->retry_array[index];\n    }\n}\n\n/*\n * Sets nicks for server.\n */\n\nvoid\nirc_server_set_nicks (struct t_irc_server *server, const char *nicks)\n{\n    char *nicks2;\n\n    /* free data */\n    server->nicks_count = 0;\n    if (server->nicks_array)\n    {\n        weechat_string_free_split (server->nicks_array);\n        server->nicks_array = NULL;\n    }\n\n    /* evaluate value */\n    nicks2 = irc_server_eval_expression (server, nicks);\n\n    /* set new nicks */\n    server->nicks_array = weechat_string_split (\n        (nicks2) ? nicks2 : IRC_SERVER_DEFAULT_NICKS,\n        \",\",\n        NULL,\n        WEECHAT_STRING_SPLIT_STRIP_LEFT\n        | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n        | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n        0,\n        &server->nicks_count);\n\n    if (nicks2)\n        free (nicks2);\n}\n\n/*\n * Sets nickname for server.\n */\n\nvoid\nirc_server_set_nick (struct t_irc_server *server, const char *nick)\n{\n    struct t_irc_channel *ptr_channel;\n\n    /* if nick is the same, just return */\n    if ((!server->nick && !nick)\n        || (server->nick && nick && strcmp (server->nick, nick) == 0))\n    {\n        return;\n    }\n\n    /* update the nick in server */\n    if (server->nick)\n        free (server->nick);\n    server->nick = (nick) ? strdup (nick) : NULL;\n\n    /* set local variable \"nick\" for server and all channels/pv */\n    weechat_buffer_set (server->buffer, \"localvar_set_nick\", nick);\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        weechat_buffer_set (ptr_channel->buffer, \"localvar_set_nick\", nick);\n    }\n\n    weechat_bar_item_update (\"input_prompt\");\n    weechat_bar_item_update (\"irc_nick\");\n    weechat_bar_item_update (\"irc_nick_host\");\n}\n\n/*\n * Sets host for server.\n */\n\nvoid\nirc_server_set_host (struct t_irc_server *server, const char *host)\n{\n    struct t_irc_channel *ptr_channel;\n\n    /* if host is the same, just return */\n    if ((!server->host && !host)\n        || (server->host && host && strcmp (server->host, host) == 0))\n    {\n        return;\n    }\n\n    /* update the nick host in server */\n    if (server->host)\n        free (server->host);\n    server->host = (host) ? strdup (host) : NULL;\n\n    /* set local variable \"host\" for server and all channels/pv */\n    weechat_buffer_set (server->buffer, \"localvar_set_host\", host);\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        weechat_buffer_set (ptr_channel->buffer,\n                            \"localvar_set_host\", host);\n    }\n\n    weechat_bar_item_update (\"irc_host\");\n    weechat_bar_item_update (\"irc_nick_host\");\n}\n\n/*\n * Gets index of nick in array \"nicks_array\".\n *\n * Returns index of nick in array, -1 if nick is not set or not found in\n * \"nicks_array\".\n */\n\nint\nirc_server_get_nick_index (struct t_irc_server *server)\n{\n    int i;\n\n    if (!server->nick)\n        return -1;\n\n    for (i = 0; i < server->nicks_count; i++)\n    {\n        if (strcmp (server->nick, server->nicks_array[i]) == 0)\n        {\n            return i;\n        }\n    }\n\n    /* nick not found */\n    return -1;\n}\n\n/*\n * Gets an alternate nick when the nick is already used on server.\n *\n * First tries all declared nicks, then builds nicks by adding \"_\", until\n * length of 9.\n *\n * If all nicks are still used, builds 99 alternate nicks by using number at the\n * end.\n *\n * Example: nicks = \"abcde,fghi,jkl\"\n *          => nicks tried:  abcde\n *                          fghi\n *                          jkl\n *                          abcde_\n *                          abcde__\n *                          abcde___\n *                          abcde____\n *                          abcde___1\n *                          abcde___2\n *                          ...\n *                          abcde__99\n *\n * Returns NULL if no more alternate nick is available.\n */\n\nconst char *\nirc_server_get_alternate_nick (struct t_irc_server *server)\n{\n    static char nick[64];\n    char str_number[64];\n    int nick_index, length_nick, length_number;\n\n    nick[0] = '\\0';\n\n    /* we are still trying nicks from option \"nicks\" */\n    if (server->nick_alternate_number < 0)\n    {\n        nick_index = irc_server_get_nick_index (server);\n        if (nick_index < 0)\n            nick_index = 0;\n        else\n        {\n            nick_index = (nick_index + 1) % server->nicks_count;\n            /* stop loop if first nick tried was not in the list of nicks */\n            if ((nick_index == 0) && (server->nick_first_tried < 0))\n                server->nick_first_tried = 0;\n        }\n\n        if (nick_index != server->nick_first_tried)\n        {\n            snprintf (nick, sizeof (nick),\n                      \"%s\", server->nicks_array[nick_index]);\n            return nick;\n        }\n\n        /* now we have tried all nicks in list */\n\n        /* if alternate nicks are disabled, just return NULL */\n        if (!IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_NICKS_ALTERNATE))\n            return NULL;\n\n        /* use main nick and we will add \"_\" and then number if needed */\n        server->nick_alternate_number = 0;\n        snprintf (nick, sizeof (nick), \"%s\", server->nicks_array[0]);\n    }\n    else\n        snprintf (nick, sizeof (nick), \"%s\", server->nick);\n\n    /* if length is < 9, just add a \"_\" */\n    if (strlen (nick) < 9)\n    {\n        strcat (nick, \"_\");\n        return nick;\n    }\n\n    server->nick_alternate_number++;\n\n    /* number is max 99 */\n    if (server->nick_alternate_number > 99)\n        return NULL;\n\n    /* be sure the nick has 9 chars max */\n    nick[9] = '\\0';\n\n    /* generate number */\n    snprintf (str_number, sizeof (str_number),\n              \"%d\", server->nick_alternate_number);\n\n    /* copy number in nick */\n    length_nick = strlen (nick);\n    length_number = strlen (str_number);\n    if (length_number > length_nick)\n        return NULL;\n    memcpy (nick + length_nick - length_number, str_number, length_number);\n\n    /* return alternate nick */\n    return nick;\n}\n\n/*\n * Gets value of a feature item in \"isupport\" (copy of IRC message 005).\n *\n * Returns value of feature (empty string if feature has no value, NULL if\n * feature is not found).\n */\n\nconst char *\nirc_server_get_isupport_value (struct t_irc_server *server, const char *feature)\n{\n    char feature2[64], *pos_feature, *pos_equal, *pos_space;\n    int length;\n    static char value[256];\n\n    if (!server || !server->isupport || !feature)\n        return NULL;\n\n    /* search feature with value */\n    snprintf (feature2, sizeof (feature2), \" %s=\", feature);\n    pos_feature = strstr (server->isupport, feature2);\n    if (pos_feature)\n    {\n        /* feature found with value, return value */\n        pos_feature++;\n        pos_equal = strchr (pos_feature, '=');\n        pos_space = strchr (pos_feature, ' ');\n        if (pos_space)\n            length = pos_space - pos_equal - 1;\n        else\n            length = strlen (pos_equal) + 1;\n        if (length > (int)sizeof (value) - 1)\n            length = (int)sizeof (value) - 1;\n        memcpy (value, pos_equal + 1, length);\n        value[length] = '\\0';\n        return value;\n    }\n\n    /* search feature without value */\n    feature2[strlen (feature2) - 1] = ' ';\n    pos_feature = strstr (server->isupport, feature2);\n    if (pos_feature)\n    {\n        value[0] = '\\0';\n        return value;\n    }\n\n    /* feature not found in isupport */\n    return NULL;\n}\n\n/*\n * Sets \"prefix_modes\" and \"prefix_chars\" in server using value of PREFIX in IRC\n * message 005.\n *\n * For example, if prefix is \"(ohv)@%+\":\n *   prefix_modes is set to \"ohv\"\n *   prefix_chars is set to \"@%+\".\n */\n\nvoid\nirc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, old_length_chars, length_modes, length_chars;\n\n    if (!server || !prefix)\n        return;\n\n    old_length_chars = (server->prefix_chars) ?\n        strlen (server->prefix_chars) : 0;\n\n    /* free previous values */\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    /* assign new values */\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n\n    length_chars = (server->prefix_chars) ? strlen (server->prefix_chars) : 0;\n    if (server->prefix_chars && (length_chars != old_length_chars))\n        irc_nick_realloc_prefixes (server, old_length_chars, length_chars);\n}\n\n/*\n * Sets lag in server buffer (local variable), update bar item \"lag\"\n * and send signal \"irc_server_lag_changed\" for the server.\n */\n\nvoid\nirc_server_set_lag (struct t_irc_server *server)\n{\n    char str_lag[32];\n\n    if (server->lag >= weechat_config_integer (irc_config_network_lag_min_show))\n    {\n        snprintf (str_lag, sizeof (str_lag),\n                  ((server->lag_check_time.tv_sec == 0) || (server->lag < 1000)) ?\n                  \"%.3f\" : \"%.0f\",\n                  ((float)(server->lag)) / 1000);\n        weechat_buffer_set (server->buffer, \"localvar_set_lag\", str_lag);\n    }\n    else\n    {\n        weechat_buffer_set (server->buffer, \"localvar_del_lag\", \"\");\n    }\n    weechat_hook_signal_send (\"irc_server_lag_changed\",\n                              WEECHAT_HOOK_SIGNAL_STRING,\n                              server->name);\n    weechat_bar_item_update (\"lag\");\n}\n\n/*\n * Gets prefix_modes for server (for example: \"ohv\").\n *\n * Returns default modes if prefix_modes is not set in server.\n */\n\nconst char *\nirc_server_get_prefix_modes (struct t_irc_server *server)\n{\n    return (server && server->prefix_modes) ?\n        server->prefix_modes : irc_server_prefix_modes_default;\n}\n\n/*\n * Gets prefix_chars for server (for example: \"@%+\").\n *\n * Returns default chars if prefix_chars is not set in server.\n */\n\nconst char *\nirc_server_get_prefix_chars (struct t_irc_server *server)\n{\n    return (server && server->prefix_chars) ?\n        server->prefix_chars : irc_server_prefix_chars_default;\n}\n\n/*\n * Gets index of mode in prefix_modes.\n *\n * The mode is for example 'o' or 'v'.\n *\n * Returns -1 if mode does not exist in server.\n */\n\nint\nirc_server_get_prefix_mode_index (struct t_irc_server *server, char mode)\n{\n    const char *prefix_modes;\n    char *pos;\n\n    if (server)\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        pos = strchr (prefix_modes, mode);\n        if (pos)\n            return pos - prefix_modes;\n    }\n\n    return -1;\n}\n\n/*\n * Gets index of prefix_char in prefix_chars.\n *\n * The prefix char is for example '@' or '+'.\n *\n * Returns -1 if prefix_char does not exist in server.\n */\n\nint\nirc_server_get_prefix_char_index (struct t_irc_server *server,\n                                  char prefix_char)\n{\n    const char *prefix_chars;\n    char *pos;\n\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        pos = strchr (prefix_chars, prefix_char);\n        if (pos)\n            return pos - prefix_chars;\n    }\n\n    return -1;\n}\n\n/*\n * Gets mode for prefix char.\n *\n * For example prefix_char '@' can return 'o'.\n *\n * Returns ' ' (space) if prefix char is not found.\n */\n\nchar\nirc_server_get_prefix_mode_for_char (struct t_irc_server *server,\n                                     char prefix_char)\n{\n    const char *prefix_modes;\n    int index;\n\n    if (server)\n    {\n        prefix_modes = irc_server_get_prefix_modes (server);\n        index = irc_server_get_prefix_char_index (server, prefix_char);\n        if (index >= 0)\n            return prefix_modes[index];\n    }\n\n    return ' ';\n}\n\n/*\n * Gets prefix char for mode.\n *\n * For example mode 'o' can return '@'.\n *\n * Returns a space if mode is not found.\n */\n\nchar\nirc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n\n    return ' ';\n}\n\n/*\n * Gets chanmodes for server (for example: \"eIb,k,l,imnpstS\").\n *\n * Returns default chanmodes if chanmodes is not set in server.\n */\n\nconst char *\nirc_server_get_chanmodes (struct t_irc_server *server)\n{\n    return (server && server->chanmodes) ?\n        server->chanmodes : irc_server_chanmodes_default;\n}\n\n/*\n * Checks if a prefix char is valid for a status message\n * (message sent for example to ops/voiced).\n *\n * The prefix (for example '@' or '+') must be in STATUSMSG,\n * or in \"prefix_chars\" if STATUSMSG is not defined.\n *\n * Returns:\n *   1: prefix is valid for a status message\n *   0: prefix is NOT valid for a status message\n */\n\nint\nirc_server_prefix_char_statusmsg (struct t_irc_server *server,\n                                  char prefix_char)\n{\n    const char *support_statusmsg;\n\n    support_statusmsg = irc_server_get_isupport_value (server, \"STATUSMSG\");\n    if (support_statusmsg)\n        return (strchr (support_statusmsg, prefix_char)) ? 1 : 0;\n\n    return (irc_server_get_prefix_char_index (server, prefix_char) >= 0) ?\n        1 : 0;\n}\n\n/*\n * Get max modes supported in one command by the server\n * (in isupport value, with the format: \"MODES=4\").\n *\n * Default is 4 if the info is not given by the server.\n */\n\nint\nirc_server_get_max_modes (struct t_irc_server *server)\n{\n    const char *support_modes;\n    char *error;\n    long number;\n    int max_modes;\n\n    max_modes = 4;\n\n    support_modes = irc_server_get_isupport_value (server, \"MODES\");\n    if (support_modes)\n    {\n        error = NULL;\n        number = strtol (support_modes, &error, 10);\n        if (error && !error[0])\n        {\n            max_modes = number;\n            if (max_modes < 1)\n                max_modes = 1;\n            if (max_modes > 128)\n                max_modes = 128;\n        }\n    }\n\n    return max_modes;\n}\n\n/*\n * Gets an evaluated default_msg server option: replaces \"%v\" by WeeChat\n * version if there's no ${...} in string, or just evaluates the string.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_default_msg (const char *default_msg,\n                            struct t_irc_server *server,\n                            const char *channel_name)\n{\n    char *version;\n    struct t_hashtable *extra_vars;\n    char *msg, *res;\n\n    /*\n     * \"%v\" for version is deprecated since WeeChat 1.6, where\n     * an expression ${info:version} is preferred, so we replace\n     * the \"%v\" with version only if there's no \"${...}\" in string\n     */\n    if (strstr (default_msg, \"%v\") && !strstr (default_msg, \"${\"))\n    {\n        version = weechat_info_get (\"version\", \"\");\n        res = weechat_string_replace (default_msg, \"%v\",\n                                      (version) ? version : \"\");\n        if (version)\n            free (version);\n        return res;\n    }\n\n    extra_vars = weechat_hashtable_new (32,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        NULL,\n                                        NULL);\n    if (extra_vars)\n    {\n        weechat_hashtable_set (extra_vars, \"server\", server->name);\n        weechat_hashtable_set (extra_vars, \"channel\",\n                               (channel_name) ? channel_name : \"\");\n        weechat_hashtable_set (extra_vars, \"nick\", server->nick);\n    }\n\n    msg = weechat_string_eval_expression (default_msg, NULL, extra_vars, NULL);\n\n    if (extra_vars)\n        weechat_hashtable_free (extra_vars);\n\n    return msg;\n}\n\n/*\n * Allocates a new server and adds it to the servers queue.\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_alloc (const char *name)\n{\n    struct t_irc_server *new_server;\n    int i, length;\n    char *option_name;\n\n    if (irc_server_casesearch (name))\n        return NULL;\n\n    /* alloc memory for new server */\n    new_server = malloc (sizeof (*new_server));\n    if (!new_server)\n    {\n        weechat_printf (NULL,\n                        _(\"%s%s: error when allocating new server\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return NULL;\n    }\n\n    /* add new server to queue */\n    new_server->prev_server = last_irc_server;\n    new_server->next_server = NULL;\n    if (last_irc_server)\n        last_irc_server->next_server = new_server;\n    else\n        irc_servers = new_server;\n    last_irc_server = new_server;\n\n    /* set name */\n    new_server->name = strdup (name);\n\n    /* internal vars */\n    new_server->temp_server = 0;\n    new_server->reloading_from_config = 0;\n    new_server->reloaded_from_config = 0;\n    new_server->addresses_eval = NULL;\n    new_server->addresses_count = 0;\n    new_server->addresses_array = NULL;\n    new_server->ports_array = NULL;\n    new_server->retry_array = NULL;\n    new_server->index_current_address = 0;\n    new_server->current_address = NULL;\n    new_server->current_ip = NULL;\n    new_server->current_port = 0;\n    new_server->current_retry = 0;\n    new_server->sock = -1;\n    new_server->hook_connect = NULL;\n    new_server->hook_fd = NULL;\n    new_server->hook_timer_connection = NULL;\n    new_server->hook_timer_sasl = NULL;\n    new_server->is_connected = 0;\n    new_server->ssl_connected = 0;\n    new_server->disconnected = 0;\n    new_server->unterminated_message = NULL;\n    new_server->nicks_count = 0;\n    new_server->nicks_array = NULL;\n    new_server->nick_first_tried = 0;\n    new_server->nick_alternate_number = -1;\n    new_server->nick = NULL;\n    new_server->nick_modes = NULL;\n    new_server->host = NULL;\n    new_server->checking_cap_ls = 0;\n    new_server->cap_ls = weechat_hashtable_new (32,\n                                                WEECHAT_HASHTABLE_STRING,\n                                                WEECHAT_HASHTABLE_STRING,\n                                                NULL,\n                                                NULL);\n    new_server->checking_cap_list = 0;\n    new_server->cap_list = weechat_hashtable_new (32,\n                                                  WEECHAT_HASHTABLE_STRING,\n                                                  WEECHAT_HASHTABLE_STRING,\n                                                  NULL,\n                                                  NULL);\n    new_server->isupport = NULL;\n    new_server->prefix_modes = NULL;\n    new_server->prefix_chars = NULL;\n    new_server->nick_max_length = 0;\n    new_server->user_max_length = 0;\n    new_server->host_max_length = 0;\n    new_server->casemapping = IRC_SERVER_CASEMAPPING_RFC1459;\n    new_server->chantypes = NULL;\n    new_server->chanmodes = NULL;\n    new_server->monitor = 0;\n    new_server->monitor_time = 0;\n    new_server->reconnect_delay = 0;\n    new_server->reconnect_start = 0;\n    new_server->command_time = 0;\n    new_server->reconnect_join = 0;\n    new_server->disable_autojoin = 0;\n    new_server->is_away = 0;\n    new_server->away_message = NULL;\n    new_server->away_time = 0;\n    new_server->lag = 0;\n    new_server->lag_displayed = -1;\n    new_server->lag_check_time.tv_sec = 0;\n    new_server->lag_check_time.tv_usec = 0;\n    new_server->lag_next_check = time (NULL) +\n        weechat_config_integer (irc_config_network_lag_check);\n    new_server->lag_last_refresh = 0;\n    new_server->cmd_list_regexp = NULL;\n    new_server->last_user_message = 0;\n    new_server->last_away_check = 0;\n    new_server->last_data_purge = 0;\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        new_server->outqueue[i] = NULL;\n        new_server->last_outqueue[i] = NULL;\n    }\n    new_server->redirects = NULL;\n    new_server->last_redirect = NULL;\n    new_server->notify_list = NULL;\n    new_server->last_notify = NULL;\n    new_server->notify_count = 0;\n    new_server->join_manual = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_TIME,\n        NULL, NULL);\n    new_server->join_channel_key = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_STRING,\n        NULL, NULL);\n    new_server->join_noswitch = weechat_hashtable_new (\n        32,\n        WEECHAT_HASHTABLE_STRING,\n        WEECHAT_HASHTABLE_TIME,\n        NULL, NULL);\n    new_server->buffer = NULL;\n    new_server->buffer_as_string = NULL;\n    new_server->channels = NULL;\n    new_server->last_channel = NULL;\n\n    /* create options with null value */\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        length = strlen (new_server->name) + 1 +\n            strlen (irc_server_options[i][0]) +\n            512 +  /* inherited option name (irc.server_default.xxx) */\n            1;\n        option_name = malloc (length);\n        if (option_name)\n        {\n            snprintf (option_name, length, \"%s.%s << irc.server_default.%s\",\n                      new_server->name,\n                      irc_server_options[i][0],\n                      irc_server_options[i][0]);\n            new_server->options[i] = irc_config_server_new_option (\n                irc_config_file,\n                irc_config_section_server,\n                i,\n                option_name,\n                NULL,\n                NULL,\n                1,\n                &irc_config_server_check_value_cb,\n                irc_server_options[i][0],\n                NULL,\n                &irc_config_server_change_cb,\n                irc_server_options[i][0],\n                NULL);\n            irc_config_server_change_cb (irc_server_options[i][0], NULL,\n                                         new_server->options[i]);\n            free (option_name);\n        }\n    }\n\n    return new_server;\n}\n\n/*\n * Initializes a server with URL of this form: irc://nick:pass@irc.toto.org:6667\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_alloc_with_url (const char *irc_url)\n{\n    char *irc_url2, *pos_server, *pos_nick, *pos_password;\n    char *pos_address, *pos_port, *pos_channel, *pos;\n    char *server_address, *server_nicks, *server_autojoin;\n    char default_port[16];\n    int ipv6, ssl, length;\n    struct t_irc_server *ptr_server;\n\n    irc_url2 = strdup (irc_url);\n    if (!irc_url2)\n        return NULL;\n\n    pos_server = NULL;\n    pos_nick = NULL;\n    pos_password = NULL;\n    pos_address = NULL;\n    pos_port = NULL;\n    pos_channel = NULL;\n\n    ipv6 = 0;\n    ssl = 0;\n    snprintf (default_port, sizeof (default_port),\n              \"%d\", IRC_SERVER_DEFAULT_PORT);\n\n    pos_server = strstr (irc_url2, \"://\");\n    if (!pos_server || !pos_server[3])\n    {\n        free (irc_url2);\n        return NULL;\n    }\n    pos_server[0] = '\\0';\n    pos_server += 3;\n\n    pos_channel = strstr (pos_server, \"/\");\n    if (pos_channel)\n    {\n        pos_channel[0] = '\\0';\n        pos_channel++;\n        while (pos_channel[0] == '/')\n        {\n            pos_channel++;\n        }\n    }\n\n    /* check for SSL / IPv6 */\n    if (weechat_strcasecmp (irc_url2, \"irc6\") == 0)\n    {\n        ipv6 = 1;\n    }\n    else if (weechat_strcasecmp (irc_url2, \"ircs\") == 0)\n    {\n        ssl = 1;\n    }\n    else if ((weechat_strcasecmp (irc_url2, \"irc6s\") == 0)\n             || (weechat_strcasecmp (irc_url2, \"ircs6\") == 0))\n    {\n        ipv6 = 1;\n        ssl = 1;\n    }\n\n    if (ssl)\n    {\n        snprintf (default_port, sizeof (default_port),\n                  \"%d\", IRC_SERVER_DEFAULT_PORT_SSL);\n    }\n\n    /* search for nick, password, address+port */\n    pos_address = strchr (pos_server, '@');\n    if (pos_address)\n    {\n        pos_address[0] = '\\0';\n        pos_address++;\n        pos_nick = pos_server;\n        pos_password = strchr (pos_server, ':');\n        if (pos_password)\n        {\n            pos_password[0] = '\\0';\n            pos_password++;\n        }\n    }\n    else\n        pos_address = pos_server;\n\n    /*\n     * search for port in address, and skip optional [ ] around address\n     * (can be used to indicate IPv6 port, after ']')\n     */\n    if (pos_address[0] == '[')\n    {\n        pos_address++;\n        pos = strchr (pos_address, ']');\n        if (!pos)\n        {\n            free (irc_url2);\n            return NULL;\n        }\n        pos[0] = '\\0';\n        pos++;\n        pos_port = strchr (pos, ':');\n        if (pos_port)\n        {\n            pos_port[0] = '\\0';\n            pos_port++;\n        }\n    }\n    else\n    {\n        pos_port = strchr (pos_address, ':');\n        if (pos_port)\n        {\n            pos_port[0] = '\\0';\n            pos_port++;\n        }\n    }\n\n    ptr_server = irc_server_alloc (pos_address);\n    if (ptr_server)\n    {\n        ptr_server->temp_server = 1;\n        if (pos_address && pos_address[0])\n        {\n            length = strlen (pos_address) + 1 +\n                ((pos_port) ? strlen (pos_port) : 16) + 1;\n            server_address = malloc (length);\n            if (server_address)\n            {\n                snprintf (server_address, length,\n                          \"%s/%s\",\n                          pos_address,\n                          (pos_port && pos_port[0]) ? pos_port : default_port);\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_ADDRESSES],\n                    server_address,\n                    1);\n                free (server_address);\n            }\n        }\n        weechat_config_option_set (ptr_server->options[IRC_SERVER_OPTION_IPV6],\n                                   (ipv6) ? \"on\" : \"off\",\n                                   1);\n        weechat_config_option_set (ptr_server->options[IRC_SERVER_OPTION_SSL],\n                                   (ssl) ? \"on\" : \"off\",\n                                   1);\n        if (pos_nick && pos_nick[0])\n        {\n            length = ((strlen (pos_nick) + 2) * 5) + 1;\n            server_nicks = malloc (length);\n            if (server_nicks)\n            {\n                snprintf (server_nicks, length,\n                          \"%s,%s1,%s2,%s3,%s4\",\n                          pos_nick, pos_nick, pos_nick, pos_nick, pos_nick);\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_NICKS],\n                    server_nicks,\n                    1);\n                free (server_nicks);\n            }\n        }\n        if (pos_password && pos_password[0])\n        {\n            weechat_config_option_set (\n                ptr_server->options[IRC_SERVER_OPTION_PASSWORD],\n                pos_password,\n                1);\n        }\n        weechat_config_option_set (\n            ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT],\n            \"on\",\n            1);\n        /* autojoin */\n        if (pos_channel && pos_channel[0])\n        {\n            if (irc_channel_is_channel (ptr_server, pos_channel))\n                server_autojoin = strdup (pos_channel);\n            else\n            {\n                server_autojoin = malloc (strlen (pos_channel) + 2);\n                if (server_autojoin)\n                {\n                    strcpy (server_autojoin, \"#\");\n                    strcat (server_autojoin, pos_channel);\n                }\n            }\n            if (server_autojoin)\n            {\n                weechat_config_option_set (\n                    ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN],\n                    server_autojoin,\n                    1);\n                free (server_autojoin);\n            }\n        }\n    }\n\n    free (irc_url2);\n\n    return ptr_server;\n}\n\n/*\n * Applies command line options to a server.\n *\n * For example: -ssl -nossl -password=test -proxy=myproxy\n */\n\nvoid\nirc_server_apply_command_line_options (struct t_irc_server *server,\n                                       int argc, char **argv)\n{\n    int i, index_option;\n    char *pos, *option_name, *ptr_value, *value_boolean[2] = { \"off\", \"on\" };\n\n    for (i = 0; i < argc; i++)\n    {\n        if (argv[i][0] == '-')\n        {\n            pos = strchr (argv[i], '=');\n            if (pos)\n            {\n                option_name = weechat_strndup (argv[i] + 1, pos - argv[i] - 1);\n                ptr_value = pos + 1;\n            }\n            else\n            {\n                option_name = strdup (argv[i] + 1);\n                ptr_value = value_boolean[1];\n            }\n            if (option_name)\n            {\n                if (weechat_strcasecmp (option_name, \"temp\") == 0)\n                {\n                    /* temporary server, not saved */\n                    server->temp_server = 1;\n                }\n                else\n                {\n                    index_option = irc_server_search_option (option_name);\n                    if (index_option < 0)\n                    {\n                        /* look if option is negative, like \"-noxxx\" */\n                        if (weechat_strncasecmp (argv[i], \"-no\", 3) == 0)\n                        {\n                            free (option_name);\n                            option_name = strdup (argv[i] + 3);\n                            index_option = irc_server_search_option (option_name);\n                            ptr_value = value_boolean[0];\n                        }\n                    }\n                    if (index_option >= 0)\n                    {\n                        weechat_config_option_set (server->options[index_option],\n                                                   ptr_value, 1);\n                    }\n                }\n                free (option_name);\n            }\n        }\n    }\n}\n\n/*\n * Adds a message in out queue.\n */\n\nvoid\nirc_server_outqueue_add (struct t_irc_server *server, int priority,\n                         const char *command, const char *msg1,\n                         const char *msg2, int modified, const char *tags,\n                         struct t_irc_redirect *redirect)\n{\n    struct t_irc_outqueue *new_outqueue;\n\n    new_outqueue = malloc (sizeof (*new_outqueue));\n    if (new_outqueue)\n    {\n        new_outqueue->command = (command) ? strdup (command) : strdup (\"unknown\");\n        new_outqueue->message_before_mod = (msg1) ? strdup (msg1) : NULL;\n        new_outqueue->message_after_mod = (msg2) ? strdup (msg2) : NULL;\n        new_outqueue->modified = modified;\n        new_outqueue->tags = (tags) ? strdup (tags) : NULL;\n        new_outqueue->redirect = redirect;\n\n        new_outqueue->prev_outqueue = server->last_outqueue[priority];\n        new_outqueue->next_outqueue = NULL;\n        if (server->last_outqueue[priority])\n            server->last_outqueue[priority]->next_outqueue = new_outqueue;\n        else\n            server->outqueue[priority] = new_outqueue;\n        server->last_outqueue[priority] = new_outqueue;\n    }\n}\n\n/*\n * Frees a message in out queue.\n */\n\nvoid\nirc_server_outqueue_free (struct t_irc_server *server,\n                          int priority,\n                          struct t_irc_outqueue *outqueue)\n{\n    struct t_irc_outqueue *new_outqueue;\n\n    if (!server || !outqueue)\n        return;\n\n    /* remove outqueue message */\n    if (server->last_outqueue[priority] == outqueue)\n        server->last_outqueue[priority] = outqueue->prev_outqueue;\n    if (outqueue->prev_outqueue)\n    {\n        (outqueue->prev_outqueue)->next_outqueue = outqueue->next_outqueue;\n        new_outqueue = server->outqueue[priority];\n    }\n    else\n        new_outqueue = outqueue->next_outqueue;\n\n    if (outqueue->next_outqueue)\n        (outqueue->next_outqueue)->prev_outqueue = outqueue->prev_outqueue;\n\n    /* free data */\n    if (outqueue->command)\n        free (outqueue->command);\n    if (outqueue->message_before_mod)\n        free (outqueue->message_before_mod);\n    if (outqueue->message_after_mod)\n        free (outqueue->message_after_mod);\n    if (outqueue->tags)\n        free (outqueue->tags);\n    free (outqueue);\n\n    /* set new head */\n    server->outqueue[priority] = new_outqueue;\n}\n\n/*\n * Frees all messages in out queue.\n */\n\nvoid\nirc_server_outqueue_free_all (struct t_irc_server *server, int priority)\n{\n    while (server->outqueue[priority])\n    {\n        irc_server_outqueue_free (server, priority,\n                                  server->outqueue[priority]);\n    }\n}\n\n/*\n * Frees server data.\n */\n\nvoid\nirc_server_free_data (struct t_irc_server *server)\n{\n    int i;\n\n    if (!server)\n        return;\n\n    /* free linked lists */\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        irc_server_outqueue_free_all (server, i);\n    }\n    irc_redirect_free_all (server);\n    irc_notify_free_all (server);\n    irc_channel_free_all (server);\n\n    /* free hashtables */\n    weechat_hashtable_free (server->join_manual);\n    weechat_hashtable_free (server->join_channel_key);\n    weechat_hashtable_free (server->join_noswitch);\n\n    /* free server data */\n    for (i = 0; i < IRC_SERVER_NUM_OPTIONS; i++)\n    {\n        if (server->options[i])\n            weechat_config_option_free (server->options[i]);\n    }\n    if (server->name)\n        free (server->name);\n    if (server->addresses_eval)\n        free (server->addresses_eval);\n    if (server->addresses_array)\n        weechat_string_free_split (server->addresses_array);\n    if (server->ports_array)\n        free (server->ports_array);\n    if (server->retry_array)\n        free (server->retry_array);\n    if (server->current_address)\n        free (server->current_address);\n    if (server->current_ip)\n        free (server->current_ip);\n    if (server->hook_connect)\n        weechat_unhook (server->hook_connect);\n    if (server->hook_fd)\n        weechat_unhook (server->hook_fd);\n    if (server->hook_timer_connection)\n        weechat_unhook (server->hook_timer_connection);\n    if (server->hook_timer_sasl)\n        weechat_unhook (server->hook_timer_sasl);\n    if (server->unterminated_message)\n        free (server->unterminated_message);\n    if (server->nicks_array)\n        weechat_string_free_split (server->nicks_array);\n    if (server->nick)\n        free (server->nick);\n    if (server->nick_modes)\n        free (server->nick_modes);\n    if (server->host)\n        free (server->host);\n    if (server->cap_ls)\n        weechat_hashtable_free (server->cap_ls);\n    if (server->cap_list)\n        weechat_hashtable_free (server->cap_list);\n    if (server->isupport)\n        free (server->isupport);\n    if (server->prefix_modes)\n        free (server->prefix_modes);\n    if (server->prefix_chars)\n        free (server->prefix_chars);\n    if (server->chantypes)\n        free (server->chantypes);\n    if (server->chanmodes)\n        free (server->chanmodes);\n    if (server->away_message)\n        free (server->away_message);\n    if (server->cmd_list_regexp)\n    {\n        regfree (server->cmd_list_regexp);\n        free (server->cmd_list_regexp);\n    }\n    if (server->buffer_as_string)\n        free (server->buffer_as_string);\n}\n\n/*\n * Frees a server and remove it from list of servers.\n */\n\nvoid\nirc_server_free (struct t_irc_server *server)\n{\n    struct t_irc_server *new_irc_servers;\n\n    if (!server)\n        return;\n\n    /*\n     * close server buffer (and all channels/privates)\n     * (only if we are not in a /upgrade, because during upgrade we want to\n     * keep connections and closing server buffer would disconnect from server)\n     */\n    if (server->buffer && !irc_signal_upgrade_received)\n        weechat_buffer_close (server->buffer);\n\n    /* remove server from queue */\n    if (last_irc_server == server)\n        last_irc_server = server->prev_server;\n    if (server->prev_server)\n    {\n        (server->prev_server)->next_server = server->next_server;\n        new_irc_servers = irc_servers;\n    }\n    else\n        new_irc_servers = server->next_server;\n\n    if (server->next_server)\n        (server->next_server)->prev_server = server->prev_server;\n\n    irc_server_free_data (server);\n    free (server);\n    irc_servers = new_irc_servers;\n}\n\n/*\n * Frees all servers.\n */\n\nvoid\nirc_server_free_all ()\n{\n    /* for each server in memory, remove it */\n    while (irc_servers)\n    {\n        irc_server_free (irc_servers);\n    }\n}\n\n/*\n * Copies a server.\n *\n * Returns pointer to new server, NULL if error.\n */\n\nstruct t_irc_server *\nirc_server_copy (struct t_irc_server *server, const char *new_name)\n{\n    struct t_irc_server *new_server;\n    struct t_infolist *infolist;\n    char *mask, *pos;\n    const char *option_name;\n    int length, index_option;\n\n    /* check if another server exists with this name */\n    if (irc_server_casesearch (new_name))\n        return NULL;\n\n    new_server = irc_server_alloc (new_name);\n    if (new_server)\n    {\n        /* duplicate options */\n        length = 32 + strlen (server->name) + 1;\n        mask = malloc (length);\n        if (!mask)\n            return 0;\n        snprintf (mask, length, \"irc.server.%s.*\", server->name);\n        infolist = weechat_infolist_get (\"option\", NULL, mask);\n        free (mask);\n        if (infolist)\n        {\n            while (weechat_infolist_next (infolist))\n            {\n                if (!weechat_infolist_integer (infolist, \"value_is_null\"))\n                {\n                    option_name = weechat_infolist_string (infolist,\n                                                           \"option_name\");\n                    pos = strrchr (option_name, '.');\n                    if (pos)\n                    {\n                        index_option = irc_server_search_option (pos + 1);\n                        if (index_option >= 0)\n                        {\n                            weechat_config_option_set (\n                                new_server->options[index_option],\n                                weechat_infolist_string (infolist, \"value\"),\n                                1);\n                        }\n                    }\n                }\n            }\n            weechat_infolist_free (infolist);\n        }\n    }\n\n    return new_server;\n}\n\n/*\n * Renames a server (internal name).\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_rename (struct t_irc_server *server, const char *new_name)\n{\n    int length;\n    char *mask, *pos_option, *new_option_name, charset_modifier[256];\n    const char *buffer_name, *option_name;\n    struct t_infolist *infolist;\n    struct t_config_option *ptr_option;\n    struct t_irc_channel *ptr_channel;\n\n    /* check if another server exists with this name */\n    if (irc_server_casesearch (new_name))\n        return 0;\n\n    /* rename options */\n    length = 32 + strlen (server->name) + 1;\n    mask = malloc (length);\n    if (!mask)\n        return 0;\n    snprintf (mask, length, \"irc.server.%s.*\", server->name);\n    infolist = weechat_infolist_get (\"option\", NULL, mask);\n    free (mask);\n    if (infolist)\n    {\n        while (weechat_infolist_next (infolist))\n        {\n            ptr_option = weechat_config_get (\n                weechat_infolist_string (infolist, \"full_name\"));\n            if (ptr_option)\n            {\n                option_name = weechat_infolist_string (infolist, \"option_name\");\n                if (option_name)\n                {\n                    pos_option = strrchr (option_name, '.');\n                    if (pos_option)\n                    {\n                        pos_option++;\n                        length = strlen (new_name) + 1 + strlen (pos_option) + 1;\n                        new_option_name = malloc (length);\n                        if (new_option_name)\n                        {\n                            snprintf (new_option_name, length,\n                                      \"%s.%s\", new_name, pos_option);\n                            weechat_config_option_rename (ptr_option, new_option_name);\n                            free (new_option_name);\n                        }\n                    }\n                }\n            }\n        }\n        weechat_infolist_free (infolist);\n    }\n\n    /* rename server */\n    if (server->name)\n        free (server->name);\n    server->name = strdup (new_name);\n\n    /* change name and local variables on buffers */\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->buffer)\n        {\n            buffer_name = irc_buffer_build_name (server->name,\n                                                 ptr_channel->name);\n            weechat_buffer_set (ptr_channel->buffer, \"name\", buffer_name);\n            weechat_buffer_set (ptr_channel->buffer, \"localvar_set_server\",\n                                server->name);\n        }\n    }\n    if (server->buffer)\n    {\n        buffer_name = irc_buffer_build_name (server->name, NULL);\n        weechat_buffer_set (server->buffer, \"name\", buffer_name);\n        weechat_buffer_set (server->buffer, \"short_name\", server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_server\",\n                            server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_channel\",\n                            server->name);\n        snprintf (charset_modifier, sizeof (charset_modifier),\n                  \"irc.%s\", server->name);\n        weechat_buffer_set (server->buffer, \"localvar_set_charset_modifier\",\n                            charset_modifier);\n    }\n\n    return 1;\n}\n\n/*\n * Reorders list of servers.\n *\n * Returns the number of servers moved in the list (>= 0).\n */\n\nint\nirc_server_reorder (const char **servers, int num_servers)\n{\n    struct t_irc_server *ptr_server, *ptr_server2;\n    int i, num_moved;\n\n    ptr_server = irc_servers;\n    num_moved = 0;\n\n    for (i = 0; ptr_server && (i < num_servers); i++)\n    {\n        for (ptr_server2 = ptr_server; ptr_server2;\n             ptr_server2 = ptr_server2->next_server)\n        {\n            if (strcmp (ptr_server2->name, servers[i]) == 0)\n                break;\n        }\n        if (ptr_server2 == ptr_server)\n        {\n            ptr_server = ptr_server->next_server;\n        }\n        else  if (ptr_server2)\n        {\n            /* extract server from list */\n            if (ptr_server2 == irc_servers)\n                irc_servers = ptr_server2->next_server;\n            if (ptr_server2 == last_irc_server)\n                last_irc_server = ptr_server2->prev_server;\n            if (ptr_server2->prev_server)\n                (ptr_server2->prev_server)->next_server = ptr_server2->next_server;\n            if (ptr_server2->next_server)\n                (ptr_server2->next_server)->prev_server = ptr_server2->prev_server;\n\n            /* set pointers in ptr_server2 */\n            ptr_server2->prev_server = ptr_server->prev_server;\n            ptr_server2->next_server = ptr_server;\n\n            /* insert ptr_server2 before ptr_server */\n            if (ptr_server->prev_server)\n                (ptr_server->prev_server)->next_server = ptr_server2;\n            ptr_server->prev_server = ptr_server2;\n\n            /* adjust list of servers if needed */\n            if (ptr_server == irc_servers)\n                irc_servers = ptr_server2;\n\n            num_moved++;\n        }\n    }\n\n    return num_moved;\n}\n\n/*\n * Sends a signal for an IRC message (received or sent).\n */\n\nvoid\nirc_server_send_signal (struct t_irc_server *server, const char *signal,\n                        const char *command, const char *full_message,\n                        const char *tags)\n{\n    int length;\n    char *str_signal, *full_message_tags;\n\n    length = strlen (server->name) + 1 + strlen (signal) + 1 + strlen (command) + 1;\n    str_signal = malloc (length);\n    if (str_signal)\n    {\n        snprintf (str_signal, length,\n                  \"%s,%s_%s\", server->name, signal, command);\n        if (tags)\n        {\n            length = strlen (tags) + 1 + strlen (full_message) + 1;\n            full_message_tags = malloc (length);\n            if (full_message_tags)\n            {\n                snprintf (full_message_tags, length,\n                          \"%s;%s\", tags, full_message);\n                (void) weechat_hook_signal_send (str_signal,\n                                                 WEECHAT_HOOK_SIGNAL_STRING,\n                                                 (void *)full_message_tags);\n                free (full_message_tags);\n            }\n        }\n        else\n        {\n            (void) weechat_hook_signal_send (str_signal,\n                                             WEECHAT_HOOK_SIGNAL_STRING,\n                                             (void *)full_message);\n        }\n        free (str_signal);\n    }\n}\n\n/*\n * Sends data to IRC server.\n *\n * Returns number of bytes sent, -1 if error.\n */\n\nint\nirc_server_send (struct t_irc_server *server, const char *buffer, int size_buf)\n{\n    int rc;\n\n    if (!server)\n    {\n        weechat_printf (\n            NULL,\n            _(\"%s%s: sending data to server: null pointer (please report \"\n              \"problem to developers)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n\n    if (size_buf <= 0)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: sending data to server: empty buffer (please report \"\n              \"problem to developers)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n\n#ifdef HAVE_GNUTLS\n    if (server->ssl_connected)\n        rc = gnutls_record_send (server->gnutls_sess, buffer, size_buf);\n    else\n#endif /* HAVE_GNUTLS */\n        rc = send (server->sock, buffer, size_buf, 0);\n\n    if (rc < 0)\n    {\n#ifdef HAVE_GNUTLS\n        if (server->ssl_connected)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: sending data to server: error %d %s\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                rc, gnutls_strerror (rc));\n        }\n        else\n#endif /* HAVE_GNUTLS */\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: sending data to server: error %d %s\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                errno, strerror (errno));\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Sets default tags used when sending message.\n */\n\nvoid\nirc_server_set_send_default_tags (const char *tags)\n{\n    irc_server_send_default_tags = tags;\n}\n\n/*\n * Gets tags to send by concatenation of tags and irc_server_send_default_tags\n * (if set).\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_server_get_tags_to_send (const char *tags)\n{\n    int length;\n    char *buf;\n\n    if (!tags && !irc_server_send_default_tags)\n        return NULL;\n\n    if (!tags)\n        return strdup (irc_server_send_default_tags);\n\n    if (!irc_server_send_default_tags)\n        return strdup (tags);\n\n    /* concatenate tags and irc_server_send_default_tags */\n    length = strlen (tags) + 1 + strlen (irc_server_send_default_tags) + 1;\n    buf = malloc (length);\n    if (buf)\n        snprintf (buf, length, \"%s,%s\", tags, irc_server_send_default_tags);\n    return buf;\n}\n\n/*\n * Sends a message from out queue.\n */\n\nvoid\nirc_server_outqueue_send (struct t_irc_server *server)\n{\n    time_t time_now;\n    char *pos, *tags_to_send;\n    int priority, anti_flood;\n\n    time_now = time (NULL);\n\n    /* detect if system clock has been changed (now lower than before) */\n    if (server->last_user_message > time_now)\n        server->last_user_message = time_now;\n\n    for (priority = 0; priority < IRC_SERVER_NUM_OUTQUEUES_PRIO; priority++)\n    {\n        switch (priority)\n        {\n            case 0:\n                anti_flood = IRC_SERVER_OPTION_INTEGER(\n                    server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH);\n                break;\n            default:\n                anti_flood = IRC_SERVER_OPTION_INTEGER(\n                    server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW);\n                break;\n        }\n        if (server->outqueue[priority]\n            && (time_now >= server->last_user_message + anti_flood))\n        {\n            if (server->outqueue[priority]->message_before_mod)\n            {\n                pos = strchr (server->outqueue[priority]->message_before_mod,\n                              '\\r');\n                if (pos)\n                    pos[0] = '\\0';\n                irc_raw_print (server, IRC_RAW_FLAG_SEND,\n                               server->outqueue[priority]->message_before_mod);\n                if (pos)\n                    pos[0] = '\\r';\n            }\n            if (server->outqueue[priority]->message_after_mod)\n            {\n                pos = strchr (server->outqueue[priority]->message_after_mod,\n                              '\\r');\n                if (pos)\n                    pos[0] = '\\0';\n                irc_raw_print (server, IRC_RAW_FLAG_SEND |\n                               ((server->outqueue[priority]->modified) ? IRC_RAW_FLAG_MODIFIED : 0),\n                               server->outqueue[priority]->message_after_mod);\n                if (pos)\n                    pos[0] = '\\r';\n\n                /* send signal with command that will be sent to server */\n                irc_server_send_signal (\n                    server, \"irc_out\",\n                    server->outqueue[priority]->command,\n                    server->outqueue[priority]->message_after_mod,\n                    NULL);\n                tags_to_send = irc_server_get_tags_to_send (\n                    server->outqueue[priority]->tags);\n                irc_server_send_signal (\n                    server, \"irc_outtags\",\n                    server->outqueue[priority]->command,\n                    server->outqueue[priority]->message_after_mod,\n                    (tags_to_send) ? tags_to_send : \"\");\n                if (tags_to_send)\n                    free (tags_to_send);\n\n                /* send command */\n                irc_server_send (\n                    server, server->outqueue[priority]->message_after_mod,\n                    strlen (server->outqueue[priority]->message_after_mod));\n                server->last_user_message = time_now;\n\n                /* start redirection if redirect is set */\n                if (server->outqueue[priority]->redirect)\n                {\n                    irc_redirect_init_command (\n                        server->outqueue[priority]->redirect,\n                        server->outqueue[priority]->message_after_mod);\n                }\n            }\n            irc_server_outqueue_free (server, priority,\n                                      server->outqueue[priority]);\n            break;\n        }\n    }\n}\n\n/*\n * Sends one message to IRC server.\n *\n * If flag contains outqueue priority value, then messages are in a queue and\n * sent slowly (to be sure there will not be any \"excess flood\"), value of\n * queue_msg is priority:\n *   1 = higher priority, for user messages\n *   2 = lower priority, for other messages (like auto reply to CTCP queries)\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_send_one_msg (struct t_irc_server *server, int flags,\n                         const char *message, const char *nick,\n                         const char *command, const char *channel,\n                         const char *tags)\n{\n    static char buffer[4096];\n    const char *ptr_msg, *ptr_chan_nick;\n    char *new_msg, *pos, *tags_to_send, *msg_encoded;\n    char str_modifier[128], modifier_data[256];\n    int rc, queue_msg, add_to_queue, first_message, anti_flood;\n    int pos_channel, pos_text, pos_encode;\n    time_t time_now;\n    struct t_irc_redirect *ptr_redirect;\n\n    rc = 1;\n\n    /* run modifier \"irc_out_xxx\" */\n    snprintf (str_modifier, sizeof (str_modifier),\n              \"irc_out_%s\",\n              (command) ? command : \"unknown\");\n    new_msg = weechat_hook_modifier_exec (str_modifier,\n                                          server->name,\n                                          message);\n\n    /* no changes in new message */\n    if (new_msg && (strcmp (message, new_msg) == 0))\n    {\n        free (new_msg);\n        new_msg = NULL;\n    }\n\n    /* message not dropped? */\n    if (!new_msg || new_msg[0])\n    {\n        first_message = 1;\n        ptr_msg = (new_msg) ? new_msg : message;\n\n        msg_encoded = NULL;\n        irc_message_parse (server, ptr_msg, NULL, NULL, NULL, NULL, NULL, NULL,\n                           NULL, NULL, NULL, NULL, NULL, &pos_channel,\n                           &pos_text);\n        switch (IRC_SERVER_OPTION_INTEGER(server,\n                                          IRC_SERVER_OPTION_CHARSET_MESSAGE))\n        {\n            case IRC_SERVER_CHARSET_MESSAGE_MESSAGE:\n                pos_encode = 0;\n                break;\n            case IRC_SERVER_CHARSET_MESSAGE_CHANNEL:\n                pos_encode = (pos_channel >= 0) ? pos_channel : pos_text;\n                break;\n            case IRC_SERVER_CHARSET_MESSAGE_TEXT:\n                pos_encode = pos_text;\n                break;\n            default:\n                pos_encode = 0;\n                break;\n        }\n        if (pos_encode >= 0)\n        {\n            ptr_chan_nick = (channel) ? channel : nick;\n            if (ptr_chan_nick)\n            {\n                snprintf (modifier_data, sizeof (modifier_data),\n                          \"%s.%s.%s\",\n                          weechat_plugin->name,\n                          server->name,\n                          ptr_chan_nick);\n            }\n            else\n            {\n                snprintf (modifier_data, sizeof (modifier_data),\n                          \"%s.%s\",\n                          weechat_plugin->name,\n                          server->name);\n            }\n            msg_encoded = irc_message_convert_charset (ptr_msg, pos_encode,\n                                                       \"charset_encode\",\n                                                       modifier_data);\n        }\n\n        if (msg_encoded)\n            ptr_msg = msg_encoded;\n\n        while (rc && ptr_msg && ptr_msg[0])\n        {\n            pos = strchr (ptr_msg, '\\n');\n            if (pos)\n                pos[0] = '\\0';\n\n            snprintf (buffer, sizeof (buffer), \"%s\\r\\n\", ptr_msg);\n\n            /* anti-flood: look whether we should queue outgoing message or not */\n            time_now = time (NULL);\n\n            /* detect if system clock has been changed (now lower than before) */\n            if (server->last_user_message > time_now)\n                server->last_user_message = time_now;\n\n            /* get queue from flags */\n            queue_msg = 0;\n            if (flags & IRC_SERVER_SEND_OUTQ_PRIO_HIGH)\n                queue_msg = 1;\n            else if (flags & IRC_SERVER_SEND_OUTQ_PRIO_LOW)\n                queue_msg = 2;\n\n            switch (queue_msg - 1)\n            {\n                case 0:\n                    anti_flood = IRC_SERVER_OPTION_INTEGER(\n                        server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH);\n                    break;\n                default:\n                    anti_flood = IRC_SERVER_OPTION_INTEGER(\n                        server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW);\n                    break;\n            }\n\n            add_to_queue = 0;\n            if ((queue_msg > 0)\n                && (server->outqueue[queue_msg - 1]\n                    || ((anti_flood > 0)\n                        && (time_now - server->last_user_message < anti_flood))))\n            {\n                add_to_queue = queue_msg;\n            }\n\n            tags_to_send = irc_server_get_tags_to_send (tags);\n\n            ptr_redirect = irc_redirect_search_available (server);\n\n            if (add_to_queue > 0)\n            {\n                /* queue message (do not send anything now) */\n                irc_server_outqueue_add (server, add_to_queue - 1, command,\n                                         (new_msg && first_message) ? message : NULL,\n                                         buffer,\n                                         (new_msg) ? 1 : 0,\n                                         tags_to_send,\n                                         ptr_redirect);\n                /* mark redirect as \"used\" */\n                if (ptr_redirect)\n                    ptr_redirect->assigned_to_command = 1;\n            }\n            else\n            {\n                if (first_message)\n                {\n                    irc_raw_print (server, IRC_RAW_FLAG_SEND, message);\n                }\n                if (new_msg)\n                {\n                    irc_raw_print (server,\n                                   IRC_RAW_FLAG_SEND | IRC_RAW_FLAG_MODIFIED,\n                                   ptr_msg);\n                }\n\n                /* send signal with command that will be sent to server */\n                irc_server_send_signal (server, \"irc_out\",\n                                        (command) ? command : \"unknown\",\n                                        ptr_msg,\n                                        NULL);\n                irc_server_send_signal (server, \"irc_outtags\",\n                                        (command) ? command : \"unknown\",\n                                        ptr_msg,\n                                        (tags_to_send) ? tags_to_send : \"\");\n\n                if (irc_server_send (server, buffer, strlen (buffer)) <= 0)\n                    rc = 0;\n                else\n                {\n                    if (queue_msg > 0)\n                        server->last_user_message = time_now;\n                }\n                if (ptr_redirect)\n                    irc_redirect_init_command (ptr_redirect, buffer);\n            }\n\n            if (tags_to_send)\n                    free (tags_to_send);\n\n            if (pos)\n            {\n                pos[0] = '\\n';\n                ptr_msg = pos + 1;\n            }\n            else\n                ptr_msg = NULL;\n\n            first_message = 0;\n        }\n        if (msg_encoded)\n            free (msg_encoded);\n    }\n    else\n    {\n        irc_raw_print (server, IRC_RAW_FLAG_SEND | IRC_RAW_FLAG_MODIFIED,\n                       _(\"(message dropped)\"));\n    }\n\n    if (new_msg)\n        free (new_msg);\n\n    return rc;\n}\n\n/*\n * Sends formatted data to IRC server.\n *\n * Many messages may be sent, separated by '\\n'.\n *\n * If flags contains \"IRC_SERVER_SEND_RETURN_HASHTABLE\", then a hashtable with\n * split of message is returned (see function irc_message_split() in\n * irc-message.c)\n *\n * Note: hashtable must be freed after use.\n */\n\nstruct t_hashtable *\nirc_server_sendf (struct t_irc_server *server, int flags, const char *tags,\n                  const char *format, ...)\n{\n    char **items, hash_key[32], value[32], *nick, *command, *channel, *new_msg;\n    char str_modifier[128];\n    const char *str_message, *str_args;\n    int i, items_count, number, ret_number, rc;\n    struct t_hashtable *hashtable, *ret_hashtable;\n\n    if (!server)\n        return NULL;\n\n    weechat_va_format (format);\n    if (!vbuffer)\n        return NULL;\n\n    ret_hashtable = NULL;\n    ret_number = 1;\n    if (flags & IRC_SERVER_SEND_RETURN_HASHTABLE)\n    {\n        ret_hashtable = weechat_hashtable_new (32,\n                                               WEECHAT_HASHTABLE_STRING,\n                                               WEECHAT_HASHTABLE_STRING,\n                                               NULL, NULL);\n    }\n\n    rc = 1;\n    items = weechat_string_split (vbuffer, \"\\n\", NULL,\n                                  WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                  | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                  | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                  0, &items_count);\n    for (i = 0; i < items_count; i++)\n    {\n        /* run modifier \"irc_out1_xxx\" (like \"irc_out_xxx\", but before split) */\n        irc_message_parse (server, items[i], NULL, NULL,\n                           &nick, NULL, NULL, &command, &channel, NULL, NULL,\n                           NULL, NULL, NULL, NULL);\n        snprintf (str_modifier, sizeof (str_modifier),\n                  \"irc_out1_%s\",\n                  (command) ? command : \"unknown\");\n        new_msg = weechat_hook_modifier_exec (str_modifier,\n                                              server->name,\n                                              items[i]);\n\n        /* no changes in new message */\n        if (new_msg && (strcmp (items[i], new_msg) == 0))\n        {\n            free (new_msg);\n            new_msg = NULL;\n        }\n\n        /* message not dropped? */\n        if (!new_msg || new_msg[0])\n        {\n            /* send signal with command that will be sent to server (before split) */\n            irc_server_send_signal (server, \"irc_out1\",\n                                    (command) ? command : \"unknown\",\n                                    (new_msg) ? new_msg : items[i],\n                                    NULL);\n\n            /*\n             * split message if needed (max is 512 bytes by default,\n             * including the final \"\\r\\n\")\n             */\n            hashtable = irc_message_split (server,\n                                           (new_msg) ? new_msg : items[i]);\n            if (hashtable)\n            {\n                number = 1;\n                while (1)\n                {\n                    snprintf (hash_key, sizeof (hash_key), \"msg%d\", number);\n                    str_message = weechat_hashtable_get (hashtable, hash_key);\n                    if (!str_message)\n                        break;\n                    snprintf (hash_key, sizeof (hash_key), \"args%d\", number);\n                    str_args = weechat_hashtable_get (hashtable, hash_key);\n\n                    rc = irc_server_send_one_msg (server, flags, str_message,\n                                                  nick, command, channel, tags);\n                    if (!rc)\n                        break;\n\n                    if (ret_hashtable)\n                    {\n                        snprintf (hash_key, sizeof (hash_key),\n                                  \"msg%d\", ret_number);\n                        weechat_hashtable_set (ret_hashtable,\n                                               hash_key, str_message);\n                        if (str_args)\n                        {\n                            snprintf (hash_key, sizeof (hash_key),\n                                      \"args%d\", ret_number);\n                            weechat_hashtable_set (ret_hashtable,\n                                                   hash_key, str_args);\n                        }\n                        ret_number++;\n                    }\n                    number++;\n                }\n                if (ret_hashtable)\n                {\n                    snprintf (value, sizeof (value), \"%d\", ret_number - 1);\n                    weechat_hashtable_set (ret_hashtable, \"count\", value);\n                }\n                weechat_hashtable_free (hashtable);\n                if (!rc)\n                    break;\n            }\n        }\n        if (nick)\n            free (nick);\n        if (command)\n            free (command);\n        if (channel)\n            free (channel);\n        if (new_msg)\n            free (new_msg);\n    }\n    if (items)\n        weechat_string_free_split (items);\n\n    free (vbuffer);\n\n    return ret_hashtable;\n}\n\n/*\n * Adds a message to received messages queue (at the end).\n */\n\nvoid\nirc_server_msgq_add_msg (struct t_irc_server *server, const char *msg)\n{\n    struct t_irc_message *message;\n\n    if (!server->unterminated_message && !msg[0])\n        return;\n\n    message = malloc (sizeof (*message));\n    if (!message)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: not enough memory for received message\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return;\n    }\n    message->server = server;\n    if (server->unterminated_message)\n    {\n        message->data = malloc (strlen (server->unterminated_message) +\n                                strlen (msg) + 1);\n        if (!message->data)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n        else\n        {\n            strcpy (message->data, server->unterminated_message);\n            strcat (message->data, msg);\n        }\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    else\n        message->data = strdup (msg);\n\n    message->next_message = NULL;\n\n    if (irc_msgq_last_msg)\n    {\n        irc_msgq_last_msg->next_message = message;\n        irc_msgq_last_msg = message;\n    }\n    else\n    {\n        irc_recv_msgq = message;\n        irc_msgq_last_msg = message;\n    }\n}\n\n/*\n * Adds an unterminated message to queue.\n */\n\nvoid\nirc_server_msgq_add_unterminated (struct t_irc_server *server,\n                                  const char *string)\n{\n    char *unterminated_message2;\n\n    if (!string[0])\n        return;\n\n    if (server->unterminated_message)\n    {\n        unterminated_message2 =\n            realloc (server->unterminated_message,\n                     (strlen (server->unterminated_message) +\n                      strlen (string) + 1));\n        if (!unterminated_message2)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            free (server->unterminated_message);\n            server->unterminated_message = NULL;\n            return;\n        }\n        server->unterminated_message = unterminated_message2;\n        strcat (server->unterminated_message, string);\n    }\n    else\n    {\n        server->unterminated_message = strdup (string);\n        if (!server->unterminated_message)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n    }\n}\n\n/*\n * Splits received buffer, creating queued messages.\n */\n\nvoid\nirc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)\n{\n    char *pos_cr, *pos_lf;\n\n    while (buffer[0])\n    {\n        pos_cr = strchr (buffer, '\\r');\n        pos_lf = strchr (buffer, '\\n');\n\n        if (!pos_cr && !pos_lf)\n        {\n            /* no CR/LF found => add to unterminated and return */\n            irc_server_msgq_add_unterminated (server, buffer);\n            return;\n        }\n\n        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))\n        {\n            /* found '\\r' first => ignore this char */\n            pos_cr[0] = '\\0';\n            irc_server_msgq_add_unterminated (server, buffer);\n            buffer = pos_cr + 1;\n        }\n        else\n        {\n            /* found: '\\n' first => terminate message */\n            pos_lf[0] = '\\0';\n            irc_server_msgq_add_msg (server, buffer);\n            buffer = pos_lf + 1;\n        }\n    }\n}\n\n/*\n * Flushes message queue.\n */\n\nvoid\nirc_server_msgq_flush ()\n{\n    struct t_irc_message *next;\n    char *ptr_data, *new_msg, *new_msg2, *ptr_msg, *ptr_msg2, *pos;\n    char *nick, *host, *command, *channel, *arguments;\n    char *msg_decoded, *msg_decoded_without_color;\n    char str_modifier[128], modifier_data[256];\n    int pos_channel, pos_text, pos_decode;\n\n    while (irc_recv_msgq)\n    {\n        if (irc_recv_msgq->data)\n        {\n            /* read message only if connection was not lost */\n            if (irc_recv_msgq->server->sock != -1)\n            {\n                ptr_data = irc_recv_msgq->data;\n                while (ptr_data[0] == ' ')\n                {\n                    ptr_data++;\n                }\n\n                if (ptr_data[0])\n                {\n                    irc_raw_print (irc_recv_msgq->server, IRC_RAW_FLAG_RECV,\n                                   ptr_data);\n\n                    irc_message_parse (irc_recv_msgq->server,\n                                       ptr_data, NULL, NULL, NULL, NULL, NULL,\n                                       &command, NULL, NULL, NULL, NULL, NULL,\n                                       NULL, NULL);\n                    snprintf (str_modifier, sizeof (str_modifier),\n                              \"irc_in_%s\",\n                              (command) ? command : \"unknown\");\n                    new_msg = weechat_hook_modifier_exec (\n                        str_modifier,\n                        irc_recv_msgq->server->name,\n                        ptr_data);\n                    if (command)\n                        free (command);\n\n                    /* no changes in new message */\n                    if (new_msg && (strcmp (ptr_data, new_msg) == 0))\n                    {\n                        free (new_msg);\n                        new_msg = NULL;\n                    }\n\n                    /* message not dropped? */\n                    if (!new_msg || new_msg[0])\n                    {\n                        /* use new message (returned by plugin) */\n                        ptr_msg = (new_msg) ? new_msg : ptr_data;\n\n                        while (ptr_msg && ptr_msg[0])\n                        {\n                            pos = strchr (ptr_msg, '\\n');\n                            if (pos)\n                                pos[0] = '\\0';\n\n                            if (new_msg)\n                            {\n                                irc_raw_print (\n                                    irc_recv_msgq->server,\n                                    IRC_RAW_FLAG_RECV | IRC_RAW_FLAG_MODIFIED,\n                                    ptr_msg);\n                            }\n\n                            irc_message_parse (irc_recv_msgq->server, ptr_msg,\n                                               NULL, NULL, &nick, NULL, &host,\n                                               &command, &channel, &arguments,\n                                               NULL, NULL, NULL,\n                                               &pos_channel, &pos_text);\n\n                            msg_decoded = NULL;\n\n\n                            switch (IRC_SERVER_OPTION_INTEGER(irc_recv_msgq->server,\n                                                              IRC_SERVER_OPTION_CHARSET_MESSAGE))\n                            {\n                                case IRC_SERVER_CHARSET_MESSAGE_MESSAGE:\n                                    pos_decode = 0;\n                                    break;\n                                case IRC_SERVER_CHARSET_MESSAGE_CHANNEL:\n                                    pos_decode = (pos_channel >= 0) ? pos_channel : pos_text;\n                                    break;\n                                case IRC_SERVER_CHARSET_MESSAGE_TEXT:\n                                    pos_decode = pos_text;\n                                    break;\n                                default:\n                                    pos_decode = 0;\n                                    break;\n                            }\n                            if (pos_decode >= 0)\n                            {\n                                /* convert charset for message */\n                                if (channel\n                                    && irc_channel_is_channel (irc_recv_msgq->server,\n                                                               channel))\n                                {\n                                    snprintf (modifier_data, sizeof (modifier_data),\n                                              \"%s.%s.%s\",\n                                              weechat_plugin->name,\n                                              irc_recv_msgq->server->name,\n                                              channel);\n                                }\n                                else\n                                {\n                                    if (nick && (!host || (strcmp (nick, host) != 0)))\n                                    {\n                                        snprintf (modifier_data,\n                                                  sizeof (modifier_data),\n                                                  \"%s.%s.%s\",\n                                                  weechat_plugin->name,\n                                                  irc_recv_msgq->server->name,\n                                                  nick);\n                                    }\n                                    else\n                                    {\n                                        snprintf (modifier_data,\n                                                  sizeof (modifier_data),\n                                                  \"%s.%s\",\n                                                  weechat_plugin->name,\n                                                  irc_recv_msgq->server->name);\n                                    }\n                                }\n                                msg_decoded = irc_message_convert_charset (\n                                    ptr_msg, pos_decode,\n                                    \"charset_decode\", modifier_data);\n                            }\n\n                            /* replace WeeChat internal color codes by \"?\" */\n                            msg_decoded_without_color =\n                                weechat_string_remove_color (\n                                    (msg_decoded) ? msg_decoded : ptr_msg,\n                                    \"?\");\n\n                            /* call modifier after charset */\n                            ptr_msg2 = (msg_decoded_without_color) ?\n                                msg_decoded_without_color : ((msg_decoded) ? msg_decoded : ptr_msg);\n                            snprintf (str_modifier, sizeof (str_modifier),\n                                      \"irc_in2_%s\",\n                                      (command) ? command : \"unknown\");\n                            new_msg2 = weechat_hook_modifier_exec (\n                                str_modifier,\n                                irc_recv_msgq->server->name,\n                                ptr_msg2);\n                            if (new_msg2 && (strcmp (ptr_msg2, new_msg2) == 0))\n                            {\n                                free (new_msg2);\n                                new_msg2 = NULL;\n                            }\n\n                            /* message not dropped? */\n                            if (!new_msg2 || new_msg2[0])\n                            {\n                                /* use new message (returned by plugin) */\n                                if (new_msg2)\n                                    ptr_msg2 = new_msg2;\n\n                                /* parse and execute command */\n                                if (irc_redirect_message (irc_recv_msgq->server,\n                                                          ptr_msg2, command,\n                                                          arguments))\n                                {\n                                    /* message redirected, we'll not display it! */\n                                }\n                                else\n                                {\n                                    /* message not redirected, display it */\n                                    irc_protocol_recv_command (\n                                        irc_recv_msgq->server,\n                                        ptr_msg2,\n                                        command,\n                                        channel);\n                                }\n                            }\n\n                            if (new_msg2)\n                                free (new_msg2);\n                            if (nick)\n                                free (nick);\n                            if (host)\n                                free (host);\n                            if (command)\n                                free (command);\n                            if (channel)\n                                free (channel);\n                            if (arguments)\n                                free (arguments);\n                            if (msg_decoded)\n                                free (msg_decoded);\n                            if (msg_decoded_without_color)\n                                free (msg_decoded_without_color);\n\n                            if (pos)\n                            {\n                                pos[0] = '\\n';\n                                ptr_msg = pos + 1;\n                            }\n                            else\n                                ptr_msg = NULL;\n                        }\n                    }\n                    else\n                    {\n                        irc_raw_print (irc_recv_msgq->server,\n                                       IRC_RAW_FLAG_RECV | IRC_RAW_FLAG_MODIFIED,\n                                       _(\"(message dropped)\"));\n                    }\n                    if (new_msg)\n                        free (new_msg);\n                }\n            }\n            free (irc_recv_msgq->data);\n        }\n\n        next = irc_recv_msgq->next_message;\n        free (irc_recv_msgq);\n        irc_recv_msgq = next;\n        if (!irc_recv_msgq)\n            irc_msgq_last_msg = NULL;\n    }\n}\n\n/*\n * Receives data from a server.\n */\n\nint\nirc_server_recv_cb (const void *pointer, void *data, int fd)\n{\n    struct t_irc_server *server;\n    static char buffer[4096 + 2];\n    int num_read, msgq_flush, end_recv;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) fd;\n\n    server = (struct t_irc_server *)pointer;\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    msgq_flush = 0;\n    end_recv = 0;\n\n    while (!end_recv)\n    {\n        end_recv = 1;\n\n#ifdef HAVE_GNUTLS\n        if (server->ssl_connected)\n            num_read = gnutls_record_recv (server->gnutls_sess, buffer,\n                                           sizeof (buffer) - 2);\n        else\n#endif /* HAVE_GNUTLS */\n            num_read = recv (server->sock, buffer, sizeof (buffer) - 2, 0);\n\n        if (num_read > 0)\n        {\n            buffer[num_read] = '\\0';\n            irc_server_msgq_add_buffer (server, buffer);\n            msgq_flush = 1;  /* the flush will be done after the loop */\n#ifdef HAVE_GNUTLS\n            if (server->ssl_connected\n                && (gnutls_record_check_pending (server->gnutls_sess) > 0))\n            {\n                /*\n                 * if there are unread data in the gnutls buffers,\n                 * go on with recv\n                 */\n                end_recv = 0;\n            }\n#endif /* HAVE_GNUTLS */\n        }\n        else\n        {\n#ifdef HAVE_GNUTLS\n            if (server->ssl_connected)\n            {\n                if ((num_read == 0)\n                    || ((num_read != GNUTLS_E_AGAIN)\n                        && (num_read != GNUTLS_E_INTERRUPTED)))\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: reading data on socket: error %d %s\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                        num_read,\n                        (num_read == 0) ? _(\"(connection closed by peer)\") :\n                        gnutls_strerror (num_read));\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: disconnecting from server...\"),\n                        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n                    irc_server_disconnect (server, !server->is_connected, 1);\n                }\n            }\n            else\n#endif /* HAVE_GNUTLS */\n            {\n                if ((num_read == 0)\n                    || ((errno != EAGAIN) && (errno != EWOULDBLOCK)))\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: reading data on socket: error %d %s\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                        errno,\n                        (num_read == 0) ? _(\"(connection closed by peer)\") :\n                        strerror (errno));\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s%s: disconnecting from server...\"),\n                        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n                    irc_server_disconnect (server, !server->is_connected, 1);\n                }\n            }\n        }\n    }\n\n    if (msgq_flush)\n        irc_server_msgq_flush ();\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback for server connection: it is called if WeeChat is TCP-connected to\n * server, but did not receive message 001.\n */\n\nint\nirc_server_timer_connection_cb (const void *pointer, void *data,\n                                int remaining_calls)\n{\n    struct t_irc_server *server;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    server = (struct t_irc_server *)pointer;\n\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    server->hook_timer_connection = NULL;\n\n    if (!server->is_connected)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connection timeout (message 001 not received)\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        irc_server_disconnect (server, !server->is_connected, 1);\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback for SASL authentication timer: it is called if there is a timeout\n * with SASL authentication (if SASL authentication is OK or failed, then hook\n * timer is removed before this callback is called).\n */\n\nint\nirc_server_timer_sasl_cb (const void *pointer, void *data, int remaining_calls)\n{\n    struct t_irc_server *server;\n    int sasl_fail;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    server = (struct t_irc_server *)pointer;\n\n    if (!server)\n        return WEECHAT_RC_ERROR;\n\n    server->hook_timer_sasl = NULL;\n\n    if (!server->is_connected)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: SASL authentication timeout\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        sasl_fail = IRC_SERVER_OPTION_INTEGER(server,\n                                              IRC_SERVER_OPTION_SASL_FAIL);\n        if ((sasl_fail == IRC_SERVER_SASL_FAIL_RECONNECT)\n            || (sasl_fail == IRC_SERVER_SASL_FAIL_DISCONNECT))\n        {\n            irc_server_disconnect (\n                server, 0,\n                (sasl_fail == IRC_SERVER_SASL_FAIL_RECONNECT) ? 1 : 0);\n        }\n        else\n            irc_server_sendf (server, 0, NULL, \"CAP END\");\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called for each manual join of a server: deletes old channels in the\n * hashtable.\n */\n\nvoid\nirc_server_check_join_manual_cb (void *data,\n                                 struct t_hashtable *hashtable,\n                                 const void *key, const void *value)\n{\n    /* make C compiler happy */\n    (void) data;\n\n    if (*((time_t *)value) + (60 * 10) < time (NULL))\n        weechat_hashtable_remove (hashtable, key);\n}\n\n/*\n * Callback called for each join without switch of a server: deletes old channel\n * in the hashtable.\n */\n\nvoid\nirc_server_check_join_noswitch_cb (void *data,\n                                   struct t_hashtable *hashtable,\n                                   const void *key, const void *value)\n{\n    /* make C compiler happy */\n    (void) data;\n\n    if (*((time_t *)value) + (60 * 10) < time (NULL))\n        weechat_hashtable_remove (hashtable, key);\n}\n\n/*\n * Callback called for each smart filtered join of a channel: deletes old\n * entries in the hashtable.\n */\n\nvoid\nirc_server_check_join_smart_filtered_cb (void *data,\n                                         struct t_hashtable *hashtable,\n                                         const void *key, const void *value)\n{\n    int unmask_delay;\n\n    /* make C compiler happy */\n    (void) data;\n\n    unmask_delay = weechat_config_integer (irc_config_look_smart_filter_join_unmask);\n    if ((unmask_delay == 0)\n        || (*((time_t *)value) < time (NULL) - (unmask_delay * 60)))\n    {\n        weechat_hashtable_remove (hashtable, key);\n    }\n}\n\n/*\n * Timer called each second to perform some operations on servers.\n */\n\nint\nirc_server_timer_cb (const void *pointer, void *data, int remaining_calls)\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_redirect *ptr_redirect, *ptr_next_redirect;\n    time_t current_time;\n    static struct timeval tv;\n    int away_check, refresh_lag;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) remaining_calls;\n\n    current_time = time (NULL);\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        /* check if reconnection is pending */\n        if ((!ptr_server->is_connected)\n            && (ptr_server->reconnect_start > 0)\n            && (current_time >= (ptr_server->reconnect_start + ptr_server->reconnect_delay)))\n        {\n            irc_server_reconnect (ptr_server);\n        }\n        else\n        {\n            if (!ptr_server->is_connected)\n                continue;\n\n            /* send queued messages */\n            irc_server_outqueue_send (ptr_server);\n\n            /* check for lag */\n            if ((weechat_config_integer (irc_config_network_lag_check) > 0)\n                && (ptr_server->lag_check_time.tv_sec == 0)\n                && (current_time >= ptr_server->lag_next_check))\n            {\n                irc_server_sendf (ptr_server, 0, NULL, \"PING %s\",\n                                  (ptr_server->current_address) ?\n                                  ptr_server->current_address : \"weechat\");\n                gettimeofday (&(ptr_server->lag_check_time), NULL);\n                ptr_server->lag = 0;\n                ptr_server->lag_last_refresh = 0;\n            }\n            else\n            {\n                /* check away (only if lag check was not done) */\n                away_check = IRC_SERVER_OPTION_INTEGER(\n                    ptr_server, IRC_SERVER_OPTION_AWAY_CHECK);\n                if (!weechat_hashtable_has_key (ptr_server->cap_list,\n                                                \"away-notify\")\n                    && (away_check > 0)\n                    && ((ptr_server->last_away_check == 0)\n                        || (current_time >= ptr_server->last_away_check + (away_check * 60))))\n                {\n                    irc_server_check_away (ptr_server);\n                }\n            }\n\n            /* check if it's time to autojoin channels (after command delay) */\n            if ((ptr_server->command_time != 0)\n                && (current_time >= ptr_server->command_time +\n                    IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_COMMAND_DELAY)))\n            {\n                irc_server_autojoin_channels (ptr_server);\n                ptr_server->command_time = 0;\n            }\n\n            /* check if it's time to send MONITOR command */\n            if ((ptr_server->monitor_time != 0)\n                && (current_time >= ptr_server->monitor_time))\n            {\n                if (ptr_server->monitor > 0)\n                    irc_notify_send_monitor (ptr_server);\n                ptr_server->monitor_time = 0;\n            }\n\n            /* compute lag */\n            if (ptr_server->lag_check_time.tv_sec != 0)\n            {\n                refresh_lag = 0;\n                gettimeofday (&tv, NULL);\n                ptr_server->lag = (int)(weechat_util_timeval_diff (&(ptr_server->lag_check_time),\n                                                                   &tv) / 1000);\n                /* refresh lag item if needed */\n                if (((ptr_server->lag_last_refresh == 0)\n                     || (current_time >= ptr_server->lag_last_refresh + weechat_config_integer (irc_config_network_lag_refresh_interval)))\n                    && (ptr_server->lag >= weechat_config_integer (irc_config_network_lag_min_show)))\n                {\n                    ptr_server->lag_last_refresh = current_time;\n                    if (ptr_server->lag != ptr_server->lag_displayed)\n                    {\n                        ptr_server->lag_displayed = ptr_server->lag;\n                        refresh_lag = 1;\n                    }\n                }\n                /* lag timeout? => disconnect */\n                if ((weechat_config_integer (irc_config_network_lag_reconnect) > 0)\n                    && (ptr_server->lag >= weechat_config_integer (irc_config_network_lag_reconnect) * 1000))\n                {\n                    weechat_printf (\n                        ptr_server->buffer,\n                        _(\"%s%s: lag is high, reconnecting to server %s%s%s\"),\n                        weechat_prefix (\"network\"),\n                        IRC_PLUGIN_NAME,\n                        IRC_COLOR_CHAT_SERVER,\n                        ptr_server->name,\n                        IRC_COLOR_RESET);\n                    irc_server_disconnect (ptr_server, 0, 1);\n                }\n                else\n                {\n                    /* stop lag counting if max lag is reached */\n                    if ((weechat_config_integer (irc_config_network_lag_max) > 0)\n                        && (ptr_server->lag >= (weechat_config_integer (irc_config_network_lag_max) * 1000)))\n                    {\n                        /* refresh lag item */\n                        ptr_server->lag_last_refresh = current_time;\n                        if (ptr_server->lag != ptr_server->lag_displayed)\n                        {\n                            ptr_server->lag_displayed = ptr_server->lag;\n                            refresh_lag = 1;\n                        }\n\n                        /* schedule next lag check in 5 seconds */\n                        ptr_server->lag_check_time.tv_sec = 0;\n                        ptr_server->lag_check_time.tv_usec = 0;\n                        ptr_server->lag_next_check = time (NULL) +\n                            weechat_config_integer (irc_config_network_lag_check);\n                    }\n                }\n                if (refresh_lag)\n                    irc_server_set_lag (ptr_server);\n            }\n\n            /* remove redirects if timeout occurs */\n            ptr_redirect = ptr_server->redirects;\n            while (ptr_redirect)\n            {\n                ptr_next_redirect = ptr_redirect->next_redirect;\n\n                if ((ptr_redirect->start_time > 0)\n                    && (ptr_redirect->start_time + ptr_redirect->timeout < current_time))\n                {\n                    irc_redirect_stop (ptr_redirect, \"timeout\");\n                }\n\n                ptr_redirect = ptr_next_redirect;\n            }\n\n            /* purge some data (every 10 minutes) */\n            if (current_time > ptr_server->last_data_purge + (60 * 10))\n            {\n                weechat_hashtable_map (ptr_server->join_manual,\n                                       &irc_server_check_join_manual_cb,\n                                       NULL);\n                weechat_hashtable_map (ptr_server->join_noswitch,\n                                       &irc_server_check_join_noswitch_cb,\n                                       NULL);\n                for (ptr_channel = ptr_server->channels; ptr_channel;\n                     ptr_channel = ptr_channel->next_channel)\n                {\n                    if (ptr_channel->join_smart_filtered)\n                    {\n                        weechat_hashtable_map (ptr_channel->join_smart_filtered,\n                                               &irc_server_check_join_smart_filtered_cb,\n                                               NULL);\n                    }\n                }\n                ptr_server->last_data_purge = current_time;\n            }\n        }\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Closes server connection.\n */\n\nvoid\nirc_server_close_connection (struct t_irc_server *server)\n{\n    int i;\n\n    if (server->hook_timer_connection)\n    {\n        weechat_unhook (server->hook_timer_connection);\n        server->hook_timer_connection = NULL;\n    }\n\n    if (server->hook_timer_sasl)\n    {\n        weechat_unhook (server->hook_timer_sasl);\n        server->hook_timer_sasl = NULL;\n    }\n\n    if (server->hook_fd)\n    {\n        weechat_unhook (server->hook_fd);\n        server->hook_fd = NULL;\n    }\n\n    if (server->hook_connect)\n    {\n        weechat_unhook (server->hook_connect);\n        server->hook_connect = NULL;\n    }\n    else\n    {\n#ifdef HAVE_GNUTLS\n        /* close SSL connection */\n        if (server->ssl_connected)\n        {\n            if (server->sock != -1)\n                gnutls_bye (server->gnutls_sess, GNUTLS_SHUT_WR);\n            gnutls_deinit (server->gnutls_sess);\n        }\n#endif /* HAVE_GNUTLS */\n    }\n    if (server->sock != -1)\n    {\n#ifdef _WIN32\n        closesocket (server->sock);\n#else\n        close (server->sock);\n#endif /* _WIN32 */\n        server->sock = -1;\n    }\n\n    /* free any pending message */\n    if (server->unterminated_message)\n    {\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n    {\n        irc_server_outqueue_free_all (server, i);\n    }\n\n    /* remove all redirects */\n    irc_redirect_free_all (server);\n\n    /* remove all manual joins */\n    weechat_hashtable_remove_all (server->join_manual);\n\n    /* remove all keys for pending joins */\n    weechat_hashtable_remove_all (server->join_channel_key);\n\n    /* remove all keys for joins without switch */\n    weechat_hashtable_remove_all (server->join_noswitch);\n\n    /* server is now disconnected */\n    server->is_connected = 0;\n    server->ssl_connected = 0;\n}\n\n/*\n * Schedules reconnection on server.\n */\n\nvoid\nirc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        /* growing reconnect delay */\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n\n        server->reconnect_start = time (NULL);\n\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}\n\n/*\n * Logins to server.\n */\n\nvoid\nirc_server_login (struct t_irc_server *server)\n{\n    const char *capabilities;\n    char *password, *username, *realname, *username2;\n\n    password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PASSWORD));\n    username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME));\n    realname = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME));\n\n    capabilities = IRC_SERVER_OPTION_STRING(\n        server, IRC_SERVER_OPTION_CAPABILITIES);\n\n    if (password && password[0])\n    {\n        irc_server_sendf (\n            server, 0, NULL,\n            \"PASS %s%s\",\n            ((password[0] == ':') || (strchr (password, ' '))) ? \":\" : \"\",\n            password);\n    }\n\n    if (!server->nick)\n    {\n        irc_server_set_nick (server,\n                             (server->nicks_array) ?\n                             server->nicks_array[0] : \"weechat\");\n        server->nick_first_tried = 0;\n    }\n    else\n        server->nick_first_tried = irc_server_get_nick_index (server);\n\n    server->nick_alternate_number = -1;\n\n    if (irc_server_sasl_enabled (server) || (capabilities && capabilities[0]))\n    {\n        irc_server_sendf (server, 0, NULL, \"CAP LS \" IRC_SERVER_VERSION_CAP);\n    }\n\n    username2 = (username && username[0]) ?\n        weechat_string_replace (username, \" \", \"_\") : strdup (\"weechat\");\n    irc_server_sendf (\n        server, 0, NULL,\n        \"NICK %s%s\\n\"\n        \"USER %s 0 * :%s\",\n        (server->nick && strchr (server->nick, ':')) ? \":\" : \"\",\n        server->nick,\n        (username2) ? username2 : \"weechat\",\n        (realname && realname[0]) ? realname : ((username2) ? username2 : \"weechat\"));\n    if (username2)\n        free (username2);\n\n    if (server->hook_timer_connection)\n        weechat_unhook (server->hook_timer_connection);\n    server->hook_timer_connection = weechat_hook_timer (\n        IRC_SERVER_OPTION_INTEGER (server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT) * 1000,\n        0, 1,\n        &irc_server_timer_connection_cb,\n        server, NULL);\n\n    if (password)\n        free (password);\n    if (username)\n        free (username);\n    if (realname)\n        free (realname);\n}\n\n/*\n * Switches address and tries another (called if connection failed with an\n * address/port).\n */\n\nvoid\nirc_server_switch_address (struct t_irc_server *server, int connection)\n{\n    if (server->addresses_count > 1)\n    {\n        irc_server_set_index_current_address (\n            server,\n            (server->index_current_address + 1) % server->addresses_count);\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: switching address to %s/%d\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port);\n        if (connection)\n        {\n            if (server->index_current_address == 0)\n                irc_server_reconnect_schedule (server);\n            else\n                irc_server_connect (server);\n        }\n    }\n    else\n    {\n        if (connection)\n            irc_server_reconnect_schedule (server);\n    }\n}\n\n/*\n * Reads connection status.\n */\n\nint\nirc_server_connect_cb (const void *pointer, void *data,\n                       int status, int gnutls_rc, int sock,\n                       const char *error, const char *ip_address)\n{\n    struct t_irc_server *server;\n    const char *proxy;\n\n    /* make C compiler happy */\n    (void) data;\n\n    server = (struct t_irc_server *)pointer;\n\n    proxy = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY);\n\n    server->hook_connect = NULL;\n\n    server->sock = sock;\n\n    switch (status)\n    {\n        case WEECHAT_HOOK_CONNECT_OK:\n            /* set IP */\n            if (server->current_ip)\n                free (server->current_ip);\n            server->current_ip = (ip_address) ? strdup (ip_address) : NULL;\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: connected to %s/%d (%s)\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                server->current_address,\n                server->current_port,\n                (server->current_ip) ? server->current_ip : \"?\");\n            server->hook_fd = weechat_hook_fd (server->sock,\n                                               1, 0, 0,\n                                               &irc_server_recv_cb,\n                                               server, NULL);\n            /* login to server */\n            irc_server_login (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_ADDRESS_NOT_FOUND:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy address \\\"%s\\\" not found\") :\n                _(\"%s%s: address \\\"%s\\\" not found\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                server->current_address);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_IP_ADDRESS_NOT_FOUND:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy IP address not found\") :\n                _(\"%s%s: IP address not found\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_CONNECTION_REFUSED:\n            weechat_printf (\n                server->buffer,\n                (proxy && proxy[0]) ?\n                _(\"%s%s: proxy connection refused\") :\n                _(\"%s%s: connection refused\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_PROXY_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: proxy fails to establish connection to server (check \"\n                  \"username/password if used and if server address/port is \"\n                  \"allowed by proxy)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_LOCAL_HOSTNAME_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unable to set local hostname/IP\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_GNUTLS_INIT_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: TLS init error\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: TLS handshake failed\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n#ifdef HAVE_GNUTLS\n            if (gnutls_rc == GNUTLS_E_DH_PRIME_UNACCEPTABLE)\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: you should play with option \"\n                      \"irc.server.%s.ssl_dhkey_size (current value is %d, try \"\n                      \"a lower value like %d or %d)\"),\n                    weechat_prefix (\"error\"),\n                    IRC_PLUGIN_NAME,\n                    server->name,\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE),\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE) / 2,\n                    IRC_SERVER_OPTION_INTEGER (\n                        server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE) / 4);\n            }\n#else\n            (void) gnutls_rc;\n#endif /* HAVE_GNUTLS */\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_MEMORY_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory (%s)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                (error) ? error : \"-\");\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            irc_server_reconnect_schedule (server);\n            break;\n        case WEECHAT_HOOK_CONNECT_TIMEOUT:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: timeout\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_switch_address (server, 1);\n            break;\n        case WEECHAT_HOOK_CONNECT_SOCKET_ERROR:\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unable to create socket\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n            if (error && error[0])\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: error: %s\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME, error);\n            }\n            irc_server_close_connection (server);\n            server->current_retry++;\n            irc_server_reconnect_schedule (server);\n            break;\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Sets the title for a server buffer.\n */\n\nvoid\nirc_server_set_buffer_title (struct t_irc_server *server)\n{\n    char *title;\n    int length;\n\n    if (server && server->buffer)\n    {\n        if (server->is_connected)\n        {\n            length = 16 +\n                ((server->current_address) ? strlen (server->current_address) : 16) +\n                16 + ((server->current_ip) ? strlen (server->current_ip) : 16) + 1;\n            title = malloc (length);\n            if (title)\n            {\n                snprintf (title, length, \"IRC: %s/%d (%s)\",\n                          server->current_address,\n                          server->current_port,\n                          (server->current_ip) ? server->current_ip : \"\");\n                weechat_buffer_set (server->buffer, \"title\", title);\n                free (title);\n            }\n        }\n        else\n        {\n            weechat_buffer_set (server->buffer, \"title\", \"\");\n        }\n    }\n}\n\n/*\n * Creates a buffer for a server.\n *\n * Returns pointer to buffer, NULL if error.\n */\n\nstruct t_gui_buffer *\nirc_server_create_buffer (struct t_irc_server *server)\n{\n    char buffer_name[256], charset_modifier[256];\n    struct t_gui_buffer *ptr_buffer_for_merge;\n\n    ptr_buffer_for_merge = NULL;\n    switch (weechat_config_integer (irc_config_look_server_buffer))\n    {\n        case IRC_CONFIG_LOOK_SERVER_BUFFER_MERGE_WITH_CORE:\n            /* merge with WeeChat core buffer */\n            ptr_buffer_for_merge = weechat_buffer_search_main ();\n            break;\n        case IRC_CONFIG_LOOK_SERVER_BUFFER_MERGE_WITHOUT_CORE:\n            /* find buffer used to merge all IRC server buffers */\n            ptr_buffer_for_merge = irc_buffer_search_server_lowest_number ();\n            break;\n    }\n\n    snprintf (buffer_name, sizeof (buffer_name),\n              \"server.%s\", server->name);\n    server->buffer = weechat_buffer_new (buffer_name,\n                                         &irc_input_data_cb, NULL, NULL,\n                                         &irc_buffer_close_cb, NULL, NULL);\n    if (!server->buffer)\n        return NULL;\n\n    if (!weechat_buffer_get_integer (server->buffer, \"short_name_is_set\"))\n        weechat_buffer_set (server->buffer, \"short_name\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_type\", \"server\");\n    weechat_buffer_set (server->buffer, \"localvar_set_server\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_channel\", server->name);\n    snprintf (charset_modifier, sizeof (charset_modifier),\n              \"irc.%s\", server->name);\n    weechat_buffer_set (server->buffer, \"localvar_set_charset_modifier\",\n                        charset_modifier);\n\n    (void) weechat_hook_signal_send (\"logger_backlog\",\n                                     WEECHAT_HOOK_SIGNAL_POINTER,\n                                     server->buffer);\n\n    if (weechat_config_boolean (irc_config_network_send_unknown_commands))\n        weechat_buffer_set (server->buffer, \"input_get_unknown_commands\", \"1\");\n\n    /* set highlights settings on server buffer */\n    weechat_buffer_set (server->buffer, \"highlight_words_add\",\n                        weechat_config_string (irc_config_look_highlight_server));\n    if (weechat_config_string (irc_config_look_highlight_tags_restrict)\n        && weechat_config_string (irc_config_look_highlight_tags_restrict)[0])\n    {\n        weechat_buffer_set (\n            server->buffer, \"highlight_tags_restrict\",\n            weechat_config_string (irc_config_look_highlight_tags_restrict));\n    }\n\n    irc_server_set_buffer_title (server);\n\n    /*\n     * merge buffer if needed: if merge with(out) core set, and if no layout\n     * number is assigned for this buffer (if layout number is assigned, then\n     * buffer was already moved/merged by WeeChat core)\n     */\n    if (ptr_buffer_for_merge\n        && (weechat_buffer_get_integer (server->buffer, \"layout_number\") < 1))\n    {\n        weechat_buffer_merge (server->buffer, ptr_buffer_for_merge);\n    }\n\n    (void) weechat_hook_signal_send (\"irc_server_opened\",\n                                     WEECHAT_HOOK_SIGNAL_POINTER,\n                                     server->buffer);\n\n    return server->buffer;\n}\n\n/*\n * Searches for a fingerprint digest algorithm with the size (in bits).\n *\n * Returns index of algo in enum t_irc_fingerprint_digest_algo,\n * -1 if not found.\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_fingerprint_search_algo_with_size (int size)\n{\n    int i;\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        if (irc_fingerprint_digest_algos_size[i] == size)\n            return i;\n    }\n\n    /* digest algorithm not found */\n    return -1;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Returns a string with sizes of allowed fingerprint,\n * in number of hexadecimal digits (== bits / 4).\n *\n * Example of output: \"128=SHA-512, 64=SHA-256, 40=SHA-1\".\n *\n * Note: result must be freed after use.\n */\n\n#ifdef HAVE_GNUTLS\nchar *\nirc_server_fingerprint_str_sizes ()\n{\n    char str_sizes[1024], str_one_size[128];\n    int i;\n\n    str_sizes[0] = '\\0';\n\n    for (i = IRC_FINGERPRINT_NUM_ALGOS - 1; i >= 0; i--)\n    {\n        snprintf (str_one_size, sizeof (str_one_size),\n                  \"%d=%s%s\",\n                  irc_fingerprint_digest_algos_size[i] / 4,\n                  irc_fingerprint_digest_algos_name[i],\n                  (i > 0) ? \", \" : \"\");\n        strcat (str_sizes, str_one_size);\n    }\n\n    return strdup (str_sizes);\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Compares two fingerprints: one hexadecimal (given by user), the second binary\n * (received from IRC server).\n *\n * Returns:\n *    0: fingerprints are the same\n *   -1: fingerprints are different\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_compare_fingerprints (const char *fingerprint,\n                                 const unsigned char *fingerprint_server,\n                                 ssize_t fingerprint_size)\n{\n    ssize_t i;\n    unsigned int value;\n\n    if ((ssize_t)strlen (fingerprint) != fingerprint_size * 2)\n        return -1;\n\n    for (i = 0; i < fingerprint_size; i++)\n    {\n        if (sscanf (&fingerprint[i * 2], \"%02x\", &value) != 1)\n            return -1;\n        if (value != fingerprint_server[i])\n            return -1;\n    }\n\n    /* fingerprints are the same */\n    return 0;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Checks if a GnuTLS session uses the certificate with a given fingerprint.\n *\n * Returns:\n *   1: certificate has the good fingerprint\n *   0: certificate does NOT have the good fingerprint\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_check_certificate_fingerprint (struct t_irc_server *server,\n                                          gnutls_x509_crt_t certificate,\n                                          const char *good_fingerprints)\n{\n    unsigned char *fingerprint_server[IRC_FINGERPRINT_NUM_ALGOS];\n    char **fingerprints;\n    int i, rc, algo;\n    size_t size_bits, size_bytes;\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        fingerprint_server[i] = NULL;\n    }\n\n    /* split good_fingerprints */\n    fingerprints = weechat_string_split (good_fingerprints, \",\", NULL,\n                                         WEECHAT_STRING_SPLIT_STRIP_LEFT\n                                         | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                                         | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                                         0, NULL);\n    if (!fingerprints)\n        return 0;\n\n    rc = 0;\n\n    for (i = 0; fingerprints[i]; i++)\n    {\n        size_bits = strlen (fingerprints[i]) * 4;\n        size_bytes = size_bits / 8;\n\n        algo = irc_server_fingerprint_search_algo_with_size (size_bits);\n        if (algo < 0)\n            continue;\n\n        if (!fingerprint_server[algo])\n        {\n            fingerprint_server[algo] = malloc (size_bytes);\n            if (fingerprint_server[algo])\n            {\n                /* calculate the fingerprint for the certificate */\n                if (gnutls_x509_crt_get_fingerprint (\n                        certificate,\n                        irc_fingerprint_digest_algos[algo],\n                        fingerprint_server[algo],\n                        &size_bytes) != GNUTLS_E_SUCCESS)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: failed to calculate certificate \"\n                          \"fingerprint (%s)\"),\n                        weechat_prefix (\"error\"),\n                        irc_fingerprint_digest_algos_name[algo]);\n                    free (fingerprint_server[algo]);\n                    fingerprint_server[algo] = NULL;\n                }\n            }\n            else\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%s%s: not enough memory (%s)\"),\n                    weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                    \"fingerprint\");\n            }\n        }\n\n        if (fingerprint_server[algo])\n        {\n            /* check if the fingerprint matches */\n            if (irc_server_compare_fingerprints (fingerprints[i],\n                                                 fingerprint_server[algo],\n                                                 size_bytes) == 0)\n            {\n                rc = 1;\n                break;\n            }\n        }\n    }\n\n    weechat_string_free_split (fingerprints);\n\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        if (fingerprint_server[i])\n            free (fingerprint_server[i]);\n    }\n\n    return rc;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * GnuTLS callback called during handshake.\n *\n * Returns:\n *    0: certificate OK\n *   -1: error in certificate\n */\n\n#ifdef HAVE_GNUTLS\nint\nirc_server_gnutls_callback (const void *pointer, void *data,\n                            gnutls_session_t tls_session,\n                            const gnutls_datum_t *req_ca, int nreq,\n                            const gnutls_pk_algorithm_t *pk_algos,\n                            int pk_algos_len,\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n                            gnutls_retr2_st *answer,\n#else\n                            gnutls_retr_st *answer,\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n                            int action)\n{\n    struct t_irc_server *server;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n    gnutls_retr2_st tls_struct;\n#else\n    gnutls_retr_st tls_struct;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n    gnutls_x509_crt_t cert_temp;\n    const gnutls_datum_t *cert_list;\n    gnutls_datum_t filedatum;\n    unsigned int i, cert_list_len, status;\n    time_t cert_time;\n    char *cert_path0, *cert_path1, *cert_path2, *cert_str, *fingerprint_eval;\n    char *weechat_dir, *ssl_password;\n    const char *ptr_fingerprint;\n    int rc, ret, fingerprint_match, hostname_match, cert_temp_init;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n    gnutls_datum_t cinfo;\n    int rinfo;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n\n    /* make C compiler happy */\n    (void) data;\n    (void) req_ca;\n    (void) nreq;\n    (void) pk_algos;\n    (void) pk_algos_len;\n\n    rc = 0;\n\n    if (!pointer)\n        return -1;\n\n    server = (struct t_irc_server *) pointer;\n    cert_temp_init = 0;\n    cert_list = NULL;\n    cert_list_len = 0;\n    fingerprint_eval = NULL;\n    weechat_dir = NULL;\n\n    if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_VERIFY_CERT)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%sgnutls: connected using %d-bit Diffie-Hellman shared secret \"\n              \"exchange\"),\n            weechat_prefix (\"network\"),\n            IRC_SERVER_OPTION_INTEGER (server,\n                                       IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n\n        /* initialize the certificate structure */\n        if (gnutls_x509_crt_init (&cert_temp) != GNUTLS_E_SUCCESS)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: failed to initialize certificate structure\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n            goto end;\n        }\n\n        /* flag to do the \"deinit\" (at the end of function) */\n        cert_temp_init = 1;\n\n        /* get fingerprint option in server */\n        ptr_fingerprint = IRC_SERVER_OPTION_STRING(server,\n                                                   IRC_SERVER_OPTION_SSL_FINGERPRINT);\n        fingerprint_eval = irc_server_eval_fingerprint (server);\n        if (!fingerprint_eval)\n        {\n            rc = -1;\n            goto end;\n        }\n\n        /* set match options */\n        fingerprint_match = (ptr_fingerprint && ptr_fingerprint[0]) ? 0 : 1;\n        hostname_match = 0;\n\n        /* get the peer's raw certificate (chain) as sent by the peer */\n        cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n        if (cert_list)\n        {\n            weechat_printf (\n                server->buffer,\n                NG_(\"%sgnutls: receiving %d certificate\",\n                    \"%sgnutls: receiving %d certificates\",\n                    cert_list_len),\n                weechat_prefix (\"network\"),\n                cert_list_len);\n\n            for (i = 0; i < cert_list_len; i++)\n            {\n                if (gnutls_x509_crt_import (cert_temp,\n                                            &cert_list[i],\n                                            GNUTLS_X509_FMT_DER) != GNUTLS_E_SUCCESS)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: failed to import certificate[%d]\"),\n                        weechat_prefix (\"error\"), i + 1);\n                    rc = -1;\n                    goto end;\n                }\n\n                /* checks on first certificate received */\n                if (i == 0)\n                {\n                    /* check if fingerprint matches the first certificate */\n                    if (fingerprint_eval && fingerprint_eval[0])\n                    {\n                        fingerprint_match = irc_server_check_certificate_fingerprint (\n                            server, cert_temp, fingerprint_eval);\n                    }\n                    /* check if hostname matches in the first certificate */\n                    if (gnutls_x509_crt_check_hostname (cert_temp,\n                                                        server->current_address) != 0)\n                    {\n                        hostname_match = 1;\n                    }\n                }\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n                /* display infos about certificate */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400 /* 2.4.0 */\n                rinfo = gnutls_x509_crt_print (cert_temp,\n                                               GNUTLS_X509_CRT_ONELINE, &cinfo);\n#else\n                rinfo = gnutls_x509_crt_print (cert_temp,\n                                               GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n#endif /*  LIBGNUTLS_VERSION_NUMBER < 0x020400 */\n                if (rinfo == 0)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%s - certificate[%d] info:\"),\n                        weechat_prefix (\"network\"), i + 1);\n                    weechat_printf (\n                        server->buffer,\n                        \"%s   - %s\",\n                        weechat_prefix (\"network\"), cinfo.data);\n                    gnutls_free (cinfo.data);\n                }\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n                /* check dates, only if fingerprint is not set */\n                if (!ptr_fingerprint || !ptr_fingerprint[0])\n                {\n                    /* check expiration date */\n                    cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n                    if (cert_time < time (NULL))\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: certificate has expired\"),\n                            weechat_prefix (\"error\"));\n                        rc = -1;\n                    }\n                    /* check activation date */\n                    cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n                    if (cert_time > time (NULL))\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: certificate is not yet activated\"),\n                            weechat_prefix (\"error\"));\n                        rc = -1;\n                    }\n                }\n            }\n\n            /*\n             * if fingerprint is set, display if matches, and don't check\n             * anything else\n             */\n            if (ptr_fingerprint && ptr_fingerprint[0])\n            {\n                if (fingerprint_match)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: certificate fingerprint matches\"),\n                        weechat_prefix (\"network\"));\n                }\n                else\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: certificate fingerprint does NOT match \"\n                          \"(check value of option \"\n                          \"irc.server.%s.ssl_fingerprint)\"),\n                        weechat_prefix (\"error\"), server->name);\n                    rc = -1;\n                }\n                goto end;\n            }\n\n            if (!hostname_match)\n            {\n                weechat_printf (\n                    server->buffer,\n                    _(\"%sgnutls: the hostname in the certificate does NOT \"\n                      \"match \\\"%s\\\"\"),\n                    weechat_prefix (\"error\"), server->current_address);\n                rc = -1;\n            }\n        }\n\n        /* verify the peer\u2019s certificate */\n        if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: error while checking peer's certificate\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n            goto end;\n        }\n\n        /* check if certificate is trusted */\n        if (status & GNUTLS_CERT_INVALID)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate is NOT trusted\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate is trusted\"),\n                weechat_prefix (\"network\"));\n        }\n\n        /* check if certificate issuer is known */\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: peer's certificate issuer is unknown\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n\n        /* check that certificate is not revoked */\n        if (status & GNUTLS_CERT_REVOKED)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%sgnutls: the certificate has been revoked\"),\n                weechat_prefix (\"error\"));\n            rc = -1;\n        }\n    }\n    else if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_SET_CERT)\n    {\n        /* using client certificate if it exists */\n        cert_path0 = (char *) IRC_SERVER_OPTION_STRING(\n            server, IRC_SERVER_OPTION_SSL_CERT);\n        if (cert_path0 && cert_path0[0])\n        {\n            weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n            cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n            cert_path2 = (cert_path1) ?\n                weechat_string_expand_home (cert_path1) : NULL;\n\n            if (cert_path2)\n            {\n                cert_str = weechat_file_get_content (cert_path2);\n                if (cert_str)\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: sending one certificate\"),\n                        weechat_prefix (\"network\"));\n\n                    filedatum.data = (unsigned char *) cert_str;\n                    filedatum.size = strlen (cert_str);\n\n                    /* certificate */\n                    gnutls_x509_crt_init (&server->tls_cert);\n                    gnutls_x509_crt_import (server->tls_cert, &filedatum,\n                                            GNUTLS_X509_FMT_PEM);\n\n                    /* key password */\n                    ssl_password = irc_server_eval_expression (\n                        server,\n                        IRC_SERVER_OPTION_STRING(server,\n                                                 IRC_SERVER_OPTION_SSL_PASSWORD));\n\n                    /* key */\n                    gnutls_x509_privkey_init (&server->tls_cert_key);\n\n/*\n * gnutls_x509_privkey_import2 has no \"Since: ...\" in GnuTLS manual but\n * GnuTLS NEWS file lists it being added in 3.1.0:\n * https://gitlab.com/gnutls/gnutls/blob/2b715b9564681acb3008a5574dcf25464de8b038/NEWS#L2552\n */\n#if LIBGNUTLS_VERSION_NUMBER >= 0x030100 /* 3.1.0 */\n                    ret = gnutls_x509_privkey_import2 (server->tls_cert_key,\n                                                       &filedatum,\n                                                       GNUTLS_X509_FMT_PEM,\n                                                       ssl_password,\n                                                       0);\n#else\n                    ret = gnutls_x509_privkey_import (server->tls_cert_key,\n                                                      &filedatum,\n                                                      GNUTLS_X509_FMT_PEM);\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x0301000 */\n\n                    if (ret < 0)\n                    {\n                        ret = gnutls_x509_privkey_import_pkcs8 (\n                            server->tls_cert_key,\n                            &filedatum,\n                            GNUTLS_X509_FMT_PEM,\n                            ssl_password,\n                            GNUTLS_PKCS_PLAIN);\n                    }\n                    if (ret < 0)\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%sgnutls: invalid certificate \\\"%s\\\", error: \"\n                              \"%s\"),\n                            weechat_prefix (\"error\"), cert_path2,\n                            gnutls_strerror (ret));\n                        rc = -1;\n                    }\n                    else\n                    {\n\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n                        tls_struct.cert_type = GNUTLS_CRT_X509;\n                        tls_struct.key_type = GNUTLS_PRIVKEY_X509;\n#else\n                        tls_struct.type = GNUTLS_CRT_X509;\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n                        tls_struct.ncerts = 1;\n                        tls_struct.deinit_all = 0;\n                        tls_struct.cert.x509 = &server->tls_cert;\n                        tls_struct.key.x509 = server->tls_cert_key;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706 /* 1.7.6 */\n                        /* client certificate info */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400 /* 2.4.0 */\n                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                       GNUTLS_X509_CRT_ONELINE,\n                                                       &cinfo);\n#else\n                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                       GNUTLS_CRT_PRINT_ONELINE,\n                                                       &cinfo);\n#endif /* LIBGNUTLS_VERSION_NUMBER < 0x020400 */\n                        if (rinfo == 0)\n                        {\n                            weechat_printf (\n                                server->buffer,\n                                _(\"%s - client certificate info (%s):\"),\n                                weechat_prefix (\"network\"), cert_path2);\n                            weechat_printf (\n                                server->buffer, \"%s  - %s\",\n                                weechat_prefix (\"network\"), cinfo.data);\n                            gnutls_free (cinfo.data);\n                        }\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x010706 */\n                        memcpy (answer, &tls_struct, sizeof (tls_struct));\n                        free (cert_str);\n                    }\n\n                    if (ssl_password)\n                        free (ssl_password);\n                }\n                else\n                {\n                    weechat_printf (\n                        server->buffer,\n                        _(\"%sgnutls: unable to read certificate \\\"%s\\\"\"),\n                        weechat_prefix (\"error\"), cert_path2);\n                }\n            }\n\n            if (cert_path1)\n                free (cert_path1);\n            if (cert_path2)\n                free (cert_path2);\n        }\n    }\n\nend:\n    /* an error should stop the handshake unless the user doesn't care */\n    if ((rc == -1)\n        && (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY) == 0))\n    {\n        rc = 0;\n    }\n\n    if (cert_temp_init)\n        gnutls_x509_crt_deinit (cert_temp);\n    if (weechat_dir)\n        free (weechat_dir);\n    if (fingerprint_eval)\n        free (fingerprint_eval);\n\n    return rc;\n}\n#endif /* HAVE_GNUTLS */\n\n/*\n * Connects to a server.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_connect (struct t_irc_server *server)\n{\n    int length;\n    char *option_name;\n    struct t_config_option *proxy_type, *proxy_ipv6, *proxy_address;\n    struct t_config_option *proxy_port;\n    const char *proxy, *str_proxy_type, *str_proxy_address;\n\n    server->disconnected = 0;\n\n    if (!server->buffer)\n    {\n        if (!irc_server_create_buffer (server))\n            return 0;\n        weechat_buffer_set (server->buffer, \"display\", \"auto\");\n    }\n\n    irc_bar_item_update_channel ();\n\n    irc_server_set_index_current_address (server,\n                                          server->index_current_address);\n\n    if (!server->current_address)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: unknown address for server \\\"%s\\\", cannot connect\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n        return 0;\n    }\n\n    /* free some old values (from a previous connection to server) */\n    if (server->isupport)\n    {\n        free (server->isupport);\n        server->isupport = NULL;\n    }\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    proxy_type = NULL;\n    proxy_ipv6 = NULL;\n    proxy_address = NULL;\n    proxy_port = NULL;\n    str_proxy_type = NULL;\n    str_proxy_address = NULL;\n\n    proxy = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY);\n    if (proxy && proxy[0])\n    {\n        length = 32 + strlen (proxy) + 1;\n        option_name = malloc (length);\n        if (!option_name)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory (%s)\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                \"proxy\");\n            return 0;\n        }\n        snprintf (option_name, length, \"weechat.proxy.%s.type\", proxy);\n        proxy_type = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.ipv6\", proxy);\n        proxy_ipv6 = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.address\", proxy);\n        proxy_address = weechat_config_get (option_name);\n        snprintf (option_name, length, \"weechat.proxy.%s.port\", proxy);\n        proxy_port = weechat_config_get (option_name);\n        free (option_name);\n        if (!proxy_type || !proxy_address)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: proxy \\\"%s\\\" not found for server \\\"%s\\\", cannot \"\n                  \"connect\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, proxy, server->name);\n            return 0;\n        }\n        str_proxy_type = weechat_config_string (proxy_type);\n        str_proxy_address = weechat_config_string (proxy_address);\n        if (!str_proxy_type[0] || !proxy_ipv6 || !str_proxy_address[0]\n            || !proxy_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: missing proxy settings, check options for proxy \"\n                  \"\\\"%s\\\"\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, proxy);\n            return 0;\n        }\n    }\n\n    if (!server->nicks_array)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: nicks not defined for server \\\"%s\\\", cannot connect\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME, server->name);\n        return 0;\n    }\n\n#ifndef HAVE_GNUTLS\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL))\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: cannot connect with SSL because WeeChat was not built \"\n              \"with GnuTLS support\"),\n            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return 0;\n    }\n#endif /* HAVE_GNUTLS */\n    if (proxy_type)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connecting to server %s/%d%s via %s proxy %s/%d%s...\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\",\n            str_proxy_type,\n            str_proxy_address,\n            weechat_config_integer (proxy_port),\n            (weechat_config_boolean (proxy_ipv6)) ? \" (IPv6)\" : \"\");\n        weechat_log_printf (\n            _(\"Connecting to server %s/%d%s via %s proxy %s/%d%s...\"),\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\",\n            str_proxy_type,\n            str_proxy_address,\n            weechat_config_integer (proxy_port),\n            (weechat_config_boolean (proxy_ipv6)) ? \" (IPv6)\" : \"\");\n    }\n    else\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: connecting to server %s/%d%s...\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\");\n        weechat_log_printf (\n            _(\"%s%s: connecting to server %s/%d%s...\"),\n            \"\",\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port,\n            (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)) ?\n            \" (SSL)\" : \"\");\n    }\n\n    /* close connection if opened */\n    irc_server_close_connection (server);\n\n    /* open auto-joined channels now (if needed) */\n    if (weechat_config_boolean (irc_config_look_buffer_open_before_autojoin)\n        && !server->disable_autojoin)\n    {\n        irc_server_autojoin_create_buffers (server);\n    }\n\n    /* init SSL if asked and connect */\n    server->ssl_connected = 0;\n#ifdef HAVE_GNUTLS\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL))\n        server->ssl_connected = 1;\n    server->hook_connect = weechat_hook_connect (\n        proxy,\n        server->current_address,\n        server->current_port,\n        proxy_type ? weechat_config_integer (proxy_ipv6) : IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6),\n        server->current_retry,\n        (server->ssl_connected) ? &server->gnutls_sess : NULL,\n        (server->ssl_connected) ? &irc_server_gnutls_callback : NULL,\n        IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE),\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PRIORITIES),\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME),\n        &irc_server_connect_cb,\n        server,\n        NULL);\n#else\n    server->hook_connect = weechat_hook_connect (\n        proxy,\n        server->current_address,\n        server->current_port,\n        proxy_type ? weechat_config_integer (proxy_ipv6) : IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6),\n        server->current_retry,\n        NULL, NULL, 0, NULL,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME),\n        &irc_server_connect_cb,\n        server,\n        NULL);\n#endif /* HAVE_GNUTLS */\n\n    /* send signal \"irc_server_connecting\" with server name */\n    (void) weechat_hook_signal_send (\"irc_server_connecting\",\n                                     WEECHAT_HOOK_SIGNAL_STRING, server->name);\n\n    return 1;\n}\n\n/*\n * Reconnects to a server (after disconnection).\n */\n\nvoid\nirc_server_reconnect (struct t_irc_server *server)\n{\n    weechat_printf (\n        server->buffer,\n        _(\"%s%s: reconnecting to server...\"),\n        weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n\n    server->reconnect_start = 0;\n\n    if (irc_server_connect (server))\n        server->reconnect_join = 1;\n    else\n        irc_server_reconnect_schedule (server);\n}\n\n/*\n * Callback for auto-connect to servers (called at startup).\n */\n\nint\nirc_server_auto_connect_timer_cb (const void *pointer, void *data,\n                                  int remaining_calls)\n{\n    struct t_irc_server *ptr_server;\n    int auto_connect;\n\n    /* make C compiler happy */\n    (void) data;\n    (void) remaining_calls;\n\n    auto_connect = (pointer) ? 1 : 0;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        if ((auto_connect || ptr_server->temp_server)\n            && (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOCONNECT)))\n        {\n            if (!irc_server_connect (ptr_server))\n                irc_server_reconnect_schedule (ptr_server);\n        }\n    }\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Auto-connects to servers (called at startup).\n *\n * If auto_connect == 1, auto-connects to all servers with flag \"autoconnect\".\n * If auto_connect == 0, auto-connect to temporary servers only.\n */\n\nvoid\nirc_server_auto_connect (int auto_connect)\n{\n    weechat_hook_timer (1, 0, 1,\n                        &irc_server_auto_connect_timer_cb,\n                        (auto_connect) ? (void *)1 : (void *)0,\n                        NULL);\n}\n\n/*\n * Disconnects from a server.\n */\n\nvoid\nirc_server_disconnect (struct t_irc_server *server, int switch_address,\n                       int reconnect)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        /*\n         * remove all nicks and write disconnection message on each\n         * channel/private buffer\n         */\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            irc_nick_free_all (server, ptr_channel);\n            if (ptr_channel->hook_autorejoin)\n            {\n                weechat_unhook (ptr_channel->hook_autorejoin);\n                ptr_channel->hook_autorejoin = NULL;\n            }\n            weechat_buffer_set (ptr_channel->buffer, \"localvar_del_away\", \"\");\n            weechat_printf (\n                ptr_channel->buffer,\n                _(\"%s%s: disconnected from server\"),\n                weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n        }\n        /* remove away status on server buffer */\n        weechat_buffer_set (server->buffer, \"localvar_del_away\", \"\");\n    }\n\n    irc_server_close_connection (server);\n\n    if (server->buffer)\n    {\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: disconnected from server\"),\n            weechat_prefix (\"network\"), IRC_PLUGIN_NAME);\n    }\n\n    server->current_retry = 0;\n\n    if (switch_address)\n        irc_server_switch_address (server, 0);\n    else\n        irc_server_set_index_current_address (server, 0);\n\n    if (server->nick_modes)\n    {\n        free (server->nick_modes);\n        server->nick_modes = NULL;\n        weechat_bar_item_update (\"input_prompt\");\n        weechat_bar_item_update (\"irc_nick_modes\");\n    }\n    if (server->host)\n    {\n        free (server->host);\n        server->host = NULL;\n        weechat_bar_item_update (\"irc_host\");\n        weechat_bar_item_update (\"irc_nick_host\");\n    }\n    server->checking_cap_ls = 0;\n    weechat_hashtable_remove_all (server->cap_ls);\n    server->checking_cap_list = 0;\n    weechat_hashtable_remove_all (server->cap_list);\n    server->is_away = 0;\n    server->away_time = 0;\n    server->lag = 0;\n    server->lag_displayed = -1;\n    server->lag_check_time.tv_sec = 0;\n    server->lag_check_time.tv_usec = 0;\n    server->lag_next_check = time (NULL) +\n        weechat_config_integer (irc_config_network_lag_check);\n    server->lag_last_refresh = 0;\n    irc_server_set_lag (server);\n    server->monitor = 0;\n    server->monitor_time = 0;\n\n    if (reconnect\n        && IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n        irc_server_reconnect_schedule (server);\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n\n    /* discard current nick if no reconnection asked */\n    if (!reconnect && server->nick)\n        irc_server_set_nick (server, NULL);\n\n    irc_server_set_buffer_title (server);\n\n    server->disconnected = 1;\n\n    /* send signal \"irc_server_disconnected\" with server name */\n    (void) weechat_hook_signal_send (\"irc_server_disconnected\",\n                                     WEECHAT_HOOK_SIGNAL_STRING, server->name);\n}\n\n/*\n * Disconnects from all servers.\n */\n\nvoid\nirc_server_disconnect_all ()\n{\n    struct t_irc_server *ptr_server;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        irc_server_disconnect (ptr_server, 0, 0);\n    }\n}\n\n/*\n * Creates buffers for auto-joined channels on a server.\n */\n\nvoid\nirc_server_autojoin_create_buffers (struct t_irc_server *server)\n{\n    const char *pos_space;\n    char *autojoin, *autojoin2, **channels;\n    int num_channels, i;\n\n    /* buffers are opened only if no channels are currently opened */\n    if (server->channels)\n        return;\n\n    /* evaluate server option \"autojoin\" */\n    autojoin = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN));\n\n    /* extract channel names from autojoin option */\n    if (autojoin && autojoin[0])\n    {\n        pos_space = strchr (autojoin, ' ');\n        autojoin2 = (pos_space) ?\n            weechat_strndup (autojoin, pos_space - autojoin) :\n            strdup (autojoin);\n        if (autojoin2)\n        {\n            channels = weechat_string_split (\n                autojoin2,\n                \",\",\n                NULL,\n                WEECHAT_STRING_SPLIT_STRIP_LEFT\n                | WEECHAT_STRING_SPLIT_STRIP_RIGHT\n                | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS,\n                0,\n                &num_channels);\n            if (channels)\n            {\n                for (i = 0; i < num_channels; i++)\n                {\n                    irc_channel_create_buffer (\n                        server, IRC_CHANNEL_TYPE_CHANNEL, channels[i],\n                        1, 1);\n                }\n                weechat_string_free_split (channels);\n            }\n            free (autojoin2);\n        }\n    }\n\n    if (autojoin)\n        free (autojoin);\n}\n\n/*\n * Autojoins (or auto-rejoins) channels.\n */\n\nvoid\nirc_server_autojoin_channels (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n    char *autojoin;\n\n    /* auto-join after disconnection (only rejoins opened channels) */\n    if (!server->disable_autojoin && server->reconnect_join && server->channels)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if ((ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                && !ptr_channel->part)\n            {\n                if (ptr_channel->key)\n                {\n                    irc_server_sendf (server,\n                                      IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                                      \"JOIN %s %s\",\n                                      ptr_channel->name, ptr_channel->key);\n                }\n                else\n                {\n                    irc_server_sendf (server,\n                                      IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                                      \"JOIN %s\",\n                                      ptr_channel->name);\n                }\n            }\n        }\n        server->reconnect_join = 0;\n    }\n    else\n    {\n        /* auto-join when connecting to server for first time */\n        autojoin = irc_server_eval_expression (\n            server,\n            IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN));\n        if (!server->disable_autojoin && autojoin && autojoin[0])\n            irc_command_join_server (server, autojoin, 0, 0);\n        if (autojoin)\n            free (autojoin);\n    }\n\n    server->disable_autojoin = 0;\n}\n\n/*\n * Returns number of channels for server.\n */\n\nint\nirc_server_get_channel_count (struct t_irc_server *server)\n{\n    int count;\n    struct t_irc_channel *ptr_channel;\n\n    count = 0;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n        count++;\n    }\n    return count;\n}\n\n/*\n * Returns number of pv for server.\n */\n\nint\nirc_server_get_pv_count (struct t_irc_server *server)\n{\n    int count;\n    struct t_irc_channel *ptr_channel;\n\n    count = 0;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        if (ptr_channel->type == IRC_CHANNEL_TYPE_PRIVATE)\n            count++;\n    }\n    return count;\n}\n\n/*\n * Removes away for all channels/nicks (for all servers).\n */\n\nvoid\nirc_server_remove_away (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_remove_away (server, ptr_channel);\n        }\n        server->last_away_check = 0;\n    }\n}\n\n/*\n * Checks for away on all channels of a server.\n */\n\nvoid\nirc_server_check_away (struct t_irc_server *server)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_check_whox (server, ptr_channel);\n        }\n        server->last_away_check = time (NULL);\n    }\n}\n\n/*\n * Sets/unsets away status for a server (all channels).\n */\n\nvoid\nirc_server_set_away (struct t_irc_server *server, const char *nick, int is_away)\n{\n    struct t_irc_channel *ptr_channel;\n\n    if (server->is_connected)\n    {\n        /* set/del \"away\" local variable on server buffer */\n        if (is_away)\n        {\n            weechat_buffer_set (server->buffer,\n                                \"localvar_set_away\", server->away_message);\n        }\n        else\n        {\n            weechat_buffer_set (server->buffer,\n                                \"localvar_del_away\", \"\");\n        }\n\n        for (ptr_channel = server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            /* set away flag for nick on channel */\n            if (ptr_channel->type == IRC_CHANNEL_TYPE_CHANNEL)\n                irc_channel_set_away (server, ptr_channel, nick, is_away);\n\n            /* set/del \"away\" local variable on channel buffer */\n            if (is_away)\n            {\n                weechat_buffer_set (ptr_channel->buffer,\n                                    \"localvar_set_away\", server->away_message);\n            }\n            else\n            {\n                weechat_buffer_set (ptr_channel->buffer,\n                                    \"localvar_del_away\", \"\");\n            }\n        }\n    }\n}\n\n/*\n * Callback called when user sends (file or chat) to someone and that xfer\n * plugin successfully initialized xfer and is ready for sending.\n *\n * In that case, irc plugin sends message to remote nick and wait for \"accept\"\n * reply.\n */\n\nint\nirc_server_xfer_send_ready_cb (const void *pointer, void *data,\n                               const char *signal,\n                               const char *type_data, void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *type, *filename, *local_address;\n    char converted_addr[NI_MAXHOST];\n    struct addrinfo *ainfo;\n    struct sockaddr_in *saddr;\n    int spaces_in_name, rc;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0)\n            && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                converted_addr[0] = '\\0';\n                local_address = weechat_infolist_string (infolist,\n                                                         \"local_address\");\n                if (local_address)\n                {\n                    res_init ();\n                    rc = getaddrinfo (local_address, NULL, NULL, &ainfo);\n                    if ((rc == 0) && ainfo && ainfo->ai_addr)\n                    {\n                        if (ainfo->ai_family == AF_INET)\n                        {\n                            /* transform dotted 4 IP address to ulong string */\n                            saddr = (struct sockaddr_in *)ainfo->ai_addr;\n                            snprintf (converted_addr, sizeof (converted_addr),\n                                      \"%lu\",\n                                      (unsigned long)ntohl (saddr->sin_addr.s_addr));\n                        }\n                        else\n                        {\n                            snprintf (converted_addr, sizeof (converted_addr),\n                                      \"%s\", local_address);\n                        }\n                    }\n                }\n\n                type = weechat_infolist_string (infolist, \"type_string\");\n                if (type && converted_addr[0])\n                {\n                    /* send DCC PRIVMSG */\n                    if (strcmp (type, \"file_send\") == 0)\n                    {\n                        filename = weechat_infolist_string (infolist, \"filename\");\n                        spaces_in_name = (strchr (filename, ' ') != NULL);\n                        irc_server_sendf (\n                            ptr_server,\n                            IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                            \"PRIVMSG %s :\\01DCC SEND %s%s%s \"\n                            \"%s %d %s\\01\",\n                            weechat_infolist_string (infolist, \"remote_nick\"),\n                            (spaces_in_name) ? \"\\\"\" : \"\",\n                            filename,\n                            (spaces_in_name) ? \"\\\"\" : \"\",\n                            converted_addr,\n                            weechat_infolist_integer (infolist, \"port\"),\n                            weechat_infolist_string (infolist, \"size\"));\n                    }\n                    else if (strcmp (type, \"chat_send\") == 0)\n                    {\n                        irc_server_sendf (\n                            ptr_server,\n                            IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                            \"PRIVMSG %s :\\01DCC CHAT chat %s %d\\01\",\n                            weechat_infolist_string (infolist, \"remote_nick\"),\n                            converted_addr,\n                            weechat_infolist_integer (infolist, \"port\"));\n                    }\n                }\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called when user receives a file and that resume is possible (file\n * is partially received).\n *\n * In that case, irc plugin sends message to remote nick with resume position.\n */\n\nint\nirc_server_xfer_resume_ready_cb (const void *pointer, void *data,\n                                 const char *signal,\n                                 const char *type_data, void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *filename;\n    int spaces_in_name;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0) && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                filename = weechat_infolist_string (infolist, \"filename\");\n                spaces_in_name = (strchr (filename, ' ') != NULL);\n                irc_server_sendf (\n                    ptr_server,\n                    IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                    \"PRIVMSG %s :\\01DCC RESUME %s%s%s %d %s\\01\",\n                    weechat_infolist_string (infolist, \"remote_nick\"),\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    filename,\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    weechat_infolist_integer (infolist, \"port\"),\n                    weechat_infolist_string (infolist, \"start_resume\"));\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Callback called when xfer plugin accepted resume request from receiver.\n *\n * In that case, irc plugin sends accept message to remote nick with resume\n * position.\n */\n\nint\nirc_server_xfer_send_accept_resume_cb (const void *pointer, void *data,\n                                       const char *signal,\n                                       const char *type_data,\n                                       void *signal_data)\n{\n    struct t_infolist *infolist;\n    struct t_irc_server *ptr_server;\n    const char *plugin_name, *plugin_id, *filename;\n    int spaces_in_name;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    infolist = (struct t_infolist *)signal_data;\n\n    if (weechat_infolist_next (infolist))\n    {\n        plugin_name = weechat_infolist_string (infolist, \"plugin_name\");\n        plugin_id = weechat_infolist_string (infolist, \"plugin_id\");\n        if (plugin_name && (strcmp (plugin_name, IRC_PLUGIN_NAME) == 0) && plugin_id)\n        {\n            ptr_server = irc_server_search (plugin_id);\n            if (ptr_server)\n            {\n                filename = weechat_infolist_string (infolist, \"filename\");\n                spaces_in_name = (strchr (filename, ' ') != NULL);\n                irc_server_sendf (\n                    ptr_server,\n                    IRC_SERVER_SEND_OUTQ_PRIO_HIGH, NULL,\n                    \"PRIVMSG %s :\\01DCC ACCEPT %s%s%s %d %s\\01\",\n                    weechat_infolist_string (infolist, \"remote_nick\"),\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    filename,\n                    (spaces_in_name) ? \"\\\"\" : \"\",\n                    weechat_infolist_integer (infolist, \"port\"),\n                    weechat_infolist_string (infolist, \"start_resume\"));\n            }\n        }\n    }\n\n    weechat_infolist_reset_item_cursor (infolist);\n\n    return WEECHAT_RC_OK;\n}\n\n/*\n * Returns hdata for server.\n */\n\nstruct t_hdata *\nirc_server_hdata_server_cb (const void *pointer, void *data,\n                            const char *hdata_name)\n{\n    struct t_hdata *hdata;\n\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n\n    hdata = weechat_hdata_new (hdata_name, \"prev_server\", \"next_server\",\n                               0, 0, NULL, NULL);\n    if (hdata)\n    {\n        WEECHAT_HDATA_VAR(struct t_irc_server, name, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, options, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, temp_server, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reloading_from_config, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reloaded_from_config, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_eval, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, addresses_array, STRING, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, ports_array, INTEGER, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, retry_array, INTEGER, 0, \"addresses_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, index_current_address, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_address, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_ip, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_port, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, current_retry, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, sock, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_connect, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_fd, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_timer_connection, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, hook_timer_sasl, POINTER, 0, NULL, \"hook\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, is_connected, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, ssl_connected, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, disconnected, INTEGER, 0, NULL, NULL);\n#ifdef HAVE_GNUTLS\n        WEECHAT_HDATA_VAR(struct t_irc_server, gnutls_sess, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, tls_cert, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, tls_cert_key, OTHER, 0, NULL, NULL);\n#endif /* HAVE_GNUTLS */\n        WEECHAT_HDATA_VAR(struct t_irc_server, unterminated_message, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nicks_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nicks_array, STRING, 0, \"nicks_count\", NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_first_tried, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_alternate_number, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_modes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, host, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, checking_cap_ls, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cap_ls, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, checking_cap_list, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cap_list, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, isupport, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, prefix_modes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, prefix_chars, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, nick_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, user_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, host_max_length, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, casemapping, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, chantypes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, chanmodes, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, monitor, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, monitor_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_delay, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_start, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, command_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, reconnect_join, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, disable_autojoin, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, is_away, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, away_message, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, away_time, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_displayed, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_check_time, OTHER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_next_check, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, lag_last_refresh, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, cmd_list_regexp, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_user_message, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_away_check, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_data_purge, TIME, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, outqueue, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_outqueue, POINTER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, redirects, POINTER, 0, NULL, \"irc_redirect\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_redirect, POINTER, 0, NULL, \"irc_redirect\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, notify_list, POINTER, 0, NULL, \"irc_notify\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_notify, POINTER, 0, NULL, \"irc_notify\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, notify_count, INTEGER, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_manual, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_channel_key, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, join_noswitch, HASHTABLE, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, buffer, POINTER, 0, NULL, \"buffer\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, buffer_as_string, STRING, 0, NULL, NULL);\n        WEECHAT_HDATA_VAR(struct t_irc_server, channels, POINTER, 0, NULL, \"irc_channel\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, last_channel, POINTER, 0, NULL, \"irc_channel\");\n        WEECHAT_HDATA_VAR(struct t_irc_server, prev_server, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_VAR(struct t_irc_server, next_server, POINTER, 0, NULL, hdata_name);\n        WEECHAT_HDATA_LIST(irc_servers, WEECHAT_HDATA_LIST_CHECK_POINTERS);\n        WEECHAT_HDATA_LIST(last_irc_server, 0);\n    }\n    return hdata;\n}\n\n/*\n * Adds a server in an infolist.\n *\n * Returns:\n *   1: OK\n *   0: error\n */\n\nint\nirc_server_add_to_infolist (struct t_infolist *infolist,\n                            struct t_irc_server *server)\n{\n    struct t_infolist_item *ptr_item;\n\n    if (!infolist || !server)\n        return 0;\n\n    ptr_item = weechat_infolist_new_item (infolist);\n    if (!ptr_item)\n        return 0;\n\n    if (!weechat_infolist_new_var_string (ptr_item, \"name\", server->name))\n        return 0;\n    if (!weechat_infolist_new_var_pointer (ptr_item, \"buffer\", server->buffer))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"buffer_name\",\n                                          (server->buffer) ?\n                                          weechat_buffer_get_string (server->buffer, \"name\") : \"\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"buffer_short_name\",\n                                          (server->buffer) ?\n                                          weechat_buffer_get_string (server->buffer, \"short_name\") : \"\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"addresses\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_ADDRESSES)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"proxy\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ipv6\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_IPV6)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_cert\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_CERT)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_priorities\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_PRIORITIES)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_dhkey_size\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"ssl_fingerprint\",\n                                           IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SSL_FINGERPRINT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_verify\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"capabilities\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_CAPABILITIES)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sasl_mechanism\",\n                                          IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SASL_MECHANISM)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_username\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_password\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"sasl_key\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sasl_fail\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_SASL_FAIL)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoconnect\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTOCONNECT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoreconnect\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autoreconnect_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nicks\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_NICKS)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"nicks_alternate\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_NICKS_ALTERNATE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"username\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"realname\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"local_hostname\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_LOCAL_HOSTNAME)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"usermode\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERMODE)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"command\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_COMMAND)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"command_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_COMMAND_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"autojoin\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_AUTOJOIN)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autorejoin\",\n                                           IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTOREJOIN)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"autorejoin_delay\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTOREJOIN_DELAY)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"connection_timeout\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"anti_flood_prio_high\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"anti_flood_prio_low\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away_check\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AWAY_CHECK)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"away_check_max_nicks\",\n                                           IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_kick\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_KICK)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_part\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_PART)))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"msg_quit\",\n                                          IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_MSG_QUIT)))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"temp_server\", server->temp_server))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"index_current_address\", server->index_current_address))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"current_address\", server->current_address))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"current_ip\", server->current_ip))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"current_port\", server->current_port))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"current_retry\", server->current_retry))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"sock\", server->sock))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"is_connected\", server->is_connected))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"ssl_connected\", server->ssl_connected))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"disconnected\", server->disconnected))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"unterminated_message\", server->unterminated_message))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nick\", server->nick))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"nick_modes\", server->nick_modes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"host\", server->host))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"checking_cap_ls\", server->checking_cap_ls))\n        return 0;\n    if (!weechat_hashtable_add_to_infolist (server->cap_ls, ptr_item, \"cap_ls\"))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"checking_cap_list\", server->checking_cap_list))\n        return 0;\n    if (!weechat_hashtable_add_to_infolist (server->cap_list, ptr_item, \"cap_list\"))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"isupport\", server->isupport))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix_modes\", server->prefix_modes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"prefix_chars\", server->prefix_chars))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"nick_max_length\", server->nick_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"user_max_length\", server->user_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"host_max_length\", server->host_max_length))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"casemapping\", server->casemapping))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"casemapping_string\", irc_server_casemapping_string[server->casemapping]))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"chantypes\", server->chantypes))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"chanmodes\", server->chanmodes))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"monitor\", server->monitor))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"monitor_time\", server->monitor_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"reconnect_delay\", server->reconnect_delay))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"reconnect_start\", server->reconnect_start))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"command_time\", server->command_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"reconnect_join\", server->reconnect_join))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"disable_autojoin\", server->disable_autojoin))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"is_away\", server->is_away))\n        return 0;\n    if (!weechat_infolist_new_var_string (ptr_item, \"away_message\", server->away_message))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"away_time\", server->away_time))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"lag\", server->lag))\n        return 0;\n    if (!weechat_infolist_new_var_integer (ptr_item, \"lag_displayed\", server->lag_displayed))\n        return 0;\n    if (!weechat_infolist_new_var_buffer (ptr_item, \"lag_check_time\", &(server->lag_check_time), sizeof (struct timeval)))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"lag_next_check\", server->lag_next_check))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"lag_last_refresh\", server->lag_last_refresh))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_user_message\", server->last_user_message))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_away_check\", server->last_away_check))\n        return 0;\n    if (!weechat_infolist_new_var_time (ptr_item, \"last_data_purge\", server->last_data_purge))\n        return 0;\n\n    return 1;\n}\n\n/*\n * Prints server infos in WeeChat log file (usually for crash dump).\n */\n\nvoid\nirc_server_print_log ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    int i;\n\n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        weechat_log_printf (\"\");\n        weechat_log_printf (\"[server %s (addr:0x%lx)]\", ptr_server->name, ptr_server);\n        /* addresses */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]))\n            weechat_log_printf (\"  addresses. . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_ADDRESSES));\n        else\n            weechat_log_printf (\"  addresses. . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]));\n        /* proxy */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PROXY]))\n            weechat_log_printf (\"  proxy. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_PROXY));\n        else\n            weechat_log_printf (\"  proxy. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_PROXY]));\n        /* ipv6 */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_IPV6]))\n            weechat_log_printf (\"  ipv6 . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_IPV6)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ipv6 . . . . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_IPV6])) ?\n                                \"on\" : \"off\");\n        /* ssl */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL]))\n            weechat_log_printf (\"  ssl. . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl. . . . . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL])) ?\n                                \"on\" : \"off\");\n        /* ssl_cert */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]))\n            weechat_log_printf (\"  ssl_cert . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_CERT));\n        else\n            weechat_log_printf (\"  ssl_cert . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]));\n        /* ssl_password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_PASSWORD]))\n            weechat_log_printf (\"  ssl_password . . . . : null\");\n        else\n            weechat_log_printf (\"  ssl_password . . . . : (hidden)\");\n        /* ssl_priorities */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_PRIORITIES]))\n            weechat_log_printf (\"  ssl_priorities . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_PRIORITIES));\n        else\n            weechat_log_printf (\"  ssl_priorities . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_PRIORITIES]));\n        /* ssl_dhkey_size */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]))\n            weechat_log_printf (\"  ssl_dhkey_size . . . : null ('%d')\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n        else\n            weechat_log_printf (\"  ssl_dhkey_size . . . : '%d'\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]));\n        /* ssl_fingerprint */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_FINGERPRINT]))\n            weechat_log_printf (\"  ssl_fingerprint. . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_FINGERPRINT));\n        else\n            weechat_log_printf (\"  ssl_fingerprint. . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_FINGERPRINT]));\n        /* ssl_verify */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY]))\n            weechat_log_printf (\"  ssl_verify . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL_VERIFY)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl_verify . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY])) ?\n                                \"on\" : \"off\");\n        /* password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PASSWORD]))\n            weechat_log_printf (\"  password . . . . . . : null\");\n        else\n            weechat_log_printf (\"  password . . . . . . : (hidden)\");\n        /* client capabilities */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_CAPABILITIES]))\n            weechat_log_printf (\"  capabilities . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_CAPABILITIES));\n        else\n            weechat_log_printf (\"  capabilities . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_CAPABILITIES]));\n        /* sasl_mechanism */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM]))\n            weechat_log_printf (\"  sasl_mechanism . . . : null ('%s')\",\n                                irc_sasl_mechanism_string[IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SASL_MECHANISM)]);\n        else\n            weechat_log_printf (\"  sasl_mechanism . . . : '%s'\",\n                                irc_sasl_mechanism_string[weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM])]);\n        /* sasl_username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_USERNAME]))\n            weechat_log_printf (\"  sasl_username. . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SASL_USERNAME));\n        else\n            weechat_log_printf (\"  sasl_username. . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SASL_USERNAME]));\n        /* sasl_password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_PASSWORD]))\n            weechat_log_printf (\"  sasl_password. . . . : null\");\n        else\n            weechat_log_printf (\"  sasl_password. . . . : (hidden)\");\n        /* sasl_key */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_KEY]))\n            weechat_log_printf (\"  sasl_key. .  . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SASL_KEY));\n        else\n            weechat_log_printf (\"  sasl_key. .  . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SASL_KEY]));\n        /* sasl_fail */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_FAIL]))\n            weechat_log_printf (\"  sasl_fail. . . . . . : null ('%s')\",\n                                irc_server_sasl_fail_string[IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SASL_FAIL)]);\n        else\n            weechat_log_printf (\"  sasl_fail. . . . . . : '%s'\",\n                                irc_server_sasl_fail_string[weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SASL_FAIL])]);\n        /* autoconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT]))\n            weechat_log_printf (\"  autoconnect. . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOCONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoconnect. . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT])) ?\n                                \"on\" : \"off\");\n        /* autoreconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT]))\n            weechat_log_printf (\"  autoreconnect. . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoreconnect. . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT])) ?\n                                \"on\" : \"off\");\n        /* autoreconnect_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]))\n            weechat_log_printf (\"  autoreconnect_delay. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY));\n        else\n            weechat_log_printf (\"  autoreconnect_delay. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]));\n        /* nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_NICKS]))\n            weechat_log_printf (\"  nicks. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_NICKS));\n        else\n            weechat_log_printf (\"  nicks. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_NICKS]));\n        /* nicks_alternate */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_NICKS_ALTERNATE]))\n            weechat_log_printf (\"  nicks_alternate. . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_NICKS_ALTERNATE)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  nicks_alternate. . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_NICKS_ALTERNATE])) ?\n                                \"on\" : \"off\");\n        /* username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_USERNAME]))\n            weechat_log_printf (\"  username . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_USERNAME));\n        else\n            weechat_log_printf (\"  username . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERNAME]));\n        /* realname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_REALNAME]))\n            weechat_log_printf (\"  realname . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_REALNAME));\n        else\n            weechat_log_printf (\"  realname . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_REALNAME]));\n        /* local_hostname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]))\n            weechat_log_printf (\"  local_hostname . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_LOCAL_HOSTNAME));\n        else\n            weechat_log_printf (\"  local_hostname . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]));\n        /* usermode */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_USERMODE]))\n            weechat_log_printf (\"  usermode . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_USERMODE));\n        else\n            weechat_log_printf (\"  usermode . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERMODE]));\n        /* command */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND]))\n            weechat_log_printf (\"  command. . . . . . . : null\");\n        else\n            weechat_log_printf (\"  command. . . . . . . : (hidden)\");\n        /* command_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]))\n            weechat_log_printf (\"  command_delay. . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_COMMAND_DELAY));\n        else\n            weechat_log_printf (\"  command_delay. . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]));\n        /* autojoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]))\n            weechat_log_printf (\"  autojoin . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_AUTOJOIN));\n        else\n            weechat_log_printf (\"  autojoin . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]));\n        /* autorejoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN]))\n            weechat_log_printf (\"  autorejoin . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autorejoin . . . . . : %s\",\n                                (weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN])) ?\n                                \"on\" : \"off\");\n        /* autorejoin_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]))\n            weechat_log_printf (\"  autorejoin_delay . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN_DELAY));\n        else\n            weechat_log_printf (\"  autorejoin_delay . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]));\n        /* connection_timeout */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]))\n            weechat_log_printf (\"  connection_timeout . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT));\n        else\n            weechat_log_printf (\"  connection_timeout . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]));\n        /* anti_flood_prio_high */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]))\n            weechat_log_printf (\"  anti_flood_prio_high : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH));\n        else\n            weechat_log_printf (\"  anti_flood_prio_high : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]));\n        /* anti_flood_prio_low */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]))\n            weechat_log_printf (\"  anti_flood_prio_low. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW));\n        else\n            weechat_log_printf (\"  anti_flood_prio_low. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]));\n        /* away_check */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]))\n            weechat_log_printf (\"  away_check . . . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK));\n        else\n            weechat_log_printf (\"  away_check . . . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]));\n        /* away_check_max_nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]))\n            weechat_log_printf (\"  away_check_max_nicks : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS));\n        else\n            weechat_log_printf (\"  away_check_max_nicks : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]));\n        /* msg_kick */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_KICK]))\n            weechat_log_printf (\"  msg_kick . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_KICK));\n        else\n            weechat_log_printf (\"  msg_kick . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_KICK]));\n        /* msg_part */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_PART]))\n            weechat_log_printf (\"  msg_part . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_PART));\n        else\n            weechat_log_printf (\"  msg_part . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_PART]));\n        /* msg_quit */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_MSG_QUIT]))\n            weechat_log_printf (\"  msg_quit . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_MSG_QUIT));\n        else\n            weechat_log_printf (\"  msg_quit . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_MSG_QUIT]));\n        /* other server variables */\n        weechat_log_printf (\"  temp_server. . . . . : %d\",    ptr_server->temp_server);\n        weechat_log_printf (\"  reloading_from_config: %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  reloaded_from_config : %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  addresses_eval . . . : '%s'\",  ptr_server->addresses_eval);\n        weechat_log_printf (\"  addresses_count. . . : %d\",    ptr_server->addresses_count);\n        weechat_log_printf (\"  addresses_array. . . : 0x%lx\", ptr_server->addresses_array);\n        weechat_log_printf (\"  ports_array. . . . . : 0x%lx\", ptr_server->ports_array);\n        weechat_log_printf (\"  retry_array. . . . . : 0x%lx\", ptr_server->retry_array);\n        weechat_log_printf (\"  index_current_address: %d\",    ptr_server->index_current_address);\n        weechat_log_printf (\"  current_address. . . : '%s'\",  ptr_server->current_address);\n        weechat_log_printf (\"  current_ip . . . . . : '%s'\",  ptr_server->current_ip);\n        weechat_log_printf (\"  current_port . . . . : %d\",    ptr_server->current_port);\n        weechat_log_printf (\"  current_retry. . . . : %d\",    ptr_server->current_retry);\n        weechat_log_printf (\"  sock . . . . . . . . : %d\",    ptr_server->sock);\n        weechat_log_printf (\"  hook_connect . . . . : 0x%lx\", ptr_server->hook_connect);\n        weechat_log_printf (\"  hook_fd. . . . . . . : 0x%lx\", ptr_server->hook_fd);\n        weechat_log_printf (\"  hook_timer_connection: 0x%lx\", ptr_server->hook_timer_connection);\n        weechat_log_printf (\"  hook_timer_sasl. . . : 0x%lx\", ptr_server->hook_timer_sasl);\n        weechat_log_printf (\"  is_connected . . . . : %d\",    ptr_server->is_connected);\n        weechat_log_printf (\"  ssl_connected. . . . : %d\",    ptr_server->ssl_connected);\n        weechat_log_printf (\"  disconnected . . . . : %d\",    ptr_server->disconnected);\n#ifdef HAVE_GNUTLS\n        weechat_log_printf (\"  gnutls_sess. . . . . : 0x%lx\", ptr_server->gnutls_sess);\n#endif /* HAVE_GNUTLS */\n        weechat_log_printf (\"  unterminated_message : '%s'\",  ptr_server->unterminated_message);\n        weechat_log_printf (\"  nicks_count. . . . . : %d\",    ptr_server->nicks_count);\n        weechat_log_printf (\"  nicks_array. . . . . : 0x%lx\", ptr_server->nicks_array);\n        weechat_log_printf (\"  nick_first_tried . . : %d\",    ptr_server->nick_first_tried);\n        weechat_log_printf (\"  nick_alternate_number: %d\",    ptr_server->nick_alternate_number);\n        weechat_log_printf (\"  nick . . . . . . . . : '%s'\",  ptr_server->nick);\n        weechat_log_printf (\"  nick_modes . . . . . : '%s'\",  ptr_server->nick_modes);\n        weechat_log_printf (\"  host . . . . . . . . : '%s'\",  ptr_server->host);\n        weechat_log_printf (\"  checking_cap_ls. . . : %d\",    ptr_server->checking_cap_ls);\n        weechat_log_printf (\"  cap_ls . . . . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->cap_ls,\n                            weechat_hashtable_get_string (ptr_server->cap_ls, \"keys_values\"));\n        weechat_log_printf (\"  checking_cap_list. . : %d\",    ptr_server->checking_cap_list);\n        weechat_log_printf (\"  cap_list . . . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->cap_list,\n                            weechat_hashtable_get_string (ptr_server->cap_list, \"keys_values\"));\n        weechat_log_printf (\"  isupport . . . . . . : '%s'\",  ptr_server->isupport);\n        weechat_log_printf (\"  prefix_modes . . . . : '%s'\",  ptr_server->prefix_modes);\n        weechat_log_printf (\"  prefix_chars . . . . : '%s'\",  ptr_server->prefix_chars);\n        weechat_log_printf (\"  nick_max_length. . . : %d\",    ptr_server->nick_max_length);\n        weechat_log_printf (\"  user_max_length. . . : %d\",    ptr_server->user_max_length);\n        weechat_log_printf (\"  host_max_length. . . : %d\",    ptr_server->host_max_length);\n        weechat_log_printf (\"  casemapping. . . . . : %d (%s)\",\n                            ptr_server->casemapping,\n                            irc_server_casemapping_string[ptr_server->casemapping]);\n        weechat_log_printf (\"  chantypes. . . . . . : '%s'\",  ptr_server->chantypes);\n        weechat_log_printf (\"  chanmodes. . . . . . : '%s'\",  ptr_server->chanmodes);\n        weechat_log_printf (\"  monitor. . . . . . . : %d\",    ptr_server->monitor);\n        weechat_log_printf (\"  monitor_time . . . . : %lld\",  (long long)ptr_server->monitor_time);\n        weechat_log_printf (\"  reconnect_delay. . . : %d\",    ptr_server->reconnect_delay);\n        weechat_log_printf (\"  reconnect_start. . . : %lld\",  (long long)ptr_server->reconnect_start);\n        weechat_log_printf (\"  command_time . . . . : %lld\",  (long long)ptr_server->command_time);\n        weechat_log_printf (\"  reconnect_join . . . : %d\",    ptr_server->reconnect_join);\n        weechat_log_printf (\"  disable_autojoin . . : %d\",    ptr_server->disable_autojoin);\n        weechat_log_printf (\"  is_away. . . . . . . : %d\",    ptr_server->is_away);\n        weechat_log_printf (\"  away_message . . . . : '%s'\",  ptr_server->away_message);\n        weechat_log_printf (\"  away_time. . . . . . : %lld\",  (long long)ptr_server->away_time);\n        weechat_log_printf (\"  lag. . . . . . . . . : %d\",    ptr_server->lag);\n        weechat_log_printf (\"  lag_displayed. . . . : %d\",    ptr_server->lag_displayed);\n        weechat_log_printf (\"  lag_check_time . . . : tv_sec:%d, tv_usec:%d\",\n                            ptr_server->lag_check_time.tv_sec,\n                            ptr_server->lag_check_time.tv_usec);\n        weechat_log_printf (\"  lag_next_check . . . : %lld\",  (long long)ptr_server->lag_next_check);\n        weechat_log_printf (\"  lag_last_refresh . . : %lld\",  (long long)ptr_server->lag_last_refresh);\n        weechat_log_printf (\"  cmd_list_regexp. . . : 0x%lx\", ptr_server->cmd_list_regexp);\n        weechat_log_printf (\"  last_user_message. . : %lld\",  (long long)ptr_server->last_user_message);\n        weechat_log_printf (\"  last_away_check. . . : %lld\",  (long long)ptr_server->last_away_check);\n        weechat_log_printf (\"  last_data_purge. . . : %lld\",  (long long)ptr_server->last_data_purge);\n        for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n        {\n            weechat_log_printf (\"  outqueue[%02d] . . . . : 0x%lx\", i, ptr_server->outqueue[i]);\n            weechat_log_printf (\"  last_outqueue[%02d]. . : 0x%lx\", i, ptr_server->last_outqueue[i]);\n        }\n        weechat_log_printf (\"  redirects. . . . . . : 0x%lx\", ptr_server->redirects);\n        weechat_log_printf (\"  last_redirect. . . . : 0x%lx\", ptr_server->last_redirect);\n        weechat_log_printf (\"  notify_list. . . . . : 0x%lx\", ptr_server->notify_list);\n        weechat_log_printf (\"  last_notify. . . . . : 0x%lx\", ptr_server->last_notify);\n        weechat_log_printf (\"  notify_count . . . . : %d\",    ptr_server->notify_count);\n        weechat_log_printf (\"  join_manual. . . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_manual,\n                            weechat_hashtable_get_string (ptr_server->join_manual, \"keys_values\"));\n        weechat_log_printf (\"  join_channel_key . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_channel_key,\n                            weechat_hashtable_get_string (ptr_server->join_channel_key, \"keys_values\"));\n        weechat_log_printf (\"  join_noswitch. . . . : 0x%lx (hashtable: '%s')\",\n                            ptr_server->join_noswitch,\n                            weechat_hashtable_get_string (ptr_server->join_noswitch, \"keys_values\"));\n        weechat_log_printf (\"  buffer . . . . . . . : 0x%lx\", ptr_server->buffer);\n        weechat_log_printf (\"  buffer_as_string . . : 0x%lx\", ptr_server->buffer_as_string);\n        weechat_log_printf (\"  channels . . . . . . : 0x%lx\", ptr_server->channels);\n        weechat_log_printf (\"  last_channel . . . . : 0x%lx\", ptr_server->last_channel);\n        weechat_log_printf (\"  prev_server. . . . . : 0x%lx\", ptr_server->prev_server);\n        weechat_log_printf (\"  next_server. . . . . : 0x%lx\", ptr_server->next_server);\n\n        irc_redirect_print_log (ptr_server);\n\n        irc_notify_print_log (ptr_server);\n\n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            irc_channel_print_log (ptr_channel);\n        }\n    }\n}\n"], "filenames": ["ChangeLog.adoc", "src/plugins/irc/irc-nick.c", "src/plugins/irc/irc-nick.h", "src/plugins/irc/irc-server.c"], "buggy_code_start_loc": [33, 642, 76, 991], "buggy_code_end_loc": [33, 642, 76, 1034], "fixing_code_start_loc": [34, 643, 77, 991], "fixing_code_end_loc": [35, 690, 79, 1042], "type": "CWE-120", "message": "An issue was discovered in WeeChat before 2.7.1 (0.3.4 to 2.7 are affected). When a new IRC message 005 is received with longer nick prefixes, a buffer overflow and possibly a crash can happen when a new mode is set for a nick.", "other": {"cve": {"id": "CVE-2020-9760", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-23T16:15:17.923", "lastModified": "2022-04-01T15:39:04.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in WeeChat before 2.7.1 (0.3.4 to 2.7 are affected). When a new IRC message 005 is received with longer nick prefixes, a buffer overflow and possibly a crash can happen when a new mode is set for a nick."}, {"lang": "es", "value": "Se detect\u00f3 un problema en WeeChat versiones anteriores a  2.7.1 (versiones 0.3.4 hasta 2.7 est\u00e1n afectadas). Cuando se recibe un nuevo mensaje 005 IRC con prefijos nick m\u00e1s largos, un desbordamiento del b\u00fafer y posiblemente un bloqueo puede presentarse cuando se ajusta un nuevo modo para un nick."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weechat:weechat:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.3.4", "versionEndExcluding": "2.7.1", "matchCriteriaId": "AE097718-399A-4240-ACE3-ED08FDBE747E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/weechat/weechat/commit/40ccacb4330a64802b1f1e28ed9a6b6d3ca9197f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/09/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-51", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://weechat.org/doc/security/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/weechat/weechat/commit/40ccacb4330a64802b1f1e28ed9a6b6d3ca9197f"}}