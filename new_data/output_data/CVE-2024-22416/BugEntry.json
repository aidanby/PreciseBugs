{"buggy_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport os\n\nimport flask\nimport jinja2\nfrom werkzeug.serving import WSGIRequestHandler\n\nfrom .blueprints import BLUEPRINTS\nfrom .config import get_default_config\nfrom .extensions import EXTENSIONS, THEMES\nfrom .filters import TEMPLATE_FILTERS\nfrom .globals import TEMPLATE_GLOBALS\nfrom .handlers import ERROR_HANDLERS\nfrom .processors import CONTEXT_PROCESSORS\n\n\n#: flask app singleton?\nclass App:\n\n    JINJA_TEMPLATE_GLOBALS = TEMPLATE_GLOBALS\n    JINJA_TEMPLATE_FILTERS = TEMPLATE_FILTERS\n    JINJA_CONTEXT_PROCESSORS = CONTEXT_PROCESSORS\n    FLASK_ERROR_HANDLERS = ERROR_HANDLERS\n    FLASK_BLUEPRINTS = BLUEPRINTS\n    FLASK_EXTENSIONS = EXTENSIONS\n    FLASK_THEMES = THEMES\n\n\n    @classmethod\n    def _configure_config(cls, app, develop):\n        conf_obj = get_default_config(develop)\n        app.config.from_object(conf_obj)\n\n    @classmethod\n    def _configure_blueprints(cls, app, path_prefix):\n        for blueprint in cls.FLASK_BLUEPRINTS:\n            url_prefix = path_prefix if not blueprint.url_prefix else None\n            app.register_blueprint(blueprint, url_prefix=url_prefix)\n\n    @classmethod\n    def _configure_extensions(cls, app):\n        for extension in cls.FLASK_EXTENSIONS:\n            extension.init_app(app)\n\n    @classmethod\n    def _configure_themes(cls, app, path_prefix=\"\"):\n        for theme in cls.FLASK_THEMES:\n            theme.init_app(app, path_prefix)\n\n    @classmethod\n    def _configure_handlers(cls, app):\n        \"\"\"\n        Register app handlers.\n        \"\"\"\n        for exc, fn in cls.FLASK_ERROR_HANDLERS:\n            app.register_error_handler(exc, fn)\n\n        @app.after_request\n        def deny_iframe(response):\n            response.headers[\"X-Frame-Options\"] = \"DENY\"\n            return response\n\n    @classmethod\n    def _configure_json_encoding(cls, app):\n        try:\n            from .helpers import JSONProvider\n            app.json = JSONProvider(app)\n\n        except ImportError:\n            from .helpers import JSONEncoder\n            app.json_encoder = JSONEncoder\n\n    @classmethod\n    def _configure_templating(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"jinja\")\n\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.create_jinja_environment()\n\n        # NOTE: enable auto escape for all file extensions (including .js)\n        #       maybe this will break .txt rendering, but we don't render this kind of files actually\n        #       that does not change 'default_for_string=False' (by default)\n        app.jinja_env.autoescape = jinja2.select_autoescape(default=True)\n        app.jinja_env.bytecode_cache = jinja2.FileSystemBytecodeCache(cache_path)\n\n        for fn in cls.JINJA_TEMPLATE_FILTERS:\n            app.add_template_filter(fn)\n\n        for fn in cls.JINJA_TEMPLATE_GLOBALS:\n            app.add_template_global(fn)\n\n        for fn in cls.JINJA_CONTEXT_PROCESSORS:\n            app.context_processor(fn)\n\n    @classmethod\n    def _configure_session(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"flask\")\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.config[\"SESSION_FILE_DIR\"] = cache_path\n        app.config[\"SESSION_TYPE\"] = \"filesystem\"\n        app.config[\"SESSION_COOKIE_NAME\"] = \"pyload_session\"\n        app.config[\"SESSION_COOKIE_SAMESITE\"] = \"None\"\n        app.config[\"SESSION_COOKIE_SECURE\"] = app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"use_ssl\")\n        app.config[\"SESSION_PERMANENT\"] = False\n\n        session_lifetime = max(app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"session_lifetime\"), 1) * 60\n        app.config[\"PERMANENT_SESSION_LIFETIME\"] = session_lifetime\n\n    @classmethod\n    def _configure_api(cls, app, pycore):\n        app.config[\"PYLOAD_API\"] = pycore.api\n\n    @classmethod\n    def _configure_logging(cls, app, pycore):\n        # Inject our custom logger\n        app.logger = pycore.log.getChild(\"webui\")\n\n    def __new__(cls, pycore, develop=False, path_prefix=None):\n        app = flask.Flask(__name__)\n\n        cls._configure_logging(app, pycore)\n        cls._configure_api(app, pycore)\n        cls._configure_config(app, develop)\n        cls._configure_templating(app)\n        cls._configure_json_encoding(app)\n        cls._configure_session(app)\n        cls._configure_blueprints(app, path_prefix)\n        cls._configure_extensions(app)\n        cls._configure_themes(app, path_prefix or \"\")\n        cls._configure_handlers(app)\n\n        WSGIRequestHandler.protocol_version = \"HTTP/1.1\"\n\n        return app\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport os\n\nimport flask\nimport jinja2\nfrom werkzeug.serving import WSGIRequestHandler\n\nfrom .blueprints import BLUEPRINTS\nfrom .config import get_default_config\nfrom .extensions import EXTENSIONS, THEMES\nfrom .filters import TEMPLATE_FILTERS\nfrom .globals import TEMPLATE_GLOBALS\nfrom .handlers import ERROR_HANDLERS\nfrom .processors import CONTEXT_PROCESSORS\n\n\n#: flask app singleton?\nclass App:\n\n    JINJA_TEMPLATE_GLOBALS = TEMPLATE_GLOBALS\n    JINJA_TEMPLATE_FILTERS = TEMPLATE_FILTERS\n    JINJA_CONTEXT_PROCESSORS = CONTEXT_PROCESSORS\n    FLASK_ERROR_HANDLERS = ERROR_HANDLERS\n    FLASK_BLUEPRINTS = BLUEPRINTS\n    FLASK_EXTENSIONS = EXTENSIONS\n    FLASK_THEMES = THEMES\n\n\n    @classmethod\n    def _configure_config(cls, app, develop):\n        conf_obj = get_default_config(develop)\n        app.config.from_object(conf_obj)\n\n    @classmethod\n    def _configure_blueprints(cls, app, path_prefix):\n        for blueprint in cls.FLASK_BLUEPRINTS:\n            url_prefix = path_prefix if not blueprint.url_prefix else None\n            app.register_blueprint(blueprint, url_prefix=url_prefix)\n\n    @classmethod\n    def _configure_extensions(cls, app):\n        for extension in cls.FLASK_EXTENSIONS:\n            extension.init_app(app)\n\n    @classmethod\n    def _configure_themes(cls, app, path_prefix=\"\"):\n        for theme in cls.FLASK_THEMES:\n            theme.init_app(app, path_prefix)\n\n    @classmethod\n    def _configure_handlers(cls, app):\n        \"\"\"\n        Register app handlers.\n        \"\"\"\n        for exc, fn in cls.FLASK_ERROR_HANDLERS:\n            app.register_error_handler(exc, fn)\n\n        @app.after_request\n        def deny_iframe(response):\n            response.headers[\"X-Frame-Options\"] = \"DENY\"\n            return response\n\n    @classmethod\n    def _configure_json_encoding(cls, app):\n        try:\n            from .helpers import JSONProvider\n            app.json = JSONProvider(app)\n\n        except ImportError:\n            from .helpers import JSONEncoder\n            app.json_encoder = JSONEncoder\n\n    @classmethod\n    def _configure_templating(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"jinja\")\n\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.create_jinja_environment()\n\n        # NOTE: enable auto escape for all file extensions (including .js)\n        #       maybe this will break .txt rendering, but we don't render this kind of files actually\n        #       that does not change 'default_for_string=False' (by default)\n        app.jinja_env.autoescape = jinja2.select_autoescape(default=True)\n        app.jinja_env.bytecode_cache = jinja2.FileSystemBytecodeCache(cache_path)\n\n        for fn in cls.JINJA_TEMPLATE_FILTERS:\n            app.add_template_filter(fn)\n\n        for fn in cls.JINJA_TEMPLATE_GLOBALS:\n            app.add_template_global(fn)\n\n        for fn in cls.JINJA_CONTEXT_PROCESSORS:\n            app.context_processor(fn)\n\n    @classmethod\n    def _configure_session(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"flask\")\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.config[\"SESSION_FILE_DIR\"] = cache_path\n        app.config[\"SESSION_TYPE\"] = \"filesystem\"\n        app.config[\"SESSION_COOKIE_NAME\"] = \"pyload_session\"\n        app.config[\"SESSION_COOKIE_SAMESITE\"] = \"Strict\"\n        app.config[\"SESSION_COOKIE_SECURE\"] = app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"use_ssl\")\n        app.config[\"SESSION_PERMANENT\"] = False\n\n        session_lifetime = max(app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"session_lifetime\"), 1) * 60\n        app.config[\"PERMANENT_SESSION_LIFETIME\"] = session_lifetime\n\n    @classmethod\n    def _configure_api(cls, app, pycore):\n        app.config[\"PYLOAD_API\"] = pycore.api\n\n    @classmethod\n    def _configure_logging(cls, app, pycore):\n        # Inject our custom logger\n        app.logger = pycore.log.getChild(\"webui\")\n\n    def __new__(cls, pycore, develop=False, path_prefix=None):\n        app = flask.Flask(__name__)\n\n        cls._configure_logging(app, pycore)\n        cls._configure_api(app, pycore)\n        cls._configure_config(app, develop)\n        cls._configure_templating(app)\n        cls._configure_json_encoding(app)\n        cls._configure_session(app)\n        cls._configure_blueprints(app, path_prefix)\n        cls._configure_extensions(app)\n        cls._configure_themes(app, path_prefix or \"\")\n        cls._configure_handlers(app)\n\n        WSGIRequestHandler.protocol_version = \"HTTP/1.1\"\n\n        return app\n"], "filenames": ["src/pyload/webui/app/__init__.py"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [116], "fixing_code_start_loc": [115], "fixing_code_end_loc": [116], "type": "CWE-352", "message": "pyLoad is a free and open-source Download Manager written in pure Python. The `pyload` API allows any API call to be made using GET requests. Since the session cookie is not set to `SameSite: strict`, this opens the library up to severe attack possibilities via a Cross-Site Request Forgery (CSRF) attack. As a result any API call can be made via a CSRF attack by an unauthenticated user. This issue has been addressed in release `0.5.0b3.dev78`. All users are advised to upgrade.", "other": {"cve": {"id": "CVE-2024-22416", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-18T00:15:38.397", "lastModified": "2024-01-29T17:02:04.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pyLoad is a free and open-source Download Manager written in pure Python. The `pyload` API allows any API call to be made using GET requests. Since the session cookie is not set to `SameSite: strict`, this opens the library up to severe attack possibilities via a Cross-Site Request Forgery (CSRF) attack. As a result any API call can be made via a CSRF attack by an unauthenticated user. This issue has been addressed in release `0.5.0b3.dev78`. All users are advised to upgrade."}, {"lang": "es", "value": "pyLoad es un administrador de descargas gratuito y de c\u00f3digo abierto escrito en Python puro. La API `pyload` permite realizar cualquier llamada a la API mediante solicitudes GET. Dado que la cookie de sesi\u00f3n no est\u00e1 configurada en \"SameSite: strict\", esto abre la librer\u00eda a graves posibilidades de ataque a trav\u00e9s de un ataque de Cross-Site Request Forgery (CSRF). Como resultado, cualquier llamada a la API puede realizarse mediante un ataque CSRF por parte de un usuario no autenticado. Este problema se solucion\u00f3 en la versi\u00f3n `0.5.0b3.dev78`. Se recomienda a todos los usuarios que actualicen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload-ng_project:pyload-ng:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.5.0b3.dev78", "matchCriteriaId": "DD4F56D8-B2D0-4DDE-B8FD-51F372957087"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/1374c824271cb7e927740664d06d2e577624ca3e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pyload/pyload/commit/c7cdc18ad9134a75222974b39e8b427c4af845fc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pyload/pyload/security/advisories/GHSA-pgpj-v85q-h5fm", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/1374c824271cb7e927740664d06d2e577624ca3e"}}