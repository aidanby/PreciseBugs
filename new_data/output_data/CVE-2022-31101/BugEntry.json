{"buggy_code": ["<?php\n/**\n * 2007-2020 PrestaShop and Contributors\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2020 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\nnamespace PrestaShop\\Module\\BlockWishList\\Search;\n\nuse Combination;\nuse Configuration;\nuse Db;\nuse DbQuery;\nuse FrontController;\nuse Group;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchContext;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchProviderInterface;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchQuery;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchResult;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\SortOrder;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\SortOrderFactory;\nuse Product;\nuse Shop;\nuse Symfony\\Component\\Translation\\TranslatorInterface;\nuse WishList;\n\n/**\n * Responsible of getting products for specific wishlist.\n */\nclass WishListProductSearchProvider implements ProductSearchProviderInterface\n{\n    /**\n     * @var Db\n     */\n    private $db;\n\n    /**\n     * @var WishList\n     */\n    private $wishList;\n\n    /**\n     * @var SortOrderFactory\n     */\n    private $sortOrderFactory;\n\n    /**\n     * @var TranslatorInterface the translator\n     */\n    private $translator;\n\n    /**\n     * @param Db $db\n     * @param WishList $wishList\n     */\n    public function __construct(\n        Db $db,\n        WishList $wishList,\n        SortOrderFactory $sortOrderFactory,\n        TranslatorInterface $translator\n    ) {\n        $this->db = $db;\n        $this->wishList = $wishList;\n        $this->sortOrderFactory = $sortOrderFactory;\n        $this->translator = $translator;\n    }\n\n    /**\n     * @param ProductSearchContext $context\n     * @param ProductSearchQuery $query\n     *\n     * @return ProductSearchResult\n     */\n    public function runQuery(\n        ProductSearchContext $context,\n        ProductSearchQuery $query\n    ) {\n        $result = new ProductSearchResult();\n        $result->setProducts($this->getProductsOrCount($context, $query, 'products'));\n        $result->setTotalProductsCount($this->getProductsOrCount($context, $query, 'count'));\n        $sortOrders = $this->sortOrderFactory->getDefaultSortOrders();\n        $sortOrders[] = (new SortOrder('wishlist_product', 'id_wishlist_product', 'DESC'))->setLabel($this->translator->trans('Last added', [], 'Modules.Blockwishlist.Shop'));\n        $result->setAvailableSortOrders($sortOrders);\n\n        return $result;\n    }\n\n    /**\n     * @param ProductSearchContext $context\n     * @param ProductSearchQuery $query\n     * @param string $type\n     *\n     * @return array|int\n     */\n    private function getProductsOrCount(\n        ProductSearchContext $context,\n        ProductSearchQuery $query,\n        $type = 'products'\n    ) {\n        $querySearch = new DbQuery();\n\n        if ('products' === $type) {\n            $querySearch->select('p.*');\n            $querySearch->select('wp.quantity AS wishlist_quantity');\n            $querySearch->select('product_shop.*');\n            $querySearch->select('stock.out_of_stock, IFNULL(stock.quantity, 0) AS quantity');\n            $querySearch->select('pl.`description`, pl.`description_short`, pl.`link_rewrite`, pl.`meta_description`, pl.`meta_keywords`,\n            pl.`meta_title`, pl.`name`, pl.`available_now`, pl.`available_later`');\n            $querySearch->select('image_shop.`id_image` AS id_image');\n            $querySearch->select('il.`legend`');\n            $querySearch->select('\n            DATEDIFF(\n                product_shop.`date_add`,\n                DATE_SUB(\n                    \"' . date('Y-m-d') . ' 00:00:00\",\n                    INTERVAL ' . (0 <= (int) Configuration::get('PS_NB_DAYS_NEW_PRODUCT') ? Configuration::get('PS_NB_DAYS_NEW_PRODUCT') : 20) . ' DAY\n                )\n            ) > 0 AS new'\n            );\n\n            if (Combination::isFeatureActive()) {\n                $querySearch->select('product_attribute_shop.minimal_quantity AS product_attribute_minimal_quantity, IFNULL(product_attribute_shop.`id_product_attribute`,0) AS id_product_attribute');\n            }\n        } else {\n            $querySearch->select('COUNT(wp.id_product)');\n        }\n\n        $querySearch->from('product', 'p');\n        $querySearch->join(Shop::addSqlAssociation('product', 'p'));\n        $querySearch->innerJoin('wishlist_product', 'wp', 'wp.`id_product` = p.`id_product`');\n        $querySearch->leftJoin('category_product', 'cp', 'p.id_product = cp.id_product AND cp.id_category = product_shop.id_category_default');\n\n        if (Combination::isFeatureActive()) {\n            $querySearch->leftJoin('product_attribute_shop', 'product_attribute_shop', 'p.`id_product` = product_attribute_shop.`id_product` AND product_attribute_shop.`id_product_attribute` = wp.id_product_attribute AND product_attribute_shop.id_shop=' . (int) $context->getIdShop());\n        }\n\n        if ('products' === $type) {\n            $querySearch->leftJoin('stock_available', 'stock', 'stock.id_product = `p`.id_product AND stock.id_product_attribute = wp.id_product_attribute' . \\StockAvailable::addSqlShopRestriction(null, (int) $context->getIdShop(), 'stock'));\n            $querySearch->leftJoin('product_lang', 'pl', 'p.`id_product` = pl.`id_product` AND pl.`id_lang` = ' . (int) $context->getIdLang() . \\Shop::addSqlRestrictionOnLang('pl'));\n            $querySearch->leftJoin('image_shop', 'image_shop', 'image_shop.`id_product` = p.`id_product` AND image_shop.cover=1 AND image_shop.id_shop = ' . (int) $context->getIdShop());\n            $querySearch->leftJoin('image_lang', 'il', 'image_shop.`id_image` = il.`id_image` AND il.`id_lang` = ' . (int) $context->getIdLang());\n            $querySearch->leftJoin('category', 'ca', 'cp.`id_category` = ca.`id_category` AND ca.`active` = 1');\n        }\n\n        if (Group::isFeatureActive()) {\n            $groups = FrontController::getCurrentCustomerGroups();\n            $sqlGroups = false === empty($groups) ? 'IN (' . implode(',', $groups) . ')' : '=' . (int) Group::getCurrent()->id;\n            $querySearch->leftJoin('category_group', 'cg', 'cp.`id_category` = cg.`id_category` AND cg.`id_group`' . $sqlGroups);\n        }\n\n        $querySearch->where('wp.id_wishlist = ' . (int) $this->wishList->id);\n        $querySearch->where('product_shop.active = 1');\n        $querySearch->where('product_shop.visibility IN (\"both\", \"catalog\")');\n\n        if ('products' === $type) {\n            $sortOrder = $query->getSortOrder()->toLegacyOrderBy(true);\n            $querySearch->orderBy($sortOrder . ' ' . $query->getSortOrder()->toLegacyOrderWay());\n            $querySearch->limit((int) $query->getResultsPerPage(), ((int) $query->getPage() - 1) * (int) $query->getResultsPerPage());\n            $products = $this->db->executeS($querySearch);\n\n            if (empty($products)) {\n                return [];\n            }\n\n            return Product::getProductsProperties((int) $context->getIdLang(), $products);\n        }\n\n        return (int) $this->db->getValue($querySearch);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * 2007-2020 PrestaShop and Contributors\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2020 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\nnamespace PrestaShop\\Module\\BlockWishList\\Search;\n\nuse Combination;\nuse Configuration;\nuse Db;\nuse DbQuery;\nuse FrontController;\nuse Group;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchContext;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchProviderInterface;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchQuery;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\ProductSearchResult;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\SortOrder;\nuse PrestaShop\\PrestaShop\\Core\\Product\\Search\\SortOrderFactory;\nuse Product;\nuse Shop;\nuse Symfony\\Component\\Translation\\TranslatorInterface;\nuse Validate;\nuse WishList;\n\n/**\n * Responsible of getting products for specific wishlist.\n */\nclass WishListProductSearchProvider implements ProductSearchProviderInterface\n{\n    /**\n     * @var Db\n     */\n    private $db;\n\n    /**\n     * @var WishList\n     */\n    private $wishList;\n\n    /**\n     * @var SortOrderFactory\n     */\n    private $sortOrderFactory;\n\n    /**\n     * @var TranslatorInterface the translator\n     */\n    private $translator;\n\n    /**\n     * @param Db $db\n     * @param WishList $wishList\n     */\n    public function __construct(\n        Db $db,\n        WishList $wishList,\n        SortOrderFactory $sortOrderFactory,\n        TranslatorInterface $translator\n    ) {\n        $this->db = $db;\n        $this->wishList = $wishList;\n        $this->sortOrderFactory = $sortOrderFactory;\n        $this->translator = $translator;\n    }\n\n    /**\n     * @param ProductSearchContext $context\n     * @param ProductSearchQuery $query\n     *\n     * @return ProductSearchResult\n     */\n    public function runQuery(\n        ProductSearchContext $context,\n        ProductSearchQuery $query\n    ) {\n        $result = new ProductSearchResult();\n        $result->setProducts($this->getProductsOrCount($context, $query, 'products'));\n        $result->setTotalProductsCount($this->getProductsOrCount($context, $query, 'count'));\n        $sortOrders = $this->sortOrderFactory->getDefaultSortOrders();\n        $sortOrders[] = (new SortOrder('wishlist_product', 'id_wishlist_product', 'DESC'))->setLabel($this->translator->trans('Last added', [], 'Modules.Blockwishlist.Shop'));\n        $result->setAvailableSortOrders($sortOrders);\n\n        return $result;\n    }\n\n    /**\n     * @param ProductSearchContext $context\n     * @param ProductSearchQuery $query\n     * @param string $type\n     *\n     * @return array|int\n     */\n    private function getProductsOrCount(\n        ProductSearchContext $context,\n        ProductSearchQuery $query,\n        $type = 'products'\n    ) {\n        $querySearch = new DbQuery();\n\n        if ('products' === $type) {\n            $querySearch->select('p.*');\n            $querySearch->select('wp.quantity AS wishlist_quantity');\n            $querySearch->select('product_shop.*');\n            $querySearch->select('stock.out_of_stock, IFNULL(stock.quantity, 0) AS quantity');\n            $querySearch->select('pl.`description`, pl.`description_short`, pl.`link_rewrite`, pl.`meta_description`, pl.`meta_keywords`,\n            pl.`meta_title`, pl.`name`, pl.`available_now`, pl.`available_later`');\n            $querySearch->select('image_shop.`id_image` AS id_image');\n            $querySearch->select('il.`legend`');\n            $querySearch->select('\n            DATEDIFF(\n                product_shop.`date_add`,\n                DATE_SUB(\n                    \"' . date('Y-m-d') . ' 00:00:00\",\n                    INTERVAL ' . (0 <= (int) Configuration::get('PS_NB_DAYS_NEW_PRODUCT') ? Configuration::get('PS_NB_DAYS_NEW_PRODUCT') : 20) . ' DAY\n                )\n            ) > 0 AS new'\n            );\n\n            if (Combination::isFeatureActive()) {\n                $querySearch->select('product_attribute_shop.minimal_quantity AS product_attribute_minimal_quantity, IFNULL(product_attribute_shop.`id_product_attribute`,0) AS id_product_attribute');\n            }\n        } else {\n            $querySearch->select('COUNT(wp.id_product)');\n        }\n\n        $querySearch->from('product', 'p');\n        $querySearch->join(Shop::addSqlAssociation('product', 'p'));\n        $querySearch->innerJoin('wishlist_product', 'wp', 'wp.`id_product` = p.`id_product`');\n        $querySearch->leftJoin('category_product', 'cp', 'p.id_product = cp.id_product AND cp.id_category = product_shop.id_category_default');\n\n        if (Combination::isFeatureActive()) {\n            $querySearch->leftJoin('product_attribute_shop', 'product_attribute_shop', 'p.`id_product` = product_attribute_shop.`id_product` AND product_attribute_shop.`id_product_attribute` = wp.id_product_attribute AND product_attribute_shop.id_shop=' . (int) $context->getIdShop());\n        }\n\n        if ('products' === $type) {\n            $querySearch->leftJoin('stock_available', 'stock', 'stock.id_product = `p`.id_product AND stock.id_product_attribute = wp.id_product_attribute' . \\StockAvailable::addSqlShopRestriction(null, (int) $context->getIdShop(), 'stock'));\n            $querySearch->leftJoin('product_lang', 'pl', 'p.`id_product` = pl.`id_product` AND pl.`id_lang` = ' . (int) $context->getIdLang() . \\Shop::addSqlRestrictionOnLang('pl'));\n            $querySearch->leftJoin('image_shop', 'image_shop', 'image_shop.`id_product` = p.`id_product` AND image_shop.cover=1 AND image_shop.id_shop = ' . (int) $context->getIdShop());\n            $querySearch->leftJoin('image_lang', 'il', 'image_shop.`id_image` = il.`id_image` AND il.`id_lang` = ' . (int) $context->getIdLang());\n            $querySearch->leftJoin('category', 'ca', 'cp.`id_category` = ca.`id_category` AND ca.`active` = 1');\n        }\n\n        if (Group::isFeatureActive()) {\n            $groups = FrontController::getCurrentCustomerGroups();\n            $sqlGroups = false === empty($groups) ? 'IN (' . implode(',', $groups) . ')' : '=' . (int) Group::getCurrent()->id;\n            $querySearch->leftJoin('category_group', 'cg', 'cp.`id_category` = cg.`id_category` AND cg.`id_group`' . $sqlGroups);\n        }\n\n        $querySearch->where('wp.id_wishlist = ' . (int) $this->wishList->id);\n        $querySearch->where('product_shop.active = 1');\n        $querySearch->where('product_shop.visibility IN (\"both\", \"catalog\")');\n\n        if ('products' === $type) {\n            $sortOrder = $query->getSortOrder()->toLegacyOrderBy(true);\n            $sortWay = $query->getSortOrder()->toLegacyOrderWay();\n            if (Validate::isOrderBy($sortOrder) && Validate::isOrderWay($sortWay)) {\n                $querySearch->orderBy($sortOrder . ' ' . $sortWay);\n            }\n            $querySearch->limit((int) $query->getResultsPerPage(), ((int) $query->getPage() - 1) * (int) $query->getResultsPerPage());\n            $products = $this->db->executeS($querySearch);\n\n            if (empty($products)) {\n                return [];\n            }\n\n            return Product::getProductsProperties((int) $context->getIdLang(), $products);\n        }\n\n        return (int) $this->db->getValue($querySearch);\n    }\n}\n"], "filenames": ["src/Search/WishListProductSearchProvider.php"], "buggy_code_start_loc": [37], "buggy_code_end_loc": [171], "fixing_code_start_loc": [38], "fixing_code_end_loc": [175], "type": "CWE-89", "message": "prestashop/blockwishlist is a prestashop extension which adds a block containing the customer's wishlists. In affected versions an authenticated customer can perform SQL injection. This issue is fixed in version 2.1.1. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31101", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-27T23:15:08.107", "lastModified": "2022-12-09T16:09:12.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "prestashop/blockwishlist is a prestashop extension which adds a block containing the customer's wishlists. In affected versions an authenticated customer can perform SQL injection. This issue is fixed in version 2.1.1. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "prestashop/blockwishlist es una extensi\u00f3n de prestashop que a\u00f1ade un bloque que contiene las listas de deseos del cliente. En las versiones afectadas un cliente autenticado puede llevar a cabo una inyecci\u00f3n SQL. Este problema ha sido corregido en versi\u00f3n 2.1.1. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:blockwishlist:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.1", "matchCriteriaId": "A4DB2B77-2FDA-484B-AE8F-DB39CF349AC7"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/168003/Prestashop-Blockwishlist-2.1.0-SQL-Injection.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/PrestaShop/blockwishlist/commit/b3ec4b85af5fd73f74d55390b226d221298ca084", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/PrestaShop/blockwishlist/security/advisories/GHSA-2jx3-5j9v-prpp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PrestaShop/blockwishlist/commit/b3ec4b85af5fd73f74d55390b226d221298ca084"}}