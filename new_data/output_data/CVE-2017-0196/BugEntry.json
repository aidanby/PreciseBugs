{"buggy_code": ["//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\n#include \"RuntimeLibraryPch.h\"\n#include \"Types/PathTypeHandler.h\"\n#include \"Types/SpreadArgument.h\"\n\nnamespace Js\n{\n    // Make sure EmptySegment points to read-only memory.\n    // Can't do this the easy way because SparseArraySegment has a constructor...\n    static const char EmptySegmentData[sizeof(SparseArraySegmentBase)] = {0};\n    const SparseArraySegmentBase *JavascriptArray::EmptySegment = (SparseArraySegmentBase *)&EmptySegmentData;\n\n    // col0 : allocation bucket\n    // col1 : No. of missing items to set during initialization depending on bucket.\n    // col2 : allocation size for elements in given bucket.\n    // col1 and col2 is calculated at runtime\n    uint JavascriptNativeFloatArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        { 3, 0, 0 },    // allocate space for 3 elements for array of length 0,1,2,3\n        { 5, 0, 0 },    // allocate space for 5 elements for array of length 4,5\n        { 8, 0, 0 },    // allocate space for 8 elements for array of length 6,7,8\n    };\n#if defined(_M_X64_OR_ARM64)\n    const Var JavascriptArray::MissingItem = (Var)0x8000000280000002;\n    uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        {2, 0, 0},\n        {6, 0, 0},\n        {8, 0, 0},\n    };\n    uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        {4, 0, 0},\n        {6, 0, 0},\n        {8, 0, 0},\n    };\n#else\n    const Var JavascriptArray::MissingItem = (Var)0x80000002;\n    uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        { 3, 0, 0 },\n        { 7, 0, 0 },\n        { 8, 0, 0 },\n    };\n    uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        { 4, 0, 0 },\n        { 8, 0, 0 },\n    };\n#endif\n\n    const int32 JavascriptNativeIntArray::MissingItem = 0x80000002;\n    static const uint64 FloatMissingItemPattern = 0x8000000280000002ull;\n    const double JavascriptNativeFloatArray::MissingItem = *(double*)&FloatMissingItemPattern;\n\n    // Allocate enough space for 4 inline property slots and 16 inline element slots\n    const size_t JavascriptArray::StackAllocationSize = DetermineAllocationSize<JavascriptArray, 4>(16);\n    const size_t JavascriptNativeIntArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeIntArray, 4>(16);\n    const size_t JavascriptNativeFloatArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeFloatArray, 4>(16);\n\n    SegmentBTree::SegmentBTree()\n        : segmentCount(0),\n          segments(NULL),\n          keys(NULL),\n          children(NULL)\n    {\n    }\n\n    uint32 SegmentBTree::GetLazyCrossOverLimit()\n    {\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n        if (Js::Configuration::Global.flags.DisableArrayBTree)\n        {\n            return Js::JavascriptArray::InvalidIndex;\n        }\n        else if (Js::Configuration::Global.flags.ForceArrayBTree)\n        {\n            return ARRAY_CROSSOVER_FOR_VALIDATE;\n        }\n#endif\n#ifdef VALIDATE_ARRAY\n        if (Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return ARRAY_CROSSOVER_FOR_VALIDATE;\n        }\n#endif\n        return SegmentBTree::MinDegree * 3;\n    }\n\n    BOOL SegmentBTree::IsLeaf() const\n    {\n        return children == NULL;\n    }\n    BOOL SegmentBTree::IsFullNode() const\n    {\n        return segmentCount == MaxKeys;\n    }\n\n    void SegmentBTree::InternalFind(SegmentBTree* node, uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)\n    {\n        uint32 i = 0;\n\n        for(; i < node->segmentCount; i++)\n        {\n            Assert(node->keys[i] == node->segments[i]->left);\n            if (itemIndex <  node->keys[i])\n            {\n                break;\n            }\n        }\n\n        // i indicates the 1st segment in the node past any matching segment.\n        // the i'th child is the children to the 'left' of the i'th segment.\n\n        // If itemIndex matches segment i-1 (note that left is always a match even when length == 0)\n        bool matches = i > 0 && (itemIndex == node->keys[i-1] || itemIndex < node->keys[i-1] + node->segments[i-1]->length);\n\n        if (matches)\n        {\n            // Find prev segment\n            if (node->IsLeaf())\n            {\n                if (i > 1)\n                {\n                    // Previous is either sibling or set in a parent\n                    prev = node->segments[i-2];\n                }\n            }\n            else\n            {\n                // prev is the right most leaf in children[i-1] tree\n                SegmentBTree* child = &node->children[i - 1];\n                while (!child->IsLeaf())\n                {\n                    child = &child->children[child->segmentCount];\n                }\n                prev = child->segments[child->segmentCount - 1];\n            }\n\n            // Return the matching segment\n            matchOrNext = node->segments[i-1];\n        }\n        else // itemIndex in between segment i-1 and i\n        {\n            if (i > 0)\n            {\n                // Store in previous in case a match or next is the first segment in a child.\n                prev = node->segments[i-1];\n            }\n\n            if (node->IsLeaf())\n            {\n                matchOrNext = (i == 0 ? node->segments[0] : prev->next);\n            }\n            else\n            {\n                InternalFind(node->children + i, itemIndex, prev, matchOrNext);\n            }\n        }\n    }\n\n    void SegmentBTreeRoot::Find(uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)\n    {\n        prev = matchOrNext = NULL;\n        InternalFind(this, itemIndex, prev, matchOrNext);\n        Assert(prev == NULL || (prev->next == matchOrNext));// If prev exists it is immediately before matchOrNext in the list of arraysegments\n        Assert(prev == NULL || (prev->left < itemIndex && prev->left + prev->length <= itemIndex)); // prev should never be a match (left is a match if length == 0)\n        Assert(matchOrNext == NULL || (matchOrNext->left >= itemIndex || matchOrNext->left + matchOrNext->length > itemIndex));\n    }\n\n    void SegmentBTreeRoot::Add(Recycler* recycler, SparseArraySegmentBase* newSeg)\n    {\n\n        if (IsFullNode())\n        {\n            SegmentBTree * children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);\n            children[0] = *this;\n\n            // Even though the segments point to a GC pointer, the main array should keep a references\n            // as well.  So just make it a leaf allocation\n            this->segmentCount = 0;\n            this->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n            this->keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);\n            this->children = children;\n\n            // This split is the only way the tree gets deeper\n            SplitChild(recycler, this, 0, &children[0]);\n        }\n        InsertNonFullNode(recycler, this, newSeg);\n    }\n\n    void SegmentBTree::SwapSegment(uint32 originalKey, SparseArraySegmentBase* oldSeg, SparseArraySegmentBase* newSeg)\n    {\n        // Find old segment\n        uint32 itemIndex = originalKey;\n        uint32 i = 0;\n\n        for(; i < segmentCount; i++)\n        {\n            Assert(keys[i] == segments[i]->left || (oldSeg == newSeg && newSeg == segments[i]));\n            if (itemIndex <  keys[i])\n            {\n                break;\n            }\n        }\n\n        // i is 1 past any match\n\n        if (i > 0)\n        {\n            if (oldSeg == segments[i-1])\n            {\n                segments[i-1] = newSeg;\n                keys[i-1] = newSeg->left;\n                return;\n            }\n        }\n\n        Assert(!IsLeaf());\n        children[i].SwapSegment(originalKey, oldSeg, newSeg);\n    }\n\n\n    void SegmentBTree::SplitChild(Recycler* recycler, SegmentBTree* parent, uint32 iChild, SegmentBTree* child)\n    {\n        // Split child in two, move it's median key up to parent, and put the result of the split\n        // on either side of the key moved up into parent\n\n        Assert(child != NULL);\n        Assert(parent != NULL);\n        Assert(!parent->IsFullNode());\n        Assert(child->IsFullNode());\n\n        SegmentBTree newNode;\n        newNode.segmentCount = MinKeys;\n\n        // Even though the segments point to a GC pointer, the main array should keep a references\n        // as well.  So just make it a leaf allocation\n        newNode.segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n        newNode.keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);\n\n        // Move the keys above the median into the new node\n        for(uint32 i = 0; i < MinKeys; i++)\n        {\n            newNode.segments[i] = child->segments[i+MinDegree];\n            newNode.keys[i] = child->keys[i+MinDegree];\n\n            // Do not leave false positive references around in the b-tree\n            child->segments[i+MinDegree] = NULL;\n        }\n\n        // If children exist move those as well.\n        if (!child->IsLeaf())\n        {\n            newNode.children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);\n            for(uint32 j = 0; j < MinDegree; j++)\n            {\n                newNode.children[j] = child->children[j+MinDegree];\n\n                // Do not leave false positive references around in the b-tree\n                child->children[j+MinDegree].segments = NULL;\n                child->children[j+MinDegree].children = NULL;\n            }\n        }\n        child->segmentCount = MinKeys;\n\n        // Make room for the new child in parent\n        for(uint32 j = parent->segmentCount; j > iChild; j--)\n        {\n            parent->children[j+1] = parent->children[j];\n        }\n        // Copy the contents of the new node into the correct place in the parent's child array\n        parent->children[iChild+1] = newNode;\n\n        // Move the keys to make room for the median key\n        for(uint32 k = parent->segmentCount; k > iChild; k--)\n        {\n            parent->segments[k] = parent->segments[k-1];\n            parent->keys[k] = parent->keys[k-1];\n        }\n\n        // Move the median key into the proper place in the parent node\n        parent->segments[iChild] = child->segments[MinKeys];\n        parent->keys[iChild] = child->keys[MinKeys];\n\n        // Do not leave false positive references around in the b-tree\n        child->segments[MinKeys] = NULL;\n\n        parent->segmentCount++;\n    }\n\n    void SegmentBTree::InsertNonFullNode(Recycler* recycler, SegmentBTree* node, SparseArraySegmentBase* newSeg)\n    {\n        Assert(!node->IsFullNode());\n        AnalysisAssert(node->segmentCount < MaxKeys);       // Same as !node->IsFullNode()\n        Assert(newSeg != NULL);\n\n        if (node->IsLeaf())\n        {\n            // Move the keys\n            uint32 i = node->segmentCount - 1;\n            while( (i != -1) && (newSeg->left < node->keys[i]))\n            {\n                node->segments[i+1] = node->segments[i];\n                node->keys[i+1] = node->keys[i];\n                i--;\n            }\n            if (!node->segments)\n            {\n                // Even though the segments point to a GC pointer, the main array should keep a references\n                // as well.  So just make it a leaf allocation\n                node->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n                node->keys = AllocatorNewArrayLeafZ(Recycler, recycler, uint32, MaxKeys);\n            }\n            node->segments[i + 1] = newSeg;\n            node->keys[i + 1] = newSeg->left;\n            node->segmentCount++;\n        }\n        else\n        {\n            // find the correct child node\n            uint32 i = node->segmentCount-1;\n\n            while((i != -1) && (newSeg->left < node->keys[i]))\n            {\n                i--;\n            }\n            i++;\n\n            // Make room if full\n            if(node->children[i].IsFullNode())\n            {\n                // This split doesn't make the tree any deeper as node already has children.\n                SplitChild(recycler, node, i, node->children+i);\n                Assert(node->keys[i] == node->segments[i]->left);\n                if (newSeg->left > node->keys[i])\n                {\n                    i++;\n                }\n            }\n            InsertNonFullNode(recycler, node->children+i, newSeg);\n        }\n    }\n\n    inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure(BOOL operationSucceeded)\n    {\n        if (IsThrowTypeError(operationSucceeded))\n        {\n            ThrowTypeErrorOnFailure();\n        }\n    }\n\n    inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure()\n    {\n        JavascriptError::ThrowTypeError(m_scriptContext, VBSERR_ActionNotSupported, m_functionName);\n    }\n\n    inline BOOL ThrowTypeErrorOnFailureHelper::IsThrowTypeError(BOOL operationSucceeded)\n    {\n        return !operationSucceeded;\n    }\n\n    // Make sure EmptySegment points to read-only memory.\n    // Can't do this the easy way because SparseArraySegment has a constructor...\n    JavascriptArray::JavascriptArray(DynamicType * type)\n        : ArrayObject(type, false, 0)\n    {\n        Assert(type->GetTypeId() == TypeIds_Array || type->GetTypeId() == TypeIds_NativeIntArray || type->GetTypeId() == TypeIds_NativeFloatArray || ((type->GetTypeId() == TypeIds_ES5Array || type->GetTypeId() == TypeIds_Object) && type->GetPrototype() == GetScriptContext()->GetLibrary()->GetArrayPrototype()));\n        Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));\n\n    }\n\n    JavascriptArray::JavascriptArray(uint32 length, DynamicType * type)\n        : ArrayObject(type, false, length)\n    {\n        Assert(JavascriptArray::Is(type->GetTypeId()));\n        Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));\n    }\n\n    JavascriptArray::JavascriptArray(uint32 length, uint32 size, DynamicType * type)\n        : ArrayObject(type, false, length)\n    {\n        Assert(type->GetTypeId() == TypeIds_Array);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptArray::JavascriptArray(DynamicType * type, uint32 size)\n        : ArrayObject(type, false)\n    {\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, false>(this));\n        head->size = size;\n        Var fill = Js::JavascriptArray::MissingItem;\n        for (uint i = 0; i < size; i++)\n        {\n            ((SparseArraySegment<Var>*)head)->elements[i] = fill;\n        }\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(uint32 length, uint32 size, DynamicType * type)\n        : JavascriptNativeArray(type)\n    {\n        Assert(type->GetTypeId() == TypeIds_NativeIntArray);\n        this->length = length;\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<int32>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(DynamicType * type, uint32 size)\n        : JavascriptNativeArray(type)\n    {\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, false>(this));\n        head->size = size;\n        ((SparseArraySegment<int32>*)head)->FillSegmentBuffer(0, size);\n    }\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(uint32 length, uint32 size, DynamicType * type)\n        : JavascriptNativeArray(type)\n    {\n        Assert(type->GetTypeId() == TypeIds_NativeFloatArray);\n        this->length = length;\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<double>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(DynamicType * type, uint32 size)\n        : JavascriptNativeArray(type)\n    {\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, false>(this));\n        head->size = size;\n        ((SparseArraySegment<double>*)head)->FillSegmentBuffer(0, size);\n    }\n\n    bool JavascriptArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptArray::Is(typeId);\n    }\n\n    bool JavascriptArray::Is(TypeId typeId)\n    {\n        return typeId >= TypeIds_ArrayFirst && typeId <= TypeIds_ArrayLast;\n    }\n\n    bool JavascriptArray::IsVarArray(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptArray::IsVarArray(typeId);\n    }\n\n    bool JavascriptArray::IsVarArray(TypeId typeId)\n    {\n        return typeId == TypeIds_Array;\n    }\n\n    template<typename T>\n    bool JavascriptArray::IsMissingItemAt(uint32 index) const\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)this->head;\n\n        return SparseArraySegment<T>::IsMissingItem(&headSeg->elements[index]);\n    }\n\n    bool JavascriptArray::IsMissingItem(uint32 index)\n    {\n        bool isIntArray = false, isFloatArray = false;\n        this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n\n        if (isIntArray)\n        {\n            return IsMissingItemAt<int32>(index);\n        }\n        else if (isFloatArray)\n        {\n            return IsMissingItemAt<double>(index);\n        }\n        else\n        {\n            return IsMissingItemAt<Var>(index);\n        }\n    }\n\n    JavascriptArray* JavascriptArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptArray'\");\n\n        return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    // Get JavascriptArray* from a Var, which is either a JavascriptArray* or ESArray*.\n    JavascriptArray* JavascriptArray::FromAnyArray(Var aValue)\n    {\n        AssertMsg(Is(aValue) || ES5Array::Is(aValue), \"Ensure var is actually a 'JavascriptArray' or 'ES5Array'\");\n\n        return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    // Check if a Var is a direct-accessible (fast path) JavascriptArray.\n    bool JavascriptArray::IsDirectAccessArray(Var aValue)\n    {\n        return RecyclableObject::Is(aValue) &&\n            (VirtualTableInfo<JavascriptArray>::HasVirtualTable(aValue) ||\n                VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue) ||\n                VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue));\n    }\n\n    DynamicObjectFlags JavascriptArray::GetFlags() const\n    {\n        return GetArrayFlags();\n    }\n\n    DynamicObjectFlags JavascriptArray::GetFlags_Unchecked() const // do not use except in extreme circumstances\n    {\n        return GetArrayFlags_Unchecked();\n    }\n\n    void JavascriptArray::SetFlags(const DynamicObjectFlags flags)\n    {\n        SetArrayFlags(flags);\n    }\n\n    DynamicType * JavascriptArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetArrayType();\n    }\n\n    JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(const Var var)\n    {\n        bool isObjectWithArray;\n        TypeId arrayTypeId;\n        return GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);\n    }\n\n    JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(\n        const Var var,\n        bool *const isObjectWithArrayRef,\n        TypeId *const arrayTypeIdRef)\n    {\n        // This is a helper function used by jitted code. The array checks done here match the array checks done by jitted code\n        // (see Lowerer::GenerateArrayTest) to minimize bailouts.\n\n        Assert(var);\n        Assert(isObjectWithArrayRef);\n        Assert(arrayTypeIdRef);\n\n        *isObjectWithArrayRef = false;\n        *arrayTypeIdRef = TypeIds_Undefined;\n\n        if(!RecyclableObject::Is(var))\n        {\n            return nullptr;\n        }\n\n        JavascriptArray *array = nullptr;\n        INT_PTR vtable = VirtualTableInfoBase::GetVirtualTable(var);\n        if(vtable == VirtualTableInfo<DynamicObject>::Address)\n        {\n            ArrayObject* objectArray = DynamicObject::FromVar(var)->GetObjectArray();\n            array = (objectArray && Is(objectArray)) ? FromVar(objectArray) : nullptr;\n            if(!array)\n            {\n                return nullptr;\n            }\n            *isObjectWithArrayRef = true;\n            vtable = VirtualTableInfoBase::GetVirtualTable(array);\n        }\n\n        if(vtable == VirtualTableInfo<JavascriptArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_Array;\n        }\n        else if(vtable == VirtualTableInfo<JavascriptNativeIntArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_NativeIntArray;\n        }\n        else if(vtable == VirtualTableInfo<JavascriptNativeFloatArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_NativeFloatArray;\n        }\n        else\n        {\n            return nullptr;\n        }\n\n        if(!array)\n        {\n            array = FromVar(var);\n        }\n        return array;\n    }\n\n    const SparseArraySegmentBase *JavascriptArray::Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);\n        return array ? array->head : nullptr;\n    }\n\n    uint32 JavascriptArray::Jit_GetArrayHeadSegmentLength(const SparseArraySegmentBase *const headSegment)\n    {\n        // This is a helper function used by jitted code\n\n        return headSegment ? headSegment->length : 0;\n    }\n\n    bool JavascriptArray::Jit_OperationInvalidatedArrayHeadSegment(\n        const SparseArraySegmentBase *const headSegmentBeforeOperation,\n        const uint32 headSegmentLengthBeforeOperation,\n        const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        Assert(varAfterOperation);\n\n        if(!headSegmentBeforeOperation)\n        {\n            return false;\n        }\n\n        const SparseArraySegmentBase *const headSegmentAfterOperation =\n            Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(varAfterOperation);\n        return\n            headSegmentAfterOperation != headSegmentBeforeOperation ||\n            headSegmentAfterOperation->length != headSegmentLengthBeforeOperation;\n    }\n\n    uint32 JavascriptArray::Jit_GetArrayLength(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        bool isObjectWithArray;\n        TypeId arrayTypeId;\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);\n        return array && !isObjectWithArray ? array->GetLength() : 0;\n    }\n\n    bool JavascriptArray::Jit_OperationInvalidatedArrayLength(const uint32 lengthBeforeOperation, const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        return Jit_GetArrayLength(varAfterOperation) != lengthBeforeOperation;\n    }\n\n    DynamicObjectFlags JavascriptArray::Jit_GetArrayFlagsForArrayOrObjectWithArray(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);\n        return array && array->UsesObjectArrayOrFlagsAsFlags() ? array->GetFlags() : DynamicObjectFlags::None;\n    }\n\n    bool JavascriptArray::Jit_OperationCreatedFirstMissingValue(\n        const DynamicObjectFlags flagsBeforeOperation,\n        const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        Assert(varAfterOperation);\n\n        return\n            !!(flagsBeforeOperation & DynamicObjectFlags::HasNoMissingValues) &&\n            !(Jit_GetArrayFlagsForArrayOrObjectWithArray(varAfterOperation) & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    bool JavascriptArray::HasNoMissingValues() const\n    {\n        return !!(GetFlags() & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    bool JavascriptArray::HasNoMissingValues_Unchecked() const // do not use except in extreme circumstances\n    {\n        return !!(GetFlags_Unchecked() & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    void JavascriptArray::SetHasNoMissingValues(const bool hasNoMissingValues)\n    {\n        SetFlags(\n            hasNoMissingValues\n                ? GetFlags() | DynamicObjectFlags::HasNoMissingValues\n                : GetFlags() & ~DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    template<class T>\n    bool JavascriptArray::IsMissingHeadSegmentItemImpl(const uint32 index) const\n    {\n        Assert(index < head->length);\n\n        return SparseArraySegment<T>::IsMissingItem(&static_cast<SparseArraySegment<T> *>(head)->elements[index]);\n    }\n\n    bool JavascriptArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<Var>(index);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    void JavascriptCopyOnAccessNativeIntArray::ConvertCopyOnAccessSegment()\n    {\n        Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));\n        SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));\n        SparseArraySegment<int32> *newSeg = SparseArraySegment<int32>::AllocateLiteralHeadSegment(this->GetRecycler(), seg->length);\n\n#if ENABLE_DEBUG_CONFIG_OPTIONS\n        if (Js::Configuration::Global.flags.TestTrace.IsEnabled(Js::CopyOnAccessArrayPhase))\n        {\n            Output::Print(_u(\"Convert copy-on-access array: index(%d) length(%d)\\n\"), this->GetHead(), seg->length);\n            Output::Flush();\n        }\n#endif\n\n        newSeg->CopySegment(this->GetRecycler(), newSeg, 0, seg, 0, seg->length);\n        this->SetHeadAndLastUsedSegment(newSeg);\n\n        VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(this);\n        this->type = JavascriptNativeIntArray::GetInitialType(this->GetScriptContext());\n\n        ArrayCallSiteInfo *arrayInfo = this->GetArrayCallSiteInfo();\n        if (arrayInfo && !arrayInfo->isNotCopyOnAccessArray)\n        {\n            arrayInfo->isNotCopyOnAccessArray = 1;\n        }\n    }\n\n    uint32 JavascriptCopyOnAccessNativeIntArray::GetNextIndex(uint32 index) const\n    {\n        if (this->length == 0 || (index != Js::JavascriptArray::InvalidIndex && index >= this->length))\n        {\n            return Js::JavascriptArray::InvalidIndex;\n        }\n        else if (index == Js::JavascriptArray::InvalidIndex)\n        {\n            return 0;\n        }\n        else\n        {\n            return index + 1;\n        }\n    }\n\n    BOOL JavascriptCopyOnAccessNativeIntArray::DirectGetItemAt(uint32 index, int* outVal)\n    {\n        Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));\n        SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));\n\n        if (this->length == 0 || index == Js::JavascriptArray::InvalidIndex || index >= this->length)\n        {\n            return FALSE;\n        }\n        else\n        {\n            *outVal = seg->elements[index];\n            return TRUE;\n        }\n    }\n#endif\n\n    bool JavascriptNativeIntArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<int32>(index);\n    }\n\n    bool JavascriptNativeFloatArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<double>(index);\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const T& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)\n    {\n        RecyclableObject* prototype = srcArray->GetPrototype();\n        while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {\n                T n = dstIndex + (index - start);\n                dstArray->DirectSetItemAt(n, value);\n\n                count++;\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n    }\n\n    template<>\n    void JavascriptArray::InternalFillFromPrototype<uint32>(JavascriptArray *dstArray, const uint32& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)\n    {\n        RecyclableObject* prototype = srcArray->GetPrototype();\n        while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {\n                uint32 n = dstIndex + (index - start);\n                dstArray->SetItem(n, value, PropertyOperation_None);\n\n                count++;\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n    }\n\n    /* static */\n    bool JavascriptArray::HasInlineHeadSegment(uint32 length)\n    {\n        return length <= SparseArraySegmentBase::INLINE_CHUNK_SIZE;\n    }\n\n    Var JavascriptArray::OP_NewScArray(uint32 elementCount, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        return scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n    }\n\n    Var JavascriptArray::OP_NewScArrayWithElements(uint32 elementCount, Var *elements, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(elementCount <= head->length);\n        js_memcpy_s(head->elements, sizeof(Var) * head->length, elements, sizeof(Var) * elementCount);\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n\n        return arr;\n    }\n\n    Var JavascriptArray::OP_NewScArrayWithMissingValues(uint32 elementCount, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        JavascriptArray *const array = static_cast<JavascriptArray *>(OP_NewScArray(elementCount, scriptContext));\n        array->SetHasNoMissingValues(false);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)array->head;\n        head->FillSegmentBuffer(0, elementCount);\n\n        return array;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScArray(uint32 elementCount, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(elementCount);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(elementCount);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n        return arr;\n    }\n#endif\n    Var JavascriptArray::OP_NewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext)\n    {\n        uint32 count = ints->count;\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(count > 0 && count == head->length);\n        for (uint i = 0; i < count; i++)\n        {\n            head->elements[i] = JavascriptNumber::ToVar(ints->elements[i], scriptContext);\n        }\n        return arr;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        // Called only to create array literals: size is known.\n        uint32 count = ints->count;\n\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr;\n\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary *lib = scriptContext->GetLibrary();\n            FunctionBody *functionBody = weakFuncRef->Get();\n\n            if (JavascriptLibrary::IsCopyOnAccessArrayCallSite(lib, arrayInfo, count))\n            {\n                Assert(lib->cacheForCopyOnAccessArraySegments);\n                arr = scriptContext->GetLibrary()->CreateCopyOnAccessNativeIntArrayLiteral(arrayInfo, functionBody, ints);\n            }\n            else\n#endif\n            {\n                arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(count);\n                SparseArraySegment<int32> *head = static_cast<SparseArraySegment<int32>*>(arr->head);\n                Assert(count > 0 && count == head->length);\n                js_memcpy_s(head->elements, sizeof(int32)* head->length, ints->elements, sizeof(int32)* count);\n            }\n\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);\n            SparseArraySegment<double> *head = (SparseArraySegment<double>*)arr->head;\n            Assert(count > 0 && count == head->length);\n            for (uint i = 0; i < count; i++)\n            {\n                head->elements[i] = (double)ints->elements[i];\n            }\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        return OP_NewScIntArray(ints, scriptContext);\n    }\n#endif\n\n    Var JavascriptArray::OP_NewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext)\n    {\n        uint32 count = doubles->count;\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(count > 0 && count == head->length);\n        for (uint i = 0; i < count; i++)\n        {\n            double dval = doubles->elements[i];\n            int32 ival;\n            if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))\n            {\n                head->elements[i] = TaggedInt::ToVarUnchecked(ival);\n            }\n            else\n            {\n                head->elements[i] = JavascriptNumber::ToVarNoCheck(dval, scriptContext);\n            }\n        }\n        return arr;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        // Called only to create array literals: size is known.\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            arrayInfo->SetIsNotNativeIntArray();\n            uint32 count = doubles->count;\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);\n            SparseArraySegment<double> *head = (SparseArraySegment<double>*)arr->head;\n            Assert(count > 0 && count == head->length);\n            js_memcpy_s(head->elements, sizeof(double) * head->length, doubles->elements, sizeof(double) * count);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        return OP_NewScFltArray(doubles, scriptContext);\n    }\n\n    Var JavascriptArray::ProfiledNewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n\n        Assert(JavascriptFunction::Is(function) &&\n               JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);\n        Assert(callInfo.Count >= 2);\n\n        ArrayCallSiteInfo *arrayInfo = (ArrayCallSiteInfo*)args[0];\n        JavascriptArray* pNew = nullptr;\n\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                if (arrayInfo && arrayInfo->IsNativeArray())\n                {\n                    if (arrayInfo->IsNativeIntArray())\n                    {\n                        pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);\n                    }\n                    else\n                    {\n                        pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);\n                    }\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateArray(elementCount);\n                }\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                if (arrayInfo && arrayInfo->IsNativeArray())\n                {\n                    if (arrayInfo->IsNativeIntArray())\n                    {\n                        pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);\n                    }\n                    else\n                    {\n                        pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);\n                    }\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateArray(uvalue);\n                }\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            if (arrayInfo && arrayInfo->IsNativeArray())\n            {\n                if (arrayInfo->IsNativeIntArray())\n                {\n                    pNew = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);\n                }\n            }\n            else\n            {\n                pNew = function->GetLibrary()->CreateArray(callInfo.Count - 1);\n            }\n            pNew->FillFromArgs(callInfo.Count - 1, 0, args.Values, arrayInfo);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n        return pNew;\n    }\n#endif\n\n    Var JavascriptArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        // Call to new Array(), possibly under another name.\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        // SkipDefaultNewObject function flag should have prevented the default object\n        // being created, except when call true a host dispatch.\n        const CallInfo &callInfo = args.Info;\n        Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];\n        bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);\n        Assert( isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr\n            || JavascriptOperators::GetTypeId(args[0]) == TypeIds_HostDispatch);\n\n        ScriptContext* scriptContext = function->GetScriptContext();\n        JavascriptArray* pNew = nullptr;\n\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            pNew = CreateArrayFromConstructorNoArg(function, scriptContext);\n\n            return isCtorSuperCall ?\n                JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :\n                pNew;\n        }\n\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                pNew = CreateArrayFromConstructor(function, elementCount, scriptContext);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                pNew = CreateArrayFromConstructor(function, uvalue, scriptContext);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = CreateArrayFromConstructor(function, 1, scriptContext);\n\n                JavascriptOperators::SetItem(pNew, pNew, 0u, firstArgument, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n\n                // If we were passed an uninitialized JavascriptArray as the this argument,\n                // we need to set the length. We must do this _after_ setting the first\n                // element as the array may have side effects such as a setter for property\n                // named '0' which would make the previous length of the array observable.\n                // If we weren't passed a JavascriptArray as the this argument, this is no-op.\n                pNew->SetLength(1);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n            pNew = CreateArrayFromConstructor(function, callInfo.Count - 1, scriptContext);\n            pNew->JavascriptArray::FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n        return isCtorSuperCall ?\n            JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :\n            pNew;\n    }\n\n    JavascriptArray* JavascriptArray::CreateArrayFromConstructor(RecyclableObject* constructor, uint32 length, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = constructor->GetLibrary();\n\n        // Create the Array object we'll return - this is the only way to create an object which is an exotic Array object.\n        // Note: We need to use the library from the ScriptContext of the constructor, not the currently executing function.\n        //       This is for the case where a built-in @@create method from a different JavascriptLibrary is installed on\n        //       constructor.\n        return library->CreateArray(length);\n    }\n\n    JavascriptArray* JavascriptArray::CreateArrayFromConstructorNoArg(RecyclableObject* constructor, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = constructor->GetLibrary();\n        return library->CreateArray();\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewInstanceNoArg(RecyclableObject *function, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        Assert(JavascriptFunction::Is(function) &&\n               JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);\n\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArray();\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArray();\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        return scriptContext->GetLibrary()->CreateArray();\n    }\n#endif\n\n    Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        Assert(!PHASE_OFF1(NativeArrayPhase));\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        const CallInfo &callInfo = args.Info;\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            return function->GetLibrary()->CreateNativeIntArray();\n        }\n\n        JavascriptArray* pNew = nullptr;\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            JavascriptNativeIntArray *arr = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);\n            pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n\n        return pNew;\n    }\n\n    Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        Assert(!PHASE_OFF1(NativeArrayPhase));\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        const CallInfo &callInfo = args.Info;\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            return function->GetLibrary()->CreateNativeFloatArray();\n        }\n\n        JavascriptArray* pNew = nullptr;\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            JavascriptNativeFloatArray *arr = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);\n            pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n\n        return pNew;\n    }\n\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n\n            bool isTaggedInt = TaggedInt::Is(item);\n            bool isTaggedIntMissingValue = false;\n#ifdef _M_AMD64\n            if (isTaggedInt)\n            {\n                int32 iValue = TaggedInt::ToInt32(item);\n                isTaggedIntMissingValue = Js::SparseArraySegment<int32>::IsMissingItem(&iValue);\n            }\n#endif\n            if (isTaggedInt && !isTaggedIntMissingValue)\n            {\n                // This is taggedInt case and we verified that item is not missing value in AMD64.\n                this->DirectSetItemAt(i, TaggedInt::ToInt32(item));\n            }\n            else if (!isTaggedIntMissingValue && JavascriptNumber::Is_NoTaggedIntCheck(item))\n            {\n                double dvalue = JavascriptNumber::GetValue(item);\n                int32 ivalue;\n                if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !Js::SparseArraySegment<int32>::IsMissingItem(&ivalue))\n                {\n                    this->DirectSetItemAt(i, ivalue);\n                }\n                else\n                {\n#if ENABLE_PROFILE_INFO\n                    if (arrayInfo)\n                    {\n                        arrayInfo->SetIsNotNativeIntArray();\n                    }\n#endif\n\n                    if (HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)\n                    {\n                        // Avoid shrinking the number of elements in the head segment. We can still create a new\n                        // array here, so go ahead.\n                        JavascriptNativeFloatArray *fArr =\n                            this->GetScriptContext()->GetLibrary()->CreateNativeFloatArrayLiteral(length);\n                        return fArr->JavascriptNativeFloatArray::FillFromArgs(length, 0, args);\n                    }\n\n                    JavascriptNativeFloatArray *fArr = JavascriptNativeIntArray::ToNativeFloatArray(this);\n                    fArr->DirectSetItemAt(i, dvalue);\n#if ENABLE_PROFILE_INFO\n                    return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, arrayInfo, dontCreateNewArray);\n#else\n                    return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, dontCreateNewArray);\n#endif\n                }\n            }\n            else\n            {\n#if ENABLE_PROFILE_INFO\n                if (arrayInfo)\n                {\n                    arrayInfo->SetIsNotNativeArray();\n                }\n#endif\n\n                #pragma prefast(suppress:6237, \"The right hand side condition does not have any side effects.\")\n                if (sizeof(int32) < sizeof(Var) && HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)\n                {\n                    // Avoid shrinking the number of elements in the head segment. We can still create a new\n                    // array here, so go ahead.\n                    JavascriptArray *arr = this->GetScriptContext()->GetLibrary()->CreateArrayLiteral(length);\n                    return arr->JavascriptArray::FillFromArgs(length, 0, args);\n                }\n\n                JavascriptArray *arr = JavascriptNativeIntArray::ToVarArray(this);\n#if ENABLE_PROFILE_INFO\n                return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);\n#else\n                return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);\n#endif\n            }\n        }\n\n        return this;\n    }\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n            if (TaggedInt::Is(item))\n            {\n                this->DirectSetItemAt(i, TaggedInt::ToDouble(item));\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(item))\n            {\n                this->DirectSetItemAt(i, JavascriptNumber::GetValue(item));\n            }\n            else\n            {\n                JavascriptArray *arr = JavascriptNativeFloatArray::ToVarArray(this);\n#if ENABLE_PROFILE_INFO\n                if (arrayInfo)\n                {\n                    arrayInfo->SetIsNotNativeArray();\n                }\n                return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);\n#else\n                return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);\n#endif\n            }\n        }\n\n        return this;\n    }\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint32 i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n            this->DirectSetItemAt(i, item);\n        }\n\n        return this;\n    }\n\n    DynamicType * JavascriptNativeIntArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetNativeIntArrayType();\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    DynamicType * JavascriptCopyOnAccessNativeIntArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetCopyOnAccessNativeIntArrayType();\n    }\n#endif\n\n    JavascriptNativeFloatArray *JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(intArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Float array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Float array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Int array to Float array\"));\n                Output::Flush();\n            }\n#endif\n\n            arrayInfo->SetIsNotNativeIntArray();\n        }\n#endif\n\n        // Grow the segments\n\n        ScriptContext *scriptContext = intArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = intArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            int i;\n            int32 ival;\n\n            // The old segment will have size/2 and length capped by the new size.\n            seg->size >>= 1;\n            if (seg == intArray->head || seg->length > (seg->size >>= 1))\n            {\n                // Some live elements are being pushed out of this segment, so allocate a new one.\n                SparseArraySegment<double> *newSeg =\n                    SparseArraySegment<double>::AllocateSegment(recycler, left, length, nextSeg);\n                Assert(newSeg != nullptr);\n                Assert((prevSeg == nullptr) == (seg == intArray->head));\n                newSeg->next = nextSeg;\n                intArray->LinkSegments((SparseArraySegment<double>*)prevSeg, newSeg);\n                if (intArray->GetLastUsedSegment() == seg)\n                {\n                    intArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n                SegmentBTree * segmentMap = intArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n\n                // Fill the new segment with the overflow.\n                for (i = 0; (uint)i < newSeg->length; i++)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i /*+ seg->length*/];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        continue;\n                    }\n                    newSeg->elements[i] = (double)ival;\n                }\n            }\n            else\n            {\n                // Now convert the contents that will remain in the old segment.\n                for (i = seg->length - 1; i >= 0; i--)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        ((SparseArraySegment<double>*)seg)->elements[i] = (double)JavascriptNativeFloatArray::MissingItem;\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<double>*)seg)->elements[i] = (double)ival;\n                    }\n                }\n                prevSeg = seg;\n            }\n        }\n\n        if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())\n        {\n            intArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();\n        }\n        else\n        {\n            if (intArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);\n                }\n                else\n                {\n                    intArray->ChangeType();\n                }\n            }\n            intArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(intArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(intArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));\n            VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(intArray);\n        }\n\n        return (JavascriptNativeFloatArray*)intArray;\n    }\n\n    /*\n    *   JavascriptArray::ChangeArrayTypeToNativeArray<double>\n    *   -   Converts the Var Array's type to NativeFloat.\n    *   -   Sets the VirtualTable to \"JavascriptNativeFloatArray\"\n    */\n    template<>\n    void JavascriptArray::ChangeArrayTypeToNativeArray<double>(JavascriptArray * varArray, ScriptContext * scriptContext)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())\n        {\n            varArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();\n        }\n        else\n        {\n            if (varArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);\n                }\n                else\n                {\n                    varArray->ChangeType();\n                }\n            }\n            varArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(varArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(varArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));\n            VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(varArray);\n        }\n    }\n\n    /*\n    *   JavascriptArray::ChangeArrayTypeToNativeArray<int32>\n    *   -   Converts the Var Array's type to NativeInt.\n    *   -   Sets the VirtualTable to \"JavascriptNativeIntArray\"\n    */\n    template<>\n    void JavascriptArray::ChangeArrayTypeToNativeArray<int32>(JavascriptArray * varArray, ScriptContext * scriptContext)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())\n        {\n            varArray->type = scriptContext->GetLibrary()->GetNativeIntArrayType();\n        }\n        else\n        {\n            if (varArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);\n                }\n                else\n                {\n                    varArray->ChangeType();\n                }\n            }\n            varArray->GetType()->SetTypeId(TypeIds_NativeIntArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(varArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::SetVirtualTable(varArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));\n            VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(varArray);\n        }\n    }\n\n    template<>\n    int32 JavascriptArray::GetNativeValue<int32>(Js::Var ival, ScriptContext * scriptContext)\n    {\n        return JavascriptConversion::ToInt32(ival, scriptContext);\n    }\n\n    template <>\n    double JavascriptArray::GetNativeValue<double>(Var ival, ScriptContext * scriptContext)\n    {\n        return JavascriptConversion::ToNumber(ival, scriptContext);\n    }\n\n\n    /*\n    *   JavascriptArray::ConvertToNativeArrayInPlace\n    *   In place conversion of all Var elements to Native Int/Double elements in an array.\n    *   We do not update the DynamicProfileInfo of the array here.\n    */\n    template<typename NativeArrayType, typename T>\n    NativeArrayType *JavascriptArray::ConvertToNativeArrayInPlace(JavascriptArray *varArray)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        ScriptContext *scriptContext = varArray->GetScriptContext();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = varArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            int i;\n            Var ival;\n\n            uint32 growFactor = sizeof(Var) / sizeof(T);\n            AssertMsg(growFactor == 1, \"We support only in place conversion of Var array to Native Array\");\n\n            // Now convert the contents that will remain in the old segment.\n            for (i = seg->length - 1; i >= 0; i--)\n            {\n                ival = ((SparseArraySegment<Var>*)seg)->elements[i];\n                if (ival == JavascriptArray::MissingItem)\n                {\n                    ((SparseArraySegment<T>*)seg)->elements[i] = NativeArrayType::MissingItem;\n                }\n                else\n                {\n                    ((SparseArraySegment<T>*)seg)->elements[i] = GetNativeValue<T>(ival, scriptContext);\n                }\n            }\n            prevSeg = seg;\n        }\n\n        // Update the type of the Array\n        ChangeArrayTypeToNativeArray<T>(varArray, scriptContext);\n\n        return (NativeArrayType*)varArray;\n    }\n\n    JavascriptArray *JavascriptNativeIntArray::ConvertToVarArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(intArray);\n#endif\n        ScriptContext *scriptContext = intArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = intArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            int i;\n            int32 ival;\n\n            // Shrink?\n            uint32 growFactor = sizeof(Var) / sizeof(int32);\n            if ((growFactor != 1 && (seg == intArray->head || seg->length > (seg->size /= growFactor))) ||\n                (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler)))\n            {\n                // Some live elements are being pushed out of this segment, so allocate a new one.\n                // And/or the old segment is not scanned by the recycler, so we need a new one to hold vars.\n                SparseArraySegment<Var> *newSeg =\n                    SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);\n\n                AnalysisAssert(newSeg);\n                Assert((prevSeg == nullptr) == (seg == intArray->head));\n                newSeg->next = nextSeg;\n                intArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);\n                if (intArray->GetLastUsedSegment() == seg)\n                {\n                    intArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n\n                SegmentBTree * segmentMap = intArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n\n                // Fill the new segment with the overflow.\n                for (i = 0; (uint)i < newSeg->length; i++)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        continue;\n                    }\n                    newSeg->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);\n                }\n            }\n            else\n            {\n                // Now convert the contents that will remain in the old segment.\n                // Walk backward in case we're growing the element size.\n                for (i = seg->length - 1; i >= 0; i--)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        ((SparseArraySegment<Var>*)seg)->elements[i] = (Var)JavascriptArray::MissingItem;\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<Var>*)seg)->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);\n                    }\n                }\n                prevSeg = seg;\n            }\n        }\n\n        if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())\n        {\n            intArray->type = scriptContext->GetLibrary()->GetArrayType();\n        }\n        else\n        {\n            if (intArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);\n                }\n                else\n                {\n                    intArray->ChangeType();\n                }\n            }\n            intArray->GetType()->SetTypeId(TypeIds_Array);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(intArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(intArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));\n            VirtualTableInfo<JavascriptArray>::SetVirtualTable(intArray);\n        }\n\n        return intArray;\n    }\n    JavascriptArray *JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(intArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Var array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Int array to Var array\"));\n                Output::Flush();\n            }\n#endif\n\n            arrayInfo->SetIsNotNativeArray();\n        }\n#endif\n\n        intArray->ClearArrayCallSiteIndex();\n\n        return ConvertToVarArray(intArray);\n    }\n\n    DynamicType * JavascriptNativeFloatArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetNativeFloatArrayType();\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::ConvertToVarArray\n    *   This function only converts all Float elements to Var elements in an array.\n    *   DynamicProfileInfo of the array is not updated in this function.\n    */\n    JavascriptArray *JavascriptNativeFloatArray::ConvertToVarArray(JavascriptNativeFloatArray *fArray)\n    {\n        // We can't be growing the size of the element.\n        Assert(sizeof(double) >= sizeof(Var));\n\n        uint32 shrinkFactor = sizeof(double) / sizeof(Var);\n        ScriptContext *scriptContext = fArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = fArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            if (seg->size == 0)\n            {\n                continue;\n            }\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            SparseArraySegment<Var> *newSeg;\n            if (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler))\n            {\n                // The old segment is not scanned by the recycler, so we need a new one to hold vars.\n                newSeg =\n                    SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);\n                Assert((prevSeg == nullptr) == (seg == fArray->head));\n                newSeg->next = nextSeg;\n                fArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);\n                if (fArray->GetLastUsedSegment() == seg)\n                {\n                    fArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n\n                SegmentBTree * segmentMap = fArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n            }\n            else\n            {\n                newSeg = (SparseArraySegment<Var>*)seg;\n                prevSeg = seg;\n                if (shrinkFactor != 1)\n                {\n                    uint32 newSize = seg->size * shrinkFactor;\n                    uint32 limit;\n                    if (seg->next)\n                    {\n                        limit = seg->next->left;\n                    }\n                    else\n                    {\n                        limit = JavascriptArray::MaxArrayLength;\n                    }\n                    seg->size = min(newSize, limit - seg->left);\n                }\n            }\n            uint32 i;\n            for (i = 0; i < seg->length; i++)\n            {\n                if (SparseArraySegment<double>::IsMissingItem(&((SparseArraySegment<double>*)seg)->elements[i]))\n                {\n                    if (seg == newSeg)\n                    {\n                        newSeg->elements[i] = (Var)JavascriptArray::MissingItem;\n                    }\n                    Assert(newSeg->elements[i] == (Var)JavascriptArray::MissingItem);\n                }\n                else if (*(uint64*)&(((SparseArraySegment<double>*)seg)->elements[i]) == 0ull)\n                {\n                    newSeg->elements[i] = TaggedInt::ToVarUnchecked(0);\n                }\n                else\n                {\n                    int32 ival;\n                    double dval = ((SparseArraySegment<double>*)seg)->elements[i];\n                    if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))\n                    {\n                        newSeg->elements[i] = TaggedInt::ToVarUnchecked(ival);\n                    }\n                    else\n                    {\n                        newSeg->elements[i] = JavascriptNumber::ToVarWithCheck(dval, scriptContext);\n                    }\n                }\n            }\n            if (seg == newSeg && shrinkFactor != 1)\n            {\n                // Fill the remaining slots.\n                newSeg->FillSegmentBuffer(i, seg->size);\n            }\n        }\n\n        if (fArray->GetType() == scriptContext->GetLibrary()->GetNativeFloatArrayType())\n        {\n            fArray->type = scriptContext->GetLibrary()->GetArrayType();\n        }\n        else\n        {\n            if (fArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = fArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(fArray);\n                }\n                else\n                {\n                    fArray->ChangeType();\n                }\n            }\n            fArray->GetType()->SetTypeId(TypeIds_Array);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(fArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(fArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(fArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(fArray));\n            VirtualTableInfo<JavascriptArray>::SetVirtualTable(fArray);\n        }\n\n        return fArray;\n    }\n\n    JavascriptArray *JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray *fArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = fArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(fArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Float array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Float array to Var array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Float array to Var array\"));\n                Output::Flush();\n            }\n#endif\n\n            if(fArray->GetScriptContext()->IsScriptContextInNonDebugMode())\n            {\n                Assert(!arrayInfo->IsNativeIntArray());\n            }\n\n            arrayInfo->SetIsNotNativeArray();\n        }\n#endif\n\n        fArray->ClearArrayCallSiteIndex();\n\n        return ConvertToVarArray(fArray);\n\n    }\n\n    // Convert Var to index in the Array.\n    // Note: Spec calls out a few rules for these parameters:\n    // 1. if (arg > length) { return length; }\n    // clamp to length, not length-1\n    // 2. if (arg < 0) { return max(0, length + arg); }\n    // treat negative arg as index from the end of the array (with -1 mapping to length-1)\n    // Effectively, this function will return a value between 0 and length, inclusive.\n    int64 JavascriptArray::GetIndexFromVar(Js::Var arg, int64 length, ScriptContext* scriptContext)\n    {\n        int64 index;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue < 0)\n            {\n                index = max<int64>(0, length + intValue);\n            }\n            else\n            {\n                index = intValue;\n            }\n\n            if (index > length)\n            {\n                index = length;\n            }\n        }\n        else\n        {\n            double doubleValue = JavascriptConversion::ToInteger(arg, scriptContext);\n\n            // Handle the Number.POSITIVE_INFINITY case\n            if (doubleValue > length)\n            {\n                return length;\n            }\n\n            index = NumberUtilities::TryToInt64(doubleValue);\n\n            if (index < 0)\n            {\n                index = max<int64>(0, index + length);\n            }\n        }\n\n        return index;\n    }\n\n    TypeId JavascriptArray::OP_SetNativeIntElementC(JavascriptNativeIntArray *arr, uint32 index, Var value, ScriptContext *scriptContext)\n    {\n        int32 iValue;\n        double dValue;\n\n        TypeId typeId = arr->TrySetNativeIntArrayItem(value, &iValue, &dValue);\n        if (typeId == TypeIds_NativeIntArray)\n        {\n            arr->SetArrayLiteralItem(index, iValue);\n        }\n        else if (typeId == TypeIds_NativeFloatArray)\n        {\n            arr->SetArrayLiteralItem(index, dValue);\n        }\n        else\n        {\n            arr->SetArrayLiteralItem(index, value);\n        }\n        return typeId;\n    }\n\n    TypeId JavascriptArray::OP_SetNativeFloatElementC(JavascriptNativeFloatArray *arr, uint32 index, Var value, ScriptContext *scriptContext)\n    {\n        double dValue;\n        TypeId typeId = arr->TrySetNativeFloatArrayItem(value, &dValue);\n        if (typeId == TypeIds_NativeFloatArray)\n        {\n            arr->SetArrayLiteralItem(index, dValue);\n        }\n        else\n        {\n            arr->SetArrayLiteralItem(index, value);\n        }\n        return typeId;\n    }\n\n    template<typename T>\n    void JavascriptArray::SetArrayLiteralItem(uint32 index, T value)\n    {\n        SparseArraySegment<T> * segment = (SparseArraySegment<T>*)this->head;\n\n        Assert(segment->left == 0);\n        Assert(index < segment->length);\n\n        segment->elements[index] = value;\n    }\n\n    void JavascriptNativeIntArray::SetIsPrototype()\n    {\n        // Force the array to be non-native to simplify inspection, filling from proto, etc.\n        ToVarArray(this);\n        __super::SetIsPrototype();\n    }\n\n    void JavascriptNativeFloatArray::SetIsPrototype()\n    {\n        // Force the array to be non-native to simplify inspection, filling from proto, etc.\n        ToVarArray(this);\n        __super::SetIsPrototype();\n    }\n\n#if ENABLE_PROFILE_INFO\n    ArrayCallSiteInfo *JavascriptNativeArray::GetArrayCallSiteInfo()\n    {\n        RecyclerWeakReference<FunctionBody> *weakRef = this->weakRefToFuncBody;\n        if (weakRef)\n        {\n            FunctionBody *functionBody = weakRef->Get();\n            if (functionBody)\n            {\n                if (functionBody->HasDynamicProfileInfo())\n                {\n                    Js::ProfileId profileId = this->GetArrayCallSiteIndex();\n                    if (profileId < functionBody->GetProfiledArrayCallSiteCount())\n                    {\n                        return functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, profileId);\n                    }\n                }\n            }\n            else\n            {\n                this->ClearArrayCallSiteIndex();\n            }\n        }\n        return nullptr;\n    }\n\n    void JavascriptNativeArray::SetArrayProfileInfo(RecyclerWeakReference<FunctionBody> *weakRef, ArrayCallSiteInfo *arrayInfo)\n    {\n        Assert(weakRef);\n        FunctionBody *functionBody = weakRef->Get();\n        if (functionBody && functionBody->HasDynamicProfileInfo())\n        {\n            ArrayCallSiteInfo *baseInfo = functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, 0);\n            Js::ProfileId index = (Js::ProfileId)(arrayInfo - baseInfo);\n            Assert(index < functionBody->GetProfiledArrayCallSiteCount());\n            SetArrayCallSite(index, weakRef);\n        }\n    }\n\n    void JavascriptNativeArray::CopyArrayProfileInfo(Js::JavascriptNativeArray* baseArray)\n    {\n        if (baseArray->weakRefToFuncBody)\n        {\n            if (baseArray->weakRefToFuncBody->Get())\n            {\n                SetArrayCallSite(baseArray->GetArrayCallSiteIndex(), baseArray->weakRefToFuncBody);\n            }\n            else\n            {\n                baseArray->ClearArrayCallSiteIndex();\n            }\n        }\n    }\n#endif\n\n    Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)\n    {\n        if (JavascriptNativeIntArray::Is(this))\n        {\n            return this->FindMinOrMax<int32, false>(scriptContext, findMax);\n        }\n        else\n        {\n            return this->FindMinOrMax<double, true>(scriptContext, findMax);\n        }\n    }\n\n    template <typename T, bool checkNaNAndNegZero>\n    Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)\n    {\n        AssertMsg(this->HasNoMissingValues(), \"Fastpath is only for arrays with one segment and no missing values\");\n        uint len = this->GetLength();\n\n        Js::SparseArraySegment<T>* headSegment = ((Js::SparseArraySegment<T>*)this->GetHead());\n        uint headSegLen = headSegment->length;\n        Assert(headSegLen == len);\n\n        if (headSegment->next == nullptr)\n        {\n            T currentRes = headSegment->elements[0];\n            for (uint i = 0; i < headSegLen; i++)\n            {\n                T compare = headSegment->elements[i];\n                if (checkNaNAndNegZero && JavascriptNumber::IsNan(double(compare)))\n                {\n                    return scriptContext->GetLibrary()->GetNaN();\n                }\n                if (findMax ? currentRes < compare : currentRes > compare ||\n                    (checkNaNAndNegZero && compare == 0 && Js::JavascriptNumber::IsNegZero(double(currentRes))))\n                {\n                    currentRes = compare;\n                }\n            }\n            return Js::JavascriptNumber::ToVarNoCheck(currentRes, scriptContext);\n        }\n        else\n        {\n            AssertMsg(false, \"FindMinOrMax currently supports native arrays with only one segment\");\n            Throw::FatalInternalError();\n        }\n    }\n\n    SparseArraySegmentBase * JavascriptArray::GetLastUsedSegment() const\n    {\n        return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot->lastUsedSegment : segmentUnion.lastUsedSegment);\n    }\n\n    void JavascriptArray::SetHeadAndLastUsedSegment(SparseArraySegmentBase * segment)\n    {\n\n        Assert(!HasSegmentMap());\n        this->head = this->segmentUnion.lastUsedSegment = segment;\n    }\n\n    void JavascriptArray::SetLastUsedSegment(SparseArraySegmentBase * segment)\n    {\n        if (HasSegmentMap())\n        {\n            this->segmentUnion.segmentBTreeRoot->lastUsedSegment = segment;\n        }\n        else\n        {\n            this->segmentUnion.lastUsedSegment = segment;\n        }\n    }\n    bool JavascriptArray::HasSegmentMap() const\n    {\n        return !!(GetFlags() & DynamicObjectFlags::HasSegmentMap);\n    }\n\n    SegmentBTreeRoot * JavascriptArray::GetSegmentMap() const\n    {\n        return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot : nullptr);\n    }\n\n    void JavascriptArray::SetSegmentMap(SegmentBTreeRoot * segmentMap)\n    {\n        Assert(!HasSegmentMap());\n        SparseArraySegmentBase * lastUsedSeg = this->segmentUnion.lastUsedSegment;\n        SetFlags(GetFlags() | DynamicObjectFlags::HasSegmentMap);\n        segmentUnion.segmentBTreeRoot = segmentMap;\n        segmentMap->lastUsedSegment = lastUsedSeg;\n    }\n\n    void JavascriptArray::ClearSegmentMap()\n    {\n        if (HasSegmentMap())\n        {\n            SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n            SparseArraySegmentBase * lastUsedSeg = segmentUnion.segmentBTreeRoot->lastUsedSegment;\n            segmentUnion.segmentBTreeRoot = nullptr;\n            segmentUnion.lastUsedSegment = lastUsedSeg;\n        }\n    }\n\n    SegmentBTreeRoot * JavascriptArray::BuildSegmentMap()\n    {\n        Recycler* recycler = GetRecycler();\n        SegmentBTreeRoot* tmpSegmentMap = AllocatorNewStruct(Recycler, recycler, SegmentBTreeRoot);\n        ForEachSegment([recycler, tmpSegmentMap](SparseArraySegmentBase * current)\n        {\n            tmpSegmentMap->Add(recycler, current);\n            return false;\n        });\n\n        // There could be OOM during building segment map. Save to array only after its successful completion.\n        SetSegmentMap(tmpSegmentMap);\n        return tmpSegmentMap;\n    }\n\n    void JavascriptArray::TryAddToSegmentMap(Recycler* recycler, SparseArraySegmentBase* seg)\n    {\n        SegmentBTreeRoot * savedSegmentMap = GetSegmentMap();\n        if (savedSegmentMap)\n        {\n            //\n            // We could OOM and throw when adding to segmentMap, resulting in a corrupted segmentMap on this\n            // array. Set segmentMap to null temporarily to protect from this. It will be restored correctly\n            // if adding segment succeeds.\n            //\n            ClearSegmentMap();\n            savedSegmentMap->Add(recycler, seg);\n            SetSegmentMap(savedSegmentMap);\n        }\n    }\n\n    void JavascriptArray::InvalidateLastUsedSegment()\n    {\n        this->SetLastUsedSegment(this->head);\n    }\n\n    DescriptorFlags JavascriptArray::GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        DescriptorFlags flags;\n        if (GetSetterBuiltIns(propertyId, info, &flags))\n        {\n            return flags;\n        }\n        return __super::GetSetter(propertyId, setterValue, info, requestContext);\n    }\n\n    DescriptorFlags JavascriptArray::GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        DescriptorFlags flags;\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && GetSetterBuiltIns(propertyRecord->GetPropertyId(), info, &flags))\n        {\n            return flags;\n        }\n\n        return __super::GetSetter(propertyNameString, setterValue, info, requestContext);\n    }\n\n    bool JavascriptArray::GetSetterBuiltIns(PropertyId propertyId, PropertyValueInfo* info, DescriptorFlags* descriptorFlags)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            PropertyValueInfo::SetNoCache(info, this);\n            *descriptorFlags = WritableData;\n            return true;\n        }\n        return false;\n    }\n\n    SparseArraySegmentBase * JavascriptArray::GetBeginLookupSegment(uint32 index, const bool useSegmentMap) const\n    {\n        SparseArraySegmentBase *seg = nullptr;\n        SparseArraySegmentBase * lastUsedSeg = this->GetLastUsedSegment();\n        if (lastUsedSeg != nullptr && lastUsedSeg->left <= index)\n        {\n            seg = lastUsedSeg;\n            if(index - lastUsedSeg->left < lastUsedSeg->size)\n            {\n                return seg;\n            }\n        }\n\n        SegmentBTreeRoot * segmentMap = GetSegmentMap();\n        if(!useSegmentMap || !segmentMap)\n        {\n            return seg ? seg : this->head;\n        }\n\n        if(seg)\n        {\n            // If indexes are being accessed sequentially, check the segment after the last-used segment before checking the\n            // segment map, as it is likely to hit\n            SparseArraySegmentBase *const nextSeg = seg->next;\n            if(nextSeg)\n            {\n                if(index < nextSeg->left)\n                {\n                    return seg;\n                }\n                else if(index - nextSeg->left < nextSeg->size)\n                {\n                    return nextSeg;\n                }\n            }\n        }\n\n        SparseArraySegmentBase *matchOrNextSeg;\n        segmentMap->Find(index, seg, matchOrNextSeg);\n        return seg ? seg : matchOrNextSeg;\n    }\n\n    uint32 JavascriptArray::GetNextIndex(uint32 index) const\n    {\n        if (JavascriptNativeIntArray::Is((Var)this))\n        {\n            return this->GetNextIndexHelper<int32>(index);\n        }\n        else if (JavascriptNativeFloatArray::Is((Var)this))\n        {\n            return this->GetNextIndexHelper<double>(index);\n        }\n        return this->GetNextIndexHelper<Var>(index);\n    }\n\n    template<typename T>\n    uint32 JavascriptArray::GetNextIndexHelper(uint32 index) const\n    {\n        AssertMsg(this->head, \"array head should never be null\");\n        uint candidateIndex;\n\n        if (index == JavascriptArray::InvalidIndex)\n        {\n            candidateIndex = head->left;\n        }\n        else\n        {\n            candidateIndex = index + 1;\n        }\n\n        SparseArraySegment<T>* current = (SparseArraySegment<T>*)this->GetBeginLookupSegment(candidateIndex);\n\n        while (current != nullptr)\n        {\n            if ((current->left <= candidateIndex) && ((candidateIndex - current->left) < current->length))\n            {\n                for (uint i = candidateIndex - current->left; i < current->length; i++)\n                {\n                    if (!SparseArraySegment<T>::IsMissingItem(&current->elements[i]))\n                    {\n                        return i + current->left;\n                    }\n                }\n            }\n            current = (SparseArraySegment<T>*)current->next;\n            if (current != NULL)\n            {\n                if (candidateIndex < current->left)\n                {\n                    candidateIndex = current->left;\n                }\n            }\n        }\n        return JavascriptArray::InvalidIndex;\n    }\n\n    // If new length > length, we just reset the length\n    // If new length < length, we need to remove the rest of the elements and segment\n    void JavascriptArray::SetLength(uint32 newLength)\n    {\n        if (newLength == length)\n            return;\n\n        if (head == EmptySegment)\n        {\n            // Do nothing to the segment.\n        }\n        else if (newLength == 0)\n        {\n            this->ClearElements(head, 0);\n            head->length = 0;\n            head->next = nullptr;\n            SetHasNoMissingValues();\n\n            ClearSegmentMap();\n            this->InvalidateLastUsedSegment();\n        }\n        else if (newLength < length)\n        {\n            // _ _ 2 3 _ _ 6 7 _ _\n\n            // SetLength(0)\n            // 0 <= left -> set *prev = null\n            // SetLength(2)\n            // 2 <= left -> set *prev = null\n            // SetLength(3)\n            // 3 !<= left; 3 <= right -> truncate to length - 1\n            // SetLength(5)\n            // 5 <=\n\n            SparseArraySegmentBase* next = GetBeginLookupSegment(newLength - 1); // head, or next.left < newLength\n            SparseArraySegmentBase** prev = &head;\n\n            while(next != nullptr)\n            {\n                if (newLength <= next->left)\n                {\n                    ClearSegmentMap(); // truncate segments, null out segmentMap\n                    *prev = nullptr;\n                    break;\n                }\n                else if (newLength <= (next->left + next->length))\n                {\n                    if (next->next)\n                    {\n                        ClearSegmentMap(); // Will truncate segments, null out segmentMap\n                    }\n\n                    uint32 newSegmentLength = newLength - next->left;\n                    this->ClearElements(next, newSegmentLength);\n                    next->next = nullptr;\n                    next->length = newSegmentLength;\n                    break;\n                }\n                else\n                {\n                    prev = &next->next;\n                    next = next->next;\n                }\n            }\n            this->InvalidateLastUsedSegment();\n        }\n        this->length = newLength;\n\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n    }\n\n    BOOL JavascriptArray::SetLength(Var newLength)\n    {\n        ScriptContext *scriptContext;\n        if(TaggedInt::Is(newLength))\n        {\n            int32 lenValue = TaggedInt::ToInt32(newLength);\n            if (lenValue < 0)\n            {\n                scriptContext = GetScriptContext();\n                if (scriptContext->GetThreadContext()->RecordImplicitException())\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n            }\n            else\n            {\n                this->SetLength(lenValue);\n            }\n            return TRUE;\n        }\n\n        scriptContext = GetScriptContext();\n        uint32 uintValue = JavascriptConversion::ToUInt32(newLength, scriptContext);\n        double dblValue = JavascriptConversion::ToNumber(newLength, scriptContext);\n        if (dblValue == uintValue)\n        {\n            this->SetLength(uintValue);\n        }\n        else\n        {\n            ThreadContext* threadContext = scriptContext->GetThreadContext();\n            ImplicitCallFlags flags = threadContext->GetImplicitCallFlags();\n            if (flags != ImplicitCall_None && threadContext->IsDisableImplicitCall())\n            {\n                // We couldn't execute the implicit call(s) needed to convert the newLength to an integer.\n                // Do nothing and let the jitted code bail out.\n                return TRUE;\n            }\n\n            if (threadContext->RecordImplicitException())\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n            }\n        }\n\n        return TRUE;\n    }\n\n    void JavascriptArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<Var>::ClearElements(((SparseArraySegment<Var>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    void JavascriptNativeIntArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<int32>::ClearElements(((SparseArraySegment<int32>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    void JavascriptNativeFloatArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<double>::ClearElements(((SparseArraySegment<double>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    Var JavascriptArray::DirectGetItem(uint32 index)\n    {\n        SparseArraySegment<Var> *seg = (SparseArraySegment<Var>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<Var>::IsMissingItem(&seg->elements[offset]))\n            {\n                return seg->elements[offset];\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptNativeIntArray::DirectGetItem(uint32 index)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        SparseArraySegment<int32> *seg = (SparseArraySegment<int32>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<int32>::IsMissingItem(&seg->elements[offset]))\n            {\n                return JavascriptNumber::ToVar(seg->elements[offset], GetScriptContext());\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    DescriptorFlags JavascriptNativeIntArray::GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif \n        int32 value = 0;\n        return this->DirectGetItemAt(index, &value) ? WritableData : None;\n    }\n\n\n    Var JavascriptNativeFloatArray::DirectGetItem(uint32 index)\n    {\n        SparseArraySegment<double> *seg = (SparseArraySegment<double>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<double>::IsMissingItem(&seg->elements[offset]))\n            {\n                return JavascriptNumber::ToVarWithCheck(seg->elements[offset], GetScriptContext());\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptArray::DirectGetItem(JavascriptString *propName, ScriptContext* scriptContext)\n    {\n        PropertyRecord const * propertyRecord;\n        scriptContext->GetOrAddPropertyRecord(propName->GetString(), propName->GetLength(), &propertyRecord);\n        return JavascriptOperators::GetProperty(this, propertyRecord->GetPropertyId(), scriptContext, NULL);\n    }\n\n    BOOL JavascriptArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        if (this->DirectGetItemAt(index, outVal))\n        {\n            return TRUE;\n        }\n\n        ScriptContext* requestContext = type->GetScriptContext();\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    //\n    // Link prev and current. If prev is NULL, make current the head segment.\n    //\n    void JavascriptArray::LinkSegmentsCommon(SparseArraySegmentBase* prev, SparseArraySegmentBase* current)\n    {\n        if (prev)\n        {\n            prev->next = current;\n        }\n        else\n        {\n            Assert(current);\n            head = current;\n        }\n    }\n\n    template<typename T>\n    BOOL JavascriptArray::DirectDeleteItemAt(uint32 itemIndex)\n    {\n        if (itemIndex >= length)\n        {\n            return true;\n        }\n        SparseArraySegment<T>* next = (SparseArraySegment<T>*)GetBeginLookupSegment(itemIndex);\n        while(next != nullptr && next->left <= itemIndex)\n        {\n            uint32 limit = next->left + next->length;\n            if (itemIndex < limit)\n            {\n                next->SetElement(GetRecycler(), itemIndex, SparseArraySegment<T>::GetMissingItem());\n                if(itemIndex - next->left == next->length - 1)\n                {\n                    --next->length;\n                }\n                else if(next == head)\n                {\n                    SetHasNoMissingValues(false);\n                }\n                break;\n            }\n            next = (SparseArraySegment<T>*)next->next;\n        }\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n        return true;\n    }\n\n    template <> Var JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)\n    {\n        return idxDest.ToNumber(scriptContext);\n    }\n\n    template <> uint32 JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)\n    {\n        // Note this is only for setting Array length which is a uint32\n        return idxDest.IsSmallIndex() ? idxDest.GetSmallIndex() : UINT_MAX;\n    }\n\n    template <> Var JavascriptArray::ConvertToIndex(uint32 idxDest, ScriptContext* scriptContext)\n    {\n        return  JavascriptNumber::ToVar(idxDest, scriptContext);\n    }\n\n    void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, uint32 index)\n    {\n        if (!succeeded)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(index, scriptContext), scriptContext)->GetSz());\n        }\n    }\n\n    void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, BigIndex index)\n    {\n        if (!succeeded)\n        {\n            uint64 i = (uint64)(index.IsSmallIndex() ? index.GetSmallIndex() : index.GetBigIndex());\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(i, scriptContext), scriptContext)->GetSz());\n        }\n    }\n\n    BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, uint32 idxDest, Var aItem)\n    {\n        return pDestObj->SetItem(idxDest, aItem, Js::PropertyOperation_ThrowIfNotExtensible);\n    }\n    BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, BigIndex idxDest, Var aItem)\n    {\n        ScriptContext* scriptContext = pDestObj->GetScriptContext();\n\n        if (idxDest.IsSmallIndex())\n        {\n            return pDestObj->SetItem(idxDest.GetSmallIndex(), aItem, Js::PropertyOperation_ThrowIfNotExtensible);\n        }\n        PropertyRecord const * propertyRecord;\n        JavascriptOperators::GetPropertyIdForInt(idxDest.GetBigIndex(), scriptContext, &propertyRecord);\n        return pDestObj->SetProperty(propertyRecord->GetPropertyId(), aItem, PropertyOperation_ThrowIfNotExtensible, nullptr);\n    }\n\n    template<typename T>\n    void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, uint start, BigIndex startIdxDest, BOOL FirstPromotedItemIsSpreadable, BigIndex FirstPromotedItemLength)\n    {\n        // This never gets called.\n        Throw::InternalError();\n    }\n    //\n    // Helper for EntryConcat. Concat args or elements of arg arrays into dest array.\n    //\n    template<typename T>\n    void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, uint start, uint startIdxDest, BOOL firstPromotedItemIsSpreadable, BigIndex firstPromotedItemLength)\n    {\n        JavascriptArray* pDestArray = nullptr;\n\n        if (JavascriptArray::Is(pDestObj))\n        {\n            pDestArray = JavascriptArray::FromVar(pDestObj);\n        }\n\n        T idxDest = startIdxDest;\n        for (uint idxArg = start; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n            BOOL spreadable = false;\n            if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())\n            {\n                // firstPromotedItemIsSpreadable is ONLY used to resume after a type promotion from uint32 to uint64\n                // we do this because calls to IsConcatSpreadable are observable (a big deal for proxies) and we don't\n                // want to do the work a second time as soon as we record the length we clear the flag.\n                spreadable = firstPromotedItemIsSpreadable || JavascriptOperators::IsConcatSpreadable(aItem);\n\n                if (!spreadable)\n                {\n                    JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext);\n                    ++idxDest;\n                    continue;\n                }\n            }\n\n            if (pDestArray && JavascriptArray::IsDirectAccessArray(aItem) && JavascriptArray::IsDirectAccessArray(pDestArray)\n                && BigIndex(idxDest + JavascriptArray::FromVar(aItem)->length).IsSmallIndex()) // Fast path\n            {\n                if (JavascriptNativeIntArray::Is(aItem))\n                {\n                    JavascriptNativeIntArray *pItemArray = JavascriptNativeIntArray::FromVar(aItem);\n                    CopyNativeIntArrayElementsToVar(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else if (JavascriptNativeFloatArray::Is(aItem))\n                {\n                    JavascriptNativeFloatArray *pItemArray = JavascriptNativeFloatArray::FromVar(aItem);\n                    CopyNativeFloatArrayElementsToVar(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else\n                {\n                    JavascriptArray* pItemArray = JavascriptArray::FromVar(aItem);\n                    CopyArrayElements(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n            }\n            else\n            {\n                // Flatten if other array or remote array (marked with TypeIds_Array)\n                if (DynamicObject::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array || spreadable)\n                {\n                    //CONSIDER: enumerating remote array instead of walking all indices\n                    BigIndex length;\n                    if (firstPromotedItemIsSpreadable)\n                    {\n                        firstPromotedItemIsSpreadable = false;\n                        length = firstPromotedItemLength;\n                    }\n                    else if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n                    {\n                        // we can cast to uin64 without fear of converting negative numbers to large positive ones\n                        // from int64 because ToLength makes negative lengths 0\n                        length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                    }\n                    else\n                    {\n                        length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                    }\n\n                    if (PromoteToBigIndex(length,idxDest))\n                    {\n                        // This is a special case for spreadable objects. We do not pre-calculate the length\n                        // in EntryConcat like we do with Arrays because a getProperty on an object Length\n                        // is observable. The result is we have to check for overflows separately for\n                        // spreadable objects and promote to a bigger index type when we find them.\n                        ConcatArgs<BigIndex>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, /*firstPromotedItemIsSpreadable*/true, length);\n                        return;\n                    }\n\n                    if (length + idxDest > FiftyThirdPowerOfTwoMinusOne) // 2^53-1: from ECMA 22.1.3.1 Array.prototype.concat(...arguments)\n                    {\n                        JavascriptError::ThrowTypeError(scriptContext, JSERR_IllegalArraySizeAndLength);\n                    }\n\n                    RecyclableObject* itemObject = RecyclableObject::FromVar(aItem);\n                    Var subItem;\n                    uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;\n                    for (uint32 idxSubItem = 0u; idxSubItem < lengthToUin32Max; ++idxSubItem)\n                    {\n                        if (JavascriptOperators::HasItem(itemObject, idxSubItem))\n                        {\n                            subItem = JavascriptOperators::GetItem(itemObject, idxSubItem, scriptContext);\n\n                            if (pDestArray)\n                            {\n                                pDestArray->DirectSetItemAt(idxDest, subItem);\n                            }\n                            else\n                            {\n                                ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxDest);\n                            }\n                        }\n                        ++idxDest;\n                    }\n\n                    for (BigIndex idxSubItem = MaxArrayLength; idxSubItem < length; ++idxSubItem)\n                    {\n                        PropertyRecord const * propertyRecord;\n                        JavascriptOperators::GetPropertyIdForInt(idxSubItem.GetBigIndex(), scriptContext, &propertyRecord);\n                        if (JavascriptOperators::HasProperty(itemObject,propertyRecord->GetPropertyId()))\n                        {\n                            subItem = JavascriptOperators::GetProperty(itemObject, propertyRecord->GetPropertyId(), scriptContext);\n                            if (pDestArray)\n                            {\n                                pDestArray->DirectSetItemAt(idxDest, subItem);\n                            }\n                            else\n                            {\n                                ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxSubItem);\n                            }\n                        }\n                        ++idxDest;\n                    }\n                }\n                else // concat 1 item\n                {\n                    JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext);\n                    ++idxDest;\n                }\n            }\n        }\n        if (!pDestArray)\n        {\n            pDestObj->SetProperty(PropertyIds::length, ConvertToIndex<T, Var>(idxDest, scriptContext), Js::PropertyOperation_None, nullptr);\n        }\n        else if (pDestArray->GetLength() != ConvertToIndex<T, uint32>(idxDest, scriptContext))\n        {\n            pDestArray->SetLength(ConvertToIndex<T, uint32>(idxDest, scriptContext));\n        }\n    }\n    bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, BigIndex rhs)\n    {\n        return false; // already a big index\n    }\n\n    bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, uint32 rhs)\n    {\n        ::Math::RecordOverflowPolicy destLengthOverflow;\n        if (lhs.IsSmallIndex())\n        {\n            UInt32Math::Add(lhs.GetSmallIndex(), rhs, destLengthOverflow);\n            return destLengthOverflow.HasOverflowed();\n        }\n        return true;\n    }\n\n    JavascriptArray* JavascriptArray::ConcatIntArgs(JavascriptNativeIntArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)\n    {\n        uint idxDest = 0u;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n\n            bool concatSpreadable = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem);\n            if (!JavascriptNativeIntArray::Is(pDestArray))\n            {\n                ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pDestArray;\n            }\n            if(!concatSpreadable)\n            {\n                pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible);\n                idxDest = idxDest + 1;\n                if (!JavascriptNativeIntArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back\n                {\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n                continue;\n            }\n\n            if (JavascriptNativeIntArray::Is(aItem)) // Fast path\n            {\n                JavascriptNativeIntArray* pItemArray = JavascriptNativeIntArray::FromVar(aItem);\n                bool converted = CopyNativeIntArrayElements(pDestArray, idxDest, pItemArray);\n                idxDest = idxDest + pItemArray->length;\n                if (converted)\n                {\n                    // Copying the last array forced a conversion, so switch over to the var version\n                    // to finish.\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n            }\n            else if (!JavascriptArray::IsAnyArray(aItem) && remoteTypeIds[idxArg] != TypeIds_Array)\n            {\n                if (TaggedInt::Is(aItem))\n                {\n                    pDestArray->DirectSetItemAt(idxDest, TaggedInt::ToInt32(aItem));\n                }\n                else\n                {\n#if DBG\n                    int32 int32Value;\n                    Assert(\n                        JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) &&\n                        !SparseArraySegment<int32>::IsMissingItem(&int32Value));\n#endif\n                    pDestArray->DirectSetItemAt(idxDest, static_cast<int32>(JavascriptNumber::GetValue(aItem)));\n                }\n                ++idxDest;\n            }\n            else\n            {\n                JavascriptArray *pVarDestArray = JavascriptNativeIntArray::ConvertToVarArray(pDestArray);\n                ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pVarDestArray;\n            }\n        }\n        if (pDestArray->GetLength() != idxDest)\n        {\n            pDestArray->SetLength(idxDest);\n        }\n        return pDestArray;\n    }\n\n    JavascriptArray* JavascriptArray::ConcatFloatArgs(JavascriptNativeFloatArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)\n    {\n        uint idxDest = 0u;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n\n            bool concatSpreadable = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem);\n            if (!JavascriptNativeFloatArray::Is(pDestArray))\n            {\n                ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pDestArray;\n            }\n            if (!concatSpreadable)\n            {\n                pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible);\n\n                idxDest = idxDest + 1;\n                if (!JavascriptNativeFloatArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back\n                {\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n                continue;\n            }\n\n            bool converted;\n            if (JavascriptArray::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array)\n            {\n                if (JavascriptNativeIntArray::Is(aItem)) // Fast path\n                {\n                    JavascriptNativeIntArray *pIntArray = JavascriptNativeIntArray::FromVar(aItem);\n                    converted = CopyNativeIntArrayElementsToFloat(pDestArray, idxDest, pIntArray);\n                    idxDest = idxDest + pIntArray->length;\n                }\n                else if (JavascriptNativeFloatArray::Is(aItem))\n                {\n                    JavascriptNativeFloatArray* pItemArray = JavascriptNativeFloatArray::FromVar(aItem);\n                    converted = CopyNativeFloatArrayElements(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else\n                {\n                    JavascriptArray *pVarDestArray = JavascriptNativeFloatArray::ConvertToVarArray(pDestArray);\n                    ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                    return pVarDestArray;\n                }\n                if (converted)\n                {\n                    // Copying the last array forced a conversion, so switch over to the var version\n                    // to finish.\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n            }\n            else\n            {\n                if (TaggedInt::Is(aItem))\n                {\n                    pDestArray->DirectSetItemAt(idxDest, (double)TaggedInt::ToInt32(aItem));\n                }\n                else\n                {\n                    Assert(JavascriptNumber::Is(aItem));\n                    pDestArray->DirectSetItemAt(idxDest, JavascriptNumber::GetValue(aItem));\n                }\n                ++idxDest;\n            }\n        }\n        if (pDestArray->GetLength() != idxDest)\n        {\n            pDestArray->SetLength(idxDest);\n        }\n\n        return pDestArray;\n    }\n\n    bool JavascriptArray::BoxConcatItem(Var aItem, uint idxArg, ScriptContext *scriptContext)\n    {\n        return idxArg == 0 && !JavascriptOperators::IsObject(aItem);\n    }\n\n    Var JavascriptArray::EntryConcat(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));\n        }\n\n        //\n        // Compute the destination ScriptArray size:\n        // - Each item, flattening only one level if a ScriptArray.\n        //\n\n        uint32 cDestLength = 0;\n        JavascriptArray * pDestArray = NULL;\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault + (args.Info.Count * sizeof(TypeId*)));\n        TypeId* remoteTypeIds = (TypeId*)_alloca(args.Info.Count * sizeof(TypeId*));\n\n        bool isInt = true;\n        bool isFloat = true;\n        ::Math::RecordOverflowPolicy destLengthOverflow;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(aItem);\n#endif\n            if (DynamicObject::IsAnyArray(aItem)) // Get JavascriptArray or ES5Array length\n            {\n                JavascriptArray * pItemArray = JavascriptArray::FromAnyArray(aItem);\n                if (isFloat)\n                {\n                    if (!JavascriptNativeIntArray::Is(pItemArray))\n                    {\n                        isInt = false;\n                        if (!JavascriptNativeFloatArray::Is(pItemArray))\n                        {\n                            isFloat = false;\n                        }\n                    }\n                }\n                cDestLength = UInt32Math::Add(cDestLength, pItemArray->GetLength(), destLengthOverflow);\n            }\n            else // Get remote array or object length\n            {\n                // We already checked for types derived from JavascriptArray. These are types that should behave like array\n                // i.e. proxy to array and remote array.\n                if (JavascriptOperators::IsArray(aItem))\n                {\n                    // Don't try to preserve nativeness of remote arrays. The extra complexity is probably not\n                    // worth it.\n                    isInt = false;\n                    isFloat = false;\n                    if (!JavascriptProxy::Is(aItem))\n                    {\n                        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n                        {\n                            int64 len = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                            // clipping to MaxArrayLength will overflow when added to cDestLength which we catch below\n                            cDestLength = UInt32Math::Add(cDestLength, len < MaxArrayLength ? (uint32)len : MaxArrayLength, destLengthOverflow);\n                        }\n                        else\n                        {\n                            uint len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                            cDestLength = UInt32Math::Add(cDestLength, len, destLengthOverflow);\n                        }\n                    }\n                    remoteTypeIds[idxArg] = TypeIds_Array; // Mark remote array, no matter remote JavascriptArray or ES5Array.\n                }\n                else\n                {\n                    if (isFloat)\n                    {\n                        if (BoxConcatItem(aItem, idxArg, scriptContext))\n                        {\n                            // A primitive will be boxed, so we have to create a var array for the result.\n                            isInt = false;\n                            isFloat = false;\n                        }\n                        else if (!TaggedInt::Is(aItem))\n                        {\n                            if (!JavascriptNumber::Is(aItem))\n                            {\n                                isInt = false;\n                                isFloat = false;\n                            }\n                            else if (isInt)\n                            {\n                                int32 int32Value;\n                                if(!JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) ||\n                                    SparseArraySegment<int32>::IsMissingItem(&int32Value))\n                                {\n                                    isInt = false;\n                                }\n                            }\n                        }\n                        else if(isInt)\n                        {\n                            int32 int32Value = TaggedInt::ToInt32(aItem);\n                            if(SparseArraySegment<int32>::IsMissingItem(&int32Value))\n                            {\n                                isInt = false;\n                            }\n                        }\n                    }\n\n                    remoteTypeIds[idxArg] = TypeIds_Limit;\n                    cDestLength = UInt32Math::Add(cDestLength, 1, destLengthOverflow);\n                }\n            }\n        }\n        if (destLengthOverflow.HasOverflowed())\n        {\n            cDestLength = MaxArrayLength;\n            isInt = false;\n            isFloat = false;\n        }\n\n        //\n        // Create the destination array\n        //\n        RecyclableObject* pDestObj = nullptr;\n        bool isArray = false;\n        pDestObj = ArraySpeciesCreate(args[0], 0, scriptContext);\n        if (pDestObj)\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pDestObj);\n#endif\n            // Check the thing that species create made. If it's a native array that can't handle the source\n            // data, convert it. If it's a more conservative kind of array than the source data, indicate that\n            // so that the data will be converted on copy.\n            if (isInt)\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    isArray = true;\n                }\n                else\n                {\n                    isInt = false;\n                    isFloat = JavascriptNativeFloatArray::Is(pDestObj);\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n            else if (isFloat)\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else\n                {\n                    isFloat = JavascriptNativeFloatArray::Is(pDestObj);\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n            else\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else if (JavascriptNativeFloatArray::Is(pDestObj))\n                {\n                    JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else\n                {\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n        }\n\n        if (pDestObj == nullptr || isArray)\n        {\n            if (isInt)\n            {\n                JavascriptNativeIntArray *pIntArray = isArray ? JavascriptNativeIntArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeIntArray(cDestLength);\n                pIntArray->EnsureHead<int32>();\n                pDestArray = ConcatIntArgs(pIntArray, remoteTypeIds, args, scriptContext);\n            }\n            else if (isFloat)\n            {\n                JavascriptNativeFloatArray *pFArray = isArray ? JavascriptNativeFloatArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeFloatArray(cDestLength);\n                pFArray->EnsureHead<double>();\n                pDestArray = ConcatFloatArgs(pFArray, remoteTypeIds, args, scriptContext);\n            }\n            else\n            {\n\n                pDestArray = isArray ?  JavascriptArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateArray(cDestLength);\n                // if the constructor has changed then we no longer specialize for ints and floats\n                pDestArray->EnsureHead<Var>();\n                ConcatArgsCallingHelper(pDestArray, remoteTypeIds, args, scriptContext, destLengthOverflow);\n            }\n\n            //\n            // Return the new array instance.\n            //\n\n#ifdef VALIDATE_ARRAY\n            pDestArray->ValidateArray();\n#endif\n\n            return pDestArray;\n        }\n        Assert(pDestObj);\n        ConcatArgsCallingHelper(pDestObj, remoteTypeIds, args, scriptContext, destLengthOverflow);\n\n        return pDestObj;\n    }\n\n    void JavascriptArray::ConcatArgsCallingHelper(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, ::Math::RecordOverflowPolicy &destLengthOverflow)\n    {\n        if (destLengthOverflow.HasOverflowed())\n        {\n            ConcatArgs<BigIndex>(pDestObj, remoteTypeIds, args, scriptContext);\n        }\n        else\n        {\n            // Use faster uint32 version if no overflow\n            ConcatArgs<uint32>(pDestObj, remoteTypeIds, args, scriptContext);\n        }\n    }\n\n    template<typename T>\n    /* static */ void JavascriptArray::SetConcatItem(Var aItem, uint idxArg, JavascriptArray* pDestArray, RecyclableObject* pDestObj, T idxDest, ScriptContext *scriptContext)\n    {\n        if (BoxConcatItem(aItem, idxArg, scriptContext))\n        {\n            // bug# 725784: ES5: not calling ToObject in Step 1 of 15.4.4.4\n            RecyclableObject* pObj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(aItem, scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));\n            }\n            if (pDestArray)\n            {\n                pDestArray->DirectSetItemAt(idxDest, pObj);\n            }\n            else\n            {\n                SetArrayLikeObjects(pDestObj, idxDest, pObj);\n            }\n        }\n        else\n        {\n            if (pDestArray)\n            {\n                pDestArray->DirectSetItemAt(idxDest, aItem);\n            }\n            else\n            {\n                SetArrayLikeObjects(pDestObj, idxDest, aItem);\n            }\n        }\n    }\n\n    uint32 JavascriptArray::GetFromIndex(Var arg, uint32 length, ScriptContext *scriptContext)\n    {\n        uint32 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = intValue;\n            }\n            else\n            {\n                // (intValue + length) may exceed 2^31 or may be < 0, so promote to int64\n                fromIndex = (uint32)max(0i64, (int64)(length) + intValue);\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n            if (value > length)\n            {\n                return (uint32)-1;\n            }\n            else if (value >= 0)\n            {\n                fromIndex = (uint32)value;\n            }\n            else\n            {\n                fromIndex = (uint32)max((double)0, value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    uint64 JavascriptArray::GetFromIndex(Var arg, uint64 length, ScriptContext *scriptContext)\n    {\n        uint64 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int64 intValue = TaggedInt::ToInt64(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = intValue;\n            }\n            else\n            {\n                fromIndex = max((int64)0, (int64)(intValue + length));\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n            if (value > length)\n            {\n                return (uint64)-1;\n            }\n            else if (value >= 0)\n            {\n                fromIndex = (uint64)value;\n            }\n            else\n            {\n                fromIndex = (uint64)max((double)0, value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    int64 JavascriptArray::GetFromLastIndex(Var arg, int64 length, ScriptContext *scriptContext)\n    {\n        int64 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = min<int64>(intValue, length - 1);\n            }\n            else if ((uint32)-intValue > length)\n            {\n                return length;\n            }\n            else\n            {\n                fromIndex = intValue + length;\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n\n            if (value >= 0)\n            {\n                fromIndex = (int64)min(value, (double)(length - 1));\n            }\n            else if (value + length < 0)\n            {\n                return length;\n            }\n            else\n            {\n                fromIndex = (int64)(value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    // includesAlgorithm specifies to follow ES7 Array.prototype.includes semantics instead of Array.prototype.indexOf\n    // Differences\n    //    1. Returns boolean true or false value instead of the search hit index\n    //    2. Follows SameValueZero algorithm instead of StrictEquals\n    //    3. Missing values are scanned if the search value is undefined\n\n    template <bool includesAlgorithm>\n    Var JavascriptArray::IndexOfHelper(Arguments const & args, ScriptContext *scriptContext)\n    {\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        BigIndex length;\n        Var trueValue = scriptContext->GetLibrary()->GetTrue();\n        Var falseValue = scriptContext->GetLibrary()->GetFalse();\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.indexOf\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (pArr)\n        {\n            Var search;\n            uint32 fromIndex;\n            uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();\n            if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            int32 index = pArr->HeadSegmentIndexOfHelper(search, fromIndex, len, includesAlgorithm, scriptContext);\n\n            // If we found the search value in the head segment, or if we determined there is no need to search other segments,\n            // we stop right here.\n            if (index != -1 || fromIndex == -1)\n            {\n                if (includesAlgorithm)\n                {\n                    //Array.prototype.includes\n                    return (index == -1)? falseValue : trueValue;\n                }\n                else\n                {\n                    //Array.prototype.indexOf\n                    return JavascriptNumber::ToVar(index, scriptContext);\n                }\n            }\n\n            //  If we really must search other segments, let's do it now. We'll have to search the slow way (dealing with holes, etc.).\n\n            switch (pArr->GetTypeId())\n            {\n            case Js::TypeIds_Array:\n                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);\n            case Js::TypeIds_NativeIntArray:\n                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, len, scriptContext);\n            case Js::TypeIds_NativeFloatArray:\n                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, len, scriptContext);\n            default:\n                AssertMsg(FALSE, \"invalid array typeid\");\n                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);\n            }\n        }\n\n        // source object is not a JavascriptArray but source could be a TypedArray\n        if (TypedArrayBase::Is(obj))\n        {\n            if (length.IsSmallIndex() || length.IsUint32Max())\n            {\n                Var search;\n                uint32 fromIndex;\n                uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();\n                if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))\n                {\n                    return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n                }\n                return TemplatedIndexOfHelper<includesAlgorithm>(TypedArrayBase::FromVar(obj), search, fromIndex, length.GetSmallIndex(), scriptContext);\n            }\n        }\n        if (length.IsSmallIndex())\n        {\n            Var search;\n            uint32 fromIndex;\n            if (!GetParamForIndexOf(length.GetSmallIndex(), args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetSmallIndex(), scriptContext);\n        }\n        else\n        {\n            Var search;\n            uint64 fromIndex;\n            if (!GetParamForIndexOf(length.GetBigIndex(), args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetBigIndex(), scriptContext);\n        }\n    }\n\n    // Array.prototype.indexOf as defined in ES6.0 (final) Section 22.1.3.11\n    Var JavascriptArray::EntryIndexOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_indexOf);\n\n        Var returnValue =  IndexOfHelper<false>(args, scriptContext);\n\n        //IndexOfHelper code is reused for array.prototype.includes as well. Let us assert here we didn't get a true or false instead of index\n        Assert(returnValue != scriptContext->GetLibrary()->GetTrue() && returnValue != scriptContext->GetLibrary()->GetFalse());\n\n        return returnValue;\n    }\n\n    Var JavascriptArray::EntryIncludes(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_includes);\n\n        Var returnValue = IndexOfHelper<true>(args, scriptContext);\n        Assert(returnValue == scriptContext->GetLibrary()->GetTrue() || returnValue == scriptContext->GetLibrary()->GetFalse());\n\n        return returnValue;\n    }\n\n\n    template<typename T>\n    BOOL JavascriptArray::GetParamForIndexOf(T length, Arguments const& args, Var& search, T& fromIndex, ScriptContext * scriptContext)\n    {\n        if (length == 0)\n        {\n            return false;\n        }\n\n        if (args.Info.Count > 2)\n        {\n            fromIndex = GetFromIndex(args[2], length, scriptContext);\n            if (fromIndex >= length)\n            {\n                return false;\n            }\n            search = args[1];\n        }\n        else\n        {\n            fromIndex = 0;\n            search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();\n        }\n        return true;\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // Note: Sometime cross site array go down this path to get the marshalling\n        Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));\n        if (checkHasItem && !JavascriptOperators::HasItem(obj, index))\n        {\n            return FALSE;\n        }\n        return JavascriptOperators::GetItem(obj, index, element, scriptContext);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // Note: Sometime cross site array go down this path to get the marshalling\n        Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));\n        PropertyRecord const * propertyRecord;\n        JavascriptOperators::GetPropertyIdForInt(index, scriptContext, &propertyRecord);\n        if (checkHasItem && !JavascriptOperators::HasProperty(obj, propertyRecord->GetPropertyId()))\n        {\n            return FALSE;\n        }\n        *element = JavascriptOperators::GetProperty(obj, propertyRecord->GetPropertyId(), scriptContext);\n        return *element != scriptContext->GetLibrary()->GetUndefined();\n\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptArray::DirectGetItemAtFull(index, element);\n    }\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptNativeIntArray::DirectGetItemAtFull(index, element);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptNativeFloatArray::DirectGetItemAtFull(index, element);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // We need to do explicit check for items since length value may not actually match the actual TypedArray length.\n        // User could add a length property to a TypedArray instance which lies and returns a different value from the underlying length.\n        // Since this method can be called via Array.prototype.indexOf with .apply or .call passing a TypedArray as this parameter\n        // we don't know whether or not length == typedArrayBase->GetLength().\n        if (checkHasItem && !typedArrayBase->HasItem(index))\n        {\n            return false;\n        }\n\n        *element = typedArrayBase->DirectGetItem(index);\n        return true;\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <bool includesAlgorithm, typename T, typename P>\n    Var JavascriptArray::TemplatedIndexOfHelper(T * pArr, Var search, P fromIndex, P toIndex, ScriptContext * scriptContext)\n    {\n        Var element = nullptr;\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        bool doUndefinedSearch = includesAlgorithm && JavascriptOperators::GetTypeId(search) == TypeIds_Undefined;\n\n        Var trueValue = scriptContext->GetLibrary()->GetTrue();\n        Var falseValue = scriptContext->GetLibrary()->GetFalse();\n\n        //Consider: enumerating instead of walking all indices\n        for (P i = fromIndex; i < toIndex; i++)\n        {\n            if (!TryTemplatedGetItem(pArr, i, &element, scriptContext, !includesAlgorithm))\n            {\n                if (doUndefinedSearch)\n                {\n                    return trueValue;\n                }\n                continue;\n            }\n\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (element == search)\n                {\n                    return includesAlgorithm? trueValue : JavascriptNumber::ToVar(i, scriptContext);\n                }\n                continue;\n            }\n\n            if (includesAlgorithm)\n            {\n                //Array.prototype.includes\n                if (JavascriptConversion::SameValueZero(element, search))\n                {\n                    return trueValue;\n                }\n            }\n            else\n            {\n                //Array.prototype.indexOf\n                if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n                {\n                    return JavascriptNumber::ToVar(i, scriptContext);\n                }\n            }\n        }\n\n        return includesAlgorithm ? falseValue :  TaggedInt::ToVarUnchecked(-1);\n    }\n\n    int32 JavascriptArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)\n    {\n        Assert(Is(GetTypeId()) && !JavascriptNativeArray::Is(GetTypeId()));\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        // We need to cast head segment to SparseArraySegment<Var> to have access to GetElement (onSparseArraySegment<T>). Because there are separate overloads of this\n        // virtual method on JavascriptNativeIntArray and JavascriptNativeFloatArray, we know this version of this method will only be called for true JavascriptArray, and not for\n        // either of the derived native arrays, so the elements of each segment used here must be Vars. Hence, the cast is safe.\n        SparseArraySegment<Var>* head = static_cast<SparseArraySegment<Var>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            Var element = head->GetElement(i);\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (search == element)\n                {\n                    return i;\n                }\n            }\n            else if (includesAlgorithm && JavascriptConversion::SameValueZero(element, search))\n            {\n                //Array.prototype.includes\n                return i;\n            }\n            else if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n            {\n                //Array.prototype.indexOf\n                return i;\n            }\n        }\n\n        // Element not found in the head segment. Keep looking only if the range of indices extends past\n        // the head segment.\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    template<typename T>\n    bool AreAllBytesEqual(T value)\n    {\n        byte* bValue = (byte*)&value;\n        byte firstByte = *bValue++;\n        for (int i = 1; i < sizeof(T); ++i)\n        {\n            if (*bValue++ != firstByte)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(double* buffer, uint32 length, double value)\n    {\n        if (JavascriptNumber::IsZero(value) && !JavascriptNumber::IsNegZero(value))\n        {\n            memset(buffer, 0, sizeof(double) * length);\n        }\n        else\n        {\n            for (uint32 i = 0; i < length; i++)\n            {\n                buffer[i] = value;\n            }\n        }\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(int32* buffer, uint32 length, int32 value)\n    {\n        if (value == 0 || AreAllBytesEqual(value))\n        {\n            memset(buffer, *(byte*)&value, sizeof(int32)* length);\n        }\n        else\n        {\n            for (uint32 i = 0; i < length; i++)\n            {\n                buffer[i] = value;\n            }\n        }\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(Js::Var* buffer, uint32 length, Js::Var value)\n    {\n        for (uint32 i = 0; i < length; i++)\n        {\n            buffer[i] = value;\n        }\n    }\n\n    int32 JavascriptNativeIntArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm,  ScriptContext * scriptContext)\n    {\n        // We proceed largely in the same manner as in JavascriptArray's version of this method (see comments there for more information),\n        // except when we can further optimize thanks to the knowledge that all elements in the array are int32's. This allows for two additional optimizations:\n        // 1. Only tagged ints or JavascriptNumbers that can be represented as int32 can be strict equal to some element in the array (all int32). Thus, if\n        // the search value is some other kind of Var, we can return -1 without ever iterating over the elements.\n        // 2. If the search value is a number that can be represented as int32, then we inspect the elements, but we don't need to perform the full strict equality algorithm.\n        // Instead we can use simple C++ equality (which in case of such values is equivalent to strict equality in JavaScript).\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n        int32 searchAsInt32;\n        if (isSearchTaggedInt)\n        {\n            searchAsInt32 = TaggedInt::ToInt32(search);\n        }\n        else if (!JavascriptNumber::TryGetInt32Value<true>(JavascriptNumber::GetValue(search), &searchAsInt32))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n\n        // We need to cast head segment to SparseArraySegment<int32> to have access to GetElement (onSparseArraySegment<T>). Because there are separate overloads of this\n        // virtual method on JavascriptNativeIntArray and JavascriptNativeFloatArray, we know this version of this method will only be called for true JavascriptNativeIntArray, and not for\n        // the other two, so the elements of each segment used here must be int32's. Hence, the cast is safe.\n\n        SparseArraySegment<int32> * head = static_cast<SparseArraySegment<int32>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            int32 element = head->GetElement(i);\n            if (searchAsInt32 == element)\n            {\n                return i;\n            }\n        }\n\n        // Element not found in the head segment. Keep looking only if the range of indices extends past\n        // the head segment.\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    int32 JavascriptNativeFloatArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)\n    {\n        // We proceed largely in the same manner as in JavascriptArray's version of this method (see comments there for more information),\n        // except when we can further optimize thanks to the knowledge that all elements in the array are doubles. This allows for two additional optimizations:\n        // 1. Only tagged ints or JavascriptNumbers can be strict equal to some element in the array (all doubles). Thus, if\n        // the search value is some other kind of Var, we can return -1 without ever iterating over the elements.\n        // 2. If the search value is a number, then we inspect the elements, but we don't need to perform the full strict equality algorithm.\n        // Instead we can use simple C++ equality (which in case of such values is equivalent to strict equality in JavaScript).\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n\n        double searchAsDouble = isSearchTaggedInt ? TaggedInt::ToDouble(search) : JavascriptNumber::GetValue(search);\n\n        // We need to cast head segment to SparseArraySegment<double> to have access to GetElement (SparseArraySegment). We know the\n        // segment's elements are all Vars so the cast is safe. It would have been more convenient here if JavascriptArray\n        // used SparseArraySegment<Var>, instead of SparseArraySegmentBase.\n\n\n        SparseArraySegment<double> * head = static_cast<SparseArraySegment<double>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n\n        bool matchNaN = includesAlgorithm && JavascriptNumber::IsNan(searchAsDouble);\n\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            double element = head->GetElement(i);\n\n            if (element == searchAsDouble)\n            {\n                return i;\n            }\n\n            //NaN != NaN we expect to match for NaN in Array.prototype.includes algorithm\n            if (matchNaN && JavascriptNumber::IsNan(element))\n            {\n                return i;\n            }\n\n        }\n\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    Var JavascriptArray::EntryJoin(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.join\"));\n        }\n\n        JavascriptString* separator;\n        if (args.Info.Count >= 2)\n        {\n            TypeId typeId = JavascriptOperators::GetTypeId(args[1]);\n            //ES5 15.4.4.5 If separator is undefined, let separator be the single-character String \",\".\n            if (TypeIds_Undefined != typeId)\n            {\n                separator = JavascriptConversion::ToString(args[1], scriptContext);\n            }\n            else\n            {\n                separator = scriptContext->GetLibrary()->GetCommaDisplayString();\n            }\n        }\n        else\n        {\n            separator = scriptContext->GetLibrary()->GetCommaDisplayString();\n        }\n\n        return JoinHelper(args[0], separator, scriptContext);\n    }\n\n    JavascriptString* JavascriptArray::JoinToString(Var value, ScriptContext* scriptContext)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(value);\n        if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n        else\n        {\n            return JavascriptConversion::ToString(value, scriptContext);\n        }\n    }\n\n    JavascriptString* JavascriptArray::JoinHelper(Var thisArg, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        bool isArray = JavascriptArray::Is(thisArg) && (scriptContext == JavascriptArray::FromVar(thisArg)->GetScriptContext());\n        bool isProxy = JavascriptProxy::Is(thisArg) && (scriptContext == JavascriptProxy::FromVar(thisArg)->GetScriptContext());\n        Var target = NULL;\n        bool isTargetObjectPushed = false;\n        // if we are visiting a proxy object, track that we have visited the target object as well so the next time w\n        // call the join helper for the target of this proxy, we will return above.\n        if (isProxy)\n        {\n            JavascriptProxy* proxy = JavascriptProxy::FromVar(thisArg);\n            Assert(proxy);\n            target = proxy->GetTarget();\n            if (target != nullptr)\n            {\n                // If we end up joining same array, instead of going in infinite loop, return the empty string\n                if (scriptContext->CheckObject(target))\n                {\n                    return scriptContext->GetLibrary()->GetEmptyString();\n                }\n                else\n                {\n                    scriptContext->PushObject(target);\n                    isTargetObjectPushed = true;\n                }\n            }\n        }\n        // If we end up joining same array, instead of going in infinite loop, return the empty string\n        else if (scriptContext->CheckObject(thisArg))\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        if (!isTargetObjectPushed)\n        {\n            scriptContext->PushObject(thisArg);\n        }\n\n        JavascriptString* res = nullptr;\n\n        TryFinally([&]()\n        {\n            if (isArray)\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray(thisArg);\n#endif\n                JavascriptArray * arr = JavascriptArray::FromVar(thisArg);\n                switch (arr->GetTypeId())\n                {\n                case Js::TypeIds_Array:\n                    res = JoinArrayHelper(arr, separator, scriptContext);\n                    break;\n                case Js::TypeIds_NativeIntArray:\n                    res = JoinArrayHelper(JavascriptNativeIntArray::FromVar(arr), separator, scriptContext);\n                    break;\n                case Js::TypeIds_NativeFloatArray:\n                    res = JoinArrayHelper(JavascriptNativeFloatArray::FromVar(arr), separator, scriptContext);\n                    break;\n                }\n\n            }\n            else if (RecyclableObject::Is(thisArg))\n            {\n                res = JoinOtherHelper(RecyclableObject::FromVar(thisArg), separator, scriptContext);\n            }\n            else\n            {\n                res = JoinOtherHelper(scriptContext->GetLibrary()->CreateNumberObject(thisArg), separator, scriptContext);\n            }\n        },\n        [&](bool/*hasException*/)\n        {\n            Var top = scriptContext->PopObject();\n            if (isProxy)\n            {\n                AssertMsg(top == target, \"Unmatched operation stack\");\n            }\n            else\n            {\n                AssertMsg(top == thisArg, \"Unmatched operation stack\");\n            }\n        });\n\n        if (res == nullptr)\n        {\n            res = scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        return res;\n    }\n\n    static const charcount_t Join_MaxEstimatedAppendCount = static_cast<charcount_t>((64 << 20) / sizeof(void *)); // 64 MB worth of pointers\n\n    template <typename T>\n    JavascriptString* JavascriptArray::JoinArrayHelper(T * arr, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        Assert(VirtualTableInfo<T>::HasVirtualTable(arr) || VirtualTableInfo<CrossSiteObject<T>>::HasVirtualTable(arr));\n        const uint32 arrLength = arr->length;\n        switch(arrLength)\n        {\n            default:\n            {\nCaseDefault:\n                bool hasSeparator = (separator->GetLength() != 0);\n                const charcount_t estimatedAppendCount =\n                    min(\n                        Join_MaxEstimatedAppendCount,\n                        static_cast<charcount_t>(arrLength + (hasSeparator ? arrLength - 1 : 0)));\n                CompoundString *const cs =\n                    CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());\n                Var item;\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    cs->Append(JavascriptArray::JoinToString(item, scriptContext));\n                }\n                for (uint32 i = 1; i < arrLength; i++)\n                {\n                    if (hasSeparator)\n                    {\n                        cs->Append(separator);\n                    }\n\n                    if (TryTemplatedGetItem(arr, i, &item, scriptContext))\n                    {\n                        cs->Append(JavascriptArray::JoinToString(item, scriptContext));\n                    }\n                }\n                return cs;\n            }\n\n            case 2:\n            {\n                bool hasSeparator = (separator->GetLength() != 0);\n                if(hasSeparator)\n                {\n                    goto CaseDefault;\n                }\n\n                JavascriptString *res = nullptr;\n                Var item;\n\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    res = JavascriptArray::JoinToString(item, scriptContext);\n                }\n\n                if (TryTemplatedGetItem(arr, 1u, &item, scriptContext))\n                {\n                    JavascriptString *const itemString = JavascriptArray::JoinToString(item, scriptContext);\n                    return res ? ConcatString::New(res, itemString) : itemString;\n                }\n\n                if(res)\n                {\n                    return res;\n                }\n\n                goto Case0;\n            }\n\n            case 1:\n            {\n                Var item;\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    return JavascriptArray::JoinToString(item, scriptContext);\n                }\n                // fall through\n            }\n\n            case 0:\nCase0:\n                return scriptContext->GetLibrary()->GetEmptyString();\n        }\n    }\n\n    JavascriptString* JavascriptArray::JoinOtherHelper(RecyclableObject* object, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n        // Even for arrays, this is now observable via proxies.\n        // If source object is not an array, we fall back to this behavior anyway.\n        Var lenValue = JavascriptOperators::OP_GetLength(object, scriptContext);\n        int64 cSrcLength = JavascriptConversion::ToLength(lenValue, scriptContext);\n\n        switch (cSrcLength)\n        {\n            default:\n            {\nCaseDefault:\n                bool hasSeparator = (separator->GetLength() != 0);\n                const charcount_t estimatedAppendCount =\n                    min(\n                        Join_MaxEstimatedAppendCount,\n                        static_cast<charcount_t>(cSrcLength + (hasSeparator ? cSrcLength - 1 : 0)));\n                CompoundString *const cs =\n                    CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    cs->Append(JavascriptArray::JoinToString(value, scriptContext));\n                }\n                for (uint32 i = 1; i < cSrcLength; i++)\n                {\n                    if (hasSeparator)\n                    {\n                        cs->Append(separator);\n                    }\n                    if (JavascriptOperators::GetItem(object, i, &value, scriptContext))\n                    {\n                        cs->Append(JavascriptArray::JoinToString(value, scriptContext));\n                    }\n                }\n                return cs;\n            }\n\n            case 2:\n            {\n                bool hasSeparator = (separator->GetLength() != 0);\n                if(hasSeparator)\n                {\n                    goto CaseDefault;\n                }\n\n                JavascriptString *res = nullptr;\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    res = JavascriptArray::JoinToString(value, scriptContext);\n                }\n                if (JavascriptOperators::GetItem(object, 1u, &value, scriptContext))\n                {\n                    JavascriptString *const valueString = JavascriptArray::JoinToString(value, scriptContext);\n                    return res ? ConcatString::New(res, valueString) : valueString;\n                }\n                if(res)\n                {\n                    return res;\n                }\n                goto Case0;\n            }\n\n            case 1:\n            {\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    return JavascriptArray::JoinToString(value, scriptContext);\n                }\n                // fall through\n            }\n\n            case 0:\nCase0:\n                return scriptContext->GetLibrary()->GetEmptyString();\n        }\n    }\n\n    Var JavascriptArray::EntryLastIndexOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_lastIndexOf);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.lastIndexOf\"));\n            }\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        Var search;\n        int64 fromIndex;\n        if (!GetParamForLastIndexOf(length, args, search, fromIndex, scriptContext))\n        {\n            return TaggedInt::ToVarUnchecked(-1);\n        }\n\n        if (pArr)\n        {\n            switch (pArr->GetTypeId())\n            {\n            case Js::TypeIds_Array:\n                return LastIndexOfHelper(pArr, search, fromIndex, scriptContext);\n            case Js::TypeIds_NativeIntArray:\n                return LastIndexOfHelper(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, scriptContext);\n            case Js::TypeIds_NativeFloatArray:\n                return LastIndexOfHelper(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, scriptContext);\n            default:\n                AssertMsg(FALSE, \"invalid array typeid\");\n                return LastIndexOfHelper(pArr, search, fromIndex, scriptContext);\n            }\n        }\n\n        // source object is not a JavascriptArray but source could be a TypedArray\n        if (TypedArrayBase::Is(obj))\n        {\n            return LastIndexOfHelper(TypedArrayBase::FromVar(obj), search, fromIndex, scriptContext);\n        }\n\n        return LastIndexOfHelper(obj, search, fromIndex, scriptContext);\n    }\n\n    // Array.prototype.lastIndexOf as described in ES6.0 (draft 22) Section 22.1.3.14\n    BOOL JavascriptArray::GetParamForLastIndexOf(int64 length, Arguments const & args, Var& search, int64& fromIndex, ScriptContext * scriptContext)\n    {\n        if (length == 0)\n        {\n            return false;\n        }\n\n        if (args.Info.Count > 2)\n        {\n            fromIndex = GetFromLastIndex(args[2], length, scriptContext);\n\n            if (fromIndex >= length)\n            {\n                return false;\n            }\n            search = args[1];\n        }\n        else\n        {\n            search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();\n            fromIndex = length - 1;\n        }\n        return true;\n    }\n\n    template <typename T>\n    Var JavascriptArray::LastIndexOfHelper(T* pArr, Var search, int64 fromIndex, ScriptContext * scriptContext)\n    {\n        Var element = nullptr;\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n\n        // First handle the indices > 2^32\n        while (fromIndex >= MaxArrayLength)\n        {\n            Var index = JavascriptNumber::ToVar(fromIndex, scriptContext);\n\n            if (JavascriptOperators::OP_HasItem(pArr, index, scriptContext))\n            {\n                element = JavascriptOperators::OP_GetElementI(pArr, index, scriptContext);\n\n                if (isSearchTaggedInt && TaggedInt::Is(element))\n                {\n                    if (element == search)\n                    {\n                        return index;\n                    }\n                    fromIndex--;\n                    continue;\n                }\n\n                if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n                {\n                    return index;\n                }\n            }\n\n            fromIndex--;\n        }\n\n        Assert(fromIndex < MaxArrayLength);\n\n        // fromIndex now has to be < MaxArrayLength so casting to uint32 is safe\n        uint32 end = static_cast<uint32>(fromIndex);\n\n        for (uint32 i = 0; i <= end; i++)\n        {\n            uint32 index = end - i;\n\n            if (!TryTemplatedGetItem(pArr, index, &element, scriptContext))\n            {\n                continue;\n            }\n\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (element == search)\n                {\n                    return JavascriptNumber::ToVar(index, scriptContext);\n                }\n                continue;\n            }\n\n            if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n            {\n                return JavascriptNumber::ToVar(index, scriptContext);\n            }\n        }\n\n        return TaggedInt::ToVarUnchecked(-1);\n    }\n\n    /*\n    *   PopWithNoDst\n    *   - For pop calls that do not return a value, we only need to decrement the length of the array.\n    */\n    void JavascriptNativeArray::PopWithNoDst(Var nativeArray)\n    {\n        Assert(JavascriptNativeArray::Is(nativeArray));\n        JavascriptArray * arr = JavascriptArray::FromVar(nativeArray);\n\n        // we will bailout on length 0\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->GetLength() - 1;\n        arr->SetLength(index);\n    }\n\n    /*\n    *   JavascriptNativeIntArray::Pop\n    *   -   Returns int32 value from the array.\n    *   -   Returns missing item when the element is not available in the array object.\n    *   -   It doesn't walk up the prototype chain.\n    *   -   Length is decremented only if it pops an int32 element, in all other cases - we bail out from the jitted code.\n    *   -   This api cannot cause any implicit call and hence do not need implicit call bailout test around this api\n    */\n    int32 JavascriptNativeIntArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        Assert(JavascriptNativeIntArray::Is(object));\n        JavascriptNativeIntArray * arr = JavascriptNativeIntArray::FromVar(object);\n\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->length - 1;\n\n        int32 element = Js::JavascriptOperators::OP_GetNativeIntElementI_UInt32(object, index, scriptContext);\n\n        //If it is a missing item, then don't update the length - Pre-op Bail out will happen.\n        if(!SparseArraySegment<int32>::IsMissingItem(&element))\n        {\n            arr->SetLength(index);\n        }\n        return element;\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::Pop\n    *   -   Returns double value from the array.\n    *   -   Returns missing item when the element is not available in the array object.\n    *   -   It doesn't walk up the prototype chain.\n    *   -   Length is decremented only if it pops a double element, in all other cases - we bail out from the jitted code.\n    *   -   This api cannot cause any implicit call and hence do not need implicit call bailout test around this api\n    */\n    double JavascriptNativeFloatArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        Assert(JavascriptNativeFloatArray::Is(object));\n        JavascriptNativeFloatArray * arr = JavascriptNativeFloatArray::FromVar(object);\n\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->length - 1;\n\n        double element = Js::JavascriptOperators::OP_GetNativeFloatElementI_UInt32(object, index, scriptContext);\n\n        // If it is a missing item then don't update the length - Pre-op Bail out will happen.\n        if(!SparseArraySegment<double>::IsMissingItem(&element))\n        {\n            arr->SetLength(index);\n        }\n        return element;\n    }\n\n    /*\n    *   JavascriptArray::Pop\n    *   -   Calls the generic Pop API, which can find elements from the prototype chain, when it is not available in the array object.\n    *   -   This API may cause implicit calls. Handles Array and non-array objects\n    */\n    Var JavascriptArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        if (JavascriptArray::Is(object))\n        {\n            return EntryPopJavascriptArray(scriptContext, object);\n        }\n        else\n        {\n            return EntryPopNonJavascriptArray(scriptContext, object);\n        }\n    }\n\n    Var JavascriptArray::EntryPopJavascriptArray(ScriptContext * scriptContext, Var object)\n    {\n        JavascriptArray * arr = JavascriptArray::FromVar(object);\n        uint32 length = arr->length;\n\n        if (length == 0)\n        {\n            // If length is 0, return 'undefined'\n            return scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        uint32 index = length - 1;\n        Var element;\n\n        if (!arr->DirectGetItemAtFull(index, &element))\n        {\n            element = scriptContext->GetLibrary()->GetUndefined();\n        }\n        else\n        {\n            element = CrossSite::MarshalVar(scriptContext, element);\n        }\n        arr->SetLength(index); // SetLength will clear element at index\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n        return element;\n    }\n\n    Var JavascriptArray::EntryPopNonJavascriptArray(ScriptContext * scriptContext, Var object)\n    {\n        RecyclableObject* dynamicObject = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(object, scriptContext, &dynamicObject))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));\n        }\n        BigIndex length;\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.pop\"));\n        if (length == 0u)\n        {\n            // Set length = 0\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            return scriptContext->GetLibrary()->GetUndefined();\n        }\n        BigIndex index = length;\n        --index;\n        Var element;\n        if (index.IsSmallIndex())\n        {\n            if (!JavascriptOperators::GetItem(dynamicObject, index.GetSmallIndex(), &element, scriptContext))\n            {\n                element = scriptContext->GetLibrary()->GetUndefined();\n            }\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n\n            // Set the new length\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        else\n        {\n            if (!JavascriptOperators::GetItem(dynamicObject, index.GetBigIndex(), &element, scriptContext))\n            {\n                element = scriptContext->GetLibrary()->GetUndefined();\n            }\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n\n            // Set the new length\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        return element;\n    }\n\n    Var JavascriptArray::EntryPop(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            return EntryPopJavascriptArray(scriptContext, args.Values[0]);\n        }\n        else\n        {\n            return EntryPopNonJavascriptArray(scriptContext, args.Values[0]);\n        }\n    }\n\n    /*\n    *   JavascriptNativeIntArray::Push\n    *   Pushes Int element in a native Int Array.\n    *   We call the generic Push, if the array is not native Int or we have a really big array.\n    */\n    Var JavascriptNativeIntArray::Push(ScriptContext * scriptContext, Var array, int value)\n    {\n        // Handle non crossSite native int arrays here length within MaxArrayLength.\n        // JavascriptArray::Push will handle other cases.\n        if (JavascriptNativeIntArray::IsNonCrossSite(array))\n        {\n            JavascriptNativeIntArray * nativeIntArray = JavascriptNativeIntArray::FromVar(array);\n            Assert(!nativeIntArray->IsCrossSiteObject());\n            uint32 n = nativeIntArray->length;\n\n            if(n < JavascriptArray::MaxArrayLength)\n            {\n                nativeIntArray->SetItem(n, value);\n\n                n++;\n\n                AssertMsg(n == nativeIntArray->length, \"Wrong update to the length of the native Int array\");\n\n                return JavascriptNumber::ToVar(n, scriptContext);\n            }\n        }\n        return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVar(value, scriptContext));\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::Push\n    *   Pushes Float element in a native Int Array.\n    *   We call the generic Push, if the array is not native Float or we have a really big array.\n    */\n    Var JavascriptNativeFloatArray::Push(ScriptContext * scriptContext, Var * array, double value)\n    {\n        // Handle non crossSite native int arrays here length within MaxArrayLength.\n        // JavascriptArray::Push will handle other cases.\n        if(JavascriptNativeFloatArray::IsNonCrossSite(array))\n        {\n            JavascriptNativeFloatArray * nativeFloatArray = JavascriptNativeFloatArray::FromVar(array);\n            Assert(!nativeFloatArray->IsCrossSiteObject());\n            uint32 n = nativeFloatArray->length;\n\n            if(n < JavascriptArray::MaxArrayLength)\n            {\n                nativeFloatArray->SetItem(n, value);\n\n                n++;\n\n                AssertMsg(n == nativeFloatArray->length, \"Wrong update to the length of the native Float array\");\n                return JavascriptNumber::ToVar(n, scriptContext);\n            }\n        }\n\n        return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVarNoCheck(value, scriptContext));\n    }\n\n    /*\n    *   JavascriptArray::Push\n    *   Pushes Var element in a Var Array.\n    */\n    Var JavascriptArray::Push(ScriptContext * scriptContext, Var object, Var value)\n    {\n        Var args[2];\n        args[0] = object;\n        args[1] = value;\n\n        if (JavascriptArray::Is(object))\n        {\n            return EntryPushJavascriptArray(scriptContext, args, 2);\n        }\n        else\n        {\n            return EntryPushNonJavascriptArray(scriptContext, args, 2);\n        }\n\n    }\n\n    /*\n    *   EntryPushNonJavascriptArray\n    *   - Handles Entry push calls, when Objects are not javascript arrays\n    */\n    Var JavascriptArray::EntryPushNonJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n            RecyclableObject* obj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));\n            }\n\n            Var length = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            if(JavascriptOperators::GetTypeId(length) == TypeIds_Undefined && scriptContext->GetThreadContext()->IsDisableImplicitCall() &&\n                scriptContext->GetThreadContext()->GetImplicitCallFlags() != Js::ImplicitCall_None)\n            {\n                return length;\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n            BigIndex n;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                n = (uint64) JavascriptConversion::ToLength(length, scriptContext);\n            }\n            else\n            {\n                n = JavascriptConversion::ToUInt32(length, scriptContext);\n            }\n            // First handle \"small\" indices.\n            uint index;\n            for (index=1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)\n            {\n                if (h.IsThrowTypeError(JavascriptOperators::SetItem(obj, obj, n.GetSmallIndex(), args[index], scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if (scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n            }\n\n            // Use BigIndex if we need to push indices >= MaxArrayLength\n            if (index < argCount)\n            {\n                BigIndex big = n;\n\n                for (; index < argCount; ++index, ++big)\n                {\n                    if (h.IsThrowTypeError(big.SetItem(obj, args[index], PropertyOperation_ThrowIfNotExtensible)))\n                    {\n                        if(scriptContext->GetThreadContext()->RecordImplicitException())\n                        {\n                            h.ThrowTypeErrorOnFailure();\n                        }\n                        else\n                        {\n                            return nullptr;\n                        }\n                    }\n\n                }\n\n                // Set the new length; for objects it is all right for this to be >= MaxArrayLength\n                if (h.IsThrowTypeError(JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, big.ToNumber(scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if(scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n\n                return big.ToNumber(scriptContext);\n            }\n            else\n            {\n                // Set the new length\n                Var lengthAsNUmberVar = JavascriptNumber::ToVar(n.IsSmallIndex() ? n.GetSmallIndex() : n.GetBigIndex(), scriptContext);\n                if (h.IsThrowTypeError(JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, lengthAsNUmberVar, scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if(scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n\n                return lengthAsNUmberVar;\n            }\n    }\n\n    /*\n    *   JavascriptArray::EntryPushJavascriptArray\n    *   Pushes Var element in a Var Array.\n    *   Returns the length of the array.\n    */\n    Var JavascriptArray::EntryPushJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n        JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);\n        uint n = arr->length;\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n\n        // Fast Path for one push for small indexes\n        if (argCount == 2 && n < JavascriptArray::MaxArrayLength)\n        {\n            // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n            h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[1], PropertyOperation_None));\n            return JavascriptNumber::ToVar(n + 1, scriptContext);\n        }\n\n        // Fast Path for multiple push for small indexes\n        if (JavascriptArray::MaxArrayLength - argCount + 1 > n && JavascriptArray::IsVarArray(arr) && scriptContext == arr->GetScriptContext())\n        {\n            uint index;\n            for (index = 1; index < argCount; ++index, ++n)\n            {\n                Assert(n != JavascriptArray::MaxArrayLength);\n                // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n                arr->JavascriptArray::DirectSetItemAt(n, args[index]);\n            }\n            return JavascriptNumber::ToVar(n, scriptContext);\n        }\n\n        return EntryPushJavascriptArrayNoFastPath(scriptContext, args, argCount);\n    }\n\n    Var JavascriptArray::EntryPushJavascriptArrayNoFastPath(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n        JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);\n        uint n = arr->length;\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n\n        // First handle \"small\" indices.\n        uint index;\n        for (index = 1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)\n        {\n            // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n            h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[index], PropertyOperation_None));\n        }\n\n        // Use BigIndex if we need to push indices >= MaxArrayLength\n        if (index < argCount)\n        {\n            // Not supporting native array with BigIndex.\n            arr = EnsureNonNativeArray(arr);\n            Assert(n == JavascriptArray::MaxArrayLength);\n            for (BigIndex big = n; index < argCount; ++index, ++big)\n            {\n                h.ThrowTypeErrorOnFailure(big.SetItem(arr, args[index]));\n            }\n\n#ifdef VALIDATE_ARRAY\n            arr->ValidateArray();\n#endif\n            // This is where we should set the length, but for arrays it cannot be >= MaxArrayLength\n            JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n        }\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n        return JavascriptNumber::ToVar(n, scriptContext);\n    }\n\n    /*\n    *   JavascriptArray::EntryPush\n    *   Handles Push calls(Script Function)\n    */\n    Var JavascriptArray::EntryPush(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            return EntryPushJavascriptArray(scriptContext, args.Values, args.Info.Count);\n        }\n        else\n        {\n            return EntryPushNonJavascriptArray(scriptContext, args.Values, args.Info.Count);\n        }\n    }\n\n\n    Var JavascriptArray::EntryReverse(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));\n        }\n\n        BigIndex length = 0u;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext);\n    }\n\n    // Array.prototype.reverse as described in ES6.0 (draft 22) Section 22.1.3.20\n    template <typename T>\n    Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)\n    {\n        T middle = length / 2;\n        Var lowerValue = nullptr, upperValue = nullptr;\n        T lowerExists, upperExists;\n        const char16* methodName;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n\n        if (isTypedArrayEntryPoint)\n        {\n            methodName = _u(\"[TypedArray].prototype.reverse\");\n        }\n        else\n        {\n            methodName = _u(\"Array.prototype.reverse\");\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, methodName);\n\n        if (pArr)\n        {\n            Recycler * recycler = scriptContext->GetRecycler();\n\n            if (length <= 1)\n            {\n                return pArr;\n            }\n\n            if (pArr->IsFillFromPrototypes())\n            {\n                // For odd-length arrays, the middle element is unchanged,\n                // so we cannot fill it from the prototypes.\n                if (length % 2 == 0)\n                {\n                    pArr->FillFromPrototypes(0, (uint32)length);\n                }\n                else\n                {\n                    middle = length / 2;\n                    pArr->FillFromPrototypes(0, (uint32)middle);\n                    pArr->FillFromPrototypes(1 + (uint32)middle, (uint32)length);\n                }\n            }\n\n            if (pArr->HasNoMissingValues() && pArr->head && pArr->head->next)\n            {\n                // This function currently does not track missing values in the head segment if there are multiple segments\n                pArr->SetHasNoMissingValues(false);\n            }\n\n            // Above FillFromPrototypes call can change the length of the array. Our segment calculation below will\n            // not work with the stale length. Update the length.\n            // Note : since we are reversing the whole segment below - the functionality is not spec compliant already.\n            length = pArr->length;\n\n            SparseArraySegmentBase* seg = pArr->head;\n            SparseArraySegmentBase *prevSeg = nullptr;\n            SparseArraySegmentBase *nextSeg = nullptr;\n            SparseArraySegmentBase *pinPrevSeg = nullptr;\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n\n            if (JavascriptNativeIntArray::Is(pArr))\n            {\n                isIntArray = true;\n            }\n            else if (JavascriptNativeFloatArray::Is(pArr))\n            {\n                isFloatArray = true;\n            }\n\n            while (seg)\n            {\n                nextSeg = seg->next;\n\n                // If seg.length == 0, it is possible that (seg.left + seg.length == prev.left + prev.length),\n                // resulting in 2 segments sharing the same \"left\".\n                if (seg->length > 0)\n                {\n                    if (isIntArray)\n                    {\n                        ((SparseArraySegment<int32>*)seg)->ReverseSegment(recycler);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ((SparseArraySegment<double>*)seg)->ReverseSegment(recycler);\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<Var>*)seg)->ReverseSegment(recycler);\n                    }\n\n                    seg->left = ((uint32)length) > (seg->left + seg->length) ? ((uint32)length) - (seg->left + seg->length) : 0;\n\n                    seg->next = prevSeg;\n                    // Make sure size doesn't overlap with next segment.\n                    // An easy fix is to just truncate the size...\n                    seg->EnsureSizeInBound();\n\n                    // If the last segment is a leaf, then we may be losing our last scanned pointer to its previous\n                    // segment. Hold onto it with pinPrevSeg until we reallocate below.\n                    pinPrevSeg = prevSeg;\n                    prevSeg = seg;\n                }\n\n                seg = nextSeg;\n            }\n\n            pArr->head = prevSeg;\n\n            // Just dump the segment map on reverse\n            pArr->ClearSegmentMap();\n\n            if (isIntArray)\n            {\n                if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))\n                {\n                    pArr->ReallocNonLeafSegment((SparseArraySegment<int32>*)pArr->head, pArr->head->next);\n                }\n                pArr->EnsureHeadStartsFromZero<int32>(recycler);\n            }\n            else if (isFloatArray)\n            {\n                if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))\n                {\n                    pArr->ReallocNonLeafSegment((SparseArraySegment<double>*)pArr->head, pArr->head->next);\n                }\n                pArr->EnsureHeadStartsFromZero<double>(recycler);\n            }\n            else\n            {\n                pArr->EnsureHeadStartsFromZero<Var>(recycler);\n            }\n\n            pArr->InvalidateLastUsedSegment(); // lastUsedSegment might be 0-length and discarded above\n\n#ifdef VALIDATE_ARRAY\n            pArr->ValidateArray();\n#endif\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= JavascriptArray::MaxArrayLength);\n            if (typedArrayBase->GetLength() == length)\n            {\n                // If typedArrayBase->length == length then we know that the TypedArray will have all items < length\n                // and we won't have to check that the elements exist or not.\n                for (uint32 lower = 0; lower < (uint32)middle; lower++)\n                {\n                    uint32 upper = (uint32)length - lower - 1;\n\n                    lowerValue = typedArrayBase->DirectGetItem(lower);\n                    upperValue = typedArrayBase->DirectGetItem(upper);\n\n                    // We still have to call HasItem even though we know the TypedArray has both lower and upper because\n                    // there may be a proxy handler trapping HasProperty.\n                    lowerExists = typedArrayBase->HasItem(lower);\n                    upperExists = typedArrayBase->HasItem(upper);\n\n                    h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                    h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                }\n            }\n            else\n            {\n                for (uint32 lower = 0; lower < middle; lower++)\n                {\n                    uint32 upper = (uint32)length - lower - 1;\n\n                    lowerValue = typedArrayBase->DirectGetItem(lower);\n                    upperValue = typedArrayBase->DirectGetItem(upper);\n\n                    lowerExists = typedArrayBase->HasItem(lower);\n                    upperExists = typedArrayBase->HasItem(upper);\n\n                    if (lowerExists)\n                    {\n                        if (upperExists)\n                        {\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                        }\n                        else\n                        {\n                            // This will always fail for a TypedArray if lower < length\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(lower, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                        }\n                    }\n                    else\n                    {\n                        if (upperExists)\n                        {\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                            // This will always fail for a TypedArray if upper < length\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(upper, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (T lower = 0; lower < middle; lower++)\n            {\n                T upper = length - lower - 1;\n\n                lowerExists = JavascriptOperators::HasItem(obj, lower) &&\n                              JavascriptOperators::GetItem(obj, lower, &lowerValue, scriptContext);\n\n                upperExists = JavascriptOperators::HasItem(obj, upper) &&\n                              JavascriptOperators::GetItem(obj, upper, &upperValue, scriptContext);\n\n                if (lowerExists)\n                {\n                    if (upperExists)\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                    else\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, lower, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                }\n                else\n                {\n                    if (upperExists)\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, upper, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                    }\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    template<typename T>\n    void JavascriptArray::ShiftHelper(JavascriptArray* pArr, ScriptContext * scriptContext)\n    {\n        Recycler * recycler = scriptContext->GetRecycler();\n\n        SparseArraySegment<T>* next = (SparseArraySegment<T>*)pArr->head->next;\n        while (next)\n        {\n            next->left--;\n            next = (SparseArraySegment<T>*)next->next;\n        }\n\n        // head and next might overlap as the next segment left is decremented\n        next = (SparseArraySegment<T>*)pArr->head->next;\n        if (next && (pArr->head->size > next->left))\n        {\n            AssertMsg(pArr->head->left == 0, \"Array always points to a head starting at index 0\");\n            AssertMsg(pArr->head->size == next->left + 1, \"Shift next->left overlaps current segment by more than 1 element\");\n\n            SparseArraySegment<T> *head = (SparseArraySegment<T>*)pArr->head;\n            // Merge the two adjacent segments\n            if (next->length != 0)\n            {\n                uint32 offset = head->size - 1;\n                // There is room for one unshifted element in head segment.\n                // Hence it's enough if we grow the head segment by next->length - 1\n\n                if (next->next)\n                {\n                    // If we have a next->next, we can't grow pass the left of that\n\n                    // If the array had a segment map before, the next->next might just be right after next as well.\n                    // So we just need to grow to the end of the next segment\n                    // TODO: merge that segment too?\n                    Assert(next->next->left >= head->size);\n                    uint32 maxGrowSize = next->next->left - head->size;\n                    if (maxGrowSize != 0)\n                    {\n                        head = head->GrowByMinMax(recycler, next->length - 1, maxGrowSize); //-1 is to account for unshift\n                    }\n                    else\n                    {\n                        // The next segment is only of length one, so we already have space in the header to copy that\n                        Assert(next->length == 1);\n                    }\n                }\n                else\n                {\n                    head = head->GrowByMin(recycler, next->length - 1); //-1 is to account for unshift\n                }\n                memmove(head->elements + offset, next->elements, next->length * sizeof(T));\n                head->length = offset + next->length;\n                pArr->head = head;\n            }\n            head->next = next->next;\n            pArr->InvalidateLastUsedSegment();\n        }\n\n#ifdef VALIDATE_ARRAY\n            pArr->ValidateArray();\n#endif\n    }\n\n    Var JavascriptArray::EntryShift(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n            return res;\n        }\n        if (JavascriptArray::Is(args[0]))\n        {\n            JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n\n            if (pArr->length == 0)\n            {\n                return res;\n            }\n\n            if(pArr->IsFillFromPrototypes())\n            {\n                pArr->FillFromPrototypes(0, pArr->length); // We need find all missing value from [[proto]] object\n            }\n\n            if(pArr->HasNoMissingValues() && pArr->head && pArr->head->next)\n            {\n                // This function currently does not track missing values in the head segment if there are multiple segments\n                pArr->SetHasNoMissingValues(false);\n            }\n\n            pArr->length--;\n\n            pArr->ClearSegmentMap(); // Dump segmentMap on shift (before any allocation)\n\n            Recycler * recycler = scriptContext->GetRecycler();\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n\n            if(JavascriptNativeIntArray::Is(pArr))\n            {\n                isIntArray = true;\n            }\n            else if(JavascriptNativeFloatArray::Is(pArr))\n            {\n                isFloatArray = true;\n            }\n\n            if (pArr->head->length != 0)\n            {\n                if(isIntArray)\n                {\n                    int32 nativeResult = ((SparseArraySegment<int32>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<int32>::IsMissingItem(&nativeResult))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = Js::JavascriptNumber::ToVar(nativeResult, scriptContext);\n                    }\n                    ((SparseArraySegment<int32>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n                else if (isFloatArray)\n                {\n                    double nativeResult = ((SparseArraySegment<double>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<double>::IsMissingItem(&nativeResult))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = Js::JavascriptNumber::ToVarNoCheck(nativeResult, scriptContext);\n                    }\n                    ((SparseArraySegment<double>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n                else\n                {\n                    res = ((SparseArraySegment<Var>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<Var>::IsMissingItem(&res))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = CrossSite::MarshalVar(scriptContext, res);\n                    }\n                    ((SparseArraySegment<Var>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n            }\n\n            if(isIntArray)\n            {\n                ShiftHelper<int32>(pArr, scriptContext);\n            }\n            else if (isFloatArray)\n            {\n                ShiftHelper<double>(pArr, scriptContext);\n            }\n            else\n            {\n                ShiftHelper<Var>(pArr, scriptContext);\n            }\n        }\n        else\n        {\n            RecyclableObject* dynamicObject = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.shift\"));\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.shift\"));\n\n            BigIndex length = 0u;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n\n            if (length == 0u)\n            {\n                // If length is 0, return 'undefined'\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                return scriptContext->GetLibrary()->GetUndefined();\n            }\n            if (!JavascriptOperators::GetItem(dynamicObject, 0u, &res, scriptContext))\n            {\n                res = scriptContext->GetLibrary()->GetUndefined();\n            }\n            --length;\n            uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;\n            for (uint32 i = 0u; i < lengthToUin32Max; i++)\n            {\n                if (JavascriptOperators::HasItem(dynamicObject, i + 1))\n                {\n                    Var element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible, /*skipPrototypeCheck*/ true));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n            }\n\n            for (uint64 i = MaxArrayLength; length > i; i++)\n            {\n                if (JavascriptOperators::HasItem(dynamicObject, i + 1))\n                {\n                    Var element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n            }\n\n            if (length.IsSmallIndex())\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            }\n            else\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            }\n        }\n        return res;\n    }\n\n    Js::JavascriptArray* JavascriptArray::CreateNewArrayHelper(uint32 len, bool isIntArray, bool isFloatArray,  Js::JavascriptArray* baseArray, ScriptContext* scriptContext)\n    {\n        if (isIntArray)\n        {\n            Js::JavascriptNativeIntArray *pnewArr = scriptContext->GetLibrary()->CreateNativeIntArray(len);\n            pnewArr->EnsureHead<int32>();\n#if ENABLE_PROFILE_INFO\n            pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeIntArray::FromVar(baseArray));\n#endif\n\n            return pnewArr;\n        }\n        else if (isFloatArray)\n        {\n            Js::JavascriptNativeFloatArray *pnewArr  = scriptContext->GetLibrary()->CreateNativeFloatArray(len);\n            pnewArr->EnsureHead<double>();\n#if ENABLE_PROFILE_INFO\n            pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeFloatArray::FromVar(baseArray));\n#endif\n\n            return pnewArr;\n        }\n        else\n        {\n            JavascriptArray *pnewArr = pnewArr = scriptContext->GetLibrary()->CreateArray(len);\n            pnewArr->EnsureHead<Var>();\n            return pnewArr;\n        }\n   }\n\n    template<typename T>\n    void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)pArr->head;\n        SparseArraySegment<T>* pnewHeadSeg = (SparseArraySegment<T>*)pnewArr->head;\n\n        // Fill the newly created sliced array\n        js_memcpy_s(pnewHeadSeg->elements, sizeof(T) * newLen, headSeg->elements + start, sizeof(T) * newLen);\n        pnewHeadSeg->length = newLen;\n\n        Assert(pnewHeadSeg->length <= pnewHeadSeg->size);\n        // Prototype lookup for missing elements\n        if (!pArr->HasNoMissingValues())\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                // array type might be changed in the below call to DirectGetItemAtFull\n                // need recheck array type before checking array item [i + start]\n                if (pArr->IsMissingItem(i + start))\n                {\n                    Var element;\n                    pnewArr->SetHasNoMissingValues(false);\n                    if (pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        pnewArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n        }\n#ifdef DBG\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }\n    // If the creating profile data has changed, convert it to the type of array indicated\n    // in the profile\n    void JavascriptArray::GetArrayTypeAndConvert(bool* isIntArray, bool* isFloatArray)\n    {\n        if (JavascriptNativeIntArray::Is(this))\n        {\n#if ENABLE_PROFILE_INFO\n            JavascriptNativeIntArray* nativeIntArray = JavascriptNativeIntArray::FromVar(this);\n            ArrayCallSiteInfo* info = nativeIntArray->GetArrayCallSiteInfo();\n            if(!info || info->IsNativeIntArray())\n            {\n                *isIntArray = true;\n            }\n            else if(info->IsNativeFloatArray())\n            {\n                JavascriptNativeIntArray::ToNativeFloatArray(nativeIntArray);\n                *isFloatArray = true;\n            }\n            else\n            {\n                JavascriptNativeIntArray::ToVarArray(nativeIntArray);\n            }\n#else\n            *isIntArray = true;\n#endif\n        }\n        else if (JavascriptNativeFloatArray::Is(this))\n        {\n#if ENABLE_PROFILE_INFO\n            JavascriptNativeFloatArray* nativeFloatArray = JavascriptNativeFloatArray::FromVar(this);\n            ArrayCallSiteInfo* info = nativeFloatArray->GetArrayCallSiteInfo();\n\n            if(info && !info->IsNativeArray())\n            {\n                JavascriptNativeFloatArray::ToVarArray(nativeFloatArray);\n            }\n            else\n            {\n                *isFloatArray = true;\n            }\n#else\n            *isFloatArray = true;\n#endif\n        }\n    }\n\n    Var JavascriptArray::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n            return res;\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.slice\"));\n            }\n        }\n\n        Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(lenValue, scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max());\n        return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.slice as described in ES6.0 (draft 22) Section 22.1.3.22\n    template <typename T>\n    Var JavascriptArray::SliceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        JavascriptArray* newArr = nullptr;\n        RecyclableObject* newObj = nullptr;\n        bool isIntArray = false;\n        bool isFloatArray = false;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n        bool isBuiltinArrayCtor = true;\n        T startT = 0;\n        T newLenT = length;\n        T endT = length;\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n        if (args.Info.Count > 1)\n        {\n            startT = GetFromIndex(args[1], length, scriptContext);\n\n            if (startT > length)\n            {\n                startT = length;\n            }\n\n            if (args.Info.Count > 2)\n            {\n                if (JavascriptOperators::GetTypeId(args[2]) == TypeIds_Undefined)\n                {\n                    endT = length;\n                }\n                else\n                {\n                    endT = GetFromIndex(args[2], length, scriptContext);\n\n                    if (endT > length)\n                    {\n                        endT = length;\n                    }\n                }\n            }\n\n            newLenT = endT > startT ? endT - startT : 0;\n        }\n\n        if (TypedArrayBase::IsDetachedTypedArray(obj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.slice\"));\n        }\n\n        // If we came from Array.prototype.slice and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // If the entry point is %TypedArray%.prototype.slice or the source object is an Array exotic object we should try to load the constructor property\n        // and use it to construct the return object.\n        if (isTypedArrayEntryPoint)\n        {\n            Var constructor = JavascriptOperators::SpeciesConstructor(typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext);\n            isBuiltinArrayCtor = (constructor == library->GetArrayConstructor());\n\n            // If we have an array source object, we need to make sure to do the right thing if it's a native array.\n            // The helpers below which do the element copying require the source and destination arrays to have the same native type.\n            if (pArr && isBuiltinArrayCtor)\n            {\n                if (newLenT > JavascriptArray::MaxArrayLength)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                // If the constructor function is the built-in Array constructor, we can be smart and create the right type of native array.\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n                newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);\n                newObj = newArr;\n            }\n            else if (JavascriptOperators::IsConstructor(constructor))\n            {\n                if (pArr)\n                {\n                    // If the constructor function is any other function, it can return anything so we have to call it.\n                    // Roll the source array into a non-native array if it was one.\n                    pArr = EnsureNonNativeArray(pArr);\n                }\n\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(newLenT, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)newLenT, scriptContext));\n            }\n            else\n            {\n                // We only need to throw a TypeError when the constructor property is not an actual constructor if %TypedArray%.prototype.slice was called\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidTypedArray_Constructor, _u(\"[TypedArray].prototype.slice\"));\n            }\n        }\n\n        else if (pArr != nullptr)\n        {\n            newObj = ArraySpeciesCreate(pArr, newLenT, scriptContext, &isIntArray, &isFloatArray, &isBuiltinArrayCtor);\n        }\n\n        // skip the typed array and \"pure\" array case, we still need to handle special arrays like es5array, remote array, and proxy of array.\n        else\n        {\n            newObj = ArraySpeciesCreate(obj, newLenT, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        }\n\n        // If we didn't create a new object above we will create a new array here.\n        // This is the pre-ES6 behavior or the case of calling Array.prototype.slice with a constructor argument that is not a constructor function.\n        if (newObj == nullptr)\n        {\n            if (pArr)\n            {\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n            }\n\n            if (newLenT > JavascriptArray::MaxArrayLength)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n\n            newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);\n#endif\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        uint32 start  = (uint32) startT;\n        uint32 newLen = (uint32) newLenT;\n\n        // We at least have to have newObj as a valid object\n        Assert(newObj);\n\n        // Bail out early if the new object will have zero length.\n        if (newLen == 0)\n        {\n            return newObj;\n        }\n\n        if (pArr)\n        {\n            // If we constructed a new Array object, we have some nice helpers here\n            if (newArr && isBuiltinArrayCtor)\n            {\n                if (JavascriptArray::IsDirectAccessArray(newArr))\n                {\n                    if (((start + newLen) <= pArr->head->length) && newLen <= newArr->head->size) //Fast Path\n                    {\n                        if (isIntArray)\n                        {\n                            SliceHelper<int32>(pArr, newArr, start, newLen);\n                        }\n                        else if (isFloatArray)\n                        {\n                            SliceHelper<double>(pArr, newArr, start, newLen);\n                        }\n                        else\n                        {\n                            SliceHelper<Var>(pArr, newArr, start, newLen);\n                        }\n                    }\n                    else\n                    {\n                        if (isIntArray)\n                        {\n                            CopyNativeIntArrayElements(JavascriptNativeIntArray::FromVar(newArr), 0, JavascriptNativeIntArray::FromVar(pArr), start, start + newLen);\n                        }\n                        else if (isFloatArray)\n                        {\n                            CopyNativeFloatArrayElements(JavascriptNativeFloatArray::FromVar(newArr), 0, JavascriptNativeFloatArray::FromVar(pArr), start, start + newLen);\n                        }\n                        else\n                        {\n                            CopyArrayElements(newArr, 0u, pArr, start, start + newLen);\n                        }\n                    }\n                }\n                else\n                {\n                    AssertMsg(CONFIG_FLAG(ForceES5Array), \"newArr can only be ES5Array when it is forced\");\n                    Var element;\n                    for (uint32 i = 0; i < newLen; i++)\n                    {\n                        if (!pArr->DirectGetItemAtFull(i + start, &element))\n                        {\n                            continue;\n                        }\n\n                        newArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n            else\n            {\n                // The constructed object isn't an array, we'll need to use normal object manipulation\n                Var element;\n\n                for (uint32 i = 0; i < newLen; i++)\n                {\n                    if (!pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        continue;\n                    }\n\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            // Source is a TypedArray, we must have created the return object via a call to constructor, but newObj may not be a TypedArray (or an array either)\n            TypedArrayBase* newTypedArray = nullptr;\n\n            if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n\n            Var element;\n\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                // We only need to call HasItem in the case that we are called from Array.prototype.slice\n                if (!isTypedArrayEntryPoint && !typedArrayBase->HasItem(i + start))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(i + start);\n\n                // The object we got back from the constructor might not be a TypedArray. In fact, it could be any object.\n                if (newTypedArray)\n                {\n                    newTypedArray->DirectSetItem(i, element);\n                }\n                else if (newArr)\n                {\n                    newArr->DirectSetItemAt(i, element);\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI_UInt32(newObj, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                if (JavascriptOperators::HasItem(obj, i + start))\n                {\n                    Var element = JavascriptOperators::GetItem(obj, i + start, scriptContext);\n                    if (newArr != nullptr)\n                    {\n                        newArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                    }\n                }\n            }\n        }\n\n        if (!isTypedArrayEntryPoint)\n        {\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (JavascriptArray::Is(newObj))\n        {\n            JavascriptArray::FromVar(newObj)->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    struct CompareVarsInfo\n    {\n        ScriptContext* scriptContext;\n        RecyclableObject* compFn;\n    };\n\n    int __cdecl compareVars(void* cvInfoV, const void* aRef, const void* bRef)\n    {\n        CompareVarsInfo* cvInfo=(CompareVarsInfo*)cvInfoV;\n        ScriptContext* requestContext=cvInfo->scriptContext;\n        RecyclableObject* compFn=cvInfo->compFn;\n\n        AssertMsg(*(Var*)aRef, \"No null expected in sort\");\n        AssertMsg(*(Var*)bRef, \"No null expected in sort\");\n\n        if (compFn != nullptr)\n        {\n            ScriptContext* scriptContext = compFn->GetScriptContext();\n            // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n            CallFlags flags = CallFlags_Value;\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            Var retVal;\n            if (requestContext != scriptContext)\n            {\n                Var leftVar = CrossSite::MarshalVar(scriptContext, *(Var*)aRef);\n                Var rightVar = CrossSite::MarshalVar(scriptContext, *(Var*)bRef);\n                retVal = CALL_FUNCTION(compFn, CallInfo(flags, 3), undefined, leftVar, rightVar);\n            }\n            else\n            {\n                retVal = CALL_FUNCTION(compFn, CallInfo(flags, 3), undefined, *(Var*)aRef, *(Var*)bRef);\n            }\n\n            if (TaggedInt::Is(retVal))\n            {\n                return TaggedInt::ToInt32(retVal);\n            }\n            double dblResult;\n            if (JavascriptNumber::Is_NoTaggedIntCheck(retVal))\n            {\n                dblResult = JavascriptNumber::GetValue(retVal);\n            }\n            else\n            {\n                dblResult = JavascriptConversion::ToNumber_Full(retVal, scriptContext);\n            }\n            if (dblResult < 0)\n            {\n                return -1;\n            }\n            return (dblResult > 0) ? 1 : 0;\n        }\n        else\n        {\n            JavascriptString* pStr1 = JavascriptConversion::ToString(*(Var*)aRef, requestContext);\n            JavascriptString* pStr2 = JavascriptConversion::ToString(*(Var*)bRef, requestContext);\n\n            return JavascriptString::strcmp(pStr1, pStr2);\n        }\n    }\n\n    static void hybridSort(__inout_ecount(length) Var *elements, uint32 length, CompareVarsInfo* compareInfo)\n    {\n        // The cost of memory moves starts to be more expensive than additional comparer calls (given a simple comparer)\n        // for arrays of more than 512 elements.\n        if (length > 512)\n        {\n            qsort_s(elements, length, sizeof(Var), compareVars, compareInfo);\n            return;\n        }\n\n        for (int i = 1; i < (int)length; i++)\n        {\n            if (compareVars(compareInfo, elements + i, elements + i - 1) < 0) {\n                // binary search for the left-most element greater than value:\n                int first = 0;\n                int last = i - 1;\n                while (first <= last)\n                {\n                    int middle = (first + last) / 2;\n                    if (compareVars(compareInfo, elements + i, elements + middle) < 0)\n                    {\n                        last = middle - 1;\n                    }\n                    else\n                    {\n                        first = middle + 1;\n                    }\n                }\n\n                // insert value right before first:\n                Var value = elements[i];\n                memmove(elements + first + 1, elements + first, (i - first) * sizeof(Var));\n                elements[first] = value;\n            }\n        }\n    }\n\n    void JavascriptArray::Sort(RecyclableObject* compFn)\n    {\n        if (length <= 1)\n        {\n            return;\n        }\n\n        this->EnsureHead<Var>();\n        ScriptContext* scriptContext = this->GetScriptContext();\n        Recycler* recycler = scriptContext->GetRecycler();\n\n        CompareVarsInfo cvInfo;\n        cvInfo.scriptContext = scriptContext;\n        cvInfo.compFn = compFn;\n\n        Assert(head != nullptr);\n\n        // Just dump the segment map on sort\n        ClearSegmentMap();\n\n        uint32 countUndefined = 0;\n        SparseArraySegment<Var>* startSeg = (SparseArraySegment<Var>*)head;\n\n        // Sort may have side effects on the array. Setting a dummy head so that original array is not affected\n        uint32 saveLength = length;\n        // that if compare function tries to modify the array it won't AV.\n        head = const_cast<SparseArraySegmentBase*>(EmptySegment);\n        SetFlags(DynamicObjectFlags::None);\n        this->InvalidateLastUsedSegment();\n        length = 0;\n\n        TryFinally([&]()\n        {\n            //The array is a continuous array if there is only one segment\n            if (startSeg->next == nullptr) // Single segment fast path\n            {\n                if (compFn != nullptr)\n                {\n                    countUndefined = startSeg->RemoveUndefined(scriptContext);\n\n#ifdef VALIDATE_ARRAY\n                    ValidateSegment(startSeg);\n#endif\n                    hybridSort(startSeg->elements, startSeg->length, &cvInfo);\n                }\n                else\n                {\n                    countUndefined = sort(startSeg->elements, &startSeg->length, scriptContext);\n                }\n                head = startSeg;\n            }\n            else\n            {\n                SparseArraySegment<Var>* allElements = SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, nullptr);\n                SparseArraySegment<Var>* next = startSeg;\n\n                uint32 nextIndex = 0;\n                // copy all the elements to single segment\n                while (next)\n                {\n                    countUndefined += next->RemoveUndefined(scriptContext);\n                    if (next->length != 0)\n                    {\n                        allElements = SparseArraySegment<Var>::CopySegment(recycler, allElements, nextIndex, next, next->left, next->length);\n                    }\n                    next = (SparseArraySegment<Var>*)next->next;\n                    nextIndex = allElements->length;\n\n#ifdef VALIDATE_ARRAY\n                    ValidateSegment(allElements);\n#endif\n                }\n\n                if (compFn != nullptr)\n                {\n                    hybridSort(allElements->elements, allElements->length, &cvInfo);\n                }\n                else\n                {\n                    sort(allElements->elements, &allElements->length, scriptContext);\n                }\n\n                head = allElements;\n                head->next = nullptr;\n            }\n        },\n        [&](bool hasException)\n        {\n            length = saveLength;\n            ClearSegmentMap(); // Dump the segmentMap again in case user compare function rebuilds it\n            if (hasException)\n            {\n                head = startSeg;\n                this->InvalidateLastUsedSegment();\n            }\n        });\n\n#if DEBUG\n        {\n            uint32 countNull = 0;\n            uint32 index = head->length - 1;\n            while (countNull < head->length)\n            {\n                if (((SparseArraySegment<Var>*)head)->elements[index] != NULL)\n                {\n                    break;\n                }\n                index--;\n                countNull++;\n            }\n            AssertMsg(countNull == 0, \"No null expected at the end\");\n        }\n#endif\n\n        if (countUndefined != 0)\n        {\n            // fill undefined at the end\n            uint32 newLength = head->length + countUndefined;\n            if (newLength > head->size)\n            {\n                head = ((SparseArraySegment<Var>*)head)->GrowByMin(recycler, newLength - head->size);\n            }\n\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            for (uint32 i = head->length; i < newLength; i++)\n            {\n                ((SparseArraySegment<Var>*)head)->elements[i] = undefined;\n            }\n            head->length = newLength;\n        }\n        SetHasNoMissingValues();\n        this->InvalidateLastUsedSegment();\n\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n        return;\n    }\n\n    uint32 JavascriptArray::sort(__inout_ecount(*len) Var *orig, uint32 *len, ScriptContext *scriptContext)\n    {\n        uint32 count = 0, countUndefined = 0;\n        Element *elements = RecyclerNewArrayZ(scriptContext->GetRecycler(), Element, *len);\n        RecyclableObject *undefined = scriptContext->GetLibrary()->GetUndefined();\n\n        //\n        // Create the Elements array\n        //\n\n        for (uint32 i = 0; i < *len; ++i)\n        {\n            if (!SparseArraySegment<Var>::IsMissingItem(&orig[i]))\n            {\n                if (!JavascriptOperators::IsUndefinedObject(orig[i], undefined))\n                {\n                    elements[count].Value = orig[i];\n                    elements[count].StringValue =  JavascriptConversion::ToString(orig[i], scriptContext);\n\n                    count++;\n                }\n                else\n                {\n                    countUndefined++;\n                }\n            }\n        }\n\n        if (count > 0)\n        {\n            SortElements(elements, 0, count - 1);\n\n            for (uint32 i = 0; i < count; ++i)\n            {\n                orig[i] = elements[i].Value;\n            }\n        }\n\n        for (uint32 i = count + countUndefined; i < *len; ++i)\n        {\n            orig[i] = SparseArraySegment<Var>::GetMissingItem();\n        }\n\n        *len = count; // set the correct length\n        return countUndefined;\n    }\n\n    int __cdecl JavascriptArray::CompareElements(void* context, const void* elem1, const void* elem2)\n    {\n        const Element* element1 = static_cast<const Element*>(elem1);\n        const Element* element2 = static_cast<const Element*>(elem2);\n\n        Assert(element1 != NULL);\n        Assert(element2 != NULL);\n\n        return JavascriptString::strcmp(element1->StringValue, element2->StringValue);\n    }\n\n    void JavascriptArray::SortElements(Element* elements, uint32 left, uint32 right)\n    {\n        qsort_s(elements, right - left + 1, sizeof(Element), CompareElements, this);\n    }\n\n    Var JavascriptArray::EntrySort(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.sort\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");\n\n        RecyclableObject* compFn = NULL;\n        if (args.Info.Count > 1)\n        {\n            if (JavascriptConversion::IsCallable(args[1]))\n            {\n                compFn = RecyclableObject::FromVar(args[1]);\n            }\n            else\n            {\n                TypeId typeId = JavascriptOperators::GetTypeId(args[1]);\n\n                // Use default comparer:\n                // - In ES5 mode if the argument is undefined.\n                bool useDefaultComparer = typeId == TypeIds_Undefined;\n                if (!useDefaultComparer)\n                {\n                    JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedInternalObject, _u(\"Array.prototype.sort\"));\n                }\n            }\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n\n            JavascriptArray *arr = JavascriptArray::FromVar(args[0]);\n\n            if (arr->length <= 1)\n            {\n                return args[0];\n            }\n\n            if(arr->IsFillFromPrototypes())\n            {\n                arr->FillFromPrototypes(0, arr->length); // We need find all missing value from [[proto]] object\n            }\n\n            // Maintain nativity of the array only for the following cases (To favor inplace conversions - keeps the conversion cost less):\n            // -    int cases for X86 and\n            // -    FloatArray for AMD64\n            // We convert the entire array back and forth once here O(n), rather than doing the costly conversion down the call stack which is O(nlogn)\n\n#if defined(_M_X64_OR_ARM64)\n            if(compFn && JavascriptNativeFloatArray::Is(arr))\n            {\n                arr = JavascriptNativeFloatArray::ConvertToVarArray((JavascriptNativeFloatArray*)arr);\n                arr->Sort(compFn);\n                arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeFloatArray, double>(arr);\n            }\n            else\n            {\n                EnsureNonNativeArray(arr);\n                arr->Sort(compFn);\n            }\n#else\n            if(compFn && JavascriptNativeIntArray::Is(arr))\n            {\n                //EnsureNonNativeArray(arr);\n                arr = JavascriptNativeIntArray::ConvertToVarArray((JavascriptNativeIntArray*)arr);\n                arr->Sort(compFn);\n                arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeIntArray, int32>(arr);\n            }\n            else\n            {\n                EnsureNonNativeArray(arr);\n                arr->Sort(compFn);\n            }\n#endif\n\n        }\n        else\n        {\n            RecyclableObject* pObj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.sort\"));\n            }\n            uint32 len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n            JavascriptArray* sortArray = scriptContext->GetLibrary()->CreateArray(len);\n            sortArray->EnsureHead<Var>();\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.sort\"));\n\n            BEGIN_TEMP_ALLOCATOR(tempAlloc, scriptContext, _u(\"Runtime\"))\n            {\n                JsUtil::List<uint32, ArenaAllocator>* indexList = JsUtil::List<uint32, ArenaAllocator>::New(tempAlloc);\n\n                for (uint32 i = 0; i < len; i++)\n                {\n                    Var item;\n                    if (JavascriptOperators::GetItem(pObj, i, &item, scriptContext))\n                    {\n                        indexList->Add(i);\n                        sortArray->DirectSetItemAt(i, item);\n                    }\n                }\n                if (indexList->Count() > 0)\n                {\n                    if (sortArray->length > 1)\n                    {\n                        sortArray->FillFromPrototypes(0, sortArray->length); // We need find all missing value from [[proto]] object\n                    }\n                    sortArray->Sort(compFn);\n\n                    uint32 removeIndex = sortArray->head->length;\n                    for (uint32 i = 0; i < removeIndex; i++)\n                    {\n                        AssertMsg(!SparseArraySegment<Var>::IsMissingItem(&((SparseArraySegment<Var>*)sortArray->head)->elements[i]), \"No gaps expected in sorted array\");\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, i, ((SparseArraySegment<Var>*)sortArray->head)->elements[i], scriptContext));\n                    }\n                    for (int i = 0; i < indexList->Count(); i++)\n                    {\n                        uint32 value = indexList->Item(i);\n                        if (value >= removeIndex)\n                        {\n                            h.ThrowTypeErrorOnFailure((JavascriptOperators::DeleteItem(pObj, value)));\n                        }\n                    }\n                }\n\n            }\n            END_TEMP_ALLOCATOR(tempAlloc, scriptContext);\n        }\n        return args[0];\n    }\n\n    Var JavascriptArray::EntrySplice(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");\n\n        bool isArr = false;\n        JavascriptArray* pArr = 0;\n        RecyclableObject* pObj = 0;\n        RecyclableObject* newObj = nullptr;\n        uint32 start = 0;\n        uint32 deleteLen = 0;\n        uint32 len = 0;\n\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            isArr = true;\n            pArr = JavascriptArray::FromVar(args[0]);\n            pObj = pArr;\n            len = pArr->length;\n\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.splice\"));\n            }\n\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                int64 len64 = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n                len = len64 > UINT_MAX ? UINT_MAX : (uint)len64;\n            }\n            else\n            {\n                len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n            }\n        }\n\n        switch (args.Info.Count)\n        {\n        case 1:\n            start = len;\n            deleteLen = 0;\n            break;\n\n        case 2:\n            start = min(GetFromIndex(args[1], len, scriptContext), len);\n            deleteLen = len - start;\n            break;\n\n        default:\n            start = GetFromIndex(args[1], len, scriptContext);\n\n            if (start > len)\n            {\n                start = len;\n            }\n\n            // When start >= len, we know we won't be deleting any items and don't really need to evaluate the second argument.\n            // However, ECMA 262 15.4.4.12 requires that it be evaluated, anyway.  If the argument is an object with a valueOf\n            // with a side effect, this evaluation is observable.  Hence, we must evaluate.\n            if (TaggedInt::Is(args[2]))\n            {\n                int intDeleteLen = TaggedInt::ToInt32(args[2]);\n                if (intDeleteLen < 0)\n                {\n                    deleteLen = 0;\n                }\n                else\n                {\n                    deleteLen = intDeleteLen;\n                }\n            }\n            else\n            {\n                double dblDeleteLen = JavascriptConversion::ToInteger(args[2], scriptContext);\n\n                if (dblDeleteLen > len)\n                {\n                    deleteLen = (uint32)-1;\n                }\n                else if (dblDeleteLen <= 0)\n                {\n                    deleteLen = 0;\n                }\n                else\n                {\n                    deleteLen = (uint32)dblDeleteLen;\n                }\n            }\n            deleteLen = min(len - start, deleteLen);\n            break;\n        }\n\n        Var* insertArgs = args.Info.Count > 3 ? &args.Values[3] : nullptr;\n        uint32 insertLen = args.Info.Count > 3 ? args.Info.Count - 3 : 0;\n\n        ::Math::RecordOverflowPolicy newLenOverflow;\n        uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice\n\n        if (isArr)\n        {\n            // If we have missing values then convert to not native array for now\n            // In future, we could support this scenario.\n            if (deleteLen == insertLen)\n            {\n                pArr->FillFromPrototypes(start, start + deleteLen);\n            }\n            else if (len)\n            {\n                pArr->FillFromPrototypes(start, len);\n            }\n\n            //\n            // If newLen overflowed, pre-process to prevent pushing sparse array segments or elements out of\n            // max array length, which would result in tons of index overflow and difficult to fix.\n            //\n            if (newLenOverflow.HasOverflowed())\n            {\n                pArr = EnsureNonNativeArray(pArr);\n                BigIndex dstIndex = MaxArrayLength;\n\n                uint32 maxInsertLen = MaxArrayLength - start;\n                if (insertLen > maxInsertLen)\n                {\n                    // Copy overflowing insertArgs to properties\n                    for (uint32 i = maxInsertLen; i < insertLen; i++)\n                    {\n                        pArr->DirectSetItemAt(dstIndex, insertArgs[i]);\n                        ++dstIndex;\n                    }\n\n                    insertLen = maxInsertLen; // update\n\n                    // Truncate elements on the right to properties\n                    if (start + deleteLen < len)\n                    {\n                        pArr->TruncateToProperties(dstIndex, start + deleteLen);\n                    }\n                }\n                else\n                {\n                    // Truncate would-overflow elements to properties\n                    pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);\n                }\n\n                len = pArr->length; // update\n                newLen = len - deleteLen + insertLen;\n                Assert(newLen == MaxArrayLength);\n            }\n\n            if (insertArgs)\n            {\n                pArr = EnsureNonNativeArray(pArr);\n            }\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n            bool isBuiltinArrayCtor = true;\n            JavascriptArray *newArr = nullptr;\n\n            // Just dump the segment map on splice (before any possible allocation and throw)\n            pArr->ClearSegmentMap();\n\n            // If the source object is an Array exotic object (Array.isArray) we should try to load the constructor property\n            // and use it to construct the return object.\n            newObj = ArraySpeciesCreate(pArr, deleteLen, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n            if (newObj != nullptr)\n            {\n                pArr = EnsureNonNativeArray(pArr);\n                // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            // This is the ES5 case, pArr['constructor'] doesn't exist, or pArr['constructor'] is the builtin Array constructor\n            {\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n                newArr = CreateNewArrayHelper(deleteLen, isIntArray, isFloatArray, pArr, scriptContext);\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);\n#endif\n            }\n\n            // If return object is a JavascriptArray, we can use all the array splice helpers\n            if (newArr && isBuiltinArrayCtor && len == pArr->length)\n            {\n\n                // Array has a single segment (need not start at 0) and splice start lies in the range\n                // of that segment we optimize splice - Fast path.\n                if (pArr->IsSingleSegmentArray() && pArr->head->HasIndex(start))\n                {\n                    if (isIntArray)\n                    {\n                        ArraySegmentSpliceHelper<int32>(newArr, (SparseArraySegment<int32>*)pArr->head, (SparseArraySegment<int32>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ArraySegmentSpliceHelper<double>(newArr, (SparseArraySegment<double>*)pArr->head, (SparseArraySegment<double>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n                    else\n                    {\n                        ArraySegmentSpliceHelper<Var>(newArr, (SparseArraySegment<Var>*)pArr->head, (SparseArraySegment<Var>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n\n                    // Since the start index is within the bounds of the original array's head segment, it will not acquire any new\n                    // missing values. If the original array had missing values in the head segment, some of them may have been\n                    // copied into the array that will be returned; otherwise, the array that is returned will also not have any\n                    // missing values.\n                    newArr->SetHasNoMissingValues(pArr->HasNoMissingValues());\n                }\n                else\n                {\n                    if (isIntArray)\n                    {\n                        ArraySpliceHelper<int32>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ArraySpliceHelper<double>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n                    else\n                    {\n                        ArraySpliceHelper<Var>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n\n                    // This function currently does not track missing values in the head segment if there are multiple segments\n                    pArr->SetHasNoMissingValues(false);\n                    newArr->SetHasNoMissingValues(false);\n                }\n\n                if (isIntArray)\n                {\n                    pArr->EnsureHeadStartsFromZero<int32>(recycler);\n                    newArr->EnsureHeadStartsFromZero<int32>(recycler);\n                }\n                else if (isFloatArray)\n                {\n                    pArr->EnsureHeadStartsFromZero<double>(recycler);\n                    newArr->EnsureHeadStartsFromZero<double>(recycler);\n                }\n                else\n                {\n                    pArr->EnsureHeadStartsFromZero<Var>(recycler);\n                    newArr->EnsureHeadStartsFromZero<Var>(recycler);\n                }\n\n                pArr->InvalidateLastUsedSegment();\n\n                // it is possible for valueOf accessors for the start or deleteLen\n                // arguments to modify the size of the array. Since the resulting size of the array\n                // is based on the cached value of length, this might lead to us having to trim\n                // excess array segments at the end of the splice operation, which SetLength() will do.\n                // However, this is also slower than performing the simple length assignment, so we only\n                // do it if we can detect the array length changing.\n                if(pArr->length != len)\n                {\n                    pArr->SetLength(newLen);\n                }\n                else\n                {\n                    pArr->length = newLen;\n                }\n\n                if (newArr->length != deleteLen)\n                {\n                    newArr->SetLength(deleteLen);\n                }\n                else\n                {\n                    newArr->length = deleteLen;\n                }\n\n                newArr->InvalidateLastUsedSegment();\n\n#ifdef VALIDATE_ARRAY\n                newArr->ValidateArray();\n                pArr->ValidateArray();\n#endif\n                if (newLenOverflow.HasOverflowed())\n                {\n                    // ES5 15.4.4.12 16: If new len overflowed, SetLength throws\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n\n                return newArr;\n            }\n        }\n\n        if (newLenOverflow.HasOverflowed())\n        {\n            return ObjectSpliceHelper<BigIndex>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);\n        }\n        else // Use uint32 version if no overflow\n        {\n            return ObjectSpliceHelper<uint32>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);\n        }\n    }\n\n    inline BOOL JavascriptArray::IsSingleSegmentArray() const\n    {\n        return nullptr == head->next;\n    }\n\n    template<typename T>\n    void JavascriptArray::ArraySegmentSpliceHelper(JavascriptArray *pnewArr, SparseArraySegment<T> *seg, SparseArraySegment<T> **prev,\n                                                    uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, Recycler *recycler)\n    {\n        // book keeping variables\n        uint32 relativeStart    = start - seg->left;  // This will be different from start when head->left is non zero -\n                                                      //(Missing elements at the beginning)\n\n        uint32 headDeleteLen    = min(start + deleteLen , seg->left + seg->length) - start;   // actual number of elements to delete in\n                                                                                              // head if deleteLen overflows the length of head\n\n        uint32 newHeadLen       = seg->length - headDeleteLen + insertLen;     // new length of the head after splice\n\n        // Save the deleted elements\n        if (headDeleteLen != 0)\n        {\n            pnewArr->InvalidateLastUsedSegment();\n            pnewArr->head = SparseArraySegment<T>::CopySegment(recycler, (SparseArraySegment<T>*)pnewArr->head, 0, seg, start, headDeleteLen);\n        }\n\n        if (newHeadLen != 0)\n        {\n            if (seg->size < newHeadLen)\n            {\n                if (seg->next)\n                {\n                    // If we have \"next\", require that we haven't adjusted next segments left yet.\n                    seg = seg->GrowByMinMax(recycler, newHeadLen - seg->size, seg->next->left - deleteLen + insertLen - seg->left - seg->size);\n                }\n                else\n                {\n                    seg = seg->GrowByMin(recycler, newHeadLen - seg->size);\n                }\n#ifdef VALIDATE_ARRAY\n                ValidateSegment(seg);\n#endif\n            }\n\n            // Move the elements if necessary\n            if (headDeleteLen != insertLen)\n            {\n                uint32 noElementsToMove = seg->length - (relativeStart + headDeleteLen);\n                memmove(seg->elements + relativeStart + insertLen,\n                                     seg->elements + relativeStart + headDeleteLen,\n                                     sizeof(T) * noElementsToMove);\n                if (newHeadLen < seg->length) // truncate if necessary\n                {\n                    seg->Truncate(seg->left + newHeadLen); // set end elements to null so that when we introduce null elements we are safe\n                }\n                seg->length = newHeadLen;\n            }\n            // Copy the new elements\n            if (insertLen > 0)\n            {\n                Assert(!VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pnewArr) &&\n                   !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pnewArr));\n\n                // inserted elements starts at argument 3 of splice(start, deleteNumber, insertelem1, insertelem2, insertelem3, ...);\n                js_memcpy_s(seg->elements + relativeStart, sizeof(Var) * insertLen, insertArgs, sizeof(Var) * insertLen);\n            }\n            *prev = seg;\n        }\n        else\n        {\n            *prev = (SparseArraySegment<T>*)seg->next;\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::ArraySpliceHelper(JavascriptArray* pnewArr, JavascriptArray* pArr, uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)\n    {\n        // Skip pnewArr->EnsureHead(): we don't use existing segment at all.\n        Recycler *recycler  = scriptContext->GetRecycler();\n\n        SparseArraySegmentBase** prevSeg  = &pArr->head;        // holds the next pointer of previous\n        SparseArraySegmentBase** prevPrevSeg  = &pArr->head;    // this holds the previous pointer to prevSeg dirty trick.\n        SparseArraySegmentBase* savePrev = nullptr;\n\n        Assert(pArr->head); // We should never have a null head.\n        pArr->EnsureHead<T>();\n        SparseArraySegment<T>* startSeg = (SparseArraySegment<T>*)pArr->head;\n\n        const uint32 limit = start + deleteLen;\n        uint32 rightLimit;\n        if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))\n        {\n            rightLimit = JavascriptArray::MaxArrayLength;\n        }\n\n        // Find out the segment to start delete\n        while (startSeg && (rightLimit <= start))\n        {\n            savePrev = startSeg;\n            prevPrevSeg = prevSeg;\n            prevSeg = &startSeg->next;\n            startSeg = (SparseArraySegment<T>*)startSeg->next;\n\n            if (startSeg)\n            {\n                if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))\n                {\n                    rightLimit = JavascriptArray::MaxArrayLength;\n                }\n            }\n        }\n\n        // handle inlined segment\n        SparseArraySegmentBase* inlineHeadSegment = nullptr;\n        bool hasInlineSegment = false;\n        // The following if else set is used to determine whether a shallow or hard copy is needed\n        if (JavascriptNativeArray::Is(pArr))\n        {\n            if (JavascriptNativeFloatArray::Is(pArr))\n            {\n                inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>((JavascriptNativeFloatArray*)pArr);\n            }\n            else if (JavascriptNativeIntArray::Is(pArr))\n            {\n                inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>((JavascriptNativeIntArray*)pArr);\n            }\n            Assert(inlineHeadSegment);\n            hasInlineSegment = (startSeg == (SparseArraySegment<T>*)inlineHeadSegment);\n        }\n        else\n        {\n            // This will result in false positives. It is used because DetermineInlineHeadSegmentPointer\n            // does not handle Arrays that change type e.g. from JavascriptNativeIntArray to JavascriptArray\n            // This conversion in particular is problematic because JavascriptNativeIntArray is larger than JavascriptArray\n            // so the returned head segment ptr never equals pArr->head. So we will default to using this and deal with\n            // false positives. It is better than always doing a hard copy.\n            hasInlineSegment = HasInlineHeadSegment(pArr->head->length);\n        }\n\n        if (startSeg)\n        {\n            // Delete Phase\n            if (startSeg->left <= start && (startSeg->left + startSeg->length) >= limit)\n            {\n                // All splice happens in one segment.\n                SparseArraySegmentBase *nextSeg = startSeg->next;\n                // Splice the segment first, which might OOM throw but the array would be intact.\n                JavascriptArray::ArraySegmentSpliceHelper(pnewArr, (SparseArraySegment<T>*)startSeg, (SparseArraySegment<T>**)prevSeg, start, deleteLen, insertArgs, insertLen, recycler);\n                while (nextSeg)\n                {\n                    // adjust next segments left\n                    nextSeg->left = nextSeg->left - deleteLen + insertLen;\n                    if (nextSeg->next == nullptr)\n                    {\n                        nextSeg->EnsureSizeInBound();\n                    }\n                    nextSeg = nextSeg->next;\n                }\n                if (*prevSeg)\n                {\n                    (*prevSeg)->EnsureSizeInBound();\n                }\n                return;\n            }\n            else\n            {\n                SparseArraySegment<T>* newHeadSeg = nullptr; // pnewArr->head is null\n                SparseArraySegmentBase** prevNewHeadSeg = &(pnewArr->head);\n\n                // delete till deleteLen and reuse segments for new array if it is possible.\n                // 3 steps -\n                //1. delete 1st segment (which may be partial delete)\n                // 2. delete next n complete segments\n                // 3. delete last segment (which again may be partial delete)\n\n                // Step (1)  -- WOOB 1116297: When left >= start, step (1) is skipped, resulting in pNewArr->head->left != 0. We need to touch up pNewArr.\n                if (startSeg->left < start)\n                {\n                    if (start < startSeg->left + startSeg->length)\n                    {\n                        uint32 headDeleteLen = startSeg->left + startSeg->length - start;\n\n                        if (startSeg->next)\n                        {\n                            // We know the new segment will have a next segment, so allocate it as non-leaf.\n                            newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        else\n                        {\n                            newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);\n                        newHeadSeg->next = nullptr;\n                        *prevNewHeadSeg = newHeadSeg;\n                        prevNewHeadSeg = &newHeadSeg->next;\n                        startSeg->Truncate(start);\n                    }\n                    savePrev = startSeg;\n                    prevPrevSeg = prevSeg;\n                    prevSeg = &startSeg->next;\n                    startSeg = (SparseArraySegment<T>*)startSeg->next;\n                }\n\n                // Step (2) first we should do a hard copy if we have an inline head Segment\n                else if (hasInlineSegment && nullptr != startSeg)\n                {\n                    // start should be in between left and left + length\n                    if (startSeg->left  <= start && start < startSeg->left + startSeg->length)\n                    {\n                        uint32 headDeleteLen = startSeg->left + startSeg->length - start;\n                        if (startSeg->next)\n                        {\n                            // We know the new segment will have a next segment, so allocate it as non-leaf.\n                            newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        else\n                        {\n                            newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);\n                        *prevNewHeadSeg = newHeadSeg;\n                        prevNewHeadSeg = &newHeadSeg->next;\n\n                        // Remove the entire segment from the original array\n                        *prevSeg = startSeg->next;\n                        startSeg = (SparseArraySegment<T>*)startSeg->next;\n                    }\n                    // if we have an inline head segment with 0 elements, remove it\n                    else if (startSeg->left == 0 && startSeg->length == 0)\n                    {\n                        Assert(startSeg->size != 0);\n                        *prevSeg = startSeg->next;\n                        startSeg = (SparseArraySegment<T>*)startSeg->next;\n                    }\n                }\n                // Step (2) proper\n                SparseArraySegmentBase *temp = nullptr;\n                while (startSeg && (startSeg->left + startSeg->length) <= limit)\n                {\n                    temp = startSeg->next;\n\n                    // move that entire segment to new array\n                    startSeg->left = startSeg->left - start;\n                    startSeg->next = nullptr;\n                    *prevNewHeadSeg = startSeg;\n                    prevNewHeadSeg = &startSeg->next;\n\n                    // Remove the entire segment from the original array\n                    *prevSeg = temp;\n                    startSeg = (SparseArraySegment<T>*)temp;\n                }\n\n                // Step(2) above could delete the original head segment entirely, causing current head not\n                // starting from 0. Then if any of the following throw, we have a corrupted array. Need\n                // protection here.\n                bool dummyHeadNodeInserted = false;\n                if (!savePrev && (!startSeg || startSeg->left != 0))\n                {\n                    Assert(pArr->head == startSeg);\n                    pArr->EnsureHeadStartsFromZero<T>(recycler);\n                    Assert(pArr->head && pArr->head->next == startSeg);\n\n                    savePrev = pArr->head;\n                    prevPrevSeg = prevSeg;\n                    prevSeg = &pArr->head->next;\n                    dummyHeadNodeInserted = true;\n                }\n\n                // Step (3)\n                if (startSeg && (startSeg->left < limit))\n                {\n                    // copy the first part of the last segment to be deleted to new array\n                    uint32 headDeleteLen = start + deleteLen - startSeg->left ;\n\n                    newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, startSeg->left -  start, headDeleteLen, (SparseArraySegmentBase *)nullptr);\n                    newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, startSeg->left -  start, startSeg, startSeg->left, headDeleteLen);\n                    newHeadSeg->next = nullptr;\n                    *prevNewHeadSeg = newHeadSeg;\n                    prevNewHeadSeg = &newHeadSeg->next;\n\n                    // move the last segment\n                    memmove(startSeg->elements, startSeg->elements + headDeleteLen, sizeof(T) * (startSeg->length - headDeleteLen));\n                    startSeg->left = startSeg->left + headDeleteLen; // We are moving the left ahead to point to the right index\n                    startSeg->length = startSeg->length - headDeleteLen;\n                    startSeg->Truncate(startSeg->left + startSeg->length);\n                    startSeg->EnsureSizeInBound(); // Just truncated, size might exceed next.left\n                }\n\n                if (startSeg && ((startSeg->left - deleteLen + insertLen) == 0) && dummyHeadNodeInserted)\n                {\n                    Assert(start + insertLen == 0);\n                    // Remove the dummy head node to preserve array consistency.\n                    pArr->head = startSeg;\n                    savePrev = nullptr;\n                    prevSeg = &pArr->head;\n                }\n\n                while (startSeg)\n                {\n                    startSeg->left = startSeg->left - deleteLen + insertLen ;\n                    if (startSeg->next == nullptr)\n                    {\n                        startSeg->EnsureSizeInBound();\n                    }\n                    startSeg = (SparseArraySegment<T>*)startSeg->next;\n                }\n            }\n        }\n\n        // The size of pnewArr head allocated in above step 1 might exceed next.left concatenated in step 2/3.\n        pnewArr->head->EnsureSizeInBound();\n        if (savePrev)\n        {\n            savePrev->EnsureSizeInBound();\n        }\n\n        // insert elements\n        if (insertLen > 0)\n        {\n            Assert(!JavascriptNativeIntArray::Is(pArr) && !JavascriptNativeFloatArray::Is(pArr));\n\n            // InsertPhase\n            SparseArraySegment<T> *segInsert = nullptr;\n\n            // see if we are just about the right of the previous segment\n            Assert(!savePrev || savePrev->left <= start);\n            if (savePrev && (start - savePrev->left < savePrev->size))\n            {\n                segInsert = (SparseArraySegment<T>*)savePrev;\n                uint32 spaceLeft = segInsert->size - (start - segInsert->left);\n                if(spaceLeft < insertLen)\n                {\n                    if (!segInsert->next)\n                    {\n                        segInsert = segInsert->GrowByMin(recycler, insertLen - spaceLeft);\n                    }\n                    else\n                    {\n                        segInsert = segInsert->GrowByMinMax(recycler, insertLen - spaceLeft, segInsert->next->left - segInsert->left - segInsert->size);\n                    }\n                }\n                *prevPrevSeg = segInsert;\n                segInsert->length = start + insertLen - segInsert->left;\n            }\n            else\n            {\n                segInsert = SparseArraySegment<T>::AllocateSegment(recycler, start, insertLen, *prevSeg);\n                segInsert->next = *prevSeg;\n                *prevSeg = segInsert;\n                savePrev = segInsert;\n            }\n\n            uint32 relativeStart = start - segInsert->left;\n            // inserted elements starts at argument 3 of splice(start, deleteNumber, insertelem1, insertelem2, insertelem3, ...);\n            js_memcpy_s(segInsert->elements + relativeStart, sizeof(T) * insertLen, insertArgs, sizeof(T) * insertLen);\n        }\n    }\n\n    template<typename indexT>\n    RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, uint32 len, uint32 start,\n        uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext, RecyclableObject* pNewObj)\n    {\n        JavascriptArray *pnewArr = nullptr;\n\n        if (pNewObj == nullptr)\n        {\n            pNewObj = ArraySpeciesCreate(pObj, deleteLen, scriptContext);\n            if (pNewObj == nullptr || !JavascriptArray::Is(pNewObj))\n            {\n                pnewArr = scriptContext->GetLibrary()->CreateArray(deleteLen);\n                pnewArr->EnsureHead<Var>();\n\n                pNewObj = pnewArr;\n            }\n        }\n\n        if (JavascriptArray::Is(pNewObj))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pNewObj);\n#endif\n            pnewArr = JavascriptArray::FromVar(pNewObj);\n        }\n\n        // copy elements to delete to new array\n        if (deleteLen > 0)\n        {\n            for (uint32 i = 0; i < deleteLen; i++)\n            {\n               if (JavascriptOperators::HasItem(pObj, start+i))\n               {\n                   Var element = JavascriptOperators::GetItem(pObj, start + i, scriptContext);\n                   if (pnewArr)\n                   {\n                       pnewArr->SetItem(i, element, PropertyOperation_None);\n                   }\n                   else\n                   {\n                       ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(pNewObj, i, element), scriptContext, i);\n                   }\n               }\n            }\n        }\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.splice\"));\n\n        // If the return object is not an array, we'll need to set the 'length' property\n        if (pnewArr == nullptr)\n        {\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, JavascriptNumber::ToVar(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n\n        // Now we need reserve room if it is necessary\n        if (insertLen > deleteLen) // Might overflow max array length\n        {\n            // Unshift [start + deleteLen, len) to start + insertLen\n            Unshift<indexT>(pObj, start + insertLen, start + deleteLen, len, scriptContext);\n        }\n        else if (insertLen < deleteLen) // Won't overflow max array length\n        {\n            uint32 j = 0;\n            for (uint32 i = start + deleteLen; i < len; i++)\n            {\n                if (JavascriptOperators::HasItem(pObj, i))\n                {\n                    Var element = JavascriptOperators::GetItem(pObj, i, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, start + insertLen + j, element, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, start + insertLen + j, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n                j++;\n            }\n\n            // Clean up the rest\n            for (uint32 i = len; i > len - deleteLen + insertLen; i--)\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, i - 1, PropertyOperation_ThrowOnDeleteIfNotConfig));\n            }\n        }\n\n        if (insertLen > 0)\n        {\n            indexT dstIndex = start; // insert index might overflow max array length\n            for (uint i = 0; i < insertLen; i++)\n            {\n                h.ThrowTypeErrorOnFailure(IndexTrace<indexT>::SetItem(pObj, dstIndex, insertArgs[i], PropertyOperation_ThrowIfNotExtensible));\n                ++dstIndex;\n            }\n        }\n\n        // Set up new length\n        indexT newLen = indexT(len - deleteLen) + insertLen;\n        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pObj, pObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n#ifdef VALIDATE_ARRAY\n        if (pnewArr)\n        {\n            pnewArr->ValidateArray();\n        }\n#endif\n        return pNewObj;\n    }\n\n    Var JavascriptArray::EntryToLocaleString(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedObject, _u(\"Array.prototype.toLocaleString\"));\n        }\n\n        if (JavascriptArray::IsDirectAccessArray(args[0]))\n        {\n            JavascriptArray* arr = JavascriptArray::FromVar(args[0]);\n            return ToLocaleString(arr, scriptContext);\n        }\n        else\n        {\n            if (TypedArrayBase::IsDetachedTypedArray(args[0]))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.toLocalString\"));\n            }\n\n            RecyclableObject* obj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toLocaleString\"));\n            }\n            return ToLocaleString(obj, scriptContext);\n        }\n    }\n\n    //\n    // Unshift object elements [start, end) to toIndex, asserting toIndex > start.\n    //\n    template<typename T, typename P>\n    void JavascriptArray::Unshift(RecyclableObject* obj, const T& toIndex, uint32 start, P end, ScriptContext* scriptContext)\n    {\n        typedef IndexTrace<T> index_trace;\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));\n        if (start < end)\n        {\n            T newEnd = (end - start - 1);// newEnd - 1\n            T dst = toIndex + newEnd;\n            uint32 i = 0;\n            if (end > UINT32_MAX)\n            {\n                uint64 i64 = end;\n                for (; i64 > UINT32_MAX; i64--)\n                {\n                    if (JavascriptOperators::HasItem(obj, i64 - 1))\n                    {\n                        Var element = JavascriptOperators::GetItem(obj, i64 - 1, scriptContext);\n                        h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                    else\n                    {\n                        h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                    }\n\n                    --dst;\n                }\n                i = UINT32_MAX;\n            }\n            else\n            {\n                i = (uint32) end;\n            }\n            for (; i > start; i--)\n            {\n                if (JavascriptOperators::HasItem(obj, i-1))\n                {\n                    Var element = JavascriptOperators::GetItem(obj, i - 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n\n                --dst;\n            }\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::GrowArrayHeadHelperForUnshift(JavascriptArray* pArr, uint32 unshiftElements, ScriptContext * scriptContext)\n    {\n        SparseArraySegmentBase* nextToHeadSeg = pArr->head->next;\n        Recycler* recycler = scriptContext->GetRecycler();\n\n        if (nextToHeadSeg == nullptr)\n        {\n            pArr->EnsureHead<T>();\n            pArr->head = ((SparseArraySegment<T>*)pArr->head)->GrowByMin(recycler, unshiftElements);\n        }\n        else\n        {\n            pArr->head = ((SparseArraySegment<T>*)pArr->head)->GrowByMinMax(recycler, unshiftElements, ((nextToHeadSeg->left + unshiftElements) - pArr->head->left - pArr->head->size));\n        }\n\n    }\n\n    template<typename T>\n    void JavascriptArray::UnshiftHelper(JavascriptArray* pArr, uint32 unshiftElements, Js::Var * elements)\n    {\n        SparseArraySegment<T>* head = (SparseArraySegment<T>*)pArr->head;\n        // Make enough room in the head segment to insert new elements at the front\n        memmove(head->elements + unshiftElements, head->elements, sizeof(T) * pArr->head->length);\n        uint32 oldHeadLength = head->length;\n        head->length += unshiftElements;\n\n        /* Set head segment as the last used segment */\n        pArr->InvalidateLastUsedSegment();\n\n        bool hasNoMissingValues = pArr->HasNoMissingValues();\n\n        /* Set HasNoMissingValues to false -> Since we shifted elements right, we might have missing values after the memmove */\n        if(unshiftElements > oldHeadLength)\n        {\n            pArr->SetHasNoMissingValues(false);\n        }\n\n#if ENABLE_PROFILE_INFO\n        pArr->FillFromArgs(unshiftElements, 0, elements, nullptr, true/*dontCreateNewArray*/);\n#else\n        pArr->FillFromArgs(unshiftElements, 0, elements, true/*dontCreateNewArray*/);\n#endif\n\n        // Setting back to the old value\n        pArr->SetHasNoMissingValues(hasNoMissingValues);\n    }\n\n    Var JavascriptArray::EntryUnshift(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n           return res;\n        }\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);\n\n            uint32 unshiftElements = args.Info.Count - 1;\n\n            if (unshiftElements > 0)\n            {\n                if (pArr->IsFillFromPrototypes())\n                {\n                    pArr->FillFromPrototypes(0, pArr->length); // We need find all missing value from [[proto]] object\n                }\n\n                // Pre-process: truncate overflowing elements to properties\n                bool newLenOverflowed = false;\n                uint32 maxLen = MaxArrayLength - unshiftElements;\n                if (pArr->length > maxLen)\n                {\n                    newLenOverflowed = true;\n                    // Ensure the array is non-native when overflow happens\n                    EnsureNonNativeArray(pArr);\n                    pArr->TruncateToProperties(MaxArrayLength, maxLen);\n                    Assert(pArr->length + unshiftElements == MaxArrayLength);\n                }\n\n                pArr->ClearSegmentMap(); // Dump segmentMap on unshift (before any possible allocation and throw)\n\n                Assert(pArr->length <= MaxArrayLength - unshiftElements);\n\n                SparseArraySegmentBase* renumberSeg = pArr->head->next;\n\n                bool isIntArray = false;\n                bool isFloatArray = false;\n\n                if (JavascriptNativeIntArray::Is(pArr))\n                {\n                    isIntArray = true;\n                }\n                else if (JavascriptNativeFloatArray::Is(pArr))\n                {\n                    isFloatArray = true;\n                }\n\n                // If we need to grow head segment and there is already a next segment, then allocate the new head segment upfront\n                // If there is OOM in array allocation, then array consistency is maintained.\n                if (pArr->head->size < pArr->head->length + unshiftElements)\n                {\n                    if (isIntArray)\n                    {\n                        GrowArrayHeadHelperForUnshift<int32>(pArr, unshiftElements, scriptContext);\n                    }\n                    else if (isFloatArray)\n                    {\n                        GrowArrayHeadHelperForUnshift<double>(pArr, unshiftElements, scriptContext);\n                    }\n                    else\n                    {\n                        GrowArrayHeadHelperForUnshift<Var>(pArr, unshiftElements, scriptContext);\n                    }\n                }\n\n                while (renumberSeg)\n                {\n                    renumberSeg->left += unshiftElements;\n                    if (renumberSeg->next == nullptr)\n                    {\n                        // last segment can shift its left + size beyond MaxArrayLength, so truncate if so\n                        renumberSeg->EnsureSizeInBound();\n                    }\n                    renumberSeg = renumberSeg->next;\n                }\n\n                if (isIntArray)\n                {\n                    UnshiftHelper<int32>(pArr, unshiftElements, args.Values);\n                }\n                else if (isFloatArray)\n                {\n                    UnshiftHelper<double>(pArr, unshiftElements, args.Values);\n                }\n                else\n                {\n                    UnshiftHelper<Var>(pArr, unshiftElements, args.Values);\n                }\n\n                pArr->InvalidateLastUsedSegment();\n                pArr->length += unshiftElements;\n\n#ifdef VALIDATE_ARRAY\n                pArr->ValidateArray();\n#endif\n\n                if (newLenOverflowed) // ES5: throw if new \"length\" exceeds max array length\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n            }\n            res = JavascriptNumber::ToVar(pArr->length, scriptContext);\n        }\n        else\n        {\n            RecyclableObject* dynamicObject = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));\n            }\n\n            BigIndex length;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            uint32 unshiftElements = args.Info.Count - 1;\n            if (unshiftElements > 0)\n            {\n                uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;\n                // Note: end will always be a smallIndex either it is less than length in which case it is MaxSpaceUint32\n                // or MaxSpaceUint32 is greater than length meaning length is a uint32 number\n                BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;\n                if (end < length)\n                {\n                    // Unshift [end, length) to MaxArrayLength\n                    // MaxArrayLength + (length - MaxSpaceUint32 - 1) = length + unshiftElements -1\n                    if (length.IsSmallIndex())\n                    {\n                        Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext);\n                    }\n                    else\n                    {\n                        Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetBigIndex(), scriptContext);\n                    }\n                }\n\n                // Unshift [0, end) to unshiftElements\n                // unshiftElements + (MaxSpaceUint32 - 0 - 1) = MaxArrayLength -1 therefore this unshift covers up to MaxArrayLength - 1\n                Unshift<uint32>(dynamicObject, unshiftElements, 0, end.GetSmallIndex(), scriptContext);\n\n                for (uint32 i = 0; i < unshiftElements; i++)\n                {\n                    JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true);\n                }\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));\n\n            //ES6 - update 'length' even if unshiftElements == 0;\n            BigIndex newLen = length + unshiftElements;\n            res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        return res;\n\n    }\n\n    Var JavascriptArray::EntryToString(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedObject);\n        }\n\n         // ES5 15.4.4.2: call join, or built-in Object.prototype.toString\n\n        RecyclableObject* obj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toString\"));\n        }\n\n        // In ES5 we could be calling a user defined join, even on array. We must [[Get]] join at runtime.\n        Var join = JavascriptOperators::GetProperty(obj, PropertyIds::join, scriptContext);\n        if (JavascriptConversion::IsCallable(join))\n        {\n            RecyclableObject* func = RecyclableObject::FromVar(join);\n            // We need to record implicit call here, because marked the Array.toString as no side effect,\n            // but if we call user code here which may have side effect\n            ThreadContext * threadContext = scriptContext->GetThreadContext();\n            Var result = threadContext->ExecuteImplicitCall(func, ImplicitCall_ToPrimitive, [=]() -> Js::Var\n            {\n                // Stack object should have a pre-op bail on implicit call. We shouldn't see them here.\n                Assert(!ThreadContext::IsOnStack(obj));\n\n                // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n                CallFlags flags = CallFlags_Value;\n                return CALL_FUNCTION(func, CallInfo(flags, 1), obj);\n            });\n\n            if(!result)\n            {\n                // There was an implicit call and implicit calls are disabled. This would typically cause a bailout.\n                Assert(threadContext->IsDisableImplicitCall());\n                result = scriptContext->GetLibrary()->GetNull();\n            }\n\n            return result;\n        }\n        else\n        {\n            // call built-in Object.prototype.toString\n            return CALL_ENTRYPOINT(JavascriptObject::EntryToString, function, CallInfo(1), obj);\n        }\n    }\n\n#if DEBUG\n    BOOL JavascriptArray::GetIndex(const char16* propName, uint32 *pIndex)\n    {\n        uint32 lu, luDig;\n\n        int32 cch = (int32)wcslen(propName);\n        char16* pch = const_cast<char16 *>(propName);\n\n        lu = *pch - '0';\n        if (lu > 9)\n            return FALSE;\n\n        if (0 == lu)\n        {\n            *pIndex = 0;\n            return 1 == cch;\n        }\n\n        while ((luDig = *++pch - '0') < 10)\n        {\n            // If we overflow 32 bits, ignore the item\n            if (lu > 0x19999999)\n                return FALSE;\n            lu *= 10;\n            if(lu > (ULONG_MAX - luDig))\n                return FALSE;\n            lu += luDig;\n        }\n\n        if (pch - propName != cch)\n            return FALSE;\n\n        if (lu == JavascriptArray::InvalidIndex)\n        {\n            // 0xFFFFFFFF is not treated as an array index so that the length can be\n            // capped at 32 bits.\n            return FALSE;\n        }\n\n        *pIndex = lu;\n        return TRUE;\n    }\n#endif\n\n    JavascriptString* JavascriptArray::GetLocaleSeparator(ScriptContext* scriptContext)\n    {\n#ifdef ENABLE_GLOBALIZATION\n        LCID lcid = GetUserDefaultLCID();\n        int count = 0;\n        char16 szSeparator[6];\n\n        // According to the document for GetLocaleInfo this is a sufficient buffer size.\n        count = GetLocaleInfoW(lcid, LOCALE_SLIST, szSeparator, 5);\n        if( !count)\n        {\n            AssertMsg(FALSE, \"GetLocaleInfo failed\");\n            return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();\n        }\n        else\n        {\n            // Append ' '  if necessary\n            if( count < 2 || szSeparator[count-2] != ' ')\n            {\n                szSeparator[count-1] = ' ';\n                szSeparator[count] = '\\0';\n            }\n\n            return JavascriptString::NewCopyBuffer(szSeparator, count, scriptContext);\n        }\n#else\n        // xplat-todo: Support locale-specific seperator\n        return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();\n#endif\n    }\n\n    template <typename T>\n    JavascriptString* JavascriptArray::ToLocaleString(T* arr, ScriptContext* scriptContext)\n    {\n        uint32 length = 0;\n        if (TypedArrayBase::Is(arr))\n        {\n            // For a TypedArray use the actual length of the array.\n            length = TypedArrayBase::FromVar(arr)->GetLength();\n        }\n        else\n        {\n            //For anything else, use the \"length\" property if present.\n            length = ItemTrace<T>::GetLength(arr, scriptContext);\n        }\n\n        if (length == 0 || scriptContext->CheckObject(arr))\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        JavascriptString* res = scriptContext->GetLibrary()->GetEmptyString();\n        bool pushedObject = false;\n\n        TryFinally([&]()\n        {\n            scriptContext->PushObject(arr);\n            pushedObject = true;\n\n            Var element;\n            if (ItemTrace<T>::GetItem(arr, 0, &element, scriptContext))\n            {\n                res = JavascriptArray::ToLocaleStringHelper(element, scriptContext);\n            }\n\n            if (length > 1)\n            {\n                JavascriptString* separator = GetLocaleSeparator(scriptContext);\n\n                for (uint32 i = 1; i < length; i++)\n                {\n                    res = JavascriptString::Concat(res, separator);\n                    if (ItemTrace<T>::GetItem(arr, i, &element, scriptContext))\n                    {\n                        res = JavascriptString::Concat(res, JavascriptArray::ToLocaleStringHelper(element, scriptContext));\n                    }\n                }\n            }\n        },\n        [&](bool/*hasException*/)\n        {\n            if (pushedObject)\n            {\n                Var top = scriptContext->PopObject();\n                AssertMsg(top == arr, \"Unmatched operation stack\");\n            }\n        });\n\n        if (res == nullptr)\n        {\n            res = scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        return res;\n    }\n\n    Var JavascriptArray::EntryIsArray(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Constructor_isArray);\n\n        if (args.Info.Count < 2)\n        {\n            return scriptContext->GetLibrary()->GetFalse();\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[1]);\n#endif\n        if (JavascriptOperators::IsArray(args[1]))\n        {\n            return scriptContext->GetLibrary()->GetTrue();\n        }\n        return scriptContext->GetLibrary()->GetFalse();\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Find() calls the given predicate callback on each element of the array, in\n    /// order, and returns the first element that makes the predicate return true,\n    /// as described in (ES6.0: S22.1.3.8).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryFind(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));\n        }\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));\n            }\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n\n        return JavascriptArray::FindHelper<false>(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    template <bool findIndex>\n    Var JavascriptArray::FindHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // typedArrayBase is only non-null if and only if we came here via the TypedArray entrypoint\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"[TypedArray].prototype.findIndex\") : _u(\"[TypedArray].prototype.find\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"Array.prototype.findIndex\") : _u(\"Array.prototype.find\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.find/findIndex and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var element = nullptr;\n        Var testResult = nullptr;\n\n        if (pArr)\n        {\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = undefined;\n                pArr->DirectGetItemAtFull(k, &element);\n\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = typedArrayBase->DirectGetItem(k);\n\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    typedArrayBase);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    obj);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n\n        return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();\n    }\n\n    ///----------------------------------------------------------------------------\n    /// FindIndex() calls the given predicate callback on each element of the\n    /// array, in order, and returns the index of the first element that makes the\n    /// predicate return true, as described in (ES6.0: S22.1.3.9).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryFindIndex(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));\n        }\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));\n            }\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::FindHelper<true>(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Entries() returns a new ArrayIterator object configured to return key-\n    /// value pairs matching the elements of the this array/array-like object,\n    /// as described in (ES6.0: S22.1.3.4).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryEntries(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::KeyAndValue);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Keys() returns a new ArrayIterator object configured to return the keys\n    /// of the this array/array-like object, as described in (ES6.0: S22.1.3.13).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryKeys(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Key);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Values() returns a new ArrayIterator object configured to return the values\n    /// of the this array/array-like object, as described in (ES6.0: S22.1.3.29).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryValues(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Value);\n    }\n\n    Var JavascriptArray::EntryEvery(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.every\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_every);\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.every as described by ES6.0 (draft 22) Section 22.1.3.5\n    template <typename T>\n    Var JavascriptArray::EveryHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // typedArrayBase is only non-null if and only if we came here via the TypedArray entrypoint\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.every\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.every\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        Var element = nullptr;\n        Var testResult = nullptr;\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        if (pArr)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetFalse();\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!typedArrayBase->HasItem(k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n\n                if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetFalse();\n                }\n            }\n        }\n        else\n        {\n            for (T k = 0; k < length; k++)\n            {\n                // According to es6 spec, we need to call Has first before calling Get\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n\n                    testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                    {\n                        return scriptContext->GetLibrary()->GetFalse();\n                    }\n                }\n            }\n        }\n\n        return scriptContext->GetLibrary()->GetTrue();\n    }\n\n    Var JavascriptArray::EntrySome(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.some\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_some);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n            if (length.IsSmallIndex())\n        {\n            return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.some as described in ES6.0 (draft 22) Section 22.1.3.23\n    template <typename T>\n    Var JavascriptArray::SomeHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // We are in the TypedArray version of this API if and only if typedArrayBase != nullptr\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.some\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.some\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.some and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var element = nullptr;\n        Var testResult = nullptr;\n\n        if (pArr)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetTrue();\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                // If k < typedArrayBase->length, we know that HasItem will return true.\n                // But we still have to call it in case there's a proxy trap or in the case that we are calling\n                // Array.prototype.some with a TypedArray that has a different length instance property.\n                if (!typedArrayBase->HasItem(k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetTrue();\n                }\n            }\n        }\n        else\n        {\n            for (T k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                    {\n                        return scriptContext->GetLibrary()->GetTrue();\n                    }\n                }\n            }\n        }\n\n        return scriptContext->GetLibrary()->GetFalse();\n    }\n\n    Var JavascriptArray::EntryForEach(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.forEach\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_forEach)\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* dynamicObject = nullptr;\n        RecyclableObject* callBackFn = nullptr;\n        Var thisArg = nullptr;\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            dynamicObject = pArr;\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));\n            }\n\n            if (JavascriptArray::Is(dynamicObject) && scriptContext == JavascriptArray::FromVar(dynamicObject)->GetScriptContext())\n            {\n                pArr = JavascriptArray::FromVar(dynamicObject);\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.forEach\"));\n        }\n        callBackFn = RecyclableObject::FromVar(args[1]);\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        auto fn32 = [dynamicObject, callBackFn, flags, thisArg, scriptContext](uint32 k, Var element)\n        {\n            CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                element,\n                JavascriptNumber::ToVar(k, scriptContext),\n                dynamicObject);\n        };\n\n        auto fn64 = [dynamicObject, callBackFn, flags, thisArg, scriptContext](uint64 k, Var element)\n        {\n            CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                element,\n                JavascriptNumber::ToVar(k, scriptContext),\n                dynamicObject);\n        };\n\n        if (pArr)\n        {\n            Assert(pArr == dynamicObject);\n            pArr->ForEachItemInRange<true>(0, length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex(), scriptContext, fn32);\n        }\n        else\n        {\n            if (length.IsSmallIndex())\n            {\n                TemplatedForEachItemInRange<true>(dynamicObject, 0u, length.GetSmallIndex(), scriptContext, fn32);\n            }\n            else\n            {\n                TemplatedForEachItemInRange<true>(dynamicObject, 0ui64, length.GetBigIndex(), scriptContext, fn64);\n            }\n        }\n        return scriptContext->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptArray::EntryCopyWithin(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        int64 length;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.copyWithin\"));\n            }\n\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::CopyWithinHelper(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    // Array.prototype.copyWithin as defined in ES6.0 (draft 22) Section 22.1.3.3\n    Var JavascriptArray::CopyWithinHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        int64 fromVal = 0;\n        int64 toVal = 0;\n        int64 finalVal = length;\n\n        // If we came from Array.prototype.copyWithin and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        if (args.Info.Count > 1)\n        {\n            toVal = JavascriptArray::GetIndexFromVar(args[1], length, scriptContext);\n\n            if (args.Info.Count > 2)\n            {\n                fromVal = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext);\n\n                if (args.Info.Count > 3 && args[3] != library->GetUndefined())\n                {\n                    finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext);\n                }\n            }\n        }\n\n        // If count would be negative or zero, we won't do anything so go ahead and return early.\n        if (finalVal <= fromVal || length <= toVal)\n        {\n            return obj;\n        }\n\n        // Make sure we won't underflow during the count calculation\n        Assert(finalVal > fromVal && length > toVal);\n\n        int64 count = min(finalVal - fromVal, length - toVal);\n\n        // We shouldn't have made it here if the count was going to be zero\n        Assert(count > 0);\n\n        int direction;\n\n        if (fromVal < toVal && toVal < (fromVal + count))\n        {\n            direction = -1;\n            fromVal += count - 1;\n            toVal += count - 1;\n        }\n        else\n        {\n            direction = 1;\n        }\n\n        // If we are going to copy elements from or to indices > 2^32-1 we'll execute this (slightly slower path)\n        // It's possible to optimize here so that we use the normal code below except for the > 2^32-1 indices\n        if ((direction == -1 && (fromVal >= MaxArrayLength || toVal >= MaxArrayLength))\n            || (((fromVal + count) > MaxArrayLength) || ((toVal + count) > MaxArrayLength)))\n        {\n            while (count > 0)\n            {\n                Var index = JavascriptNumber::ToVar(fromVal, scriptContext);\n\n                if (JavascriptOperators::OP_HasItem(obj, index, scriptContext))\n                {\n                    Var val = JavascriptOperators::OP_GetElementI(obj, index, scriptContext);\n\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), val, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                }\n                else\n                {\n                    JavascriptOperators::OP_DeleteElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), scriptContext, PropertyOperation_ThrowOnDeleteIfNotConfig);\n                }\n\n                fromVal += direction;\n                toVal += direction;\n                count--;\n            }\n        }\n        else\n        {\n            Assert(fromVal < MaxArrayLength);\n            Assert(toVal < MaxArrayLength);\n            Assert(direction == -1 || (fromVal + count < MaxArrayLength && toVal + count < MaxArrayLength));\n\n            uint32 fromIndex = static_cast<uint32>(fromVal);\n            uint32 toIndex = static_cast<uint32>(toVal);\n\n            while (count > 0)\n            {\n                if (obj->HasItem(fromIndex))\n                {\n                    if (typedArrayBase)\n                    {\n                        Var val = typedArrayBase->DirectGetItem(fromIndex);\n\n                        typedArrayBase->DirectSetItem(toIndex, val);\n                    }\n                    else if (pArr)\n                    {\n                        Var val = pArr->DirectGetItem(fromIndex);\n\n                        pArr->SetItem(toIndex, val, Js::PropertyOperation_ThrowIfNotExtensible);\n                    }\n                    else\n                    {\n                        Var val = JavascriptOperators::OP_GetElementI_UInt32(obj, fromIndex, scriptContext);\n\n                        JavascriptOperators::OP_SetElementI_UInt32(obj, toIndex, val, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                    }\n                }\n                else\n                {\n                    obj->DeleteItem(toIndex, PropertyOperation_ThrowOnDeleteIfNotConfig);\n                }\n\n                fromIndex += direction;\n                toIndex += direction;\n                count--;\n            }\n        }\n\n        return obj;\n    }\n\n    Var JavascriptArray::EntryFill(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        int64 length;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.fill\"));\n            }\n\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::FillHelper(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    // Array.prototype.fill as defined in ES6.0 (draft 22) Section 22.1.3.6\n    Var JavascriptArray::FillHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n\n        // If we came from Array.prototype.fill and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        Var fillValue;\n\n        if (args.Info.Count > 1)\n        {\n            fillValue = args[1];\n        }\n        else\n        {\n            fillValue = library->GetUndefined();\n        }\n\n        int64 k = 0;\n        int64 finalVal = length;\n\n        if (args.Info.Count > 2)\n        {\n            k = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext);\n\n            if (args.Info.Count > 3 && !JavascriptOperators::IsUndefinedObject(args[3]))\n            {\n                finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext);\n            }\n        }\n\n        if (k < MaxArrayLength)\n        {\n            int64 end = min<int64>(finalVal, MaxArrayLength);\n            uint32 u32k = static_cast<uint32>(k);\n\n            while (u32k < end)\n            {\n                if (typedArrayBase)\n                {\n                    typedArrayBase->DirectSetItem(u32k, fillValue);\n                }\n                else if (pArr)\n                {\n                    pArr->SetItem(u32k, fillValue, PropertyOperation_ThrowIfNotExtensible);\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI_UInt32(obj, u32k, fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n\n                u32k++;\n            }\n\n            BigIndex dstIndex = MaxArrayLength;\n\n            for (int64 i = end; i < finalVal; ++i)\n            {\n                if (pArr)\n                {\n                    pArr->DirectSetItemAt(dstIndex, fillValue);\n                    ++dstIndex;\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n        else\n        {\n            BigIndex dstIndex = static_cast<uint64>(k);\n\n            for (int64 i = k; i < finalVal; i++)\n            {\n                if (pArr)\n                {\n                    pArr->DirectSetItemAt(dstIndex, fillValue);\n                    ++dstIndex;\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    // Array.prototype.map as defined by ES6.0 (Final) 22.1.3.15\n    Var JavascriptArray::EntryMap(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.map\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_map);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));\n            }\n        }\n\n        length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n\n    template<typename T>\n    Var JavascriptArray::MapHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        RecyclableObject* newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n        bool isBuiltinArrayCtor = true;\n\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (isTypedArrayEntryPoint)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.map\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.map\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // If the entry point is %TypedArray%.prototype.map or the source object is an Array exotic object we should try to load the constructor property\n        // and use it to construct the return object.\n        if (isTypedArrayEntryPoint)\n        {\n            Var constructor = JavascriptOperators::SpeciesConstructor(\n                typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext);\n            isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());\n\n            if (JavascriptOperators::IsConstructor(constructor))\n            {\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)length, scriptContext));\n            }\n            else if (isTypedArrayEntryPoint)\n            {\n                // We only need to throw a TypeError when the constructor property is not an actual constructor if %TypedArray%.prototype.map was called\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"[TypedArray].prototype.map\"));\n            }\n        }\n        // skip the typed array and \"pure\" array case, we still need to handle special arrays like es5array, remote array, and proxy of array.\n        else if (pArr == nullptr || scriptContext->GetConfig()->IsES6SpeciesEnabled())\n        {\n            newObj = ArraySpeciesCreate(obj, length, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        }\n\n        if (newObj == nullptr)\n        {\n            if (length > UINT_MAX)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n            newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        Var element = nullptr;\n        Var mappedValue = nullptr;\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags callBackFnflags = CallFlags_Value;\n        CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);\n\n        // We at least have to have newObj as a valid object\n        Assert(newObj);\n\n        if (pArr != nullptr)\n        {\n            // If source is a JavascriptArray, newObj may or may not be an array based on what was in source's constructor property\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                // If newArr is a valid pointer, then we constructed an array to return. Otherwise we need to do generic object operations\n                if (newArr && isBuiltinArrayCtor)\n                {\n                    newArr->DirectSetItemAt(k, mappedValue);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);\n                }\n            }\n        }\n        else if (typedArrayBase != nullptr)\n        {\n            // Source is a TypedArray, we may have tried to call a constructor, but newObj may not be a TypedArray (or an array either)\n            TypedArrayBase* newTypedArray = nullptr;\n\n            if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                // We can't rely on the length value being equal to typedArrayBase->GetLength() because user code may lie and\n                // attach any length property to a TypedArray instance and pass it as this parameter when .calling\n                // Array.prototype.map.\n                if (!typedArrayBase->HasItem(k))\n                {\n                    // We know that if HasItem returns false, all the future calls to HasItem will return false as well since\n                    // we visit the items in order. We could return early here except that we have to continue calling HasItem\n                    // on all the subsequent items according to the spec.\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    obj);\n\n                // If newObj is a TypedArray, set the mappedValue directly, otherwise see if it's an array and finally fall back to\n                // the normal Set path.\n                if (newTypedArray)\n                {\n                    newTypedArray->DirectSetItem(k, mappedValue);\n                }\n                else if (newArr)\n                {\n                    newArr->DirectSetItemAt(k, mappedValue);\n                }\n                else\n                {\n                    JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue);\n                }\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (newArr && isBuiltinArrayCtor)\n                    {\n                        newArr->SetItem(k, mappedValue, PropertyOperation_None);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);\n                    }\n                }\n            }\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (JavascriptArray::Is(newObj))\n        {\n            newArr->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryFilter(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.filter\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_filter);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* dynamicObject = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            dynamicObject = pArr;\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::FilterHelper(pArr, dynamicObject, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::FilterHelper(pArr, dynamicObject, length.GetBigIndex(), args, scriptContext);\n    }\n\n    template <typename T>\n    Var JavascriptArray::FilterHelper(JavascriptArray* pArr, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.filter\"));\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If the source object is an Array exotic object we should try to load the constructor property and use it to construct the return object.\n        bool isBuiltinArrayCtor = true;\n        RecyclableObject* newObj = ArraySpeciesCreate(obj, 0, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        JavascriptArray* newArr = nullptr;\n\n        if (newObj == nullptr)\n        {\n            newArr = scriptContext->GetLibrary()->CreateArray(0);\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        Var element = nullptr;\n        Var selected = nullptr;\n\n        if (pArr)\n        {\n            Assert(length <= MaxArrayLength);\n            uint32 i = 0;\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                selected = CALL_ENTRYPOINT(callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),\n                    thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(selected, scriptContext))\n                {\n                    // Try to fast path if the return object is an array\n                    if (newArr && isBuiltinArrayCtor)\n                    {\n                        newArr->DirectSetItemAt(i, element);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                    }\n                    ++i;\n                }\n            }\n        }\n        else\n        {\n            BigIndex i = 0u;\n\n            for (T k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    selected = CALL_ENTRYPOINT(callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),\n                        thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (JavascriptConversion::ToBoolean(selected, scriptContext))\n                    {\n                        if (newArr)\n                        {\n                            newArr->DirectSetItemAt(i, element);\n                        }\n                        else\n                        {\n                            ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                        }\n                        ++i;\n                    }\n                }\n            }\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (newArr)\n        {\n            newArr->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryReduce(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduce\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduce);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));\n        }\n\n        BigIndex length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));\n            }\n\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n            }\n        }\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.reduce as described in ES6.0 (draft 22) Section 22.1.3.18\n    template <typename T>\n    Var JavascriptArray::ReduceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduce\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduce\"));\n            }\n        }\n\n        // If we came from Array.prototype.reduce and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        T k = 0;\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var accumulator = nullptr;\n        Var element = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            accumulator = args[2];\n        }\n        else\n        {\n            if (length == 0)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n            bool bPresent = false;\n\n            if (pArr)\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (!pArr->DirectGetItemAtFull((uint32)k, &element))\n                    {\n                        continue;\n                    }\n\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else if (typedArrayBase)\n            {\n                Assert(length <= UINT_MAX);\n\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (!typedArrayBase->HasItem((uint32)k))\n                    {\n                        continue;\n                    }\n\n                    element = typedArrayBase->DirectGetItem((uint32)k);\n\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (JavascriptOperators::HasItem(obj, k))\n                    {\n                        accumulator = JavascriptOperators::GetItem(obj, k, scriptContext);\n                        bPresent = true;\n                    }\n                }\n            }\n\n            if (bPresent == false)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n        }\n\n        Assert(accumulator);\n\n        Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        if (pArr)\n        {\n            for (; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull((uint32)k, &element))\n                {\n                    continue;\n                }\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n            for (; k < length; k++)\n            {\n                if (!typedArrayBase->HasItem((uint32)k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem((uint32)k);\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n            }\n        }\n        else\n        {\n            for (; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n\n                    accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                        accumulator,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n                }\n            }\n        }\n\n        return accumulator;\n    }\n\n    Var JavascriptArray::EntryReduceRight(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduceRight\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduceRight);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));\n        }\n\n        BigIndex length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.reduceRight as described in ES6.0 (draft 22) Section 22.1.3.19\n    template <typename T>\n    Var JavascriptArray::ReduceRightHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduceRight\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduceRight\"));\n            }\n        }\n\n        // If we came from Array.prototype.reduceRight and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var accumulator = nullptr;\n        Var element = nullptr;\n        T k = 0;\n        T index = 0;\n\n        if (args.Info.Count > 2)\n        {\n            accumulator = args[2];\n        }\n        else\n        {\n            if (length == 0)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n            bool bPresent = false;\n            if (pArr)\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (!pArr->DirectGetItemAtFull((uint32)index, &element))\n                    {\n                        continue;\n                    }\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else if (typedArrayBase)\n            {\n                Assert(length <= UINT_MAX);\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (!typedArrayBase->HasItem((uint32)index))\n                    {\n                        continue;\n                    }\n                    element = typedArrayBase->DirectGetItem((uint32)index);\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (JavascriptOperators::HasItem(obj, index))\n                    {\n                        accumulator = JavascriptOperators::GetItem(obj, index, scriptContext);\n                        bPresent = true;\n                    }\n                }\n            }\n            if (bPresent == false)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();\n\n        if (pArr)\n        {\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (!pArr->DirectGetItemAtFull((uint32)index, &element))\n                {\n                    continue;\n                }\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(index, scriptContext),\n                    pArr);\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (!typedArrayBase->HasItem((uint32) index))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem((uint32)index);\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(index, scriptContext),\n                    typedArrayBase);\n            }\n        }\n        else\n        {\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (JavascriptOperators::HasItem(obj, index))\n                {\n                    element = JavascriptOperators::GetItem(obj, index, scriptContext);\n                    accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                        accumulator,\n                        element,\n                        JavascriptNumber::ToVar(index, scriptContext),\n                        obj);\n                }\n            }\n        }\n\n        return accumulator;\n    }\n\n    Var JavascriptArray::EntryFrom(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.from\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        RecyclableObject* constructor = nullptr;\n\n        if (JavascriptOperators::IsConstructor(args[0]))\n        {\n            constructor = RecyclableObject::FromVar(args[0]);\n        }\n\n        RecyclableObject* items = nullptr;\n\n        if (args.Info.Count < 2 || !JavascriptConversion::ToObject(args[1], scriptContext, &items))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedObject, _u(\"Array.from\"));\n        }\n\n        JavascriptArray* itemsArr = nullptr;\n\n        if (JavascriptArray::Is(items))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(items);\n#endif\n            itemsArr = JavascriptArray::FromVar(items);\n        }\n\n        bool mapping = false;\n        JavascriptFunction* mapFn = nullptr;\n        Var mapFnThisArg = nullptr;\n\n        if (args.Info.Count >= 3 && !JavascriptOperators::IsUndefinedObject(args[2]))\n        {\n            if (!JavascriptFunction::Is(args[2]))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.from\"));\n            }\n\n            mapFn = JavascriptFunction::FromVar(args[2]);\n\n            if (args.Info.Count >= 4)\n            {\n                mapFnThisArg = args[3];\n            }\n            else\n            {\n                mapFnThisArg = library->GetUndefined();\n            }\n\n            mapping = true;\n        }\n\n        RecyclableObject* newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n\n        RecyclableObject* iterator = JavascriptOperators::GetIterator(items, scriptContext, true /* optional */);\n\n        if (iterator != nullptr)\n        {\n            if (constructor)\n            {\n                Js::Var constructorArgs[] = { constructor };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            {\n                newArr = scriptContext->GetLibrary()->CreateArray(0);\n                newArr->EnsureHead<Var>();\n                newObj = newArr;\n            }\n\n            uint32 k = 0;\n\n            JavascriptOperators::DoIteratorStepAndValue(iterator, scriptContext, [&](Var nextValue) {\n                if (mapping)\n                {\n                    Assert(mapFn != nullptr);\n                    Assert(mapFnThisArg != nullptr);\n\n                    Js::Var mapFnArgs[] = { mapFnThisArg, nextValue, JavascriptNumber::ToVar(k, scriptContext) };\n                    Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));\n                    nextValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));\n                }\n\n                if (newArr)\n                {\n                    newArr->SetItem(k, nextValue, PropertyOperation_None);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, nextValue), scriptContext, k);\n                }\n\n                k++;\n            });\n\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(k, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n        else\n        {\n            Var lenValue = JavascriptOperators::OP_GetLength(items, scriptContext);\n            int64 len = JavascriptConversion::ToLength(lenValue, scriptContext);\n\n            if (constructor)\n            {\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            {\n                // Abstract operation ArrayCreate throws RangeError if length argument is > 2^32 -1\n                if (len > MaxArrayLength)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect, _u(\"Array.from\"));\n                }\n\n                // Static cast len should be valid (len < 2^32) or we would throw above\n                newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(len));\n                newArr->EnsureHead<Var>();\n                newObj = newArr;\n            }\n\n            uint32 k = 0;\n\n            for ( ; k < len; k++)\n            {\n                Var kValue;\n\n                if (itemsArr)\n                {\n                    kValue = itemsArr->DirectGetItem(k);\n                }\n                else\n                {\n                    kValue = JavascriptOperators::OP_GetElementI_UInt32(items, k, scriptContext);\n                }\n\n                if (mapping)\n                {\n                    Assert(mapFn != nullptr);\n                    Assert(mapFnThisArg != nullptr);\n\n                    Js::Var mapFnArgs[] = { mapFnThisArg, kValue, JavascriptNumber::ToVar(k, scriptContext) };\n                    Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));\n                    kValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));\n                }\n\n                if (newArr)\n                {\n                    newArr->SetItem(k, kValue, PropertyOperation_None);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k);\n                }\n            }\n\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.of\"));\n        }\n\n        return JavascriptArray::OfHelper(false, args, scriptContext);\n    }\n\n    Var JavascriptArray::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n\n        Assert(args.Info.Count > 0);\n\n        return args[0];\n    }\n\n    // Array.of and %TypedArray%.of as described in ES6.0 (draft 22) Section 22.1.2.2 and 22.2.2.2\n    Var JavascriptArray::OfHelper(bool isTypedArrayEntryPoint, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        // args.Info.Count cannot equal zero or we would have thrown above so no chance of underflowing\n        uint32 len = args.Info.Count - 1;\n        Var newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n        TypedArrayBase* newTypedArray = nullptr;\n        bool isBuiltinArrayCtor = true;\n\n        if (JavascriptOperators::IsConstructor(args[0]))\n        {\n            RecyclableObject* constructor = RecyclableObject::FromVar(args[0]);\n            isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());\n\n            Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };\n            Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n            newObj = isTypedArrayEntryPoint ?\n                TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), len, scriptContext) :\n                JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext);\n\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n            else if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n        }\n        else\n        {\n            // We only throw when the constructor property is not a constructor function in the TypedArray version\n            if (isTypedArrayEntryPoint)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedFunction, _u(\"[TypedArray].of\"));\n            }\n\n            newArr = scriptContext->GetLibrary()->CreateArray(len);\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n\n        // At least we have a new object of some kind\n        Assert(newObj);\n\n        if (isBuiltinArrayCtor)\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n\n                newArr->DirectSetItemAt(k, kValue);\n            }\n        }\n        else if (newTypedArray)\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n\n                newTypedArray->DirectSetItem(k, kValue);\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n                ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k);\n            }\n        }\n\n        if (!isTypedArrayEntryPoint)\n        {\n            // Set length if we are in the Array version of the function\n            JavascriptOperators::OP_SetProperty(newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, nullptr, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n        return newObj;\n    }\n\n    JavascriptString* JavascriptArray::ToLocaleStringHelper(Var value, ScriptContext* scriptContext)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(value);\n        if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n        else\n        {\n            return JavascriptConversion::ToLocaleString(value, scriptContext);\n        }\n    }\n\n    inline BOOL JavascriptArray::IsFullArray() const\n    {\n        if (head && head->length == length)\n        {\n            AssertMsg(head->next == 0 && head->left == 0, \"Invalid Array\");\n            return true;\n        }\n        return (0 == length);\n    }\n\n    /*\n    *   IsFillFromPrototypes\n    *   -   Check the array has no missing values and only head segment.\n    *   -   Also ensure if the lengths match.\n    */\n    bool JavascriptArray::IsFillFromPrototypes()\n    {\n        return !(this->head->next == nullptr && this->HasNoMissingValues() && this->length == this->head->length);\n    }\n\n    // Fill all missing value in the array and fill it from prototype between startIndex and limitIndex\n    // typically startIndex = 0 and limitIndex = length. From start of the array till end of the array.\n    void JavascriptArray::FillFromPrototypes(uint32 startIndex, uint32 limitIndex)\n    {\n        if (startIndex >= limitIndex)\n        {\n            return;\n        }\n\n        RecyclableObject* prototype = this->GetPrototype();\n\n        // Fill all missing values by walking through prototype\n        while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(this, nullptr, prototype, startIndex, limitIndex,0, [this](uint32 index, Var value) {\n                this->SetItem(index, value, PropertyOperation_None);\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n    }\n\n    //\n    // JavascriptArray requires head->left == 0 for fast path Get.\n    //\n    template<typename T>\n    void JavascriptArray::EnsureHeadStartsFromZero(Recycler * recycler)\n    {\n        if (head == nullptr || head->left != 0)\n        {\n            // This is used to fix up altered arrays.\n            // any SegmentMap would be invalid at this point.\n            ClearSegmentMap();\n\n            //\n            // We could OOM and throw when allocating new empty head, resulting in a corrupted array. Need\n            // some protection here. Save the head and switch this array to EmptySegment. Will be restored\n            // correctly if allocating new segment succeeds.\n            //\n            SparseArraySegment<T>* savedHead = (SparseArraySegment<T>*)this->head;\n            SparseArraySegment<T>* savedLastUsedSegment = (SparseArraySegment<T>*)this->GetLastUsedSegment();\n            SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase*>(EmptySegment));\n\n            SparseArraySegment<T> *newSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, 0, savedHead);\n            newSeg->next = savedHead;\n            this->head = newSeg;\n            SetHasNoMissingValues();\n            this->SetLastUsedSegment(savedLastUsedSegment);\n        }\n    }\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    void JavascriptArray::CheckForceES5Array()\n    {\n        if (Configuration::Global.flags.ForceES5Array)\n        {\n            // There's a bad interaction with the jitted code for native array creation here.\n            // ForceES5Array doesn't interact well with native arrays\n            if (PHASE_OFF1(NativeArrayPhase))\n            {\n                GetTypeHandler()->ConvertToTypeWithItemAttributes(this);\n            }\n        }\n    }\n#endif\n\n    template <typename T, typename Fn>\n    void JavascriptArray::ForEachOwnMissingArrayIndexOfObject(JavascriptArray *baseArray, JavascriptArray *destArray, RecyclableObject* obj, uint32 startIndex, uint32 limitIndex, T destIndex, Fn fn)\n    {\n        Assert(DynamicObject::IsAnyArray(obj) || JavascriptOperators::IsObject(obj));\n\n        Var oldValue;\n        JavascriptArray* arr = nullptr;\n        if (DynamicObject::IsAnyArray(obj))\n        {\n            arr = JavascriptArray::FromAnyArray(obj);\n        }\n        else if (DynamicType::Is(obj->GetTypeId()))\n        {\n            DynamicObject* dynobj = DynamicObject::FromVar(obj);\n            ArrayObject* objectArray = dynobj->GetObjectArray();\n            arr = (objectArray && JavascriptArray::IsAnyArray(objectArray)) ? JavascriptArray::FromAnyArray(objectArray) : nullptr;\n        }\n\n        if (arr != nullptr)\n        {\n            if (JavascriptArray::Is(arr))\n            {\n                arr = EnsureNonNativeArray(arr);\n                ArrayElementEnumerator e(arr, startIndex, limitIndex);\n\n                while(e.MoveNext<Var>())\n                {\n                    uint32 index = e.GetIndex();\n                    if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))\n                    {\n                        T n = destIndex + (index - startIndex);\n                        if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))\n                        {\n                            fn(index, e.GetItem<Var>());\n                        }\n                    }\n                }\n            }\n            else\n            {\n                ScriptContext* scriptContext = obj->GetScriptContext();\n\n                Assert(ES5Array::Is(arr));\n\n                ES5Array* es5Array = ES5Array::FromVar(arr);\n                ES5ArrayIndexStaticEnumerator<true> e(es5Array);\n\n                while (e.MoveNext())\n                {\n                    uint32 index = e.GetIndex();\n                    if (index < startIndex) continue;\n                    else if (index >= limitIndex) break;\n\n                    if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))\n                    {\n                        T n = destIndex + (index - startIndex);\n                        if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))\n                        {\n                            Var value = nullptr;\n                            if (JavascriptOperators::GetOwnItem(obj, index, &value, scriptContext))\n                            {\n                                fn(index, value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //\n    // ArrayElementEnumerator to enumerate array elements (not including elements from prototypes).\n    //\n    JavascriptArray::ArrayElementEnumerator::ArrayElementEnumerator(JavascriptArray* arr, uint32 start, uint32 end)\n        : start(start), end(min(end, arr->length))\n    {\n        Init(arr);\n    }\n\n    //\n    // Initialize this enumerator and prepare for the first MoveNext.\n    //\n    void JavascriptArray::ArrayElementEnumerator::Init(JavascriptArray* arr)\n    {\n        // Find start segment\n        seg = (arr ? arr->GetBeginLookupSegment(start) : nullptr);\n        while (seg && (seg->left + seg->length <= start))\n        {\n            seg = seg->next;\n        }\n\n        // Set start index and endIndex\n        if (seg)\n        {\n            if (seg->left >= end)\n            {\n                seg = nullptr;\n            }\n            else\n            {\n                // set index to be at target index - 1, so MoveNext will move to target\n                index = max(seg->left, start) - seg->left - 1;\n                endIndex = min(end - seg->left, seg->length);\n            }\n        }\n    }\n\n    //\n    // Move to the next element if available.\n    //\n    template<typename T>\n    inline bool JavascriptArray::ArrayElementEnumerator::MoveNext()\n    {\n        while (seg)\n        {\n            // Look for next non-null item in current segment\n            while (++index < endIndex)\n            {\n                if (!SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]))\n                {\n                    return true;\n                }\n            }\n\n            // Move to next segment\n            seg = seg->next;\n            if (seg)\n            {\n                if (seg->left >= end)\n                {\n                    seg = nullptr;\n                    break;\n                }\n                else\n                {\n                    index = static_cast<uint32>(-1);\n                    endIndex = min(end - seg->left, seg->length);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    //\n    // Get current array element index.\n    //\n    uint32 JavascriptArray::ArrayElementEnumerator::GetIndex() const\n    {\n        Assert(seg && index < seg->length && index < endIndex);\n        return seg->left + index;\n    }\n\n    //\n    // Get current array element value.\n    //\n    template<typename T>\n    T JavascriptArray::ArrayElementEnumerator::GetItem() const\n    {\n        Assert(seg && index < seg->length && index < endIndex &&\n               !SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]));\n        return ((SparseArraySegment<T>*)seg)->elements[index];\n    }\n\n    //\n    // Construct a BigIndex initialized to a given uint32 (small index).\n    //\n    JavascriptArray::BigIndex::BigIndex(uint32 initIndex)\n        : index(initIndex), bigIndex(InvalidIndex)\n    {\n        //ok if initIndex == InvalidIndex\n    }\n\n    //\n    // Construct a BigIndex initialized to a given uint64 (large or small index).\n    //\n    JavascriptArray::BigIndex::BigIndex(uint64 initIndex)\n        : index(InvalidIndex), bigIndex(initIndex)\n    {\n        if (bigIndex < InvalidIndex) // if it's actually small index\n        {\n            index = static_cast<uint32>(bigIndex);\n            bigIndex = InvalidIndex;\n        }\n    }\n\n    bool JavascriptArray::BigIndex::IsUint32Max() const\n    {\n        return index == InvalidIndex && bigIndex == InvalidIndex;\n    }\n    bool JavascriptArray::BigIndex::IsSmallIndex() const\n    {\n        return index < InvalidIndex;\n    }\n\n    uint32 JavascriptArray::BigIndex::GetSmallIndex() const\n    {\n        Assert(IsSmallIndex());\n        return index;\n    }\n\n    uint64 JavascriptArray::BigIndex::GetBigIndex() const\n    {\n        Assert(!IsSmallIndex());\n        return bigIndex;\n    }\n    //\n    // Convert this index value to a JS number\n    //\n    Var JavascriptArray::BigIndex::ToNumber(ScriptContext* scriptContext) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::ToNumber(index, scriptContext);\n        }\n        else\n        {\n            return JavascriptNumber::ToVar(bigIndex, scriptContext);\n        }\n    }\n\n    //\n    // Increment this index by 1.\n    //\n    const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator++()\n    {\n        if (IsSmallIndex())\n        {\n            ++index;\n            // If index reaches InvalidIndex, we will start to use bigIndex which is initially InvalidIndex.\n        }\n        else\n        {\n            bigIndex = bigIndex + 1;\n        }\n\n        return *this;\n    }\n\n    //\n    // Decrement this index by 1.\n    //\n    const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator--()\n    {\n        if (IsSmallIndex())\n        {\n            --index;\n        }\n        else\n        {\n            Assert(index == InvalidIndex && bigIndex >= InvalidIndex);\n\n            --bigIndex;\n            if (bigIndex < InvalidIndex)\n            {\n                index = InvalidIndex - 1;\n                bigIndex = InvalidIndex;\n            }\n        }\n\n        return *this;\n    }\n\n    JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(const BigIndex& delta) const\n    {\n        if (delta.IsSmallIndex())\n        {\n            return operator+(delta.GetSmallIndex());\n        }\n        if (IsSmallIndex())\n        {\n            return index + delta.GetBigIndex();\n        }\n\n        return bigIndex + delta.GetBigIndex();\n    }\n\n    //\n    // Get a new BigIndex representing this + delta.\n    //\n    JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(uint32 delta) const\n    {\n        if (IsSmallIndex())\n        {\n            uint32 newIndex;\n            if (UInt32Math::Add(index, delta, &newIndex))\n            {\n                return static_cast<uint64>(index) + static_cast<uint64>(delta);\n            }\n            else\n            {\n                return newIndex; // ok if newIndex == InvalidIndex\n            }\n        }\n        else\n        {\n            return bigIndex + static_cast<uint64>(delta);\n        }\n    }\n\n    bool JavascriptArray::BigIndex::operator==(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() == rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() == (uint64) rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) == rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() == rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator> (const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() > rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() > (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) > rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() > rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator< (const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() < rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() < (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) < rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() < rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator<=(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() <= rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() <= (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) <= rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() <= rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator>=(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() >= rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() >= (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) >= rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() >= rhs.GetBigIndex();\n    }\n\n    BOOL JavascriptArray::BigIndex::GetItem(JavascriptArray* arr, Var* outVal) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::GetItem(arr, index, outVal);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->GetProperty(arr, propertyRecord->GetPropertyId(), outVal, NULL, scriptContext);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::SetItem(JavascriptArray* arr, Var newValue) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::SetItem(arr, index, newValue);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->SetProperty(propertyRecord->GetPropertyId(), newValue, PropertyOperation_None, NULL);\n        }\n    }\n\n    void JavascriptArray::BigIndex::SetItemIfNotExist(JavascriptArray* arr, Var newValue) const\n    {\n        if (IsSmallIndex())\n        {\n            small_index::SetItemIfNotExist(arr, index, newValue);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            Var oldValue;\n            PropertyId propertyId = propertyRecord->GetPropertyId();\n            if (!arr->GetProperty(arr, propertyId, &oldValue, NULL, scriptContext))\n            {\n                arr->SetProperty(propertyId, newValue, PropertyOperation_None, NULL);\n            }\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::DeleteItem(JavascriptArray* arr) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::DeleteItem(arr, index);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->DeleteProperty(propertyRecord->GetPropertyId(), PropertyOperation_None);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::SetItem(RecyclableObject* obj, Var newValue, PropertyOperationFlags flags) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::SetItem(obj, index, newValue, flags);\n        }\n        else\n        {\n            ScriptContext* scriptContext = obj->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return JavascriptOperators::SetProperty(obj, obj, propertyRecord->GetPropertyId(), newValue, scriptContext, flags);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::DeleteItem(RecyclableObject* obj, PropertyOperationFlags flags) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::DeleteItem(obj, index, flags);\n        }\n        else\n        {\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, obj->GetScriptContext(), &propertyRecord);\n            return JavascriptOperators::DeleteProperty(obj, propertyRecord->GetPropertyId(), flags);\n        }\n    }\n\n    //\n    // Truncate the array at start and clone the truncated span as properties starting at dstIndex (asserting dstIndex >= MaxArrayLength).\n    //\n    void JavascriptArray::TruncateToProperties(const BigIndex& dstIndex, uint32 start)\n    {\n        Assert(!dstIndex.IsSmallIndex());\n        typedef IndexTrace<BigIndex> index_trace;\n\n        BigIndex dst = dstIndex;\n        uint32 i = start;\n\n        ArrayElementEnumerator e(this, start);\n        while(e.MoveNext<Var>())\n        {\n            // delete all items not enumerated\n            while (i < e.GetIndex())\n            {\n                index_trace::DeleteItem(this, dst);\n                ++i;\n                ++dst;\n            }\n\n            // Copy over the item\n            index_trace::SetItem(this, dst, e.GetItem<Var>());\n            ++i;\n            ++dst;\n        }\n\n        // Delete the rest till length\n        while (i < this->length)\n        {\n            index_trace::DeleteItem(this, dst);\n            ++i;\n            ++dst;\n        }\n\n        // Elements moved, truncate the array at start\n        SetLength(start);\n    }\n\n    //\n    // Copy a srcArray elements (including elements from prototypes) to a dstArray starting from an index.\n    //\n    template<typename T>\n    void JavascriptArray::InternalCopyArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<Var>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<Var>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    //\n    // Copy a srcArray elements (including elements from prototypes) to a dstArray starting from an index. If the index grows larger than\n    // \"array index\", it will automatically turn to SetProperty using the index as property name.\n    //\n    void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, uint32 dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    template <typename T>\n    void JavascriptArray::CopyAnyArrayElementsToVar(JavascriptArray* dstArray, T dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(srcArray);\n#endif\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(dstArray);\n#endif\n        if (JavascriptNativeIntArray::Is(srcArray))\n        {\n            CopyNativeIntArrayElementsToVar(dstArray, dstIndex, JavascriptNativeIntArray::FromVar(srcArray), start, end);\n        }\n        else if (JavascriptNativeFloatArray::Is(srcArray))\n        {\n            CopyNativeFloatArrayElementsToVar(dstArray, dstIndex, JavascriptNativeFloatArray::FromVar(srcArray), start, end);\n        }\n        else\n        {\n            CopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyNativeIntArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    bool JavascriptArray::CopyNativeIntArrayElements(JavascriptNativeIntArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<int32>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeIntArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool JavascriptArray::CopyNativeIntArrayElementsToFloat(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, (double)e.GetItem<int32>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyNativeFloatArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    bool JavascriptArray::CopyNativeFloatArrayElements(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<double>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<double>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    JavascriptArray *JavascriptArray::EnsureNonNativeArray(JavascriptArray *arr)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arr);\n#endif\n        if (JavascriptNativeIntArray::Is(arr))\n        {\n            arr = JavascriptNativeIntArray::ToVarArray((JavascriptNativeIntArray*)arr);\n        }\n        else if (JavascriptNativeFloatArray::Is(arr))\n        {\n            arr = JavascriptNativeFloatArray::ToVarArray((JavascriptNativeFloatArray*)arr);\n        }\n\n        return arr;\n    }\n\n    BOOL JavascriptNativeIntArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        ScriptContext* requestContext = type->GetScriptContext();\n        if (JavascriptNativeIntArray::GetItem(this, index, outVal, requestContext))\n        {\n            return TRUE;\n        }\n\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        ScriptContext* requestContext = type->GetScriptContext();\n        if (JavascriptNativeFloatArray::GetItem(this, index, outVal, requestContext))\n        {\n            return TRUE;\n        }\n\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalCopyNativeIntArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ScriptContext *scriptContext = dstArray->GetScriptContext();\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, JavascriptNumber::ToVar(e.GetItem<int32>(), scriptContext));\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalCopyNativeFloatArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ScriptContext *scriptContext = dstArray->GetScriptContext();\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<double>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, JavascriptNumber::ToVarWithCheck(e.GetItem<double>(), scriptContext));\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    Var JavascriptArray::SpreadArrayArgs(Var arrayToSpread, const Js::AuxArray<uint32> *spreadIndices, ScriptContext *scriptContext)\n    {\n        // At this stage we have an array literal with some arguments to be spread.\n        // First we need to calculate the real size of the final literal.\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arrayToSpread);\n#endif\n        JavascriptArray *array = FromVar(arrayToSpread);\n        uint32 actualLength = array->GetLength();\n\n        for (unsigned i = 0; i < spreadIndices->count; ++i)\n        {\n            actualLength = UInt32Math::Add(actualLength - 1, GetSpreadArgLen(array->DirectGetItem(spreadIndices->elements[i]), scriptContext));\n        }\n\n        JavascriptArray *result = FromVar(OP_NewScArrayWithMissingValues(actualLength, scriptContext));\n\n        // Now we copy each element and expand the spread parameters inline.\n        for (unsigned i = 0, spreadArrIndex = 0, resultIndex = 0; i < array->GetLength() && resultIndex < actualLength; ++i)\n        {\n            uint32 spreadIndex = spreadIndices->elements[spreadArrIndex]; // The index of the next element to be spread.\n\n            // An array needs a slow copy if it is a cross-site object or we have missing values that need to be set to undefined.\n            auto needArraySlowCopy = [&](Var instance) {\n                if (JavascriptArray::Is(instance))\n                {\n                    JavascriptArray *arr = JavascriptArray::FromVar(instance);\n                    return arr->IsCrossSiteObject() || arr->IsFillFromPrototypes();\n                }\n                return false;\n            };\n\n            // Designed to have interchangeable arguments with CopyAnyArrayElementsToVar.\n            auto slowCopy = [&scriptContext, &needArraySlowCopy](JavascriptArray *dstArray, unsigned dstIndex, Var srcArray, uint32 start, uint32 end) {\n                Assert(needArraySlowCopy(srcArray) || ArgumentsObject::Is(srcArray) || TypedArrayBase::Is(srcArray) || JavascriptString::Is(srcArray));\n\n                RecyclableObject *propertyObject;\n                if (!JavascriptOperators::GetPropertyObject(srcArray, scriptContext, &propertyObject))\n                {\n                    JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidSpreadArgument);\n                }\n\n                for (uint32 j = start; j < end; j++)\n                {\n                    Var element;\n                    if (!JavascriptOperators::GetItem(srcArray, propertyObject, j, &element, scriptContext))\n                    {\n                        // Copy across missing values as undefined as per 12.2.5.2 SpreadElement : ... AssignmentExpression 5f.\n                        element = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    dstArray->DirectSetItemAt(dstIndex++, element);\n                }\n            };\n\n            if (i < spreadIndex)\n            {\n                // Any non-spread elements can be copied in bulk.\n\n                if (needArraySlowCopy(array))\n                {\n                    slowCopy(result, resultIndex, (Var)array, i, spreadIndex);\n                }\n                else\n                {\n                    CopyAnyArrayElementsToVar(result, resultIndex, array, i, spreadIndex);\n                }\n                resultIndex += spreadIndex - i;\n                i = spreadIndex - 1;\n                continue;\n            }\n            else if (i > spreadIndex)\n            {\n                // Any non-spread elements terminating the array can also be copied in bulk.\n                Assert(spreadArrIndex == spreadIndices->count - 1);\n                if (needArraySlowCopy(array))\n                {\n                    slowCopy(result, resultIndex, array, i, array->GetLength());\n                }\n                else\n                {\n                    CopyAnyArrayElementsToVar(result, resultIndex, array, i, array->GetLength());\n                }\n                break;\n            }\n            else\n            {\n                Var instance = array->DirectGetItem(i);\n\n                if (SpreadArgument::Is(instance))\n                {\n                    SpreadArgument* spreadArgument = SpreadArgument::FromVar(instance);\n                    uint32 len = spreadArgument->GetArgumentSpreadCount();\n                    const Var*  spreadItems = spreadArgument->GetArgumentSpread();\n                    for (uint32 j = 0; j < len; j++)\n                    {\n                        result->DirectSetItemAt(resultIndex++, spreadItems[j]);\n                    }\n\n                }\n                else\n                {\n                    AssertMsg(JavascriptArray::Is(instance) || TypedArrayBase::Is(instance), \"Only SpreadArgument, TypedArray, and JavascriptArray should be listed as spread arguments\");\n\n                    // We first try to interpret the spread parameter as a JavascriptArray.\n                    JavascriptArray *arr = nullptr;\n                    if (JavascriptArray::Is(instance))\n                    {\n                        arr = JavascriptArray::FromVar(instance);\n                    }\n\n                    if (arr != nullptr)\n                    {\n                        if (arr->GetLength() > 0)\n                        {\n                            if (needArraySlowCopy(arr))\n                            {\n                                slowCopy(result, resultIndex, arr, 0, arr->GetLength());\n                            }\n                            else\n                            {\n                                CopyAnyArrayElementsToVar(result, resultIndex, arr, 0, arr->GetLength());\n                            }\n                            resultIndex += arr->GetLength();\n                        }\n                    }\n                    else\n                    {\n                        uint32 len = GetSpreadArgLen(instance, scriptContext);\n                        slowCopy(result, resultIndex, instance, 0, len);\n                        resultIndex += len;\n                    }\n                }\n\n                if (spreadArrIndex < spreadIndices->count - 1)\n                {\n                    spreadArrIndex++;\n                }\n            }\n        }\n        return result;\n    }\n\n    uint32 JavascriptArray::GetSpreadArgLen(Var spreadArg, ScriptContext *scriptContext)\n    {\n        // A spread argument can be anything that returns a 'length' property, even if that\n        // property is null or undefined.\n        spreadArg = CrossSite::MarshalVar(scriptContext, spreadArg);\n        if (JavascriptArray::Is(spreadArg))\n        {\n            JavascriptArray *arr = JavascriptArray::FromVar(spreadArg);\n            return arr->GetLength();\n        }\n\n        if (TypedArrayBase::Is(spreadArg))\n        {\n            TypedArrayBase *tarr = TypedArrayBase::FromVar(spreadArg);\n            return tarr->GetLength();\n        }\n\n        if (SpreadArgument::Is(spreadArg))\n        {\n            SpreadArgument *spreadFunctionArgs = SpreadArgument::FromVar(spreadArg);\n            return spreadFunctionArgs->GetArgumentSpreadCount();\n        }\n\n        AssertMsg(false, \"LdCustomSpreadIteratorList should have converted the arg to one of the above types\");\n        Throw::FatalInternalError();\n    }\n\n#ifdef VALIDATE_ARRAY\n    class ArraySegmentsVisitor\n    {\n    private:\n        SparseArraySegmentBase* seg;\n\n    public:\n        ArraySegmentsVisitor(SparseArraySegmentBase* head)\n            : seg(head)\n        {\n        }\n\n        void operator()(SparseArraySegmentBase* s)\n        {\n            Assert(seg == s);\n            if (seg)\n            {\n                seg = seg->next;\n            }\n        }\n    };\n\n    void JavascriptArray::ValidateArrayCommon()\n    {\n        SparseArraySegmentBase * lastUsedSegment = this->GetLastUsedSegment();\n        AssertMsg(this != nullptr && head && lastUsedSegment, \"Array should not be null\");\n        AssertMsg(head->left == 0, \"Array always should have a segment starting at zero\");\n\n        // Simple segments validation\n        bool foundLastUsedSegment = false;\n        SparseArraySegmentBase *seg = head;\n        while(seg != nullptr)\n        {\n            if (seg == lastUsedSegment)\n            {\n                foundLastUsedSegment = true;\n            }\n\n            AssertMsg(seg->length <= seg->size , \"Length greater than size not possible\");\n\n            SparseArraySegmentBase* next = seg->next;\n            if (next != nullptr)\n            {\n                AssertMsg(seg->left < next->left, \"Segment is adjacent to or overlaps with next segment\");\n                AssertMsg(seg->size <= (next->left - seg->left), \"Segment is adjacent to or overlaps with next segment\");\n                AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n            }\n            else\n            {\n                AssertMsg(seg->length <= MaxArrayLength - seg->left, \"Segment index range overflow\");\n                AssertMsg(seg->left + seg->length <= this->length, \"Segment index range exceeds array length\");\n            }\n\n            seg = next;\n        }\n        AssertMsg(foundLastUsedSegment || HasSegmentMap(), \"Corrupt lastUsedSegment in array header\");\n\n        // Validate segmentMap if present\n        if (HasSegmentMap())\n        {\n            ArraySegmentsVisitor visitor(head);\n            GetSegmentMap()->Walk(visitor);\n        }\n    }\n\n    void JavascriptArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateVarSegment((SparseArraySegment<Var>*)head);\n    }\n\n    void JavascriptNativeIntArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n#if DBG\n            SparseArraySegmentBase *seg = head;\n            while (seg)\n            {\n                if (seg->next != nullptr)\n                {\n                    AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n                }\n                seg = seg->next;\n            }\n#endif\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateSegment<int32>((SparseArraySegment<int32>*)head);\n    }\n\n    void JavascriptNativeFloatArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n#if DBG\n            SparseArraySegmentBase *seg = head;\n            while (seg)\n            {\n                if (seg->next != nullptr)\n                {\n                    AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n                }\n                seg = seg->next;\n            }\n#endif\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateSegment<double>((SparseArraySegment<double>*)head);\n    }\n\n\n    void JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>* seg)\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n        int32 inspect;\n        double inspectDouble;\n        while (seg)\n        {\n            uint32 i = 0;\n            for (i = 0; i < seg->length; i++)\n            {\n                if (SparseArraySegment<Var>::IsMissingItem(&seg->elements[i]))\n                {\n                    continue;\n                }\n                if (TaggedInt::Is(seg->elements[i]))\n                {\n                    inspect = TaggedInt::ToInt32(seg->elements[i]);\n\n                }\n                else if (JavascriptNumber::Is_NoTaggedIntCheck(seg->elements[i]))\n                {\n                    inspectDouble = JavascriptNumber::GetValue(seg->elements[i]);\n                }\n                else\n                {\n                    AssertMsg(RecyclableObject::Is(seg->elements[i]), \"Invalid entry in segment\");\n                }\n            }\n            ValidateSegment(seg);\n\n            seg = (SparseArraySegment<Var>*)seg->next;\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::ValidateSegment(SparseArraySegment<T>* seg)\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n\n        while (seg)\n        {\n            uint32 i = seg->length;\n            while (i < seg->size)\n            {\n                AssertMsg(SparseArraySegment<T>::IsMissingItem(&seg->elements[i]), \"Non missing value the end of the segment\");\n                i++;\n            }\n\n            seg = (SparseArraySegment<T>*)seg->next;\n        }\n    }\n#endif\n\n    template <typename T>\n    void JavascriptArray::InitBoxedInlineHeadSegment(SparseArraySegment<T> * dst, SparseArraySegment<T> * src)\n    {\n        // Don't copy the segment map, we will build it again\n        SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n\n        SetHeadAndLastUsedSegment(dst);\n\n        dst->left = src->left;\n        dst->length = src->length;\n        dst->size = src->size;\n        dst->next = src->next;\n\n        js_memcpy_s(dst->elements, sizeof(T) * dst->size, src->elements, sizeof(T) * src->size);\n\n    }\n\n    JavascriptArray::JavascriptArray(JavascriptArray * instance, bool boxHead)\n        : ArrayObject(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, true>(this), (SparseArraySegment<Var>*)instance->head);\n        }\n        else\n        {\n\n            SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n            head = instance->head;\n            SetLastUsedSegment(instance->GetLastUsedSegment());\n        }\n    }\n\n    template <typename T>\n    T * JavascriptArray::BoxStackInstance(T * instance)\n    {\n        Assert(ThreadContext::IsOnStack(instance));\n        // On the stack, the we reserved a pointer before the object as to store the boxed value\n        T ** boxedInstanceRef = ((T **)instance) - 1;\n        T * boxedInstance = *boxedInstanceRef;\n        if (boxedInstance)\n        {\n            return boxedInstance;\n        }\n\n        const size_t inlineSlotsSize = instance->GetTypeHandler()->GetInlineSlotsSize();\n        if (ThreadContext::IsOnStack(instance->head))\n        {\n            boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(),\n                inlineSlotsSize + sizeof(Js::SparseArraySegmentBase) + instance->head->size * sizeof(typename T::TElement),\n                T, instance, true);\n        }\n        else if(inlineSlotsSize)\n        {\n            boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(), inlineSlotsSize, T, instance, false);\n        }\n        else\n        {\n            boxedInstance = RecyclerNew(instance->GetRecycler(), T, instance, false);\n        }\n\n        *boxedInstanceRef = boxedInstance;\n        return boxedInstance;\n    }\n\n    JavascriptArray *\n    JavascriptArray::BoxStackInstance(JavascriptArray * instance)\n    {\n        return BoxStackInstance<JavascriptArray>(instance);\n    }\n\n#if ENABLE_TTD\n    void JavascriptArray::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array || this->GetTypeId() == Js::TypeIds_ES5Array, \"Should only be used on basic arrays (or called as super from ES5Array.\");\n\n        ScriptContext* ctx = this->GetScriptContext();\n\n        uint32 index = Js::JavascriptArray::InvalidIndex;\n        while(true)\n        {\n            index = this->GetNextIndex(index);\n            if(index == Js::JavascriptArray::InvalidIndex) // End of array\n            {\n                break;\n            }\n\n            Js::Var aval = nullptr;\n            if(this->DirectGetVarItemAt(index, &aval, ctx))\n            {\n                extractor->MarkVisitVar(aval);\n            }\n        }\n    }\n\n    void JavascriptArray::ProcessCorePaths()\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic arrays.\");\n\n        ScriptContext* ctx = this->GetScriptContext();\n\n        uint32 index = Js::JavascriptArray::InvalidIndex;\n        while(true)\n        {\n            index = this->GetNextIndex(index);\n            if(index == Js::JavascriptArray::InvalidIndex) // End of array\n            {\n                break;\n            }\n\n            Js::Var aval = nullptr;\n            if(this->DirectGetVarItemAt(index, &aval, ctx))\n            {\n                TTD::UtilSupport::TTAutoString pathExt;\n                ctx->TTDWellKnownInfo->BuildArrayIndexBuffer(index, pathExt);\n\n                ctx->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, aval, pathExt.GetStrValue());\n            }\n        }\n    }\n\n    TTD::NSSnapObjects::SnapObjectType JavascriptArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapArrayObject;\n    }\n\n    void JavascriptArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic Js arrays.\");\n\n        TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>* sai = TTD::NSSnapObjects::ExtractArrayValues<TTD::TTDVar>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>*, TTD::NSSnapObjects::SnapObjectType::SnapArrayObject>(objData, sai);\n    }\n#endif\n\n    JavascriptNativeArray::JavascriptNativeArray(JavascriptNativeArray * instance) :\n        JavascriptArray(instance, false),\n        weakRefToFuncBody(instance->weakRefToFuncBody)\n    {\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(JavascriptNativeIntArray * instance, bool boxHead) :\n        JavascriptNativeArray(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>(this), (SparseArraySegment<int>*)instance->head);\n        }\n        else\n        {\n            // Base class ctor should have copied these\n            Assert(head == instance->head);\n            Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());\n        }\n    }\n\n    JavascriptNativeIntArray *\n    JavascriptNativeIntArray::BoxStackInstance(JavascriptNativeIntArray * instance)\n    {\n        return JavascriptArray::BoxStackInstance<JavascriptNativeIntArray>(instance);\n    }\n\n#if ENABLE_TTD\n    TTD::NSSnapObjects::SnapObjectType JavascriptNativeIntArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject;\n    }\n\n    void JavascriptNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTD::NSSnapObjects::SnapArrayInfo<int32>* sai = TTD::NSSnapObjects::ExtractArrayValues<int32>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<int32>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject>(objData, sai);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    TTD::NSSnapObjects::SnapObjectType JavascriptCopyOnAccessNativeIntArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::Invalid;\n    }\n\n    void JavascriptCopyOnAccessNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(false, \"Not implemented yet!!!\");\n    }\n#endif\n#endif\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(JavascriptNativeFloatArray * instance, bool boxHead) :\n        JavascriptNativeArray(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>(this), (SparseArraySegment<double>*)instance->head);\n        }\n        else\n        {\n            // Base class ctor should have copied these\n            Assert(head == instance->head);\n            Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());\n        }\n    }\n\n    JavascriptNativeFloatArray *\n    JavascriptNativeFloatArray::BoxStackInstance(JavascriptNativeFloatArray * instance)\n    {\n        return JavascriptArray::BoxStackInstance<JavascriptNativeFloatArray>(instance);\n    }\n\n#if ENABLE_TTD\n    TTD::NSSnapObjects::SnapObjectType JavascriptNativeFloatArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject;\n    }\n\n    void JavascriptNativeFloatArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_NativeFloatArray, \"Should only be used on native float arrays.\");\n\n        TTD::NSSnapObjects::SnapArrayInfo<double>* sai = TTD::NSSnapObjects::ExtractArrayValues<double>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<double>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject>(objData, sai);\n    }\n#endif\n\n    template<typename T>\n    RecyclableObject*\n    JavascriptArray::ArraySpeciesCreate(Var originalArray, T length, ScriptContext* scriptContext, bool *pIsIntArray, bool *pIsFloatArray, bool *pIsBuiltinArrayCtor)\n    {\n        if (originalArray == nullptr || !scriptContext->GetConfig()->IsES6SpeciesEnabled())\n        {\n            return nullptr;\n        }\n\n        if (JavascriptArray::Is(originalArray)\n            && !DynamicObject::FromVar(originalArray)->GetDynamicType()->GetTypeHandler()->GetIsNotPathTypeHandlerOrHasUserDefinedCtor()\n            && DynamicObject::FromVar(originalArray)->GetPrototype() == scriptContext->GetLibrary()->GetArrayPrototype()\n            && !scriptContext->GetLibrary()->GetArrayObjectHasUserDefinedSpecies())\n        {\n            return nullptr;\n        }\n\n        Var constructor = scriptContext->GetLibrary()->GetUndefined();\n\n        if (JavascriptOperators::IsArray(originalArray))\n        {\n            if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(originalArray), PropertyIds::constructor, &constructor, scriptContext))\n            {\n                return nullptr;\n            }\n\n            if (JavascriptOperators::IsConstructor(constructor))\n            {\n                ScriptContext* constructorScriptContext = RecyclableObject::FromVar(constructor)->GetScriptContext();\n                if (constructorScriptContext != scriptContext)\n                {\n                    if (constructorScriptContext->GetLibrary()->GetArrayConstructor() == constructor)\n                    {\n                        constructor = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                }\n            }\n\n            if (JavascriptOperators::IsObject(constructor))\n            {\n                if (!JavascriptOperators::GetProperty((RecyclableObject*)constructor, PropertyIds::_symbolSpecies, &constructor, scriptContext))\n                {\n                    if (pIsBuiltinArrayCtor != nullptr)\n                    {\n                        *pIsBuiltinArrayCtor = false;\n                    }\n\n                    return nullptr;\n                }\n                if (constructor == scriptContext->GetLibrary()->GetNull())\n                {\n                    constructor = scriptContext->GetLibrary()->GetUndefined();\n                }\n            }\n        }\n\n        if (constructor == scriptContext->GetLibrary()->GetUndefined() || constructor == scriptContext->GetLibrary()->GetArrayConstructor())\n        {\n            if (length > UINT_MAX)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n\n            if (nullptr == pIsIntArray)\n            {\n                return scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));\n            }\n            else\n            {\n                // If the constructor function is the built-in Array constructor, we can be smart and create the right type of native array.\n                JavascriptArray* pArr = JavascriptArray::FromVar(originalArray);\n                pArr->GetArrayTypeAndConvert(pIsIntArray, pIsFloatArray);\n                return CreateNewArrayHelper(static_cast<uint32>(length), *pIsIntArray, *pIsFloatArray, pArr, scriptContext);\n            }\n        }\n\n        if (!JavascriptOperators::IsConstructor(constructor))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"constructor[Symbol.species]\"));\n        }\n\n        if (pIsBuiltinArrayCtor != nullptr)\n        {\n            *pIsBuiltinArrayCtor = false;\n        }\n\n        Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };\n        Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n\n        return RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n    }\n    /*static*/\n    PropertyId const JavascriptArray::specialPropertyIds[] =\n    {\n        PropertyIds::length\n    };\n\n    BOOL JavascriptArray::DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::DeleteProperty(propertyId, flags);\n    }\n\n    BOOL JavascriptArray::DeleteProperty(JavascriptString *propertyNameString, PropertyOperationFlags flags)\n    {\n        JsUtil::CharacterBuffer<WCHAR> propertyName(propertyNameString->GetString(), propertyNameString->GetLength());\n        if (BuiltInPropertyRecords::length.Equals(propertyName))\n        {\n            return false;\n        }\n        return DynamicObject::DeleteProperty(propertyNameString, flags);\n    }\n\n    BOOL JavascriptArray::HasProperty(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return true;\n        }\n\n        ScriptContext* scriptContext = GetScriptContext();\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return this->HasItem(index);\n        }\n\n        return DynamicObject::HasProperty(propertyId);\n    }\n\n    BOOL JavascriptArray::IsEnumerable(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::IsEnumerable(propertyId);\n    }\n\n    BOOL JavascriptArray::IsConfigurable(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::IsConfigurable(propertyId);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetEnumerable(PropertyId propertyId, BOOL value)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(!value); // Can't change array length enumerable\n            return true;\n        }\n\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetEnumerable(this, propertyId, value);\n        }\n\n        return __super::SetEnumerable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetWritable(PropertyId propertyId, BOOL value)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n        uint32 index;\n\n        bool setLengthNonWritable = (propertyId == PropertyIds::length && !value);\n        if (setLengthNonWritable || scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetWritable(this, propertyId, value);\n        }\n\n        return __super::SetWritable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetConfigurable(PropertyId propertyId, BOOL value)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(!value); // Can't change array length configurable\n            return true;\n        }\n\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetConfigurable(this, propertyId, value);\n        }\n\n        return __super::SetConfigurable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetAttributes(PropertyId propertyId, PropertyAttributes attributes)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        // SetAttributes on \"length\" is not expected. DefineOwnProperty uses SetWritable. If this is\n        // changed, we need to handle it here.\n        Assert(propertyId != PropertyIds::length);\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetItemAttributes(this, index, attributes);\n        }\n\n        return __super::SetAttributes(propertyId, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetItemAccessors(this, index, getter, setter);\n        }\n\n        return __super::SetAccessors(propertyId, getter, setter, flags);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemWithAttributes(uint32 index, Var value, PropertyAttributes attributes)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemWithAttributes(this, index, value, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemAttributes(uint32 index, PropertyAttributes attributes)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemAttributes(this, index, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemAccessors(uint32 index, Var getter, Var setter)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemAccessors(this, index, getter, setter);\n    }\n\n    // Check if this objectArray isFrozen.\n    BOOL JavascriptArray::IsObjectArrayFrozen()\n    {\n        // If this is still a JavascriptArray, it's not frozen.\n        return false;\n    }\n\n    JavascriptEnumerator * JavascriptArray::GetIndexEnumerator(EnumeratorFlags flags, ScriptContext* requestContext)\n    {\n        if (!!(flags & EnumeratorFlags::SnapShotSemantics))\n        {\n            return RecyclerNew(GetRecycler(), JavascriptArrayIndexSnapshotEnumerator, this, flags, requestContext);\n        }\n        return RecyclerNew(GetRecycler(), JavascriptArrayIndexEnumerator, this, flags, requestContext);\n    }\n\n    BOOL JavascriptArray::GetNonIndexEnumerator(JavascriptStaticEnumerator * enumerator, ScriptContext* requestContext)\n    {\n        return enumerator->Initialize(nullptr, nullptr, this, EnumeratorFlags::SnapShotSemantics, requestContext, nullptr);\n    }\n\n    BOOL JavascriptArray::IsItemEnumerable(uint32 index)\n    {\n        return true;\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::PreventExtensions()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->PreventExtensions(this);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::Seal()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Seal(this);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::Freeze()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Freeze(this);\n    }\n\n    BOOL JavascriptArray::GetSpecialPropertyName(uint32 index, Var *propertyName, ScriptContext * requestContext)\n    {\n        if (index == 0)\n        {\n            *propertyName = requestContext->GetPropertyString(PropertyIds::length);\n            return true;\n        }\n        return false;\n    }\n\n    // Returns the number of special non-enumerable properties this type has.\n    uint JavascriptArray::GetSpecialPropertyCount() const\n    {\n        return _countof(specialPropertyIds);\n    }\n\n    // Returns the list of special non-enumerable properties for the type.\n    PropertyId const * JavascriptArray::GetSpecialPropertyIds() const\n    {\n        return specialPropertyIds;\n    }\n\n    BOOL JavascriptArray::GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        return JavascriptArray::GetProperty(originalInstance, propertyId, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        if (GetPropertyBuiltIns(propertyId, value))\n        {\n            return true;\n        }\n\n        ScriptContext* scriptContext = GetScriptContext();\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return this->GetItem(this, index, value, scriptContext);\n        }\n\n        return DynamicObject::GetProperty(originalInstance, propertyId, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),\n            \"Numeric property names should have been converted to uint or PropertyRecord*\");\n\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && GetPropertyBuiltIns(propertyRecord->GetPropertyId(), value))\n        {\n            return true;\n        }\n\n        return DynamicObject::GetProperty(originalInstance, propertyNameString, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetPropertyBuiltIns(PropertyId propertyId, Var* value)\n    {\n        //\n        // length being accessed. Return array length\n        //\n        if (propertyId == PropertyIds::length)\n        {\n            *value = JavascriptNumber::ToVar(this->GetLength(), GetScriptContext());\n            return true;\n        }\n\n        return false;\n    }\n\n    BOOL JavascriptArray::HasItem(uint32 index)\n    {\n        Var value;\n        return this->DirectGetItemAt<Var>(index, &value);\n    }\n\n    BOOL JavascriptArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptNativeIntArray::HasItem(uint32 index)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        int32 value;\n        return this->DirectGetItemAt<int32>(index, &value);\n    }\n\n    BOOL JavascriptNativeFloatArray::HasItem(uint32 index)\n    {\n        double dvalue;\n        return this->DirectGetItemAt<double>(index, &dvalue);\n    }\n\n    BOOL JavascriptNativeIntArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        return JavascriptNativeIntArray::DirectGetVarItemAt(index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeIntArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        int32 intvalue;\n        if (!this->DirectGetItemAt<int32>(index, &intvalue))\n        {\n            return FALSE;\n        }\n        *value = JavascriptNumber::ToVar(intvalue, requestContext);\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeIntArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeIntArray::GetItem(originalInstance, index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeFloatArray::DirectGetVarItemAt(index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        double dvalue;\n        int32 ivalue;\n        if (!this->DirectGetItemAt<double>(index, &dvalue))\n        {\n            return FALSE;\n        }\n        if (*(uint64*)&dvalue == 0ull)\n        {\n            *value = TaggedInt::ToVarUnchecked(0);\n        }\n        else if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !TaggedInt::IsOverflow(ivalue))\n        {\n            *value = TaggedInt::ToVarUnchecked(ivalue);\n        }\n        else\n        {\n            *value = JavascriptNumber::ToVarWithCheck(dvalue, requestContext);\n        }\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeFloatArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeFloatArray::GetItem(originalInstance, index, value, requestContext);\n    }\n\n    BOOL JavascriptArray::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        uint32 indexValue;\n        if (propertyId == PropertyIds::length)\n        {\n            return this->SetLength(value);\n        }\n        else if (GetScriptContext()->IsNumericPropertyId(propertyId, &indexValue))\n        {\n            // Call this or subclass method\n            return SetItem(indexValue, value, flags);\n        }\n        else\n        {\n            return DynamicObject::SetProperty(propertyId, value, flags, info);\n        }\n    }\n\n    BOOL JavascriptArray::SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)\n    {\n        AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),\n            \"Numeric property names should have been converted to uint or PropertyRecord*\");\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && propertyRecord->GetPropertyId() == PropertyIds::length)\n        {\n            return this->SetLength(value);\n        }\n\n        return DynamicObject::SetProperty(propertyNameString, value, flags, info);\n    }\n\n    BOOL JavascriptArray::SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags, SideEffects possibleSideEffects)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        ScriptContext* scriptContext = GetScriptContext();\n\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(attributes == PropertyWritable);\n            Assert(IsWritable(propertyId) && !IsConfigurable(propertyId) && !IsEnumerable(propertyId));\n            return this->SetLength(value);\n        }\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            // Call this or subclass method\n            return SetItemWithAttributes(index, value, attributes);\n        }\n\n        return __super::SetPropertyWithAttributes(propertyId, value, attributes, info, flags, possibleSideEffects);\n    }\n\n    BOOL JavascriptArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        this->DirectSetItemAt(index, value);\n        return true;\n    }\n\n    BOOL JavascriptNativeIntArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        int32 iValue;\n        double dValue;\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        TypeId typeId = this->TrySetNativeIntArrayItem(value, &iValue, &dValue);\n        if (typeId == TypeIds_NativeIntArray)\n        {\n            this->SetItem(index, iValue);\n        }\n        else if (typeId == TypeIds_NativeFloatArray)\n        {\n            reinterpret_cast<JavascriptNativeFloatArray*>(this)->DirectSetItemAt<double>(index, dValue);\n        }\n        else\n        {\n            this->DirectSetItemAt<Var>(index, value);\n        }\n\n        return TRUE;\n    }\n\n    TypeId JavascriptNativeIntArray::TrySetNativeIntArrayItem(Var value, int32 *iValue, double *dValue)\n    {\n        if (TaggedInt::Is(value))\n        {\n            int32 i = TaggedInt::ToInt32(value);\n            if (i != JavascriptNativeIntArray::MissingItem)\n            {\n                *iValue = i;\n                return TypeIds_NativeIntArray;\n            }\n        }\n        if (JavascriptNumber::Is_NoTaggedIntCheck(value))\n        {\n            bool isInt32;\n            int32 i;\n            double d = JavascriptNumber::GetValue(value);\n            if (JavascriptNumber::TryGetInt32OrUInt32Value(d, &i, &isInt32))\n            {\n                if (isInt32 && i != JavascriptNativeIntArray::MissingItem)\n                {\n                    *iValue = i;\n                    return TypeIds_NativeIntArray;\n                }\n            }\n            else\n            {\n                *dValue = d;\n                JavascriptNativeIntArray::ToNativeFloatArray(this);\n                return TypeIds_NativeFloatArray;\n            }\n        }\n\n        JavascriptNativeIntArray::ToVarArray(this);\n        return TypeIds_Array;\n    }\n\n    BOOL JavascriptNativeIntArray::SetItem(uint32 index, int32 iValue)\n    {\n        if (iValue == JavascriptNativeIntArray::MissingItem)\n        {\n            JavascriptArray *varArr = JavascriptNativeIntArray::ToVarArray(this);\n            varArr->DirectSetItemAt(index, JavascriptNumber::ToVar(iValue, GetScriptContext()));\n            return TRUE;\n        }\n\n        this->DirectSetItemAt(index, iValue);\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeFloatArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        double dValue;\n        TypeId typeId = this->TrySetNativeFloatArrayItem(value, &dValue);\n        if (typeId == TypeIds_NativeFloatArray)\n        {\n            this->SetItem(index, dValue);\n        }\n        else\n        {\n            this->DirectSetItemAt(index, value);\n        }\n        return TRUE;\n    }\n\n    TypeId JavascriptNativeFloatArray::TrySetNativeFloatArrayItem(Var value, double *dValue)\n    {\n        if (TaggedInt::Is(value))\n        {\n            *dValue = (double)TaggedInt::ToInt32(value);\n            return TypeIds_NativeFloatArray;\n        }\n        else if (JavascriptNumber::Is_NoTaggedIntCheck(value))\n        {\n            *dValue = JavascriptNumber::GetValue(value);\n            return TypeIds_NativeFloatArray;\n        }\n\n        JavascriptNativeFloatArray::ToVarArray(this);\n        return TypeIds_Array;\n    }\n\n    BOOL JavascriptNativeFloatArray::SetItem(uint32 index, double dValue)\n    {\n        if (*(uint64*)&dValue == *(uint64*)&JavascriptNativeFloatArray::MissingItem)\n        {\n            JavascriptArray *varArr = JavascriptNativeFloatArray::ToVarArray(this);\n            varArr->DirectSetItemAt(index, JavascriptNumber::ToVarNoCheck(dValue, GetScriptContext()));\n            return TRUE;\n        }\n\n        this->DirectSetItemAt<double>(index, dValue);\n        return TRUE;\n    }\n\n    BOOL JavascriptArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<Var>(index);\n    }\n\n    BOOL JavascriptNativeIntArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<int32>(index);\n    }\n\n    BOOL JavascriptNativeFloatArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<double>(index);\n    }\n\n    BOOL JavascriptArray::GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache)\n    {\n        return enumerator->Initialize(nullptr, this, this, flags, requestContext, forInCache);\n    }\n\n    BOOL JavascriptArray::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)\n    {\n        stringBuilder->Append(_u('['));\n\n        if (this->length < 10)\n        {\n            auto funcPtr = [&]()\n            {\n                ENTER_PINNED_SCOPE(JavascriptString, valueStr);\n                valueStr = JavascriptArray::JoinHelper(this, GetLibrary()->GetCommaDisplayString(), requestContext);\n                stringBuilder->Append(valueStr->GetString(), valueStr->GetLength());\n                LEAVE_PINNED_SCOPE();\n            };\n\n            if (!requestContext->GetThreadContext()->IsScriptActive())\n            {\n                BEGIN_JS_RUNTIME_CALL(requestContext);\n                {\n                    funcPtr();\n                }\n                END_JS_RUNTIME_CALL(requestContext);\n            }\n            else\n            {\n                funcPtr();\n            }\n        }\n        else\n        {\n            stringBuilder->AppendCppLiteral(_u(\"...\"));\n        }\n\n        stringBuilder->Append(_u(']'));\n\n        return TRUE;\n    }\n\n    BOOL JavascriptArray::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)\n    {\n        stringBuilder->AppendCppLiteral(_u(\"Object, (Array)\"));\n        return TRUE;\n    }\n\n    bool JavascriptNativeArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeArray::Is(typeId);\n    }\n\n    bool JavascriptNativeArray::Is(TypeId typeId)\n    {\n        return JavascriptNativeIntArray::Is(typeId) || JavascriptNativeFloatArray::Is(typeId);\n    }\n\n    JavascriptNativeArray* JavascriptNativeArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeArray'\");\n\n        return static_cast<JavascriptNativeArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    bool JavascriptNativeIntArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeIntArray::Is(typeId);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    bool JavascriptCopyOnAccessNativeIntArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptCopyOnAccessNativeIntArray::Is(typeId);\n    }\n#endif\n\n    bool JavascriptNativeIntArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_NativeIntArray;\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    bool JavascriptCopyOnAccessNativeIntArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_CopyOnAccessNativeIntArray;\n    }\n#endif\n\n    bool JavascriptNativeIntArray::IsNonCrossSite(Var aValue)\n    {\n        bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue);\n        Assert(ret == (JavascriptNativeIntArray::Is(aValue) && !JavascriptNativeIntArray::FromVar(aValue)->IsCrossSiteObject()));\n        return ret;\n    }\n\n    JavascriptNativeIntArray* JavascriptNativeIntArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeIntArray'\");\n\n        return static_cast<JavascriptNativeIntArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    JavascriptCopyOnAccessNativeIntArray* JavascriptCopyOnAccessNativeIntArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptCopyOnAccessNativeIntArray'\");\n\n        return static_cast<JavascriptCopyOnAccessNativeIntArray *>(RecyclableObject::FromVar(aValue));\n    }\n#endif\n\n    bool JavascriptNativeFloatArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeFloatArray::Is(typeId);\n    }\n\n    bool JavascriptNativeFloatArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_NativeFloatArray;\n    }\n\n    bool JavascriptNativeFloatArray::IsNonCrossSite(Var aValue)\n    {\n        bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue);\n        Assert(ret == (JavascriptNativeFloatArray::Is(aValue) && !JavascriptNativeFloatArray::FromVar(aValue)->IsCrossSiteObject()));\n        return ret;\n    }\n\n    JavascriptNativeFloatArray* JavascriptNativeFloatArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeFloatArray'\");\n\n        return static_cast<JavascriptNativeFloatArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    template int   Js::JavascriptArray::GetParamForIndexOf<unsigned int>(unsigned int, Js::Arguments const&, void*&, unsigned int&, Js::ScriptContext*);\n    template bool  Js::JavascriptArray::ArrayElementEnumerator::MoveNext<void*>();\n    template void  Js::JavascriptArray::SetArrayLiteralItem<void*>(unsigned int, void*);\n    template void* Js::JavascriptArray::TemplatedIndexOfHelper<false, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);\n    template void* Js::JavascriptArray::TemplatedIndexOfHelper<true, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);\n} //namespace Js\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\n//Note: see function  ArraySpliceHelper of JavascriptArray.cpp\n\nif (this.WScript && this.WScript.LoadScriptFile) { // Check for running in ch\n    this.WScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");\n}\n\nvar restorePropertyFromDescriptor = function (obj, prop, desc) {\n    if (typeof desc == 'undefined') {\n        delete obj[prop];\n    } else {\n        Object.defineProperty(obj, prop, desc);\n    }\n}\n\nvar tests = [\n    {\n        name: \"OS7342663:OOB writes using type confusion in InternalCopyArrayElements\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                class MyArray extends Uint32Array { }\n                Object.defineProperty(MyArray, Symbol.species, { value: function() { return arr1; } });\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [float_val, float_val, float_val, float_val];\n                test.length = 0x1000;\n                test.__proto__ = new MyArray(0);\n\n                var res = Array.prototype.slice.apply(test, []);  // OOB write\n                assert.areEqual(0x1000, res.length, \"res.length == 0x1000\");\n                assert.areEqual(float_val, res[0], \"res[0] == float_val\");\n                assert.areEqual(float_val, res[1], \"res[1] == float_val\");\n                assert.areEqual(float_val, res[2], \"res[2] == float_val\");\n                assert.areEqual(float_val, res[3], \"res[3] == float_val\");\n                assert.areEqual(undefined, res[4], \"res[4] == float_val\");\n                assert.areEqual(undefined, res[0xfff], \"res[0xfff] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342689:OOB writes using type confusion in InternalFillFromPrototypes\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead,\n                0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe,\n                0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead,\n                0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                class MyArray extends Uint32Array { }\n                Object.defineProperty(MyArray, Symbol.species, { value: function() { return arr1; } });\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [{}];\n                delete test[0];\n                test.length = 0x1000;\n                var src = [float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val];\n                test.__proto__ = src;\n                test.__proto__.__proto__ = new MyArray(0);\n\n               //this will write 0xfffc0daddeadbabe to [arr1] + 0x1D8\n                var res = Array.prototype.slice.apply(test, [])\n                assert.areEqual(0x1000, res.length, \"res.length == 0x1000\");\n                assert.areEqual(float_val, res[0], \"res[0] == float_val\");\n                assert.areEqual(float_val, res[1], \"res[1] == float_val\");\n                assert.areEqual(float_val, res[2], \"res[2] == float_val\");\n                assert.areEqual(float_val, res[src.length-1], \"res[src.length-1] == float_val\");\n                assert.areEqual(undefined, res[src.length], \"res[src] == undefined\");\n                assert.areEqual(undefined, res[0xfff], \"res[0xfff] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7307908:type confusion in Array.prototype.slice\",\n        body: function ()\n        {\n            function test() {\n                var arr = [1, 2]\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n               //Our species function will get called during chakra!Js::JavascriptArray::SliceHelper<unsigned int>\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                           //change 'arr' from TypeIds_NativeIntArray to TypeIds_Array\n                            arr[0] = WScript;\n\n                           //return a TypeIds_NativeIntArray so we can read back out the 64 bit pointer as two 32bit ints.\n                            return [];\n                        }\n                    }\n                );\n\n               //trigger the bug and retrieve a TypeIds_NativeIntArray array containing a pointer.\n                var brr = arr.slice();\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(2, brr[1], \"brr[0] == WScript\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342791:type confusion in Array.from\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [float_val, float_val, float_val, float_val];\n                delete test[0];\n                delete test[1];\n                delete test[2];\n\n                var res = Array.from.apply(function(){return arr1}, [test]);\n                assert.areEqual(4, res.length, \"res.length == 4\");\n                assert.areEqual(undefined, res[0], \"res[0] == undefined\");\n                assert.areEqual(undefined, res[1], \"res[1] == undefined\");\n                assert.areEqual(undefined, res[2], \"res[2] == undefined\");\n                assert.areEqual(float_val, res[3], \"res[3] == float_val\");\n\n                assert.areEqual(['1','2','3'], Array.from.apply(()=>new Array(), [\"123\"]), \"Array.from on iterable\");\n                assert.areEqual([1,2,3], Array.from.apply(()=>new Array(), [{\"0\":1, \"1\":2, \"2\":3, \"length\":3}]), \"Array.from on non-iterable\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342844:type confusion in Array.of\",\n        body: function ()\n        {\n            function test() {\n                var brr = Array.of.call(()=>[ 1, 2, 3, 4 ],\n                    WScript, // supply 2 copies of target so the brr array will have a length of 2 and we can read the 64bit pointer.\n                    WScript\n                );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"res[0] == WScript\");\n                assert.areEqual(WScript, brr[1], \"res[1] == WScript\");\n                assert.areEqual(undefined, brr[2], \"res[2] == undefined\");\n                assert.areEqual(undefined, brr[3], \"res[3] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342907:type confusion in Array.prototype.map\",\n        body: function ()\n        {\n            function test() {\n                var arr = [ 1, 2 ];\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                            return [];\n                        }\n                    }\n                );\n\n               //The value returned from our callback is directly set into the array whose type we create via the species.\n                var brr = arr.map( function( v )\n                    {\n                        if( v == 1 )\n                            return WScript;\n                    }\n                );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(undefined, brr[1], \"brr[1] == undefined\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.map with Proxy\",\n        body: function ()\n        {\n            function test() {\n                var d = [1,2,3];\n                class dummy {\n                    constructor() {\n                        return d;\n                    }\n                }\n\n                var handler = {\n                    get: function(target, name) {\n                        if(name == \"length\") {\n                            return 0x100;\n                        }\n\n                        return {[Symbol.species] : dummy};\n                    },\n\n                    has: function(target, name) {\n                        return true;\n                    }\n                };\n\n                var p = new Proxy([], handler);\n                var a = new Array(1,2,3);\n\n                function test(){\n                    return 0x777777777777;\n                }\n\n                var o = a.map.call(p, test);\n                assert.areEqual(Array(0x100).fill(0x777777777777), o);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342965:type confusion in Array.prototype.splice\",\n        body: function ()\n        {\n            function test() {\n               //create a TypeIds_Array holding two 64 bit values (The same amount of space for four 32 bit values).\n                var arr = [ WScript, WScript ];\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n               //Our species function will get called during chakra!Js::JavascriptArray::EntrySplice\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                           //return a TypeIds_NativeIntArray so we can read back out a 64 bit pointer as two 32bit ints.\n                            return [ 1, 2, 3, 4 ];\n                        }\n                    }\n                );\n\n               //trigger the bug and retrieve a TypeIds_NativeIntArray array containing a pointer. The helper\n               //method ArraySegmentSpliceHelper<Var> will directly copy over the TypeIds_Array segment data\n               //into the TypeIds_NativeIntArray segment.\n                var brr = arr.splice( 0, 2 );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(WScript, brr[1], \"brr[1] == WScript\");\n                assert.areEqual(undefined, brr[2], \"brr[2] == undefined\");\n                assert.areEqual(undefined, brr[3], \"brr[3] == undefined\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.join\",\n        body: function ()\n        {\n            function test() {\n                var a = [0, 1, 2, 3];\n                var b = [];\n                delete a[0];\n                Object.setPrototypeOf(a, b)\n                Object.defineProperty(b, \"0\",\n                    {\n                        get: function() {\n                                a[2] = \"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(\"-1,1,abc,3\", a.join());\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.indexOf\",\n        body: function ()\n        {\n            function test() {\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var a = [0, 1, 2, 3];\n                var b = [];\n                delete a[1];\n                Object.setPrototypeOf(a, b);\n                Object.defineProperty(b, \"1\",\n                    {\n                        get: function() {\n                                a[2] = float_val; //\"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(3, a.indexOf(3));\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.lastIndexOf\",\n        body: function ()\n        {\n            function test() {\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var a = [3, 2, 1, 0];\n                var b = [];\n                delete a[3];\n                Object.setPrototypeOf(a, b);\n                Object.defineProperty(b, \"3\",\n                    {\n                        get: function() {\n                                a[1] = float_val; //\"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(0, a.lastIndexOf(3));\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Function.prototype.apply\",\n        body: function ()\n        {\n            function test() {\n                var t = [1,2,3];\n\n                function f(){\n                    var h = [];\n                    var a = [...arguments]\n\n                    for(item in a){\n                        var n = new Number(a[item]);\n\n                        if( n < 0) {\n                            n = n + 0x100000000;\n                        }\n\n                        h.push(n.toString(16));\n                    }\n\n                    return h;\n                }\n\n                var q = f;\n\n                t.length = 20;\n                var o = {};\n                Object.defineProperty(o, '3', {\n                    get: function() {\n                        var ta = [];\n                        ta.fill.call(t, \"natalie\");\n                        return 5;\n                    }\n                });\n\n                t.__proto__ = o;\n\n                var j = [];\n                assert.areEqual(\"1,2,3,5,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN\", f.apply(null, t).toString());\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"[MSRC34910] type confusion in Array.prototype.filter\",\n        body: function ()\n        {\n            function mappingFn(elem, index, arr) {\n                arr[1] = 'hello';\n                return true;\n            }\n\n            var arr = [1, 2, 3];\n\n            var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n            Object.defineProperty(arr.constructor, Symbol.species, { get : function () {  return function() { return [22, 33]; } } } );\n            var b = Array.prototype.filter.call(arr, mappingFn);\n            assert.areEqual('hello', b[1]);\n\n            restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n        }\n    },\n    {\n        name: \"[MSRC35046] heap overflow in Array.prototype.splice\",\n        body: function ()\n        {\n            var a = [];\n            var o = {};\n\n            Object.defineProperty(o, 'constructor', {\n                get: function() {\n                    a.length = 0xfffffffe;\n                    [].fill.call(a, 0, 0xfffff000, 0xfffffffe);\n                    return Array;\n                }});\n\n            a.__proto__ = o;\n            var q = new Array(50).fill(1.1);\n\n            var b = [].splice.call(a, 0, 0, ...q);\n            assert.areEqual(50, a.length);\n            assert.areEqual(q, a);\n        }\n    },\n    {\n        name: \"[MSRC35086] type confusion in FillFromPrototypes\",\n        body: function ()\n        {\n            var a = new Array(0x11111111, 0x22222222, 0x33333333, 0x44444444, 0x12121212);\n\n            var handler = {\n                    getPrototypeOf: function(target, name) {\n                        return a;\n                    }\n                };\n\n            var p = new Proxy([], handler);\n            var b = [{}, [], \"abc\"];\n\n            b.__proto__ = p;\n            b.length = 4;\n            var c = [[],\"abc\",1145324612];\n\n            a.shift.call(b);\n            assert.areEqual(3, b.length);\n            assert.areEqual([], b[0]);\n            assert.areEqual(\"abc\", b[1]);\n            assert.areEqual(1145324612, b[2]);\n        }\n    },\n    {\n        name: \"[MSRC35272] type confusion in JSON.parse\",\n        body: function ()\n        {\n            var a = 1;\n            var once = false;\n            function f(){\n                if(!once){\n                    a = new Array(2)\n                    this[2] = a;\n                }\n                once = true;\n                return 0x41414141;\n            }\n\n            var r = JSON.parse(\"[1111, 22222, 333333]\", f);\n            assert.areEqual(0x41414141, r);\n        }\n    },\n    {\n        name: \"[MSRC35383] type confusion in Array.prototype.concat\",\n        body: function ()\n        {\n            var n = [];\n            for (var i = 0; i < 0x10; i++)\n                n.push([0x11111111, 0x11111111, 0, 0x11111111,0x11111111, 0x11111111, 0, 0x11111111,0x11111111, 0x11111111, 0, 0x11111111,0x11111111,0x11111111, 0, 0x11111111,0x11111111 ,1 ,2 ,3 ,4]);\n\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {  return n[3]; }; };\n            }\n\n            var f = function(a){ return a; }\n\n            var x = [\"dabao\", 0, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    return (p == \"constructor\") ? fake : x[p];\n                }\n            });\n\n            assert.areEqual(x, Array.prototype.concat.apply(y));\n        }\n    },\n    {\n        name: \"[MSRC35389] type confusion in Array.prototype.splice\",\n        body: function ()\n        {\n            var arr = [0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344]\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {\n                    return arr;\n                }; };\n            }\n\n            var x = [0, 2, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    return (p == \"constructor\") ? fake : x[p];\n                }\n            });\n\n            Array.prototype.splice.apply(y);\n            assert.areEqual(x, y);\n        }\n    },\n    {\n        name: \"[MSRC35389 variation] type confusion in Array.prototype.slice\",\n        body: function ()\n        {\n            var arr = [0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344];\n\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {\n                    return arr;\n                }; };\n            }\n\n            var x = [0, 2, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    if (p == \"constructor\")\n                        return fake\n                    if (p == 'length');\n                        return 1;\n                    return x[p];\n                },\n                has: function() {\n                    return false;\n                }\n            });\n\n            assert.areEqual([0x41424344], Array.prototype.slice.call(y));\n        }\n    },\n    {\n        name: \"[MSRC34994,35226] heap overflow in Array.prototype.reverse\",\n        body: function ()\n        {\n            var count = 0;\n            arr = new Array(100);\n            var desc = Object.getOwnPropertyDescriptor(Array.prototype, 1);\n            Object.defineProperty(Array.prototype, 1, { get: function () {\n                    count++;\n                    if (count == 1) {\n                        arr.push(null);\n                    }\n                }});\n\n            arr.reverse();\n            restorePropertyFromDescriptor(Array.prototype, 1, desc);\n            assert.areEqual(101, arr.length);\n        }\n    },\n];\ntestRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });\n"], "fixing_code": ["//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\n#include \"RuntimeLibraryPch.h\"\n#include \"Types/PathTypeHandler.h\"\n#include \"Types/SpreadArgument.h\"\n\nnamespace Js\n{\n    // Make sure EmptySegment points to read-only memory.\n    // Can't do this the easy way because SparseArraySegment has a constructor...\n    static const char EmptySegmentData[sizeof(SparseArraySegmentBase)] = {0};\n    const SparseArraySegmentBase *JavascriptArray::EmptySegment = (SparseArraySegmentBase *)&EmptySegmentData;\n\n    // col0 : allocation bucket\n    // col1 : No. of missing items to set during initialization depending on bucket.\n    // col2 : allocation size for elements in given bucket.\n    // col1 and col2 is calculated at runtime\n    uint JavascriptNativeFloatArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        { 3, 0, 0 },    // allocate space for 3 elements for array of length 0,1,2,3\n        { 5, 0, 0 },    // allocate space for 5 elements for array of length 4,5\n        { 8, 0, 0 },    // allocate space for 8 elements for array of length 6,7,8\n    };\n#if defined(_M_X64_OR_ARM64)\n    const Var JavascriptArray::MissingItem = (Var)0x8000000280000002;\n    uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        {2, 0, 0},\n        {6, 0, 0},\n        {8, 0, 0},\n    };\n    uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        {4, 0, 0},\n        {6, 0, 0},\n        {8, 0, 0},\n    };\n#else\n    const Var JavascriptArray::MissingItem = (Var)0x80000002;\n    uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        { 3, 0, 0 },\n        { 7, 0, 0 },\n        { 8, 0, 0 },\n    };\n    uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =\n    {\n        // See comments above on how to read this\n        { 4, 0, 0 },\n        { 8, 0, 0 },\n    };\n#endif\n\n    const int32 JavascriptNativeIntArray::MissingItem = 0x80000002;\n    static const uint64 FloatMissingItemPattern = 0x8000000280000002ull;\n    const double JavascriptNativeFloatArray::MissingItem = *(double*)&FloatMissingItemPattern;\n\n    // Allocate enough space for 4 inline property slots and 16 inline element slots\n    const size_t JavascriptArray::StackAllocationSize = DetermineAllocationSize<JavascriptArray, 4>(16);\n    const size_t JavascriptNativeIntArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeIntArray, 4>(16);\n    const size_t JavascriptNativeFloatArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeFloatArray, 4>(16);\n\n    SegmentBTree::SegmentBTree()\n        : segmentCount(0),\n          segments(NULL),\n          keys(NULL),\n          children(NULL)\n    {\n    }\n\n    uint32 SegmentBTree::GetLazyCrossOverLimit()\n    {\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n        if (Js::Configuration::Global.flags.DisableArrayBTree)\n        {\n            return Js::JavascriptArray::InvalidIndex;\n        }\n        else if (Js::Configuration::Global.flags.ForceArrayBTree)\n        {\n            return ARRAY_CROSSOVER_FOR_VALIDATE;\n        }\n#endif\n#ifdef VALIDATE_ARRAY\n        if (Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return ARRAY_CROSSOVER_FOR_VALIDATE;\n        }\n#endif\n        return SegmentBTree::MinDegree * 3;\n    }\n\n    BOOL SegmentBTree::IsLeaf() const\n    {\n        return children == NULL;\n    }\n    BOOL SegmentBTree::IsFullNode() const\n    {\n        return segmentCount == MaxKeys;\n    }\n\n    void SegmentBTree::InternalFind(SegmentBTree* node, uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)\n    {\n        uint32 i = 0;\n\n        for(; i < node->segmentCount; i++)\n        {\n            Assert(node->keys[i] == node->segments[i]->left);\n            if (itemIndex <  node->keys[i])\n            {\n                break;\n            }\n        }\n\n        // i indicates the 1st segment in the node past any matching segment.\n        // the i'th child is the children to the 'left' of the i'th segment.\n\n        // If itemIndex matches segment i-1 (note that left is always a match even when length == 0)\n        bool matches = i > 0 && (itemIndex == node->keys[i-1] || itemIndex < node->keys[i-1] + node->segments[i-1]->length);\n\n        if (matches)\n        {\n            // Find prev segment\n            if (node->IsLeaf())\n            {\n                if (i > 1)\n                {\n                    // Previous is either sibling or set in a parent\n                    prev = node->segments[i-2];\n                }\n            }\n            else\n            {\n                // prev is the right most leaf in children[i-1] tree\n                SegmentBTree* child = &node->children[i - 1];\n                while (!child->IsLeaf())\n                {\n                    child = &child->children[child->segmentCount];\n                }\n                prev = child->segments[child->segmentCount - 1];\n            }\n\n            // Return the matching segment\n            matchOrNext = node->segments[i-1];\n        }\n        else // itemIndex in between segment i-1 and i\n        {\n            if (i > 0)\n            {\n                // Store in previous in case a match or next is the first segment in a child.\n                prev = node->segments[i-1];\n            }\n\n            if (node->IsLeaf())\n            {\n                matchOrNext = (i == 0 ? node->segments[0] : prev->next);\n            }\n            else\n            {\n                InternalFind(node->children + i, itemIndex, prev, matchOrNext);\n            }\n        }\n    }\n\n    void SegmentBTreeRoot::Find(uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)\n    {\n        prev = matchOrNext = NULL;\n        InternalFind(this, itemIndex, prev, matchOrNext);\n        Assert(prev == NULL || (prev->next == matchOrNext));// If prev exists it is immediately before matchOrNext in the list of arraysegments\n        Assert(prev == NULL || (prev->left < itemIndex && prev->left + prev->length <= itemIndex)); // prev should never be a match (left is a match if length == 0)\n        Assert(matchOrNext == NULL || (matchOrNext->left >= itemIndex || matchOrNext->left + matchOrNext->length > itemIndex));\n    }\n\n    void SegmentBTreeRoot::Add(Recycler* recycler, SparseArraySegmentBase* newSeg)\n    {\n\n        if (IsFullNode())\n        {\n            SegmentBTree * children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);\n            children[0] = *this;\n\n            // Even though the segments point to a GC pointer, the main array should keep a references\n            // as well.  So just make it a leaf allocation\n            this->segmentCount = 0;\n            this->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n            this->keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);\n            this->children = children;\n\n            // This split is the only way the tree gets deeper\n            SplitChild(recycler, this, 0, &children[0]);\n        }\n        InsertNonFullNode(recycler, this, newSeg);\n    }\n\n    void SegmentBTree::SwapSegment(uint32 originalKey, SparseArraySegmentBase* oldSeg, SparseArraySegmentBase* newSeg)\n    {\n        // Find old segment\n        uint32 itemIndex = originalKey;\n        uint32 i = 0;\n\n        for(; i < segmentCount; i++)\n        {\n            Assert(keys[i] == segments[i]->left || (oldSeg == newSeg && newSeg == segments[i]));\n            if (itemIndex <  keys[i])\n            {\n                break;\n            }\n        }\n\n        // i is 1 past any match\n\n        if (i > 0)\n        {\n            if (oldSeg == segments[i-1])\n            {\n                segments[i-1] = newSeg;\n                keys[i-1] = newSeg->left;\n                return;\n            }\n        }\n\n        Assert(!IsLeaf());\n        children[i].SwapSegment(originalKey, oldSeg, newSeg);\n    }\n\n\n    void SegmentBTree::SplitChild(Recycler* recycler, SegmentBTree* parent, uint32 iChild, SegmentBTree* child)\n    {\n        // Split child in two, move it's median key up to parent, and put the result of the split\n        // on either side of the key moved up into parent\n\n        Assert(child != NULL);\n        Assert(parent != NULL);\n        Assert(!parent->IsFullNode());\n        Assert(child->IsFullNode());\n\n        SegmentBTree newNode;\n        newNode.segmentCount = MinKeys;\n\n        // Even though the segments point to a GC pointer, the main array should keep a references\n        // as well.  So just make it a leaf allocation\n        newNode.segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n        newNode.keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);\n\n        // Move the keys above the median into the new node\n        for(uint32 i = 0; i < MinKeys; i++)\n        {\n            newNode.segments[i] = child->segments[i+MinDegree];\n            newNode.keys[i] = child->keys[i+MinDegree];\n\n            // Do not leave false positive references around in the b-tree\n            child->segments[i+MinDegree] = NULL;\n        }\n\n        // If children exist move those as well.\n        if (!child->IsLeaf())\n        {\n            newNode.children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);\n            for(uint32 j = 0; j < MinDegree; j++)\n            {\n                newNode.children[j] = child->children[j+MinDegree];\n\n                // Do not leave false positive references around in the b-tree\n                child->children[j+MinDegree].segments = NULL;\n                child->children[j+MinDegree].children = NULL;\n            }\n        }\n        child->segmentCount = MinKeys;\n\n        // Make room for the new child in parent\n        for(uint32 j = parent->segmentCount; j > iChild; j--)\n        {\n            parent->children[j+1] = parent->children[j];\n        }\n        // Copy the contents of the new node into the correct place in the parent's child array\n        parent->children[iChild+1] = newNode;\n\n        // Move the keys to make room for the median key\n        for(uint32 k = parent->segmentCount; k > iChild; k--)\n        {\n            parent->segments[k] = parent->segments[k-1];\n            parent->keys[k] = parent->keys[k-1];\n        }\n\n        // Move the median key into the proper place in the parent node\n        parent->segments[iChild] = child->segments[MinKeys];\n        parent->keys[iChild] = child->keys[MinKeys];\n\n        // Do not leave false positive references around in the b-tree\n        child->segments[MinKeys] = NULL;\n\n        parent->segmentCount++;\n    }\n\n    void SegmentBTree::InsertNonFullNode(Recycler* recycler, SegmentBTree* node, SparseArraySegmentBase* newSeg)\n    {\n        Assert(!node->IsFullNode());\n        AnalysisAssert(node->segmentCount < MaxKeys);       // Same as !node->IsFullNode()\n        Assert(newSeg != NULL);\n\n        if (node->IsLeaf())\n        {\n            // Move the keys\n            uint32 i = node->segmentCount - 1;\n            while( (i != -1) && (newSeg->left < node->keys[i]))\n            {\n                node->segments[i+1] = node->segments[i];\n                node->keys[i+1] = node->keys[i];\n                i--;\n            }\n            if (!node->segments)\n            {\n                // Even though the segments point to a GC pointer, the main array should keep a references\n                // as well.  So just make it a leaf allocation\n                node->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);\n                node->keys = AllocatorNewArrayLeafZ(Recycler, recycler, uint32, MaxKeys);\n            }\n            node->segments[i + 1] = newSeg;\n            node->keys[i + 1] = newSeg->left;\n            node->segmentCount++;\n        }\n        else\n        {\n            // find the correct child node\n            uint32 i = node->segmentCount-1;\n\n            while((i != -1) && (newSeg->left < node->keys[i]))\n            {\n                i--;\n            }\n            i++;\n\n            // Make room if full\n            if(node->children[i].IsFullNode())\n            {\n                // This split doesn't make the tree any deeper as node already has children.\n                SplitChild(recycler, node, i, node->children+i);\n                Assert(node->keys[i] == node->segments[i]->left);\n                if (newSeg->left > node->keys[i])\n                {\n                    i++;\n                }\n            }\n            InsertNonFullNode(recycler, node->children+i, newSeg);\n        }\n    }\n\n    inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure(BOOL operationSucceeded)\n    {\n        if (IsThrowTypeError(operationSucceeded))\n        {\n            ThrowTypeErrorOnFailure();\n        }\n    }\n\n    inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure()\n    {\n        JavascriptError::ThrowTypeError(m_scriptContext, VBSERR_ActionNotSupported, m_functionName);\n    }\n\n    inline BOOL ThrowTypeErrorOnFailureHelper::IsThrowTypeError(BOOL operationSucceeded)\n    {\n        return !operationSucceeded;\n    }\n\n    // Make sure EmptySegment points to read-only memory.\n    // Can't do this the easy way because SparseArraySegment has a constructor...\n    JavascriptArray::JavascriptArray(DynamicType * type)\n        : ArrayObject(type, false, 0)\n    {\n        Assert(type->GetTypeId() == TypeIds_Array || type->GetTypeId() == TypeIds_NativeIntArray || type->GetTypeId() == TypeIds_NativeFloatArray || ((type->GetTypeId() == TypeIds_ES5Array || type->GetTypeId() == TypeIds_Object) && type->GetPrototype() == GetScriptContext()->GetLibrary()->GetArrayPrototype()));\n        Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));\n\n    }\n\n    JavascriptArray::JavascriptArray(uint32 length, DynamicType * type)\n        : ArrayObject(type, false, length)\n    {\n        Assert(JavascriptArray::Is(type->GetTypeId()));\n        Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));\n    }\n\n    JavascriptArray::JavascriptArray(uint32 length, uint32 size, DynamicType * type)\n        : ArrayObject(type, false, length)\n    {\n        Assert(type->GetTypeId() == TypeIds_Array);\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptArray::JavascriptArray(DynamicType * type, uint32 size)\n        : ArrayObject(type, false)\n    {\n        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, false>(this));\n        head->size = size;\n        Var fill = Js::JavascriptArray::MissingItem;\n        for (uint i = 0; i < size; i++)\n        {\n            ((SparseArraySegment<Var>*)head)->elements[i] = fill;\n        }\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(uint32 length, uint32 size, DynamicType * type)\n        : JavascriptNativeArray(type)\n    {\n        Assert(type->GetTypeId() == TypeIds_NativeIntArray);\n        this->length = length;\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<int32>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(DynamicType * type, uint32 size)\n        : JavascriptNativeArray(type)\n    {\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, false>(this));\n        head->size = size;\n        ((SparseArraySegment<int32>*)head)->FillSegmentBuffer(0, size);\n    }\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(uint32 length, uint32 size, DynamicType * type)\n        : JavascriptNativeArray(type)\n    {\n        Assert(type->GetTypeId() == TypeIds_NativeFloatArray);\n        this->length = length;\n        Recycler* recycler = GetRecycler();\n        SetHeadAndLastUsedSegment(SparseArraySegment<double>::AllocateSegment(recycler, 0, 0, size, nullptr));\n    }\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(DynamicType * type, uint32 size)\n        : JavascriptNativeArray(type)\n    {\n        SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, false>(this));\n        head->size = size;\n        ((SparseArraySegment<double>*)head)->FillSegmentBuffer(0, size);\n    }\n\n    bool JavascriptArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptArray::Is(typeId);\n    }\n\n    bool JavascriptArray::Is(TypeId typeId)\n    {\n        return typeId >= TypeIds_ArrayFirst && typeId <= TypeIds_ArrayLast;\n    }\n\n    bool JavascriptArray::IsVarArray(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptArray::IsVarArray(typeId);\n    }\n\n    bool JavascriptArray::IsVarArray(TypeId typeId)\n    {\n        return typeId == TypeIds_Array;\n    }\n\n    template<typename T>\n    bool JavascriptArray::IsMissingItemAt(uint32 index) const\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)this->head;\n\n        return SparseArraySegment<T>::IsMissingItem(&headSeg->elements[index]);\n    }\n\n    bool JavascriptArray::IsMissingItem(uint32 index)\n    {\n        if (this->length <= index)\n        {\n            return false;\n        }\n\n        bool isIntArray = false, isFloatArray = false;\n        this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n\n        if (isIntArray)\n        {\n            return IsMissingItemAt<int32>(index);\n        }\n        else if (isFloatArray)\n        {\n            return IsMissingItemAt<double>(index);\n        }\n        else\n        {\n            return IsMissingItemAt<Var>(index);\n        }\n    }\n\n    JavascriptArray* JavascriptArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptArray'\");\n\n        return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    // Get JavascriptArray* from a Var, which is either a JavascriptArray* or ESArray*.\n    JavascriptArray* JavascriptArray::FromAnyArray(Var aValue)\n    {\n        AssertMsg(Is(aValue) || ES5Array::Is(aValue), \"Ensure var is actually a 'JavascriptArray' or 'ES5Array'\");\n\n        return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    // Check if a Var is a direct-accessible (fast path) JavascriptArray.\n    bool JavascriptArray::IsDirectAccessArray(Var aValue)\n    {\n        return RecyclableObject::Is(aValue) &&\n            (VirtualTableInfo<JavascriptArray>::HasVirtualTable(aValue) ||\n                VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue) ||\n                VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue));\n    }\n\n    DynamicObjectFlags JavascriptArray::GetFlags() const\n    {\n        return GetArrayFlags();\n    }\n\n    DynamicObjectFlags JavascriptArray::GetFlags_Unchecked() const // do not use except in extreme circumstances\n    {\n        return GetArrayFlags_Unchecked();\n    }\n\n    void JavascriptArray::SetFlags(const DynamicObjectFlags flags)\n    {\n        SetArrayFlags(flags);\n    }\n\n    DynamicType * JavascriptArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetArrayType();\n    }\n\n    JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(const Var var)\n    {\n        bool isObjectWithArray;\n        TypeId arrayTypeId;\n        return GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);\n    }\n\n    JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(\n        const Var var,\n        bool *const isObjectWithArrayRef,\n        TypeId *const arrayTypeIdRef)\n    {\n        // This is a helper function used by jitted code. The array checks done here match the array checks done by jitted code\n        // (see Lowerer::GenerateArrayTest) to minimize bailouts.\n\n        Assert(var);\n        Assert(isObjectWithArrayRef);\n        Assert(arrayTypeIdRef);\n\n        *isObjectWithArrayRef = false;\n        *arrayTypeIdRef = TypeIds_Undefined;\n\n        if(!RecyclableObject::Is(var))\n        {\n            return nullptr;\n        }\n\n        JavascriptArray *array = nullptr;\n        INT_PTR vtable = VirtualTableInfoBase::GetVirtualTable(var);\n        if(vtable == VirtualTableInfo<DynamicObject>::Address)\n        {\n            ArrayObject* objectArray = DynamicObject::FromVar(var)->GetObjectArray();\n            array = (objectArray && Is(objectArray)) ? FromVar(objectArray) : nullptr;\n            if(!array)\n            {\n                return nullptr;\n            }\n            *isObjectWithArrayRef = true;\n            vtable = VirtualTableInfoBase::GetVirtualTable(array);\n        }\n\n        if(vtable == VirtualTableInfo<JavascriptArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_Array;\n        }\n        else if(vtable == VirtualTableInfo<JavascriptNativeIntArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_NativeIntArray;\n        }\n        else if(vtable == VirtualTableInfo<JavascriptNativeFloatArray>::Address)\n        {\n            *arrayTypeIdRef = TypeIds_NativeFloatArray;\n        }\n        else\n        {\n            return nullptr;\n        }\n\n        if(!array)\n        {\n            array = FromVar(var);\n        }\n        return array;\n    }\n\n    const SparseArraySegmentBase *JavascriptArray::Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);\n        return array ? array->head : nullptr;\n    }\n\n    uint32 JavascriptArray::Jit_GetArrayHeadSegmentLength(const SparseArraySegmentBase *const headSegment)\n    {\n        // This is a helper function used by jitted code\n\n        return headSegment ? headSegment->length : 0;\n    }\n\n    bool JavascriptArray::Jit_OperationInvalidatedArrayHeadSegment(\n        const SparseArraySegmentBase *const headSegmentBeforeOperation,\n        const uint32 headSegmentLengthBeforeOperation,\n        const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        Assert(varAfterOperation);\n\n        if(!headSegmentBeforeOperation)\n        {\n            return false;\n        }\n\n        const SparseArraySegmentBase *const headSegmentAfterOperation =\n            Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(varAfterOperation);\n        return\n            headSegmentAfterOperation != headSegmentBeforeOperation ||\n            headSegmentAfterOperation->length != headSegmentLengthBeforeOperation;\n    }\n\n    uint32 JavascriptArray::Jit_GetArrayLength(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        bool isObjectWithArray;\n        TypeId arrayTypeId;\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);\n        return array && !isObjectWithArray ? array->GetLength() : 0;\n    }\n\n    bool JavascriptArray::Jit_OperationInvalidatedArrayLength(const uint32 lengthBeforeOperation, const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        return Jit_GetArrayLength(varAfterOperation) != lengthBeforeOperation;\n    }\n\n    DynamicObjectFlags JavascriptArray::Jit_GetArrayFlagsForArrayOrObjectWithArray(const Var var)\n    {\n        // This is a helper function used by jitted code\n\n        JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);\n        return array && array->UsesObjectArrayOrFlagsAsFlags() ? array->GetFlags() : DynamicObjectFlags::None;\n    }\n\n    bool JavascriptArray::Jit_OperationCreatedFirstMissingValue(\n        const DynamicObjectFlags flagsBeforeOperation,\n        const Var varAfterOperation)\n    {\n        // This is a helper function used by jitted code\n\n        Assert(varAfterOperation);\n\n        return\n            !!(flagsBeforeOperation & DynamicObjectFlags::HasNoMissingValues) &&\n            !(Jit_GetArrayFlagsForArrayOrObjectWithArray(varAfterOperation) & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    bool JavascriptArray::HasNoMissingValues() const\n    {\n        return !!(GetFlags() & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    bool JavascriptArray::HasNoMissingValues_Unchecked() const // do not use except in extreme circumstances\n    {\n        return !!(GetFlags_Unchecked() & DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    void JavascriptArray::SetHasNoMissingValues(const bool hasNoMissingValues)\n    {\n        SetFlags(\n            hasNoMissingValues\n                ? GetFlags() | DynamicObjectFlags::HasNoMissingValues\n                : GetFlags() & ~DynamicObjectFlags::HasNoMissingValues);\n    }\n\n    template<class T>\n    bool JavascriptArray::IsMissingHeadSegmentItemImpl(const uint32 index) const\n    {\n        Assert(index < head->length);\n\n        return SparseArraySegment<T>::IsMissingItem(&static_cast<SparseArraySegment<T> *>(head)->elements[index]);\n    }\n\n    bool JavascriptArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<Var>(index);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    void JavascriptCopyOnAccessNativeIntArray::ConvertCopyOnAccessSegment()\n    {\n        Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));\n        SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));\n        SparseArraySegment<int32> *newSeg = SparseArraySegment<int32>::AllocateLiteralHeadSegment(this->GetRecycler(), seg->length);\n\n#if ENABLE_DEBUG_CONFIG_OPTIONS\n        if (Js::Configuration::Global.flags.TestTrace.IsEnabled(Js::CopyOnAccessArrayPhase))\n        {\n            Output::Print(_u(\"Convert copy-on-access array: index(%d) length(%d)\\n\"), this->GetHead(), seg->length);\n            Output::Flush();\n        }\n#endif\n\n        newSeg->CopySegment(this->GetRecycler(), newSeg, 0, seg, 0, seg->length);\n        this->SetHeadAndLastUsedSegment(newSeg);\n\n        VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(this);\n        this->type = JavascriptNativeIntArray::GetInitialType(this->GetScriptContext());\n\n        ArrayCallSiteInfo *arrayInfo = this->GetArrayCallSiteInfo();\n        if (arrayInfo && !arrayInfo->isNotCopyOnAccessArray)\n        {\n            arrayInfo->isNotCopyOnAccessArray = 1;\n        }\n    }\n\n    uint32 JavascriptCopyOnAccessNativeIntArray::GetNextIndex(uint32 index) const\n    {\n        if (this->length == 0 || (index != Js::JavascriptArray::InvalidIndex && index >= this->length))\n        {\n            return Js::JavascriptArray::InvalidIndex;\n        }\n        else if (index == Js::JavascriptArray::InvalidIndex)\n        {\n            return 0;\n        }\n        else\n        {\n            return index + 1;\n        }\n    }\n\n    BOOL JavascriptCopyOnAccessNativeIntArray::DirectGetItemAt(uint32 index, int* outVal)\n    {\n        Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));\n        SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));\n\n        if (this->length == 0 || index == Js::JavascriptArray::InvalidIndex || index >= this->length)\n        {\n            return FALSE;\n        }\n        else\n        {\n            *outVal = seg->elements[index];\n            return TRUE;\n        }\n    }\n#endif\n\n    bool JavascriptNativeIntArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<int32>(index);\n    }\n\n    bool JavascriptNativeFloatArray::IsMissingHeadSegmentItem(const uint32 index) const\n    {\n        return IsMissingHeadSegmentItemImpl<double>(index);\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const T& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)\n    {\n        RecyclableObject* prototype = srcArray->GetPrototype();\n        while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {\n                T n = dstIndex + (index - start);\n                dstArray->DirectSetItemAt(n, value);\n\n                count++;\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n    }\n\n    template<>\n    void JavascriptArray::InternalFillFromPrototype<uint32>(JavascriptArray *dstArray, const uint32& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)\n    {\n        RecyclableObject* prototype = srcArray->GetPrototype();\n        while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {\n                uint32 n = dstIndex + (index - start);\n                dstArray->SetItem(n, value, PropertyOperation_None);\n\n                count++;\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n    }\n\n    /* static */\n    bool JavascriptArray::HasInlineHeadSegment(uint32 length)\n    {\n        return length <= SparseArraySegmentBase::INLINE_CHUNK_SIZE;\n    }\n\n    Var JavascriptArray::OP_NewScArray(uint32 elementCount, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        return scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n    }\n\n    Var JavascriptArray::OP_NewScArrayWithElements(uint32 elementCount, Var *elements, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(elementCount <= head->length);\n        js_memcpy_s(head->elements, sizeof(Var) * head->length, elements, sizeof(Var) * elementCount);\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n\n        return arr;\n    }\n\n    Var JavascriptArray::OP_NewScArrayWithMissingValues(uint32 elementCount, ScriptContext* scriptContext)\n    {\n        // Called only to create array literals: size is known.\n        JavascriptArray *const array = static_cast<JavascriptArray *>(OP_NewScArray(elementCount, scriptContext));\n        array->SetHasNoMissingValues(false);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)array->head;\n        head->FillSegmentBuffer(0, elementCount);\n\n        return array;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScArray(uint32 elementCount, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(elementCount);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(elementCount);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);\n        return arr;\n    }\n#endif\n    Var JavascriptArray::OP_NewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext)\n    {\n        uint32 count = ints->count;\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(count > 0 && count == head->length);\n        for (uint i = 0; i < count; i++)\n        {\n            head->elements[i] = JavascriptNumber::ToVar(ints->elements[i], scriptContext);\n        }\n        return arr;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        // Called only to create array literals: size is known.\n        uint32 count = ints->count;\n\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr;\n\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary *lib = scriptContext->GetLibrary();\n            FunctionBody *functionBody = weakFuncRef->Get();\n\n            if (JavascriptLibrary::IsCopyOnAccessArrayCallSite(lib, arrayInfo, count))\n            {\n                Assert(lib->cacheForCopyOnAccessArraySegments);\n                arr = scriptContext->GetLibrary()->CreateCopyOnAccessNativeIntArrayLiteral(arrayInfo, functionBody, ints);\n            }\n            else\n#endif\n            {\n                arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(count);\n                SparseArraySegment<int32> *head = static_cast<SparseArraySegment<int32>*>(arr->head);\n                Assert(count > 0 && count == head->length);\n                js_memcpy_s(head->elements, sizeof(int32)* head->length, ints->elements, sizeof(int32)* count);\n            }\n\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);\n            SparseArraySegment<double> *head = (SparseArraySegment<double>*)arr->head;\n            Assert(count > 0 && count == head->length);\n            for (uint i = 0; i < count; i++)\n            {\n                head->elements[i] = (double)ints->elements[i];\n            }\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        return OP_NewScIntArray(ints, scriptContext);\n    }\n#endif\n\n    Var JavascriptArray::OP_NewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext)\n    {\n        uint32 count = doubles->count;\n        JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);\n        SparseArraySegment<Var> *head = (SparseArraySegment<Var>*)arr->head;\n        Assert(count > 0 && count == head->length);\n        for (uint i = 0; i < count; i++)\n        {\n            double dval = doubles->elements[i];\n            int32 ival;\n            if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))\n            {\n                head->elements[i] = TaggedInt::ToVarUnchecked(ival);\n            }\n            else\n            {\n                head->elements[i] = JavascriptNumber::ToVarNoCheck(dval, scriptContext);\n            }\n        }\n        return arr;\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        // Called only to create array literals: size is known.\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            arrayInfo->SetIsNotNativeIntArray();\n            uint32 count = doubles->count;\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);\n            SparseArraySegment<double> *head = (SparseArraySegment<double>*)arr->head;\n            Assert(count > 0 && count == head->length);\n            js_memcpy_s(head->elements, sizeof(double) * head->length, doubles->elements, sizeof(double) * count);\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n\n            return arr;\n        }\n\n        return OP_NewScFltArray(doubles, scriptContext);\n    }\n\n    Var JavascriptArray::ProfiledNewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n\n        Assert(JavascriptFunction::Is(function) &&\n               JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);\n        Assert(callInfo.Count >= 2);\n\n        ArrayCallSiteInfo *arrayInfo = (ArrayCallSiteInfo*)args[0];\n        JavascriptArray* pNew = nullptr;\n\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                if (arrayInfo && arrayInfo->IsNativeArray())\n                {\n                    if (arrayInfo->IsNativeIntArray())\n                    {\n                        pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);\n                    }\n                    else\n                    {\n                        pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);\n                    }\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateArray(elementCount);\n                }\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                if (arrayInfo && arrayInfo->IsNativeArray())\n                {\n                    if (arrayInfo->IsNativeIntArray())\n                    {\n                        pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);\n                    }\n                    else\n                    {\n                        pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);\n                    }\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateArray(uvalue);\n                }\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            if (arrayInfo && arrayInfo->IsNativeArray())\n            {\n                if (arrayInfo->IsNativeIntArray())\n                {\n                    pNew = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);\n                }\n                else\n                {\n                    pNew = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);\n                }\n            }\n            else\n            {\n                pNew = function->GetLibrary()->CreateArray(callInfo.Count - 1);\n            }\n            pNew->FillFromArgs(callInfo.Count - 1, 0, args.Values, arrayInfo);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n        return pNew;\n    }\n#endif\n\n    Var JavascriptArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        // Call to new Array(), possibly under another name.\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        // SkipDefaultNewObject function flag should have prevented the default object\n        // being created, except when call true a host dispatch.\n        const CallInfo &callInfo = args.Info;\n        Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];\n        bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);\n        Assert( isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr\n            || JavascriptOperators::GetTypeId(args[0]) == TypeIds_HostDispatch);\n\n        ScriptContext* scriptContext = function->GetScriptContext();\n        JavascriptArray* pNew = nullptr;\n\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            pNew = CreateArrayFromConstructorNoArg(function, scriptContext);\n\n            return isCtorSuperCall ?\n                JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :\n                pNew;\n        }\n\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                pNew = CreateArrayFromConstructor(function, elementCount, scriptContext);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                pNew = CreateArrayFromConstructor(function, uvalue, scriptContext);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = CreateArrayFromConstructor(function, 1, scriptContext);\n\n                JavascriptOperators::SetItem(pNew, pNew, 0u, firstArgument, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n\n                // If we were passed an uninitialized JavascriptArray as the this argument,\n                // we need to set the length. We must do this _after_ setting the first\n                // element as the array may have side effects such as a setter for property\n                // named '0' which would make the previous length of the array observable.\n                // If we weren't passed a JavascriptArray as the this argument, this is no-op.\n                pNew->SetLength(1);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n            pNew = CreateArrayFromConstructor(function, callInfo.Count - 1, scriptContext);\n            pNew->JavascriptArray::FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n        return isCtorSuperCall ?\n            JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :\n            pNew;\n    }\n\n    JavascriptArray* JavascriptArray::CreateArrayFromConstructor(RecyclableObject* constructor, uint32 length, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = constructor->GetLibrary();\n\n        // Create the Array object we'll return - this is the only way to create an object which is an exotic Array object.\n        // Note: We need to use the library from the ScriptContext of the constructor, not the currently executing function.\n        //       This is for the case where a built-in @@create method from a different JavascriptLibrary is installed on\n        //       constructor.\n        return library->CreateArray(length);\n    }\n\n    JavascriptArray* JavascriptArray::CreateArrayFromConstructorNoArg(RecyclableObject* constructor, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = constructor->GetLibrary();\n        return library->CreateArray();\n    }\n\n#if ENABLE_PROFILE_INFO\n    Var JavascriptArray::ProfiledNewInstanceNoArg(RecyclableObject *function, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)\n    {\n        Assert(JavascriptFunction::Is(function) &&\n               JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);\n\n        if (arrayInfo->IsNativeIntArray())\n        {\n            JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArray();\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        if (arrayInfo->IsNativeFloatArray())\n        {\n            JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArray();\n            arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);\n            return arr;\n        }\n\n        return scriptContext->GetLibrary()->CreateArray();\n    }\n#endif\n\n    Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        Assert(!PHASE_OFF1(NativeArrayPhase));\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        const CallInfo &callInfo = args.Info;\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            return function->GetLibrary()->CreateNativeIntArray();\n        }\n\n        JavascriptArray* pNew = nullptr;\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            JavascriptNativeIntArray *arr = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);\n            pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n\n        return pNew;\n    }\n\n    Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n        return NewInstance(function, args);\n    }\n\n    Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, Arguments args)\n    {\n        Assert(!PHASE_OFF1(NativeArrayPhase));\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        const CallInfo &callInfo = args.Info;\n        if (callInfo.Count < 2)\n        {\n            // No arguments passed to Array(), so create with the default size (0).\n            return function->GetLibrary()->CreateNativeFloatArray();\n        }\n\n        JavascriptArray* pNew = nullptr;\n        if (callInfo.Count == 2)\n        {\n            // Exactly one argument, which is the array length if it's a uint32.\n            Var firstArgument = args[1];\n            int elementCount;\n            if (TaggedInt::Is(firstArgument))\n            {\n                elementCount = TaggedInt::ToInt32(firstArgument);\n                if (elementCount < 0)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))\n            {\n                // Non-tagged-int number: make sure the double value is really a uint32.\n                double value = JavascriptNumber::GetValue(firstArgument);\n                uint32 uvalue = JavascriptConversion::ToUInt32(value);\n                if (value != uvalue)\n                {\n                    JavascriptError::ThrowRangeError(\n                        function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);\n                }\n                pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);\n            }\n            else\n            {\n                //\n                // First element is not int/double\n                // create an array of length 1.\n                // Set first element as the passed Var\n                //\n\n                pNew = function->GetLibrary()->CreateArray(1);\n                pNew->DirectSetItemAt<Var>(0, firstArgument);\n            }\n        }\n        else\n        {\n            // Called with a list of initial element values.\n            // Create an array of the appropriate length and walk the list.\n\n            JavascriptNativeFloatArray *arr = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);\n            pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);\n        }\n\n#ifdef VALIDATE_ARRAY\n        pNew->ValidateArray();\n#endif\n\n        return pNew;\n    }\n\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n\n            bool isTaggedInt = TaggedInt::Is(item);\n            bool isTaggedIntMissingValue = false;\n#ifdef _M_AMD64\n            if (isTaggedInt)\n            {\n                int32 iValue = TaggedInt::ToInt32(item);\n                isTaggedIntMissingValue = Js::SparseArraySegment<int32>::IsMissingItem(&iValue);\n            }\n#endif\n            if (isTaggedInt && !isTaggedIntMissingValue)\n            {\n                // This is taggedInt case and we verified that item is not missing value in AMD64.\n                this->DirectSetItemAt(i, TaggedInt::ToInt32(item));\n            }\n            else if (!isTaggedIntMissingValue && JavascriptNumber::Is_NoTaggedIntCheck(item))\n            {\n                double dvalue = JavascriptNumber::GetValue(item);\n                int32 ivalue;\n                if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !Js::SparseArraySegment<int32>::IsMissingItem(&ivalue))\n                {\n                    this->DirectSetItemAt(i, ivalue);\n                }\n                else\n                {\n#if ENABLE_PROFILE_INFO\n                    if (arrayInfo)\n                    {\n                        arrayInfo->SetIsNotNativeIntArray();\n                    }\n#endif\n\n                    if (HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)\n                    {\n                        // Avoid shrinking the number of elements in the head segment. We can still create a new\n                        // array here, so go ahead.\n                        JavascriptNativeFloatArray *fArr =\n                            this->GetScriptContext()->GetLibrary()->CreateNativeFloatArrayLiteral(length);\n                        return fArr->JavascriptNativeFloatArray::FillFromArgs(length, 0, args);\n                    }\n\n                    JavascriptNativeFloatArray *fArr = JavascriptNativeIntArray::ToNativeFloatArray(this);\n                    fArr->DirectSetItemAt(i, dvalue);\n#if ENABLE_PROFILE_INFO\n                    return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, arrayInfo, dontCreateNewArray);\n#else\n                    return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, dontCreateNewArray);\n#endif\n                }\n            }\n            else\n            {\n#if ENABLE_PROFILE_INFO\n                if (arrayInfo)\n                {\n                    arrayInfo->SetIsNotNativeArray();\n                }\n#endif\n\n                #pragma prefast(suppress:6237, \"The right hand side condition does not have any side effects.\")\n                if (sizeof(int32) < sizeof(Var) && HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)\n                {\n                    // Avoid shrinking the number of elements in the head segment. We can still create a new\n                    // array here, so go ahead.\n                    JavascriptArray *arr = this->GetScriptContext()->GetLibrary()->CreateArrayLiteral(length);\n                    return arr->JavascriptArray::FillFromArgs(length, 0, args);\n                }\n\n                JavascriptArray *arr = JavascriptNativeIntArray::ToVarArray(this);\n#if ENABLE_PROFILE_INFO\n                return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);\n#else\n                return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);\n#endif\n            }\n        }\n\n        return this;\n    }\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n            if (TaggedInt::Is(item))\n            {\n                this->DirectSetItemAt(i, TaggedInt::ToDouble(item));\n            }\n            else if (JavascriptNumber::Is_NoTaggedIntCheck(item))\n            {\n                this->DirectSetItemAt(i, JavascriptNumber::GetValue(item));\n            }\n            else\n            {\n                JavascriptArray *arr = JavascriptNativeFloatArray::ToVarArray(this);\n#if ENABLE_PROFILE_INFO\n                if (arrayInfo)\n                {\n                    arrayInfo->SetIsNotNativeArray();\n                }\n                return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);\n#else\n                return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);\n#endif\n            }\n        }\n\n        return this;\n    }\n\n#if ENABLE_PROFILE_INFO\n    JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)\n#else\n    JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)\n#endif\n    {\n        uint32 i;\n        for (i = start; i < length; i++)\n        {\n            Var item = args[i + 1];\n            this->DirectSetItemAt(i, item);\n        }\n\n        return this;\n    }\n\n    DynamicType * JavascriptNativeIntArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetNativeIntArrayType();\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    DynamicType * JavascriptCopyOnAccessNativeIntArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetCopyOnAccessNativeIntArrayType();\n    }\n#endif\n\n    JavascriptNativeFloatArray *JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(intArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Float array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Float array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Int array to Float array\"));\n                Output::Flush();\n            }\n#endif\n\n            arrayInfo->SetIsNotNativeIntArray();\n        }\n#endif\n\n        // Grow the segments\n\n        ScriptContext *scriptContext = intArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = intArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            int i;\n            int32 ival;\n\n            // The old segment will have size/2 and length capped by the new size.\n            seg->size >>= 1;\n            if (seg == intArray->head || seg->length > (seg->size >>= 1))\n            {\n                // Some live elements are being pushed out of this segment, so allocate a new one.\n                SparseArraySegment<double> *newSeg =\n                    SparseArraySegment<double>::AllocateSegment(recycler, left, length, nextSeg);\n                Assert(newSeg != nullptr);\n                Assert((prevSeg == nullptr) == (seg == intArray->head));\n                newSeg->next = nextSeg;\n                intArray->LinkSegments((SparseArraySegment<double>*)prevSeg, newSeg);\n                if (intArray->GetLastUsedSegment() == seg)\n                {\n                    intArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n                SegmentBTree * segmentMap = intArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n\n                // Fill the new segment with the overflow.\n                for (i = 0; (uint)i < newSeg->length; i++)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i /*+ seg->length*/];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        continue;\n                    }\n                    newSeg->elements[i] = (double)ival;\n                }\n            }\n            else\n            {\n                // Now convert the contents that will remain in the old segment.\n                for (i = seg->length - 1; i >= 0; i--)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        ((SparseArraySegment<double>*)seg)->elements[i] = (double)JavascriptNativeFloatArray::MissingItem;\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<double>*)seg)->elements[i] = (double)ival;\n                    }\n                }\n                prevSeg = seg;\n            }\n        }\n\n        if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())\n        {\n            intArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();\n        }\n        else\n        {\n            if (intArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);\n                }\n                else\n                {\n                    intArray->ChangeType();\n                }\n            }\n            intArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(intArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(intArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));\n            VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(intArray);\n        }\n\n        return (JavascriptNativeFloatArray*)intArray;\n    }\n\n    /*\n    *   JavascriptArray::ChangeArrayTypeToNativeArray<double>\n    *   -   Converts the Var Array's type to NativeFloat.\n    *   -   Sets the VirtualTable to \"JavascriptNativeFloatArray\"\n    */\n    template<>\n    void JavascriptArray::ChangeArrayTypeToNativeArray<double>(JavascriptArray * varArray, ScriptContext * scriptContext)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())\n        {\n            varArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();\n        }\n        else\n        {\n            if (varArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);\n                }\n                else\n                {\n                    varArray->ChangeType();\n                }\n            }\n            varArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(varArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(varArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));\n            VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(varArray);\n        }\n    }\n\n    /*\n    *   JavascriptArray::ChangeArrayTypeToNativeArray<int32>\n    *   -   Converts the Var Array's type to NativeInt.\n    *   -   Sets the VirtualTable to \"JavascriptNativeIntArray\"\n    */\n    template<>\n    void JavascriptArray::ChangeArrayTypeToNativeArray<int32>(JavascriptArray * varArray, ScriptContext * scriptContext)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())\n        {\n            varArray->type = scriptContext->GetLibrary()->GetNativeIntArrayType();\n        }\n        else\n        {\n            if (varArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);\n                }\n                else\n                {\n                    varArray->ChangeType();\n                }\n            }\n            varArray->GetType()->SetTypeId(TypeIds_NativeIntArray);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(varArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::SetVirtualTable(varArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));\n            VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(varArray);\n        }\n    }\n\n    template<>\n    int32 JavascriptArray::GetNativeValue<int32>(Js::Var ival, ScriptContext * scriptContext)\n    {\n        return JavascriptConversion::ToInt32(ival, scriptContext);\n    }\n\n    template <>\n    double JavascriptArray::GetNativeValue<double>(Var ival, ScriptContext * scriptContext)\n    {\n        return JavascriptConversion::ToNumber(ival, scriptContext);\n    }\n\n\n    /*\n    *   JavascriptArray::ConvertToNativeArrayInPlace\n    *   In place conversion of all Var elements to Native Int/Double elements in an array.\n    *   We do not update the DynamicProfileInfo of the array here.\n    */\n    template<typename NativeArrayType, typename T>\n    NativeArrayType *JavascriptArray::ConvertToNativeArrayInPlace(JavascriptArray *varArray)\n    {\n        AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");\n\n        ScriptContext *scriptContext = varArray->GetScriptContext();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = varArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            int i;\n            Var ival;\n\n            uint32 growFactor = sizeof(Var) / sizeof(T);\n            AssertMsg(growFactor == 1, \"We support only in place conversion of Var array to Native Array\");\n\n            // Now convert the contents that will remain in the old segment.\n            for (i = seg->length - 1; i >= 0; i--)\n            {\n                ival = ((SparseArraySegment<Var>*)seg)->elements[i];\n                if (ival == JavascriptArray::MissingItem)\n                {\n                    ((SparseArraySegment<T>*)seg)->elements[i] = NativeArrayType::MissingItem;\n                }\n                else\n                {\n                    ((SparseArraySegment<T>*)seg)->elements[i] = GetNativeValue<T>(ival, scriptContext);\n                }\n            }\n            prevSeg = seg;\n        }\n\n        // Update the type of the Array\n        ChangeArrayTypeToNativeArray<T>(varArray, scriptContext);\n\n        return (NativeArrayType*)varArray;\n    }\n\n    JavascriptArray *JavascriptNativeIntArray::ConvertToVarArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(intArray);\n#endif\n        ScriptContext *scriptContext = intArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = intArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            uint32 size = seg->size;\n            if (size == 0)\n            {\n                continue;\n            }\n\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            int i;\n            int32 ival;\n\n            // Shrink?\n            uint32 growFactor = sizeof(Var) / sizeof(int32);\n            if ((growFactor != 1 && (seg == intArray->head || seg->length > (seg->size /= growFactor))) ||\n                (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler)))\n            {\n                // Some live elements are being pushed out of this segment, so allocate a new one.\n                // And/or the old segment is not scanned by the recycler, so we need a new one to hold vars.\n                SparseArraySegment<Var> *newSeg =\n                    SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);\n\n                AnalysisAssert(newSeg);\n                Assert((prevSeg == nullptr) == (seg == intArray->head));\n                newSeg->next = nextSeg;\n                intArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);\n                if (intArray->GetLastUsedSegment() == seg)\n                {\n                    intArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n\n                SegmentBTree * segmentMap = intArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n\n                // Fill the new segment with the overflow.\n                for (i = 0; (uint)i < newSeg->length; i++)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        continue;\n                    }\n                    newSeg->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);\n                }\n            }\n            else\n            {\n                // Now convert the contents that will remain in the old segment.\n                // Walk backward in case we're growing the element size.\n                for (i = seg->length - 1; i >= 0; i--)\n                {\n                    ival = ((SparseArraySegment<int32>*)seg)->elements[i];\n                    if (ival == JavascriptNativeIntArray::MissingItem)\n                    {\n                        ((SparseArraySegment<Var>*)seg)->elements[i] = (Var)JavascriptArray::MissingItem;\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<Var>*)seg)->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);\n                    }\n                }\n                prevSeg = seg;\n            }\n        }\n\n        if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())\n        {\n            intArray->type = scriptContext->GetLibrary()->GetArrayType();\n        }\n        else\n        {\n            if (intArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);\n                }\n                else\n                {\n                    intArray->ChangeType();\n                }\n            }\n            intArray->GetType()->SetTypeId(TypeIds_Array);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(intArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(intArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));\n            VirtualTableInfo<JavascriptArray>::SetVirtualTable(intArray);\n        }\n\n        return intArray;\n    }\n    JavascriptArray *JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray *intArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(intArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Int array to Var array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Int array to Var array\"));\n                Output::Flush();\n            }\n#endif\n\n            arrayInfo->SetIsNotNativeArray();\n        }\n#endif\n\n        intArray->ClearArrayCallSiteIndex();\n\n        return ConvertToVarArray(intArray);\n    }\n\n    DynamicType * JavascriptNativeFloatArray::GetInitialType(ScriptContext * scriptContext)\n    {\n        return scriptContext->GetLibrary()->GetNativeFloatArrayType();\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::ConvertToVarArray\n    *   This function only converts all Float elements to Var elements in an array.\n    *   DynamicProfileInfo of the array is not updated in this function.\n    */\n    JavascriptArray *JavascriptNativeFloatArray::ConvertToVarArray(JavascriptNativeFloatArray *fArray)\n    {\n        // We can't be growing the size of the element.\n        Assert(sizeof(double) >= sizeof(Var));\n\n        uint32 shrinkFactor = sizeof(double) / sizeof(Var);\n        ScriptContext *scriptContext = fArray->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n        SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;\n        for (seg = fArray->head; seg; seg = nextSeg)\n        {\n            nextSeg = seg->next;\n            if (seg->size == 0)\n            {\n                continue;\n            }\n            uint32 left = seg->left;\n            uint32 length = seg->length;\n            SparseArraySegment<Var> *newSeg;\n            if (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler))\n            {\n                // The old segment is not scanned by the recycler, so we need a new one to hold vars.\n                newSeg =\n                    SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);\n                Assert((prevSeg == nullptr) == (seg == fArray->head));\n                newSeg->next = nextSeg;\n                fArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);\n                if (fArray->GetLastUsedSegment() == seg)\n                {\n                    fArray->SetLastUsedSegment(newSeg);\n                }\n                prevSeg = newSeg;\n\n                SegmentBTree * segmentMap = fArray->GetSegmentMap();\n                if (segmentMap)\n                {\n                    segmentMap->SwapSegment(left, seg, newSeg);\n                }\n            }\n            else\n            {\n                newSeg = (SparseArraySegment<Var>*)seg;\n                prevSeg = seg;\n                if (shrinkFactor != 1)\n                {\n                    uint32 newSize = seg->size * shrinkFactor;\n                    uint32 limit;\n                    if (seg->next)\n                    {\n                        limit = seg->next->left;\n                    }\n                    else\n                    {\n                        limit = JavascriptArray::MaxArrayLength;\n                    }\n                    seg->size = min(newSize, limit - seg->left);\n                }\n            }\n            uint32 i;\n            for (i = 0; i < seg->length; i++)\n            {\n                if (SparseArraySegment<double>::IsMissingItem(&((SparseArraySegment<double>*)seg)->elements[i]))\n                {\n                    if (seg == newSeg)\n                    {\n                        newSeg->elements[i] = (Var)JavascriptArray::MissingItem;\n                    }\n                    Assert(newSeg->elements[i] == (Var)JavascriptArray::MissingItem);\n                }\n                else if (*(uint64*)&(((SparseArraySegment<double>*)seg)->elements[i]) == 0ull)\n                {\n                    newSeg->elements[i] = TaggedInt::ToVarUnchecked(0);\n                }\n                else\n                {\n                    int32 ival;\n                    double dval = ((SparseArraySegment<double>*)seg)->elements[i];\n                    if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))\n                    {\n                        newSeg->elements[i] = TaggedInt::ToVarUnchecked(ival);\n                    }\n                    else\n                    {\n                        newSeg->elements[i] = JavascriptNumber::ToVarWithCheck(dval, scriptContext);\n                    }\n                }\n            }\n            if (seg == newSeg && shrinkFactor != 1)\n            {\n                // Fill the remaining slots.\n                newSeg->FillSegmentBuffer(i, seg->size);\n            }\n        }\n\n        if (fArray->GetType() == scriptContext->GetLibrary()->GetNativeFloatArrayType())\n        {\n            fArray->type = scriptContext->GetLibrary()->GetArrayType();\n        }\n        else\n        {\n            if (fArray->GetDynamicType()->GetIsLocked())\n            {\n                DynamicTypeHandler *typeHandler = fArray->GetDynamicType()->GetTypeHandler();\n                if (typeHandler->IsPathTypeHandler())\n                {\n                    // We can't allow a type with the new type ID to be promoted to the old type.\n                    // So go to a dictionary type handler, which will orphan the new type.\n                    // This should be a corner case, so the inability to share the new type is unlikely to matter.\n                    // If it does matter, try building a path from the new type's built-in root.\n                    static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(fArray);\n                }\n                else\n                {\n                    fArray->ChangeType();\n                }\n            }\n            fArray->GetType()->SetTypeId(TypeIds_Array);\n        }\n\n        if (CrossSite::IsCrossSiteObjectTyped(fArray))\n        {\n            Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(fArray));\n            VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(fArray);\n        }\n        else\n        {\n            Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(fArray));\n            VirtualTableInfo<JavascriptArray>::SetVirtualTable(fArray);\n        }\n\n        return fArray;\n    }\n\n    JavascriptArray *JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray *fArray)\n    {\n#if ENABLE_PROFILE_INFO\n        ArrayCallSiteInfo *arrayInfo = fArray->GetArrayCallSiteInfo();\n        if (arrayInfo)\n        {\n#if DBG\n            Js::JavascriptStackWalker walker(fArray->GetScriptContext());\n            Js::JavascriptFunction* caller = NULL;\n            bool foundScriptCaller = false;\n            while(walker.GetCaller(&caller))\n            {\n                if(caller != NULL && Js::ScriptFunction::Is(caller))\n                {\n                    foundScriptCaller = true;\n                    break;\n                }\n            }\n\n            if(foundScriptCaller)\n            {\n                Assert(caller);\n                Assert(caller->GetFunctionBody());\n                if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))\n                {\n                    Output::Print(_u(\"Conversion: Float array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);\n                    Output::Flush();\n                }\n            }\n            else\n            {\n                if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n                {\n                    Output::Print(_u(\"Conversion: Float array to Var array across ScriptContexts\"));\n                    Output::Flush();\n                }\n            }\n#else\n            if(PHASE_TRACE1(Js::NativeArrayConversionPhase))\n            {\n                Output::Print(_u(\"Conversion: Float array to Var array\"));\n                Output::Flush();\n            }\n#endif\n\n            if(fArray->GetScriptContext()->IsScriptContextInNonDebugMode())\n            {\n                Assert(!arrayInfo->IsNativeIntArray());\n            }\n\n            arrayInfo->SetIsNotNativeArray();\n        }\n#endif\n\n        fArray->ClearArrayCallSiteIndex();\n\n        return ConvertToVarArray(fArray);\n\n    }\n\n    // Convert Var to index in the Array.\n    // Note: Spec calls out a few rules for these parameters:\n    // 1. if (arg > length) { return length; }\n    // clamp to length, not length-1\n    // 2. if (arg < 0) { return max(0, length + arg); }\n    // treat negative arg as index from the end of the array (with -1 mapping to length-1)\n    // Effectively, this function will return a value between 0 and length, inclusive.\n    int64 JavascriptArray::GetIndexFromVar(Js::Var arg, int64 length, ScriptContext* scriptContext)\n    {\n        int64 index;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue < 0)\n            {\n                index = max<int64>(0, length + intValue);\n            }\n            else\n            {\n                index = intValue;\n            }\n\n            if (index > length)\n            {\n                index = length;\n            }\n        }\n        else\n        {\n            double doubleValue = JavascriptConversion::ToInteger(arg, scriptContext);\n\n            // Handle the Number.POSITIVE_INFINITY case\n            if (doubleValue > length)\n            {\n                return length;\n            }\n\n            index = NumberUtilities::TryToInt64(doubleValue);\n\n            if (index < 0)\n            {\n                index = max<int64>(0, index + length);\n            }\n        }\n\n        return index;\n    }\n\n    TypeId JavascriptArray::OP_SetNativeIntElementC(JavascriptNativeIntArray *arr, uint32 index, Var value, ScriptContext *scriptContext)\n    {\n        int32 iValue;\n        double dValue;\n\n        TypeId typeId = arr->TrySetNativeIntArrayItem(value, &iValue, &dValue);\n        if (typeId == TypeIds_NativeIntArray)\n        {\n            arr->SetArrayLiteralItem(index, iValue);\n        }\n        else if (typeId == TypeIds_NativeFloatArray)\n        {\n            arr->SetArrayLiteralItem(index, dValue);\n        }\n        else\n        {\n            arr->SetArrayLiteralItem(index, value);\n        }\n        return typeId;\n    }\n\n    TypeId JavascriptArray::OP_SetNativeFloatElementC(JavascriptNativeFloatArray *arr, uint32 index, Var value, ScriptContext *scriptContext)\n    {\n        double dValue;\n        TypeId typeId = arr->TrySetNativeFloatArrayItem(value, &dValue);\n        if (typeId == TypeIds_NativeFloatArray)\n        {\n            arr->SetArrayLiteralItem(index, dValue);\n        }\n        else\n        {\n            arr->SetArrayLiteralItem(index, value);\n        }\n        return typeId;\n    }\n\n    template<typename T>\n    void JavascriptArray::SetArrayLiteralItem(uint32 index, T value)\n    {\n        SparseArraySegment<T> * segment = (SparseArraySegment<T>*)this->head;\n\n        Assert(segment->left == 0);\n        Assert(index < segment->length);\n\n        segment->elements[index] = value;\n    }\n\n    void JavascriptNativeIntArray::SetIsPrototype()\n    {\n        // Force the array to be non-native to simplify inspection, filling from proto, etc.\n        ToVarArray(this);\n        __super::SetIsPrototype();\n    }\n\n    void JavascriptNativeFloatArray::SetIsPrototype()\n    {\n        // Force the array to be non-native to simplify inspection, filling from proto, etc.\n        ToVarArray(this);\n        __super::SetIsPrototype();\n    }\n\n#if ENABLE_PROFILE_INFO\n    ArrayCallSiteInfo *JavascriptNativeArray::GetArrayCallSiteInfo()\n    {\n        RecyclerWeakReference<FunctionBody> *weakRef = this->weakRefToFuncBody;\n        if (weakRef)\n        {\n            FunctionBody *functionBody = weakRef->Get();\n            if (functionBody)\n            {\n                if (functionBody->HasDynamicProfileInfo())\n                {\n                    Js::ProfileId profileId = this->GetArrayCallSiteIndex();\n                    if (profileId < functionBody->GetProfiledArrayCallSiteCount())\n                    {\n                        return functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, profileId);\n                    }\n                }\n            }\n            else\n            {\n                this->ClearArrayCallSiteIndex();\n            }\n        }\n        return nullptr;\n    }\n\n    void JavascriptNativeArray::SetArrayProfileInfo(RecyclerWeakReference<FunctionBody> *weakRef, ArrayCallSiteInfo *arrayInfo)\n    {\n        Assert(weakRef);\n        FunctionBody *functionBody = weakRef->Get();\n        if (functionBody && functionBody->HasDynamicProfileInfo())\n        {\n            ArrayCallSiteInfo *baseInfo = functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, 0);\n            Js::ProfileId index = (Js::ProfileId)(arrayInfo - baseInfo);\n            Assert(index < functionBody->GetProfiledArrayCallSiteCount());\n            SetArrayCallSite(index, weakRef);\n        }\n    }\n\n    void JavascriptNativeArray::CopyArrayProfileInfo(Js::JavascriptNativeArray* baseArray)\n    {\n        if (baseArray->weakRefToFuncBody)\n        {\n            if (baseArray->weakRefToFuncBody->Get())\n            {\n                SetArrayCallSite(baseArray->GetArrayCallSiteIndex(), baseArray->weakRefToFuncBody);\n            }\n            else\n            {\n                baseArray->ClearArrayCallSiteIndex();\n            }\n        }\n    }\n#endif\n\n    Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)\n    {\n        if (JavascriptNativeIntArray::Is(this))\n        {\n            return this->FindMinOrMax<int32, false>(scriptContext, findMax);\n        }\n        else\n        {\n            return this->FindMinOrMax<double, true>(scriptContext, findMax);\n        }\n    }\n\n    template <typename T, bool checkNaNAndNegZero>\n    Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)\n    {\n        AssertMsg(this->HasNoMissingValues(), \"Fastpath is only for arrays with one segment and no missing values\");\n        uint len = this->GetLength();\n\n        Js::SparseArraySegment<T>* headSegment = ((Js::SparseArraySegment<T>*)this->GetHead());\n        uint headSegLen = headSegment->length;\n        Assert(headSegLen == len);\n\n        if (headSegment->next == nullptr)\n        {\n            T currentRes = headSegment->elements[0];\n            for (uint i = 0; i < headSegLen; i++)\n            {\n                T compare = headSegment->elements[i];\n                if (checkNaNAndNegZero && JavascriptNumber::IsNan(double(compare)))\n                {\n                    return scriptContext->GetLibrary()->GetNaN();\n                }\n                if (findMax ? currentRes < compare : currentRes > compare ||\n                    (checkNaNAndNegZero && compare == 0 && Js::JavascriptNumber::IsNegZero(double(currentRes))))\n                {\n                    currentRes = compare;\n                }\n            }\n            return Js::JavascriptNumber::ToVarNoCheck(currentRes, scriptContext);\n        }\n        else\n        {\n            AssertMsg(false, \"FindMinOrMax currently supports native arrays with only one segment\");\n            Throw::FatalInternalError();\n        }\n    }\n\n    SparseArraySegmentBase * JavascriptArray::GetLastUsedSegment() const\n    {\n        return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot->lastUsedSegment : segmentUnion.lastUsedSegment);\n    }\n\n    void JavascriptArray::SetHeadAndLastUsedSegment(SparseArraySegmentBase * segment)\n    {\n\n        Assert(!HasSegmentMap());\n        this->head = this->segmentUnion.lastUsedSegment = segment;\n    }\n\n    void JavascriptArray::SetLastUsedSegment(SparseArraySegmentBase * segment)\n    {\n        if (HasSegmentMap())\n        {\n            this->segmentUnion.segmentBTreeRoot->lastUsedSegment = segment;\n        }\n        else\n        {\n            this->segmentUnion.lastUsedSegment = segment;\n        }\n    }\n    bool JavascriptArray::HasSegmentMap() const\n    {\n        return !!(GetFlags() & DynamicObjectFlags::HasSegmentMap);\n    }\n\n    SegmentBTreeRoot * JavascriptArray::GetSegmentMap() const\n    {\n        return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot : nullptr);\n    }\n\n    void JavascriptArray::SetSegmentMap(SegmentBTreeRoot * segmentMap)\n    {\n        Assert(!HasSegmentMap());\n        SparseArraySegmentBase * lastUsedSeg = this->segmentUnion.lastUsedSegment;\n        SetFlags(GetFlags() | DynamicObjectFlags::HasSegmentMap);\n        segmentUnion.segmentBTreeRoot = segmentMap;\n        segmentMap->lastUsedSegment = lastUsedSeg;\n    }\n\n    void JavascriptArray::ClearSegmentMap()\n    {\n        if (HasSegmentMap())\n        {\n            SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n            SparseArraySegmentBase * lastUsedSeg = segmentUnion.segmentBTreeRoot->lastUsedSegment;\n            segmentUnion.segmentBTreeRoot = nullptr;\n            segmentUnion.lastUsedSegment = lastUsedSeg;\n        }\n    }\n\n    SegmentBTreeRoot * JavascriptArray::BuildSegmentMap()\n    {\n        Recycler* recycler = GetRecycler();\n        SegmentBTreeRoot* tmpSegmentMap = AllocatorNewStruct(Recycler, recycler, SegmentBTreeRoot);\n        ForEachSegment([recycler, tmpSegmentMap](SparseArraySegmentBase * current)\n        {\n            tmpSegmentMap->Add(recycler, current);\n            return false;\n        });\n\n        // There could be OOM during building segment map. Save to array only after its successful completion.\n        SetSegmentMap(tmpSegmentMap);\n        return tmpSegmentMap;\n    }\n\n    void JavascriptArray::TryAddToSegmentMap(Recycler* recycler, SparseArraySegmentBase* seg)\n    {\n        SegmentBTreeRoot * savedSegmentMap = GetSegmentMap();\n        if (savedSegmentMap)\n        {\n            //\n            // We could OOM and throw when adding to segmentMap, resulting in a corrupted segmentMap on this\n            // array. Set segmentMap to null temporarily to protect from this. It will be restored correctly\n            // if adding segment succeeds.\n            //\n            ClearSegmentMap();\n            savedSegmentMap->Add(recycler, seg);\n            SetSegmentMap(savedSegmentMap);\n        }\n    }\n\n    void JavascriptArray::InvalidateLastUsedSegment()\n    {\n        this->SetLastUsedSegment(this->head);\n    }\n\n    DescriptorFlags JavascriptArray::GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        DescriptorFlags flags;\n        if (GetSetterBuiltIns(propertyId, info, &flags))\n        {\n            return flags;\n        }\n        return __super::GetSetter(propertyId, setterValue, info, requestContext);\n    }\n\n    DescriptorFlags JavascriptArray::GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        DescriptorFlags flags;\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && GetSetterBuiltIns(propertyRecord->GetPropertyId(), info, &flags))\n        {\n            return flags;\n        }\n\n        return __super::GetSetter(propertyNameString, setterValue, info, requestContext);\n    }\n\n    bool JavascriptArray::GetSetterBuiltIns(PropertyId propertyId, PropertyValueInfo* info, DescriptorFlags* descriptorFlags)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            PropertyValueInfo::SetNoCache(info, this);\n            *descriptorFlags = WritableData;\n            return true;\n        }\n        return false;\n    }\n\n    SparseArraySegmentBase * JavascriptArray::GetBeginLookupSegment(uint32 index, const bool useSegmentMap) const\n    {\n        SparseArraySegmentBase *seg = nullptr;\n        SparseArraySegmentBase * lastUsedSeg = this->GetLastUsedSegment();\n        if (lastUsedSeg != nullptr && lastUsedSeg->left <= index)\n        {\n            seg = lastUsedSeg;\n            if(index - lastUsedSeg->left < lastUsedSeg->size)\n            {\n                return seg;\n            }\n        }\n\n        SegmentBTreeRoot * segmentMap = GetSegmentMap();\n        if(!useSegmentMap || !segmentMap)\n        {\n            return seg ? seg : this->head;\n        }\n\n        if(seg)\n        {\n            // If indexes are being accessed sequentially, check the segment after the last-used segment before checking the\n            // segment map, as it is likely to hit\n            SparseArraySegmentBase *const nextSeg = seg->next;\n            if(nextSeg)\n            {\n                if(index < nextSeg->left)\n                {\n                    return seg;\n                }\n                else if(index - nextSeg->left < nextSeg->size)\n                {\n                    return nextSeg;\n                }\n            }\n        }\n\n        SparseArraySegmentBase *matchOrNextSeg;\n        segmentMap->Find(index, seg, matchOrNextSeg);\n        return seg ? seg : matchOrNextSeg;\n    }\n\n    uint32 JavascriptArray::GetNextIndex(uint32 index) const\n    {\n        if (JavascriptNativeIntArray::Is((Var)this))\n        {\n            return this->GetNextIndexHelper<int32>(index);\n        }\n        else if (JavascriptNativeFloatArray::Is((Var)this))\n        {\n            return this->GetNextIndexHelper<double>(index);\n        }\n        return this->GetNextIndexHelper<Var>(index);\n    }\n\n    template<typename T>\n    uint32 JavascriptArray::GetNextIndexHelper(uint32 index) const\n    {\n        AssertMsg(this->head, \"array head should never be null\");\n        uint candidateIndex;\n\n        if (index == JavascriptArray::InvalidIndex)\n        {\n            candidateIndex = head->left;\n        }\n        else\n        {\n            candidateIndex = index + 1;\n        }\n\n        SparseArraySegment<T>* current = (SparseArraySegment<T>*)this->GetBeginLookupSegment(candidateIndex);\n\n        while (current != nullptr)\n        {\n            if ((current->left <= candidateIndex) && ((candidateIndex - current->left) < current->length))\n            {\n                for (uint i = candidateIndex - current->left; i < current->length; i++)\n                {\n                    if (!SparseArraySegment<T>::IsMissingItem(&current->elements[i]))\n                    {\n                        return i + current->left;\n                    }\n                }\n            }\n            current = (SparseArraySegment<T>*)current->next;\n            if (current != NULL)\n            {\n                if (candidateIndex < current->left)\n                {\n                    candidateIndex = current->left;\n                }\n            }\n        }\n        return JavascriptArray::InvalidIndex;\n    }\n\n    // If new length > length, we just reset the length\n    // If new length < length, we need to remove the rest of the elements and segment\n    void JavascriptArray::SetLength(uint32 newLength)\n    {\n        if (newLength == length)\n            return;\n\n        if (head == EmptySegment)\n        {\n            // Do nothing to the segment.\n        }\n        else if (newLength == 0)\n        {\n            this->ClearElements(head, 0);\n            head->length = 0;\n            head->next = nullptr;\n            SetHasNoMissingValues();\n\n            ClearSegmentMap();\n            this->InvalidateLastUsedSegment();\n        }\n        else if (newLength < length)\n        {\n            // _ _ 2 3 _ _ 6 7 _ _\n\n            // SetLength(0)\n            // 0 <= left -> set *prev = null\n            // SetLength(2)\n            // 2 <= left -> set *prev = null\n            // SetLength(3)\n            // 3 !<= left; 3 <= right -> truncate to length - 1\n            // SetLength(5)\n            // 5 <=\n\n            SparseArraySegmentBase* next = GetBeginLookupSegment(newLength - 1); // head, or next.left < newLength\n            SparseArraySegmentBase** prev = &head;\n\n            while(next != nullptr)\n            {\n                if (newLength <= next->left)\n                {\n                    ClearSegmentMap(); // truncate segments, null out segmentMap\n                    *prev = nullptr;\n                    break;\n                }\n                else if (newLength <= (next->left + next->length))\n                {\n                    if (next->next)\n                    {\n                        ClearSegmentMap(); // Will truncate segments, null out segmentMap\n                    }\n\n                    uint32 newSegmentLength = newLength - next->left;\n                    this->ClearElements(next, newSegmentLength);\n                    next->next = nullptr;\n                    next->length = newSegmentLength;\n                    break;\n                }\n                else\n                {\n                    prev = &next->next;\n                    next = next->next;\n                }\n            }\n            this->InvalidateLastUsedSegment();\n        }\n        this->length = newLength;\n\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n    }\n\n    BOOL JavascriptArray::SetLength(Var newLength)\n    {\n        ScriptContext *scriptContext;\n        if(TaggedInt::Is(newLength))\n        {\n            int32 lenValue = TaggedInt::ToInt32(newLength);\n            if (lenValue < 0)\n            {\n                scriptContext = GetScriptContext();\n                if (scriptContext->GetThreadContext()->RecordImplicitException())\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n            }\n            else\n            {\n                this->SetLength(lenValue);\n            }\n            return TRUE;\n        }\n\n        scriptContext = GetScriptContext();\n        uint32 uintValue = JavascriptConversion::ToUInt32(newLength, scriptContext);\n        double dblValue = JavascriptConversion::ToNumber(newLength, scriptContext);\n        if (dblValue == uintValue)\n        {\n            this->SetLength(uintValue);\n        }\n        else\n        {\n            ThreadContext* threadContext = scriptContext->GetThreadContext();\n            ImplicitCallFlags flags = threadContext->GetImplicitCallFlags();\n            if (flags != ImplicitCall_None && threadContext->IsDisableImplicitCall())\n            {\n                // We couldn't execute the implicit call(s) needed to convert the newLength to an integer.\n                // Do nothing and let the jitted code bail out.\n                return TRUE;\n            }\n\n            if (threadContext->RecordImplicitException())\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n            }\n        }\n\n        return TRUE;\n    }\n\n    void JavascriptArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<Var>::ClearElements(((SparseArraySegment<Var>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    void JavascriptNativeIntArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<int32>::ClearElements(((SparseArraySegment<int32>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    void JavascriptNativeFloatArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)\n    {\n        SparseArraySegment<double>::ClearElements(((SparseArraySegment<double>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);\n    }\n\n    Var JavascriptArray::DirectGetItem(uint32 index)\n    {\n        SparseArraySegment<Var> *seg = (SparseArraySegment<Var>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<Var>::IsMissingItem(&seg->elements[offset]))\n            {\n                return seg->elements[offset];\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptNativeIntArray::DirectGetItem(uint32 index)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        SparseArraySegment<int32> *seg = (SparseArraySegment<int32>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<int32>::IsMissingItem(&seg->elements[offset]))\n            {\n                return JavascriptNumber::ToVar(seg->elements[offset], GetScriptContext());\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    DescriptorFlags JavascriptNativeIntArray::GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif \n        int32 value = 0;\n        return this->DirectGetItemAt(index, &value) ? WritableData : None;\n    }\n\n\n    Var JavascriptNativeFloatArray::DirectGetItem(uint32 index)\n    {\n        SparseArraySegment<double> *seg = (SparseArraySegment<double>*)this->GetLastUsedSegment();\n        uint32 offset = index - seg->left;\n        if (index >= seg->left && offset < seg->length)\n        {\n            if (!SparseArraySegment<double>::IsMissingItem(&seg->elements[offset]))\n            {\n                return JavascriptNumber::ToVarWithCheck(seg->elements[offset], GetScriptContext());\n            }\n        }\n        Var element;\n        if (DirectGetItemAtFull(index, &element))\n        {\n            return element;\n        }\n        return GetType()->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptArray::DirectGetItem(JavascriptString *propName, ScriptContext* scriptContext)\n    {\n        PropertyRecord const * propertyRecord;\n        scriptContext->GetOrAddPropertyRecord(propName->GetString(), propName->GetLength(), &propertyRecord);\n        return JavascriptOperators::GetProperty(this, propertyRecord->GetPropertyId(), scriptContext, NULL);\n    }\n\n    BOOL JavascriptArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        if (this->DirectGetItemAt(index, outVal))\n        {\n            return TRUE;\n        }\n\n        ScriptContext* requestContext = type->GetScriptContext();\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    //\n    // Link prev and current. If prev is NULL, make current the head segment.\n    //\n    void JavascriptArray::LinkSegmentsCommon(SparseArraySegmentBase* prev, SparseArraySegmentBase* current)\n    {\n        if (prev)\n        {\n            prev->next = current;\n        }\n        else\n        {\n            Assert(current);\n            head = current;\n        }\n    }\n\n    template<typename T>\n    BOOL JavascriptArray::DirectDeleteItemAt(uint32 itemIndex)\n    {\n        if (itemIndex >= length)\n        {\n            return true;\n        }\n        SparseArraySegment<T>* next = (SparseArraySegment<T>*)GetBeginLookupSegment(itemIndex);\n        while(next != nullptr && next->left <= itemIndex)\n        {\n            uint32 limit = next->left + next->length;\n            if (itemIndex < limit)\n            {\n                next->SetElement(GetRecycler(), itemIndex, SparseArraySegment<T>::GetMissingItem());\n                if(itemIndex - next->left == next->length - 1)\n                {\n                    --next->length;\n                }\n                else if(next == head)\n                {\n                    SetHasNoMissingValues(false);\n                }\n                break;\n            }\n            next = (SparseArraySegment<T>*)next->next;\n        }\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n        return true;\n    }\n\n    template <> Var JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)\n    {\n        return idxDest.ToNumber(scriptContext);\n    }\n\n    template <> uint32 JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)\n    {\n        // Note this is only for setting Array length which is a uint32\n        return idxDest.IsSmallIndex() ? idxDest.GetSmallIndex() : UINT_MAX;\n    }\n\n    template <> Var JavascriptArray::ConvertToIndex(uint32 idxDest, ScriptContext* scriptContext)\n    {\n        return  JavascriptNumber::ToVar(idxDest, scriptContext);\n    }\n\n    void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, uint32 index)\n    {\n        if (!succeeded)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(index, scriptContext), scriptContext)->GetSz());\n        }\n    }\n\n    void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, BigIndex index)\n    {\n        if (!succeeded)\n        {\n            uint64 i = (uint64)(index.IsSmallIndex() ? index.GetSmallIndex() : index.GetBigIndex());\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(i, scriptContext), scriptContext)->GetSz());\n        }\n    }\n\n    BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, uint32 idxDest, Var aItem)\n    {\n        return pDestObj->SetItem(idxDest, aItem, Js::PropertyOperation_ThrowIfNotExtensible);\n    }\n    BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, BigIndex idxDest, Var aItem)\n    {\n        ScriptContext* scriptContext = pDestObj->GetScriptContext();\n\n        if (idxDest.IsSmallIndex())\n        {\n            return pDestObj->SetItem(idxDest.GetSmallIndex(), aItem, Js::PropertyOperation_ThrowIfNotExtensible);\n        }\n        PropertyRecord const * propertyRecord;\n        JavascriptOperators::GetPropertyIdForInt(idxDest.GetBigIndex(), scriptContext, &propertyRecord);\n        return pDestObj->SetProperty(propertyRecord->GetPropertyId(), aItem, PropertyOperation_ThrowIfNotExtensible, nullptr);\n    }\n\n    template<typename T>\n    void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, uint start, BigIndex startIdxDest, BOOL FirstPromotedItemIsSpreadable, BigIndex FirstPromotedItemLength)\n    {\n        // This never gets called.\n        Throw::InternalError();\n    }\n    //\n    // Helper for EntryConcat. Concat args or elements of arg arrays into dest array.\n    //\n    template<typename T>\n    void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, uint start, uint startIdxDest, BOOL firstPromotedItemIsSpreadable, BigIndex firstPromotedItemLength)\n    {\n        JavascriptArray* pDestArray = nullptr;\n\n        if (JavascriptArray::Is(pDestObj))\n        {\n            pDestArray = JavascriptArray::FromVar(pDestObj);\n        }\n\n        T idxDest = startIdxDest;\n        for (uint idxArg = start; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n            BOOL spreadable = false;\n            if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())\n            {\n                // firstPromotedItemIsSpreadable is ONLY used to resume after a type promotion from uint32 to uint64\n                // we do this because calls to IsConcatSpreadable are observable (a big deal for proxies) and we don't\n                // want to do the work a second time as soon as we record the length we clear the flag.\n                spreadable = firstPromotedItemIsSpreadable || JavascriptOperators::IsConcatSpreadable(aItem);\n\n                if (!spreadable)\n                {\n                    JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext);\n                    ++idxDest;\n                    continue;\n                }\n            }\n\n            if (pDestArray && JavascriptArray::IsDirectAccessArray(aItem) && JavascriptArray::IsDirectAccessArray(pDestArray)\n                && BigIndex(idxDest + JavascriptArray::FromVar(aItem)->length).IsSmallIndex()) // Fast path\n            {\n                if (JavascriptNativeIntArray::Is(aItem))\n                {\n                    JavascriptNativeIntArray *pItemArray = JavascriptNativeIntArray::FromVar(aItem);\n                    CopyNativeIntArrayElementsToVar(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else if (JavascriptNativeFloatArray::Is(aItem))\n                {\n                    JavascriptNativeFloatArray *pItemArray = JavascriptNativeFloatArray::FromVar(aItem);\n                    CopyNativeFloatArrayElementsToVar(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else\n                {\n                    JavascriptArray* pItemArray = JavascriptArray::FromVar(aItem);\n                    CopyArrayElements(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n            }\n            else\n            {\n                // Flatten if other array or remote array (marked with TypeIds_Array)\n                if (DynamicObject::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array || spreadable)\n                {\n                    //CONSIDER: enumerating remote array instead of walking all indices\n                    BigIndex length;\n                    if (firstPromotedItemIsSpreadable)\n                    {\n                        firstPromotedItemIsSpreadable = false;\n                        length = firstPromotedItemLength;\n                    }\n                    else if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n                    {\n                        // we can cast to uin64 without fear of converting negative numbers to large positive ones\n                        // from int64 because ToLength makes negative lengths 0\n                        length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                    }\n                    else\n                    {\n                        length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                    }\n\n                    if (PromoteToBigIndex(length,idxDest))\n                    {\n                        // This is a special case for spreadable objects. We do not pre-calculate the length\n                        // in EntryConcat like we do with Arrays because a getProperty on an object Length\n                        // is observable. The result is we have to check for overflows separately for\n                        // spreadable objects and promote to a bigger index type when we find them.\n                        ConcatArgs<BigIndex>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, /*firstPromotedItemIsSpreadable*/true, length);\n                        return;\n                    }\n\n                    if (length + idxDest > FiftyThirdPowerOfTwoMinusOne) // 2^53-1: from ECMA 22.1.3.1 Array.prototype.concat(...arguments)\n                    {\n                        JavascriptError::ThrowTypeError(scriptContext, JSERR_IllegalArraySizeAndLength);\n                    }\n\n                    RecyclableObject* itemObject = RecyclableObject::FromVar(aItem);\n                    Var subItem;\n                    uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;\n                    for (uint32 idxSubItem = 0u; idxSubItem < lengthToUin32Max; ++idxSubItem)\n                    {\n                        if (JavascriptOperators::HasItem(itemObject, idxSubItem))\n                        {\n                            subItem = JavascriptOperators::GetItem(itemObject, idxSubItem, scriptContext);\n\n                            if (pDestArray)\n                            {\n                                pDestArray->DirectSetItemAt(idxDest, subItem);\n                            }\n                            else\n                            {\n                                ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxDest);\n                            }\n                        }\n                        ++idxDest;\n                    }\n\n                    for (BigIndex idxSubItem = MaxArrayLength; idxSubItem < length; ++idxSubItem)\n                    {\n                        PropertyRecord const * propertyRecord;\n                        JavascriptOperators::GetPropertyIdForInt(idxSubItem.GetBigIndex(), scriptContext, &propertyRecord);\n                        if (JavascriptOperators::HasProperty(itemObject,propertyRecord->GetPropertyId()))\n                        {\n                            subItem = JavascriptOperators::GetProperty(itemObject, propertyRecord->GetPropertyId(), scriptContext);\n                            if (pDestArray)\n                            {\n                                pDestArray->DirectSetItemAt(idxDest, subItem);\n                            }\n                            else\n                            {\n                                ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxSubItem);\n                            }\n                        }\n                        ++idxDest;\n                    }\n                }\n                else // concat 1 item\n                {\n                    JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext);\n                    ++idxDest;\n                }\n            }\n        }\n        if (!pDestArray)\n        {\n            pDestObj->SetProperty(PropertyIds::length, ConvertToIndex<T, Var>(idxDest, scriptContext), Js::PropertyOperation_None, nullptr);\n        }\n        else if (pDestArray->GetLength() != ConvertToIndex<T, uint32>(idxDest, scriptContext))\n        {\n            pDestArray->SetLength(ConvertToIndex<T, uint32>(idxDest, scriptContext));\n        }\n    }\n    bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, BigIndex rhs)\n    {\n        return false; // already a big index\n    }\n\n    bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, uint32 rhs)\n    {\n        ::Math::RecordOverflowPolicy destLengthOverflow;\n        if (lhs.IsSmallIndex())\n        {\n            UInt32Math::Add(lhs.GetSmallIndex(), rhs, destLengthOverflow);\n            return destLengthOverflow.HasOverflowed();\n        }\n        return true;\n    }\n\n    JavascriptArray* JavascriptArray::ConcatIntArgs(JavascriptNativeIntArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)\n    {\n        uint idxDest = 0u;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n\n            bool concatSpreadable = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem);\n            if (!JavascriptNativeIntArray::Is(pDestArray))\n            {\n                ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pDestArray;\n            }\n            if(!concatSpreadable)\n            {\n                pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible);\n                idxDest = idxDest + 1;\n                if (!JavascriptNativeIntArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back\n                {\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n                continue;\n            }\n\n            if (JavascriptNativeIntArray::Is(aItem)) // Fast path\n            {\n                JavascriptNativeIntArray* pItemArray = JavascriptNativeIntArray::FromVar(aItem);\n                bool converted = CopyNativeIntArrayElements(pDestArray, idxDest, pItemArray);\n                idxDest = idxDest + pItemArray->length;\n                if (converted)\n                {\n                    // Copying the last array forced a conversion, so switch over to the var version\n                    // to finish.\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n            }\n            else if (!JavascriptArray::IsAnyArray(aItem) && remoteTypeIds[idxArg] != TypeIds_Array)\n            {\n                if (TaggedInt::Is(aItem))\n                {\n                    pDestArray->DirectSetItemAt(idxDest, TaggedInt::ToInt32(aItem));\n                }\n                else\n                {\n#if DBG\n                    int32 int32Value;\n                    Assert(\n                        JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) &&\n                        !SparseArraySegment<int32>::IsMissingItem(&int32Value));\n#endif\n                    pDestArray->DirectSetItemAt(idxDest, static_cast<int32>(JavascriptNumber::GetValue(aItem)));\n                }\n                ++idxDest;\n            }\n            else\n            {\n                JavascriptArray *pVarDestArray = JavascriptNativeIntArray::ConvertToVarArray(pDestArray);\n                ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pVarDestArray;\n            }\n        }\n        if (pDestArray->GetLength() != idxDest)\n        {\n            pDestArray->SetLength(idxDest);\n        }\n        return pDestArray;\n    }\n\n    JavascriptArray* JavascriptArray::ConcatFloatArgs(JavascriptNativeFloatArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)\n    {\n        uint idxDest = 0u;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n\n            bool concatSpreadable = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem);\n            if (!JavascriptNativeFloatArray::Is(pDestArray))\n            {\n                ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                return pDestArray;\n            }\n            if (!concatSpreadable)\n            {\n                pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible);\n\n                idxDest = idxDest + 1;\n                if (!JavascriptNativeFloatArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back\n                {\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n                continue;\n            }\n\n            bool converted;\n            if (JavascriptArray::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array)\n            {\n                if (JavascriptNativeIntArray::Is(aItem)) // Fast path\n                {\n                    JavascriptNativeIntArray *pIntArray = JavascriptNativeIntArray::FromVar(aItem);\n                    converted = CopyNativeIntArrayElementsToFloat(pDestArray, idxDest, pIntArray);\n                    idxDest = idxDest + pIntArray->length;\n                }\n                else if (JavascriptNativeFloatArray::Is(aItem))\n                {\n                    JavascriptNativeFloatArray* pItemArray = JavascriptNativeFloatArray::FromVar(aItem);\n                    converted = CopyNativeFloatArrayElements(pDestArray, idxDest, pItemArray);\n                    idxDest = idxDest + pItemArray->length;\n                }\n                else\n                {\n                    JavascriptArray *pVarDestArray = JavascriptNativeFloatArray::ConvertToVarArray(pDestArray);\n                    ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest);\n                    return pVarDestArray;\n                }\n                if (converted)\n                {\n                    // Copying the last array forced a conversion, so switch over to the var version\n                    // to finish.\n                    ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest);\n                    return pDestArray;\n                }\n            }\n            else\n            {\n                if (TaggedInt::Is(aItem))\n                {\n                    pDestArray->DirectSetItemAt(idxDest, (double)TaggedInt::ToInt32(aItem));\n                }\n                else\n                {\n                    Assert(JavascriptNumber::Is(aItem));\n                    pDestArray->DirectSetItemAt(idxDest, JavascriptNumber::GetValue(aItem));\n                }\n                ++idxDest;\n            }\n        }\n        if (pDestArray->GetLength() != idxDest)\n        {\n            pDestArray->SetLength(idxDest);\n        }\n\n        return pDestArray;\n    }\n\n    bool JavascriptArray::BoxConcatItem(Var aItem, uint idxArg, ScriptContext *scriptContext)\n    {\n        return idxArg == 0 && !JavascriptOperators::IsObject(aItem);\n    }\n\n    Var JavascriptArray::EntryConcat(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));\n        }\n\n        //\n        // Compute the destination ScriptArray size:\n        // - Each item, flattening only one level if a ScriptArray.\n        //\n\n        uint32 cDestLength = 0;\n        JavascriptArray * pDestArray = NULL;\n\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault + (args.Info.Count * sizeof(TypeId*)));\n        TypeId* remoteTypeIds = (TypeId*)_alloca(args.Info.Count * sizeof(TypeId*));\n\n        bool isInt = true;\n        bool isFloat = true;\n        ::Math::RecordOverflowPolicy destLengthOverflow;\n        for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)\n        {\n            Var aItem = args[idxArg];\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(aItem);\n#endif\n            if (DynamicObject::IsAnyArray(aItem)) // Get JavascriptArray or ES5Array length\n            {\n                JavascriptArray * pItemArray = JavascriptArray::FromAnyArray(aItem);\n                if (isFloat)\n                {\n                    if (!JavascriptNativeIntArray::Is(pItemArray))\n                    {\n                        isInt = false;\n                        if (!JavascriptNativeFloatArray::Is(pItemArray))\n                        {\n                            isFloat = false;\n                        }\n                    }\n                }\n                cDestLength = UInt32Math::Add(cDestLength, pItemArray->GetLength(), destLengthOverflow);\n            }\n            else // Get remote array or object length\n            {\n                // We already checked for types derived from JavascriptArray. These are types that should behave like array\n                // i.e. proxy to array and remote array.\n                if (JavascriptOperators::IsArray(aItem))\n                {\n                    // Don't try to preserve nativeness of remote arrays. The extra complexity is probably not\n                    // worth it.\n                    isInt = false;\n                    isFloat = false;\n                    if (!JavascriptProxy::Is(aItem))\n                    {\n                        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n                        {\n                            int64 len = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                            // clipping to MaxArrayLength will overflow when added to cDestLength which we catch below\n                            cDestLength = UInt32Math::Add(cDestLength, len < MaxArrayLength ? (uint32)len : MaxArrayLength, destLengthOverflow);\n                        }\n                        else\n                        {\n                            uint len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext);\n                            cDestLength = UInt32Math::Add(cDestLength, len, destLengthOverflow);\n                        }\n                    }\n                    remoteTypeIds[idxArg] = TypeIds_Array; // Mark remote array, no matter remote JavascriptArray or ES5Array.\n                }\n                else\n                {\n                    if (isFloat)\n                    {\n                        if (BoxConcatItem(aItem, idxArg, scriptContext))\n                        {\n                            // A primitive will be boxed, so we have to create a var array for the result.\n                            isInt = false;\n                            isFloat = false;\n                        }\n                        else if (!TaggedInt::Is(aItem))\n                        {\n                            if (!JavascriptNumber::Is(aItem))\n                            {\n                                isInt = false;\n                                isFloat = false;\n                            }\n                            else if (isInt)\n                            {\n                                int32 int32Value;\n                                if(!JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) ||\n                                    SparseArraySegment<int32>::IsMissingItem(&int32Value))\n                                {\n                                    isInt = false;\n                                }\n                            }\n                        }\n                        else if(isInt)\n                        {\n                            int32 int32Value = TaggedInt::ToInt32(aItem);\n                            if(SparseArraySegment<int32>::IsMissingItem(&int32Value))\n                            {\n                                isInt = false;\n                            }\n                        }\n                    }\n\n                    remoteTypeIds[idxArg] = TypeIds_Limit;\n                    cDestLength = UInt32Math::Add(cDestLength, 1, destLengthOverflow);\n                }\n            }\n        }\n        if (destLengthOverflow.HasOverflowed())\n        {\n            cDestLength = MaxArrayLength;\n            isInt = false;\n            isFloat = false;\n        }\n\n        //\n        // Create the destination array\n        //\n        RecyclableObject* pDestObj = nullptr;\n        bool isArray = false;\n        pDestObj = ArraySpeciesCreate(args[0], 0, scriptContext);\n        if (pDestObj)\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pDestObj);\n#endif\n            // Check the thing that species create made. If it's a native array that can't handle the source\n            // data, convert it. If it's a more conservative kind of array than the source data, indicate that\n            // so that the data will be converted on copy.\n            if (isInt)\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    isArray = true;\n                }\n                else\n                {\n                    isInt = false;\n                    isFloat = JavascriptNativeFloatArray::Is(pDestObj);\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n            else if (isFloat)\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else\n                {\n                    isFloat = JavascriptNativeFloatArray::Is(pDestObj);\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n            else\n            {\n                if (JavascriptNativeIntArray::Is(pDestObj))\n                {\n                    JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else if (JavascriptNativeFloatArray::Is(pDestObj))\n                {\n                    JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray::FromVar(pDestObj));\n                    isArray = true;\n                }\n                else\n                {\n                    isArray = JavascriptArray::Is(pDestObj);\n                }\n            }\n        }\n\n        if (pDestObj == nullptr || isArray)\n        {\n            if (isInt)\n            {\n                JavascriptNativeIntArray *pIntArray = isArray ? JavascriptNativeIntArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeIntArray(cDestLength);\n                pIntArray->EnsureHead<int32>();\n                pDestArray = ConcatIntArgs(pIntArray, remoteTypeIds, args, scriptContext);\n            }\n            else if (isFloat)\n            {\n                JavascriptNativeFloatArray *pFArray = isArray ? JavascriptNativeFloatArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeFloatArray(cDestLength);\n                pFArray->EnsureHead<double>();\n                pDestArray = ConcatFloatArgs(pFArray, remoteTypeIds, args, scriptContext);\n            }\n            else\n            {\n\n                pDestArray = isArray ?  JavascriptArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateArray(cDestLength);\n                // if the constructor has changed then we no longer specialize for ints and floats\n                pDestArray->EnsureHead<Var>();\n                ConcatArgsCallingHelper(pDestArray, remoteTypeIds, args, scriptContext, destLengthOverflow);\n            }\n\n            //\n            // Return the new array instance.\n            //\n\n#ifdef VALIDATE_ARRAY\n            pDestArray->ValidateArray();\n#endif\n\n            return pDestArray;\n        }\n        Assert(pDestObj);\n        ConcatArgsCallingHelper(pDestObj, remoteTypeIds, args, scriptContext, destLengthOverflow);\n\n        return pDestObj;\n    }\n\n    void JavascriptArray::ConcatArgsCallingHelper(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, ::Math::RecordOverflowPolicy &destLengthOverflow)\n    {\n        if (destLengthOverflow.HasOverflowed())\n        {\n            ConcatArgs<BigIndex>(pDestObj, remoteTypeIds, args, scriptContext);\n        }\n        else\n        {\n            // Use faster uint32 version if no overflow\n            ConcatArgs<uint32>(pDestObj, remoteTypeIds, args, scriptContext);\n        }\n    }\n\n    template<typename T>\n    /* static */ void JavascriptArray::SetConcatItem(Var aItem, uint idxArg, JavascriptArray* pDestArray, RecyclableObject* pDestObj, T idxDest, ScriptContext *scriptContext)\n    {\n        if (BoxConcatItem(aItem, idxArg, scriptContext))\n        {\n            // bug# 725784: ES5: not calling ToObject in Step 1 of 15.4.4.4\n            RecyclableObject* pObj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(aItem, scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));\n            }\n            if (pDestArray)\n            {\n                pDestArray->DirectSetItemAt(idxDest, pObj);\n            }\n            else\n            {\n                SetArrayLikeObjects(pDestObj, idxDest, pObj);\n            }\n        }\n        else\n        {\n            if (pDestArray)\n            {\n                pDestArray->DirectSetItemAt(idxDest, aItem);\n            }\n            else\n            {\n                SetArrayLikeObjects(pDestObj, idxDest, aItem);\n            }\n        }\n    }\n\n    uint32 JavascriptArray::GetFromIndex(Var arg, uint32 length, ScriptContext *scriptContext)\n    {\n        uint32 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = intValue;\n            }\n            else\n            {\n                // (intValue + length) may exceed 2^31 or may be < 0, so promote to int64\n                fromIndex = (uint32)max(0i64, (int64)(length) + intValue);\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n            if (value > length)\n            {\n                return (uint32)-1;\n            }\n            else if (value >= 0)\n            {\n                fromIndex = (uint32)value;\n            }\n            else\n            {\n                fromIndex = (uint32)max((double)0, value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    uint64 JavascriptArray::GetFromIndex(Var arg, uint64 length, ScriptContext *scriptContext)\n    {\n        uint64 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int64 intValue = TaggedInt::ToInt64(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = intValue;\n            }\n            else\n            {\n                fromIndex = max((int64)0, (int64)(intValue + length));\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n            if (value > length)\n            {\n                return (uint64)-1;\n            }\n            else if (value >= 0)\n            {\n                fromIndex = (uint64)value;\n            }\n            else\n            {\n                fromIndex = (uint64)max((double)0, value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    int64 JavascriptArray::GetFromLastIndex(Var arg, int64 length, ScriptContext *scriptContext)\n    {\n        int64 fromIndex;\n\n        if (TaggedInt::Is(arg))\n        {\n            int intValue = TaggedInt::ToInt32(arg);\n\n            if (intValue >= 0)\n            {\n                fromIndex = min<int64>(intValue, length - 1);\n            }\n            else if ((uint32)-intValue > length)\n            {\n                return length;\n            }\n            else\n            {\n                fromIndex = intValue + length;\n            }\n        }\n        else\n        {\n            double value = JavascriptConversion::ToInteger(arg, scriptContext);\n\n            if (value >= 0)\n            {\n                fromIndex = (int64)min(value, (double)(length - 1));\n            }\n            else if (value + length < 0)\n            {\n                return length;\n            }\n            else\n            {\n                fromIndex = (int64)(value + length);\n            }\n        }\n\n        return fromIndex;\n    }\n\n    // includesAlgorithm specifies to follow ES7 Array.prototype.includes semantics instead of Array.prototype.indexOf\n    // Differences\n    //    1. Returns boolean true or false value instead of the search hit index\n    //    2. Follows SameValueZero algorithm instead of StrictEquals\n    //    3. Missing values are scanned if the search value is undefined\n\n    template <bool includesAlgorithm>\n    Var JavascriptArray::IndexOfHelper(Arguments const & args, ScriptContext *scriptContext)\n    {\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        BigIndex length;\n        Var trueValue = scriptContext->GetLibrary()->GetTrue();\n        Var falseValue = scriptContext->GetLibrary()->GetFalse();\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.indexOf\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (pArr)\n        {\n            Var search;\n            uint32 fromIndex;\n            uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();\n            if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            int32 index = pArr->HeadSegmentIndexOfHelper(search, fromIndex, len, includesAlgorithm, scriptContext);\n\n            // If we found the search value in the head segment, or if we determined there is no need to search other segments,\n            // we stop right here.\n            if (index != -1 || fromIndex == -1)\n            {\n                if (includesAlgorithm)\n                {\n                    //Array.prototype.includes\n                    return (index == -1)? falseValue : trueValue;\n                }\n                else\n                {\n                    //Array.prototype.indexOf\n                    return JavascriptNumber::ToVar(index, scriptContext);\n                }\n            }\n\n            //  If we really must search other segments, let's do it now. We'll have to search the slow way (dealing with holes, etc.).\n\n            switch (pArr->GetTypeId())\n            {\n            case Js::TypeIds_Array:\n                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);\n            case Js::TypeIds_NativeIntArray:\n                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, len, scriptContext);\n            case Js::TypeIds_NativeFloatArray:\n                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, len, scriptContext);\n            default:\n                AssertMsg(FALSE, \"invalid array typeid\");\n                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);\n            }\n        }\n\n        // source object is not a JavascriptArray but source could be a TypedArray\n        if (TypedArrayBase::Is(obj))\n        {\n            if (length.IsSmallIndex() || length.IsUint32Max())\n            {\n                Var search;\n                uint32 fromIndex;\n                uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();\n                if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))\n                {\n                    return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n                }\n                return TemplatedIndexOfHelper<includesAlgorithm>(TypedArrayBase::FromVar(obj), search, fromIndex, length.GetSmallIndex(), scriptContext);\n            }\n        }\n        if (length.IsSmallIndex())\n        {\n            Var search;\n            uint32 fromIndex;\n            if (!GetParamForIndexOf(length.GetSmallIndex(), args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetSmallIndex(), scriptContext);\n        }\n        else\n        {\n            Var search;\n            uint64 fromIndex;\n            if (!GetParamForIndexOf(length.GetBigIndex(), args, search, fromIndex, scriptContext))\n            {\n                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);\n            }\n            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetBigIndex(), scriptContext);\n        }\n    }\n\n    // Array.prototype.indexOf as defined in ES6.0 (final) Section 22.1.3.11\n    Var JavascriptArray::EntryIndexOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_indexOf);\n\n        Var returnValue =  IndexOfHelper<false>(args, scriptContext);\n\n        //IndexOfHelper code is reused for array.prototype.includes as well. Let us assert here we didn't get a true or false instead of index\n        Assert(returnValue != scriptContext->GetLibrary()->GetTrue() && returnValue != scriptContext->GetLibrary()->GetFalse());\n\n        return returnValue;\n    }\n\n    Var JavascriptArray::EntryIncludes(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_includes);\n\n        Var returnValue = IndexOfHelper<true>(args, scriptContext);\n        Assert(returnValue == scriptContext->GetLibrary()->GetTrue() || returnValue == scriptContext->GetLibrary()->GetFalse());\n\n        return returnValue;\n    }\n\n\n    template<typename T>\n    BOOL JavascriptArray::GetParamForIndexOf(T length, Arguments const& args, Var& search, T& fromIndex, ScriptContext * scriptContext)\n    {\n        if (length == 0)\n        {\n            return false;\n        }\n\n        if (args.Info.Count > 2)\n        {\n            fromIndex = GetFromIndex(args[2], length, scriptContext);\n            if (fromIndex >= length)\n            {\n                return false;\n            }\n            search = args[1];\n        }\n        else\n        {\n            fromIndex = 0;\n            search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();\n        }\n        return true;\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // Note: Sometime cross site array go down this path to get the marshalling\n        Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));\n        if (checkHasItem && !JavascriptOperators::HasItem(obj, index))\n        {\n            return FALSE;\n        }\n        return JavascriptOperators::GetItem(obj, index, element, scriptContext);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // Note: Sometime cross site array go down this path to get the marshalling\n        Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)\n            && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));\n        PropertyRecord const * propertyRecord;\n        JavascriptOperators::GetPropertyIdForInt(index, scriptContext, &propertyRecord);\n        if (checkHasItem && !JavascriptOperators::HasProperty(obj, propertyRecord->GetPropertyId()))\n        {\n            return FALSE;\n        }\n        *element = JavascriptOperators::GetProperty(obj, propertyRecord->GetPropertyId(), scriptContext);\n        return *element != scriptContext->GetLibrary()->GetUndefined();\n\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptArray::DirectGetItemAtFull(index, element);\n    }\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptNativeIntArray::DirectGetItemAtFull(index, element);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pArr)\n            || VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(pArr));\n        return pArr->JavascriptNativeFloatArray::DirectGetItemAtFull(index, element);\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // We need to do explicit check for items since length value may not actually match the actual TypedArray length.\n        // User could add a length property to a TypedArray instance which lies and returns a different value from the underlying length.\n        // Since this method can be called via Array.prototype.indexOf with .apply or .call passing a TypedArray as this parameter\n        // we don't know whether or not length == typedArrayBase->GetLength().\n        if (checkHasItem && !typedArrayBase->HasItem(index))\n        {\n            return false;\n        }\n\n        *element = typedArrayBase->DirectGetItem(index);\n        return true;\n    }\n\n    template <>\n    BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)\n    {\n        // This should never get called.\n        Assert(false);\n        Throw::InternalError();\n    }\n\n    template <bool includesAlgorithm, typename T, typename P>\n    Var JavascriptArray::TemplatedIndexOfHelper(T * pArr, Var search, P fromIndex, P toIndex, ScriptContext * scriptContext)\n    {\n        Var element = nullptr;\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        bool doUndefinedSearch = includesAlgorithm && JavascriptOperators::GetTypeId(search) == TypeIds_Undefined;\n\n        Var trueValue = scriptContext->GetLibrary()->GetTrue();\n        Var falseValue = scriptContext->GetLibrary()->GetFalse();\n\n        //Consider: enumerating instead of walking all indices\n        for (P i = fromIndex; i < toIndex; i++)\n        {\n            if (!TryTemplatedGetItem(pArr, i, &element, scriptContext, !includesAlgorithm))\n            {\n                if (doUndefinedSearch)\n                {\n                    return trueValue;\n                }\n                continue;\n            }\n\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (element == search)\n                {\n                    return includesAlgorithm? trueValue : JavascriptNumber::ToVar(i, scriptContext);\n                }\n                continue;\n            }\n\n            if (includesAlgorithm)\n            {\n                //Array.prototype.includes\n                if (JavascriptConversion::SameValueZero(element, search))\n                {\n                    return trueValue;\n                }\n            }\n            else\n            {\n                //Array.prototype.indexOf\n                if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n                {\n                    return JavascriptNumber::ToVar(i, scriptContext);\n                }\n            }\n        }\n\n        return includesAlgorithm ? falseValue :  TaggedInt::ToVarUnchecked(-1);\n    }\n\n    int32 JavascriptArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)\n    {\n        Assert(Is(GetTypeId()) && !JavascriptNativeArray::Is(GetTypeId()));\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        // We need to cast head segment to SparseArraySegment<Var> to have access to GetElement (onSparseArraySegment<T>). Because there are separate overloads of this\n        // virtual method on JavascriptNativeIntArray and JavascriptNativeFloatArray, we know this version of this method will only be called for true JavascriptArray, and not for\n        // either of the derived native arrays, so the elements of each segment used here must be Vars. Hence, the cast is safe.\n        SparseArraySegment<Var>* head = static_cast<SparseArraySegment<Var>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            Var element = head->GetElement(i);\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (search == element)\n                {\n                    return i;\n                }\n            }\n            else if (includesAlgorithm && JavascriptConversion::SameValueZero(element, search))\n            {\n                //Array.prototype.includes\n                return i;\n            }\n            else if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n            {\n                //Array.prototype.indexOf\n                return i;\n            }\n        }\n\n        // Element not found in the head segment. Keep looking only if the range of indices extends past\n        // the head segment.\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    template<typename T>\n    bool AreAllBytesEqual(T value)\n    {\n        byte* bValue = (byte*)&value;\n        byte firstByte = *bValue++;\n        for (int i = 1; i < sizeof(T); ++i)\n        {\n            if (*bValue++ != firstByte)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(double* buffer, uint32 length, double value)\n    {\n        if (JavascriptNumber::IsZero(value) && !JavascriptNumber::IsNegZero(value))\n        {\n            memset(buffer, 0, sizeof(double) * length);\n        }\n        else\n        {\n            for (uint32 i = 0; i < length; i++)\n            {\n                buffer[i] = value;\n            }\n        }\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(int32* buffer, uint32 length, int32 value)\n    {\n        if (value == 0 || AreAllBytesEqual(value))\n        {\n            memset(buffer, *(byte*)&value, sizeof(int32)* length);\n        }\n        else\n        {\n            for (uint32 i = 0; i < length; i++)\n            {\n                buffer[i] = value;\n            }\n        }\n    }\n\n    template<>\n    void JavascriptArray::CopyValueToSegmentBuferNoCheck(Js::Var* buffer, uint32 length, Js::Var value)\n    {\n        for (uint32 i = 0; i < length; i++)\n        {\n            buffer[i] = value;\n        }\n    }\n\n    int32 JavascriptNativeIntArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm,  ScriptContext * scriptContext)\n    {\n        // We proceed largely in the same manner as in JavascriptArray's version of this method (see comments there for more information),\n        // except when we can further optimize thanks to the knowledge that all elements in the array are int32's. This allows for two additional optimizations:\n        // 1. Only tagged ints or JavascriptNumbers that can be represented as int32 can be strict equal to some element in the array (all int32). Thus, if\n        // the search value is some other kind of Var, we can return -1 without ever iterating over the elements.\n        // 2. If the search value is a number that can be represented as int32, then we inspect the elements, but we don't need to perform the full strict equality algorithm.\n        // Instead we can use simple C++ equality (which in case of such values is equivalent to strict equality in JavaScript).\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n        int32 searchAsInt32;\n        if (isSearchTaggedInt)\n        {\n            searchAsInt32 = TaggedInt::ToInt32(search);\n        }\n        else if (!JavascriptNumber::TryGetInt32Value<true>(JavascriptNumber::GetValue(search), &searchAsInt32))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n\n        // We need to cast head segment to SparseArraySegment<int32> to have access to GetElement (onSparseArraySegment<T>). Because there are separate overloads of this\n        // virtual method on JavascriptNativeIntArray and JavascriptNativeFloatArray, we know this version of this method will only be called for true JavascriptNativeIntArray, and not for\n        // the other two, so the elements of each segment used here must be int32's. Hence, the cast is safe.\n\n        SparseArraySegment<int32> * head = static_cast<SparseArraySegment<int32>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            int32 element = head->GetElement(i);\n            if (searchAsInt32 == element)\n            {\n                return i;\n            }\n        }\n\n        // Element not found in the head segment. Keep looking only if the range of indices extends past\n        // the head segment.\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    int32 JavascriptNativeFloatArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)\n    {\n        // We proceed largely in the same manner as in JavascriptArray's version of this method (see comments there for more information),\n        // except when we can further optimize thanks to the knowledge that all elements in the array are doubles. This allows for two additional optimizations:\n        // 1. Only tagged ints or JavascriptNumbers can be strict equal to some element in the array (all doubles). Thus, if\n        // the search value is some other kind of Var, we can return -1 without ever iterating over the elements.\n        // 2. If the search value is a number, then we inspect the elements, but we don't need to perform the full strict equality algorithm.\n        // Instead we can use simple C++ equality (which in case of such values is equivalent to strict equality in JavaScript).\n\n        if (!HasNoMissingValues() || fromIndex >= GetHead()->length)\n        {\n            return -1;\n        }\n\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n        if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))\n        {\n            // The value can't be in the array, but it could be in a prototype, and we can only guarantee that\n            // the head segment has no gaps.\n            fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n            return -1;\n        }\n\n        double searchAsDouble = isSearchTaggedInt ? TaggedInt::ToDouble(search) : JavascriptNumber::GetValue(search);\n\n        // We need to cast head segment to SparseArraySegment<double> to have access to GetElement (SparseArraySegment). We know the\n        // segment's elements are all Vars so the cast is safe. It would have been more convenient here if JavascriptArray\n        // used SparseArraySegment<Var>, instead of SparseArraySegmentBase.\n\n\n        SparseArraySegment<double> * head = static_cast<SparseArraySegment<double>*>(GetHead());\n        uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;\n\n        bool matchNaN = includesAlgorithm && JavascriptNumber::IsNan(searchAsDouble);\n\n        for (uint32 i = fromIndex; i < toIndexTrimmed; i++)\n        {\n            double element = head->GetElement(i);\n\n            if (element == searchAsDouble)\n            {\n                return i;\n            }\n\n            //NaN != NaN we expect to match for NaN in Array.prototype.includes algorithm\n            if (matchNaN && JavascriptNumber::IsNan(element))\n            {\n                return i;\n            }\n\n        }\n\n        fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;\n        return -1;\n    }\n\n    Var JavascriptArray::EntryJoin(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.join\"));\n        }\n\n        JavascriptString* separator;\n        if (args.Info.Count >= 2)\n        {\n            TypeId typeId = JavascriptOperators::GetTypeId(args[1]);\n            //ES5 15.4.4.5 If separator is undefined, let separator be the single-character String \",\".\n            if (TypeIds_Undefined != typeId)\n            {\n                separator = JavascriptConversion::ToString(args[1], scriptContext);\n            }\n            else\n            {\n                separator = scriptContext->GetLibrary()->GetCommaDisplayString();\n            }\n        }\n        else\n        {\n            separator = scriptContext->GetLibrary()->GetCommaDisplayString();\n        }\n\n        return JoinHelper(args[0], separator, scriptContext);\n    }\n\n    JavascriptString* JavascriptArray::JoinToString(Var value, ScriptContext* scriptContext)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(value);\n        if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n        else\n        {\n            return JavascriptConversion::ToString(value, scriptContext);\n        }\n    }\n\n    JavascriptString* JavascriptArray::JoinHelper(Var thisArg, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        bool isArray = JavascriptArray::Is(thisArg) && (scriptContext == JavascriptArray::FromVar(thisArg)->GetScriptContext());\n        bool isProxy = JavascriptProxy::Is(thisArg) && (scriptContext == JavascriptProxy::FromVar(thisArg)->GetScriptContext());\n        Var target = NULL;\n        bool isTargetObjectPushed = false;\n        // if we are visiting a proxy object, track that we have visited the target object as well so the next time w\n        // call the join helper for the target of this proxy, we will return above.\n        if (isProxy)\n        {\n            JavascriptProxy* proxy = JavascriptProxy::FromVar(thisArg);\n            Assert(proxy);\n            target = proxy->GetTarget();\n            if (target != nullptr)\n            {\n                // If we end up joining same array, instead of going in infinite loop, return the empty string\n                if (scriptContext->CheckObject(target))\n                {\n                    return scriptContext->GetLibrary()->GetEmptyString();\n                }\n                else\n                {\n                    scriptContext->PushObject(target);\n                    isTargetObjectPushed = true;\n                }\n            }\n        }\n        // If we end up joining same array, instead of going in infinite loop, return the empty string\n        else if (scriptContext->CheckObject(thisArg))\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        if (!isTargetObjectPushed)\n        {\n            scriptContext->PushObject(thisArg);\n        }\n\n        JavascriptString* res = nullptr;\n\n        TryFinally([&]()\n        {\n            if (isArray)\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray(thisArg);\n#endif\n                JavascriptArray * arr = JavascriptArray::FromVar(thisArg);\n                switch (arr->GetTypeId())\n                {\n                case Js::TypeIds_Array:\n                    res = JoinArrayHelper(arr, separator, scriptContext);\n                    break;\n                case Js::TypeIds_NativeIntArray:\n                    res = JoinArrayHelper(JavascriptNativeIntArray::FromVar(arr), separator, scriptContext);\n                    break;\n                case Js::TypeIds_NativeFloatArray:\n                    res = JoinArrayHelper(JavascriptNativeFloatArray::FromVar(arr), separator, scriptContext);\n                    break;\n                }\n\n            }\n            else if (RecyclableObject::Is(thisArg))\n            {\n                res = JoinOtherHelper(RecyclableObject::FromVar(thisArg), separator, scriptContext);\n            }\n            else\n            {\n                res = JoinOtherHelper(scriptContext->GetLibrary()->CreateNumberObject(thisArg), separator, scriptContext);\n            }\n        },\n        [&](bool/*hasException*/)\n        {\n            Var top = scriptContext->PopObject();\n            if (isProxy)\n            {\n                AssertMsg(top == target, \"Unmatched operation stack\");\n            }\n            else\n            {\n                AssertMsg(top == thisArg, \"Unmatched operation stack\");\n            }\n        });\n\n        if (res == nullptr)\n        {\n            res = scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        return res;\n    }\n\n    static const charcount_t Join_MaxEstimatedAppendCount = static_cast<charcount_t>((64 << 20) / sizeof(void *)); // 64 MB worth of pointers\n\n    template <typename T>\n    JavascriptString* JavascriptArray::JoinArrayHelper(T * arr, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        Assert(VirtualTableInfo<T>::HasVirtualTable(arr) || VirtualTableInfo<CrossSiteObject<T>>::HasVirtualTable(arr));\n        const uint32 arrLength = arr->length;\n        switch(arrLength)\n        {\n            default:\n            {\nCaseDefault:\n                bool hasSeparator = (separator->GetLength() != 0);\n                const charcount_t estimatedAppendCount =\n                    min(\n                        Join_MaxEstimatedAppendCount,\n                        static_cast<charcount_t>(arrLength + (hasSeparator ? arrLength - 1 : 0)));\n                CompoundString *const cs =\n                    CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());\n                Var item;\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    cs->Append(JavascriptArray::JoinToString(item, scriptContext));\n                }\n                for (uint32 i = 1; i < arrLength; i++)\n                {\n                    if (hasSeparator)\n                    {\n                        cs->Append(separator);\n                    }\n\n                    if (TryTemplatedGetItem(arr, i, &item, scriptContext))\n                    {\n                        cs->Append(JavascriptArray::JoinToString(item, scriptContext));\n                    }\n                }\n                return cs;\n            }\n\n            case 2:\n            {\n                bool hasSeparator = (separator->GetLength() != 0);\n                if(hasSeparator)\n                {\n                    goto CaseDefault;\n                }\n\n                JavascriptString *res = nullptr;\n                Var item;\n\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    res = JavascriptArray::JoinToString(item, scriptContext);\n                }\n\n                if (TryTemplatedGetItem(arr, 1u, &item, scriptContext))\n                {\n                    JavascriptString *const itemString = JavascriptArray::JoinToString(item, scriptContext);\n                    return res ? ConcatString::New(res, itemString) : itemString;\n                }\n\n                if(res)\n                {\n                    return res;\n                }\n\n                goto Case0;\n            }\n\n            case 1:\n            {\n                Var item;\n                if (TemplatedGetItem(arr, 0u, &item, scriptContext))\n                {\n                    return JavascriptArray::JoinToString(item, scriptContext);\n                }\n                // fall through\n            }\n\n            case 0:\nCase0:\n                return scriptContext->GetLibrary()->GetEmptyString();\n        }\n    }\n\n    JavascriptString* JavascriptArray::JoinOtherHelper(RecyclableObject* object, JavascriptString* separator, ScriptContext* scriptContext)\n    {\n        // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n        // Even for arrays, this is now observable via proxies.\n        // If source object is not an array, we fall back to this behavior anyway.\n        Var lenValue = JavascriptOperators::OP_GetLength(object, scriptContext);\n        int64 cSrcLength = JavascriptConversion::ToLength(lenValue, scriptContext);\n\n        switch (cSrcLength)\n        {\n            default:\n            {\nCaseDefault:\n                bool hasSeparator = (separator->GetLength() != 0);\n                const charcount_t estimatedAppendCount =\n                    min(\n                        Join_MaxEstimatedAppendCount,\n                        static_cast<charcount_t>(cSrcLength + (hasSeparator ? cSrcLength - 1 : 0)));\n                CompoundString *const cs =\n                    CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    cs->Append(JavascriptArray::JoinToString(value, scriptContext));\n                }\n                for (uint32 i = 1; i < cSrcLength; i++)\n                {\n                    if (hasSeparator)\n                    {\n                        cs->Append(separator);\n                    }\n                    if (JavascriptOperators::GetItem(object, i, &value, scriptContext))\n                    {\n                        cs->Append(JavascriptArray::JoinToString(value, scriptContext));\n                    }\n                }\n                return cs;\n            }\n\n            case 2:\n            {\n                bool hasSeparator = (separator->GetLength() != 0);\n                if(hasSeparator)\n                {\n                    goto CaseDefault;\n                }\n\n                JavascriptString *res = nullptr;\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    res = JavascriptArray::JoinToString(value, scriptContext);\n                }\n                if (JavascriptOperators::GetItem(object, 1u, &value, scriptContext))\n                {\n                    JavascriptString *const valueString = JavascriptArray::JoinToString(value, scriptContext);\n                    return res ? ConcatString::New(res, valueString) : valueString;\n                }\n                if(res)\n                {\n                    return res;\n                }\n                goto Case0;\n            }\n\n            case 1:\n            {\n                Var value;\n                if (JavascriptOperators::GetItem(object, 0u, &value, scriptContext))\n                {\n                    return JavascriptArray::JoinToString(value, scriptContext);\n                }\n                // fall through\n            }\n\n            case 0:\nCase0:\n                return scriptContext->GetLibrary()->GetEmptyString();\n        }\n    }\n\n    Var JavascriptArray::EntryLastIndexOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_lastIndexOf);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.lastIndexOf\"));\n            }\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        Var search;\n        int64 fromIndex;\n        if (!GetParamForLastIndexOf(length, args, search, fromIndex, scriptContext))\n        {\n            return TaggedInt::ToVarUnchecked(-1);\n        }\n\n        if (pArr)\n        {\n            switch (pArr->GetTypeId())\n            {\n            case Js::TypeIds_Array:\n                return LastIndexOfHelper(pArr, search, fromIndex, scriptContext);\n            case Js::TypeIds_NativeIntArray:\n                return LastIndexOfHelper(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, scriptContext);\n            case Js::TypeIds_NativeFloatArray:\n                return LastIndexOfHelper(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, scriptContext);\n            default:\n                AssertMsg(FALSE, \"invalid array typeid\");\n                return LastIndexOfHelper(pArr, search, fromIndex, scriptContext);\n            }\n        }\n\n        // source object is not a JavascriptArray but source could be a TypedArray\n        if (TypedArrayBase::Is(obj))\n        {\n            return LastIndexOfHelper(TypedArrayBase::FromVar(obj), search, fromIndex, scriptContext);\n        }\n\n        return LastIndexOfHelper(obj, search, fromIndex, scriptContext);\n    }\n\n    // Array.prototype.lastIndexOf as described in ES6.0 (draft 22) Section 22.1.3.14\n    BOOL JavascriptArray::GetParamForLastIndexOf(int64 length, Arguments const & args, Var& search, int64& fromIndex, ScriptContext * scriptContext)\n    {\n        if (length == 0)\n        {\n            return false;\n        }\n\n        if (args.Info.Count > 2)\n        {\n            fromIndex = GetFromLastIndex(args[2], length, scriptContext);\n\n            if (fromIndex >= length)\n            {\n                return false;\n            }\n            search = args[1];\n        }\n        else\n        {\n            search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();\n            fromIndex = length - 1;\n        }\n        return true;\n    }\n\n    template <typename T>\n    Var JavascriptArray::LastIndexOfHelper(T* pArr, Var search, int64 fromIndex, ScriptContext * scriptContext)\n    {\n        Var element = nullptr;\n        bool isSearchTaggedInt = TaggedInt::Is(search);\n\n        // First handle the indices > 2^32\n        while (fromIndex >= MaxArrayLength)\n        {\n            Var index = JavascriptNumber::ToVar(fromIndex, scriptContext);\n\n            if (JavascriptOperators::OP_HasItem(pArr, index, scriptContext))\n            {\n                element = JavascriptOperators::OP_GetElementI(pArr, index, scriptContext);\n\n                if (isSearchTaggedInt && TaggedInt::Is(element))\n                {\n                    if (element == search)\n                    {\n                        return index;\n                    }\n                    fromIndex--;\n                    continue;\n                }\n\n                if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n                {\n                    return index;\n                }\n            }\n\n            fromIndex--;\n        }\n\n        Assert(fromIndex < MaxArrayLength);\n\n        // fromIndex now has to be < MaxArrayLength so casting to uint32 is safe\n        uint32 end = static_cast<uint32>(fromIndex);\n\n        for (uint32 i = 0; i <= end; i++)\n        {\n            uint32 index = end - i;\n\n            if (!TryTemplatedGetItem(pArr, index, &element, scriptContext))\n            {\n                continue;\n            }\n\n            if (isSearchTaggedInt && TaggedInt::Is(element))\n            {\n                if (element == search)\n                {\n                    return JavascriptNumber::ToVar(index, scriptContext);\n                }\n                continue;\n            }\n\n            if (JavascriptOperators::StrictEqual(element, search, scriptContext))\n            {\n                return JavascriptNumber::ToVar(index, scriptContext);\n            }\n        }\n\n        return TaggedInt::ToVarUnchecked(-1);\n    }\n\n    /*\n    *   PopWithNoDst\n    *   - For pop calls that do not return a value, we only need to decrement the length of the array.\n    */\n    void JavascriptNativeArray::PopWithNoDst(Var nativeArray)\n    {\n        Assert(JavascriptNativeArray::Is(nativeArray));\n        JavascriptArray * arr = JavascriptArray::FromVar(nativeArray);\n\n        // we will bailout on length 0\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->GetLength() - 1;\n        arr->SetLength(index);\n    }\n\n    /*\n    *   JavascriptNativeIntArray::Pop\n    *   -   Returns int32 value from the array.\n    *   -   Returns missing item when the element is not available in the array object.\n    *   -   It doesn't walk up the prototype chain.\n    *   -   Length is decremented only if it pops an int32 element, in all other cases - we bail out from the jitted code.\n    *   -   This api cannot cause any implicit call and hence do not need implicit call bailout test around this api\n    */\n    int32 JavascriptNativeIntArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        Assert(JavascriptNativeIntArray::Is(object));\n        JavascriptNativeIntArray * arr = JavascriptNativeIntArray::FromVar(object);\n\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->length - 1;\n\n        int32 element = Js::JavascriptOperators::OP_GetNativeIntElementI_UInt32(object, index, scriptContext);\n\n        //If it is a missing item, then don't update the length - Pre-op Bail out will happen.\n        if(!SparseArraySegment<int32>::IsMissingItem(&element))\n        {\n            arr->SetLength(index);\n        }\n        return element;\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::Pop\n    *   -   Returns double value from the array.\n    *   -   Returns missing item when the element is not available in the array object.\n    *   -   It doesn't walk up the prototype chain.\n    *   -   Length is decremented only if it pops a double element, in all other cases - we bail out from the jitted code.\n    *   -   This api cannot cause any implicit call and hence do not need implicit call bailout test around this api\n    */\n    double JavascriptNativeFloatArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        Assert(JavascriptNativeFloatArray::Is(object));\n        JavascriptNativeFloatArray * arr = JavascriptNativeFloatArray::FromVar(object);\n\n        Assert(arr->GetLength() != 0);\n\n        uint32 index = arr->length - 1;\n\n        double element = Js::JavascriptOperators::OP_GetNativeFloatElementI_UInt32(object, index, scriptContext);\n\n        // If it is a missing item then don't update the length - Pre-op Bail out will happen.\n        if(!SparseArraySegment<double>::IsMissingItem(&element))\n        {\n            arr->SetLength(index);\n        }\n        return element;\n    }\n\n    /*\n    *   JavascriptArray::Pop\n    *   -   Calls the generic Pop API, which can find elements from the prototype chain, when it is not available in the array object.\n    *   -   This API may cause implicit calls. Handles Array and non-array objects\n    */\n    Var JavascriptArray::Pop(ScriptContext * scriptContext, Var object)\n    {\n        if (JavascriptArray::Is(object))\n        {\n            return EntryPopJavascriptArray(scriptContext, object);\n        }\n        else\n        {\n            return EntryPopNonJavascriptArray(scriptContext, object);\n        }\n    }\n\n    Var JavascriptArray::EntryPopJavascriptArray(ScriptContext * scriptContext, Var object)\n    {\n        JavascriptArray * arr = JavascriptArray::FromVar(object);\n        uint32 length = arr->length;\n\n        if (length == 0)\n        {\n            // If length is 0, return 'undefined'\n            return scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        uint32 index = length - 1;\n        Var element;\n\n        if (!arr->DirectGetItemAtFull(index, &element))\n        {\n            element = scriptContext->GetLibrary()->GetUndefined();\n        }\n        else\n        {\n            element = CrossSite::MarshalVar(scriptContext, element);\n        }\n        arr->SetLength(index); // SetLength will clear element at index\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n        return element;\n    }\n\n    Var JavascriptArray::EntryPopNonJavascriptArray(ScriptContext * scriptContext, Var object)\n    {\n        RecyclableObject* dynamicObject = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(object, scriptContext, &dynamicObject))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));\n        }\n        BigIndex length;\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.pop\"));\n        if (length == 0u)\n        {\n            // Set length = 0\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            return scriptContext->GetLibrary()->GetUndefined();\n        }\n        BigIndex index = length;\n        --index;\n        Var element;\n        if (index.IsSmallIndex())\n        {\n            if (!JavascriptOperators::GetItem(dynamicObject, index.GetSmallIndex(), &element, scriptContext))\n            {\n                element = scriptContext->GetLibrary()->GetUndefined();\n            }\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n\n            // Set the new length\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        else\n        {\n            if (!JavascriptOperators::GetItem(dynamicObject, index.GetBigIndex(), &element, scriptContext))\n            {\n                element = scriptContext->GetLibrary()->GetUndefined();\n            }\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n\n            // Set the new length\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        return element;\n    }\n\n    Var JavascriptArray::EntryPop(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            return EntryPopJavascriptArray(scriptContext, args.Values[0]);\n        }\n        else\n        {\n            return EntryPopNonJavascriptArray(scriptContext, args.Values[0]);\n        }\n    }\n\n    /*\n    *   JavascriptNativeIntArray::Push\n    *   Pushes Int element in a native Int Array.\n    *   We call the generic Push, if the array is not native Int or we have a really big array.\n    */\n    Var JavascriptNativeIntArray::Push(ScriptContext * scriptContext, Var array, int value)\n    {\n        // Handle non crossSite native int arrays here length within MaxArrayLength.\n        // JavascriptArray::Push will handle other cases.\n        if (JavascriptNativeIntArray::IsNonCrossSite(array))\n        {\n            JavascriptNativeIntArray * nativeIntArray = JavascriptNativeIntArray::FromVar(array);\n            Assert(!nativeIntArray->IsCrossSiteObject());\n            uint32 n = nativeIntArray->length;\n\n            if(n < JavascriptArray::MaxArrayLength)\n            {\n                nativeIntArray->SetItem(n, value);\n\n                n++;\n\n                AssertMsg(n == nativeIntArray->length, \"Wrong update to the length of the native Int array\");\n\n                return JavascriptNumber::ToVar(n, scriptContext);\n            }\n        }\n        return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVar(value, scriptContext));\n    }\n\n    /*\n    *   JavascriptNativeFloatArray::Push\n    *   Pushes Float element in a native Int Array.\n    *   We call the generic Push, if the array is not native Float or we have a really big array.\n    */\n    Var JavascriptNativeFloatArray::Push(ScriptContext * scriptContext, Var * array, double value)\n    {\n        // Handle non crossSite native int arrays here length within MaxArrayLength.\n        // JavascriptArray::Push will handle other cases.\n        if(JavascriptNativeFloatArray::IsNonCrossSite(array))\n        {\n            JavascriptNativeFloatArray * nativeFloatArray = JavascriptNativeFloatArray::FromVar(array);\n            Assert(!nativeFloatArray->IsCrossSiteObject());\n            uint32 n = nativeFloatArray->length;\n\n            if(n < JavascriptArray::MaxArrayLength)\n            {\n                nativeFloatArray->SetItem(n, value);\n\n                n++;\n\n                AssertMsg(n == nativeFloatArray->length, \"Wrong update to the length of the native Float array\");\n                return JavascriptNumber::ToVar(n, scriptContext);\n            }\n        }\n\n        return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVarNoCheck(value, scriptContext));\n    }\n\n    /*\n    *   JavascriptArray::Push\n    *   Pushes Var element in a Var Array.\n    */\n    Var JavascriptArray::Push(ScriptContext * scriptContext, Var object, Var value)\n    {\n        Var args[2];\n        args[0] = object;\n        args[1] = value;\n\n        if (JavascriptArray::Is(object))\n        {\n            return EntryPushJavascriptArray(scriptContext, args, 2);\n        }\n        else\n        {\n            return EntryPushNonJavascriptArray(scriptContext, args, 2);\n        }\n\n    }\n\n    /*\n    *   EntryPushNonJavascriptArray\n    *   - Handles Entry push calls, when Objects are not javascript arrays\n    */\n    Var JavascriptArray::EntryPushNonJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n            RecyclableObject* obj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));\n            }\n\n            Var length = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            if(JavascriptOperators::GetTypeId(length) == TypeIds_Undefined && scriptContext->GetThreadContext()->IsDisableImplicitCall() &&\n                scriptContext->GetThreadContext()->GetImplicitCallFlags() != Js::ImplicitCall_None)\n            {\n                return length;\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n            BigIndex n;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                n = (uint64) JavascriptConversion::ToLength(length, scriptContext);\n            }\n            else\n            {\n                n = JavascriptConversion::ToUInt32(length, scriptContext);\n            }\n            // First handle \"small\" indices.\n            uint index;\n            for (index=1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)\n            {\n                if (h.IsThrowTypeError(JavascriptOperators::SetItem(obj, obj, n.GetSmallIndex(), args[index], scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if (scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n            }\n\n            // Use BigIndex if we need to push indices >= MaxArrayLength\n            if (index < argCount)\n            {\n                BigIndex big = n;\n\n                for (; index < argCount; ++index, ++big)\n                {\n                    if (h.IsThrowTypeError(big.SetItem(obj, args[index], PropertyOperation_ThrowIfNotExtensible)))\n                    {\n                        if(scriptContext->GetThreadContext()->RecordImplicitException())\n                        {\n                            h.ThrowTypeErrorOnFailure();\n                        }\n                        else\n                        {\n                            return nullptr;\n                        }\n                    }\n\n                }\n\n                // Set the new length; for objects it is all right for this to be >= MaxArrayLength\n                if (h.IsThrowTypeError(JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, big.ToNumber(scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if(scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n\n                return big.ToNumber(scriptContext);\n            }\n            else\n            {\n                // Set the new length\n                Var lengthAsNUmberVar = JavascriptNumber::ToVar(n.IsSmallIndex() ? n.GetSmallIndex() : n.GetBigIndex(), scriptContext);\n                if (h.IsThrowTypeError(JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, lengthAsNUmberVar, scriptContext, PropertyOperation_ThrowIfNotExtensible)))\n                {\n                    if(scriptContext->GetThreadContext()->RecordImplicitException())\n                    {\n                        h.ThrowTypeErrorOnFailure();\n                    }\n                    else\n                    {\n                        return nullptr;\n                    }\n                }\n\n                return lengthAsNUmberVar;\n            }\n    }\n\n    /*\n    *   JavascriptArray::EntryPushJavascriptArray\n    *   Pushes Var element in a Var Array.\n    *   Returns the length of the array.\n    */\n    Var JavascriptArray::EntryPushJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n        JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);\n        uint n = arr->length;\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n\n        // Fast Path for one push for small indexes\n        if (argCount == 2 && n < JavascriptArray::MaxArrayLength)\n        {\n            // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n            h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[1], PropertyOperation_None));\n            return JavascriptNumber::ToVar(n + 1, scriptContext);\n        }\n\n        // Fast Path for multiple push for small indexes\n        if (JavascriptArray::MaxArrayLength - argCount + 1 > n && JavascriptArray::IsVarArray(arr) && scriptContext == arr->GetScriptContext())\n        {\n            uint index;\n            for (index = 1; index < argCount; ++index, ++n)\n            {\n                Assert(n != JavascriptArray::MaxArrayLength);\n                // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n                arr->JavascriptArray::DirectSetItemAt(n, args[index]);\n            }\n            return JavascriptNumber::ToVar(n, scriptContext);\n        }\n\n        return EntryPushJavascriptArrayNoFastPath(scriptContext, args, argCount);\n    }\n\n    Var JavascriptArray::EntryPushJavascriptArrayNoFastPath(ScriptContext * scriptContext, Var * args, uint argCount)\n    {\n        JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);\n        uint n = arr->length;\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));\n\n        // First handle \"small\" indices.\n        uint index;\n        for (index = 1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)\n        {\n            // Set Item is overridden by CrossSiteObject, so no need to check for IsCrossSiteObject()\n            h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[index], PropertyOperation_None));\n        }\n\n        // Use BigIndex if we need to push indices >= MaxArrayLength\n        if (index < argCount)\n        {\n            // Not supporting native array with BigIndex.\n            arr = EnsureNonNativeArray(arr);\n            Assert(n == JavascriptArray::MaxArrayLength);\n            for (BigIndex big = n; index < argCount; ++index, ++big)\n            {\n                h.ThrowTypeErrorOnFailure(big.SetItem(arr, args[index]));\n            }\n\n#ifdef VALIDATE_ARRAY\n            arr->ValidateArray();\n#endif\n            // This is where we should set the length, but for arrays it cannot be >= MaxArrayLength\n            JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n        }\n\n#ifdef VALIDATE_ARRAY\n        arr->ValidateArray();\n#endif\n        return JavascriptNumber::ToVar(n, scriptContext);\n    }\n\n    /*\n    *   JavascriptArray::EntryPush\n    *   Handles Push calls(Script Function)\n    */\n    Var JavascriptArray::EntryPush(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            return EntryPushJavascriptArray(scriptContext, args.Values, args.Info.Count);\n        }\n        else\n        {\n            return EntryPushNonJavascriptArray(scriptContext, args.Values, args.Info.Count);\n        }\n    }\n\n\n    Var JavascriptArray::EntryReverse(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));\n        }\n\n        BigIndex length = 0u;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]))\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext);\n    }\n\n    // Array.prototype.reverse as described in ES6.0 (draft 22) Section 22.1.3.20\n    template <typename T>\n    Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)\n    {\n        T middle = length / 2;\n        Var lowerValue = nullptr, upperValue = nullptr;\n        T lowerExists, upperExists;\n        const char16* methodName;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n\n        if (isTypedArrayEntryPoint)\n        {\n            methodName = _u(\"[TypedArray].prototype.reverse\");\n        }\n        else\n        {\n            methodName = _u(\"Array.prototype.reverse\");\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, methodName);\n\n        if (pArr)\n        {\n            Recycler * recycler = scriptContext->GetRecycler();\n\n            if (length <= 1)\n            {\n                return pArr;\n            }\n\n            if (pArr->IsFillFromPrototypes())\n            {\n                // For odd-length arrays, the middle element is unchanged,\n                // so we cannot fill it from the prototypes.\n                if (length % 2 == 0)\n                {\n                    pArr->FillFromPrototypes(0, (uint32)length);\n                }\n                else\n                {\n                    middle = length / 2;\n                    pArr->FillFromPrototypes(0, (uint32)middle);\n                    pArr->FillFromPrototypes(1 + (uint32)middle, (uint32)length);\n                }\n            }\n\n            if (pArr->HasNoMissingValues() && pArr->head && pArr->head->next)\n            {\n                // This function currently does not track missing values in the head segment if there are multiple segments\n                pArr->SetHasNoMissingValues(false);\n            }\n\n            // Above FillFromPrototypes call can change the length of the array. Our segment calculation below will\n            // not work with the stale length. Update the length.\n            // Note : since we are reversing the whole segment below - the functionality is not spec compliant already.\n            length = pArr->length;\n\n            SparseArraySegmentBase* seg = pArr->head;\n            SparseArraySegmentBase *prevSeg = nullptr;\n            SparseArraySegmentBase *nextSeg = nullptr;\n            SparseArraySegmentBase *pinPrevSeg = nullptr;\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n\n            if (JavascriptNativeIntArray::Is(pArr))\n            {\n                isIntArray = true;\n            }\n            else if (JavascriptNativeFloatArray::Is(pArr))\n            {\n                isFloatArray = true;\n            }\n\n            while (seg)\n            {\n                nextSeg = seg->next;\n\n                // If seg.length == 0, it is possible that (seg.left + seg.length == prev.left + prev.length),\n                // resulting in 2 segments sharing the same \"left\".\n                if (seg->length > 0)\n                {\n                    if (isIntArray)\n                    {\n                        ((SparseArraySegment<int32>*)seg)->ReverseSegment(recycler);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ((SparseArraySegment<double>*)seg)->ReverseSegment(recycler);\n                    }\n                    else\n                    {\n                        ((SparseArraySegment<Var>*)seg)->ReverseSegment(recycler);\n                    }\n\n                    seg->left = ((uint32)length) > (seg->left + seg->length) ? ((uint32)length) - (seg->left + seg->length) : 0;\n\n                    seg->next = prevSeg;\n                    // Make sure size doesn't overlap with next segment.\n                    // An easy fix is to just truncate the size...\n                    seg->EnsureSizeInBound();\n\n                    // If the last segment is a leaf, then we may be losing our last scanned pointer to its previous\n                    // segment. Hold onto it with pinPrevSeg until we reallocate below.\n                    pinPrevSeg = prevSeg;\n                    prevSeg = seg;\n                }\n\n                seg = nextSeg;\n            }\n\n            pArr->head = prevSeg;\n\n            // Just dump the segment map on reverse\n            pArr->ClearSegmentMap();\n\n            if (isIntArray)\n            {\n                if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))\n                {\n                    pArr->ReallocNonLeafSegment((SparseArraySegment<int32>*)pArr->head, pArr->head->next);\n                }\n                pArr->EnsureHeadStartsFromZero<int32>(recycler);\n            }\n            else if (isFloatArray)\n            {\n                if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))\n                {\n                    pArr->ReallocNonLeafSegment((SparseArraySegment<double>*)pArr->head, pArr->head->next);\n                }\n                pArr->EnsureHeadStartsFromZero<double>(recycler);\n            }\n            else\n            {\n                pArr->EnsureHeadStartsFromZero<Var>(recycler);\n            }\n\n            pArr->InvalidateLastUsedSegment(); // lastUsedSegment might be 0-length and discarded above\n\n#ifdef VALIDATE_ARRAY\n            pArr->ValidateArray();\n#endif\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= JavascriptArray::MaxArrayLength);\n            if (typedArrayBase->GetLength() == length)\n            {\n                // If typedArrayBase->length == length then we know that the TypedArray will have all items < length\n                // and we won't have to check that the elements exist or not.\n                for (uint32 lower = 0; lower < (uint32)middle; lower++)\n                {\n                    uint32 upper = (uint32)length - lower - 1;\n\n                    lowerValue = typedArrayBase->DirectGetItem(lower);\n                    upperValue = typedArrayBase->DirectGetItem(upper);\n\n                    // We still have to call HasItem even though we know the TypedArray has both lower and upper because\n                    // there may be a proxy handler trapping HasProperty.\n                    lowerExists = typedArrayBase->HasItem(lower);\n                    upperExists = typedArrayBase->HasItem(upper);\n\n                    h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                    h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                }\n            }\n            else\n            {\n                for (uint32 lower = 0; lower < middle; lower++)\n                {\n                    uint32 upper = (uint32)length - lower - 1;\n\n                    lowerValue = typedArrayBase->DirectGetItem(lower);\n                    upperValue = typedArrayBase->DirectGetItem(upper);\n\n                    lowerExists = typedArrayBase->HasItem(lower);\n                    upperExists = typedArrayBase->HasItem(upper);\n\n                    if (lowerExists)\n                    {\n                        if (upperExists)\n                        {\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                        }\n                        else\n                        {\n                            // This will always fail for a TypedArray if lower < length\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(lower, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue));\n                        }\n                    }\n                    else\n                    {\n                        if (upperExists)\n                        {\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue));\n                            // This will always fail for a TypedArray if upper < length\n                            h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(upper, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (T lower = 0; lower < middle; lower++)\n            {\n                T upper = length - lower - 1;\n\n                lowerExists = JavascriptOperators::HasItem(obj, lower) &&\n                              JavascriptOperators::GetItem(obj, lower, &lowerValue, scriptContext);\n\n                upperExists = JavascriptOperators::HasItem(obj, upper) &&\n                              JavascriptOperators::GetItem(obj, upper, &upperValue, scriptContext);\n\n                if (lowerExists)\n                {\n                    if (upperExists)\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                    else\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, lower, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                }\n                else\n                {\n                    if (upperExists)\n                    {\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, upper, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                    }\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    template<typename T>\n    void JavascriptArray::ShiftHelper(JavascriptArray* pArr, ScriptContext * scriptContext)\n    {\n        Recycler * recycler = scriptContext->GetRecycler();\n\n        SparseArraySegment<T>* next = (SparseArraySegment<T>*)pArr->head->next;\n        while (next)\n        {\n            next->left--;\n            next = (SparseArraySegment<T>*)next->next;\n        }\n\n        // head and next might overlap as the next segment left is decremented\n        next = (SparseArraySegment<T>*)pArr->head->next;\n        if (next && (pArr->head->size > next->left))\n        {\n            AssertMsg(pArr->head->left == 0, \"Array always points to a head starting at index 0\");\n            AssertMsg(pArr->head->size == next->left + 1, \"Shift next->left overlaps current segment by more than 1 element\");\n\n            SparseArraySegment<T> *head = (SparseArraySegment<T>*)pArr->head;\n            // Merge the two adjacent segments\n            if (next->length != 0)\n            {\n                uint32 offset = head->size - 1;\n                // There is room for one unshifted element in head segment.\n                // Hence it's enough if we grow the head segment by next->length - 1\n\n                if (next->next)\n                {\n                    // If we have a next->next, we can't grow pass the left of that\n\n                    // If the array had a segment map before, the next->next might just be right after next as well.\n                    // So we just need to grow to the end of the next segment\n                    // TODO: merge that segment too?\n                    Assert(next->next->left >= head->size);\n                    uint32 maxGrowSize = next->next->left - head->size;\n                    if (maxGrowSize != 0)\n                    {\n                        head = head->GrowByMinMax(recycler, next->length - 1, maxGrowSize); //-1 is to account for unshift\n                    }\n                    else\n                    {\n                        // The next segment is only of length one, so we already have space in the header to copy that\n                        Assert(next->length == 1);\n                    }\n                }\n                else\n                {\n                    head = head->GrowByMin(recycler, next->length - 1); //-1 is to account for unshift\n                }\n                memmove(head->elements + offset, next->elements, next->length * sizeof(T));\n                head->length = offset + next->length;\n                pArr->head = head;\n            }\n            head->next = next->next;\n            pArr->InvalidateLastUsedSegment();\n        }\n\n#ifdef VALIDATE_ARRAY\n            pArr->ValidateArray();\n#endif\n    }\n\n    Var JavascriptArray::EntryShift(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n            return res;\n        }\n        if (JavascriptArray::Is(args[0]))\n        {\n            JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n\n            if (pArr->length == 0)\n            {\n                return res;\n            }\n\n            if(pArr->IsFillFromPrototypes())\n            {\n                pArr->FillFromPrototypes(0, pArr->length); // We need find all missing value from [[proto]] object\n            }\n\n            if(pArr->HasNoMissingValues() && pArr->head && pArr->head->next)\n            {\n                // This function currently does not track missing values in the head segment if there are multiple segments\n                pArr->SetHasNoMissingValues(false);\n            }\n\n            pArr->length--;\n\n            pArr->ClearSegmentMap(); // Dump segmentMap on shift (before any allocation)\n\n            Recycler * recycler = scriptContext->GetRecycler();\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n\n            if(JavascriptNativeIntArray::Is(pArr))\n            {\n                isIntArray = true;\n            }\n            else if(JavascriptNativeFloatArray::Is(pArr))\n            {\n                isFloatArray = true;\n            }\n\n            if (pArr->head->length != 0)\n            {\n                if(isIntArray)\n                {\n                    int32 nativeResult = ((SparseArraySegment<int32>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<int32>::IsMissingItem(&nativeResult))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = Js::JavascriptNumber::ToVar(nativeResult, scriptContext);\n                    }\n                    ((SparseArraySegment<int32>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n                else if (isFloatArray)\n                {\n                    double nativeResult = ((SparseArraySegment<double>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<double>::IsMissingItem(&nativeResult))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = Js::JavascriptNumber::ToVarNoCheck(nativeResult, scriptContext);\n                    }\n                    ((SparseArraySegment<double>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n                else\n                {\n                    res = ((SparseArraySegment<Var>*)pArr->head)->GetElement(0);\n\n                    if(SparseArraySegment<Var>::IsMissingItem(&res))\n                    {\n                        res = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    else\n                    {\n                        res = CrossSite::MarshalVar(scriptContext, res);\n                    }\n                    ((SparseArraySegment<Var>*)pArr->head)->RemoveElement(recycler, 0);\n                }\n            }\n\n            if(isIntArray)\n            {\n                ShiftHelper<int32>(pArr, scriptContext);\n            }\n            else if (isFloatArray)\n            {\n                ShiftHelper<double>(pArr, scriptContext);\n            }\n            else\n            {\n                ShiftHelper<Var>(pArr, scriptContext);\n            }\n        }\n        else\n        {\n            RecyclableObject* dynamicObject = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.shift\"));\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.shift\"));\n\n            BigIndex length = 0u;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n\n            if (length == 0u)\n            {\n                // If length is 0, return 'undefined'\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                return scriptContext->GetLibrary()->GetUndefined();\n            }\n            if (!JavascriptOperators::GetItem(dynamicObject, 0u, &res, scriptContext))\n            {\n                res = scriptContext->GetLibrary()->GetUndefined();\n            }\n            --length;\n            uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;\n            for (uint32 i = 0u; i < lengthToUin32Max; i++)\n            {\n                if (JavascriptOperators::HasItem(dynamicObject, i + 1))\n                {\n                    Var element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible, /*skipPrototypeCheck*/ true));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n            }\n\n            for (uint64 i = MaxArrayLength; length > i; i++)\n            {\n                if (JavascriptOperators::HasItem(dynamicObject, i + 1))\n                {\n                    Var element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n            }\n\n            if (length.IsSmallIndex())\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            }\n            else\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig));\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n            }\n        }\n        return res;\n    }\n\n    Js::JavascriptArray* JavascriptArray::CreateNewArrayHelper(uint32 len, bool isIntArray, bool isFloatArray,  Js::JavascriptArray* baseArray, ScriptContext* scriptContext)\n    {\n        if (isIntArray)\n        {\n            Js::JavascriptNativeIntArray *pnewArr = scriptContext->GetLibrary()->CreateNativeIntArray(len);\n            pnewArr->EnsureHead<int32>();\n#if ENABLE_PROFILE_INFO\n            pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeIntArray::FromVar(baseArray));\n#endif\n\n            return pnewArr;\n        }\n        else if (isFloatArray)\n        {\n            Js::JavascriptNativeFloatArray *pnewArr  = scriptContext->GetLibrary()->CreateNativeFloatArray(len);\n            pnewArr->EnsureHead<double>();\n#if ENABLE_PROFILE_INFO\n            pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeFloatArray::FromVar(baseArray));\n#endif\n\n            return pnewArr;\n        }\n        else\n        {\n            JavascriptArray *pnewArr = pnewArr = scriptContext->GetLibrary()->CreateArray(len);\n            pnewArr->EnsureHead<Var>();\n            return pnewArr;\n        }\n   }\n\n    template<typename T>\n    void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)pArr->head;\n        SparseArraySegment<T>* pnewHeadSeg = (SparseArraySegment<T>*)pnewArr->head;\n\n        // Fill the newly created sliced array\n        js_memcpy_s(pnewHeadSeg->elements, sizeof(T) * newLen, headSeg->elements + start, sizeof(T) * newLen);\n        pnewHeadSeg->length = newLen;\n\n        Assert(pnewHeadSeg->length <= pnewHeadSeg->size);\n        // Prototype lookup for missing elements\n        if (!pArr->HasNoMissingValues())\n        {\n            for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)\n            {\n                // array type might be changed in the below call to DirectGetItemAtFull\n                // need recheck array type before checking array item [i + start]\n                if (pArr->IsMissingItem(i + start))\n                {\n                    Var element;\n                    pnewArr->SetHasNoMissingValues(false);\n                    if (pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        pnewArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n        }\n#ifdef DBG\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }\n    // If the creating profile data has changed, convert it to the type of array indicated\n    // in the profile\n    void JavascriptArray::GetArrayTypeAndConvert(bool* isIntArray, bool* isFloatArray)\n    {\n        if (JavascriptNativeIntArray::Is(this))\n        {\n#if ENABLE_PROFILE_INFO\n            JavascriptNativeIntArray* nativeIntArray = JavascriptNativeIntArray::FromVar(this);\n            ArrayCallSiteInfo* info = nativeIntArray->GetArrayCallSiteInfo();\n            if(!info || info->IsNativeIntArray())\n            {\n                *isIntArray = true;\n            }\n            else if(info->IsNativeFloatArray())\n            {\n                JavascriptNativeIntArray::ToNativeFloatArray(nativeIntArray);\n                *isFloatArray = true;\n            }\n            else\n            {\n                JavascriptNativeIntArray::ToVarArray(nativeIntArray);\n            }\n#else\n            *isIntArray = true;\n#endif\n        }\n        else if (JavascriptNativeFloatArray::Is(this))\n        {\n#if ENABLE_PROFILE_INFO\n            JavascriptNativeFloatArray* nativeFloatArray = JavascriptNativeFloatArray::FromVar(this);\n            ArrayCallSiteInfo* info = nativeFloatArray->GetArrayCallSiteInfo();\n\n            if(info && !info->IsNativeArray())\n            {\n                JavascriptNativeFloatArray::ToVarArray(nativeFloatArray);\n            }\n            else\n            {\n                *isFloatArray = true;\n            }\n#else\n            *isFloatArray = true;\n#endif\n        }\n    }\n\n    Var JavascriptArray::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n            return res;\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.slice\"));\n            }\n        }\n\n        Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(lenValue, scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max());\n        return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.slice as described in ES6.0 (draft 22) Section 22.1.3.22\n    template <typename T>\n    Var JavascriptArray::SliceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        JavascriptArray* newArr = nullptr;\n        RecyclableObject* newObj = nullptr;\n        bool isIntArray = false;\n        bool isFloatArray = false;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n        bool isBuiltinArrayCtor = true;\n        T startT = 0;\n        T newLenT = length;\n        T endT = length;\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);\n#endif\n        if (args.Info.Count > 1)\n        {\n            startT = GetFromIndex(args[1], length, scriptContext);\n\n            if (startT > length)\n            {\n                startT = length;\n            }\n\n            if (args.Info.Count > 2)\n            {\n                if (JavascriptOperators::GetTypeId(args[2]) == TypeIds_Undefined)\n                {\n                    endT = length;\n                }\n                else\n                {\n                    endT = GetFromIndex(args[2], length, scriptContext);\n\n                    if (endT > length)\n                    {\n                        endT = length;\n                    }\n                }\n            }\n\n            newLenT = endT > startT ? endT - startT : 0;\n        }\n\n        if (TypedArrayBase::IsDetachedTypedArray(obj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.slice\"));\n        }\n\n        // If we came from Array.prototype.slice and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // If the entry point is %TypedArray%.prototype.slice or the source object is an Array exotic object we should try to load the constructor property\n        // and use it to construct the return object.\n        if (isTypedArrayEntryPoint)\n        {\n            Var constructor = JavascriptOperators::SpeciesConstructor(typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext);\n            isBuiltinArrayCtor = (constructor == library->GetArrayConstructor());\n\n            // If we have an array source object, we need to make sure to do the right thing if it's a native array.\n            // The helpers below which do the element copying require the source and destination arrays to have the same native type.\n            if (pArr && isBuiltinArrayCtor)\n            {\n                if (newLenT > JavascriptArray::MaxArrayLength)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n                }\n\n                // If the constructor function is the built-in Array constructor, we can be smart and create the right type of native array.\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n                newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);\n                newObj = newArr;\n            }\n            else if (JavascriptOperators::IsConstructor(constructor))\n            {\n                if (pArr)\n                {\n                    // If the constructor function is any other function, it can return anything so we have to call it.\n                    // Roll the source array into a non-native array if it was one.\n                    pArr = EnsureNonNativeArray(pArr);\n                }\n\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(newLenT, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)newLenT, scriptContext));\n            }\n            else\n            {\n                // We only need to throw a TypeError when the constructor property is not an actual constructor if %TypedArray%.prototype.slice was called\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidTypedArray_Constructor, _u(\"[TypedArray].prototype.slice\"));\n            }\n        }\n\n        else if (pArr != nullptr)\n        {\n            newObj = ArraySpeciesCreate(pArr, newLenT, scriptContext, &isIntArray, &isFloatArray, &isBuiltinArrayCtor);\n        }\n\n        // skip the typed array and \"pure\" array case, we still need to handle special arrays like es5array, remote array, and proxy of array.\n        else\n        {\n            newObj = ArraySpeciesCreate(obj, newLenT, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        }\n\n        // If we didn't create a new object above we will create a new array here.\n        // This is the pre-ES6 behavior or the case of calling Array.prototype.slice with a constructor argument that is not a constructor function.\n        if (newObj == nullptr)\n        {\n            if (pArr)\n            {\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n            }\n\n            if (newLenT > JavascriptArray::MaxArrayLength)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n\n            newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);\n#endif\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        uint32 start  = (uint32) startT;\n        uint32 newLen = (uint32) newLenT;\n\n        // We at least have to have newObj as a valid object\n        Assert(newObj);\n\n        // Bail out early if the new object will have zero length.\n        if (newLen == 0)\n        {\n            return newObj;\n        }\n\n        if (pArr)\n        {\n            // If we constructed a new Array object, we have some nice helpers here\n            if (newArr && isBuiltinArrayCtor)\n            {\n                if (JavascriptArray::IsDirectAccessArray(newArr))\n                {\n                    if (((start + newLen) <= pArr->head->length) && newLen <= newArr->head->size) //Fast Path\n                    {\n                        if (isIntArray)\n                        {\n                            SliceHelper<int32>(pArr, newArr, start, newLen);\n                        }\n                        else if (isFloatArray)\n                        {\n                            SliceHelper<double>(pArr, newArr, start, newLen);\n                        }\n                        else\n                        {\n                            SliceHelper<Var>(pArr, newArr, start, newLen);\n                        }\n                    }\n                    else\n                    {\n                        if (isIntArray)\n                        {\n                            CopyNativeIntArrayElements(JavascriptNativeIntArray::FromVar(newArr), 0, JavascriptNativeIntArray::FromVar(pArr), start, start + newLen);\n                        }\n                        else if (isFloatArray)\n                        {\n                            CopyNativeFloatArrayElements(JavascriptNativeFloatArray::FromVar(newArr), 0, JavascriptNativeFloatArray::FromVar(pArr), start, start + newLen);\n                        }\n                        else\n                        {\n                            CopyArrayElements(newArr, 0u, pArr, start, start + newLen);\n                        }\n                    }\n                }\n                else\n                {\n                    AssertMsg(CONFIG_FLAG(ForceES5Array), \"newArr can only be ES5Array when it is forced\");\n                    Var element;\n                    for (uint32 i = 0; i < newLen; i++)\n                    {\n                        if (!pArr->DirectGetItemAtFull(i + start, &element))\n                        {\n                            continue;\n                        }\n\n                        newArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n            else\n            {\n                // The constructed object isn't an array, we'll need to use normal object manipulation\n                Var element;\n\n                for (uint32 i = 0; i < newLen; i++)\n                {\n                    if (!pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        continue;\n                    }\n\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            // Source is a TypedArray, we must have created the return object via a call to constructor, but newObj may not be a TypedArray (or an array either)\n            TypedArrayBase* newTypedArray = nullptr;\n\n            if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n\n            Var element;\n\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                // We only need to call HasItem in the case that we are called from Array.prototype.slice\n                if (!isTypedArrayEntryPoint && !typedArrayBase->HasItem(i + start))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(i + start);\n\n                // The object we got back from the constructor might not be a TypedArray. In fact, it could be any object.\n                if (newTypedArray)\n                {\n                    newTypedArray->DirectSetItem(i, element);\n                }\n                else if (newArr)\n                {\n                    newArr->DirectSetItemAt(i, element);\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI_UInt32(newObj, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                if (JavascriptOperators::HasItem(obj, i + start))\n                {\n                    Var element = JavascriptOperators::GetItem(obj, i + start, scriptContext);\n                    if (newArr != nullptr)\n                    {\n                        newArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                    }\n                }\n            }\n        }\n\n        if (!isTypedArrayEntryPoint)\n        {\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (JavascriptArray::Is(newObj))\n        {\n            JavascriptArray::FromVar(newObj)->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    struct CompareVarsInfo\n    {\n        ScriptContext* scriptContext;\n        RecyclableObject* compFn;\n    };\n\n    int __cdecl compareVars(void* cvInfoV, const void* aRef, const void* bRef)\n    {\n        CompareVarsInfo* cvInfo=(CompareVarsInfo*)cvInfoV;\n        ScriptContext* requestContext=cvInfo->scriptContext;\n        RecyclableObject* compFn=cvInfo->compFn;\n\n        AssertMsg(*(Var*)aRef, \"No null expected in sort\");\n        AssertMsg(*(Var*)bRef, \"No null expected in sort\");\n\n        if (compFn != nullptr)\n        {\n            ScriptContext* scriptContext = compFn->GetScriptContext();\n            // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n            CallFlags flags = CallFlags_Value;\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            Var retVal;\n            if (requestContext != scriptContext)\n            {\n                Var leftVar = CrossSite::MarshalVar(scriptContext, *(Var*)aRef);\n                Var rightVar = CrossSite::MarshalVar(scriptContext, *(Var*)bRef);\n                retVal = CALL_FUNCTION(compFn, CallInfo(flags, 3), undefined, leftVar, rightVar);\n            }\n            else\n            {\n                retVal = CALL_FUNCTION(compFn, CallInfo(flags, 3), undefined, *(Var*)aRef, *(Var*)bRef);\n            }\n\n            if (TaggedInt::Is(retVal))\n            {\n                return TaggedInt::ToInt32(retVal);\n            }\n            double dblResult;\n            if (JavascriptNumber::Is_NoTaggedIntCheck(retVal))\n            {\n                dblResult = JavascriptNumber::GetValue(retVal);\n            }\n            else\n            {\n                dblResult = JavascriptConversion::ToNumber_Full(retVal, scriptContext);\n            }\n            if (dblResult < 0)\n            {\n                return -1;\n            }\n            return (dblResult > 0) ? 1 : 0;\n        }\n        else\n        {\n            JavascriptString* pStr1 = JavascriptConversion::ToString(*(Var*)aRef, requestContext);\n            JavascriptString* pStr2 = JavascriptConversion::ToString(*(Var*)bRef, requestContext);\n\n            return JavascriptString::strcmp(pStr1, pStr2);\n        }\n    }\n\n    static void hybridSort(__inout_ecount(length) Var *elements, uint32 length, CompareVarsInfo* compareInfo)\n    {\n        // The cost of memory moves starts to be more expensive than additional comparer calls (given a simple comparer)\n        // for arrays of more than 512 elements.\n        if (length > 512)\n        {\n            qsort_s(elements, length, sizeof(Var), compareVars, compareInfo);\n            return;\n        }\n\n        for (int i = 1; i < (int)length; i++)\n        {\n            if (compareVars(compareInfo, elements + i, elements + i - 1) < 0) {\n                // binary search for the left-most element greater than value:\n                int first = 0;\n                int last = i - 1;\n                while (first <= last)\n                {\n                    int middle = (first + last) / 2;\n                    if (compareVars(compareInfo, elements + i, elements + middle) < 0)\n                    {\n                        last = middle - 1;\n                    }\n                    else\n                    {\n                        first = middle + 1;\n                    }\n                }\n\n                // insert value right before first:\n                Var value = elements[i];\n                memmove(elements + first + 1, elements + first, (i - first) * sizeof(Var));\n                elements[first] = value;\n            }\n        }\n    }\n\n    void JavascriptArray::Sort(RecyclableObject* compFn)\n    {\n        if (length <= 1)\n        {\n            return;\n        }\n\n        this->EnsureHead<Var>();\n        ScriptContext* scriptContext = this->GetScriptContext();\n        Recycler* recycler = scriptContext->GetRecycler();\n\n        CompareVarsInfo cvInfo;\n        cvInfo.scriptContext = scriptContext;\n        cvInfo.compFn = compFn;\n\n        Assert(head != nullptr);\n\n        // Just dump the segment map on sort\n        ClearSegmentMap();\n\n        uint32 countUndefined = 0;\n        SparseArraySegment<Var>* startSeg = (SparseArraySegment<Var>*)head;\n\n        // Sort may have side effects on the array. Setting a dummy head so that original array is not affected\n        uint32 saveLength = length;\n        // that if compare function tries to modify the array it won't AV.\n        head = const_cast<SparseArraySegmentBase*>(EmptySegment);\n        SetFlags(DynamicObjectFlags::None);\n        this->InvalidateLastUsedSegment();\n        length = 0;\n\n        TryFinally([&]()\n        {\n            //The array is a continuous array if there is only one segment\n            if (startSeg->next == nullptr) // Single segment fast path\n            {\n                if (compFn != nullptr)\n                {\n                    countUndefined = startSeg->RemoveUndefined(scriptContext);\n\n#ifdef VALIDATE_ARRAY\n                    ValidateSegment(startSeg);\n#endif\n                    hybridSort(startSeg->elements, startSeg->length, &cvInfo);\n                }\n                else\n                {\n                    countUndefined = sort(startSeg->elements, &startSeg->length, scriptContext);\n                }\n                head = startSeg;\n            }\n            else\n            {\n                SparseArraySegment<Var>* allElements = SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, nullptr);\n                SparseArraySegment<Var>* next = startSeg;\n\n                uint32 nextIndex = 0;\n                // copy all the elements to single segment\n                while (next)\n                {\n                    countUndefined += next->RemoveUndefined(scriptContext);\n                    if (next->length != 0)\n                    {\n                        allElements = SparseArraySegment<Var>::CopySegment(recycler, allElements, nextIndex, next, next->left, next->length);\n                    }\n                    next = (SparseArraySegment<Var>*)next->next;\n                    nextIndex = allElements->length;\n\n#ifdef VALIDATE_ARRAY\n                    ValidateSegment(allElements);\n#endif\n                }\n\n                if (compFn != nullptr)\n                {\n                    hybridSort(allElements->elements, allElements->length, &cvInfo);\n                }\n                else\n                {\n                    sort(allElements->elements, &allElements->length, scriptContext);\n                }\n\n                head = allElements;\n                head->next = nullptr;\n            }\n        },\n        [&](bool hasException)\n        {\n            length = saveLength;\n            ClearSegmentMap(); // Dump the segmentMap again in case user compare function rebuilds it\n            if (hasException)\n            {\n                head = startSeg;\n                this->InvalidateLastUsedSegment();\n            }\n        });\n\n#if DEBUG\n        {\n            uint32 countNull = 0;\n            uint32 index = head->length - 1;\n            while (countNull < head->length)\n            {\n                if (((SparseArraySegment<Var>*)head)->elements[index] != NULL)\n                {\n                    break;\n                }\n                index--;\n                countNull++;\n            }\n            AssertMsg(countNull == 0, \"No null expected at the end\");\n        }\n#endif\n\n        if (countUndefined != 0)\n        {\n            // fill undefined at the end\n            uint32 newLength = head->length + countUndefined;\n            if (newLength > head->size)\n            {\n                head = ((SparseArraySegment<Var>*)head)->GrowByMin(recycler, newLength - head->size);\n            }\n\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            for (uint32 i = head->length; i < newLength; i++)\n            {\n                ((SparseArraySegment<Var>*)head)->elements[i] = undefined;\n            }\n            head->length = newLength;\n        }\n        SetHasNoMissingValues();\n        this->InvalidateLastUsedSegment();\n\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n        return;\n    }\n\n    uint32 JavascriptArray::sort(__inout_ecount(*len) Var *orig, uint32 *len, ScriptContext *scriptContext)\n    {\n        uint32 count = 0, countUndefined = 0;\n        Element *elements = RecyclerNewArrayZ(scriptContext->GetRecycler(), Element, *len);\n        RecyclableObject *undefined = scriptContext->GetLibrary()->GetUndefined();\n\n        //\n        // Create the Elements array\n        //\n\n        for (uint32 i = 0; i < *len; ++i)\n        {\n            if (!SparseArraySegment<Var>::IsMissingItem(&orig[i]))\n            {\n                if (!JavascriptOperators::IsUndefinedObject(orig[i], undefined))\n                {\n                    elements[count].Value = orig[i];\n                    elements[count].StringValue =  JavascriptConversion::ToString(orig[i], scriptContext);\n\n                    count++;\n                }\n                else\n                {\n                    countUndefined++;\n                }\n            }\n        }\n\n        if (count > 0)\n        {\n            SortElements(elements, 0, count - 1);\n\n            for (uint32 i = 0; i < count; ++i)\n            {\n                orig[i] = elements[i].Value;\n            }\n        }\n\n        for (uint32 i = count + countUndefined; i < *len; ++i)\n        {\n            orig[i] = SparseArraySegment<Var>::GetMissingItem();\n        }\n\n        *len = count; // set the correct length\n        return countUndefined;\n    }\n\n    int __cdecl JavascriptArray::CompareElements(void* context, const void* elem1, const void* elem2)\n    {\n        const Element* element1 = static_cast<const Element*>(elem1);\n        const Element* element2 = static_cast<const Element*>(elem2);\n\n        Assert(element1 != NULL);\n        Assert(element2 != NULL);\n\n        return JavascriptString::strcmp(element1->StringValue, element2->StringValue);\n    }\n\n    void JavascriptArray::SortElements(Element* elements, uint32 left, uint32 right)\n    {\n        qsort_s(elements, right - left + 1, sizeof(Element), CompareElements, this);\n    }\n\n    Var JavascriptArray::EntrySort(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.sort\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");\n\n        RecyclableObject* compFn = NULL;\n        if (args.Info.Count > 1)\n        {\n            if (JavascriptConversion::IsCallable(args[1]))\n            {\n                compFn = RecyclableObject::FromVar(args[1]);\n            }\n            else\n            {\n                TypeId typeId = JavascriptOperators::GetTypeId(args[1]);\n\n                // Use default comparer:\n                // - In ES5 mode if the argument is undefined.\n                bool useDefaultComparer = typeId == TypeIds_Undefined;\n                if (!useDefaultComparer)\n                {\n                    JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedInternalObject, _u(\"Array.prototype.sort\"));\n                }\n            }\n        }\n\n        if (JavascriptArray::Is(args[0]))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n\n            JavascriptArray *arr = JavascriptArray::FromVar(args[0]);\n\n            if (arr->length <= 1)\n            {\n                return args[0];\n            }\n\n            if(arr->IsFillFromPrototypes())\n            {\n                arr->FillFromPrototypes(0, arr->length); // We need find all missing value from [[proto]] object\n            }\n\n            // Maintain nativity of the array only for the following cases (To favor inplace conversions - keeps the conversion cost less):\n            // -    int cases for X86 and\n            // -    FloatArray for AMD64\n            // We convert the entire array back and forth once here O(n), rather than doing the costly conversion down the call stack which is O(nlogn)\n\n#if defined(_M_X64_OR_ARM64)\n            if(compFn && JavascriptNativeFloatArray::Is(arr))\n            {\n                arr = JavascriptNativeFloatArray::ConvertToVarArray((JavascriptNativeFloatArray*)arr);\n                arr->Sort(compFn);\n                arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeFloatArray, double>(arr);\n            }\n            else\n            {\n                EnsureNonNativeArray(arr);\n                arr->Sort(compFn);\n            }\n#else\n            if(compFn && JavascriptNativeIntArray::Is(arr))\n            {\n                //EnsureNonNativeArray(arr);\n                arr = JavascriptNativeIntArray::ConvertToVarArray((JavascriptNativeIntArray*)arr);\n                arr->Sort(compFn);\n                arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeIntArray, int32>(arr);\n            }\n            else\n            {\n                EnsureNonNativeArray(arr);\n                arr->Sort(compFn);\n            }\n#endif\n\n        }\n        else\n        {\n            RecyclableObject* pObj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.sort\"));\n            }\n            uint32 len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n            JavascriptArray* sortArray = scriptContext->GetLibrary()->CreateArray(len);\n            sortArray->EnsureHead<Var>();\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.sort\"));\n\n            BEGIN_TEMP_ALLOCATOR(tempAlloc, scriptContext, _u(\"Runtime\"))\n            {\n                JsUtil::List<uint32, ArenaAllocator>* indexList = JsUtil::List<uint32, ArenaAllocator>::New(tempAlloc);\n\n                for (uint32 i = 0; i < len; i++)\n                {\n                    Var item;\n                    if (JavascriptOperators::GetItem(pObj, i, &item, scriptContext))\n                    {\n                        indexList->Add(i);\n                        sortArray->DirectSetItemAt(i, item);\n                    }\n                }\n                if (indexList->Count() > 0)\n                {\n                    if (sortArray->length > 1)\n                    {\n                        sortArray->FillFromPrototypes(0, sortArray->length); // We need find all missing value from [[proto]] object\n                    }\n                    sortArray->Sort(compFn);\n\n                    uint32 removeIndex = sortArray->head->length;\n                    for (uint32 i = 0; i < removeIndex; i++)\n                    {\n                        AssertMsg(!SparseArraySegment<Var>::IsMissingItem(&((SparseArraySegment<Var>*)sortArray->head)->elements[i]), \"No gaps expected in sorted array\");\n                        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, i, ((SparseArraySegment<Var>*)sortArray->head)->elements[i], scriptContext));\n                    }\n                    for (int i = 0; i < indexList->Count(); i++)\n                    {\n                        uint32 value = indexList->Item(i);\n                        if (value >= removeIndex)\n                        {\n                            h.ThrowTypeErrorOnFailure((JavascriptOperators::DeleteItem(pObj, value)));\n                        }\n                    }\n                }\n\n            }\n            END_TEMP_ALLOCATOR(tempAlloc, scriptContext);\n        }\n        return args[0];\n    }\n\n    Var JavascriptArray::EntrySplice(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        Recycler *recycler = scriptContext->GetRecycler();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");\n\n        bool isArr = false;\n        JavascriptArray* pArr = 0;\n        RecyclableObject* pObj = 0;\n        RecyclableObject* newObj = nullptr;\n        uint32 start = 0;\n        uint32 deleteLen = 0;\n        uint32 len = 0;\n\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            isArr = true;\n            pArr = JavascriptArray::FromVar(args[0]);\n            pObj = pArr;\n            len = pArr->length;\n\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.splice\"));\n            }\n\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                int64 len64 = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n                len = len64 > UINT_MAX ? UINT_MAX : (uint)len64;\n            }\n            else\n            {\n                len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);\n            }\n        }\n\n        switch (args.Info.Count)\n        {\n        case 1:\n            start = len;\n            deleteLen = 0;\n            break;\n\n        case 2:\n            start = min(GetFromIndex(args[1], len, scriptContext), len);\n            deleteLen = len - start;\n            break;\n\n        default:\n            start = GetFromIndex(args[1], len, scriptContext);\n\n            if (start > len)\n            {\n                start = len;\n            }\n\n            // When start >= len, we know we won't be deleting any items and don't really need to evaluate the second argument.\n            // However, ECMA 262 15.4.4.12 requires that it be evaluated, anyway.  If the argument is an object with a valueOf\n            // with a side effect, this evaluation is observable.  Hence, we must evaluate.\n            if (TaggedInt::Is(args[2]))\n            {\n                int intDeleteLen = TaggedInt::ToInt32(args[2]);\n                if (intDeleteLen < 0)\n                {\n                    deleteLen = 0;\n                }\n                else\n                {\n                    deleteLen = intDeleteLen;\n                }\n            }\n            else\n            {\n                double dblDeleteLen = JavascriptConversion::ToInteger(args[2], scriptContext);\n\n                if (dblDeleteLen > len)\n                {\n                    deleteLen = (uint32)-1;\n                }\n                else if (dblDeleteLen <= 0)\n                {\n                    deleteLen = 0;\n                }\n                else\n                {\n                    deleteLen = (uint32)dblDeleteLen;\n                }\n            }\n            deleteLen = min(len - start, deleteLen);\n            break;\n        }\n\n        Var* insertArgs = args.Info.Count > 3 ? &args.Values[3] : nullptr;\n        uint32 insertLen = args.Info.Count > 3 ? args.Info.Count - 3 : 0;\n\n        ::Math::RecordOverflowPolicy newLenOverflow;\n        uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice\n\n        if (isArr)\n        {\n            // If we have missing values then convert to not native array for now\n            // In future, we could support this scenario.\n            if (deleteLen == insertLen)\n            {\n                pArr->FillFromPrototypes(start, start + deleteLen);\n            }\n            else if (len)\n            {\n                pArr->FillFromPrototypes(start, len);\n            }\n\n            //\n            // If newLen overflowed, pre-process to prevent pushing sparse array segments or elements out of\n            // max array length, which would result in tons of index overflow and difficult to fix.\n            //\n            if (newLenOverflow.HasOverflowed())\n            {\n                pArr = EnsureNonNativeArray(pArr);\n                BigIndex dstIndex = MaxArrayLength;\n\n                uint32 maxInsertLen = MaxArrayLength - start;\n                if (insertLen > maxInsertLen)\n                {\n                    // Copy overflowing insertArgs to properties\n                    for (uint32 i = maxInsertLen; i < insertLen; i++)\n                    {\n                        pArr->DirectSetItemAt(dstIndex, insertArgs[i]);\n                        ++dstIndex;\n                    }\n\n                    insertLen = maxInsertLen; // update\n\n                    // Truncate elements on the right to properties\n                    if (start + deleteLen < len)\n                    {\n                        pArr->TruncateToProperties(dstIndex, start + deleteLen);\n                    }\n                }\n                else\n                {\n                    // Truncate would-overflow elements to properties\n                    pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);\n                }\n\n                len = pArr->length; // update\n                newLen = len - deleteLen + insertLen;\n                Assert(newLen == MaxArrayLength);\n            }\n\n            if (insertArgs)\n            {\n                pArr = EnsureNonNativeArray(pArr);\n            }\n\n            bool isIntArray = false;\n            bool isFloatArray = false;\n            bool isBuiltinArrayCtor = true;\n            JavascriptArray *newArr = nullptr;\n\n            // Just dump the segment map on splice (before any possible allocation and throw)\n            pArr->ClearSegmentMap();\n\n            // If the source object is an Array exotic object (Array.isArray) we should try to load the constructor property\n            // and use it to construct the return object.\n            newObj = ArraySpeciesCreate(pArr, deleteLen, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n            if (newObj != nullptr)\n            {\n                pArr = EnsureNonNativeArray(pArr);\n                // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            // This is the ES5 case, pArr['constructor'] doesn't exist, or pArr['constructor'] is the builtin Array constructor\n            {\n                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n                newArr = CreateNewArrayHelper(deleteLen, isIntArray, isFloatArray, pArr, scriptContext);\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);\n#endif\n            }\n\n            // If return object is a JavascriptArray, we can use all the array splice helpers\n            if (newArr && isBuiltinArrayCtor && len == pArr->length)\n            {\n\n                // Array has a single segment (need not start at 0) and splice start lies in the range\n                // of that segment we optimize splice - Fast path.\n                if (pArr->IsSingleSegmentArray() && pArr->head->HasIndex(start))\n                {\n                    if (isIntArray)\n                    {\n                        ArraySegmentSpliceHelper<int32>(newArr, (SparseArraySegment<int32>*)pArr->head, (SparseArraySegment<int32>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ArraySegmentSpliceHelper<double>(newArr, (SparseArraySegment<double>*)pArr->head, (SparseArraySegment<double>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n                    else\n                    {\n                        ArraySegmentSpliceHelper<Var>(newArr, (SparseArraySegment<Var>*)pArr->head, (SparseArraySegment<Var>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);\n                    }\n\n                    // Since the start index is within the bounds of the original array's head segment, it will not acquire any new\n                    // missing values. If the original array had missing values in the head segment, some of them may have been\n                    // copied into the array that will be returned; otherwise, the array that is returned will also not have any\n                    // missing values.\n                    newArr->SetHasNoMissingValues(pArr->HasNoMissingValues());\n                }\n                else\n                {\n                    if (isIntArray)\n                    {\n                        ArraySpliceHelper<int32>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n                    else if (isFloatArray)\n                    {\n                        ArraySpliceHelper<double>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n                    else\n                    {\n                        ArraySpliceHelper<Var>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);\n                    }\n\n                    // This function currently does not track missing values in the head segment if there are multiple segments\n                    pArr->SetHasNoMissingValues(false);\n                    newArr->SetHasNoMissingValues(false);\n                }\n\n                if (isIntArray)\n                {\n                    pArr->EnsureHeadStartsFromZero<int32>(recycler);\n                    newArr->EnsureHeadStartsFromZero<int32>(recycler);\n                }\n                else if (isFloatArray)\n                {\n                    pArr->EnsureHeadStartsFromZero<double>(recycler);\n                    newArr->EnsureHeadStartsFromZero<double>(recycler);\n                }\n                else\n                {\n                    pArr->EnsureHeadStartsFromZero<Var>(recycler);\n                    newArr->EnsureHeadStartsFromZero<Var>(recycler);\n                }\n\n                pArr->InvalidateLastUsedSegment();\n\n                // it is possible for valueOf accessors for the start or deleteLen\n                // arguments to modify the size of the array. Since the resulting size of the array\n                // is based on the cached value of length, this might lead to us having to trim\n                // excess array segments at the end of the splice operation, which SetLength() will do.\n                // However, this is also slower than performing the simple length assignment, so we only\n                // do it if we can detect the array length changing.\n                if(pArr->length != len)\n                {\n                    pArr->SetLength(newLen);\n                }\n                else\n                {\n                    pArr->length = newLen;\n                }\n\n                if (newArr->length != deleteLen)\n                {\n                    newArr->SetLength(deleteLen);\n                }\n                else\n                {\n                    newArr->length = deleteLen;\n                }\n\n                newArr->InvalidateLastUsedSegment();\n\n#ifdef VALIDATE_ARRAY\n                newArr->ValidateArray();\n                pArr->ValidateArray();\n#endif\n                if (newLenOverflow.HasOverflowed())\n                {\n                    // ES5 15.4.4.12 16: If new len overflowed, SetLength throws\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n\n                return newArr;\n            }\n        }\n\n        if (newLenOverflow.HasOverflowed())\n        {\n            return ObjectSpliceHelper<BigIndex>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);\n        }\n        else // Use uint32 version if no overflow\n        {\n            return ObjectSpliceHelper<uint32>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);\n        }\n    }\n\n    inline BOOL JavascriptArray::IsSingleSegmentArray() const\n    {\n        return nullptr == head->next;\n    }\n\n    template<typename T>\n    void JavascriptArray::ArraySegmentSpliceHelper(JavascriptArray *pnewArr, SparseArraySegment<T> *seg, SparseArraySegment<T> **prev,\n                                                    uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, Recycler *recycler)\n    {\n        // book keeping variables\n        uint32 relativeStart    = start - seg->left;  // This will be different from start when head->left is non zero -\n                                                      //(Missing elements at the beginning)\n\n        uint32 headDeleteLen    = min(start + deleteLen , seg->left + seg->length) - start;   // actual number of elements to delete in\n                                                                                              // head if deleteLen overflows the length of head\n\n        uint32 newHeadLen       = seg->length - headDeleteLen + insertLen;     // new length of the head after splice\n\n        // Save the deleted elements\n        if (headDeleteLen != 0)\n        {\n            pnewArr->InvalidateLastUsedSegment();\n            pnewArr->head = SparseArraySegment<T>::CopySegment(recycler, (SparseArraySegment<T>*)pnewArr->head, 0, seg, start, headDeleteLen);\n        }\n\n        if (newHeadLen != 0)\n        {\n            if (seg->size < newHeadLen)\n            {\n                if (seg->next)\n                {\n                    // If we have \"next\", require that we haven't adjusted next segments left yet.\n                    seg = seg->GrowByMinMax(recycler, newHeadLen - seg->size, seg->next->left - deleteLen + insertLen - seg->left - seg->size);\n                }\n                else\n                {\n                    seg = seg->GrowByMin(recycler, newHeadLen - seg->size);\n                }\n#ifdef VALIDATE_ARRAY\n                ValidateSegment(seg);\n#endif\n            }\n\n            // Move the elements if necessary\n            if (headDeleteLen != insertLen)\n            {\n                uint32 noElementsToMove = seg->length - (relativeStart + headDeleteLen);\n                memmove(seg->elements + relativeStart + insertLen,\n                                     seg->elements + relativeStart + headDeleteLen,\n                                     sizeof(T) * noElementsToMove);\n                if (newHeadLen < seg->length) // truncate if necessary\n                {\n                    seg->Truncate(seg->left + newHeadLen); // set end elements to null so that when we introduce null elements we are safe\n                }\n                seg->length = newHeadLen;\n            }\n            // Copy the new elements\n            if (insertLen > 0)\n            {\n                Assert(!VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pnewArr) &&\n                   !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pnewArr));\n\n                // inserted elements starts at argument 3 of splice(start, deleteNumber, insertelem1, insertelem2, insertelem3, ...);\n                js_memcpy_s(seg->elements + relativeStart, sizeof(Var) * insertLen, insertArgs, sizeof(Var) * insertLen);\n            }\n            *prev = seg;\n        }\n        else\n        {\n            *prev = (SparseArraySegment<T>*)seg->next;\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::ArraySpliceHelper(JavascriptArray* pnewArr, JavascriptArray* pArr, uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)\n    {\n        // Skip pnewArr->EnsureHead(): we don't use existing segment at all.\n        Recycler *recycler  = scriptContext->GetRecycler();\n\n        SparseArraySegmentBase** prevSeg  = &pArr->head;        // holds the next pointer of previous\n        SparseArraySegmentBase** prevPrevSeg  = &pArr->head;    // this holds the previous pointer to prevSeg dirty trick.\n        SparseArraySegmentBase* savePrev = nullptr;\n\n        Assert(pArr->head); // We should never have a null head.\n        pArr->EnsureHead<T>();\n        SparseArraySegment<T>* startSeg = (SparseArraySegment<T>*)pArr->head;\n\n        const uint32 limit = start + deleteLen;\n        uint32 rightLimit;\n        if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))\n        {\n            rightLimit = JavascriptArray::MaxArrayLength;\n        }\n\n        // Find out the segment to start delete\n        while (startSeg && (rightLimit <= start))\n        {\n            savePrev = startSeg;\n            prevPrevSeg = prevSeg;\n            prevSeg = &startSeg->next;\n            startSeg = (SparseArraySegment<T>*)startSeg->next;\n\n            if (startSeg)\n            {\n                if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))\n                {\n                    rightLimit = JavascriptArray::MaxArrayLength;\n                }\n            }\n        }\n\n        // handle inlined segment\n        SparseArraySegmentBase* inlineHeadSegment = nullptr;\n        bool hasInlineSegment = false;\n        // The following if else set is used to determine whether a shallow or hard copy is needed\n        if (JavascriptNativeArray::Is(pArr))\n        {\n            if (JavascriptNativeFloatArray::Is(pArr))\n            {\n                inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>((JavascriptNativeFloatArray*)pArr);\n            }\n            else if (JavascriptNativeIntArray::Is(pArr))\n            {\n                inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>((JavascriptNativeIntArray*)pArr);\n            }\n            Assert(inlineHeadSegment);\n            hasInlineSegment = (startSeg == (SparseArraySegment<T>*)inlineHeadSegment);\n        }\n        else\n        {\n            // This will result in false positives. It is used because DetermineInlineHeadSegmentPointer\n            // does not handle Arrays that change type e.g. from JavascriptNativeIntArray to JavascriptArray\n            // This conversion in particular is problematic because JavascriptNativeIntArray is larger than JavascriptArray\n            // so the returned head segment ptr never equals pArr->head. So we will default to using this and deal with\n            // false positives. It is better than always doing a hard copy.\n            hasInlineSegment = HasInlineHeadSegment(pArr->head->length);\n        }\n\n        if (startSeg)\n        {\n            // Delete Phase\n            if (startSeg->left <= start && (startSeg->left + startSeg->length) >= limit)\n            {\n                // All splice happens in one segment.\n                SparseArraySegmentBase *nextSeg = startSeg->next;\n                // Splice the segment first, which might OOM throw but the array would be intact.\n                JavascriptArray::ArraySegmentSpliceHelper(pnewArr, (SparseArraySegment<T>*)startSeg, (SparseArraySegment<T>**)prevSeg, start, deleteLen, insertArgs, insertLen, recycler);\n                while (nextSeg)\n                {\n                    // adjust next segments left\n                    nextSeg->left = nextSeg->left - deleteLen + insertLen;\n                    if (nextSeg->next == nullptr)\n                    {\n                        nextSeg->EnsureSizeInBound();\n                    }\n                    nextSeg = nextSeg->next;\n                }\n                if (*prevSeg)\n                {\n                    (*prevSeg)->EnsureSizeInBound();\n                }\n                return;\n            }\n            else\n            {\n                SparseArraySegment<T>* newHeadSeg = nullptr; // pnewArr->head is null\n                SparseArraySegmentBase** prevNewHeadSeg = &(pnewArr->head);\n\n                // delete till deleteLen and reuse segments for new array if it is possible.\n                // 3 steps -\n                //1. delete 1st segment (which may be partial delete)\n                // 2. delete next n complete segments\n                // 3. delete last segment (which again may be partial delete)\n\n                // Step (1)  -- WOOB 1116297: When left >= start, step (1) is skipped, resulting in pNewArr->head->left != 0. We need to touch up pNewArr.\n                if (startSeg->left < start)\n                {\n                    if (start < startSeg->left + startSeg->length)\n                    {\n                        uint32 headDeleteLen = startSeg->left + startSeg->length - start;\n\n                        if (startSeg->next)\n                        {\n                            // We know the new segment will have a next segment, so allocate it as non-leaf.\n                            newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        else\n                        {\n                            newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);\n                        newHeadSeg->next = nullptr;\n                        *prevNewHeadSeg = newHeadSeg;\n                        prevNewHeadSeg = &newHeadSeg->next;\n                        startSeg->Truncate(start);\n                    }\n                    savePrev = startSeg;\n                    prevPrevSeg = prevSeg;\n                    prevSeg = &startSeg->next;\n                    startSeg = (SparseArraySegment<T>*)startSeg->next;\n                }\n\n                // Step (2) first we should do a hard copy if we have an inline head Segment\n                else if (hasInlineSegment && nullptr != startSeg)\n                {\n                    // start should be in between left and left + length\n                    if (startSeg->left  <= start && start < startSeg->left + startSeg->length)\n                    {\n                        uint32 headDeleteLen = startSeg->left + startSeg->length - start;\n                        if (startSeg->next)\n                        {\n                            // We know the new segment will have a next segment, so allocate it as non-leaf.\n                            newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        else\n                        {\n                            newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);\n                        }\n                        newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);\n                        *prevNewHeadSeg = newHeadSeg;\n                        prevNewHeadSeg = &newHeadSeg->next;\n\n                        // Remove the entire segment from the original array\n                        *prevSeg = startSeg->next;\n                        startSeg = (SparseArraySegment<T>*)startSeg->next;\n                    }\n                    // if we have an inline head segment with 0 elements, remove it\n                    else if (startSeg->left == 0 && startSeg->length == 0)\n                    {\n                        Assert(startSeg->size != 0);\n                        *prevSeg = startSeg->next;\n                        startSeg = (SparseArraySegment<T>*)startSeg->next;\n                    }\n                }\n                // Step (2) proper\n                SparseArraySegmentBase *temp = nullptr;\n                while (startSeg && (startSeg->left + startSeg->length) <= limit)\n                {\n                    temp = startSeg->next;\n\n                    // move that entire segment to new array\n                    startSeg->left = startSeg->left - start;\n                    startSeg->next = nullptr;\n                    *prevNewHeadSeg = startSeg;\n                    prevNewHeadSeg = &startSeg->next;\n\n                    // Remove the entire segment from the original array\n                    *prevSeg = temp;\n                    startSeg = (SparseArraySegment<T>*)temp;\n                }\n\n                // Step(2) above could delete the original head segment entirely, causing current head not\n                // starting from 0. Then if any of the following throw, we have a corrupted array. Need\n                // protection here.\n                bool dummyHeadNodeInserted = false;\n                if (!savePrev && (!startSeg || startSeg->left != 0))\n                {\n                    Assert(pArr->head == startSeg);\n                    pArr->EnsureHeadStartsFromZero<T>(recycler);\n                    Assert(pArr->head && pArr->head->next == startSeg);\n\n                    savePrev = pArr->head;\n                    prevPrevSeg = prevSeg;\n                    prevSeg = &pArr->head->next;\n                    dummyHeadNodeInserted = true;\n                }\n\n                // Step (3)\n                if (startSeg && (startSeg->left < limit))\n                {\n                    // copy the first part of the last segment to be deleted to new array\n                    uint32 headDeleteLen = start + deleteLen - startSeg->left ;\n\n                    newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, startSeg->left -  start, headDeleteLen, (SparseArraySegmentBase *)nullptr);\n                    newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, startSeg->left -  start, startSeg, startSeg->left, headDeleteLen);\n                    newHeadSeg->next = nullptr;\n                    *prevNewHeadSeg = newHeadSeg;\n                    prevNewHeadSeg = &newHeadSeg->next;\n\n                    // move the last segment\n                    memmove(startSeg->elements, startSeg->elements + headDeleteLen, sizeof(T) * (startSeg->length - headDeleteLen));\n                    startSeg->left = startSeg->left + headDeleteLen; // We are moving the left ahead to point to the right index\n                    startSeg->length = startSeg->length - headDeleteLen;\n                    startSeg->Truncate(startSeg->left + startSeg->length);\n                    startSeg->EnsureSizeInBound(); // Just truncated, size might exceed next.left\n                }\n\n                if (startSeg && ((startSeg->left - deleteLen + insertLen) == 0) && dummyHeadNodeInserted)\n                {\n                    Assert(start + insertLen == 0);\n                    // Remove the dummy head node to preserve array consistency.\n                    pArr->head = startSeg;\n                    savePrev = nullptr;\n                    prevSeg = &pArr->head;\n                }\n\n                while (startSeg)\n                {\n                    startSeg->left = startSeg->left - deleteLen + insertLen ;\n                    if (startSeg->next == nullptr)\n                    {\n                        startSeg->EnsureSizeInBound();\n                    }\n                    startSeg = (SparseArraySegment<T>*)startSeg->next;\n                }\n            }\n        }\n\n        // The size of pnewArr head allocated in above step 1 might exceed next.left concatenated in step 2/3.\n        pnewArr->head->EnsureSizeInBound();\n        if (savePrev)\n        {\n            savePrev->EnsureSizeInBound();\n        }\n\n        // insert elements\n        if (insertLen > 0)\n        {\n            Assert(!JavascriptNativeIntArray::Is(pArr) && !JavascriptNativeFloatArray::Is(pArr));\n\n            // InsertPhase\n            SparseArraySegment<T> *segInsert = nullptr;\n\n            // see if we are just about the right of the previous segment\n            Assert(!savePrev || savePrev->left <= start);\n            if (savePrev && (start - savePrev->left < savePrev->size))\n            {\n                segInsert = (SparseArraySegment<T>*)savePrev;\n                uint32 spaceLeft = segInsert->size - (start - segInsert->left);\n                if(spaceLeft < insertLen)\n                {\n                    if (!segInsert->next)\n                    {\n                        segInsert = segInsert->GrowByMin(recycler, insertLen - spaceLeft);\n                    }\n                    else\n                    {\n                        segInsert = segInsert->GrowByMinMax(recycler, insertLen - spaceLeft, segInsert->next->left - segInsert->left - segInsert->size);\n                    }\n                }\n                *prevPrevSeg = segInsert;\n                segInsert->length = start + insertLen - segInsert->left;\n            }\n            else\n            {\n                segInsert = SparseArraySegment<T>::AllocateSegment(recycler, start, insertLen, *prevSeg);\n                segInsert->next = *prevSeg;\n                *prevSeg = segInsert;\n                savePrev = segInsert;\n            }\n\n            uint32 relativeStart = start - segInsert->left;\n            // inserted elements starts at argument 3 of splice(start, deleteNumber, insertelem1, insertelem2, insertelem3, ...);\n            js_memcpy_s(segInsert->elements + relativeStart, sizeof(T) * insertLen, insertArgs, sizeof(T) * insertLen);\n        }\n    }\n\n    template<typename indexT>\n    RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, uint32 len, uint32 start,\n        uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext, RecyclableObject* pNewObj)\n    {\n        JavascriptArray *pnewArr = nullptr;\n\n        if (pNewObj == nullptr)\n        {\n            pNewObj = ArraySpeciesCreate(pObj, deleteLen, scriptContext);\n            if (pNewObj == nullptr || !JavascriptArray::Is(pNewObj))\n            {\n                pnewArr = scriptContext->GetLibrary()->CreateArray(deleteLen);\n                pnewArr->EnsureHead<Var>();\n\n                pNewObj = pnewArr;\n            }\n        }\n\n        if (JavascriptArray::Is(pNewObj))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pNewObj);\n#endif\n            pnewArr = JavascriptArray::FromVar(pNewObj);\n        }\n\n        // copy elements to delete to new array\n        if (deleteLen > 0)\n        {\n            for (uint32 i = 0; i < deleteLen; i++)\n            {\n               if (JavascriptOperators::HasItem(pObj, start+i))\n               {\n                   Var element = JavascriptOperators::GetItem(pObj, start + i, scriptContext);\n                   if (pnewArr)\n                   {\n                       pnewArr->SetItem(i, element, PropertyOperation_None);\n                   }\n                   else\n                   {\n                       ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(pNewObj, i, element), scriptContext, i);\n                   }\n               }\n            }\n        }\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.splice\"));\n\n        // If the return object is not an array, we'll need to set the 'length' property\n        if (pnewArr == nullptr)\n        {\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, JavascriptNumber::ToVar(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n\n        // Now we need reserve room if it is necessary\n        if (insertLen > deleteLen) // Might overflow max array length\n        {\n            // Unshift [start + deleteLen, len) to start + insertLen\n            Unshift<indexT>(pObj, start + insertLen, start + deleteLen, len, scriptContext);\n        }\n        else if (insertLen < deleteLen) // Won't overflow max array length\n        {\n            uint32 j = 0;\n            for (uint32 i = start + deleteLen; i < len; i++)\n            {\n                if (JavascriptOperators::HasItem(pObj, i))\n                {\n                    Var element = JavascriptOperators::GetItem(pObj, i, scriptContext);\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, start + insertLen + j, element, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, start + insertLen + j, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n                j++;\n            }\n\n            // Clean up the rest\n            for (uint32 i = len; i > len - deleteLen + insertLen; i--)\n            {\n                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, i - 1, PropertyOperation_ThrowOnDeleteIfNotConfig));\n            }\n        }\n\n        if (insertLen > 0)\n        {\n            indexT dstIndex = start; // insert index might overflow max array length\n            for (uint i = 0; i < insertLen; i++)\n            {\n                h.ThrowTypeErrorOnFailure(IndexTrace<indexT>::SetItem(pObj, dstIndex, insertArgs[i], PropertyOperation_ThrowIfNotExtensible));\n                ++dstIndex;\n            }\n        }\n\n        // Set up new length\n        indexT newLen = indexT(len - deleteLen) + insertLen;\n        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pObj, pObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));\n#ifdef VALIDATE_ARRAY\n        if (pnewArr)\n        {\n            pnewArr->ValidateArray();\n        }\n#endif\n        return pNewObj;\n    }\n\n    Var JavascriptArray::EntryToLocaleString(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedObject, _u(\"Array.prototype.toLocaleString\"));\n        }\n\n        if (JavascriptArray::IsDirectAccessArray(args[0]))\n        {\n            JavascriptArray* arr = JavascriptArray::FromVar(args[0]);\n            return ToLocaleString(arr, scriptContext);\n        }\n        else\n        {\n            if (TypedArrayBase::IsDetachedTypedArray(args[0]))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.toLocalString\"));\n            }\n\n            RecyclableObject* obj = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toLocaleString\"));\n            }\n            return ToLocaleString(obj, scriptContext);\n        }\n    }\n\n    //\n    // Unshift object elements [start, end) to toIndex, asserting toIndex > start.\n    //\n    template<typename T, typename P>\n    void JavascriptArray::Unshift(RecyclableObject* obj, const T& toIndex, uint32 start, P end, ScriptContext* scriptContext)\n    {\n        typedef IndexTrace<T> index_trace;\n\n        ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));\n        if (start < end)\n        {\n            T newEnd = (end - start - 1);// newEnd - 1\n            T dst = toIndex + newEnd;\n            uint32 i = 0;\n            if (end > UINT32_MAX)\n            {\n                uint64 i64 = end;\n                for (; i64 > UINT32_MAX; i64--)\n                {\n                    if (JavascriptOperators::HasItem(obj, i64 - 1))\n                    {\n                        Var element = JavascriptOperators::GetItem(obj, i64 - 1, scriptContext);\n                        h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible));\n                    }\n                    else\n                    {\n                        h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                    }\n\n                    --dst;\n                }\n                i = UINT32_MAX;\n            }\n            else\n            {\n                i = (uint32) end;\n            }\n            for (; i > start; i--)\n            {\n                if (JavascriptOperators::HasItem(obj, i-1))\n                {\n                    Var element = JavascriptOperators::GetItem(obj, i - 1, scriptContext);\n                    h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible));\n                }\n                else\n                {\n                    h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig));\n                }\n\n                --dst;\n            }\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::GrowArrayHeadHelperForUnshift(JavascriptArray* pArr, uint32 unshiftElements, ScriptContext * scriptContext)\n    {\n        SparseArraySegmentBase* nextToHeadSeg = pArr->head->next;\n        Recycler* recycler = scriptContext->GetRecycler();\n\n        if (nextToHeadSeg == nullptr)\n        {\n            pArr->EnsureHead<T>();\n            pArr->head = ((SparseArraySegment<T>*)pArr->head)->GrowByMin(recycler, unshiftElements);\n        }\n        else\n        {\n            pArr->head = ((SparseArraySegment<T>*)pArr->head)->GrowByMinMax(recycler, unshiftElements, ((nextToHeadSeg->left + unshiftElements) - pArr->head->left - pArr->head->size));\n        }\n\n    }\n\n    template<typename T>\n    void JavascriptArray::UnshiftHelper(JavascriptArray* pArr, uint32 unshiftElements, Js::Var * elements)\n    {\n        SparseArraySegment<T>* head = (SparseArraySegment<T>*)pArr->head;\n        // Make enough room in the head segment to insert new elements at the front\n        memmove(head->elements + unshiftElements, head->elements, sizeof(T) * pArr->head->length);\n        uint32 oldHeadLength = head->length;\n        head->length += unshiftElements;\n\n        /* Set head segment as the last used segment */\n        pArr->InvalidateLastUsedSegment();\n\n        bool hasNoMissingValues = pArr->HasNoMissingValues();\n\n        /* Set HasNoMissingValues to false -> Since we shifted elements right, we might have missing values after the memmove */\n        if(unshiftElements > oldHeadLength)\n        {\n            pArr->SetHasNoMissingValues(false);\n        }\n\n#if ENABLE_PROFILE_INFO\n        pArr->FillFromArgs(unshiftElements, 0, elements, nullptr, true/*dontCreateNewArray*/);\n#else\n        pArr->FillFromArgs(unshiftElements, 0, elements, true/*dontCreateNewArray*/);\n#endif\n\n        // Setting back to the old value\n        pArr->SetHasNoMissingValues(hasNoMissingValues);\n    }\n\n    Var JavascriptArray::EntryUnshift(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        Var res = scriptContext->GetLibrary()->GetUndefined();\n\n        if (args.Info.Count == 0)\n        {\n           return res;\n        }\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);\n\n            uint32 unshiftElements = args.Info.Count - 1;\n\n            if (unshiftElements > 0)\n            {\n                if (pArr->IsFillFromPrototypes())\n                {\n                    pArr->FillFromPrototypes(0, pArr->length); // We need find all missing value from [[proto]] object\n                }\n\n                // Pre-process: truncate overflowing elements to properties\n                bool newLenOverflowed = false;\n                uint32 maxLen = MaxArrayLength - unshiftElements;\n                if (pArr->length > maxLen)\n                {\n                    newLenOverflowed = true;\n                    // Ensure the array is non-native when overflow happens\n                    EnsureNonNativeArray(pArr);\n                    pArr->TruncateToProperties(MaxArrayLength, maxLen);\n                    Assert(pArr->length + unshiftElements == MaxArrayLength);\n                }\n\n                pArr->ClearSegmentMap(); // Dump segmentMap on unshift (before any possible allocation and throw)\n\n                Assert(pArr->length <= MaxArrayLength - unshiftElements);\n\n                SparseArraySegmentBase* renumberSeg = pArr->head->next;\n\n                bool isIntArray = false;\n                bool isFloatArray = false;\n\n                if (JavascriptNativeIntArray::Is(pArr))\n                {\n                    isIntArray = true;\n                }\n                else if (JavascriptNativeFloatArray::Is(pArr))\n                {\n                    isFloatArray = true;\n                }\n\n                // If we need to grow head segment and there is already a next segment, then allocate the new head segment upfront\n                // If there is OOM in array allocation, then array consistency is maintained.\n                if (pArr->head->size < pArr->head->length + unshiftElements)\n                {\n                    if (isIntArray)\n                    {\n                        GrowArrayHeadHelperForUnshift<int32>(pArr, unshiftElements, scriptContext);\n                    }\n                    else if (isFloatArray)\n                    {\n                        GrowArrayHeadHelperForUnshift<double>(pArr, unshiftElements, scriptContext);\n                    }\n                    else\n                    {\n                        GrowArrayHeadHelperForUnshift<Var>(pArr, unshiftElements, scriptContext);\n                    }\n                }\n\n                while (renumberSeg)\n                {\n                    renumberSeg->left += unshiftElements;\n                    if (renumberSeg->next == nullptr)\n                    {\n                        // last segment can shift its left + size beyond MaxArrayLength, so truncate if so\n                        renumberSeg->EnsureSizeInBound();\n                    }\n                    renumberSeg = renumberSeg->next;\n                }\n\n                if (isIntArray)\n                {\n                    UnshiftHelper<int32>(pArr, unshiftElements, args.Values);\n                }\n                else if (isFloatArray)\n                {\n                    UnshiftHelper<double>(pArr, unshiftElements, args.Values);\n                }\n                else\n                {\n                    UnshiftHelper<Var>(pArr, unshiftElements, args.Values);\n                }\n\n                pArr->InvalidateLastUsedSegment();\n                pArr->length += unshiftElements;\n\n#ifdef VALIDATE_ARRAY\n                pArr->ValidateArray();\n#endif\n\n                if (newLenOverflowed) // ES5: throw if new \"length\" exceeds max array length\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);\n                }\n            }\n            res = JavascriptNumber::ToVar(pArr->length, scriptContext);\n        }\n        else\n        {\n            RecyclableObject* dynamicObject = nullptr;\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));\n            }\n\n            BigIndex length;\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n            }\n            uint32 unshiftElements = args.Info.Count - 1;\n            if (unshiftElements > 0)\n            {\n                uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;\n                // Note: end will always be a smallIndex either it is less than length in which case it is MaxSpaceUint32\n                // or MaxSpaceUint32 is greater than length meaning length is a uint32 number\n                BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;\n                if (end < length)\n                {\n                    // Unshift [end, length) to MaxArrayLength\n                    // MaxArrayLength + (length - MaxSpaceUint32 - 1) = length + unshiftElements -1\n                    if (length.IsSmallIndex())\n                    {\n                        Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext);\n                    }\n                    else\n                    {\n                        Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetBigIndex(), scriptContext);\n                    }\n                }\n\n                // Unshift [0, end) to unshiftElements\n                // unshiftElements + (MaxSpaceUint32 - 0 - 1) = MaxArrayLength -1 therefore this unshift covers up to MaxArrayLength - 1\n                Unshift<uint32>(dynamicObject, unshiftElements, 0, end.GetSmallIndex(), scriptContext);\n\n                for (uint32 i = 0; i < unshiftElements; i++)\n                {\n                    JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true);\n                }\n            }\n\n            ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));\n\n            //ES6 - update 'length' even if unshiftElements == 0;\n            BigIndex newLen = length + unshiftElements;\n            res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);\n            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));\n        }\n        return res;\n\n    }\n\n    Var JavascriptArray::EntryToString(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedObject);\n        }\n\n         // ES5 15.4.4.2: call join, or built-in Object.prototype.toString\n\n        RecyclableObject* obj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toString\"));\n        }\n\n        // In ES5 we could be calling a user defined join, even on array. We must [[Get]] join at runtime.\n        Var join = JavascriptOperators::GetProperty(obj, PropertyIds::join, scriptContext);\n        if (JavascriptConversion::IsCallable(join))\n        {\n            RecyclableObject* func = RecyclableObject::FromVar(join);\n            // We need to record implicit call here, because marked the Array.toString as no side effect,\n            // but if we call user code here which may have side effect\n            ThreadContext * threadContext = scriptContext->GetThreadContext();\n            Var result = threadContext->ExecuteImplicitCall(func, ImplicitCall_ToPrimitive, [=]() -> Js::Var\n            {\n                // Stack object should have a pre-op bail on implicit call. We shouldn't see them here.\n                Assert(!ThreadContext::IsOnStack(obj));\n\n                // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n                CallFlags flags = CallFlags_Value;\n                return CALL_FUNCTION(func, CallInfo(flags, 1), obj);\n            });\n\n            if(!result)\n            {\n                // There was an implicit call and implicit calls are disabled. This would typically cause a bailout.\n                Assert(threadContext->IsDisableImplicitCall());\n                result = scriptContext->GetLibrary()->GetNull();\n            }\n\n            return result;\n        }\n        else\n        {\n            // call built-in Object.prototype.toString\n            return CALL_ENTRYPOINT(JavascriptObject::EntryToString, function, CallInfo(1), obj);\n        }\n    }\n\n#if DEBUG\n    BOOL JavascriptArray::GetIndex(const char16* propName, uint32 *pIndex)\n    {\n        uint32 lu, luDig;\n\n        int32 cch = (int32)wcslen(propName);\n        char16* pch = const_cast<char16 *>(propName);\n\n        lu = *pch - '0';\n        if (lu > 9)\n            return FALSE;\n\n        if (0 == lu)\n        {\n            *pIndex = 0;\n            return 1 == cch;\n        }\n\n        while ((luDig = *++pch - '0') < 10)\n        {\n            // If we overflow 32 bits, ignore the item\n            if (lu > 0x19999999)\n                return FALSE;\n            lu *= 10;\n            if(lu > (ULONG_MAX - luDig))\n                return FALSE;\n            lu += luDig;\n        }\n\n        if (pch - propName != cch)\n            return FALSE;\n\n        if (lu == JavascriptArray::InvalidIndex)\n        {\n            // 0xFFFFFFFF is not treated as an array index so that the length can be\n            // capped at 32 bits.\n            return FALSE;\n        }\n\n        *pIndex = lu;\n        return TRUE;\n    }\n#endif\n\n    JavascriptString* JavascriptArray::GetLocaleSeparator(ScriptContext* scriptContext)\n    {\n#ifdef ENABLE_GLOBALIZATION\n        LCID lcid = GetUserDefaultLCID();\n        int count = 0;\n        char16 szSeparator[6];\n\n        // According to the document for GetLocaleInfo this is a sufficient buffer size.\n        count = GetLocaleInfoW(lcid, LOCALE_SLIST, szSeparator, 5);\n        if( !count)\n        {\n            AssertMsg(FALSE, \"GetLocaleInfo failed\");\n            return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();\n        }\n        else\n        {\n            // Append ' '  if necessary\n            if( count < 2 || szSeparator[count-2] != ' ')\n            {\n                szSeparator[count-1] = ' ';\n                szSeparator[count] = '\\0';\n            }\n\n            return JavascriptString::NewCopyBuffer(szSeparator, count, scriptContext);\n        }\n#else\n        // xplat-todo: Support locale-specific seperator\n        return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();\n#endif\n    }\n\n    template <typename T>\n    JavascriptString* JavascriptArray::ToLocaleString(T* arr, ScriptContext* scriptContext)\n    {\n        uint32 length = 0;\n        if (TypedArrayBase::Is(arr))\n        {\n            // For a TypedArray use the actual length of the array.\n            length = TypedArrayBase::FromVar(arr)->GetLength();\n        }\n        else\n        {\n            //For anything else, use the \"length\" property if present.\n            length = ItemTrace<T>::GetLength(arr, scriptContext);\n        }\n\n        if (length == 0 || scriptContext->CheckObject(arr))\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        JavascriptString* res = scriptContext->GetLibrary()->GetEmptyString();\n        bool pushedObject = false;\n\n        TryFinally([&]()\n        {\n            scriptContext->PushObject(arr);\n            pushedObject = true;\n\n            Var element;\n            if (ItemTrace<T>::GetItem(arr, 0, &element, scriptContext))\n            {\n                res = JavascriptArray::ToLocaleStringHelper(element, scriptContext);\n            }\n\n            if (length > 1)\n            {\n                JavascriptString* separator = GetLocaleSeparator(scriptContext);\n\n                for (uint32 i = 1; i < length; i++)\n                {\n                    res = JavascriptString::Concat(res, separator);\n                    if (ItemTrace<T>::GetItem(arr, i, &element, scriptContext))\n                    {\n                        res = JavascriptString::Concat(res, JavascriptArray::ToLocaleStringHelper(element, scriptContext));\n                    }\n                }\n            }\n        },\n        [&](bool/*hasException*/)\n        {\n            if (pushedObject)\n            {\n                Var top = scriptContext->PopObject();\n                AssertMsg(top == arr, \"Unmatched operation stack\");\n            }\n        });\n\n        if (res == nullptr)\n        {\n            res = scriptContext->GetLibrary()->GetEmptyString();\n        }\n\n        return res;\n    }\n\n    Var JavascriptArray::EntryIsArray(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Constructor_isArray);\n\n        if (args.Info.Count < 2)\n        {\n            return scriptContext->GetLibrary()->GetFalse();\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[1]);\n#endif\n        if (JavascriptOperators::IsArray(args[1]))\n        {\n            return scriptContext->GetLibrary()->GetTrue();\n        }\n        return scriptContext->GetLibrary()->GetFalse();\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Find() calls the given predicate callback on each element of the array, in\n    /// order, and returns the first element that makes the predicate return true,\n    /// as described in (ES6.0: S22.1.3.8).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryFind(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));\n        }\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));\n            }\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n\n        return JavascriptArray::FindHelper<false>(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    template <bool findIndex>\n    Var JavascriptArray::FindHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // typedArrayBase is only non-null if and only if we came here via the TypedArray entrypoint\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"[TypedArray].prototype.findIndex\") : _u(\"[TypedArray].prototype.find\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"Array.prototype.findIndex\") : _u(\"Array.prototype.find\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.find/findIndex and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var element = nullptr;\n        Var testResult = nullptr;\n\n        if (pArr)\n        {\n            Var undefined = scriptContext->GetLibrary()->GetUndefined();\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = undefined;\n                pArr->DirectGetItemAtFull(k, &element);\n\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = typedArrayBase->DirectGetItem(k);\n\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    typedArrayBase);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                Var index = JavascriptNumber::ToVar(k, scriptContext);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    index,\n                    obj);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return findIndex ? index : element;\n                }\n            }\n        }\n\n        return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();\n    }\n\n    ///----------------------------------------------------------------------------\n    /// FindIndex() calls the given predicate callback on each element of the\n    /// array, in order, and returns the index of the first element that makes the\n    /// predicate return true, as described in (ES6.0: S22.1.3.9).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryFindIndex(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));\n        }\n\n        int64 length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));\n            }\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::FindHelper<true>(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Entries() returns a new ArrayIterator object configured to return key-\n    /// value pairs matching the elements of the this array/array-like object,\n    /// as described in (ES6.0: S22.1.3.4).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryEntries(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::KeyAndValue);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Keys() returns a new ArrayIterator object configured to return the keys\n    /// of the this array/array-like object, as described in (ES6.0: S22.1.3.13).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryKeys(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Key);\n    }\n\n    ///----------------------------------------------------------------------------\n    /// Values() returns a new ArrayIterator object configured to return the values\n    /// of the this array/array-like object, as described in (ES6.0: S22.1.3.29).\n    ///----------------------------------------------------------------------------\n    Var JavascriptArray::EntryValues(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));\n        }\n\n        RecyclableObject* thisObj = nullptr;\n        if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));\n        }\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);\n#endif\n        return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Value);\n    }\n\n    Var JavascriptArray::EntryEvery(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.every\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_every);\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.every as described by ES6.0 (draft 22) Section 22.1.3.5\n    template <typename T>\n    Var JavascriptArray::EveryHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // typedArrayBase is only non-null if and only if we came here via the TypedArray entrypoint\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.every\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.every\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        Var element = nullptr;\n        Var testResult = nullptr;\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        if (pArr)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetFalse();\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!typedArrayBase->HasItem(k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n\n                if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetFalse();\n                }\n            }\n        }\n        else\n        {\n            for (T k = 0; k < length; k++)\n            {\n                // According to es6 spec, we need to call Has first before calling Get\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n\n                    testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (!JavascriptConversion::ToBoolean(testResult, scriptContext))\n                    {\n                        return scriptContext->GetLibrary()->GetFalse();\n                    }\n                }\n            }\n        }\n\n        return scriptContext->GetLibrary()->GetTrue();\n    }\n\n    Var JavascriptArray::EntrySome(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.some\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_some);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n            if (length.IsSmallIndex())\n        {\n            return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.some as described in ES6.0 (draft 22) Section 22.1.3.23\n    template <typename T>\n    Var JavascriptArray::SomeHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            // We are in the TypedArray version of this API if and only if typedArrayBase != nullptr\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.some\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.some\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.some and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var element = nullptr;\n        Var testResult = nullptr;\n\n        if (pArr)\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetTrue();\n                }\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                // If k < typedArrayBase->length, we know that HasItem will return true.\n                // But we still have to call it in case there's a proxy trap or in the case that we are calling\n                // Array.prototype.some with a TypedArray that has a different length instance property.\n                if (!typedArrayBase->HasItem(k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n\n                testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n\n                if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                {\n                    return scriptContext->GetLibrary()->GetTrue();\n                }\n            }\n        }\n        else\n        {\n            for (T k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    testResult = CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (JavascriptConversion::ToBoolean(testResult, scriptContext))\n                    {\n                        return scriptContext->GetLibrary()->GetTrue();\n                    }\n                }\n            }\n        }\n\n        return scriptContext->GetLibrary()->GetFalse();\n    }\n\n    Var JavascriptArray::EntryForEach(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.forEach\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_forEach)\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* dynamicObject = nullptr;\n        RecyclableObject* callBackFn = nullptr;\n        Var thisArg = nullptr;\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            dynamicObject = pArr;\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));\n            }\n\n            if (JavascriptArray::Is(dynamicObject) && scriptContext == JavascriptArray::FromVar(dynamicObject)->GetScriptContext())\n            {\n                pArr = JavascriptArray::FromVar(dynamicObject);\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.forEach\"));\n        }\n        callBackFn = RecyclableObject::FromVar(args[1]);\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        auto fn32 = [dynamicObject, callBackFn, flags, thisArg, scriptContext](uint32 k, Var element)\n        {\n            CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                element,\n                JavascriptNumber::ToVar(k, scriptContext),\n                dynamicObject);\n        };\n\n        auto fn64 = [dynamicObject, callBackFn, flags, thisArg, scriptContext](uint64 k, Var element)\n        {\n            CALL_FUNCTION(callBackFn, CallInfo(flags, 4), thisArg,\n                element,\n                JavascriptNumber::ToVar(k, scriptContext),\n                dynamicObject);\n        };\n\n        if (pArr)\n        {\n            Assert(pArr == dynamicObject);\n            pArr->ForEachItemInRange<true>(0, length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex(), scriptContext, fn32);\n        }\n        else\n        {\n            if (length.IsSmallIndex())\n            {\n                TemplatedForEachItemInRange<true>(dynamicObject, 0u, length.GetSmallIndex(), scriptContext, fn32);\n            }\n            else\n            {\n                TemplatedForEachItemInRange<true>(dynamicObject, 0ui64, length.GetBigIndex(), scriptContext, fn64);\n            }\n        }\n        return scriptContext->GetLibrary()->GetUndefined();\n    }\n\n    Var JavascriptArray::EntryCopyWithin(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        int64 length;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);\n#endif\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.copyWithin\"));\n            }\n\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::CopyWithinHelper(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    // Array.prototype.copyWithin as defined in ES6.0 (draft 22) Section 22.1.3.3\n    Var JavascriptArray::CopyWithinHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        int64 fromVal = 0;\n        int64 toVal = 0;\n        int64 finalVal = length;\n\n        // If we came from Array.prototype.copyWithin and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        if (args.Info.Count > 1)\n        {\n            toVal = JavascriptArray::GetIndexFromVar(args[1], length, scriptContext);\n\n            if (args.Info.Count > 2)\n            {\n                fromVal = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext);\n\n                if (args.Info.Count > 3 && args[3] != library->GetUndefined())\n                {\n                    finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext);\n                }\n            }\n        }\n\n        // If count would be negative or zero, we won't do anything so go ahead and return early.\n        if (finalVal <= fromVal || length <= toVal)\n        {\n            return obj;\n        }\n\n        // Make sure we won't underflow during the count calculation\n        Assert(finalVal > fromVal && length > toVal);\n\n        int64 count = min(finalVal - fromVal, length - toVal);\n\n        // We shouldn't have made it here if the count was going to be zero\n        Assert(count > 0);\n\n        int direction;\n\n        if (fromVal < toVal && toVal < (fromVal + count))\n        {\n            direction = -1;\n            fromVal += count - 1;\n            toVal += count - 1;\n        }\n        else\n        {\n            direction = 1;\n        }\n\n        // If we are going to copy elements from or to indices > 2^32-1 we'll execute this (slightly slower path)\n        // It's possible to optimize here so that we use the normal code below except for the > 2^32-1 indices\n        if ((direction == -1 && (fromVal >= MaxArrayLength || toVal >= MaxArrayLength))\n            || (((fromVal + count) > MaxArrayLength) || ((toVal + count) > MaxArrayLength)))\n        {\n            while (count > 0)\n            {\n                Var index = JavascriptNumber::ToVar(fromVal, scriptContext);\n\n                if (JavascriptOperators::OP_HasItem(obj, index, scriptContext))\n                {\n                    Var val = JavascriptOperators::OP_GetElementI(obj, index, scriptContext);\n\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), val, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                }\n                else\n                {\n                    JavascriptOperators::OP_DeleteElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), scriptContext, PropertyOperation_ThrowOnDeleteIfNotConfig);\n                }\n\n                fromVal += direction;\n                toVal += direction;\n                count--;\n            }\n        }\n        else\n        {\n            Assert(fromVal < MaxArrayLength);\n            Assert(toVal < MaxArrayLength);\n            Assert(direction == -1 || (fromVal + count < MaxArrayLength && toVal + count < MaxArrayLength));\n\n            uint32 fromIndex = static_cast<uint32>(fromVal);\n            uint32 toIndex = static_cast<uint32>(toVal);\n\n            while (count > 0)\n            {\n                if (obj->HasItem(fromIndex))\n                {\n                    if (typedArrayBase)\n                    {\n                        Var val = typedArrayBase->DirectGetItem(fromIndex);\n\n                        typedArrayBase->DirectSetItem(toIndex, val);\n                    }\n                    else if (pArr)\n                    {\n                        Var val = pArr->DirectGetItem(fromIndex);\n\n                        pArr->SetItem(toIndex, val, Js::PropertyOperation_ThrowIfNotExtensible);\n                    }\n                    else\n                    {\n                        Var val = JavascriptOperators::OP_GetElementI_UInt32(obj, fromIndex, scriptContext);\n\n                        JavascriptOperators::OP_SetElementI_UInt32(obj, toIndex, val, scriptContext, PropertyOperation_ThrowIfNotExtensible);\n                    }\n                }\n                else\n                {\n                    obj->DeleteItem(toIndex, PropertyOperation_ThrowOnDeleteIfNotConfig);\n                }\n\n                fromIndex += direction;\n                toIndex += direction;\n                count--;\n            }\n        }\n\n        return obj;\n    }\n\n    Var JavascriptArray::EntryFill(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        RecyclableObject* obj = nullptr;\n        JavascriptArray* pArr = nullptr;\n        int64 length;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.fill\"));\n            }\n\n            // In ES6-mode, we always load the length property from the object instead of using the internal slot.\n            // Even for arrays, this is now observable via proxies.\n            // If source object is not an array, we fall back to this behavior anyway.\n            Var lenValue = JavascriptOperators::OP_GetLength(obj, scriptContext);\n            length = JavascriptConversion::ToLength(lenValue, scriptContext);\n        }\n\n        return JavascriptArray::FillHelper(pArr, nullptr, obj, length, args, scriptContext);\n    }\n\n    // Array.prototype.fill as defined in ES6.0 (draft 22) Section 22.1.3.6\n    Var JavascriptArray::FillHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n\n        // If we came from Array.prototype.fill and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        Var fillValue;\n\n        if (args.Info.Count > 1)\n        {\n            fillValue = args[1];\n        }\n        else\n        {\n            fillValue = library->GetUndefined();\n        }\n\n        int64 k = 0;\n        int64 finalVal = length;\n\n        if (args.Info.Count > 2)\n        {\n            k = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext);\n\n            if (args.Info.Count > 3 && !JavascriptOperators::IsUndefinedObject(args[3]))\n            {\n                finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext);\n            }\n        }\n\n        if (k < MaxArrayLength)\n        {\n            int64 end = min<int64>(finalVal, MaxArrayLength);\n            uint32 u32k = static_cast<uint32>(k);\n\n            while (u32k < end)\n            {\n                if (typedArrayBase)\n                {\n                    typedArrayBase->DirectSetItem(u32k, fillValue);\n                }\n                else if (pArr)\n                {\n                    pArr->SetItem(u32k, fillValue, PropertyOperation_ThrowIfNotExtensible);\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI_UInt32(obj, u32k, fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n\n                u32k++;\n            }\n\n            BigIndex dstIndex = MaxArrayLength;\n\n            for (int64 i = end; i < finalVal; ++i)\n            {\n                if (pArr)\n                {\n                    pArr->DirectSetItemAt(dstIndex, fillValue);\n                    ++dstIndex;\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n        else\n        {\n            BigIndex dstIndex = static_cast<uint64>(k);\n\n            for (int64 i = k; i < finalVal; i++)\n            {\n                if (pArr)\n                {\n                    pArr->DirectSetItemAt(dstIndex, fillValue);\n                    ++dstIndex;\n                }\n                else\n                {\n                    JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible);\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    // Array.prototype.map as defined by ES6.0 (Final) 22.1.3.15\n    Var JavascriptArray::EntryMap(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.map\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_map);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));\n            }\n        }\n\n        length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max\n        return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n\n    template<typename T>\n    Var JavascriptArray::MapHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        RecyclableObject* newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;\n        bool isBuiltinArrayCtor = true;\n\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (isTypedArrayEntryPoint)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.map\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.map\"));\n            }\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray\n        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        // If the entry point is %TypedArray%.prototype.map or the source object is an Array exotic object we should try to load the constructor property\n        // and use it to construct the return object.\n        if (isTypedArrayEntryPoint)\n        {\n            Var constructor = JavascriptOperators::SpeciesConstructor(\n                typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext);\n            isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());\n\n            if (JavascriptOperators::IsConstructor(constructor))\n            {\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)length, scriptContext));\n            }\n            else if (isTypedArrayEntryPoint)\n            {\n                // We only need to throw a TypeError when the constructor property is not an actual constructor if %TypedArray%.prototype.map was called\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"[TypedArray].prototype.map\"));\n            }\n        }\n        // skip the typed array and \"pure\" array case, we still need to handle special arrays like es5array, remote array, and proxy of array.\n        else if (pArr == nullptr || scriptContext->GetConfig()->IsES6SpeciesEnabled())\n        {\n            newObj = ArraySpeciesCreate(obj, length, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        }\n\n        if (newObj == nullptr)\n        {\n            if (length > UINT_MAX)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n            newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        Var element = nullptr;\n        Var mappedValue = nullptr;\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags callBackFnflags = CallFlags_Value;\n        CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);\n\n        // We at least have to have newObj as a valid object\n        Assert(newObj);\n\n        if (pArr != nullptr)\n        {\n            // If source is a JavascriptArray, newObj may or may not be an array based on what was in source's constructor property\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                // If newArr is a valid pointer, then we constructed an array to return. Otherwise we need to do generic object operations\n                if (newArr && isBuiltinArrayCtor)\n                {\n                    newArr->DirectSetItemAt(k, mappedValue);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);\n                }\n            }\n        }\n        else if (typedArrayBase != nullptr)\n        {\n            // Source is a TypedArray, we may have tried to call a constructor, but newObj may not be a TypedArray (or an array either)\n            TypedArrayBase* newTypedArray = nullptr;\n\n            if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                // We can't rely on the length value being equal to typedArrayBase->GetLength() because user code may lie and\n                // attach any length property to a TypedArray instance and pass it as this parameter when .calling\n                // Array.prototype.map.\n                if (!typedArrayBase->HasItem(k))\n                {\n                    // We know that if HasItem returns false, all the future calls to HasItem will return false as well since\n                    // we visit the items in order. We could return early here except that we have to continue calling HasItem\n                    // on all the subsequent items according to the spec.\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem(k);\n                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    obj);\n\n                // If newObj is a TypedArray, set the mappedValue directly, otherwise see if it's an array and finally fall back to\n                // the normal Set path.\n                if (newTypedArray)\n                {\n                    newTypedArray->DirectSetItem(k, mappedValue);\n                }\n                else if (newArr)\n                {\n                    newArr->DirectSetItemAt(k, mappedValue);\n                }\n                else\n                {\n                    JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue);\n                }\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (newArr && isBuiltinArrayCtor)\n                    {\n                        newArr->SetItem(k, mappedValue, PropertyOperation_None);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);\n                    }\n                }\n            }\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (JavascriptArray::Is(newObj))\n        {\n            newArr->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryFilter(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.filter\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_filter);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));\n        }\n\n        BigIndex length;\n        JavascriptArray* pArr = nullptr;\n        RecyclableObject* dynamicObject = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            dynamicObject = pArr;\n        }\n        else\n        {\n            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(dynamicObject, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::FilterHelper(pArr, dynamicObject, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::FilterHelper(pArr, dynamicObject, length.GetBigIndex(), args, scriptContext);\n    }\n\n    template <typename T>\n    Var JavascriptArray::FilterHelper(JavascriptArray* pArr, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.filter\"));\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var thisArg = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            thisArg = args[2];\n        }\n        else\n        {\n            thisArg = scriptContext->GetLibrary()->GetUndefined();\n        }\n\n        // If the source object is an Array exotic object we should try to load the constructor property and use it to construct the return object.\n        bool isBuiltinArrayCtor = true;\n        RecyclableObject* newObj = ArraySpeciesCreate(obj, 0, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);\n        JavascriptArray* newArr = nullptr;\n\n        if (newObj == nullptr)\n        {\n            newArr = scriptContext->GetLibrary()->CreateArray(0);\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n        else\n        {\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n        }\n\n        Var element = nullptr;\n        Var selected = nullptr;\n\n        if (pArr)\n        {\n            Assert(length <= MaxArrayLength);\n            uint32 i = 0;\n\n            for (uint32 k = 0; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull(k, &element))\n                {\n                    continue;\n                }\n\n                selected = CALL_ENTRYPOINT(callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),\n                    thisArg,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n\n                if (JavascriptConversion::ToBoolean(selected, scriptContext))\n                {\n                    // Try to fast path if the return object is an array\n                    if (newArr && isBuiltinArrayCtor)\n                    {\n                        newArr->DirectSetItemAt(i, element);\n                    }\n                    else\n                    {\n                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                    }\n                    ++i;\n                }\n            }\n        }\n        else\n        {\n            BigIndex i = 0u;\n\n            for (T k = 0; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n                    selected = CALL_ENTRYPOINT(callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),\n                        thisArg,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n\n                    if (JavascriptConversion::ToBoolean(selected, scriptContext))\n                    {\n                        if (newArr)\n                        {\n                            newArr->DirectSetItemAt(i, element);\n                        }\n                        else\n                        {\n                            ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i);\n                        }\n                        ++i;\n                    }\n                }\n            }\n        }\n\n#ifdef VALIDATE_ARRAY\n        if (newArr)\n        {\n            newArr->ValidateArray();\n        }\n#endif\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryReduce(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduce\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduce);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));\n        }\n\n        BigIndex length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n\n            length = pArr->length;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));\n            }\n\n            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n            {\n                length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n            }\n            else\n            {\n                length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n            }\n        }\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.reduce as described in ES6.0 (draft 22) Section 22.1.3.18\n    template <typename T>\n    Var JavascriptArray::ReduceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduce\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduce\"));\n            }\n        }\n\n        // If we came from Array.prototype.reduce and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        T k = 0;\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var accumulator = nullptr;\n        Var element = nullptr;\n\n        if (args.Info.Count > 2)\n        {\n            accumulator = args[2];\n        }\n        else\n        {\n            if (length == 0)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n            bool bPresent = false;\n\n            if (pArr)\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (!pArr->DirectGetItemAtFull((uint32)k, &element))\n                    {\n                        continue;\n                    }\n\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else if (typedArrayBase)\n            {\n                Assert(length <= UINT_MAX);\n\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (!typedArrayBase->HasItem((uint32)k))\n                    {\n                        continue;\n                    }\n\n                    element = typedArrayBase->DirectGetItem((uint32)k);\n\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    if (JavascriptOperators::HasItem(obj, k))\n                    {\n                        accumulator = JavascriptOperators::GetItem(obj, k, scriptContext);\n                        bPresent = true;\n                    }\n                }\n            }\n\n            if (bPresent == false)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n        }\n\n        Assert(accumulator);\n\n        Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n\n        if (pArr)\n        {\n            for (; k < length; k++)\n            {\n                if (!pArr->DirectGetItemAtFull((uint32)k, &element))\n                {\n                    continue;\n                }\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    pArr);\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n            for (; k < length; k++)\n            {\n                if (!typedArrayBase->HasItem((uint32)k))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem((uint32)k);\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(k, scriptContext),\n                    typedArrayBase);\n            }\n        }\n        else\n        {\n            for (; k < length; k++)\n            {\n                if (JavascriptOperators::HasItem(obj, k))\n                {\n                    element = JavascriptOperators::GetItem(obj, k, scriptContext);\n\n                    accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                        accumulator,\n                        element,\n                        JavascriptNumber::ToVar(k, scriptContext),\n                        obj);\n                }\n            }\n        }\n\n        return accumulator;\n    }\n\n    Var JavascriptArray::EntryReduceRight(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduceRight\"));\n\n        CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduceRight);\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));\n        }\n\n        BigIndex length;\n        JavascriptArray * pArr = nullptr;\n        RecyclableObject* obj = nullptr;\n\n        if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())\n        {\n            pArr = JavascriptArray::FromVar(args[0]);\n            obj = pArr;\n        }\n        else\n        {\n            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));\n            }\n        }\n\n        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())\n        {\n            length = (uint64) JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n        else\n        {\n            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);\n        }\n\n        if (length.IsSmallIndex())\n        {\n            return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext);\n        }\n        return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext);\n    }\n\n    // Array.prototype.reduceRight as described in ES6.0 (draft 22) Section 22.1.3.19\n    template <typename T>\n    Var JavascriptArray::ReduceRightHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)\n    {\n        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))\n        {\n            if (typedArrayBase != nullptr)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduceRight\"));\n            }\n            else\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduceRight\"));\n            }\n        }\n\n        // If we came from Array.prototype.reduceRight and source object is not a JavascriptArray, source could be a TypedArray\n        if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))\n        {\n            typedArrayBase = TypedArrayBase::FromVar(obj);\n        }\n\n        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);\n        Var accumulator = nullptr;\n        Var element = nullptr;\n        T k = 0;\n        T index = 0;\n\n        if (args.Info.Count > 2)\n        {\n            accumulator = args[2];\n        }\n        else\n        {\n            if (length == 0)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n            bool bPresent = false;\n            if (pArr)\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (!pArr->DirectGetItemAtFull((uint32)index, &element))\n                    {\n                        continue;\n                    }\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else if (typedArrayBase)\n            {\n                Assert(length <= UINT_MAX);\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (!typedArrayBase->HasItem((uint32)index))\n                    {\n                        continue;\n                    }\n                    element = typedArrayBase->DirectGetItem((uint32)index);\n                    bPresent = true;\n                    accumulator = element;\n                }\n            }\n            else\n            {\n                for (; k < length && bPresent == false; k++)\n                {\n                    index = length - k - 1;\n                    if (JavascriptOperators::HasItem(obj, index))\n                    {\n                        accumulator = JavascriptOperators::GetItem(obj, index, scriptContext);\n                        bPresent = true;\n                    }\n                }\n            }\n            if (bPresent == false)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);\n            }\n\n        }\n\n        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes\n        CallFlags flags = CallFlags_Value;\n        Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();\n\n        if (pArr)\n        {\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (!pArr->DirectGetItemAtFull((uint32)index, &element))\n                {\n                    continue;\n                }\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(index, scriptContext),\n                    pArr);\n            }\n        }\n        else if (typedArrayBase)\n        {\n            Assert(length <= UINT_MAX);\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (!typedArrayBase->HasItem((uint32) index))\n                {\n                    continue;\n                }\n\n                element = typedArrayBase->DirectGetItem((uint32)index);\n\n                accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                    accumulator,\n                    element,\n                    JavascriptNumber::ToVar(index, scriptContext),\n                    typedArrayBase);\n            }\n        }\n        else\n        {\n            for (; k < length; k++)\n            {\n                index = length - k - 1;\n                if (JavascriptOperators::HasItem(obj, index))\n                {\n                    element = JavascriptOperators::GetItem(obj, index, scriptContext);\n                    accumulator = CALL_FUNCTION(callBackFn, CallInfo(flags, 5), undefinedValue,\n                        accumulator,\n                        element,\n                        JavascriptNumber::ToVar(index, scriptContext),\n                        obj);\n                }\n            }\n        }\n\n        return accumulator;\n    }\n\n    Var JavascriptArray::EntryFrom(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n        AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.from\"));\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        JavascriptLibrary* library = scriptContext->GetLibrary();\n        RecyclableObject* constructor = nullptr;\n\n        if (JavascriptOperators::IsConstructor(args[0]))\n        {\n            constructor = RecyclableObject::FromVar(args[0]);\n        }\n\n        RecyclableObject* items = nullptr;\n\n        if (args.Info.Count < 2 || !JavascriptConversion::ToObject(args[1], scriptContext, &items))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedObject, _u(\"Array.from\"));\n        }\n\n        JavascriptArray* itemsArr = nullptr;\n\n        if (JavascriptArray::Is(items))\n        {\n#if ENABLE_COPYONACCESS_ARRAY\n            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(items);\n#endif\n            itemsArr = JavascriptArray::FromVar(items);\n        }\n\n        bool mapping = false;\n        JavascriptFunction* mapFn = nullptr;\n        Var mapFnThisArg = nullptr;\n\n        if (args.Info.Count >= 3 && !JavascriptOperators::IsUndefinedObject(args[2]))\n        {\n            if (!JavascriptFunction::Is(args[2]))\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.from\"));\n            }\n\n            mapFn = JavascriptFunction::FromVar(args[2]);\n\n            if (args.Info.Count >= 4)\n            {\n                mapFnThisArg = args[3];\n            }\n            else\n            {\n                mapFnThisArg = library->GetUndefined();\n            }\n\n            mapping = true;\n        }\n\n        RecyclableObject* newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n\n        RecyclableObject* iterator = JavascriptOperators::GetIterator(items, scriptContext, true /* optional */);\n\n        if (iterator != nullptr)\n        {\n            if (constructor)\n            {\n                Js::Var constructorArgs[] = { constructor };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            {\n                newArr = scriptContext->GetLibrary()->CreateArray(0);\n                newArr->EnsureHead<Var>();\n                newObj = newArr;\n            }\n\n            uint32 k = 0;\n\n            JavascriptOperators::DoIteratorStepAndValue(iterator, scriptContext, [&](Var nextValue) {\n                if (mapping)\n                {\n                    Assert(mapFn != nullptr);\n                    Assert(mapFnThisArg != nullptr);\n\n                    Js::Var mapFnArgs[] = { mapFnThisArg, nextValue, JavascriptNumber::ToVar(k, scriptContext) };\n                    Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));\n                    nextValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));\n                }\n\n                if (newArr)\n                {\n                    newArr->SetItem(k, nextValue, PropertyOperation_None);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, nextValue), scriptContext, k);\n                }\n\n                k++;\n            });\n\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(k, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n        else\n        {\n            Var lenValue = JavascriptOperators::OP_GetLength(items, scriptContext);\n            int64 len = JavascriptConversion::ToLength(lenValue, scriptContext);\n\n            if (constructor)\n            {\n                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };\n                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n                newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n\n                if (JavascriptArray::Is(newObj))\n                {\n#if ENABLE_COPYONACCESS_ARRAY\n                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                    newArr = JavascriptArray::FromVar(newObj);\n                }\n            }\n            else\n            {\n                // Abstract operation ArrayCreate throws RangeError if length argument is > 2^32 -1\n                if (len > MaxArrayLength)\n                {\n                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect, _u(\"Array.from\"));\n                }\n\n                // Static cast len should be valid (len < 2^32) or we would throw above\n                newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(len));\n                newArr->EnsureHead<Var>();\n                newObj = newArr;\n            }\n\n            uint32 k = 0;\n\n            for ( ; k < len; k++)\n            {\n                Var kValue;\n\n                if (itemsArr)\n                {\n                    kValue = itemsArr->DirectGetItem(k);\n                }\n                else\n                {\n                    kValue = JavascriptOperators::OP_GetElementI_UInt32(items, k, scriptContext);\n                }\n\n                if (mapping)\n                {\n                    Assert(mapFn != nullptr);\n                    Assert(mapFnThisArg != nullptr);\n\n                    Js::Var mapFnArgs[] = { mapFnThisArg, kValue, JavascriptNumber::ToVar(k, scriptContext) };\n                    Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));\n                    kValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));\n                }\n\n                if (newArr)\n                {\n                    newArr->SetItem(k, kValue, PropertyOperation_None);\n                }\n                else\n                {\n                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k);\n                }\n            }\n\n            JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n        return newObj;\n    }\n\n    Var JavascriptArray::EntryOf(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);\n\n        ARGUMENTS(args, callInfo);\n        ScriptContext* scriptContext = function->GetScriptContext();\n\n        Assert(!(callInfo.Flags & CallFlags_New));\n\n        if (args.Info.Count == 0)\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.of\"));\n        }\n\n        return JavascriptArray::OfHelper(false, args, scriptContext);\n    }\n\n    Var JavascriptArray::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)\n    {\n        ARGUMENTS(args, callInfo);\n\n        Assert(args.Info.Count > 0);\n\n        return args[0];\n    }\n\n    // Array.of and %TypedArray%.of as described in ES6.0 (draft 22) Section 22.1.2.2 and 22.2.2.2\n    Var JavascriptArray::OfHelper(bool isTypedArrayEntryPoint, Arguments& args, ScriptContext* scriptContext)\n    {\n        Assert(args.Info.Count > 0);\n\n        // args.Info.Count cannot equal zero or we would have thrown above so no chance of underflowing\n        uint32 len = args.Info.Count - 1;\n        Var newObj = nullptr;\n        JavascriptArray* newArr = nullptr;\n        TypedArrayBase* newTypedArray = nullptr;\n        bool isBuiltinArrayCtor = true;\n\n        if (JavascriptOperators::IsConstructor(args[0]))\n        {\n            RecyclableObject* constructor = RecyclableObject::FromVar(args[0]);\n            isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());\n\n            Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };\n            Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n            newObj = isTypedArrayEntryPoint ?\n                TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), len, scriptContext) :\n                JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext);\n\n            // If the new object we created is an array, remember that as it will save us time setting properties in the object below\n            if (JavascriptArray::Is(newObj))\n            {\n#if ENABLE_COPYONACCESS_ARRAY\n                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);\n#endif\n                newArr = JavascriptArray::FromVar(newObj);\n            }\n            else if (TypedArrayBase::Is(newObj))\n            {\n                newTypedArray = TypedArrayBase::FromVar(newObj);\n            }\n        }\n        else\n        {\n            // We only throw when the constructor property is not a constructor function in the TypedArray version\n            if (isTypedArrayEntryPoint)\n            {\n                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedFunction, _u(\"[TypedArray].of\"));\n            }\n\n            newArr = scriptContext->GetLibrary()->CreateArray(len);\n            newArr->EnsureHead<Var>();\n            newObj = newArr;\n        }\n\n        // At least we have a new object of some kind\n        Assert(newObj);\n\n        if (isBuiltinArrayCtor)\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n\n                newArr->DirectSetItemAt(k, kValue);\n            }\n        }\n        else if (newTypedArray)\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n\n                newTypedArray->DirectSetItem(k, kValue);\n            }\n        }\n        else\n        {\n            for (uint32 k = 0; k < len; k++)\n            {\n                Var kValue = args[k + 1];\n                ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k);\n            }\n        }\n\n        if (!isTypedArrayEntryPoint)\n        {\n            // Set length if we are in the Array version of the function\n            JavascriptOperators::OP_SetProperty(newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, nullptr, PropertyOperation_ThrowIfNotExtensible);\n        }\n\n        return newObj;\n    }\n\n    JavascriptString* JavascriptArray::ToLocaleStringHelper(Var value, ScriptContext* scriptContext)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(value);\n        if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)\n        {\n            return scriptContext->GetLibrary()->GetEmptyString();\n        }\n        else\n        {\n            return JavascriptConversion::ToLocaleString(value, scriptContext);\n        }\n    }\n\n    inline BOOL JavascriptArray::IsFullArray() const\n    {\n        if (head && head->length == length)\n        {\n            AssertMsg(head->next == 0 && head->left == 0, \"Invalid Array\");\n            return true;\n        }\n        return (0 == length);\n    }\n\n    /*\n    *   IsFillFromPrototypes\n    *   -   Check the array has no missing values and only head segment.\n    *   -   Also ensure if the lengths match.\n    */\n    bool JavascriptArray::IsFillFromPrototypes()\n    {\n        return !(this->head->next == nullptr && this->HasNoMissingValues() && this->length == this->head->length);\n    }\n\n    // Fill all missing value in the array and fill it from prototype between startIndex and limitIndex\n    // typically startIndex = 0 and limitIndex = length. From start of the array till end of the array.\n    void JavascriptArray::FillFromPrototypes(uint32 startIndex, uint32 limitIndex)\n    {\n        if (startIndex >= limitIndex)\n        {\n            return;\n        }\n\n        RecyclableObject* prototype = this->GetPrototype();\n\n        // Fill all missing values by walking through prototype\n        while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)\n        {\n            ForEachOwnMissingArrayIndexOfObject(this, nullptr, prototype, startIndex, limitIndex,0, [this](uint32 index, Var value) {\n                this->SetItem(index, value, PropertyOperation_None);\n            });\n\n            prototype = prototype->GetPrototype();\n        }\n#ifdef VALIDATE_ARRAY\n        ValidateArray();\n#endif\n    }\n\n    //\n    // JavascriptArray requires head->left == 0 for fast path Get.\n    //\n    template<typename T>\n    void JavascriptArray::EnsureHeadStartsFromZero(Recycler * recycler)\n    {\n        if (head == nullptr || head->left != 0)\n        {\n            // This is used to fix up altered arrays.\n            // any SegmentMap would be invalid at this point.\n            ClearSegmentMap();\n\n            //\n            // We could OOM and throw when allocating new empty head, resulting in a corrupted array. Need\n            // some protection here. Save the head and switch this array to EmptySegment. Will be restored\n            // correctly if allocating new segment succeeds.\n            //\n            SparseArraySegment<T>* savedHead = (SparseArraySegment<T>*)this->head;\n            SparseArraySegment<T>* savedLastUsedSegment = (SparseArraySegment<T>*)this->GetLastUsedSegment();\n            SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase*>(EmptySegment));\n\n            SparseArraySegment<T> *newSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, 0, savedHead);\n            newSeg->next = savedHead;\n            this->head = newSeg;\n            SetHasNoMissingValues();\n            this->SetLastUsedSegment(savedLastUsedSegment);\n        }\n    }\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    void JavascriptArray::CheckForceES5Array()\n    {\n        if (Configuration::Global.flags.ForceES5Array)\n        {\n            // There's a bad interaction with the jitted code for native array creation here.\n            // ForceES5Array doesn't interact well with native arrays\n            if (PHASE_OFF1(NativeArrayPhase))\n            {\n                GetTypeHandler()->ConvertToTypeWithItemAttributes(this);\n            }\n        }\n    }\n#endif\n\n    template <typename T, typename Fn>\n    void JavascriptArray::ForEachOwnMissingArrayIndexOfObject(JavascriptArray *baseArray, JavascriptArray *destArray, RecyclableObject* obj, uint32 startIndex, uint32 limitIndex, T destIndex, Fn fn)\n    {\n        Assert(DynamicObject::IsAnyArray(obj) || JavascriptOperators::IsObject(obj));\n\n        Var oldValue;\n        JavascriptArray* arr = nullptr;\n        if (DynamicObject::IsAnyArray(obj))\n        {\n            arr = JavascriptArray::FromAnyArray(obj);\n        }\n        else if (DynamicType::Is(obj->GetTypeId()))\n        {\n            DynamicObject* dynobj = DynamicObject::FromVar(obj);\n            ArrayObject* objectArray = dynobj->GetObjectArray();\n            arr = (objectArray && JavascriptArray::IsAnyArray(objectArray)) ? JavascriptArray::FromAnyArray(objectArray) : nullptr;\n        }\n\n        if (arr != nullptr)\n        {\n            if (JavascriptArray::Is(arr))\n            {\n                arr = EnsureNonNativeArray(arr);\n                ArrayElementEnumerator e(arr, startIndex, limitIndex);\n\n                while(e.MoveNext<Var>())\n                {\n                    uint32 index = e.GetIndex();\n                    if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))\n                    {\n                        T n = destIndex + (index - startIndex);\n                        if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))\n                        {\n                            fn(index, e.GetItem<Var>());\n                        }\n                    }\n                }\n            }\n            else\n            {\n                ScriptContext* scriptContext = obj->GetScriptContext();\n\n                Assert(ES5Array::Is(arr));\n\n                ES5Array* es5Array = ES5Array::FromVar(arr);\n                ES5ArrayIndexStaticEnumerator<true> e(es5Array);\n\n                while (e.MoveNext())\n                {\n                    uint32 index = e.GetIndex();\n                    if (index < startIndex) continue;\n                    else if (index >= limitIndex) break;\n\n                    if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))\n                    {\n                        T n = destIndex + (index - startIndex);\n                        if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))\n                        {\n                            Var value = nullptr;\n                            if (JavascriptOperators::GetOwnItem(obj, index, &value, scriptContext))\n                            {\n                                fn(index, value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //\n    // ArrayElementEnumerator to enumerate array elements (not including elements from prototypes).\n    //\n    JavascriptArray::ArrayElementEnumerator::ArrayElementEnumerator(JavascriptArray* arr, uint32 start, uint32 end)\n        : start(start), end(min(end, arr->length))\n    {\n        Init(arr);\n    }\n\n    //\n    // Initialize this enumerator and prepare for the first MoveNext.\n    //\n    void JavascriptArray::ArrayElementEnumerator::Init(JavascriptArray* arr)\n    {\n        // Find start segment\n        seg = (arr ? arr->GetBeginLookupSegment(start) : nullptr);\n        while (seg && (seg->left + seg->length <= start))\n        {\n            seg = seg->next;\n        }\n\n        // Set start index and endIndex\n        if (seg)\n        {\n            if (seg->left >= end)\n            {\n                seg = nullptr;\n            }\n            else\n            {\n                // set index to be at target index - 1, so MoveNext will move to target\n                index = max(seg->left, start) - seg->left - 1;\n                endIndex = min(end - seg->left, seg->length);\n            }\n        }\n    }\n\n    //\n    // Move to the next element if available.\n    //\n    template<typename T>\n    inline bool JavascriptArray::ArrayElementEnumerator::MoveNext()\n    {\n        while (seg)\n        {\n            // Look for next non-null item in current segment\n            while (++index < endIndex)\n            {\n                if (!SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]))\n                {\n                    return true;\n                }\n            }\n\n            // Move to next segment\n            seg = seg->next;\n            if (seg)\n            {\n                if (seg->left >= end)\n                {\n                    seg = nullptr;\n                    break;\n                }\n                else\n                {\n                    index = static_cast<uint32>(-1);\n                    endIndex = min(end - seg->left, seg->length);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    //\n    // Get current array element index.\n    //\n    uint32 JavascriptArray::ArrayElementEnumerator::GetIndex() const\n    {\n        Assert(seg && index < seg->length && index < endIndex);\n        return seg->left + index;\n    }\n\n    //\n    // Get current array element value.\n    //\n    template<typename T>\n    T JavascriptArray::ArrayElementEnumerator::GetItem() const\n    {\n        Assert(seg && index < seg->length && index < endIndex &&\n               !SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]));\n        return ((SparseArraySegment<T>*)seg)->elements[index];\n    }\n\n    //\n    // Construct a BigIndex initialized to a given uint32 (small index).\n    //\n    JavascriptArray::BigIndex::BigIndex(uint32 initIndex)\n        : index(initIndex), bigIndex(InvalidIndex)\n    {\n        //ok if initIndex == InvalidIndex\n    }\n\n    //\n    // Construct a BigIndex initialized to a given uint64 (large or small index).\n    //\n    JavascriptArray::BigIndex::BigIndex(uint64 initIndex)\n        : index(InvalidIndex), bigIndex(initIndex)\n    {\n        if (bigIndex < InvalidIndex) // if it's actually small index\n        {\n            index = static_cast<uint32>(bigIndex);\n            bigIndex = InvalidIndex;\n        }\n    }\n\n    bool JavascriptArray::BigIndex::IsUint32Max() const\n    {\n        return index == InvalidIndex && bigIndex == InvalidIndex;\n    }\n    bool JavascriptArray::BigIndex::IsSmallIndex() const\n    {\n        return index < InvalidIndex;\n    }\n\n    uint32 JavascriptArray::BigIndex::GetSmallIndex() const\n    {\n        Assert(IsSmallIndex());\n        return index;\n    }\n\n    uint64 JavascriptArray::BigIndex::GetBigIndex() const\n    {\n        Assert(!IsSmallIndex());\n        return bigIndex;\n    }\n    //\n    // Convert this index value to a JS number\n    //\n    Var JavascriptArray::BigIndex::ToNumber(ScriptContext* scriptContext) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::ToNumber(index, scriptContext);\n        }\n        else\n        {\n            return JavascriptNumber::ToVar(bigIndex, scriptContext);\n        }\n    }\n\n    //\n    // Increment this index by 1.\n    //\n    const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator++()\n    {\n        if (IsSmallIndex())\n        {\n            ++index;\n            // If index reaches InvalidIndex, we will start to use bigIndex which is initially InvalidIndex.\n        }\n        else\n        {\n            bigIndex = bigIndex + 1;\n        }\n\n        return *this;\n    }\n\n    //\n    // Decrement this index by 1.\n    //\n    const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator--()\n    {\n        if (IsSmallIndex())\n        {\n            --index;\n        }\n        else\n        {\n            Assert(index == InvalidIndex && bigIndex >= InvalidIndex);\n\n            --bigIndex;\n            if (bigIndex < InvalidIndex)\n            {\n                index = InvalidIndex - 1;\n                bigIndex = InvalidIndex;\n            }\n        }\n\n        return *this;\n    }\n\n    JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(const BigIndex& delta) const\n    {\n        if (delta.IsSmallIndex())\n        {\n            return operator+(delta.GetSmallIndex());\n        }\n        if (IsSmallIndex())\n        {\n            return index + delta.GetBigIndex();\n        }\n\n        return bigIndex + delta.GetBigIndex();\n    }\n\n    //\n    // Get a new BigIndex representing this + delta.\n    //\n    JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(uint32 delta) const\n    {\n        if (IsSmallIndex())\n        {\n            uint32 newIndex;\n            if (UInt32Math::Add(index, delta, &newIndex))\n            {\n                return static_cast<uint64>(index) + static_cast<uint64>(delta);\n            }\n            else\n            {\n                return newIndex; // ok if newIndex == InvalidIndex\n            }\n        }\n        else\n        {\n            return bigIndex + static_cast<uint64>(delta);\n        }\n    }\n\n    bool JavascriptArray::BigIndex::operator==(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() == rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() == (uint64) rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) == rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() == rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator> (const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() > rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() > (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) > rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() > rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator< (const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() < rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() < (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) < rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() < rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator<=(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() <= rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() <= (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) <= rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() <= rhs.GetBigIndex();\n    }\n\n    bool JavascriptArray::BigIndex::operator>=(const BigIndex& rhs) const\n    {\n        if (rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            return this->GetSmallIndex() >= rhs.GetSmallIndex();\n        }\n        else if (rhs.IsSmallIndex() && !this->IsSmallIndex())\n        {\n            // if lhs is big promote rhs\n            return this->GetBigIndex() >= (uint64)rhs.GetSmallIndex();\n        }\n        else if (!rhs.IsSmallIndex() && this->IsSmallIndex())\n        {\n            // if rhs is big promote lhs\n            return ((uint64)this->GetSmallIndex()) >= rhs.GetBigIndex();\n        }\n        return this->GetBigIndex() >= rhs.GetBigIndex();\n    }\n\n    BOOL JavascriptArray::BigIndex::GetItem(JavascriptArray* arr, Var* outVal) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::GetItem(arr, index, outVal);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->GetProperty(arr, propertyRecord->GetPropertyId(), outVal, NULL, scriptContext);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::SetItem(JavascriptArray* arr, Var newValue) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::SetItem(arr, index, newValue);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->SetProperty(propertyRecord->GetPropertyId(), newValue, PropertyOperation_None, NULL);\n        }\n    }\n\n    void JavascriptArray::BigIndex::SetItemIfNotExist(JavascriptArray* arr, Var newValue) const\n    {\n        if (IsSmallIndex())\n        {\n            small_index::SetItemIfNotExist(arr, index, newValue);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            Var oldValue;\n            PropertyId propertyId = propertyRecord->GetPropertyId();\n            if (!arr->GetProperty(arr, propertyId, &oldValue, NULL, scriptContext))\n            {\n                arr->SetProperty(propertyId, newValue, PropertyOperation_None, NULL);\n            }\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::DeleteItem(JavascriptArray* arr) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::DeleteItem(arr, index);\n        }\n        else\n        {\n            ScriptContext* scriptContext = arr->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return arr->DeleteProperty(propertyRecord->GetPropertyId(), PropertyOperation_None);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::SetItem(RecyclableObject* obj, Var newValue, PropertyOperationFlags flags) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::SetItem(obj, index, newValue, flags);\n        }\n        else\n        {\n            ScriptContext* scriptContext = obj->GetScriptContext();\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);\n            return JavascriptOperators::SetProperty(obj, obj, propertyRecord->GetPropertyId(), newValue, scriptContext, flags);\n        }\n    }\n\n    BOOL JavascriptArray::BigIndex::DeleteItem(RecyclableObject* obj, PropertyOperationFlags flags) const\n    {\n        if (IsSmallIndex())\n        {\n            return small_index::DeleteItem(obj, index, flags);\n        }\n        else\n        {\n            PropertyRecord const * propertyRecord;\n            JavascriptOperators::GetPropertyIdForInt(bigIndex, obj->GetScriptContext(), &propertyRecord);\n            return JavascriptOperators::DeleteProperty(obj, propertyRecord->GetPropertyId(), flags);\n        }\n    }\n\n    //\n    // Truncate the array at start and clone the truncated span as properties starting at dstIndex (asserting dstIndex >= MaxArrayLength).\n    //\n    void JavascriptArray::TruncateToProperties(const BigIndex& dstIndex, uint32 start)\n    {\n        Assert(!dstIndex.IsSmallIndex());\n        typedef IndexTrace<BigIndex> index_trace;\n\n        BigIndex dst = dstIndex;\n        uint32 i = start;\n\n        ArrayElementEnumerator e(this, start);\n        while(e.MoveNext<Var>())\n        {\n            // delete all items not enumerated\n            while (i < e.GetIndex())\n            {\n                index_trace::DeleteItem(this, dst);\n                ++i;\n                ++dst;\n            }\n\n            // Copy over the item\n            index_trace::SetItem(this, dst, e.GetItem<Var>());\n            ++i;\n            ++dst;\n        }\n\n        // Delete the rest till length\n        while (i < this->length)\n        {\n            index_trace::DeleteItem(this, dst);\n            ++i;\n            ++dst;\n        }\n\n        // Elements moved, truncate the array at start\n        SetLength(start);\n    }\n\n    //\n    // Copy a srcArray elements (including elements from prototypes) to a dstArray starting from an index.\n    //\n    template<typename T>\n    void JavascriptArray::InternalCopyArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<Var>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<Var>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    //\n    // Copy a srcArray elements (including elements from prototypes) to a dstArray starting from an index. If the index grows larger than\n    // \"array index\", it will automatically turn to SetProperty using the index as property name.\n    //\n    void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, uint32 dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    template <typename T>\n    void JavascriptArray::CopyAnyArrayElementsToVar(JavascriptArray* dstArray, T dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(srcArray);\n#endif\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(dstArray);\n#endif\n        if (JavascriptNativeIntArray::Is(srcArray))\n        {\n            CopyNativeIntArrayElementsToVar(dstArray, dstIndex, JavascriptNativeIntArray::FromVar(srcArray), start, end);\n        }\n        else if (JavascriptNativeFloatArray::Is(srcArray))\n        {\n            CopyNativeFloatArrayElementsToVar(dstArray, dstIndex, JavascriptNativeFloatArray::FromVar(srcArray), start, end);\n        }\n        else\n        {\n            CopyArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyNativeIntArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    bool JavascriptArray::CopyNativeIntArrayElements(JavascriptNativeIntArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<int32>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeIntArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool JavascriptArray::CopyNativeIntArrayElementsToFloat(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, (double)e.GetItem<int32>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            uint32 len = end - start;\n            if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))\n            {\n                // Won't overflow, use faster small_index version\n                InternalCopyNativeFloatArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);\n            }\n            else\n            {\n                InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);\n            }\n        }\n    }\n\n    //\n    // Faster small_index overload of CopyArrayElements, asserting the uint32 dstIndex won't overflow.\n    //\n    void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start < end)\n        {\n            Assert(end - start <= MaxArrayLength - dstIndex);\n            InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);\n        }\n    }\n\n    bool JavascriptArray::CopyNativeFloatArrayElements(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        end = min(end, srcArray->length);\n        if (start >= end)\n        {\n            return false;\n        }\n\n        Assert(end - start <= MaxArrayLength - dstIndex);\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<double>())\n        {\n            uint n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, e.GetItem<double>());\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);\n            InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);\n            return true;\n        }\n\n        return false;\n    }\n\n    JavascriptArray *JavascriptArray::EnsureNonNativeArray(JavascriptArray *arr)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arr);\n#endif\n        if (JavascriptNativeIntArray::Is(arr))\n        {\n            arr = JavascriptNativeIntArray::ToVarArray((JavascriptNativeIntArray*)arr);\n        }\n        else if (JavascriptNativeFloatArray::Is(arr))\n        {\n            arr = JavascriptNativeFloatArray::ToVarArray((JavascriptNativeFloatArray*)arr);\n        }\n\n        return arr;\n    }\n\n    BOOL JavascriptNativeIntArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        ScriptContext* requestContext = type->GetScriptContext();\n        if (JavascriptNativeIntArray::GetItem(this, index, outVal, requestContext))\n        {\n            return TRUE;\n        }\n\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::DirectGetItemAtFull(uint32 index, Var* outVal)\n    {\n        ScriptContext* requestContext = type->GetScriptContext();\n        if (JavascriptNativeFloatArray::GetItem(this, index, outVal, requestContext))\n        {\n            return TRUE;\n        }\n\n        return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalCopyNativeIntArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ScriptContext *scriptContext = dstArray->GetScriptContext();\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<int32>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, JavascriptNumber::ToVar(e.GetItem<int32>(), scriptContext));\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::InternalCopyNativeFloatArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)\n    {\n        Assert(start < end && end <= srcArray->length);\n\n        uint32 count = 0;\n\n        // iterate on the array itself\n        ScriptContext *scriptContext = dstArray->GetScriptContext();\n        ArrayElementEnumerator e(srcArray, start, end);\n        while(e.MoveNext<double>())\n        {\n            T n = dstIndex + (e.GetIndex() - start);\n            dstArray->DirectSetItemAt(n, JavascriptNumber::ToVarWithCheck(e.GetItem<double>(), scriptContext));\n            count++;\n        }\n\n        // iterate on the array's prototypes only if not all elements found\n        if (start + count != end)\n        {\n            InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);\n        }\n    }\n\n    Var JavascriptArray::SpreadArrayArgs(Var arrayToSpread, const Js::AuxArray<uint32> *spreadIndices, ScriptContext *scriptContext)\n    {\n        // At this stage we have an array literal with some arguments to be spread.\n        // First we need to calculate the real size of the final literal.\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arrayToSpread);\n#endif\n        JavascriptArray *array = FromVar(arrayToSpread);\n        uint32 actualLength = array->GetLength();\n\n        for (unsigned i = 0; i < spreadIndices->count; ++i)\n        {\n            actualLength = UInt32Math::Add(actualLength - 1, GetSpreadArgLen(array->DirectGetItem(spreadIndices->elements[i]), scriptContext));\n        }\n\n        JavascriptArray *result = FromVar(OP_NewScArrayWithMissingValues(actualLength, scriptContext));\n\n        // Now we copy each element and expand the spread parameters inline.\n        for (unsigned i = 0, spreadArrIndex = 0, resultIndex = 0; i < array->GetLength() && resultIndex < actualLength; ++i)\n        {\n            uint32 spreadIndex = spreadIndices->elements[spreadArrIndex]; // The index of the next element to be spread.\n\n            // An array needs a slow copy if it is a cross-site object or we have missing values that need to be set to undefined.\n            auto needArraySlowCopy = [&](Var instance) {\n                if (JavascriptArray::Is(instance))\n                {\n                    JavascriptArray *arr = JavascriptArray::FromVar(instance);\n                    return arr->IsCrossSiteObject() || arr->IsFillFromPrototypes();\n                }\n                return false;\n            };\n\n            // Designed to have interchangeable arguments with CopyAnyArrayElementsToVar.\n            auto slowCopy = [&scriptContext, &needArraySlowCopy](JavascriptArray *dstArray, unsigned dstIndex, Var srcArray, uint32 start, uint32 end) {\n                Assert(needArraySlowCopy(srcArray) || ArgumentsObject::Is(srcArray) || TypedArrayBase::Is(srcArray) || JavascriptString::Is(srcArray));\n\n                RecyclableObject *propertyObject;\n                if (!JavascriptOperators::GetPropertyObject(srcArray, scriptContext, &propertyObject))\n                {\n                    JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidSpreadArgument);\n                }\n\n                for (uint32 j = start; j < end; j++)\n                {\n                    Var element;\n                    if (!JavascriptOperators::GetItem(srcArray, propertyObject, j, &element, scriptContext))\n                    {\n                        // Copy across missing values as undefined as per 12.2.5.2 SpreadElement : ... AssignmentExpression 5f.\n                        element = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                    dstArray->DirectSetItemAt(dstIndex++, element);\n                }\n            };\n\n            if (i < spreadIndex)\n            {\n                // Any non-spread elements can be copied in bulk.\n\n                if (needArraySlowCopy(array))\n                {\n                    slowCopy(result, resultIndex, (Var)array, i, spreadIndex);\n                }\n                else\n                {\n                    CopyAnyArrayElementsToVar(result, resultIndex, array, i, spreadIndex);\n                }\n                resultIndex += spreadIndex - i;\n                i = spreadIndex - 1;\n                continue;\n            }\n            else if (i > spreadIndex)\n            {\n                // Any non-spread elements terminating the array can also be copied in bulk.\n                Assert(spreadArrIndex == spreadIndices->count - 1);\n                if (needArraySlowCopy(array))\n                {\n                    slowCopy(result, resultIndex, array, i, array->GetLength());\n                }\n                else\n                {\n                    CopyAnyArrayElementsToVar(result, resultIndex, array, i, array->GetLength());\n                }\n                break;\n            }\n            else\n            {\n                Var instance = array->DirectGetItem(i);\n\n                if (SpreadArgument::Is(instance))\n                {\n                    SpreadArgument* spreadArgument = SpreadArgument::FromVar(instance);\n                    uint32 len = spreadArgument->GetArgumentSpreadCount();\n                    const Var*  spreadItems = spreadArgument->GetArgumentSpread();\n                    for (uint32 j = 0; j < len; j++)\n                    {\n                        result->DirectSetItemAt(resultIndex++, spreadItems[j]);\n                    }\n\n                }\n                else\n                {\n                    AssertMsg(JavascriptArray::Is(instance) || TypedArrayBase::Is(instance), \"Only SpreadArgument, TypedArray, and JavascriptArray should be listed as spread arguments\");\n\n                    // We first try to interpret the spread parameter as a JavascriptArray.\n                    JavascriptArray *arr = nullptr;\n                    if (JavascriptArray::Is(instance))\n                    {\n                        arr = JavascriptArray::FromVar(instance);\n                    }\n\n                    if (arr != nullptr)\n                    {\n                        if (arr->GetLength() > 0)\n                        {\n                            if (needArraySlowCopy(arr))\n                            {\n                                slowCopy(result, resultIndex, arr, 0, arr->GetLength());\n                            }\n                            else\n                            {\n                                CopyAnyArrayElementsToVar(result, resultIndex, arr, 0, arr->GetLength());\n                            }\n                            resultIndex += arr->GetLength();\n                        }\n                    }\n                    else\n                    {\n                        uint32 len = GetSpreadArgLen(instance, scriptContext);\n                        slowCopy(result, resultIndex, instance, 0, len);\n                        resultIndex += len;\n                    }\n                }\n\n                if (spreadArrIndex < spreadIndices->count - 1)\n                {\n                    spreadArrIndex++;\n                }\n            }\n        }\n        return result;\n    }\n\n    uint32 JavascriptArray::GetSpreadArgLen(Var spreadArg, ScriptContext *scriptContext)\n    {\n        // A spread argument can be anything that returns a 'length' property, even if that\n        // property is null or undefined.\n        spreadArg = CrossSite::MarshalVar(scriptContext, spreadArg);\n        if (JavascriptArray::Is(spreadArg))\n        {\n            JavascriptArray *arr = JavascriptArray::FromVar(spreadArg);\n            return arr->GetLength();\n        }\n\n        if (TypedArrayBase::Is(spreadArg))\n        {\n            TypedArrayBase *tarr = TypedArrayBase::FromVar(spreadArg);\n            return tarr->GetLength();\n        }\n\n        if (SpreadArgument::Is(spreadArg))\n        {\n            SpreadArgument *spreadFunctionArgs = SpreadArgument::FromVar(spreadArg);\n            return spreadFunctionArgs->GetArgumentSpreadCount();\n        }\n\n        AssertMsg(false, \"LdCustomSpreadIteratorList should have converted the arg to one of the above types\");\n        Throw::FatalInternalError();\n    }\n\n#ifdef VALIDATE_ARRAY\n    class ArraySegmentsVisitor\n    {\n    private:\n        SparseArraySegmentBase* seg;\n\n    public:\n        ArraySegmentsVisitor(SparseArraySegmentBase* head)\n            : seg(head)\n        {\n        }\n\n        void operator()(SparseArraySegmentBase* s)\n        {\n            Assert(seg == s);\n            if (seg)\n            {\n                seg = seg->next;\n            }\n        }\n    };\n\n    void JavascriptArray::ValidateArrayCommon()\n    {\n        SparseArraySegmentBase * lastUsedSegment = this->GetLastUsedSegment();\n        AssertMsg(this != nullptr && head && lastUsedSegment, \"Array should not be null\");\n        AssertMsg(head->left == 0, \"Array always should have a segment starting at zero\");\n\n        // Simple segments validation\n        bool foundLastUsedSegment = false;\n        SparseArraySegmentBase *seg = head;\n        while(seg != nullptr)\n        {\n            if (seg == lastUsedSegment)\n            {\n                foundLastUsedSegment = true;\n            }\n\n            AssertMsg(seg->length <= seg->size , \"Length greater than size not possible\");\n\n            SparseArraySegmentBase* next = seg->next;\n            if (next != nullptr)\n            {\n                AssertMsg(seg->left < next->left, \"Segment is adjacent to or overlaps with next segment\");\n                AssertMsg(seg->size <= (next->left - seg->left), \"Segment is adjacent to or overlaps with next segment\");\n                AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n            }\n            else\n            {\n                AssertMsg(seg->length <= MaxArrayLength - seg->left, \"Segment index range overflow\");\n                AssertMsg(seg->left + seg->length <= this->length, \"Segment index range exceeds array length\");\n            }\n\n            seg = next;\n        }\n        AssertMsg(foundLastUsedSegment || HasSegmentMap(), \"Corrupt lastUsedSegment in array header\");\n\n        // Validate segmentMap if present\n        if (HasSegmentMap())\n        {\n            ArraySegmentsVisitor visitor(head);\n            GetSegmentMap()->Walk(visitor);\n        }\n    }\n\n    void JavascriptArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateVarSegment((SparseArraySegment<Var>*)head);\n    }\n\n    void JavascriptNativeIntArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n#if DBG\n            SparseArraySegmentBase *seg = head;\n            while (seg)\n            {\n                if (seg->next != nullptr)\n                {\n                    AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n                }\n                seg = seg->next;\n            }\n#endif\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateSegment<int32>((SparseArraySegment<int32>*)head);\n    }\n\n    void JavascriptNativeFloatArray::ValidateArray()\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n#if DBG\n            SparseArraySegmentBase *seg = head;\n            while (seg)\n            {\n                if (seg->next != nullptr)\n                {\n                    AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");\n                }\n                seg = seg->next;\n            }\n#endif\n            return;\n        }\n        ValidateArrayCommon();\n        // Detailed segments validation\n        JavascriptArray::ValidateSegment<double>((SparseArraySegment<double>*)head);\n    }\n\n\n    void JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>* seg)\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n        int32 inspect;\n        double inspectDouble;\n        while (seg)\n        {\n            uint32 i = 0;\n            for (i = 0; i < seg->length; i++)\n            {\n                if (SparseArraySegment<Var>::IsMissingItem(&seg->elements[i]))\n                {\n                    continue;\n                }\n                if (TaggedInt::Is(seg->elements[i]))\n                {\n                    inspect = TaggedInt::ToInt32(seg->elements[i]);\n\n                }\n                else if (JavascriptNumber::Is_NoTaggedIntCheck(seg->elements[i]))\n                {\n                    inspectDouble = JavascriptNumber::GetValue(seg->elements[i]);\n                }\n                else\n                {\n                    AssertMsg(RecyclableObject::Is(seg->elements[i]), \"Invalid entry in segment\");\n                }\n            }\n            ValidateSegment(seg);\n\n            seg = (SparseArraySegment<Var>*)seg->next;\n        }\n    }\n\n    template<typename T>\n    void JavascriptArray::ValidateSegment(SparseArraySegment<T>* seg)\n    {\n        if (!Js::Configuration::Global.flags.ArrayValidate)\n        {\n            return;\n        }\n\n        while (seg)\n        {\n            uint32 i = seg->length;\n            while (i < seg->size)\n            {\n                AssertMsg(SparseArraySegment<T>::IsMissingItem(&seg->elements[i]), \"Non missing value the end of the segment\");\n                i++;\n            }\n\n            seg = (SparseArraySegment<T>*)seg->next;\n        }\n    }\n#endif\n\n    template <typename T>\n    void JavascriptArray::InitBoxedInlineHeadSegment(SparseArraySegment<T> * dst, SparseArraySegment<T> * src)\n    {\n        // Don't copy the segment map, we will build it again\n        SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n\n        SetHeadAndLastUsedSegment(dst);\n\n        dst->left = src->left;\n        dst->length = src->length;\n        dst->size = src->size;\n        dst->next = src->next;\n\n        js_memcpy_s(dst->elements, sizeof(T) * dst->size, src->elements, sizeof(T) * src->size);\n\n    }\n\n    JavascriptArray::JavascriptArray(JavascriptArray * instance, bool boxHead)\n        : ArrayObject(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, true>(this), (SparseArraySegment<Var>*)instance->head);\n        }\n        else\n        {\n\n            SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);\n            head = instance->head;\n            SetLastUsedSegment(instance->GetLastUsedSegment());\n        }\n    }\n\n    template <typename T>\n    T * JavascriptArray::BoxStackInstance(T * instance)\n    {\n        Assert(ThreadContext::IsOnStack(instance));\n        // On the stack, the we reserved a pointer before the object as to store the boxed value\n        T ** boxedInstanceRef = ((T **)instance) - 1;\n        T * boxedInstance = *boxedInstanceRef;\n        if (boxedInstance)\n        {\n            return boxedInstance;\n        }\n\n        const size_t inlineSlotsSize = instance->GetTypeHandler()->GetInlineSlotsSize();\n        if (ThreadContext::IsOnStack(instance->head))\n        {\n            boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(),\n                inlineSlotsSize + sizeof(Js::SparseArraySegmentBase) + instance->head->size * sizeof(typename T::TElement),\n                T, instance, true);\n        }\n        else if(inlineSlotsSize)\n        {\n            boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(), inlineSlotsSize, T, instance, false);\n        }\n        else\n        {\n            boxedInstance = RecyclerNew(instance->GetRecycler(), T, instance, false);\n        }\n\n        *boxedInstanceRef = boxedInstance;\n        return boxedInstance;\n    }\n\n    JavascriptArray *\n    JavascriptArray::BoxStackInstance(JavascriptArray * instance)\n    {\n        return BoxStackInstance<JavascriptArray>(instance);\n    }\n\n#if ENABLE_TTD\n    void JavascriptArray::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array || this->GetTypeId() == Js::TypeIds_ES5Array, \"Should only be used on basic arrays (or called as super from ES5Array.\");\n\n        ScriptContext* ctx = this->GetScriptContext();\n\n        uint32 index = Js::JavascriptArray::InvalidIndex;\n        while(true)\n        {\n            index = this->GetNextIndex(index);\n            if(index == Js::JavascriptArray::InvalidIndex) // End of array\n            {\n                break;\n            }\n\n            Js::Var aval = nullptr;\n            if(this->DirectGetVarItemAt(index, &aval, ctx))\n            {\n                extractor->MarkVisitVar(aval);\n            }\n        }\n    }\n\n    void JavascriptArray::ProcessCorePaths()\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic arrays.\");\n\n        ScriptContext* ctx = this->GetScriptContext();\n\n        uint32 index = Js::JavascriptArray::InvalidIndex;\n        while(true)\n        {\n            index = this->GetNextIndex(index);\n            if(index == Js::JavascriptArray::InvalidIndex) // End of array\n            {\n                break;\n            }\n\n            Js::Var aval = nullptr;\n            if(this->DirectGetVarItemAt(index, &aval, ctx))\n            {\n                TTD::UtilSupport::TTAutoString pathExt;\n                ctx->TTDWellKnownInfo->BuildArrayIndexBuffer(index, pathExt);\n\n                ctx->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, aval, pathExt.GetStrValue());\n            }\n        }\n    }\n\n    TTD::NSSnapObjects::SnapObjectType JavascriptArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapArrayObject;\n    }\n\n    void JavascriptArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic Js arrays.\");\n\n        TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>* sai = TTD::NSSnapObjects::ExtractArrayValues<TTD::TTDVar>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>*, TTD::NSSnapObjects::SnapObjectType::SnapArrayObject>(objData, sai);\n    }\n#endif\n\n    JavascriptNativeArray::JavascriptNativeArray(JavascriptNativeArray * instance) :\n        JavascriptArray(instance, false),\n        weakRefToFuncBody(instance->weakRefToFuncBody)\n    {\n    }\n\n    JavascriptNativeIntArray::JavascriptNativeIntArray(JavascriptNativeIntArray * instance, bool boxHead) :\n        JavascriptNativeArray(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>(this), (SparseArraySegment<int>*)instance->head);\n        }\n        else\n        {\n            // Base class ctor should have copied these\n            Assert(head == instance->head);\n            Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());\n        }\n    }\n\n    JavascriptNativeIntArray *\n    JavascriptNativeIntArray::BoxStackInstance(JavascriptNativeIntArray * instance)\n    {\n        return JavascriptArray::BoxStackInstance<JavascriptNativeIntArray>(instance);\n    }\n\n#if ENABLE_TTD\n    TTD::NSSnapObjects::SnapObjectType JavascriptNativeIntArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject;\n    }\n\n    void JavascriptNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTD::NSSnapObjects::SnapArrayInfo<int32>* sai = TTD::NSSnapObjects::ExtractArrayValues<int32>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<int32>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject>(objData, sai);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    TTD::NSSnapObjects::SnapObjectType JavascriptCopyOnAccessNativeIntArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::Invalid;\n    }\n\n    void JavascriptCopyOnAccessNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(false, \"Not implemented yet!!!\");\n    }\n#endif\n#endif\n\n    JavascriptNativeFloatArray::JavascriptNativeFloatArray(JavascriptNativeFloatArray * instance, bool boxHead) :\n        JavascriptNativeArray(instance)\n    {\n        if (boxHead)\n        {\n            InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>(this), (SparseArraySegment<double>*)instance->head);\n        }\n        else\n        {\n            // Base class ctor should have copied these\n            Assert(head == instance->head);\n            Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());\n        }\n    }\n\n    JavascriptNativeFloatArray *\n    JavascriptNativeFloatArray::BoxStackInstance(JavascriptNativeFloatArray * instance)\n    {\n        return JavascriptArray::BoxStackInstance<JavascriptNativeFloatArray>(instance);\n    }\n\n#if ENABLE_TTD\n    TTD::NSSnapObjects::SnapObjectType JavascriptNativeFloatArray::GetSnapTag_TTD() const\n    {\n        return TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject;\n    }\n\n    void JavascriptNativeFloatArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)\n    {\n        TTDAssert(this->GetTypeId() == Js::TypeIds_NativeFloatArray, \"Should only be used on native float arrays.\");\n\n        TTD::NSSnapObjects::SnapArrayInfo<double>* sai = TTD::NSSnapObjects::ExtractArrayValues<double>(this, alloc);\n        TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<double>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject>(objData, sai);\n    }\n#endif\n\n    template<typename T>\n    RecyclableObject*\n    JavascriptArray::ArraySpeciesCreate(Var originalArray, T length, ScriptContext* scriptContext, bool *pIsIntArray, bool *pIsFloatArray, bool *pIsBuiltinArrayCtor)\n    {\n        if (originalArray == nullptr || !scriptContext->GetConfig()->IsES6SpeciesEnabled())\n        {\n            return nullptr;\n        }\n\n        if (JavascriptArray::Is(originalArray)\n            && !DynamicObject::FromVar(originalArray)->GetDynamicType()->GetTypeHandler()->GetIsNotPathTypeHandlerOrHasUserDefinedCtor()\n            && DynamicObject::FromVar(originalArray)->GetPrototype() == scriptContext->GetLibrary()->GetArrayPrototype()\n            && !scriptContext->GetLibrary()->GetArrayObjectHasUserDefinedSpecies())\n        {\n            return nullptr;\n        }\n\n        Var constructor = scriptContext->GetLibrary()->GetUndefined();\n\n        if (JavascriptOperators::IsArray(originalArray))\n        {\n            if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(originalArray), PropertyIds::constructor, &constructor, scriptContext))\n            {\n                return nullptr;\n            }\n\n            if (JavascriptOperators::IsConstructor(constructor))\n            {\n                ScriptContext* constructorScriptContext = RecyclableObject::FromVar(constructor)->GetScriptContext();\n                if (constructorScriptContext != scriptContext)\n                {\n                    if (constructorScriptContext->GetLibrary()->GetArrayConstructor() == constructor)\n                    {\n                        constructor = scriptContext->GetLibrary()->GetUndefined();\n                    }\n                }\n            }\n\n            if (JavascriptOperators::IsObject(constructor))\n            {\n                if (!JavascriptOperators::GetProperty((RecyclableObject*)constructor, PropertyIds::_symbolSpecies, &constructor, scriptContext))\n                {\n                    if (pIsBuiltinArrayCtor != nullptr)\n                    {\n                        *pIsBuiltinArrayCtor = false;\n                    }\n\n                    return nullptr;\n                }\n                if (constructor == scriptContext->GetLibrary()->GetNull())\n                {\n                    constructor = scriptContext->GetLibrary()->GetUndefined();\n                }\n            }\n        }\n\n        if (constructor == scriptContext->GetLibrary()->GetUndefined() || constructor == scriptContext->GetLibrary()->GetArrayConstructor())\n        {\n            if (length > UINT_MAX)\n            {\n                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);\n            }\n\n            if (nullptr == pIsIntArray)\n            {\n                return scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));\n            }\n            else\n            {\n                // If the constructor function is the built-in Array constructor, we can be smart and create the right type of native array.\n                JavascriptArray* pArr = JavascriptArray::FromVar(originalArray);\n                pArr->GetArrayTypeAndConvert(pIsIntArray, pIsFloatArray);\n                return CreateNewArrayHelper(static_cast<uint32>(length), *pIsIntArray, *pIsFloatArray, pArr, scriptContext);\n            }\n        }\n\n        if (!JavascriptOperators::IsConstructor(constructor))\n        {\n            JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"constructor[Symbol.species]\"));\n        }\n\n        if (pIsBuiltinArrayCtor != nullptr)\n        {\n            *pIsBuiltinArrayCtor = false;\n        }\n\n        Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };\n        Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));\n\n        return RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));\n    }\n    /*static*/\n    PropertyId const JavascriptArray::specialPropertyIds[] =\n    {\n        PropertyIds::length\n    };\n\n    BOOL JavascriptArray::DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::DeleteProperty(propertyId, flags);\n    }\n\n    BOOL JavascriptArray::DeleteProperty(JavascriptString *propertyNameString, PropertyOperationFlags flags)\n    {\n        JsUtil::CharacterBuffer<WCHAR> propertyName(propertyNameString->GetString(), propertyNameString->GetLength());\n        if (BuiltInPropertyRecords::length.Equals(propertyName))\n        {\n            return false;\n        }\n        return DynamicObject::DeleteProperty(propertyNameString, flags);\n    }\n\n    BOOL JavascriptArray::HasProperty(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return true;\n        }\n\n        ScriptContext* scriptContext = GetScriptContext();\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return this->HasItem(index);\n        }\n\n        return DynamicObject::HasProperty(propertyId);\n    }\n\n    BOOL JavascriptArray::IsEnumerable(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::IsEnumerable(propertyId);\n    }\n\n    BOOL JavascriptArray::IsConfigurable(PropertyId propertyId)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            return false;\n        }\n        return DynamicObject::IsConfigurable(propertyId);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetEnumerable(PropertyId propertyId, BOOL value)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(!value); // Can't change array length enumerable\n            return true;\n        }\n\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetEnumerable(this, propertyId, value);\n        }\n\n        return __super::SetEnumerable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetWritable(PropertyId propertyId, BOOL value)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n        uint32 index;\n\n        bool setLengthNonWritable = (propertyId == PropertyIds::length && !value);\n        if (setLengthNonWritable || scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetWritable(this, propertyId, value);\n        }\n\n        return __super::SetWritable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetConfigurable(PropertyId propertyId, BOOL value)\n    {\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(!value); // Can't change array length configurable\n            return true;\n        }\n\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetConfigurable(this, propertyId, value);\n        }\n\n        return __super::SetConfigurable(propertyId, value);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetAttributes(PropertyId propertyId, PropertyAttributes attributes)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        // SetAttributes on \"length\" is not expected. DefineOwnProperty uses SetWritable. If this is\n        // changed, we need to handle it here.\n        Assert(propertyId != PropertyIds::length);\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetItemAttributes(this, index, attributes);\n        }\n\n        return __super::SetAttributes(propertyId, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags)\n    {\n        ScriptContext* scriptContext = this->GetScriptContext();\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n                ->SetItemAccessors(this, index, getter, setter);\n        }\n\n        return __super::SetAccessors(propertyId, getter, setter, flags);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemWithAttributes(uint32 index, Var value, PropertyAttributes attributes)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemWithAttributes(this, index, value, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemAttributes(uint32 index, PropertyAttributes attributes)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemAttributes(this, index, attributes);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::SetItemAccessors(uint32 index, Var getter, Var setter)\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)\n            ->SetItemAccessors(this, index, getter, setter);\n    }\n\n    // Check if this objectArray isFrozen.\n    BOOL JavascriptArray::IsObjectArrayFrozen()\n    {\n        // If this is still a JavascriptArray, it's not frozen.\n        return false;\n    }\n\n    JavascriptEnumerator * JavascriptArray::GetIndexEnumerator(EnumeratorFlags flags, ScriptContext* requestContext)\n    {\n        if (!!(flags & EnumeratorFlags::SnapShotSemantics))\n        {\n            return RecyclerNew(GetRecycler(), JavascriptArrayIndexSnapshotEnumerator, this, flags, requestContext);\n        }\n        return RecyclerNew(GetRecycler(), JavascriptArrayIndexEnumerator, this, flags, requestContext);\n    }\n\n    BOOL JavascriptArray::GetNonIndexEnumerator(JavascriptStaticEnumerator * enumerator, ScriptContext* requestContext)\n    {\n        return enumerator->Initialize(nullptr, nullptr, this, EnumeratorFlags::SnapShotSemantics, requestContext, nullptr);\n    }\n\n    BOOL JavascriptArray::IsItemEnumerable(uint32 index)\n    {\n        return true;\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::PreventExtensions()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->PreventExtensions(this);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::Seal()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Seal(this);\n    }\n\n    //\n    // Evolve typeHandlers explicitly so that simple typeHandlers can skip array\n    // handling and only check instance objectArray for numeric propertyIds.\n    //\n    BOOL JavascriptArray::Freeze()\n    {\n        return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Freeze(this);\n    }\n\n    BOOL JavascriptArray::GetSpecialPropertyName(uint32 index, Var *propertyName, ScriptContext * requestContext)\n    {\n        if (index == 0)\n        {\n            *propertyName = requestContext->GetPropertyString(PropertyIds::length);\n            return true;\n        }\n        return false;\n    }\n\n    // Returns the number of special non-enumerable properties this type has.\n    uint JavascriptArray::GetSpecialPropertyCount() const\n    {\n        return _countof(specialPropertyIds);\n    }\n\n    // Returns the list of special non-enumerable properties for the type.\n    PropertyId const * JavascriptArray::GetSpecialPropertyIds() const\n    {\n        return specialPropertyIds;\n    }\n\n    BOOL JavascriptArray::GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        return JavascriptArray::GetProperty(originalInstance, propertyId, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        if (GetPropertyBuiltIns(propertyId, value))\n        {\n            return true;\n        }\n\n        ScriptContext* scriptContext = GetScriptContext();\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            return this->GetItem(this, index, value, scriptContext);\n        }\n\n        return DynamicObject::GetProperty(originalInstance, propertyId, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)\n    {\n        AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),\n            \"Numeric property names should have been converted to uint or PropertyRecord*\");\n\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && GetPropertyBuiltIns(propertyRecord->GetPropertyId(), value))\n        {\n            return true;\n        }\n\n        return DynamicObject::GetProperty(originalInstance, propertyNameString, value, info, requestContext);\n    }\n\n    BOOL JavascriptArray::GetPropertyBuiltIns(PropertyId propertyId, Var* value)\n    {\n        //\n        // length being accessed. Return array length\n        //\n        if (propertyId == PropertyIds::length)\n        {\n            *value = JavascriptNumber::ToVar(this->GetLength(), GetScriptContext());\n            return true;\n        }\n\n        return false;\n    }\n\n    BOOL JavascriptArray::HasItem(uint32 index)\n    {\n        Var value;\n        return this->DirectGetItemAt<Var>(index, &value);\n    }\n\n    BOOL JavascriptArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        return this->DirectGetItemAt<Var>(index, value);\n    }\n\n    BOOL JavascriptNativeIntArray::HasItem(uint32 index)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        int32 value;\n        return this->DirectGetItemAt<int32>(index, &value);\n    }\n\n    BOOL JavascriptNativeFloatArray::HasItem(uint32 index)\n    {\n        double dvalue;\n        return this->DirectGetItemAt<double>(index, &dvalue);\n    }\n\n    BOOL JavascriptNativeIntArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        return JavascriptNativeIntArray::DirectGetVarItemAt(index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeIntArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        int32 intvalue;\n        if (!this->DirectGetItemAt<int32>(index, &intvalue))\n        {\n            return FALSE;\n        }\n        *value = JavascriptNumber::ToVar(intvalue, requestContext);\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeIntArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeIntArray::GetItem(originalInstance, index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeFloatArray::DirectGetVarItemAt(index, value, requestContext);\n    }\n\n    BOOL JavascriptNativeFloatArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)\n    {\n        double dvalue;\n        int32 ivalue;\n        if (!this->DirectGetItemAt<double>(index, &dvalue))\n        {\n            return FALSE;\n        }\n        if (*(uint64*)&dvalue == 0ull)\n        {\n            *value = TaggedInt::ToVarUnchecked(0);\n        }\n        else if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !TaggedInt::IsOverflow(ivalue))\n        {\n            *value = TaggedInt::ToVarUnchecked(ivalue);\n        }\n        else\n        {\n            *value = JavascriptNumber::ToVarWithCheck(dvalue, requestContext);\n        }\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeFloatArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)\n    {\n        return JavascriptNativeFloatArray::GetItem(originalInstance, index, value, requestContext);\n    }\n\n    BOOL JavascriptArray::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        uint32 indexValue;\n        if (propertyId == PropertyIds::length)\n        {\n            return this->SetLength(value);\n        }\n        else if (GetScriptContext()->IsNumericPropertyId(propertyId, &indexValue))\n        {\n            // Call this or subclass method\n            return SetItem(indexValue, value, flags);\n        }\n        else\n        {\n            return DynamicObject::SetProperty(propertyId, value, flags, info);\n        }\n    }\n\n    BOOL JavascriptArray::SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)\n    {\n        AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),\n            \"Numeric property names should have been converted to uint or PropertyRecord*\");\n\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        PropertyRecord const* propertyRecord;\n        this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);\n\n        if (propertyRecord != nullptr && propertyRecord->GetPropertyId() == PropertyIds::length)\n        {\n            return this->SetLength(value);\n        }\n\n        return DynamicObject::SetProperty(propertyNameString, value, flags, info);\n    }\n\n    BOOL JavascriptArray::SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags, SideEffects possibleSideEffects)\n    {\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        ScriptContext* scriptContext = GetScriptContext();\n\n        if (propertyId == PropertyIds::length)\n        {\n            Assert(attributes == PropertyWritable);\n            Assert(IsWritable(propertyId) && !IsConfigurable(propertyId) && !IsEnumerable(propertyId));\n            return this->SetLength(value);\n        }\n\n        uint32 index;\n        if (scriptContext->IsNumericPropertyId(propertyId, &index))\n        {\n            // Call this or subclass method\n            return SetItemWithAttributes(index, value, attributes);\n        }\n\n        return __super::SetPropertyWithAttributes(propertyId, value, attributes, info, flags, possibleSideEffects);\n    }\n\n    BOOL JavascriptArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        this->DirectSetItemAt(index, value);\n        return true;\n    }\n\n    BOOL JavascriptNativeIntArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        int32 iValue;\n        double dValue;\n#if ENABLE_COPYONACCESS_ARRAY\n        JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);\n#endif\n        TypeId typeId = this->TrySetNativeIntArrayItem(value, &iValue, &dValue);\n        if (typeId == TypeIds_NativeIntArray)\n        {\n            this->SetItem(index, iValue);\n        }\n        else if (typeId == TypeIds_NativeFloatArray)\n        {\n            reinterpret_cast<JavascriptNativeFloatArray*>(this)->DirectSetItemAt<double>(index, dValue);\n        }\n        else\n        {\n            this->DirectSetItemAt<Var>(index, value);\n        }\n\n        return TRUE;\n    }\n\n    TypeId JavascriptNativeIntArray::TrySetNativeIntArrayItem(Var value, int32 *iValue, double *dValue)\n    {\n        if (TaggedInt::Is(value))\n        {\n            int32 i = TaggedInt::ToInt32(value);\n            if (i != JavascriptNativeIntArray::MissingItem)\n            {\n                *iValue = i;\n                return TypeIds_NativeIntArray;\n            }\n        }\n        if (JavascriptNumber::Is_NoTaggedIntCheck(value))\n        {\n            bool isInt32;\n            int32 i;\n            double d = JavascriptNumber::GetValue(value);\n            if (JavascriptNumber::TryGetInt32OrUInt32Value(d, &i, &isInt32))\n            {\n                if (isInt32 && i != JavascriptNativeIntArray::MissingItem)\n                {\n                    *iValue = i;\n                    return TypeIds_NativeIntArray;\n                }\n            }\n            else\n            {\n                *dValue = d;\n                JavascriptNativeIntArray::ToNativeFloatArray(this);\n                return TypeIds_NativeFloatArray;\n            }\n        }\n\n        JavascriptNativeIntArray::ToVarArray(this);\n        return TypeIds_Array;\n    }\n\n    BOOL JavascriptNativeIntArray::SetItem(uint32 index, int32 iValue)\n    {\n        if (iValue == JavascriptNativeIntArray::MissingItem)\n        {\n            JavascriptArray *varArr = JavascriptNativeIntArray::ToVarArray(this);\n            varArr->DirectSetItemAt(index, JavascriptNumber::ToVar(iValue, GetScriptContext()));\n            return TRUE;\n        }\n\n        this->DirectSetItemAt(index, iValue);\n        return TRUE;\n    }\n\n    BOOL JavascriptNativeFloatArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)\n    {\n        double dValue;\n        TypeId typeId = this->TrySetNativeFloatArrayItem(value, &dValue);\n        if (typeId == TypeIds_NativeFloatArray)\n        {\n            this->SetItem(index, dValue);\n        }\n        else\n        {\n            this->DirectSetItemAt(index, value);\n        }\n        return TRUE;\n    }\n\n    TypeId JavascriptNativeFloatArray::TrySetNativeFloatArrayItem(Var value, double *dValue)\n    {\n        if (TaggedInt::Is(value))\n        {\n            *dValue = (double)TaggedInt::ToInt32(value);\n            return TypeIds_NativeFloatArray;\n        }\n        else if (JavascriptNumber::Is_NoTaggedIntCheck(value))\n        {\n            *dValue = JavascriptNumber::GetValue(value);\n            return TypeIds_NativeFloatArray;\n        }\n\n        JavascriptNativeFloatArray::ToVarArray(this);\n        return TypeIds_Array;\n    }\n\n    BOOL JavascriptNativeFloatArray::SetItem(uint32 index, double dValue)\n    {\n        if (*(uint64*)&dValue == *(uint64*)&JavascriptNativeFloatArray::MissingItem)\n        {\n            JavascriptArray *varArr = JavascriptNativeFloatArray::ToVarArray(this);\n            varArr->DirectSetItemAt(index, JavascriptNumber::ToVarNoCheck(dValue, GetScriptContext()));\n            return TRUE;\n        }\n\n        this->DirectSetItemAt<double>(index, dValue);\n        return TRUE;\n    }\n\n    BOOL JavascriptArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<Var>(index);\n    }\n\n    BOOL JavascriptNativeIntArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<int32>(index);\n    }\n\n    BOOL JavascriptNativeFloatArray::DeleteItem(uint32 index, PropertyOperationFlags flags)\n    {\n        return this->DirectDeleteItemAt<double>(index);\n    }\n\n    BOOL JavascriptArray::GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache)\n    {\n        return enumerator->Initialize(nullptr, this, this, flags, requestContext, forInCache);\n    }\n\n    BOOL JavascriptArray::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)\n    {\n        stringBuilder->Append(_u('['));\n\n        if (this->length < 10)\n        {\n            auto funcPtr = [&]()\n            {\n                ENTER_PINNED_SCOPE(JavascriptString, valueStr);\n                valueStr = JavascriptArray::JoinHelper(this, GetLibrary()->GetCommaDisplayString(), requestContext);\n                stringBuilder->Append(valueStr->GetString(), valueStr->GetLength());\n                LEAVE_PINNED_SCOPE();\n            };\n\n            if (!requestContext->GetThreadContext()->IsScriptActive())\n            {\n                BEGIN_JS_RUNTIME_CALL(requestContext);\n                {\n                    funcPtr();\n                }\n                END_JS_RUNTIME_CALL(requestContext);\n            }\n            else\n            {\n                funcPtr();\n            }\n        }\n        else\n        {\n            stringBuilder->AppendCppLiteral(_u(\"...\"));\n        }\n\n        stringBuilder->Append(_u(']'));\n\n        return TRUE;\n    }\n\n    BOOL JavascriptArray::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)\n    {\n        stringBuilder->AppendCppLiteral(_u(\"Object, (Array)\"));\n        return TRUE;\n    }\n\n    bool JavascriptNativeArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeArray::Is(typeId);\n    }\n\n    bool JavascriptNativeArray::Is(TypeId typeId)\n    {\n        return JavascriptNativeIntArray::Is(typeId) || JavascriptNativeFloatArray::Is(typeId);\n    }\n\n    JavascriptNativeArray* JavascriptNativeArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeArray'\");\n\n        return static_cast<JavascriptNativeArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    bool JavascriptNativeIntArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeIntArray::Is(typeId);\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    bool JavascriptCopyOnAccessNativeIntArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptCopyOnAccessNativeIntArray::Is(typeId);\n    }\n#endif\n\n    bool JavascriptNativeIntArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_NativeIntArray;\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    bool JavascriptCopyOnAccessNativeIntArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_CopyOnAccessNativeIntArray;\n    }\n#endif\n\n    bool JavascriptNativeIntArray::IsNonCrossSite(Var aValue)\n    {\n        bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue);\n        Assert(ret == (JavascriptNativeIntArray::Is(aValue) && !JavascriptNativeIntArray::FromVar(aValue)->IsCrossSiteObject()));\n        return ret;\n    }\n\n    JavascriptNativeIntArray* JavascriptNativeIntArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeIntArray'\");\n\n        return static_cast<JavascriptNativeIntArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n#if ENABLE_COPYONACCESS_ARRAY\n    JavascriptCopyOnAccessNativeIntArray* JavascriptCopyOnAccessNativeIntArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptCopyOnAccessNativeIntArray'\");\n\n        return static_cast<JavascriptCopyOnAccessNativeIntArray *>(RecyclableObject::FromVar(aValue));\n    }\n#endif\n\n    bool JavascriptNativeFloatArray::Is(Var aValue)\n    {\n        TypeId typeId = JavascriptOperators::GetTypeId(aValue);\n        return JavascriptNativeFloatArray::Is(typeId);\n    }\n\n    bool JavascriptNativeFloatArray::Is(TypeId typeId)\n    {\n        return typeId == TypeIds_NativeFloatArray;\n    }\n\n    bool JavascriptNativeFloatArray::IsNonCrossSite(Var aValue)\n    {\n        bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue);\n        Assert(ret == (JavascriptNativeFloatArray::Is(aValue) && !JavascriptNativeFloatArray::FromVar(aValue)->IsCrossSiteObject()));\n        return ret;\n    }\n\n    JavascriptNativeFloatArray* JavascriptNativeFloatArray::FromVar(Var aValue)\n    {\n        AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeFloatArray'\");\n\n        return static_cast<JavascriptNativeFloatArray *>(RecyclableObject::FromVar(aValue));\n    }\n\n    template int   Js::JavascriptArray::GetParamForIndexOf<unsigned int>(unsigned int, Js::Arguments const&, void*&, unsigned int&, Js::ScriptContext*);\n    template bool  Js::JavascriptArray::ArrayElementEnumerator::MoveNext<void*>();\n    template void  Js::JavascriptArray::SetArrayLiteralItem<void*>(unsigned int, void*);\n    template void* Js::JavascriptArray::TemplatedIndexOfHelper<false, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);\n    template void* Js::JavascriptArray::TemplatedIndexOfHelper<true, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);\n} //namespace Js\n", "//-------------------------------------------------------------------------------------------------------\n// Copyright (C) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n//-------------------------------------------------------------------------------------------------------\n\n//Note: see function  ArraySpliceHelper of JavascriptArray.cpp\n\nif (this.WScript && this.WScript.LoadScriptFile) { // Check for running in ch\n    this.WScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");\n}\n\nvar restorePropertyFromDescriptor = function (obj, prop, desc) {\n    if (typeof desc == 'undefined') {\n        delete obj[prop];\n    } else {\n        Object.defineProperty(obj, prop, desc);\n    }\n}\n\nvar tests = [\n    {\n        name: \"OS7342663:OOB writes using type confusion in InternalCopyArrayElements\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                class MyArray extends Uint32Array { }\n                Object.defineProperty(MyArray, Symbol.species, { value: function() { return arr1; } });\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [float_val, float_val, float_val, float_val];\n                test.length = 0x1000;\n                test.__proto__ = new MyArray(0);\n\n                var res = Array.prototype.slice.apply(test, []);  // OOB write\n                assert.areEqual(0x1000, res.length, \"res.length == 0x1000\");\n                assert.areEqual(float_val, res[0], \"res[0] == float_val\");\n                assert.areEqual(float_val, res[1], \"res[1] == float_val\");\n                assert.areEqual(float_val, res[2], \"res[2] == float_val\");\n                assert.areEqual(float_val, res[3], \"res[3] == float_val\");\n                assert.areEqual(undefined, res[4], \"res[4] == float_val\");\n                assert.areEqual(undefined, res[0xfff], \"res[0xfff] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342689:OOB writes using type confusion in InternalFillFromPrototypes\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead,\n                0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe,\n                0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead,\n                0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                class MyArray extends Uint32Array { }\n                Object.defineProperty(MyArray, Symbol.species, { value: function() { return arr1; } });\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [{}];\n                delete test[0];\n                test.length = 0x1000;\n                var src = [float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val,\n                float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val, float_val];\n                test.__proto__ = src;\n                test.__proto__.__proto__ = new MyArray(0);\n\n               //this will write 0xfffc0daddeadbabe to [arr1] + 0x1D8\n                var res = Array.prototype.slice.apply(test, [])\n                assert.areEqual(0x1000, res.length, \"res.length == 0x1000\");\n                assert.areEqual(float_val, res[0], \"res[0] == float_val\");\n                assert.areEqual(float_val, res[1], \"res[1] == float_val\");\n                assert.areEqual(float_val, res[2], \"res[2] == float_val\");\n                assert.areEqual(float_val, res[src.length-1], \"res[src.length-1] == float_val\");\n                assert.areEqual(undefined, res[src.length], \"res[src] == undefined\");\n                assert.areEqual(undefined, res[0xfff], \"res[0xfff] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7307908:type confusion in Array.prototype.slice\",\n        body: function ()\n        {\n            function test() {\n                var arr = [1, 2]\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n               //Our species function will get called during chakra!Js::JavascriptArray::SliceHelper<unsigned int>\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                           //change 'arr' from TypeIds_NativeIntArray to TypeIds_Array\n                            arr[0] = WScript;\n\n                           //return a TypeIds_NativeIntArray so we can read back out the 64 bit pointer as two 32bit ints.\n                            return [];\n                        }\n                    }\n                );\n\n               //trigger the bug and retrieve a TypeIds_NativeIntArray array containing a pointer.\n                var brr = arr.slice();\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(2, brr[1], \"brr[0] == WScript\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342791:type confusion in Array.from\",\n        body: function ()\n        {\n            function test() {\n                var arr1 = [0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe, 0xdead, 0xbabe];\n\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var test = [float_val, float_val, float_val, float_val];\n                delete test[0];\n                delete test[1];\n                delete test[2];\n\n                var res = Array.from.apply(function(){return arr1}, [test]);\n                assert.areEqual(4, res.length, \"res.length == 4\");\n                assert.areEqual(undefined, res[0], \"res[0] == undefined\");\n                assert.areEqual(undefined, res[1], \"res[1] == undefined\");\n                assert.areEqual(undefined, res[2], \"res[2] == undefined\");\n                assert.areEqual(float_val, res[3], \"res[3] == float_val\");\n\n                assert.areEqual(['1','2','3'], Array.from.apply(()=>new Array(), [\"123\"]), \"Array.from on iterable\");\n                assert.areEqual([1,2,3], Array.from.apply(()=>new Array(), [{\"0\":1, \"1\":2, \"2\":3, \"length\":3}]), \"Array.from on non-iterable\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342844:type confusion in Array.of\",\n        body: function ()\n        {\n            function test() {\n                var brr = Array.of.call(()=>[ 1, 2, 3, 4 ],\n                    WScript, // supply 2 copies of target so the brr array will have a length of 2 and we can read the 64bit pointer.\n                    WScript\n                );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"res[0] == WScript\");\n                assert.areEqual(WScript, brr[1], \"res[1] == WScript\");\n                assert.areEqual(undefined, brr[2], \"res[2] == undefined\");\n                assert.areEqual(undefined, brr[3], \"res[3] == undefined\");\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342907:type confusion in Array.prototype.map\",\n        body: function ()\n        {\n            function test() {\n                var arr = [ 1, 2 ];\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                            return [];\n                        }\n                    }\n                );\n\n               //The value returned from our callback is directly set into the array whose type we create via the species.\n                var brr = arr.map( function( v )\n                    {\n                        if( v == 1 )\n                            return WScript;\n                    }\n                );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(undefined, brr[1], \"brr[1] == undefined\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.map with Proxy\",\n        body: function ()\n        {\n            function test() {\n                var d = [1,2,3];\n                class dummy {\n                    constructor() {\n                        return d;\n                    }\n                }\n\n                var handler = {\n                    get: function(target, name) {\n                        if(name == \"length\") {\n                            return 0x100;\n                        }\n\n                        return {[Symbol.species] : dummy};\n                    },\n\n                    has: function(target, name) {\n                        return true;\n                    }\n                };\n\n                var p = new Proxy([], handler);\n                var a = new Array(1,2,3);\n\n                function test(){\n                    return 0x777777777777;\n                }\n\n                var o = a.map.call(p, test);\n                assert.areEqual(Array(0x100).fill(0x777777777777), o);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"OS7342965:type confusion in Array.prototype.splice\",\n        body: function ()\n        {\n            function test() {\n               //create a TypeIds_Array holding two 64 bit values (The same amount of space for four 32 bit values).\n                var arr = [ WScript, WScript ];\n                var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n\n               //Our species function will get called during chakra!Js::JavascriptArray::EntrySplice\n                Object.defineProperty(\n                    arr.constructor,\n                    Symbol.species,\n                    {\n                        value : function()\n                        {\n                           //return a TypeIds_NativeIntArray so we can read back out a 64 bit pointer as two 32bit ints.\n                            return [ 1, 2, 3, 4 ];\n                        }\n                    }\n                );\n\n               //trigger the bug and retrieve a TypeIds_NativeIntArray array containing a pointer. The helper\n               //method ArraySegmentSpliceHelper<Var> will directly copy over the TypeIds_Array segment data\n               //into the TypeIds_NativeIntArray segment.\n                var brr = arr.splice( 0, 2 );\n\n                assert.areEqual(2, brr.length, \"brr.length == 2\");\n                assert.areEqual(WScript, brr[0], \"brr[0] == WScript\");\n                assert.areEqual(WScript, brr[1], \"brr[1] == WScript\");\n                assert.areEqual(undefined, brr[2], \"brr[2] == undefined\");\n                assert.areEqual(undefined, brr[3], \"brr[3] == undefined\");\n\n                restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.join\",\n        body: function ()\n        {\n            function test() {\n                var a = [0, 1, 2, 3];\n                var b = [];\n                delete a[0];\n                Object.setPrototypeOf(a, b)\n                Object.defineProperty(b, \"0\",\n                    {\n                        get: function() {\n                                a[2] = \"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(\"-1,1,abc,3\", a.join());\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.indexOf\",\n        body: function ()\n        {\n            function test() {\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var a = [0, 1, 2, 3];\n                var b = [];\n                delete a[1];\n                Object.setPrototypeOf(a, b);\n                Object.defineProperty(b, \"1\",\n                    {\n                        get: function() {\n                                a[2] = float_val; //\"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(3, a.indexOf(3));\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Array.prototype.lastIndexOf\",\n        body: function ()\n        {\n            function test() {\n                var float_val = 0xdaddeadbabe * 4.9406564584124654E-324;\n                var a = [3, 2, 1, 0];\n                var b = [];\n                delete a[3];\n                Object.setPrototypeOf(a, b);\n                Object.defineProperty(b, \"3\",\n                    {\n                        get: function() {\n                                a[1] = float_val; //\"abc\";\n                                return -1;\n                            }\n                    });\n\n                assert.areEqual(0, a.lastIndexOf(3));\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"type confusion in Function.prototype.apply\",\n        body: function ()\n        {\n            function test() {\n                var t = [1,2,3];\n\n                function f(){\n                    var h = [];\n                    var a = [...arguments]\n\n                    for(item in a){\n                        var n = new Number(a[item]);\n\n                        if( n < 0) {\n                            n = n + 0x100000000;\n                        }\n\n                        h.push(n.toString(16));\n                    }\n\n                    return h;\n                }\n\n                var q = f;\n\n                t.length = 20;\n                var o = {};\n                Object.defineProperty(o, '3', {\n                    get: function() {\n                        var ta = [];\n                        ta.fill.call(t, \"natalie\");\n                        return 5;\n                    }\n                });\n\n                t.__proto__ = o;\n\n                var j = [];\n                assert.areEqual(\"1,2,3,5,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN\", f.apply(null, t).toString());\n            }\n            test();\n            test();\n            test();\n        }\n    },\n    {\n        name: \"[MSRC34910] type confusion in Array.prototype.filter\",\n        body: function ()\n        {\n            function mappingFn(elem, index, arr) {\n                arr[1] = 'hello';\n                return true;\n            }\n\n            var arr = [1, 2, 3];\n\n            var desc = Object.getOwnPropertyDescriptor(arr.constructor, Symbol.species);\n            Object.defineProperty(arr.constructor, Symbol.species, { get : function () {  return function() { return [22, 33]; } } } );\n            var b = Array.prototype.filter.call(arr, mappingFn);\n            assert.areEqual('hello', b[1]);\n\n            restorePropertyFromDescriptor(arr.constructor, Symbol.species, desc);\n        }\n    },\n    {\n        name: \"[MSRC35046] heap overflow in Array.prototype.splice\",\n        body: function ()\n        {\n            var a = [];\n            var o = {};\n\n            Object.defineProperty(o, 'constructor', {\n                get: function() {\n                    a.length = 0xfffffffe;\n                    [].fill.call(a, 0, 0xfffff000, 0xfffffffe);\n                    return Array;\n                }});\n\n            a.__proto__ = o;\n            var q = new Array(50).fill(1.1);\n\n            var b = [].splice.call(a, 0, 0, ...q);\n            assert.areEqual(50, a.length);\n            assert.areEqual(q, a);\n        }\n    },\n    {\n        name: \"[MSRC35086] type confusion in FillFromPrototypes\",\n        body: function ()\n        {\n            var a = new Array(0x11111111, 0x22222222, 0x33333333, 0x44444444, 0x12121212);\n\n            var handler = {\n                    getPrototypeOf: function(target, name) {\n                        return a;\n                    }\n                };\n\n            var p = new Proxy([], handler);\n            var b = [{}, [], \"abc\"];\n\n            b.__proto__ = p;\n            b.length = 4;\n            var c = [[],\"abc\",1145324612];\n\n            a.shift.call(b);\n            assert.areEqual(3, b.length);\n            assert.areEqual([], b[0]);\n            assert.areEqual(\"abc\", b[1]);\n            assert.areEqual(1145324612, b[2]);\n        }\n    },\n    {\n        name: \"[MSRC35272] type confusion in JSON.parse\",\n        body: function ()\n        {\n            var a = 1;\n            var once = false;\n            function f(){\n                if(!once){\n                    a = new Array(2)\n                    this[2] = a;\n                }\n                once = true;\n                return 0x41414141;\n            }\n\n            var r = JSON.parse(\"[1111, 22222, 333333]\", f);\n            assert.areEqual(0x41414141, r);\n        }\n    },\n    {\n        name: \"[MSRC35383] type confusion in Array.prototype.concat\",\n        body: function ()\n        {\n            var n = [];\n            for (var i = 0; i < 0x10; i++)\n                n.push([0x11111111, 0x11111111, 0, 0x11111111,0x11111111, 0x11111111, 0, 0x11111111,0x11111111, 0x11111111, 0, 0x11111111,0x11111111,0x11111111, 0, 0x11111111,0x11111111 ,1 ,2 ,3 ,4]);\n\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {  return n[3]; }; };\n            }\n\n            var f = function(a){ return a; }\n\n            var x = [\"dabao\", 0, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    return (p == \"constructor\") ? fake : x[p];\n                }\n            });\n\n            assert.areEqual(x, Array.prototype.concat.apply(y));\n        }\n    },\n    {\n        name: \"[MSRC35389] type confusion in Array.prototype.splice\",\n        body: function ()\n        {\n            var arr = [0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344]\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {\n                    return arr;\n                }; };\n            }\n\n            var x = [0, 2, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    return (p == \"constructor\") ? fake : x[p];\n                }\n            });\n\n            Array.prototype.splice.apply(y);\n            assert.areEqual(x, y);\n        }\n    },\n    {\n        name: \"[MSRC35389 variation] type confusion in Array.prototype.slice\",\n        body: function ()\n        {\n            var arr = [0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344,0x41424344];\n\n            class fake extends Object {\n                static get [Symbol.species]() { return function() {\n                    return arr;\n                }; };\n            }\n\n            var x = [0, 2, 0, 0x41414141];\n            var y = new Proxy(x, {\n                get: function(t, p, r) {\n                    if (p == \"constructor\")\n                        return fake\n                    if (p == 'length');\n                        return 1;\n                    return x[p];\n                },\n                has: function() {\n                    return false;\n                }\n            });\n\n            assert.areEqual([0x41424344], Array.prototype.slice.call(y));\n        }\n    },\n    {\n        name: \"[MSRC34994,35226] heap overflow in Array.prototype.reverse\",\n        body: function ()\n        {\n            var count = 0;\n            arr = new Array(100);\n            var desc = Object.getOwnPropertyDescriptor(Array.prototype, 1);\n            Object.defineProperty(Array.prototype, 1, { get: function () {\n                    count++;\n                    if (count == 1) {\n                        arr.push(null);\n                    }\n                }});\n\n            arr.reverse();\n            restorePropertyFromDescriptor(Array.prototype, 1, desc);\n            assert.areEqual(101, arr.length);\n        }\n    },\n    {\r\n        name: \"Heap overread when splice mutates the array when executing slice\",\r\n        body: function ()\r\n        {\r\n            var getterCalled = false;\r\n            var a = [1, 2];\r\n            for (var i = 0; i < 100 * 1024; i++) {\r\n                a.push(i);\r\n            }\r\n            delete a[0]; // Make a missing item\r\n            var protoObj = [11];\r\n            Object.defineProperty(protoObj, '0', {\r\n                get : function () {\r\n                    getterCalled = true;\r\n                    Object.setPrototypeOf(a, Array.prototype);\r\n                    a.splice(0); // head seg is now length=0\r\n                    return 42;\r\n                },\r\n                configurable : true\r\n            });\r\n            Object.setPrototypeOf(a, protoObj);\r\n            var b = a.slice();\r\n            assert.isTrue(getterCalled);\r\n            assert.areEqual(0, a.length, \"Getter will splice the array to zero length\");\r\n            assert.areEqual(100 * 1024 + 2, b.length, \"Validating that slice will return the full array even though splice is deleting the whole array\");\r\n        }\r\n    },\r\n];\ntestRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });\n"], "filenames": ["lib/Runtime/Library/JavascriptArray.cpp", "test/Array/Array_TypeConfusion_bugs.js"], "buggy_code_start_loc": [479, 595], "buggy_code_end_loc": [5771, 595], "fixing_code_start_loc": [480, 596], "fixing_code_end_loc": [5776, 623], "type": "CWE-200", "message": "An information disclosure vulnerability in Microsoft scripting engine allows remote attackers to obtain sensitive information from process memory via a crafted web site, aka \"Microsoft Browser Information Disclosure Vulnerability.\"", "other": {"cve": {"id": "CVE-2017-0196", "sourceIdentifier": "secure@microsoft.com", "published": "2017-07-17T13:18:11.297", "lastModified": "2017-07-21T16:23:59.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An information disclosure vulnerability in Microsoft scripting engine allows remote attackers to obtain sensitive information from process memory via a crafted web site, aka \"Microsoft Browser Information Disclosure Vulnerability.\""}, {"lang": "es", "value": "Una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n en el motor de scripting de Microsoft, permite a los atacantes remotos obtener informaci\u00f3n confidencial de la memoria del proceso por medio de un sitio web creado, tambi\u00e9n se conoce como \"Microsoft Browser Information Disclosure Vulnerability\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge:*:*:*:*:*:*:*:*", "matchCriteriaId": "8BD5B232-95EA-4F8E-8C7D-7976877AD243"}]}]}], "references": [{"url": "https://github.com/Microsoft/ChakraCore/commit/065b7978c40ded35c356ced6cd922a40156c9c46", "source": "secure@microsoft.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Microsoft/ChakraCore/commit/065b7978c40ded35c356ced6cd922a40156c9c46"}}