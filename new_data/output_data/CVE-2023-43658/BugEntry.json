{"buggy_code": ["3.1.999: afc2ee684de41601d6cecc46713d139760f176a6\n3.1.0.beta3: 10077ca904956005f9fa83c3d9fb124b59e8c47b\n2.9.0.beta13: b4c366b35d6f9778e54a878aa083348e8a45e86e\n2.9.0.beta9: 6f16ae10dc0306d6e1369e0d1414416d7e72141d\n2.9.0.beta7: ec34a96f215dce9c7321dfe04f6dd0172a197711\n2.9.0.beta3: 9ab1b76a1425304f3434b49db49cb4eec8919cf6\n2.7.0.beta3: 52e22b9972dc79c67f6a2f7c4c9f918307222030\n", "# frozen_string_literal: true\n\n# name: discourse-calendar\n# about: Display a calendar in the first post of a topic\n# version: 0.3\n# author: Daniel Waterworth, Joffrey Jaffeux\n# url: https://github.com/discourse/discourse-calendar\n\nlibdir = File.join(File.dirname(__FILE__), \"vendor/holidays/lib\")\n$LOAD_PATH.unshift(libdir) unless $LOAD_PATH.include?(libdir)\n\ngem \"rrule\", \"0.4.4\", require: false\n\nrequire_relative \"lib/calendar_settings_validator.rb\"\n\nenabled_site_setting :calendar_enabled\n\nregister_asset \"stylesheets/vendor/fullcalendar.min.css\"\nregister_asset \"stylesheets/common/discourse-calendar.scss\"\nregister_asset \"stylesheets/common/discourse-calendar-holidays.scss\"\nregister_asset \"stylesheets/common/upcoming-events-calendar.scss\"\nregister_asset \"stylesheets/common/discourse-post-event.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-preview.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-builder.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-invitees.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-upcoming-events.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-core-ext.scss\"\nregister_asset \"stylesheets/mobile/discourse-post-event-core-ext.scss\", :mobile\nregister_asset \"stylesheets/common/discourse-post-event-bulk-invite-modal.scss\"\nregister_asset \"stylesheets/mobile/discourse-calendar.scss\", :mobile\nregister_asset \"stylesheets/mobile/discourse-post-event.scss\", :mobile\nregister_asset \"stylesheets/desktop/discourse-calendar.scss\", :desktop\nregister_asset \"stylesheets/colors.scss\", :color_definitions\nregister_asset \"stylesheets/common/user-preferences.scss\"\nregister_svg_icon \"fas fa-calendar-day\"\nregister_svg_icon \"fas fa-clock\"\nregister_svg_icon \"fas fa-file-csv\"\nregister_svg_icon \"fas fa-star\"\nregister_svg_icon \"fas fa-file-upload\"\n\nmodule ::DiscourseCalendar\n  PLUGIN_NAME = \"discourse-calendar\"\n\n  # Type of calendar ('static' or 'dynamic')\n  CALENDAR_CUSTOM_FIELD = \"calendar\"\n\n  # User custom field set when user is on holiday\n  HOLIDAY_CUSTOM_FIELD = \"on_holiday\"\n\n  # List of all users on holiday\n  USERS_ON_HOLIDAY_KEY = \"users_on_holiday\"\n\n  # User region used in finding holidays\n  REGION_CUSTOM_FIELD = \"holidays-region\"\n\n  # List of groups\n  GROUP_TIMEZONES_CUSTOM_FIELD = \"group-timezones\"\n\n  def self.users_on_holiday\n    PluginStore.get(PLUGIN_NAME, USERS_ON_HOLIDAY_KEY) || []\n  end\n\n  def self.users_on_holiday=(usernames)\n    PluginStore.set(PLUGIN_NAME, USERS_ON_HOLIDAY_KEY, usernames)\n  end\nend\n\nmodule ::DiscoursePostEvent\n  PLUGIN_NAME = \"discourse-post-event\"\n\n  # Topic where op has a post event custom field\n  TOPIC_POST_EVENT_STARTS_AT = \"TopicEventStartsAt\"\n  TOPIC_POST_EVENT_ENDS_AT = \"TopicEventEndsAt\"\nend\n\nrequire_relative \"lib/discourse_calendar/engine\"\n\nafter_initialize do\n  reloadable_patch do\n    Category.register_custom_field_type(\"sort_topics_by_event_start_date\", :boolean)\n    Category.register_custom_field_type(\"disable_topic_resorting\", :boolean)\n    Site.preloaded_category_custom_fields << \"sort_topics_by_event_start_date\"\n    Site.preloaded_category_custom_fields << \"disable_topic_resorting\"\n  end\n\n  add_to_serializer :basic_category, :sort_topics_by_event_start_date do\n    object.custom_fields[\"sort_topics_by_event_start_date\"]\n  end\n\n  add_to_serializer :basic_category, :disable_topic_resorting do\n    object.custom_fields[\"disable_topic_resorting\"]\n  end\n\n  reloadable_patch do\n    TopicQuery.add_custom_filter(:order_by_event_date) do |results, topic_query|\n      if SiteSetting.sort_categories_by_event_start_date_enabled &&\n           topic_query.options[:category_id]\n        category = Category.find_by(id: topic_query.options[:category_id])\n        if category && category.custom_fields &&\n             category.custom_fields[\"sort_topics_by_event_start_date\"]\n          results =\n            results.joins(\n              \"LEFT JOIN topic_custom_fields AS custom_fields on custom_fields.topic_id = topics.id\n            AND custom_fields.name = '#{DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT}'\n            \",\n            ).reorder(\"topics.pinned_at ASC, custom_fields.value ASC\")\n        end\n      end\n      results\n    end\n  end\n\n  # DISCOURSE CALENDAR HOLIDAYS\n\n  add_admin_route \"admin.calendar\", \"calendar\"\n\n  # DISCOURSE POST EVENT\n\n  require_relative \"jobs/regular/discourse_post_event/bulk_invite\"\n  require_relative \"jobs/regular/discourse_post_event/bump_topic\"\n  require_relative \"jobs/regular/discourse_post_event/send_reminder\"\n  require_relative \"lib/discourse_post_event/engine\"\n  require_relative \"lib/discourse_post_event/event_finder\"\n  require_relative \"lib/discourse_post_event/event_parser\"\n  require_relative \"lib/discourse_post_event/event_validator\"\n  require_relative \"lib/discourse_post_event/export_csv_controller_extension\"\n  require_relative \"lib/discourse_post_event/export_csv_file_extension\"\n  require_relative \"lib/discourse_post_event/post_extension\"\n  require_relative \"lib/discourse_post_event/rrule_generator\"\n\n  ::ActionController::Base.prepend_view_path File.expand_path(\"../app/views\", __FILE__)\n\n  reloadable_patch do\n    ExportCsvController.class_eval { prepend DiscoursePostEvent::ExportCsvControllerExtension }\n    Jobs::ExportCsvFile.class_eval { prepend DiscoursePostEvent::ExportPostEventCsvReportExtension }\n    Post.class_eval { prepend DiscoursePostEvent::PostExtension }\n  end\n\n  add_to_class(:user, :can_create_discourse_post_event?) do\n    return @can_create_discourse_post_event if defined?(@can_create_discourse_post_event)\n    @can_create_discourse_post_event =\n      begin\n        return true if staff?\n        allowed_groups = SiteSetting.discourse_post_event_allowed_on_groups.to_s.split(\"|\").compact\n        allowed_groups.present? && groups.where(id: allowed_groups).exists?\n      rescue StandardError\n        false\n      end\n  end\n\n  add_to_class(:guardian, :can_act_on_invitee?) do |invitee|\n    user && (user.staff? || user.id == invitee.user_id)\n  end\n\n  add_to_class(:guardian, :can_create_discourse_post_event?) do\n    user && user.can_create_discourse_post_event?\n  end\n\n  add_to_serializer(:current_user, :can_create_discourse_post_event) do\n    object.can_create_discourse_post_event?\n  end\n\n  add_to_class(:user, :can_act_on_discourse_post_event?) do |event|\n    return @can_act_on_discourse_post_event if defined?(@can_act_on_discourse_post_event)\n    @can_act_on_discourse_post_event =\n      begin\n        return true if staff?\n        can_create_discourse_post_event? && Guardian.new(self).can_edit_post?(event.post)\n      rescue StandardError\n        false\n      end\n  end\n\n  add_to_class(:guardian, :can_act_on_discourse_post_event?) do |event|\n    user && user.can_act_on_discourse_post_event?(event)\n  end\n\n  add_class_method(:group, :discourse_post_event_allowed_groups) do\n    where(id: SiteSetting.discourse_post_event_allowed_on_groups.split(\"|\").compact)\n  end\n\n  TopicView.on_preload do |topic_view|\n    if SiteSetting.discourse_post_event_enabled\n      topic_view.instance_variable_set(:@posts, topic_view.posts.includes(:event))\n    end\n  end\n\n  add_to_serializer(\n    :post,\n    :event,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled && !object.nil? && !object.deleted_at.present?\n    end,\n  ) { DiscoursePostEvent::EventSerializer.new(object.event, scope: scope, root: false) }\n\n  on(:post_created) { |post| DiscoursePostEvent::Event.update_from_raw(post) }\n\n  on(:post_edited) { |post| DiscoursePostEvent::Event.update_from_raw(post) }\n\n  on(:post_destroyed) do |post|\n    if SiteSetting.discourse_post_event_enabled && post.event\n      post.event.update!(deleted_at: Time.now)\n    end\n  end\n\n  on(:post_recovered) do |post|\n    post.event.update!(deleted_at: nil) if SiteSetting.discourse_post_event_enabled && post.event\n  end\n\n  add_preloaded_topic_list_custom_field DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT\n\n  add_to_serializer(\n    :topic_view,\n    :event_starts_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title &&\n        object.topic.custom_fields.keys.include?(DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT)\n    end,\n  ) { object.topic.custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT] }\n\n  add_to_class(:topic, :event_starts_at) do\n    @event_starts_at ||= custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT]\n  end\n\n  add_to_serializer(\n    :topic_list_item,\n    :event_starts_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title && object.event_starts_at\n    end,\n  ) { object.event_starts_at }\n\n  add_preloaded_topic_list_custom_field DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT\n\n  add_to_serializer(\n    :topic_view,\n    :event_ends_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title &&\n        object.topic.custom_fields.keys.include?(DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT)\n    end,\n  ) { object.topic.custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT] }\n\n  add_to_class(:topic, :event_ends_at) do\n    @event_ends_at ||= custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT]\n  end\n\n  add_to_serializer(\n    :topic_list_item,\n    :event_ends_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title && object.event_ends_at\n    end,\n  ) { object.event_ends_at }\n\n  # DISCOURSE CALENDAR\n\n  require_relative \"jobs/scheduled/create_holiday_events\"\n  require_relative \"jobs/scheduled/delete_expired_event_posts\"\n  require_relative \"jobs/scheduled/monitor_event_dates\"\n  require_relative \"jobs/scheduled/update_holiday_usernames\"\n  require_relative \"lib/calendar_validator\"\n  require_relative \"lib/calendar\"\n  require_relative \"lib/event_validator\"\n  require_relative \"lib/group_timezones\"\n  require_relative \"lib/holiday_status\"\n  require_relative \"lib/time_sniffer\"\n  require_relative \"lib/users_on_holiday\"\n\n  register_post_custom_field_type(DiscourseCalendar::CALENDAR_CUSTOM_FIELD, :string)\n  register_post_custom_field_type(DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD, :json)\n  TopicView.default_post_custom_fields << DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD\n\n  register_user_custom_field_type(DiscourseCalendar::HOLIDAY_CUSTOM_FIELD, :boolean)\n\n  allow_staff_user_custom_field(DiscourseCalendar::HOLIDAY_CUSTOM_FIELD)\n  DiscoursePluginRegistry.serialized_current_user_fields << DiscourseCalendar::REGION_CUSTOM_FIELD\n  register_editable_user_custom_field(DiscourseCalendar::REGION_CUSTOM_FIELD)\n\n  on(:site_setting_changed) do |name, old_value, new_value|\n    next unless %i[all_day_event_start_time all_day_event_end_time].include? name\n\n    Post\n      .where(id: CalendarEvent.select(:post_id).distinct)\n      .each { |post| CalendarEvent.update(post) }\n  end\n\n  on(:post_process_cooked) do |doc, post|\n    DiscourseCalendar::Calendar.update(post)\n    DiscourseCalendar::GroupTimezones.update(post)\n    CalendarEvent.update(post)\n  end\n\n  on(:post_recovered) do |post, _, _|\n    DiscourseCalendar::Calendar.update(post)\n    DiscourseCalendar::GroupTimezones.update(post)\n    CalendarEvent.update(post)\n  end\n\n  on(:post_destroyed) do |post, _, _|\n    DiscourseCalendar::Calendar.destroy(post)\n    CalendarEvent.where(post_id: post.id).destroy_all\n  end\n\n  validate(:post, :validate_calendar) do |force = nil|\n    return unless self.raw_changed? || force\n\n    validator = DiscourseCalendar::CalendarValidator.new(self)\n    validator.validate_calendar\n  end\n\n  validate(:post, :validate_event) do |force = nil|\n    return unless self.raw_changed? || force\n    return if self.is_first_post?\n\n    # Skip if not a calendar topic\n    return if !self&.topic&.first_post&.custom_fields&.[](DiscourseCalendar::CALENDAR_CUSTOM_FIELD)\n\n    validator = DiscourseCalendar::EventValidator.new(self)\n    validator.validate_event\n  end\n\n  add_to_class(:post, :has_group_timezones?) do\n    custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD].present?\n  end\n\n  add_to_class(:post, :group_timezones) do\n    custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] || {}\n  end\n\n  add_to_class(:post, :group_timezones=) do |val|\n    if val.present?\n      custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] = val\n    else\n      custom_fields.delete(DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD)\n    end\n  end\n\n  add_to_serializer(:post, :calendar_details, include_condition: -> { object.is_first_post? }) do\n    grouped = {}\n    standalones = []\n\n    CalendarEvent\n      .where(topic_id: object.topic_id)\n      .order(:start_date, :end_date)\n      .each do |event|\n        if event.post_id\n          standalones << {\n            type: :standalone,\n            post_number: event.post_number,\n            message: event.description,\n            from: event.start_date,\n            to: event.end_date,\n            username: event.username,\n            recurring: event.recurrence,\n            post_url: Post.url(\"-\", event.topic_id, event.post_number),\n            timezone: event.timezone,\n          }\n        else\n          identifier = \"#{event.region.split(\"_\").first}-#{event.start_date.strftime(\"%j\")}\"\n\n          grouped[identifier] ||= { type: :grouped, from: event.start_date, name: [], users: [] }\n\n          user = User.find_by_username(event.username)\n\n          grouped[identifier][:name] << event.description\n          grouped[identifier][:users] << {\n            username: event.username,\n            timezone: user.present? ? user.user_option.timezone : nil,\n          }\n        end\n      end\n\n    grouped.each do |_, v|\n      v[:name].sort!.uniq!\n      v[:name] = v[:name].join(\", \")\n      v[:users].sort! { |a, b| a[:username] <=> b[:username] }\n      v[:users].uniq! { |u| u[:username] }\n    end\n\n    standalones + grouped.values\n  end\n\n  add_to_serializer(\n    :post,\n    :group_timezones,\n    include_condition: -> do\n      post_custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD].present?\n    end,\n  ) do\n    result = {}\n    group_timezones = post_custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] || {}\n    group_names = group_timezones[\"groups\"] || []\n\n    if group_names.present?\n      users =\n        User\n          .joins(:groups, :user_option)\n          .where(\"groups.name\": group_names)\n          .select(\"users.*\", \"groups.name AS group_name\", \"user_options.timezone\")\n\n      users.each do |u|\n        result[u.group_name] ||= []\n        result[u.group_name] << UserTimezoneSerializer.new(u, root: false).as_json\n      end\n    end\n\n    result\n  end\n\n  add_to_serializer(:site, :users_on_holiday, include_condition: -> { scope.is_staff? }) do\n    DiscourseCalendar.users_on_holiday\n  end\n\n  on(:reduce_cooked) do |fragment, post|\n    if SiteSetting.discourse_post_event_enabled\n      fragment\n        .css(\".discourse-post-event\")\n        .each do |event_node|\n          starts_at = event_node[\"data-start\"]\n          ends_at = event_node[\"data-end\"]\n          dates = \"#{starts_at} (#{event_node[\"data-timezone\"] || \"UTC\"})\"\n          dates = \"#{dates} \u2192 #{ends_at} (#{event_node[\"data-timezone\"] || \"UTC\"})\" if ends_at\n\n          event_name = event_node[\"data-name\"] || post.topic.title\n          event_node.replace <<~TXT\n          <div style='border:1px solid #dedede'>\n            <p><a href=\"#{Discourse.base_url}#{post.url}\">#{event_name}</a></p>\n            <p>#{dates}</p>\n          </div>\n        TXT\n        end\n    end\n  end\n\n  on(:user_destroyed) { |user| DiscoursePostEvent::Invitee.where(user_id: user.id).destroy_all }\n\n  if respond_to?(:add_post_revision_notifier_recipients)\n    add_post_revision_notifier_recipients do |post_revision|\n      # next if no modifications\n      next if !post_revision.modifications.present?\n\n      # do no notify recipients when only updating tags\n      next if post_revision.modifications.keys == [\"tags\"]\n\n      ids = []\n      post = post_revision.post\n\n      if post && post.is_first_post? && post.event\n        ids.concat(post.event.on_going_event_invitees.pluck(:user_id))\n      end\n\n      ids\n    end\n  end\n\n  on(:site_setting_changed) do |name, old_val, new_val|\n    next if name != :discourse_post_event_allowed_custom_fields\n\n    previous_fields = old_val.split(\"|\")\n    new_fields = new_val.split(\"|\")\n    removed_fields = previous_fields - new_fields\n\n    next if removed_fields.empty?\n\n    DiscoursePostEvent::Event.all.find_each do |event|\n      removed_fields.each { |field| event.custom_fields.delete(field) }\n      event.save\n    end\n  end\n\n  if defined?(DiscourseAutomation)\n    on(:discourse_post_event_event_started) do |event|\n      DiscourseAutomation::Automation\n        .where(enabled: true, trigger: \"event_started\")\n        .each do |automation|\n          fields = automation.serialized_fields\n          topic_id = fields.dig(\"topic_id\", \"value\")\n\n          next unless event.post.topic.id.to_s == topic_id\n\n          automation.trigger!(\n            \"kind\" => \"event_started\",\n            \"event\" => event,\n            \"placeholders\" => {\n              \"event_url\" => event.url,\n            },\n          )\n        end\n    end\n\n    add_triggerable_to_scriptable(\"event_started\", \"send_chat_message\")\n\n    add_automation_triggerable(\"event_started\") do\n      placeholder :event_url\n\n      field :topic_id, component: :text\n    end\n  end\n\n  query =\n    Proc.new do |notifications, data|\n      notifications.where(\"data::json ->> 'topic_title' = ?\", data[:topic_title].to_s).where(\n        \"data::json ->> 'message' = ?\",\n        data[:message].to_s,\n      )\n    end\n\n  reminders_consolidation_plan =\n    Notifications::DeletePreviousNotifications.new(\n      type: Notification.types[:event_reminder],\n      previous_query_blk: query,\n    )\n\n  invitation_consolidation_plan =\n    Notifications::DeletePreviousNotifications.new(\n      type: Notification.types[:event_invitation],\n      previous_query_blk: query,\n    )\n\n  register_notification_consolidation_plan(reminders_consolidation_plan)\n  register_notification_consolidation_plan(invitation_consolidation_plan)\n\n  Report.add_report(\"currently_away\") do |report|\n    group_filter = report.filters.dig(:group) || Group::AUTO_GROUPS[:staff]\n    report.add_filter(\"group\", type: \"group\", default: group_filter)\n\n    return unless group = Group.find_by(id: group_filter)\n\n    report.labels = [\n      { property: :username, title: I18n.t(\"reports.currently_away.labels.username\") },\n    ]\n\n    group_usernames = group.users.pluck(:username)\n    on_holiday_usernames = DiscourseCalendar.users_on_holiday\n    report.data = (group_usernames & on_holiday_usernames).map { |username| { username: username } }\n    report.total = report.data.count\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\ndescribe PrettyText do\n  before do\n    freeze_time Time.utc(2018, 6, 5, 18, 40)\n\n    SiteSetting.calendar_enabled = true\n    SiteSetting.discourse_post_event_enabled = true\n  end\n\n  context \"with a public event\" do\n    describe \"An event is displayed in an email\" do\n      let(:user_1) { Fabricate(:user, admin: true) }\n\n      context \"when the event has no name\" do\n        let(:post_1) { create_post_with_event(user_1) }\n\n        it \"displays the topic title\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has a name\" do\n        let(:post_1) { create_post_with_event(user_1, 'name=\"Pancakes event\"') }\n\n        it \"displays the event name\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">Pancakes event</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has an end date\" do\n        let(:post_1) { create_post_with_event(user_1, 'end=\"2018-06-22\"') }\n\n        it \"displays the end date\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC) \u2192 2018-06-22 (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has a timezone\" do\n        let(:post_1) { create_post_with_event(user_1, 'timezone=\"America/New_York\"') }\n\n        it \"uses the timezone\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (America/New_York)</p>\n            </div>\n          HTML\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["3.1.0.beta3: 10077ca904956005f9fa83c3d9fb124b59e8c47b\n2.9.0.beta13: b4c366b35d6f9778e54a878aa083348e8a45e86e\n2.9.0.beta9: 6f16ae10dc0306d6e1369e0d1414416d7e72141d\n2.9.0.beta7: ec34a96f215dce9c7321dfe04f6dd0172a197711\n2.9.0.beta3: 9ab1b76a1425304f3434b49db49cb4eec8919cf6\n2.7.0.beta3: 52e22b9972dc79c67f6a2f7c4c9f918307222030\n", "# frozen_string_literal: true\n\n# name: discourse-calendar\n# about: Display a calendar in the first post of a topic\n# version: 0.3\n# author: Daniel Waterworth, Joffrey Jaffeux\n# url: https://github.com/discourse/discourse-calendar\n\nlibdir = File.join(File.dirname(__FILE__), \"vendor/holidays/lib\")\n$LOAD_PATH.unshift(libdir) unless $LOAD_PATH.include?(libdir)\n\ngem \"rrule\", \"0.4.4\", require: false\n\nrequire_relative \"lib/calendar_settings_validator.rb\"\n\nenabled_site_setting :calendar_enabled\n\nregister_asset \"stylesheets/vendor/fullcalendar.min.css\"\nregister_asset \"stylesheets/common/discourse-calendar.scss\"\nregister_asset \"stylesheets/common/discourse-calendar-holidays.scss\"\nregister_asset \"stylesheets/common/upcoming-events-calendar.scss\"\nregister_asset \"stylesheets/common/discourse-post-event.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-preview.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-builder.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-invitees.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-upcoming-events.scss\"\nregister_asset \"stylesheets/common/discourse-post-event-core-ext.scss\"\nregister_asset \"stylesheets/mobile/discourse-post-event-core-ext.scss\", :mobile\nregister_asset \"stylesheets/common/discourse-post-event-bulk-invite-modal.scss\"\nregister_asset \"stylesheets/mobile/discourse-calendar.scss\", :mobile\nregister_asset \"stylesheets/mobile/discourse-post-event.scss\", :mobile\nregister_asset \"stylesheets/desktop/discourse-calendar.scss\", :desktop\nregister_asset \"stylesheets/colors.scss\", :color_definitions\nregister_asset \"stylesheets/common/user-preferences.scss\"\nregister_svg_icon \"fas fa-calendar-day\"\nregister_svg_icon \"fas fa-clock\"\nregister_svg_icon \"fas fa-file-csv\"\nregister_svg_icon \"fas fa-star\"\nregister_svg_icon \"fas fa-file-upload\"\n\nmodule ::DiscourseCalendar\n  PLUGIN_NAME = \"discourse-calendar\"\n\n  # Type of calendar ('static' or 'dynamic')\n  CALENDAR_CUSTOM_FIELD = \"calendar\"\n\n  # User custom field set when user is on holiday\n  HOLIDAY_CUSTOM_FIELD = \"on_holiday\"\n\n  # List of all users on holiday\n  USERS_ON_HOLIDAY_KEY = \"users_on_holiday\"\n\n  # User region used in finding holidays\n  REGION_CUSTOM_FIELD = \"holidays-region\"\n\n  # List of groups\n  GROUP_TIMEZONES_CUSTOM_FIELD = \"group-timezones\"\n\n  def self.users_on_holiday\n    PluginStore.get(PLUGIN_NAME, USERS_ON_HOLIDAY_KEY) || []\n  end\n\n  def self.users_on_holiday=(usernames)\n    PluginStore.set(PLUGIN_NAME, USERS_ON_HOLIDAY_KEY, usernames)\n  end\nend\n\nmodule ::DiscoursePostEvent\n  PLUGIN_NAME = \"discourse-post-event\"\n\n  # Topic where op has a post event custom field\n  TOPIC_POST_EVENT_STARTS_AT = \"TopicEventStartsAt\"\n  TOPIC_POST_EVENT_ENDS_AT = \"TopicEventEndsAt\"\nend\n\nrequire_relative \"lib/discourse_calendar/engine\"\n\nafter_initialize do\n  reloadable_patch do\n    Category.register_custom_field_type(\"sort_topics_by_event_start_date\", :boolean)\n    Category.register_custom_field_type(\"disable_topic_resorting\", :boolean)\n    Site.preloaded_category_custom_fields << \"sort_topics_by_event_start_date\"\n    Site.preloaded_category_custom_fields << \"disable_topic_resorting\"\n  end\n\n  add_to_serializer :basic_category, :sort_topics_by_event_start_date do\n    object.custom_fields[\"sort_topics_by_event_start_date\"]\n  end\n\n  add_to_serializer :basic_category, :disable_topic_resorting do\n    object.custom_fields[\"disable_topic_resorting\"]\n  end\n\n  reloadable_patch do\n    TopicQuery.add_custom_filter(:order_by_event_date) do |results, topic_query|\n      if SiteSetting.sort_categories_by_event_start_date_enabled &&\n           topic_query.options[:category_id]\n        category = Category.find_by(id: topic_query.options[:category_id])\n        if category && category.custom_fields &&\n             category.custom_fields[\"sort_topics_by_event_start_date\"]\n          results =\n            results.joins(\n              \"LEFT JOIN topic_custom_fields AS custom_fields on custom_fields.topic_id = topics.id\n            AND custom_fields.name = '#{DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT}'\n            \",\n            ).reorder(\"topics.pinned_at ASC, custom_fields.value ASC\")\n        end\n      end\n      results\n    end\n  end\n\n  # DISCOURSE CALENDAR HOLIDAYS\n\n  add_admin_route \"admin.calendar\", \"calendar\"\n\n  # DISCOURSE POST EVENT\n\n  require_relative \"jobs/regular/discourse_post_event/bulk_invite\"\n  require_relative \"jobs/regular/discourse_post_event/bump_topic\"\n  require_relative \"jobs/regular/discourse_post_event/send_reminder\"\n  require_relative \"lib/discourse_post_event/engine\"\n  require_relative \"lib/discourse_post_event/event_finder\"\n  require_relative \"lib/discourse_post_event/event_parser\"\n  require_relative \"lib/discourse_post_event/event_validator\"\n  require_relative \"lib/discourse_post_event/export_csv_controller_extension\"\n  require_relative \"lib/discourse_post_event/export_csv_file_extension\"\n  require_relative \"lib/discourse_post_event/post_extension\"\n  require_relative \"lib/discourse_post_event/rrule_generator\"\n\n  ::ActionController::Base.prepend_view_path File.expand_path(\"../app/views\", __FILE__)\n\n  reloadable_patch do\n    ExportCsvController.class_eval { prepend DiscoursePostEvent::ExportCsvControllerExtension }\n    Jobs::ExportCsvFile.class_eval { prepend DiscoursePostEvent::ExportPostEventCsvReportExtension }\n    Post.class_eval { prepend DiscoursePostEvent::PostExtension }\n  end\n\n  add_to_class(:user, :can_create_discourse_post_event?) do\n    return @can_create_discourse_post_event if defined?(@can_create_discourse_post_event)\n    @can_create_discourse_post_event =\n      begin\n        return true if staff?\n        allowed_groups = SiteSetting.discourse_post_event_allowed_on_groups.to_s.split(\"|\").compact\n        allowed_groups.present? && groups.where(id: allowed_groups).exists?\n      rescue StandardError\n        false\n      end\n  end\n\n  add_to_class(:guardian, :can_act_on_invitee?) do |invitee|\n    user && (user.staff? || user.id == invitee.user_id)\n  end\n\n  add_to_class(:guardian, :can_create_discourse_post_event?) do\n    user && user.can_create_discourse_post_event?\n  end\n\n  add_to_serializer(:current_user, :can_create_discourse_post_event) do\n    object.can_create_discourse_post_event?\n  end\n\n  add_to_class(:user, :can_act_on_discourse_post_event?) do |event|\n    return @can_act_on_discourse_post_event if defined?(@can_act_on_discourse_post_event)\n    @can_act_on_discourse_post_event =\n      begin\n        return true if staff?\n        can_create_discourse_post_event? && Guardian.new(self).can_edit_post?(event.post)\n      rescue StandardError\n        false\n      end\n  end\n\n  add_to_class(:guardian, :can_act_on_discourse_post_event?) do |event|\n    user && user.can_act_on_discourse_post_event?(event)\n  end\n\n  add_class_method(:group, :discourse_post_event_allowed_groups) do\n    where(id: SiteSetting.discourse_post_event_allowed_on_groups.split(\"|\").compact)\n  end\n\n  TopicView.on_preload do |topic_view|\n    if SiteSetting.discourse_post_event_enabled\n      topic_view.instance_variable_set(:@posts, topic_view.posts.includes(:event))\n    end\n  end\n\n  add_to_serializer(\n    :post,\n    :event,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled && !object.nil? && !object.deleted_at.present?\n    end,\n  ) { DiscoursePostEvent::EventSerializer.new(object.event, scope: scope, root: false) }\n\n  on(:post_created) { |post| DiscoursePostEvent::Event.update_from_raw(post) }\n\n  on(:post_edited) { |post| DiscoursePostEvent::Event.update_from_raw(post) }\n\n  on(:post_destroyed) do |post|\n    if SiteSetting.discourse_post_event_enabled && post.event\n      post.event.update!(deleted_at: Time.now)\n    end\n  end\n\n  on(:post_recovered) do |post|\n    post.event.update!(deleted_at: nil) if SiteSetting.discourse_post_event_enabled && post.event\n  end\n\n  add_preloaded_topic_list_custom_field DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT\n\n  add_to_serializer(\n    :topic_view,\n    :event_starts_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title &&\n        object.topic.custom_fields.keys.include?(DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT)\n    end,\n  ) { object.topic.custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT] }\n\n  add_to_class(:topic, :event_starts_at) do\n    @event_starts_at ||= custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_STARTS_AT]\n  end\n\n  add_to_serializer(\n    :topic_list_item,\n    :event_starts_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title && object.event_starts_at\n    end,\n  ) { object.event_starts_at }\n\n  add_preloaded_topic_list_custom_field DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT\n\n  add_to_serializer(\n    :topic_view,\n    :event_ends_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title &&\n        object.topic.custom_fields.keys.include?(DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT)\n    end,\n  ) { object.topic.custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT] }\n\n  add_to_class(:topic, :event_ends_at) do\n    @event_ends_at ||= custom_fields[DiscoursePostEvent::TOPIC_POST_EVENT_ENDS_AT]\n  end\n\n  add_to_serializer(\n    :topic_list_item,\n    :event_ends_at,\n    include_condition: -> do\n      SiteSetting.discourse_post_event_enabled &&\n        SiteSetting.display_post_event_date_on_topic_title && object.event_ends_at\n    end,\n  ) { object.event_ends_at }\n\n  # DISCOURSE CALENDAR\n\n  require_relative \"jobs/scheduled/create_holiday_events\"\n  require_relative \"jobs/scheduled/delete_expired_event_posts\"\n  require_relative \"jobs/scheduled/monitor_event_dates\"\n  require_relative \"jobs/scheduled/update_holiday_usernames\"\n  require_relative \"lib/calendar_validator\"\n  require_relative \"lib/calendar\"\n  require_relative \"lib/event_validator\"\n  require_relative \"lib/group_timezones\"\n  require_relative \"lib/holiday_status\"\n  require_relative \"lib/time_sniffer\"\n  require_relative \"lib/users_on_holiday\"\n\n  register_post_custom_field_type(DiscourseCalendar::CALENDAR_CUSTOM_FIELD, :string)\n  register_post_custom_field_type(DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD, :json)\n  TopicView.default_post_custom_fields << DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD\n\n  register_user_custom_field_type(DiscourseCalendar::HOLIDAY_CUSTOM_FIELD, :boolean)\n\n  allow_staff_user_custom_field(DiscourseCalendar::HOLIDAY_CUSTOM_FIELD)\n  DiscoursePluginRegistry.serialized_current_user_fields << DiscourseCalendar::REGION_CUSTOM_FIELD\n  register_editable_user_custom_field(DiscourseCalendar::REGION_CUSTOM_FIELD)\n\n  on(:site_setting_changed) do |name, old_value, new_value|\n    next unless %i[all_day_event_start_time all_day_event_end_time].include? name\n\n    Post\n      .where(id: CalendarEvent.select(:post_id).distinct)\n      .each { |post| CalendarEvent.update(post) }\n  end\n\n  on(:post_process_cooked) do |doc, post|\n    DiscourseCalendar::Calendar.update(post)\n    DiscourseCalendar::GroupTimezones.update(post)\n    CalendarEvent.update(post)\n  end\n\n  on(:post_recovered) do |post, _, _|\n    DiscourseCalendar::Calendar.update(post)\n    DiscourseCalendar::GroupTimezones.update(post)\n    CalendarEvent.update(post)\n  end\n\n  on(:post_destroyed) do |post, _, _|\n    DiscourseCalendar::Calendar.destroy(post)\n    CalendarEvent.where(post_id: post.id).destroy_all\n  end\n\n  validate(:post, :validate_calendar) do |force = nil|\n    return unless self.raw_changed? || force\n\n    validator = DiscourseCalendar::CalendarValidator.new(self)\n    validator.validate_calendar\n  end\n\n  validate(:post, :validate_event) do |force = nil|\n    return unless self.raw_changed? || force\n    return if self.is_first_post?\n\n    # Skip if not a calendar topic\n    return if !self&.topic&.first_post&.custom_fields&.[](DiscourseCalendar::CALENDAR_CUSTOM_FIELD)\n\n    validator = DiscourseCalendar::EventValidator.new(self)\n    validator.validate_event\n  end\n\n  add_to_class(:post, :has_group_timezones?) do\n    custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD].present?\n  end\n\n  add_to_class(:post, :group_timezones) do\n    custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] || {}\n  end\n\n  add_to_class(:post, :group_timezones=) do |val|\n    if val.present?\n      custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] = val\n    else\n      custom_fields.delete(DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD)\n    end\n  end\n\n  add_to_serializer(:post, :calendar_details, include_condition: -> { object.is_first_post? }) do\n    grouped = {}\n    standalones = []\n\n    CalendarEvent\n      .where(topic_id: object.topic_id)\n      .order(:start_date, :end_date)\n      .each do |event|\n        if event.post_id\n          standalones << {\n            type: :standalone,\n            post_number: event.post_number,\n            message: event.description,\n            from: event.start_date,\n            to: event.end_date,\n            username: event.username,\n            recurring: event.recurrence,\n            post_url: Post.url(\"-\", event.topic_id, event.post_number),\n            timezone: event.timezone,\n          }\n        else\n          identifier = \"#{event.region.split(\"_\").first}-#{event.start_date.strftime(\"%j\")}\"\n\n          grouped[identifier] ||= { type: :grouped, from: event.start_date, name: [], users: [] }\n\n          user = User.find_by_username(event.username)\n\n          grouped[identifier][:name] << event.description\n          grouped[identifier][:users] << {\n            username: event.username,\n            timezone: user.present? ? user.user_option.timezone : nil,\n          }\n        end\n      end\n\n    grouped.each do |_, v|\n      v[:name].sort!.uniq!\n      v[:name] = v[:name].join(\", \")\n      v[:users].sort! { |a, b| a[:username] <=> b[:username] }\n      v[:users].uniq! { |u| u[:username] }\n    end\n\n    standalones + grouped.values\n  end\n\n  add_to_serializer(\n    :post,\n    :group_timezones,\n    include_condition: -> do\n      post_custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD].present?\n    end,\n  ) do\n    result = {}\n    group_timezones = post_custom_fields[DiscourseCalendar::GROUP_TIMEZONES_CUSTOM_FIELD] || {}\n    group_names = group_timezones[\"groups\"] || []\n\n    if group_names.present?\n      users =\n        User\n          .joins(:groups, :user_option)\n          .where(\"groups.name\": group_names)\n          .select(\"users.*\", \"groups.name AS group_name\", \"user_options.timezone\")\n\n      users.each do |u|\n        result[u.group_name] ||= []\n        result[u.group_name] << UserTimezoneSerializer.new(u, root: false).as_json\n      end\n    end\n\n    result\n  end\n\n  add_to_serializer(:site, :users_on_holiday, include_condition: -> { scope.is_staff? }) do\n    DiscourseCalendar.users_on_holiday\n  end\n\n  on(:reduce_cooked) do |fragment, post|\n    if SiteSetting.discourse_post_event_enabled\n      fragment\n        .css(\".discourse-post-event\")\n        .each do |event_node|\n          starts_at = event_node[\"data-start\"]\n          ends_at = event_node[\"data-end\"]\n          dates = \"#{starts_at} (#{event_node[\"data-timezone\"] || \"UTC\"})\"\n          dates = \"#{dates} \u2192 #{ends_at} (#{event_node[\"data-timezone\"] || \"UTC\"})\" if ends_at\n\n          event_name = event_node[\"data-name\"] || post.topic.title\n          event_node.replace <<~TXT\n          <div style='border:1px solid #dedede'>\n            <p><a href=\"#{Discourse.base_url}#{post.url}\">#{CGI.escape_html(event_name)}</a></p>\n            <p>#{CGI.escape_html(dates)}</p>\n          </div>\n        TXT\n        end\n    end\n  end\n\n  on(:user_destroyed) { |user| DiscoursePostEvent::Invitee.where(user_id: user.id).destroy_all }\n\n  if respond_to?(:add_post_revision_notifier_recipients)\n    add_post_revision_notifier_recipients do |post_revision|\n      # next if no modifications\n      next if !post_revision.modifications.present?\n\n      # do no notify recipients when only updating tags\n      next if post_revision.modifications.keys == [\"tags\"]\n\n      ids = []\n      post = post_revision.post\n\n      if post && post.is_first_post? && post.event\n        ids.concat(post.event.on_going_event_invitees.pluck(:user_id))\n      end\n\n      ids\n    end\n  end\n\n  on(:site_setting_changed) do |name, old_val, new_val|\n    next if name != :discourse_post_event_allowed_custom_fields\n\n    previous_fields = old_val.split(\"|\")\n    new_fields = new_val.split(\"|\")\n    removed_fields = previous_fields - new_fields\n\n    next if removed_fields.empty?\n\n    DiscoursePostEvent::Event.all.find_each do |event|\n      removed_fields.each { |field| event.custom_fields.delete(field) }\n      event.save\n    end\n  end\n\n  if defined?(DiscourseAutomation)\n    on(:discourse_post_event_event_started) do |event|\n      DiscourseAutomation::Automation\n        .where(enabled: true, trigger: \"event_started\")\n        .each do |automation|\n          fields = automation.serialized_fields\n          topic_id = fields.dig(\"topic_id\", \"value\")\n\n          next unless event.post.topic.id.to_s == topic_id\n\n          automation.trigger!(\n            \"kind\" => \"event_started\",\n            \"event\" => event,\n            \"placeholders\" => {\n              \"event_url\" => event.url,\n            },\n          )\n        end\n    end\n\n    add_triggerable_to_scriptable(\"event_started\", \"send_chat_message\")\n\n    add_automation_triggerable(\"event_started\") do\n      placeholder :event_url\n\n      field :topic_id, component: :text\n    end\n  end\n\n  query =\n    Proc.new do |notifications, data|\n      notifications.where(\"data::json ->> 'topic_title' = ?\", data[:topic_title].to_s).where(\n        \"data::json ->> 'message' = ?\",\n        data[:message].to_s,\n      )\n    end\n\n  reminders_consolidation_plan =\n    Notifications::DeletePreviousNotifications.new(\n      type: Notification.types[:event_reminder],\n      previous_query_blk: query,\n    )\n\n  invitation_consolidation_plan =\n    Notifications::DeletePreviousNotifications.new(\n      type: Notification.types[:event_invitation],\n      previous_query_blk: query,\n    )\n\n  register_notification_consolidation_plan(reminders_consolidation_plan)\n  register_notification_consolidation_plan(invitation_consolidation_plan)\n\n  Report.add_report(\"currently_away\") do |report|\n    group_filter = report.filters.dig(:group) || Group::AUTO_GROUPS[:staff]\n    report.add_filter(\"group\", type: \"group\", default: group_filter)\n\n    return unless group = Group.find_by(id: group_filter)\n\n    report.labels = [\n      { property: :username, title: I18n.t(\"reports.currently_away.labels.username\") },\n    ]\n\n    group_usernames = group.users.pluck(:username)\n    on_holiday_usernames = DiscourseCalendar.users_on_holiday\n    report.data = (group_usernames & on_holiday_usernames).map { |username| { username: username } }\n    report.total = report.data.count\n  end\nend\n", "# frozen_string_literal: true\nrequire \"rails_helper\"\n\ndescribe PrettyText do\n  before do\n    freeze_time Time.utc(2018, 6, 5, 18, 40)\n\n    SiteSetting.calendar_enabled = true\n    SiteSetting.discourse_post_event_enabled = true\n  end\n\n  context \"with a public event\" do\n    describe \"An event is displayed in an email\" do\n      let(:user_1) { Fabricate(:user, admin: true) }\n\n      context \"when the event has no name\" do\n        let(:post_1) { create_post_with_event(user_1) }\n\n        it \"displays the topic title\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has a name\" do\n        let(:post_1) { create_post_with_event(user_1, 'name=\"Pancakes event\"') }\n        let(:post_2) do\n          create_post_with_event(user_1, 'name=\"Pancakes event <a>with html chars</a>\"')\n        end\n\n        it \"displays the event name\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">Pancakes event</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC)</p>\n            </div>\n          HTML\n        end\n\n        it \"properly escapes title\" do\n          cooked = PrettyText.cook(post_2.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_2)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_2.url}\">Pancakes event &lt;a&gt;with html chars&lt;/a&gt;</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has an end date\" do\n        let(:post_1) { create_post_with_event(user_1, 'end=\"2018-06-22\"') }\n\n        it \"displays the end date\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (UTC) \u2192 2018-06-22 (UTC)</p>\n            </div>\n          HTML\n        end\n      end\n\n      context \"when the event has a timezone\" do\n        let(:post_1) { create_post_with_event(user_1, 'timezone=\"America/New_York\"') }\n\n        it \"uses the timezone\" do\n          cooked = PrettyText.cook(post_1.raw)\n\n          expect(PrettyText.format_for_email(cooked, post_1)).to match_html(<<~HTML)\n            <div style='border:1px solid #dedede'>\n              <p><a href=\"#{Discourse.base_url}#{post_1.url}\">#{post_1.topic.title}</a></p>\n              <p>2018-06-05T18:39:50.000Z (America/New_York)</p>\n            </div>\n          HTML\n        end\n      end\n    end\n  end\nend\n"], "filenames": [".discourse-compatibility", "plugin.rb", "spec/lib/discourse_post_event/pretty_text_spec.rb"], "buggy_code_start_loc": [1, 432, 32], "buggy_code_end_loc": [2, 434, 39], "fixing_code_start_loc": [0, 432, 33], "fixing_code_end_loc": [0, 434, 54], "type": "CWE-79", "message": "dicourse-calendar is a plugin for the Discourse messaging platform which adds the ability to create a dynamic calendar in the first post of a topic. Improper escaping of event titles could lead to Cross-site Scripting (XSS) within the 'email preview' UI when a site has CSP disabled. Having CSP disabled is a non-default configuration, so the vast majority of sites are unaffected. This problem is resolved in the latest version of the discourse-calendar plugin. Users are advised to upgrade. Users unable to upgrade should ensure CSP is enabled on the forum.", "other": {"cve": {"id": "CVE-2023-43658", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-16T22:15:12.143", "lastModified": "2023-10-20T17:47:32.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "dicourse-calendar is a plugin for the Discourse messaging platform which adds the ability to create a dynamic calendar in the first post of a topic. Improper escaping of event titles could lead to Cross-site Scripting (XSS) within the 'email preview' UI when a site has CSP disabled. Having CSP disabled is a non-default configuration, so the vast majority of sites are unaffected. This problem is resolved in the latest version of the discourse-calendar plugin. Users are advised to upgrade. Users unable to upgrade should ensure CSP is enabled on the forum."}, {"lang": "es", "value": "dicourse-calendar es un complemento para la plataforma de mensajer\u00eda Discourse que agrega la capacidad de crear un calendario din\u00e1mico en la primera publicaci\u00f3n de un tema. El escape inadecuado de los t\u00edtulos de los eventos podr\u00eda provocar Cross-Site Scripting (XSS) dentro de la interfaz de usuario de \"email preview\" cuando un sitio tiene CSP deshabilitado. Tener CSP deshabilitado es una configuraci\u00f3n no predeterminada, por lo que la gran mayor\u00eda de los sitios no se ven afectados. Este problema se resuelve en la \u00faltima versi\u00f3n del complemento de calendario de discourse. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben asegurarse de que CSP est\u00e9 habilitado en el foro."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_calendar:*:*:*:*:*:discourse:*:*", "versionEndIncluding": "2023-10-16", "matchCriteriaId": "F346D3A9-CFE0-4941-BCFB-52700D54CABD"}]}]}], "references": [{"url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-calendar/commit/9788310906febb36822d6823d14f1059c39644de", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-calendar/security/advisories/GHSA-3fwj-f6ww-7hr6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-calendar/commit/9788310906febb36822d6823d14f1059c39644de"}}