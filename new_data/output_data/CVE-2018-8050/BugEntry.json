{"buggy_code": ["/*\n * The AFFLIB page abstraction.\n * Distributed under the Berkeley 4-part license\n */\n\n#include \"affconfig.h\"\n#include \"afflib.h\"\n#include \"afflib_i.h\"\n\n\n/* af_read_sizes:\n * Get the page sizes if they are set in the file.\n */\nvoid af_read_sizes(AFFILE *af)\n{\n    af_get_seg(af,AF_SECTORSIZE,&af->image_sectorsize,0,0);\n    if(af->image_sectorsize==0) af->image_sectorsize = 512; // reasonable default\n\n    if(af_get_seg(af,AF_PAGESIZE,&af->image_pagesize,0,0)){\n\taf_get_seg(af,AF_SEGSIZE_D,&af->image_pagesize,0,0); // try old name\n    }\n\n    /* Read the badflag if it is present.\n     * Be sure to adjust badflag size to current sector size (which may have changed).\n     */\n    if(af->badflag!=0) free(af->badflag);\n    af->badflag = (unsigned char *)malloc(af->image_sectorsize);\n    size_t sectorsize = af->image_sectorsize;\n    if(af_get_seg(af,AF_BADFLAG,0,af->badflag,(size_t *)&sectorsize)==0){\n\taf->badflag_set = 1;\n    }\n\n    /* Read the image file segment if it is present.\n     * If it isn't, scan through the disk image to figure out the size of the disk image.\n     */\n\n    if(af_get_segq(af,AF_IMAGESIZE,(int64_t *)&af->image_size)){\n\n\t/* Calculate the imagesize by scanning all of the pages that are in\n\t * the disk image and finding the highest page number.\n\t * Then read that page to find the last allocated byte.\n\t */\n\tchar segname[AF_MAX_NAME_LEN];\n\tsize_t datalen = 0;\n\taf_rewind_seg(af);\t\t//  start at the beginning\n\tint64_t highest_page_number = 0;\n\twhile(af_get_next_seg(af,segname,sizeof(segname),0,0,&datalen)==0){\n\t    if(segname[0]==0) continue;\t// ignore sector\n\t    int64_t pagenum = af_segname_page_number(segname);\n\t    if(pagenum > highest_page_number) highest_page_number = pagenum;\n\t}\n\tsize_t highest_page_len = 0;\n\tif(af_get_page(af,highest_page_number,0,&highest_page_len)==0){\n\t    af->image_size = af->image_pagesize * highest_page_number + highest_page_len;\n\t}\n    }\n    af->image_size_in_file = af->image_size;\n}\n\n\nint af_page_size(AFFILE *af)\n{\n    return af->image_pagesize;\n}\n\nint af_get_pagesize(AFFILE *af)\n{\n    return af->image_pagesize;\n}\n\n/* af_set_sectorsize:\n * Sets the sectorsize.\n * Fails with -1 if imagesize >=0 unless these changes permitted\n */\nint af_set_sectorsize(AFFILE *af,int sectorsize)\n{\n    struct af_vnode_info vni;\n    af_vstat(af,&vni);\n    if(vni.changable_pagesize==0 && af->image_size>0){\n\terrno = EINVAL;\n\treturn -1;\n    }\n    af->image_sectorsize =sectorsize;\n    if(af->badflag==0) af->badflag = (unsigned char *)malloc(sectorsize);\n    else af->badflag = (unsigned char *)realloc(af->badflag,sectorsize);\n    af->badflag_set = 0;\n\n    if(af_update_seg(af,AF_SECTORSIZE,sectorsize,0,0)){\n\tif(errno != ENOTSUP) return -1;\n    }\n    return 0;\n}\n\nint\taf_get_sectorsize(AFFILE *af)\t// returns sector size\n{\n    return af->image_sectorsize;\n}\n\n/*\n * af_set_pagesize:\n * Sets the pagesize. Fails with -1 if it can't be changed.\n */\nint af_set_pagesize(AFFILE *af,uint32_t pagesize)\n{\n    /* Allow the pagesize to be changed if it hasn't been set yet\n     * and if this format doesn't support metadata updating (which is the raw formats)\n     */\n    struct af_vnode_info vni;\n\n    af_vstat(af,&vni);\n\n    if(vni.changable_pagesize==0 && af->image_size>0){\n\tif(pagesize==af->image_pagesize) return 0; // it's already set to this, so let it pass\n\terrno = EINVAL;\n\treturn -1;\n    }\n    if(pagesize % af->image_sectorsize != 0){\n\t(*af->error_reporter)(\"Cannot set pagesize to %d (sectorsize=%d)\\n\",\n\t\t\t      pagesize,af->image_sectorsize);\n\terrno = EINVAL;\n\treturn -1;\n    }\n\n    af->image_pagesize = pagesize;\n    if(af_update_seg(af,AF_PAGESIZE,pagesize,0,0)){\n\tif(errno != ENOTSUP) return -1;\t// error updating (don't report ENOTSUP);\n    }\n    return 0;\n}\n\n\n/****************************************************************\n *** page-level interface\n ****************************************************************/\n\nint af_get_page_raw(AFFILE *af,int64_t pagenum,uint32_t *arg,\n\t\t    unsigned char *data,size_t *bytes)\n{\n    char segname[AF_MAX_NAME_LEN];\n\n    memset(segname,0,sizeof(segname));\n    sprintf(segname,AF_PAGE,pagenum);\n    int r = af_get_seg(af,segname,arg,data,bytes);\n    if(r < 0 && errno == ENOENT)\n    {\n\t/* Couldn't read with AF_PAGE; try AF_SEG_D.\n\t * This is legacy for the old AFF files. Perhaps we should delete it.\n\t */\n\tsprintf(segname,AF_SEG_D,pagenum);\n\tr = af_get_seg(af,segname,arg,data,bytes);\n    }\n    /* Update the counters */\n    if(r==0 && bytes && *bytes>0) af->pages_read++; // note that we read a page\n    return r;\n}\n\n/* af_get_page:\n * Get a page from its named segment.\n * If the page is compressed, uncompress it.\n * data points to a segmenet of at least *bytes;\n * *bytes is then modified to indicate the actual amount of bytes read.\n * Return 0 if success, -1 if fail.\n */\n\nint af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)\n{\n    uint32_t arg=0;\n    size_t page_len=0;\n\n    if (af_trace){\n\tfprintf(af_trace,\"af_get_page(%p,pagenum=%\" I64d \",buf=%p,bytes=%u)\\n\",af,pagenum,data,(int)*bytes);\n    }\n\n    /* Find out the size of the segment and if it is compressed or not.\n     * If we can't find it with new nomenclature, try the old one...\n     */\n    int r = af_get_page_raw(af,pagenum,&arg,0,&page_len);\n    if(r){\n\t/* Segment doesn't exist.\n\t * If we have been provided with a buffer,\n\t * fill buffer with the 'bad segment' flag and return.\n\t */\n\tif(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT)\n\t{\n\t    for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize;\n\t\ti+= af->image_sectorsize){\n\t\tmemcpy(data+i,af->badflag,af->image_sectorsize);\n\t\taf->bytes_memcpy += af->image_sectorsize;\n\t    }\n\n\t    r = 0;\n\t}\n\treturn r;\t\t// segment doesn't exist\n    }\n\n\n    /* If the segment isn't compressed, just get it*/\n    uint32_t pageflag = 0;\n    if((arg & AF_PAGE_COMPRESSED)==0){\n\tif(data==0){\t\t\t// if no data provided, just return size of the segment if requested\n\t    if(bytes) *bytes = page_len;\t// set the number of bytes in the page if requested\n\t    return 0;\n\t}\n\tint ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes);\n\tif(*bytes > page_len) *bytes = page_len; // we only read this much\n\tif(ret!=0) return ret;\t\t// some error happened?\n    }\n    else {\n\t/* Allocate memory to hold the compressed segment */\n\tunsigned char *compressed_data = (unsigned char *)malloc(page_len);\n\tsize_t compressed_data_len = page_len;\n\tif(compressed_data==0){\n\t    return -2;\t\t\t// memory error\n\t}\n\n\t/* Get the data */\n\tif(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){\n\t    free(compressed_data);\n\t    return -3;\t\t\t// read error\n\t}\n\n\t/* Now uncompress directly into the buffer provided by the caller, unless the caller didn't\n\t * provide a buffer. If that happens, allocate our own...\n\t */\n\tint res = -1;\t\t\t// 0 is success\n\tbool free_data = false;\n\tif(data==0){\n\t    data = (unsigned char *)malloc(af->image_pagesize);\n\t    free_data = true;\n\t    *bytes = af->image_pagesize; // I can hold this much\n\t}\n\n\tswitch((pageflag & AF_PAGE_COMP_ALG_MASK)){\n\tcase AF_PAGE_COMP_ALG_ZERO:\n\t    if(compressed_data_len != 4){\n\t\t(*af->error_reporter)(\"ALG_ZERO compressed data is %d bytes, expected 4.\",compressed_data_len);\n\t\tbreak;\n\t    }\n\t    memset(data,0,af->image_pagesize);\n\t    *bytes = ntohl(*(long *)compressed_data);\n\t    res = 0;\t\t\t// not very hard to decompress with the ZERO compressor.\n\t    break;\n\n\tcase AF_PAGE_COMP_ALG_ZLIB:\n\t    res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len);\n\t    switch(res){\n\t    case Z_OK:\n\t\tbreak;\n\t    case Z_ERRNO:\n\t\t(*af->error_reporter)(\"Z_ERRNOR decompressing segment %\" I64d,pagenum);\n\t    case Z_STREAM_ERROR:\n\t\t(*af->error_reporter)(\"Z_STREAM_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_DATA_ERROR:\n\t\t(*af->error_reporter)(\"Z_DATA_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_MEM_ERROR:\n\t\t(*af->error_reporter)(\"Z_MEM_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_BUF_ERROR:\n\t\t(*af->error_reporter)(\"Z_BUF_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_VERSION_ERROR:\n\t\t(*af->error_reporter)(\"Z_VERSION_ERROR decompressing segment %\" I64d,pagenum);\n\t    default:\n\t\t(*af->error_reporter)(\"uncompress returned an invalid value in get_segment\");\n\t    }\n\t    break;\n\n#ifdef USE_LZMA\n\tcase AF_PAGE_COMP_ALG_LZMA:\n\t    res = lzma_uncompress(data,bytes,compressed_data,compressed_data_len);\n\t    if (af_trace) fprintf(af_trace,\"   LZMA decompressed page %\" I64d \". %d bytes => %u bytes\\n\",\n\t\t\t\t  pagenum,(int)compressed_data_len,(int)*bytes);\n\t    switch(res){\n\t    case 0:break;\t\t// OK\n\t    case 1:(*af->error_reporter)(\"LZMA header error decompressing segment %\" I64d \"\\n\",pagenum);\n\t\tbreak;\n\t    case 2:(*af->error_reporter)(\"LZMA memory error decompressing segment %\" I64d \"\\n\",pagenum);\n\t\tbreak;\n\t    }\n\t    break;\n#endif\n\n\tdefault:\n\t    (*af->error_reporter)(\"Unknown compression algorithm 0x%d\",\n\t\t\t\t  pageflag & AF_PAGE_COMP_ALG_MASK);\n\t    break;\n\t}\n\n\tif(free_data){\n\t    free(data);\n\t    data = 0;\t\t\t// restore the way it was\n\t}\n\tfree(compressed_data);\t\t// don't need this one anymore\n\taf->pages_decompressed++;\n\tif(res!=Z_OK) return -1;\n    }\n\n    /* If the page size is larger than the sector_size,\n     * make sure that the rest of the sector is zeroed, and that the\n     * rest after that has the 'bad block' notation.\n     */\n    if(data && (af->image_pagesize > af->image_sectorsize)){\n\tconst int SECTOR_SIZE = af->image_sectorsize;\t// for ease of typing\n\tsize_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE;\n\tfor(size_t i=0;i<bytes_left_in_sector;i++){\n\t    data[*bytes + i] = 0;\n\t}\n\tsize_t end_of_data = *bytes + bytes_left_in_sector;\n\n\t/* Now fill to the end of the page... */\n\tfor(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){\n\t    memcpy(data+i,af->badflag,SECTOR_SIZE);\n\t    af->bytes_memcpy += SECTOR_SIZE;\n\t}\n    }\n    return 0;\n}\n\n\nstatic bool is_buffer_zero(unsigned char *buf,int buflen)\n{\n    if(buflen >= (int)sizeof(long))\n    {\n        // align to word boundary\n        buflen -= (intptr_t)buf % sizeof(long);\n\n        while((intptr_t)buf % sizeof(long))\n        {\n            if(*buf++)\n                return false;\n        }\n\n        // read in words\n        long *ptr = (long*)buf;\n        buf += buflen - buflen % sizeof(long);\n        buflen %= sizeof(long);\n\n        while(ptr < (long*)buf)\n        {\n            if(*ptr++)\n                return false;\n        }\n    }\n\n    while(buflen--)\n    {\n        if(*buf++)\n            return false;\n    }\n\n    return true;\n}\n\n/* Write a actual data segment to the disk and sign if necessary. */\nint af_update_page(AFFILE *af,int64_t pagenum,unsigned char *data,int datalen)\n{\n    char segname_buf[32];\n    snprintf(segname_buf,sizeof(segname_buf),AF_PAGE,pagenum); // determine segment name\n\n#ifdef USE_AFFSIGS\n    /* Write out the signature if we have a private key */\n    if(af->crypto && af->crypto->sign_privkey){\n\taf_sign_seg3(af,segname_buf,0,data,datalen,AF_SIGNATURE_MODE1);\n    }\n#endif\n\n#ifdef HAVE_MD5\n    /* Write out MD5 if requested */\n    if(af->write_md5){\n\tunsigned char md5_buf[16];\n\tchar md5name_buf[32];\n\tMD5(data,datalen,md5_buf);\n\tsnprintf(md5name_buf,sizeof(md5name_buf),AF_PAGE_MD5,pagenum);\n\taf_update_segf(af,md5name_buf,0,md5_buf,sizeof(md5_buf),AF_SIGFLAG_NOSIG); // ignore failure\n    }\n#endif\n#ifdef HAVE_SHA1\n    /* Write out SHA1 if requested */\n    if(af->write_sha1){\n\tunsigned char sha1_buf[20];\n\tchar sha1name_buf[32];\n\tSHA1(data,datalen,sha1_buf);\n\tsnprintf(sha1name_buf,sizeof(sha1name_buf),AF_PAGE_SHA1,pagenum);\n\taf_update_segf(af,sha1name_buf,0,sha1_buf,sizeof(sha1_buf),AF_SIGFLAG_NOSIG); // ignore failure\n    }\n#endif\n    /* Write out SHA256 if requested and if SHA256 is available */\n    if(af->write_sha256){\n\tunsigned char sha256_buf[32];\n\tif(af_SHA256(data,datalen,sha256_buf)==0){\n\t    char sha256name_buf[32];\n\t    snprintf(sha256name_buf,sizeof(sha256name_buf),AF_PAGE_SHA256,pagenum);\n\t    af_update_segf(af,sha256name_buf,0,sha256_buf,sizeof(sha256_buf),AF_SIGFLAG_NOSIG); // ignore failure\n\t}\n    }\n\n    /* Check for bypass */\n    if(af->v->write){\n\tint r = (*af->v->write)(af,data,af->image_pagesize * pagenum,datalen);\n\tif(r!=datalen) return -1;\n\treturn 0;\n    }\n\n    struct affcallback_info acbi;\n    int ret = 0;\n    uint64_t starting_pages_written = af->pages_written;\n\n    /* Setup the callback structure */\n    memset(&acbi,0,sizeof(acbi));\n    acbi.info_version = 1;\n    acbi.af = af->parent ? af->parent : af;\n    acbi.pagenum = pagenum;\n    acbi.bytes_to_write = datalen;\n\n    size_t destLen = af->image_pagesize;\t// it could be this big.\n\n    /* Compress and write the data, if we are allowed to compress */\n    if(af->compression_type != AF_COMPRESSION_ALG_NONE){\n\tunsigned char *cdata = (unsigned char *)malloc(destLen); // compressed data\n\tuint32_t *ldata = (uint32_t *)cdata; // allows me to reference as a buffer of uint32_ts\n\tif(cdata!=0){\t\t// If data could be allocated\n\t    int cres = -1;\t\t// compression results\n\t    uint32_t flag = 0;\t// flag for data segment\n\t    int dont_compress = 0;\n\n\t    /* Try zero compression first; it's the best algorithm we have  */\n\t    if(is_buffer_zero(data,datalen)){\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_ZERO;\n\t\tacbi.compression_level = AF_COMPRESSION_MAX;\n\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\t*ldata = htonl(datalen); // store the data length\n\t\tdestLen = 4;\t\t // 4 bytes\n\t\tflag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_ZERO | AF_PAGE_COMP_MAX;\n\t\tcres = 0;\n\n\t\tacbi.compressed = 1;\t\t// it was compressed\n\t\tif(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t    }\n\n#ifdef USE_LZMA\n\t    if(cres!=0 && af->compression_type==AF_COMPRESSION_ALG_LZMA){ // try to compress with LZMA\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_LZMA;\n\t\tacbi.compression_level = 7; // right now, this is the level we use\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\tcres = lzma_compress(cdata,&destLen,data,datalen,9);\n#if 0\n\t\tswitch(cres){\n\t\tcase 0:break;\t\t// OKAY\n\t\tcase 1: (*af->error_reporter)(\"LZMA: Unspecified Error\\n\");break;\n\t\tcase 2: (*af->error_reporter)(\"LZMA: Memory Allocating Error\\n\");break;\n\t\tcase 3: (*af->error_reporter)(\"LZMA: Output buffer OVERFLOW\\n\"); break;\n\t\tdefault: (*af->error_reporter)(\"LZMA: Unknown error %d\\n\",cres);break;\n\t\t}\n#endif\n\t\tif(cres==0){\n\t\t    flag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_LZMA;\n\t\t    acbi.compressed = 1;\n\t\t    if(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t\t}\n\t\telse {\n\t\t    /* Don't bother reporting LZMA errors; we just won't compress */\n\t\t    dont_compress = 1;\n\t\t    if(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t\t}\n\t    }\n#endif\n\n\t    if(cres!=0\n\t       && af->compression_type==AF_COMPRESSION_ALG_ZLIB\n\t       && dont_compress==0){ // try to compress with zlib\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_ZLIB; // only one that we support\n\t\tacbi.compression_level = af->compression_level;\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\tcres = compress2((Bytef *)cdata, (uLongf *)&destLen,\n\t\t\t\t (Bytef *)data,datalen, af->compression_level);\n\n\t\tif(cres==0){\n\t\t    flag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_ZLIB;\n\t\t    if(af->compression_level == AF_COMPRESSION_MAX){\n\t\t\tflag |= AF_PAGE_COMP_MAX; // useful to know it can't be better\n\t\t    }\n\t\t}\n\t\tacbi.compressed = 1;\t// it was compressed (or not compressed)\n\t\tif(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t    }\n\n\t    if(cres==0 && destLen < af->image_pagesize){\n\t\t/* Prepare to write out the compressed segment with compression */\n\t\tif(af->w_callback) {acbi.phase = 3;(*af->w_callback)(&acbi);}\n\t\tret = af_update_segf(af,segname_buf,flag,cdata,destLen,AF_SIGFLAG_NOSIG);\n\t\tacbi.bytes_written = destLen;\n\t\tif(af->w_callback) {acbi.phase = 4;(*af->w_callback)(&acbi);}\n\t\tif(ret==0){\n\t\t    af->pages_written++;\n\t\t    af->pages_compressed++;\n\t\t}\n\t    }\n\t    free(cdata);\n\t    cdata = 0;\n\t}\n    }\n\n    /* If a compressed segment was not written, write it uncompressed */\n    if(af->pages_written == starting_pages_written){\n\tif(af->w_callback) {acbi.phase = 3;(*af->w_callback)(&acbi);}\n\tret = af_update_segf(af,segname_buf,0,data,datalen,AF_SIGFLAG_NOSIG);\n\tacbi.bytes_written = datalen;\n\tif(af->w_callback) {acbi.phase = 4;(*af->w_callback)(&acbi);}\n\tif(ret==0){\n\t    acbi.bytes_written = datalen;\t// because that is how much we wrote\n\t    af->pages_written++;\n\t}\n    }\n    return ret;\n}\n\n/****************************************************************\n *** Cache interface\n ****************************************************************/\n\n/* The page cache is a read/write cache.\n *\n * Pages that are read are cached after they are decompressed.\n * When new pages are fetched, we check the cache first to see if they are there;\n * if so, they are satsfied by the cache.\n *\n * Modifications are written to the cache, then dumped to the disk.\n *\n * The cache is managed by two functions:\n * af_cache_flush(af) - (prevously af_purge)\n *      - Makes sure that all dirty buffers are written.\n *      - Sets af->pb=NULL (no current page)\n *      - (returns 0 if success, -1 if failure.)\n *\n * af_cache_writethrough(af,page,buf,buflen)\n *      - used for write bypass\n *\n */\n\nstatic int cachetime = 0;\n\n\nint af_cache_flush(AFFILE *af)\n{\n    if(af_trace) fprintf(af_trace,\"af_cache_flush()\\n\");\n    int ret = 0;\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagebuf_valid && p->pagebuf_dirty){\n\t    if(af_update_page(af,p->pagenum,p->pagebuf,p->pagebuf_bytes)){\n\t\tret = -1;\t\t// got an error; keep going, though\n\t    }\n\t    p->pagebuf_dirty = 0;\n\t    if(af_trace) fprintf(af_trace,\"af_cache_flush: slot %d page %\" PRIu64 \" flushed.\\n\",i,p->pagenum);\n\t}\n    }\n    return ret;\t\t\t\t// now return the error that I might have gotten\n}\n\n/* If the page being written is in the cache, update it.\n * Question: would it make sense to copy the data anyway? I don't think so, because\n * the main use of writethrough is when imaging, and in that event you probably don't\n * want the extra memcpy.\n */\nvoid af_cache_writethrough(AFFILE *af,int64_t pagenum,const unsigned char *buf,int bufflen)\n{\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid && p->pagenum == pagenum){\n\t    if(p->pagebuf_dirty){\n\t\t(*af->error_reporter)(\"af_cache_writethrough: overwriting page %\" I64u \".\\n\",pagenum);\n\t\texit(-1);\t\t// this shouldn't happen\n\t    }\n\t    memcpy(p->pagebuf,buf,bufflen);\n\t    memset(p->pagebuf+bufflen,0,af->image_pagesize-bufflen); // zero fill the rest\n\t    af->bytes_memcpy += bufflen;\n\t    p->pagebuf_valid = 1;\t// we have a copy of it now.\n\t    p->pagebuf_dirty = 0;\t// but it isn't dirty\n\t    p->last = cachetime++;\n\t}\n    }\n}\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#ifndef HAVE_VALLOC\n#define valloc malloc\n#endif\n\nstruct aff_pagebuf *af_cache_alloc(AFFILE *af,int64_t pagenum)\n{\n    if(af_trace) fprintf(af_trace,\"af_cache_alloc(%p,%\" I64d \")\\n\",af,pagenum);\n\n    /* Make sure nothing in the cache is dirty */\n    if(af_cache_flush(af) < 0)\n\treturn 0;\n\n    /* See if this page is already in the cache */\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid && p->pagenum==pagenum){\n\t    af->cache_hits++;\n\t    if(af_trace) fprintf(af_trace,\"  page %\" I64d \" satisfied fromcache\\n\",pagenum);\n\t    p->last = cachetime++;\n\t    return p;\n\t}\n    }\n\n    af->cache_misses++;\n    int slot = -1;\n    /* See if there is an empty slot in the cache */\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid==0){\n\t    slot = i;\n\t    if(af_trace) fprintf(af_trace,\"  slot %d given to page %\" I64d \"\\n\",slot,pagenum);\n\t    break;\n\t}\n    }\n    if(slot==-1){\n\t/* Find the oldest cache entry */\n\tint oldest_i = 0;\n\tint oldest_t = af->pbcache[0].last;\n\tfor(int i=1;i<af->num_pbufs;i++){\n\t    if(af->pbcache[i].last < oldest_t){\n\t\toldest_t = af->pbcache[i].last;\n\t\toldest_i = i;\n\t    }\n\t}\n\tslot = oldest_i;\n\tif(af_trace) fprintf(af_trace,\"  slot %d assigned to page %\" I64d \"\\n\",slot,pagenum);\n    }\n    /* take over this slot */\n    struct aff_pagebuf *p = &af->pbcache[slot];\n    if(p->pagebuf==0){\n\tp->pagebuf = (unsigned char *)valloc(af->image_pagesize); // allocate to a page boundary\n\tif(p->pagebuf==0){\n\t    /* Malloc failed; See if we can just use the first slot */\n\t    slot = 0;\n\t    if(af->pbcache[0].pagebuf==0) return 0; // ugh. Cannot malloc?\n\n\t    /* First slot is available. Just use it. */\n\t    p = &af->pbcache[0];\n\t}\n    }\n    memset(p->pagebuf,0,af->image_pagesize); // clean object reuse\n    p->pagenum = pagenum;\n    p->pagenum_valid = 1;\n    p->pagebuf_valid = 0;\n    p->pagebuf_dirty = 0;\n    p->last = cachetime++;\n    if(af_trace){\n\tfprintf(af_trace,\"   current pages in cache: \");\n\tfor(int i=0;i<af->num_pbufs;i++){\n\t    fprintf(af_trace,\" %\" I64d,af->pbcache[i].pagenum);\n\t}\n\tfprintf(af_trace,\"\\n\");\n    }\n    return p;\n}\n\n\n\n\n"], "fixing_code": ["/*\n * The AFFLIB page abstraction.\n * Distributed under the Berkeley 4-part license\n */\n\n#include \"affconfig.h\"\n#include \"afflib.h\"\n#include \"afflib_i.h\"\n\n\n/* af_read_sizes:\n * Get the page sizes if they are set in the file.\n */\nvoid af_read_sizes(AFFILE *af)\n{\n    af_get_seg(af,AF_SECTORSIZE,&af->image_sectorsize,0,0);\n    if(af->image_sectorsize==0) af->image_sectorsize = 512; // reasonable default\n\n    if(af_get_seg(af,AF_PAGESIZE,&af->image_pagesize,0,0)){\n\taf_get_seg(af,AF_SEGSIZE_D,&af->image_pagesize,0,0); // try old name\n    }\n\n    /* Read the badflag if it is present.\n     * Be sure to adjust badflag size to current sector size (which may have changed).\n     */\n    if(af->badflag!=0) free(af->badflag);\n    af->badflag = (unsigned char *)malloc(af->image_sectorsize);\n    size_t sectorsize = af->image_sectorsize;\n    if(af_get_seg(af,AF_BADFLAG,0,af->badflag,(size_t *)&sectorsize)==0){\n\taf->badflag_set = 1;\n    }\n\n    /* Read the image file segment if it is present.\n     * If it isn't, scan through the disk image to figure out the size of the disk image.\n     */\n\n    if(af_get_segq(af,AF_IMAGESIZE,(int64_t *)&af->image_size)){\n\n\t/* Calculate the imagesize by scanning all of the pages that are in\n\t * the disk image and finding the highest page number.\n\t * Then read that page to find the last allocated byte.\n\t */\n\tchar segname[AF_MAX_NAME_LEN];\n\tsize_t datalen = 0;\n\taf_rewind_seg(af);\t\t//  start at the beginning\n\tint64_t highest_page_number = 0;\n\twhile(af_get_next_seg(af,segname,sizeof(segname),0,0,&datalen)==0){\n\t    if(segname[0]==0) continue;\t// ignore sector\n\t    int64_t pagenum = af_segname_page_number(segname);\n\t    if(pagenum > highest_page_number) highest_page_number = pagenum;\n\t}\n\tsize_t highest_page_len = 0;\n\tif(af_get_page(af,highest_page_number,0,&highest_page_len)==0){\n\t    af->image_size = af->image_pagesize * highest_page_number + highest_page_len;\n\t}\n    }\n    af->image_size_in_file = af->image_size;\n}\n\n\nint af_page_size(AFFILE *af)\n{\n    return af->image_pagesize;\n}\n\nint af_get_pagesize(AFFILE *af)\n{\n    return af->image_pagesize;\n}\n\n/* af_set_sectorsize:\n * Sets the sectorsize.\n * Fails with -1 if imagesize >=0 unless these changes permitted\n */\nint af_set_sectorsize(AFFILE *af,int sectorsize)\n{\n    struct af_vnode_info vni;\n    af_vstat(af,&vni);\n    if(vni.changable_pagesize==0 && af->image_size>0){\n\terrno = EINVAL;\n\treturn -1;\n    }\n    af->image_sectorsize =sectorsize;\n    if(af->badflag==0) af->badflag = (unsigned char *)malloc(sectorsize);\n    else af->badflag = (unsigned char *)realloc(af->badflag,sectorsize);\n    af->badflag_set = 0;\n\n    if(af_update_seg(af,AF_SECTORSIZE,sectorsize,0,0)){\n\tif(errno != ENOTSUP) return -1;\n    }\n    return 0;\n}\n\nint\taf_get_sectorsize(AFFILE *af)\t// returns sector size\n{\n    return af->image_sectorsize;\n}\n\n/*\n * af_set_pagesize:\n * Sets the pagesize. Fails with -1 if it can't be changed.\n */\nint af_set_pagesize(AFFILE *af,uint32_t pagesize)\n{\n    /* Allow the pagesize to be changed if it hasn't been set yet\n     * and if this format doesn't support metadata updating (which is the raw formats)\n     */\n    struct af_vnode_info vni;\n\n    af_vstat(af,&vni);\n\n    if(vni.changable_pagesize==0 && af->image_size>0){\n\tif(pagesize==af->image_pagesize) return 0; // it's already set to this, so let it pass\n\terrno = EINVAL;\n\treturn -1;\n    }\n    if(pagesize % af->image_sectorsize != 0){\n\t(*af->error_reporter)(\"Cannot set pagesize to %d (sectorsize=%d)\\n\",\n\t\t\t      pagesize,af->image_sectorsize);\n\terrno = EINVAL;\n\treturn -1;\n    }\n\n    af->image_pagesize = pagesize;\n    if(af_update_seg(af,AF_PAGESIZE,pagesize,0,0)){\n\tif(errno != ENOTSUP) return -1;\t// error updating (don't report ENOTSUP);\n    }\n    return 0;\n}\n\n\n/****************************************************************\n *** page-level interface\n ****************************************************************/\n\nint af_get_page_raw(AFFILE *af,int64_t pagenum,uint32_t *arg,\n\t\t    unsigned char *data,size_t *bytes)\n{\n    char segname[AF_MAX_NAME_LEN];\n\n    memset(segname,0,sizeof(segname));\n    sprintf(segname,AF_PAGE,pagenum);\n    int r = af_get_seg(af,segname,arg,data,bytes);\n    if(r < 0 && errno == ENOENT)\n    {\n\t/* Couldn't read with AF_PAGE; try AF_SEG_D.\n\t * This is legacy for the old AFF files. Perhaps we should delete it.\n\t */\n\tsprintf(segname,AF_SEG_D,pagenum);\n\tr = af_get_seg(af,segname,arg,data,bytes);\n    }\n    /* Update the counters */\n    if(r==0 && bytes && *bytes>0) af->pages_read++; // note that we read a page\n    return r;\n}\n\n/* af_get_page:\n * Get a page from its named segment.\n * If the page is compressed, uncompress it.\n * data points to a segmenet of at least *bytes;\n * *bytes is then modified to indicate the actual amount of bytes read.\n * Return 0 if success, -1 if fail.\n */\n\nint af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)\n{\n    uint32_t arg=0;\n    size_t page_len=0;\n\n    if (af_trace){\n\tfprintf(af_trace,\"af_get_page(%p,pagenum=%\" I64d \",buf=%p,bytes=%u)\\n\",af,pagenum,data,(int)*bytes);\n    }\n\n    /* Find out the size of the segment and if it is compressed or not.\n     * If we can't find it with new nomenclature, try the old one...\n     */\n    int r = af_get_page_raw(af,pagenum,&arg,0,&page_len);\n    if(r){\n\t/* Segment doesn't exist.\n\t * If we have been provided with a buffer,\n\t * fill buffer with the 'bad segment' flag and return.\n\t */\n\tif(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT)\n\t{\n\t    for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize;\n\t\ti+= af->image_sectorsize){\n\t\tmemcpy(data+i,af->badflag,af->image_sectorsize);\n\t\taf->bytes_memcpy += af->image_sectorsize;\n\t    }\n\n\t    r = 0;\n\t}\n\treturn r;\t\t// segment doesn't exist\n    }\n\n\n    /* If the segment isn't compressed, just get it*/\n    uint32_t pageflag = 0;\n    if((arg & AF_PAGE_COMPRESSED)==0){\n\tif(data==0){\t\t\t// if no data provided, just return size of the segment if requested\n\t    if(bytes) *bytes = page_len;\t// set the number of bytes in the page if requested\n\t    return 0;\n\t}\n\tint ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes);\n\tif(*bytes > page_len) *bytes = page_len; // we only read this much\n\tif(ret!=0) return ret;\t\t// some error happened?\n    }\n    else {\n\t/* Allocate memory to hold the compressed segment */\n\tunsigned char *compressed_data = (unsigned char *)malloc(page_len);\n\tsize_t compressed_data_len = page_len;\n\tif(compressed_data==0){\n\t    return -2;\t\t\t// memory error\n\t}\n\n\t/* Get the data */\n\tif(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){\n\t    free(compressed_data);\n\t    return -3;\t\t\t// read error\n\t}\n\n\t/* Sanity check to avoid undefined behaviour when calling malloc below with pagesize from a corrupt AFF image. */\n\tif(af->image_pagesize <= 0 || af->image_pagesize > 16*1024*1024)\n\t    return -1;\n\n\n\t/* Now uncompress directly into the buffer provided by the caller, unless the caller didn't\n\t * provide a buffer. If that happens, allocate our own...\n\t */\n\tint res = -1;\t\t\t// 0 is success\n\tbool free_data = false;\n\tif(data==0){\n\t    data = (unsigned char *)malloc(af->image_pagesize);\n\t    free_data = true;\n\t    *bytes = af->image_pagesize; // I can hold this much\n\t}\n\n\tswitch((pageflag & AF_PAGE_COMP_ALG_MASK)){\n\tcase AF_PAGE_COMP_ALG_ZERO:\n\t    if(compressed_data_len != 4){\n\t\t(*af->error_reporter)(\"ALG_ZERO compressed data is %d bytes, expected 4.\",compressed_data_len);\n\t\tbreak;\n\t    }\n\t    memset(data,0,af->image_pagesize);\n\t    *bytes = ntohl(*(long *)compressed_data);\n\t    res = 0;\t\t\t// not very hard to decompress with the ZERO compressor.\n\t    break;\n\n\tcase AF_PAGE_COMP_ALG_ZLIB:\n\t    res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len);\n\t    switch(res){\n\t    case Z_OK:\n\t\tbreak;\n\t    case Z_ERRNO:\n\t\t(*af->error_reporter)(\"Z_ERRNOR decompressing segment %\" I64d,pagenum);\n\t    case Z_STREAM_ERROR:\n\t\t(*af->error_reporter)(\"Z_STREAM_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_DATA_ERROR:\n\t\t(*af->error_reporter)(\"Z_DATA_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_MEM_ERROR:\n\t\t(*af->error_reporter)(\"Z_MEM_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_BUF_ERROR:\n\t\t(*af->error_reporter)(\"Z_BUF_ERROR decompressing segment %\" I64d,pagenum);\n\t    case Z_VERSION_ERROR:\n\t\t(*af->error_reporter)(\"Z_VERSION_ERROR decompressing segment %\" I64d,pagenum);\n\t    default:\n\t\t(*af->error_reporter)(\"uncompress returned an invalid value in get_segment\");\n\t    }\n\t    break;\n\n#ifdef USE_LZMA\n\tcase AF_PAGE_COMP_ALG_LZMA:\n\t    res = lzma_uncompress(data,bytes,compressed_data,compressed_data_len);\n\t    if (af_trace) fprintf(af_trace,\"   LZMA decompressed page %\" I64d \". %d bytes => %u bytes\\n\",\n\t\t\t\t  pagenum,(int)compressed_data_len,(int)*bytes);\n\t    switch(res){\n\t    case 0:break;\t\t// OK\n\t    case 1:(*af->error_reporter)(\"LZMA header error decompressing segment %\" I64d \"\\n\",pagenum);\n\t\tbreak;\n\t    case 2:(*af->error_reporter)(\"LZMA memory error decompressing segment %\" I64d \"\\n\",pagenum);\n\t\tbreak;\n\t    }\n\t    break;\n#endif\n\n\tdefault:\n\t    (*af->error_reporter)(\"Unknown compression algorithm 0x%d\",\n\t\t\t\t  pageflag & AF_PAGE_COMP_ALG_MASK);\n\t    break;\n\t}\n\n\tif(free_data){\n\t    free(data);\n\t    data = 0;\t\t\t// restore the way it was\n\t}\n\tfree(compressed_data);\t\t// don't need this one anymore\n\taf->pages_decompressed++;\n\tif(res!=Z_OK) return -1;\n    }\n\n    /* If the page size is larger than the sector_size,\n     * make sure that the rest of the sector is zeroed, and that the\n     * rest after that has the 'bad block' notation.\n     */\n    if(data && (af->image_pagesize > af->image_sectorsize)){\n\tconst int SECTOR_SIZE = af->image_sectorsize;\t// for ease of typing\n\tsize_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE;\n\tfor(size_t i=0;i<bytes_left_in_sector;i++){\n\t    data[*bytes + i] = 0;\n\t}\n\tsize_t end_of_data = *bytes + bytes_left_in_sector;\n\n\t/* Now fill to the end of the page... */\n\tfor(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){\n\t    memcpy(data+i,af->badflag,SECTOR_SIZE);\n\t    af->bytes_memcpy += SECTOR_SIZE;\n\t}\n    }\n    return 0;\n}\n\n\nstatic bool is_buffer_zero(unsigned char *buf,int buflen)\n{\n    if(buflen >= (int)sizeof(long))\n    {\n        // align to word boundary\n        buflen -= (intptr_t)buf % sizeof(long);\n\n        while((intptr_t)buf % sizeof(long))\n        {\n            if(*buf++)\n                return false;\n        }\n\n        // read in words\n        long *ptr = (long*)buf;\n        buf += buflen - buflen % sizeof(long);\n        buflen %= sizeof(long);\n\n        while(ptr < (long*)buf)\n        {\n            if(*ptr++)\n                return false;\n        }\n    }\n\n    while(buflen--)\n    {\n        if(*buf++)\n            return false;\n    }\n\n    return true;\n}\n\n/* Write a actual data segment to the disk and sign if necessary. */\nint af_update_page(AFFILE *af,int64_t pagenum,unsigned char *data,int datalen)\n{\n    char segname_buf[32];\n    snprintf(segname_buf,sizeof(segname_buf),AF_PAGE,pagenum); // determine segment name\n\n#ifdef USE_AFFSIGS\n    /* Write out the signature if we have a private key */\n    if(af->crypto && af->crypto->sign_privkey){\n\taf_sign_seg3(af,segname_buf,0,data,datalen,AF_SIGNATURE_MODE1);\n    }\n#endif\n\n#ifdef HAVE_MD5\n    /* Write out MD5 if requested */\n    if(af->write_md5){\n\tunsigned char md5_buf[16];\n\tchar md5name_buf[32];\n\tMD5(data,datalen,md5_buf);\n\tsnprintf(md5name_buf,sizeof(md5name_buf),AF_PAGE_MD5,pagenum);\n\taf_update_segf(af,md5name_buf,0,md5_buf,sizeof(md5_buf),AF_SIGFLAG_NOSIG); // ignore failure\n    }\n#endif\n#ifdef HAVE_SHA1\n    /* Write out SHA1 if requested */\n    if(af->write_sha1){\n\tunsigned char sha1_buf[20];\n\tchar sha1name_buf[32];\n\tSHA1(data,datalen,sha1_buf);\n\tsnprintf(sha1name_buf,sizeof(sha1name_buf),AF_PAGE_SHA1,pagenum);\n\taf_update_segf(af,sha1name_buf,0,sha1_buf,sizeof(sha1_buf),AF_SIGFLAG_NOSIG); // ignore failure\n    }\n#endif\n    /* Write out SHA256 if requested and if SHA256 is available */\n    if(af->write_sha256){\n\tunsigned char sha256_buf[32];\n\tif(af_SHA256(data,datalen,sha256_buf)==0){\n\t    char sha256name_buf[32];\n\t    snprintf(sha256name_buf,sizeof(sha256name_buf),AF_PAGE_SHA256,pagenum);\n\t    af_update_segf(af,sha256name_buf,0,sha256_buf,sizeof(sha256_buf),AF_SIGFLAG_NOSIG); // ignore failure\n\t}\n    }\n\n    /* Check for bypass */\n    if(af->v->write){\n\tint r = (*af->v->write)(af,data,af->image_pagesize * pagenum,datalen);\n\tif(r!=datalen) return -1;\n\treturn 0;\n    }\n\n    struct affcallback_info acbi;\n    int ret = 0;\n    uint64_t starting_pages_written = af->pages_written;\n\n    /* Setup the callback structure */\n    memset(&acbi,0,sizeof(acbi));\n    acbi.info_version = 1;\n    acbi.af = af->parent ? af->parent : af;\n    acbi.pagenum = pagenum;\n    acbi.bytes_to_write = datalen;\n\n    size_t destLen = af->image_pagesize;\t// it could be this big.\n\n    /* Compress and write the data, if we are allowed to compress */\n    if(af->compression_type != AF_COMPRESSION_ALG_NONE){\n\tunsigned char *cdata = (unsigned char *)malloc(destLen); // compressed data\n\tuint32_t *ldata = (uint32_t *)cdata; // allows me to reference as a buffer of uint32_ts\n\tif(cdata!=0){\t\t// If data could be allocated\n\t    int cres = -1;\t\t// compression results\n\t    uint32_t flag = 0;\t// flag for data segment\n\t    int dont_compress = 0;\n\n\t    /* Try zero compression first; it's the best algorithm we have  */\n\t    if(is_buffer_zero(data,datalen)){\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_ZERO;\n\t\tacbi.compression_level = AF_COMPRESSION_MAX;\n\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\t*ldata = htonl(datalen); // store the data length\n\t\tdestLen = 4;\t\t // 4 bytes\n\t\tflag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_ZERO | AF_PAGE_COMP_MAX;\n\t\tcres = 0;\n\n\t\tacbi.compressed = 1;\t\t// it was compressed\n\t\tif(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t    }\n\n#ifdef USE_LZMA\n\t    if(cres!=0 && af->compression_type==AF_COMPRESSION_ALG_LZMA){ // try to compress with LZMA\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_LZMA;\n\t\tacbi.compression_level = 7; // right now, this is the level we use\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\tcres = lzma_compress(cdata,&destLen,data,datalen,9);\n#if 0\n\t\tswitch(cres){\n\t\tcase 0:break;\t\t// OKAY\n\t\tcase 1: (*af->error_reporter)(\"LZMA: Unspecified Error\\n\");break;\n\t\tcase 2: (*af->error_reporter)(\"LZMA: Memory Allocating Error\\n\");break;\n\t\tcase 3: (*af->error_reporter)(\"LZMA: Output buffer OVERFLOW\\n\"); break;\n\t\tdefault: (*af->error_reporter)(\"LZMA: Unknown error %d\\n\",cres);break;\n\t\t}\n#endif\n\t\tif(cres==0){\n\t\t    flag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_LZMA;\n\t\t    acbi.compressed = 1;\n\t\t    if(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t\t}\n\t\telse {\n\t\t    /* Don't bother reporting LZMA errors; we just won't compress */\n\t\t    dont_compress = 1;\n\t\t    if(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t\t}\n\t    }\n#endif\n\n\t    if(cres!=0\n\t       && af->compression_type==AF_COMPRESSION_ALG_ZLIB\n\t       && dont_compress==0){ // try to compress with zlib\n\t\tacbi.compression_alg   = AF_PAGE_COMP_ALG_ZLIB; // only one that we support\n\t\tacbi.compression_level = af->compression_level;\n\t\tif(af->w_callback) { acbi.phase = 1; (*af->w_callback)(&acbi); }\n\n\t\tcres = compress2((Bytef *)cdata, (uLongf *)&destLen,\n\t\t\t\t (Bytef *)data,datalen, af->compression_level);\n\n\t\tif(cres==0){\n\t\t    flag = AF_PAGE_COMPRESSED | AF_PAGE_COMP_ALG_ZLIB;\n\t\t    if(af->compression_level == AF_COMPRESSION_MAX){\n\t\t\tflag |= AF_PAGE_COMP_MAX; // useful to know it can't be better\n\t\t    }\n\t\t}\n\t\tacbi.compressed = 1;\t// it was compressed (or not compressed)\n\t\tif(af->w_callback) {acbi.phase = 2;(*af->w_callback)(&acbi);}\n\t    }\n\n\t    if(cres==0 && destLen < af->image_pagesize){\n\t\t/* Prepare to write out the compressed segment with compression */\n\t\tif(af->w_callback) {acbi.phase = 3;(*af->w_callback)(&acbi);}\n\t\tret = af_update_segf(af,segname_buf,flag,cdata,destLen,AF_SIGFLAG_NOSIG);\n\t\tacbi.bytes_written = destLen;\n\t\tif(af->w_callback) {acbi.phase = 4;(*af->w_callback)(&acbi);}\n\t\tif(ret==0){\n\t\t    af->pages_written++;\n\t\t    af->pages_compressed++;\n\t\t}\n\t    }\n\t    free(cdata);\n\t    cdata = 0;\n\t}\n    }\n\n    /* If a compressed segment was not written, write it uncompressed */\n    if(af->pages_written == starting_pages_written){\n\tif(af->w_callback) {acbi.phase = 3;(*af->w_callback)(&acbi);}\n\tret = af_update_segf(af,segname_buf,0,data,datalen,AF_SIGFLAG_NOSIG);\n\tacbi.bytes_written = datalen;\n\tif(af->w_callback) {acbi.phase = 4;(*af->w_callback)(&acbi);}\n\tif(ret==0){\n\t    acbi.bytes_written = datalen;\t// because that is how much we wrote\n\t    af->pages_written++;\n\t}\n    }\n    return ret;\n}\n\n/****************************************************************\n *** Cache interface\n ****************************************************************/\n\n/* The page cache is a read/write cache.\n *\n * Pages that are read are cached after they are decompressed.\n * When new pages are fetched, we check the cache first to see if they are there;\n * if so, they are satsfied by the cache.\n *\n * Modifications are written to the cache, then dumped to the disk.\n *\n * The cache is managed by two functions:\n * af_cache_flush(af) - (prevously af_purge)\n *      - Makes sure that all dirty buffers are written.\n *      - Sets af->pb=NULL (no current page)\n *      - (returns 0 if success, -1 if failure.)\n *\n * af_cache_writethrough(af,page,buf,buflen)\n *      - used for write bypass\n *\n */\n\nstatic int cachetime = 0;\n\n\nint af_cache_flush(AFFILE *af)\n{\n    if(af_trace) fprintf(af_trace,\"af_cache_flush()\\n\");\n    int ret = 0;\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagebuf_valid && p->pagebuf_dirty){\n\t    if(af_update_page(af,p->pagenum,p->pagebuf,p->pagebuf_bytes)){\n\t\tret = -1;\t\t// got an error; keep going, though\n\t    }\n\t    p->pagebuf_dirty = 0;\n\t    if(af_trace) fprintf(af_trace,\"af_cache_flush: slot %d page %\" PRIu64 \" flushed.\\n\",i,p->pagenum);\n\t}\n    }\n    return ret;\t\t\t\t// now return the error that I might have gotten\n}\n\n/* If the page being written is in the cache, update it.\n * Question: would it make sense to copy the data anyway? I don't think so, because\n * the main use of writethrough is when imaging, and in that event you probably don't\n * want the extra memcpy.\n */\nvoid af_cache_writethrough(AFFILE *af,int64_t pagenum,const unsigned char *buf,int bufflen)\n{\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid && p->pagenum == pagenum){\n\t    if(p->pagebuf_dirty){\n\t\t(*af->error_reporter)(\"af_cache_writethrough: overwriting page %\" I64u \".\\n\",pagenum);\n\t\texit(-1);\t\t// this shouldn't happen\n\t    }\n\t    memcpy(p->pagebuf,buf,bufflen);\n\t    memset(p->pagebuf+bufflen,0,af->image_pagesize-bufflen); // zero fill the rest\n\t    af->bytes_memcpy += bufflen;\n\t    p->pagebuf_valid = 1;\t// we have a copy of it now.\n\t    p->pagebuf_dirty = 0;\t// but it isn't dirty\n\t    p->last = cachetime++;\n\t}\n    }\n}\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#ifndef HAVE_VALLOC\n#define valloc malloc\n#endif\n\nstruct aff_pagebuf *af_cache_alloc(AFFILE *af,int64_t pagenum)\n{\n    if(af_trace) fprintf(af_trace,\"af_cache_alloc(%p,%\" I64d \")\\n\",af,pagenum);\n\n    /* Make sure nothing in the cache is dirty */\n    if(af_cache_flush(af) < 0)\n\treturn 0;\n\n    /* See if this page is already in the cache */\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid && p->pagenum==pagenum){\n\t    af->cache_hits++;\n\t    if(af_trace) fprintf(af_trace,\"  page %\" I64d \" satisfied fromcache\\n\",pagenum);\n\t    p->last = cachetime++;\n\t    return p;\n\t}\n    }\n\n    af->cache_misses++;\n    int slot = -1;\n    /* See if there is an empty slot in the cache */\n    for(int i=0;i<af->num_pbufs;i++){\n\tstruct aff_pagebuf *p = &af->pbcache[i];\n\tif(p->pagenum_valid==0){\n\t    slot = i;\n\t    if(af_trace) fprintf(af_trace,\"  slot %d given to page %\" I64d \"\\n\",slot,pagenum);\n\t    break;\n\t}\n    }\n    if(slot==-1){\n\t/* Find the oldest cache entry */\n\tint oldest_i = 0;\n\tint oldest_t = af->pbcache[0].last;\n\tfor(int i=1;i<af->num_pbufs;i++){\n\t    if(af->pbcache[i].last < oldest_t){\n\t\toldest_t = af->pbcache[i].last;\n\t\toldest_i = i;\n\t    }\n\t}\n\tslot = oldest_i;\n\tif(af_trace) fprintf(af_trace,\"  slot %d assigned to page %\" I64d \"\\n\",slot,pagenum);\n    }\n    /* take over this slot */\n    struct aff_pagebuf *p = &af->pbcache[slot];\n    if(p->pagebuf==0){\n\tp->pagebuf = (unsigned char *)valloc(af->image_pagesize); // allocate to a page boundary\n\tif(p->pagebuf==0){\n\t    /* Malloc failed; See if we can just use the first slot */\n\t    slot = 0;\n\t    if(af->pbcache[0].pagebuf==0) return 0; // ugh. Cannot malloc?\n\n\t    /* First slot is available. Just use it. */\n\t    p = &af->pbcache[0];\n\t}\n    }\n    memset(p->pagebuf,0,af->image_pagesize); // clean object reuse\n    p->pagenum = pagenum;\n    p->pagenum_valid = 1;\n    p->pagebuf_valid = 0;\n    p->pagebuf_dirty = 0;\n    p->last = cachetime++;\n    if(af_trace){\n\tfprintf(af_trace,\"   current pages in cache: \");\n\tfor(int i=0;i<af->num_pbufs;i++){\n\t    fprintf(af_trace,\" %\" I64d,af->pbcache[i].pagenum);\n\t}\n\tfprintf(af_trace,\"\\n\");\n    }\n    return p;\n}\n\n\n\n\n"], "filenames": ["lib/afflib_pages.cpp"], "buggy_code_start_loc": [220], "buggy_code_end_loc": [220], "fixing_code_start_loc": [221], "fixing_code_end_loc": [226], "type": "CWE-20", "message": "The af_get_page() function in lib/afflib_pages.cpp in AFFLIB (aka AFFLIBv3) through 3.7.16 allows remote attackers to cause a denial of service (segmentation fault) via a corrupt AFF image that triggers an unexpected pagesize value.", "other": {"cve": {"id": "CVE-2018-8050", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-11T06:29:00.207", "lastModified": "2018-04-12T14:18:29.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The af_get_page() function in lib/afflib_pages.cpp in AFFLIB (aka AFFLIBv3) through 3.7.16 allows remote attackers to cause a denial of service (segmentation fault) via a corrupt AFF image that triggers an unexpected pagesize value."}, {"lang": "es", "value": "La funci\u00f3n af_get_page() en lib/afflib_pages.cpp en AFFLIB (tambi\u00e9n conocido como AFFLIBv3), hasta la versi\u00f3n 3.7.16, permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n) mediante una imagen AFF corrupta que desencadena un valor de tama\u00f1o de p\u00e1gina inesperado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:afflib_project:afflib:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.7.16", "matchCriteriaId": "F063B481-A66C-4710-95F4-C6E8BC98E25D"}]}]}], "references": [{"url": "https://github.com/sshock/AFFLIBv3/commit/435a2ca802358a3debb6d164d2c33049131df81c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sshock/AFFLIBv3/commit/435a2ca802358a3debb6d164d2c33049131df81c"}}