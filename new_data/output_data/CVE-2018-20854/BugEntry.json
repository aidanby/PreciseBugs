{"buggy_code": ["// SPDX-License-Identifier: (GPL-2.0 OR MIT)\n/*\n * SerDes PHY driver for Microsemi Ocelot\n *\n * Copyright (c) 2018 Microsemi\n *\n */\n\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <soc/mscc/ocelot_hsio.h>\n#include <dt-bindings/phy/phy-ocelot-serdes.h>\n\nstruct serdes_ctrl {\n\tstruct regmap\t\t*regs;\n\tstruct device\t\t*dev;\n\tstruct phy\t\t*phys[SERDES_MAX];\n};\n\nstruct serdes_macro {\n\tu8\t\t\tidx;\n\t/* Not used when in QSGMII or PCIe mode */\n\tint\t\t\tport;\n\tstruct serdes_ctrl\t*ctrl;\n};\n\n#define MCB_S1G_CFG_TIMEOUT     50\n\nstatic int __serdes_write_mcb_s1g(struct regmap *regmap, u8 macro, u32 op)\n{\n\tunsigned int regval;\n\n\tregmap_write(regmap, HSIO_MCB_S1G_ADDR_CFG, op |\n\t\t     HSIO_MCB_S1G_ADDR_CFG_SERDES1G_ADDR(BIT(macro)));\n\n\treturn regmap_read_poll_timeout(regmap, HSIO_MCB_S1G_ADDR_CFG, regval,\n\t\t\t\t\t(regval & op) != op, 100,\n\t\t\t\t\tMCB_S1G_CFG_TIMEOUT * 1000);\n}\n\nstatic int serdes_commit_mcb_s1g(struct regmap *regmap, u8 macro)\n{\n\treturn __serdes_write_mcb_s1g(regmap, macro,\n\t\tHSIO_MCB_S1G_ADDR_CFG_SERDES1G_WR_ONE_SHOT);\n}\n\nstatic int serdes_update_mcb_s1g(struct regmap *regmap, u8 macro)\n{\n\treturn __serdes_write_mcb_s1g(regmap, macro,\n\t\tHSIO_MCB_S1G_ADDR_CFG_SERDES1G_RD_ONE_SHOT);\n}\n\nstatic int serdes_init_s1g(struct regmap *regmap, u8 serdes)\n{\n\tint ret;\n\n\tret = serdes_update_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(regmap, HSIO_S1G_COMMON_CFG,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_LANE |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_ELOOP |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_FLOOP,\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_LANE);\n\n\tregmap_update_bits(regmap, HSIO_S1G_PLL_CFG,\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_ENA |\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA_M,\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA(200) |\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_ENA);\n\n\tregmap_update_bits(regmap, HSIO_S1G_MISC_CFG,\n\t\t\t   HSIO_S1G_MISC_CFG_DES_100FX_CPMD_ENA |\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST,\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST);\n\n\tret = serdes_commit_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(regmap, HSIO_S1G_COMMON_CFG,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST);\n\n\tregmap_update_bits(regmap, HSIO_S1G_MISC_CFG,\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST, 0);\n\n\tret = serdes_commit_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstruct serdes_mux {\n\tu8\t\t\tidx;\n\tu8\t\t\tport;\n\tenum phy_mode\t\tmode;\n\tu32\t\t\tmask;\n\tu32\t\t\tmux;\n};\n\n#define SERDES_MUX(_idx, _port, _mode, _mask, _mux) {\t\t\\\n\t.idx = _idx,\t\t\t\t\t\t\\\n\t.port = _port,\t\t\t\t\t\t\\\n\t.mode = _mode,\t\t\t\t\t\t\\\n\t.mask = _mask,\t\t\t\t\t\t\\\n\t.mux = _mux,\t\t\t\t\t\t\\\n}\n\n#define SERDES_MUX_SGMII(i, p, m, c) SERDES_MUX(i, p, PHY_MODE_SGMII, m, c)\n#define SERDES_MUX_QSGMII(i, p, m, c) SERDES_MUX(i, p, PHY_MODE_QSGMII, m, c)\n\nstatic const struct serdes_mux ocelot_serdes_muxes[] = {\n\tSERDES_MUX_SGMII(SERDES1G(0), 0, 0, 0),\n\tSERDES_MUX_SGMII(SERDES1G(1), 1, HSIO_HW_CFG_DEV1G_5_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(1), 5, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE, HSIO_HW_CFG_DEV1G_5_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(2), 2, HSIO_HW_CFG_DEV1G_4_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(2), 4, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_4_MODE, HSIO_HW_CFG_DEV1G_4_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(3), 3, HSIO_HW_CFG_DEV1G_6_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(3), 6, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_6_MODE, HSIO_HW_CFG_DEV1G_6_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(4), 4, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_4_MODE | HSIO_HW_CFG_DEV1G_9_MODE,\n\t\t\t 0),\n\tSERDES_MUX_SGMII(SERDES1G(4), 9, HSIO_HW_CFG_DEV1G_4_MODE |\n\t\t\t HSIO_HW_CFG_DEV1G_9_MODE, HSIO_HW_CFG_DEV1G_4_MODE |\n\t\t\t HSIO_HW_CFG_DEV1G_9_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(5), 5, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE,\n\t\t\t 0),\n\tSERDES_MUX_SGMII(SERDES1G(5), 10, HSIO_HW_CFG_PCIE_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE,\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 4, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 5, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 6, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_SGMII(SERDES6G(0), 7, HSIO_HW_CFG_QSGMII_ENA, 0),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 7, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_SGMII(SERDES6G(1), 8, 0, 0),\n\tSERDES_MUX_SGMII(SERDES6G(2), 10, HSIO_HW_CFG_PCIE_ENA |\n\t\t\t HSIO_HW_CFG_DEV2G5_10_MODE, 0),\n\tSERDES_MUX(SERDES6G(2), 10, PHY_MODE_PCIE, HSIO_HW_CFG_PCIE_ENA,\n\t\t   HSIO_HW_CFG_PCIE_ENA),\n};\n\nstatic int serdes_set_mode(struct phy *phy, enum phy_mode mode)\n{\n\tstruct serdes_macro *macro = phy_get_drvdata(phy);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ocelot_serdes_muxes); i++) {\n\t\tif (macro->idx != ocelot_serdes_muxes[i].idx ||\n\t\t    mode != ocelot_serdes_muxes[i].mode)\n\t\t\tcontinue;\n\n\t\tif (mode != PHY_MODE_QSGMII &&\n\t\t    macro->port != ocelot_serdes_muxes[i].port)\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(macro->ctrl->regs, HSIO_HW_CFG,\n\t\t\t\t\t ocelot_serdes_muxes[i].mask,\n\t\t\t\t\t ocelot_serdes_muxes[i].mux);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (macro->idx <= SERDES1G_MAX)\n\t\t\treturn serdes_init_s1g(macro->ctrl->regs, macro->idx);\n\n\t\t/* SERDES6G and PCIe not supported yet */\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct phy_ops serdes_ops = {\n\t.set_mode\t= serdes_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int serdes_phy_create(struct serdes_ctrl *ctrl, u8 idx, struct phy **phy)\n{\n\tstruct serdes_macro *macro;\n\n\t*phy = devm_phy_create(ctrl->dev, NULL, &serdes_ops);\n\tif (IS_ERR(*phy))\n\t\treturn PTR_ERR(*phy);\n\n\tmacro = devm_kzalloc(ctrl->dev, sizeof(*macro), GFP_KERNEL);\n\tif (!macro)\n\t\treturn -ENOMEM;\n\n\tmacro->idx = idx;\n\tmacro->ctrl = ctrl;\n\tmacro->port = -1;\n\n\tphy_set_drvdata(*phy, macro);\n\n\treturn 0;\n}\n\nstatic int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id serdes_ids[] = {\n\t{ .compatible = \"mscc,vsc7514-serdes\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, serdes_ids);\n\nstatic struct platform_driver mscc_ocelot_serdes = {\n\t.probe\t\t= serdes_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mscc,ocelot-serdes\",\n\t\t.of_match_table = of_match_ptr(serdes_ids),\n\t},\n};\n\nmodule_platform_driver(mscc_ocelot_serdes);\n\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@bootlin.com>\");\nMODULE_DESCRIPTION(\"SerDes driver for Microsemi Ocelot\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: (GPL-2.0 OR MIT)\n/*\n * SerDes PHY driver for Microsemi Ocelot\n *\n * Copyright (c) 2018 Microsemi\n *\n */\n\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <soc/mscc/ocelot_hsio.h>\n#include <dt-bindings/phy/phy-ocelot-serdes.h>\n\nstruct serdes_ctrl {\n\tstruct regmap\t\t*regs;\n\tstruct device\t\t*dev;\n\tstruct phy\t\t*phys[SERDES_MAX];\n};\n\nstruct serdes_macro {\n\tu8\t\t\tidx;\n\t/* Not used when in QSGMII or PCIe mode */\n\tint\t\t\tport;\n\tstruct serdes_ctrl\t*ctrl;\n};\n\n#define MCB_S1G_CFG_TIMEOUT     50\n\nstatic int __serdes_write_mcb_s1g(struct regmap *regmap, u8 macro, u32 op)\n{\n\tunsigned int regval;\n\n\tregmap_write(regmap, HSIO_MCB_S1G_ADDR_CFG, op |\n\t\t     HSIO_MCB_S1G_ADDR_CFG_SERDES1G_ADDR(BIT(macro)));\n\n\treturn regmap_read_poll_timeout(regmap, HSIO_MCB_S1G_ADDR_CFG, regval,\n\t\t\t\t\t(regval & op) != op, 100,\n\t\t\t\t\tMCB_S1G_CFG_TIMEOUT * 1000);\n}\n\nstatic int serdes_commit_mcb_s1g(struct regmap *regmap, u8 macro)\n{\n\treturn __serdes_write_mcb_s1g(regmap, macro,\n\t\tHSIO_MCB_S1G_ADDR_CFG_SERDES1G_WR_ONE_SHOT);\n}\n\nstatic int serdes_update_mcb_s1g(struct regmap *regmap, u8 macro)\n{\n\treturn __serdes_write_mcb_s1g(regmap, macro,\n\t\tHSIO_MCB_S1G_ADDR_CFG_SERDES1G_RD_ONE_SHOT);\n}\n\nstatic int serdes_init_s1g(struct regmap *regmap, u8 serdes)\n{\n\tint ret;\n\n\tret = serdes_update_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(regmap, HSIO_S1G_COMMON_CFG,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_LANE |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_ELOOP |\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_FLOOP,\n\t\t\t   HSIO_S1G_COMMON_CFG_ENA_LANE);\n\n\tregmap_update_bits(regmap, HSIO_S1G_PLL_CFG,\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_ENA |\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA_M,\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_CTRL_DATA(200) |\n\t\t\t   HSIO_S1G_PLL_CFG_PLL_FSM_ENA);\n\n\tregmap_update_bits(regmap, HSIO_S1G_MISC_CFG,\n\t\t\t   HSIO_S1G_MISC_CFG_DES_100FX_CPMD_ENA |\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST,\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST);\n\n\tret = serdes_commit_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(regmap, HSIO_S1G_COMMON_CFG,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST,\n\t\t\t   HSIO_S1G_COMMON_CFG_SYS_RST);\n\n\tregmap_update_bits(regmap, HSIO_S1G_MISC_CFG,\n\t\t\t   HSIO_S1G_MISC_CFG_LANE_RST, 0);\n\n\tret = serdes_commit_mcb_s1g(regmap, serdes);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstruct serdes_mux {\n\tu8\t\t\tidx;\n\tu8\t\t\tport;\n\tenum phy_mode\t\tmode;\n\tu32\t\t\tmask;\n\tu32\t\t\tmux;\n};\n\n#define SERDES_MUX(_idx, _port, _mode, _mask, _mux) {\t\t\\\n\t.idx = _idx,\t\t\t\t\t\t\\\n\t.port = _port,\t\t\t\t\t\t\\\n\t.mode = _mode,\t\t\t\t\t\t\\\n\t.mask = _mask,\t\t\t\t\t\t\\\n\t.mux = _mux,\t\t\t\t\t\t\\\n}\n\n#define SERDES_MUX_SGMII(i, p, m, c) SERDES_MUX(i, p, PHY_MODE_SGMII, m, c)\n#define SERDES_MUX_QSGMII(i, p, m, c) SERDES_MUX(i, p, PHY_MODE_QSGMII, m, c)\n\nstatic const struct serdes_mux ocelot_serdes_muxes[] = {\n\tSERDES_MUX_SGMII(SERDES1G(0), 0, 0, 0),\n\tSERDES_MUX_SGMII(SERDES1G(1), 1, HSIO_HW_CFG_DEV1G_5_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(1), 5, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE, HSIO_HW_CFG_DEV1G_5_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(2), 2, HSIO_HW_CFG_DEV1G_4_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(2), 4, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_4_MODE, HSIO_HW_CFG_DEV1G_4_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(3), 3, HSIO_HW_CFG_DEV1G_6_MODE, 0),\n\tSERDES_MUX_SGMII(SERDES1G(3), 6, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_6_MODE, HSIO_HW_CFG_DEV1G_6_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(4), 4, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_4_MODE | HSIO_HW_CFG_DEV1G_9_MODE,\n\t\t\t 0),\n\tSERDES_MUX_SGMII(SERDES1G(4), 9, HSIO_HW_CFG_DEV1G_4_MODE |\n\t\t\t HSIO_HW_CFG_DEV1G_9_MODE, HSIO_HW_CFG_DEV1G_4_MODE |\n\t\t\t HSIO_HW_CFG_DEV1G_9_MODE),\n\tSERDES_MUX_SGMII(SERDES1G(5), 5, HSIO_HW_CFG_QSGMII_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE,\n\t\t\t 0),\n\tSERDES_MUX_SGMII(SERDES1G(5), 10, HSIO_HW_CFG_PCIE_ENA |\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE,\n\t\t\t HSIO_HW_CFG_DEV1G_5_MODE | HSIO_HW_CFG_DEV2G5_10_MODE),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 4, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 5, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 6, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_SGMII(SERDES6G(0), 7, HSIO_HW_CFG_QSGMII_ENA, 0),\n\tSERDES_MUX_QSGMII(SERDES6G(0), 7, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA),\n\tSERDES_MUX_SGMII(SERDES6G(1), 8, 0, 0),\n\tSERDES_MUX_SGMII(SERDES6G(2), 10, HSIO_HW_CFG_PCIE_ENA |\n\t\t\t HSIO_HW_CFG_DEV2G5_10_MODE, 0),\n\tSERDES_MUX(SERDES6G(2), 10, PHY_MODE_PCIE, HSIO_HW_CFG_PCIE_ENA,\n\t\t   HSIO_HW_CFG_PCIE_ENA),\n};\n\nstatic int serdes_set_mode(struct phy *phy, enum phy_mode mode)\n{\n\tstruct serdes_macro *macro = phy_get_drvdata(phy);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ocelot_serdes_muxes); i++) {\n\t\tif (macro->idx != ocelot_serdes_muxes[i].idx ||\n\t\t    mode != ocelot_serdes_muxes[i].mode)\n\t\t\tcontinue;\n\n\t\tif (mode != PHY_MODE_QSGMII &&\n\t\t    macro->port != ocelot_serdes_muxes[i].port)\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(macro->ctrl->regs, HSIO_HW_CFG,\n\t\t\t\t\t ocelot_serdes_muxes[i].mask,\n\t\t\t\t\t ocelot_serdes_muxes[i].mux);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (macro->idx <= SERDES1G_MAX)\n\t\t\treturn serdes_init_s1g(macro->ctrl->regs, macro->idx);\n\n\t\t/* SERDES6G and PCIe not supported yet */\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct phy_ops serdes_ops = {\n\t.set_mode\t= serdes_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int serdes_phy_create(struct serdes_ctrl *ctrl, u8 idx, struct phy **phy)\n{\n\tstruct serdes_macro *macro;\n\n\t*phy = devm_phy_create(ctrl->dev, NULL, &serdes_ops);\n\tif (IS_ERR(*phy))\n\t\treturn PTR_ERR(*phy);\n\n\tmacro = devm_kzalloc(ctrl->dev, sizeof(*macro), GFP_KERNEL);\n\tif (!macro)\n\t\treturn -ENOMEM;\n\n\tmacro->idx = idx;\n\tmacro->ctrl = ctrl;\n\tmacro->port = -1;\n\n\tphy_set_drvdata(*phy, macro);\n\n\treturn 0;\n}\n\nstatic int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id serdes_ids[] = {\n\t{ .compatible = \"mscc,vsc7514-serdes\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, serdes_ids);\n\nstatic struct platform_driver mscc_ocelot_serdes = {\n\t.probe\t\t= serdes_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mscc,ocelot-serdes\",\n\t\t.of_match_table = of_match_ptr(serdes_ids),\n\t},\n};\n\nmodule_platform_driver(mscc_ocelot_serdes);\n\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@bootlin.com>\");\nMODULE_DESCRIPTION(\"SerDes driver for Microsemi Ocelot\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n"], "filenames": ["drivers/phy/mscc/phy-ocelot-serdes.c"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [264], "fixing_code_start_loc": [209], "fixing_code_end_loc": [264], "type": "CWE-125", "message": "An issue was discovered in the Linux kernel before 4.20. drivers/phy/mscc/phy-ocelot-serdes.c has an off-by-one error with a resultant ctrl->phys out-of-bounds read.", "other": {"cve": {"id": "CVE-2018-20854", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-26T05:15:10.360", "lastModified": "2019-09-06T00:15:11.427", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.20. drivers/phy/mscc/phy-ocelot-serdes.c has an off-by-one error with a resultant ctrl->phys out-of-bounds read."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux anterior a versi\u00f3n 4.20. El archivo drivers/phy/mscc/phy-ocelot-serdes.c presenta un error por un paso (off-by-one) con un resultado de lectura fuera de l\u00edmites de ctrl-)phys."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.20", "matchCriteriaId": "206C569C-BEB7-4638-8334-1CC4B26CA86C"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6acb47d1a318e5b3b7115354ebc4ea060c59d3a1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190905-0002/", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K32450233", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K32450233?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6acb47d1a318e5b3b7115354ebc4ea060c59d3a1"}}