{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2018, Linaro Ltd */\n\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n\n#include \"qrtr.h\"\n\nstruct qrtr_tun {\n\tstruct qrtr_endpoint ep;\n\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n};\n\nstatic int qrtr_tun_send(struct qrtr_endpoint *ep, struct sk_buff *skb)\n{\n\tstruct qrtr_tun *tun = container_of(ep, struct qrtr_tun, ep);\n\n\tskb_queue_tail(&tun->queue, skb);\n\n\t/* wake up any blocking processes, waiting for new data */\n\twake_up_interruptible(&tun->readq);\n\n\treturn 0;\n}\n\nstatic int qrtr_tun_open(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun;\n\n\ttun = kzalloc(sizeof(*tun), GFP_KERNEL);\n\tif (!tun)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&tun->queue);\n\tinit_waitqueue_head(&tun->readq);\n\n\ttun->ep.xmit = qrtr_tun_send;\n\n\tfilp->private_data = tun;\n\n\treturn qrtr_endpoint_register(&tun->ep, QRTR_EP_NID_AUTO);\n}\n\nstatic ssize_t qrtr_tun_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tstruct sk_buff *skb;\n\tint count;\n\n\twhile (!(skb = skb_dequeue(&tun->queue))) {\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t/* Wait until we get data or the endpoint goes away */\n\t\tif (wait_event_interruptible(tun->readq,\n\t\t\t\t\t     !skb_queue_empty(&tun->queue)))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tcount = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, count, to) != count)\n\t\tcount = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn count;\n}\n\nstatic ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t qrtr_tun_poll(struct file *filp, poll_table *wait)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &tun->readq, wait);\n\n\tif (!skb_queue_empty(&tun->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int qrtr_tun_release(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\tstruct sk_buff *skb;\n\n\tqrtr_endpoint_unregister(&tun->ep);\n\n\t/* Discard all SKBs */\n\twhile (!skb_queue_empty(&tun->queue)) {\n\t\tskb = skb_dequeue(&tun->queue);\n\t\tkfree_skb(skb);\n\t}\n\n\tkfree(tun);\n\n\treturn 0;\n}\n\nstatic const struct file_operations qrtr_tun_ops = {\n\t.owner = THIS_MODULE,\n\t.open = qrtr_tun_open,\n\t.poll = qrtr_tun_poll,\n\t.read_iter = qrtr_tun_read_iter,\n\t.write_iter = qrtr_tun_write_iter,\n\t.release = qrtr_tun_release,\n};\n\nstatic struct miscdevice qrtr_tun_miscdev = {\n\tMISC_DYNAMIC_MINOR,\n\t\"qrtr-tun\",\n\t&qrtr_tun_ops,\n};\n\nstatic int __init qrtr_tun_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&qrtr_tun_miscdev);\n\tif (ret)\n\t\tpr_err(\"failed to register Qualcomm IPC Router tun device\\n\");\n\n\treturn ret;\n}\n\nstatic void __exit qrtr_tun_exit(void)\n{\n\tmisc_deregister(&qrtr_tun_miscdev);\n}\n\nmodule_init(qrtr_tun_init);\nmodule_exit(qrtr_tun_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm IPC Router TUN device\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2018, Linaro Ltd */\n\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n\n#include \"qrtr.h\"\n\nstruct qrtr_tun {\n\tstruct qrtr_endpoint ep;\n\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n};\n\nstatic int qrtr_tun_send(struct qrtr_endpoint *ep, struct sk_buff *skb)\n{\n\tstruct qrtr_tun *tun = container_of(ep, struct qrtr_tun, ep);\n\n\tskb_queue_tail(&tun->queue, skb);\n\n\t/* wake up any blocking processes, waiting for new data */\n\twake_up_interruptible(&tun->readq);\n\n\treturn 0;\n}\n\nstatic int qrtr_tun_open(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun;\n\n\ttun = kzalloc(sizeof(*tun), GFP_KERNEL);\n\tif (!tun)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&tun->queue);\n\tinit_waitqueue_head(&tun->readq);\n\n\ttun->ep.xmit = qrtr_tun_send;\n\n\tfilp->private_data = tun;\n\n\treturn qrtr_endpoint_register(&tun->ep, QRTR_EP_NID_AUTO);\n}\n\nstatic ssize_t qrtr_tun_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tstruct sk_buff *skb;\n\tint count;\n\n\twhile (!(skb = skb_dequeue(&tun->queue))) {\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t/* Wait until we get data or the endpoint goes away */\n\t\tif (wait_event_interruptible(tun->readq,\n\t\t\t\t\t     !skb_queue_empty(&tun->queue)))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tcount = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, count, to) != count)\n\t\tcount = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn count;\n}\n\nstatic ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tkfree(kbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t qrtr_tun_poll(struct file *filp, poll_table *wait)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &tun->readq, wait);\n\n\tif (!skb_queue_empty(&tun->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int qrtr_tun_release(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\tstruct sk_buff *skb;\n\n\tqrtr_endpoint_unregister(&tun->ep);\n\n\t/* Discard all SKBs */\n\twhile (!skb_queue_empty(&tun->queue)) {\n\t\tskb = skb_dequeue(&tun->queue);\n\t\tkfree_skb(skb);\n\t}\n\n\tkfree(tun);\n\n\treturn 0;\n}\n\nstatic const struct file_operations qrtr_tun_ops = {\n\t.owner = THIS_MODULE,\n\t.open = qrtr_tun_open,\n\t.poll = qrtr_tun_poll,\n\t.read_iter = qrtr_tun_read_iter,\n\t.write_iter = qrtr_tun_write_iter,\n\t.release = qrtr_tun_release,\n};\n\nstatic struct miscdevice qrtr_tun_miscdev = {\n\tMISC_DYNAMIC_MINOR,\n\t\"qrtr-tun\",\n\t&qrtr_tun_ops,\n};\n\nstatic int __init qrtr_tun_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&qrtr_tun_miscdev);\n\tif (ret)\n\t\tpr_err(\"failed to register Qualcomm IPC Router tun device\\n\");\n\n\treturn ret;\n}\n\nstatic void __exit qrtr_tun_exit(void)\n{\n\tmisc_deregister(&qrtr_tun_miscdev);\n}\n\nmodule_init(qrtr_tun_init);\nmodule_exit(qrtr_tun_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm IPC Router TUN device\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["net/qrtr/tun.c"], "buggy_code_start_loc": [87], "buggy_code_end_loc": [91], "fixing_code_start_loc": [87], "fixing_code_end_loc": [95], "type": "CWE-401", "message": "A memory leak in the qrtr_tun_write_iter() function in net/qrtr/tun.c in the Linux kernel before 5.3 allows attackers to cause a denial of service (memory consumption), aka CID-a21b7f0cff19.", "other": {"cve": {"id": "CVE-2019-19079", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.623", "lastModified": "2023-01-17T21:31:31.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the qrtr_tun_write_iter() function in net/qrtr/tun.c in the Linux kernel before 5.3 allows attackers to cause a denial of service (memory consumption), aka CID-a21b7f0cff19."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n qrtr_tun_write_iter() en el archivo net/qrtr/tun.c en el kernel de Linux versiones anteriores a la versi\u00f3n  5.3, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-a21b7f0cff19."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.18", "versionEndExcluding": "4.19.89", "matchCriteriaId": "3CD7E62F-CBBE-4D8A-84F6-E8F6F0932FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.3", "matchCriteriaId": "376E0E0E-795B-4FBF-919C-339C9D945591"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a21b7f0cff1906a93a0130b74713b15a0b36481d", "source": "cve@mitre.org", "tags": ["Patch", "Tool Signature"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4258-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a21b7f0cff1906a93a0130b74713b15a0b36481d"}}