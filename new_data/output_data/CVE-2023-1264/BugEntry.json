{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * getchar.c: Code related to getting a character from the user or a script\n * file, manipulations with redo buffer and stuff buffer.\n */\n\n#include \"vim.h\"\n\n/*\n * These buffers are used for storing:\n * - stuffed characters: A command that is translated into another command.\n * - redo characters: will redo the last change.\n * - recorded characters: for the \"q\" command.\n *\n * The bytes are stored like in the typeahead buffer:\n * - K_SPECIAL introduces a special key (two more bytes follow).  A literal\n *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.\n * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,\n *   otherwise switching the GUI on would make mappings invalid).\n *   A literal CSI is stored as CSI KS_EXTRA KE_CSI.\n * These translations are also done on multi-byte characters!\n *\n * Escaping CSI bytes is done by the system-specific input functions, called\n * by ui_inchar().\n * Escaping K_SPECIAL is done by inchar().\n * Un-escaping is done by vgetc().\n */\n\n#define MINIMAL_SIZE 20\t\t\t// minimal size for b_str\n\nstatic buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};\n\nstatic int typeahead_char = 0;\t\t// typeahead char that's not flushed\n\n/*\n * when block_redo is TRUE redo buffer will not be changed\n * used by edit() to repeat insertions and 'V' command for redoing\n */\nstatic int\tblock_redo = FALSE;\n\nstatic int\tKeyNoremap = 0;\t    // remapping flags\n\n/*\n * Variables used by vgetorpeek() and flush_buffers().\n *\n * typebuf.tb_buf[] contains all characters that are not consumed yet.\n * typebuf.tb_buf[typebuf.tb_off] is the first valid character.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.\n * The head of the buffer may contain the result of mappings, abbreviations\n * and @a commands.  The length of this part is typebuf.tb_maplen.\n * typebuf.tb_silent is the part where <silent> applies.\n * After the head are characters that come from the terminal.\n * typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that\n * should not be considered for abbreviations.\n * Some parts of typebuf.tb_buf may not be mapped. These parts are remembered\n * in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and\n * contains RM_NONE for the characters that are not to be remapped.\n * typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.\n * (typebuf has been put in globals.h, because check_termcode() needs it).\n */\n#define RM_YES\t\t0\t// tb_noremap: remap\n#define RM_NONE\t\t1\t// tb_noremap: don't remap\n#define RM_SCRIPT\t2\t// tb_noremap: remap local script mappings\n#define RM_ABBR\t\t4\t// tb_noremap: don't remap, do abbrev.\n\n// typebuf.tb_buf has three parts: room in front (for result of mappings), the\n// middle for typeahead and room for new characters (which needs to be 3 *\n// MAXMAPLEN for the Amiga).\n#define TYPELEN_INIT\t(5 * (MAXMAPLEN + 3))\nstatic char_u\ttypebuf_init[TYPELEN_INIT];\t// initial typebuf.tb_buf\nstatic char_u\tnoremapbuf_init[TYPELEN_INIT];\t// initial typebuf.tb_noremap\n\nstatic int\tlast_recorded_len = 0;\t// number of last recorded chars\n\n#ifdef FEAT_EVAL\nmapblock_T\t*last_used_map = NULL;\nint\t\tlast_used_sid = -1;\n#endif\n\nstatic int\tread_readbuf(buffheader_T *buf, int advance);\nstatic void\tinit_typebuf(void);\nstatic void\tmay_sync_undo(void);\nstatic void\tfree_typebuf(void);\nstatic void\tclosescript(void);\nstatic void\tupdatescript(int c);\nstatic int\tvgetorpeek(int);\nstatic int\tinchar(char_u *buf, int maxlen, long wait_time);\n\n/*\n * Free and clear a buffer.\n */\n    static void\nfree_buff(buffheader_T *buf)\n{\n    buffblock_T\t*p, *np;\n\n    for (p = buf->bh_first.b_next; p != NULL; p = np)\n    {\n\tnp = p->b_next;\n\tvim_free(p);\n    }\n    buf->bh_first.b_next = NULL;\n    buf->bh_curr = NULL;\n}\n\n/*\n * Return the contents of a buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    static char_u *\nget_buffcont(\n    buffheader_T\t*buffer,\n    int\t\t\tdozero)\t    // count == zero is not an error\n{\n    long_u\t    count = 0;\n    char_u\t    *p = NULL;\n    char_u\t    *p2;\n    char_u\t    *str;\n    buffblock_T *bp;\n\n    // compute the total length of the string\n    for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\tcount += (long_u)STRLEN(bp->b_str);\n\n    if ((count || dozero) && (p = alloc(count + 1)) != NULL)\n    {\n\tp2 = p;\n\tfor (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\t    for (str = bp->b_str; *str; )\n\t\t*p2++ = *str++;\n\t*p2 = NUL;\n    }\n    return (p);\n}\n\n/*\n * Return the contents of the record buffer as a single string\n * and clear the record buffer.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_recorded(void)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    p = get_buffcont(&recordbuff, TRUE);\n    free_buff(&recordbuff);\n\n    /*\n     * Remove the characters that were added the last time, these must be the\n     * (possibly mapped) characters that stopped the recording.\n     */\n    len = STRLEN(p);\n    if ((int)len >= last_recorded_len)\n    {\n\tlen -= last_recorded_len;\n\tp[len] = NUL;\n    }\n\n    /*\n     * When stopping recording from Insert mode with CTRL-O q, also remove the\n     * CTRL-O.\n     */\n    if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)\n\tp[len - 1] = NUL;\n\n    return (p);\n}\n\n/*\n * Return the contents of the redo buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_inserted(void)\n{\n    return get_buffcont(&redobuff, FALSE);\n}\n\n/*\n * Add string \"s\" after the current block of buffer \"buf\".\n * K_SPECIAL and CSI should have been escaped already.\n */\n    static void\nadd_buff(\n    buffheader_T\t*buf,\n    char_u\t\t*s,\n    long\t\tslen)\t// length of \"s\" or -1\n{\n    buffblock_T *p;\n    long_u\t    len;\n\n    if (slen < 0)\n\tslen = (long)STRLEN(s);\n    if (slen == 0)\t\t\t\t// don't add empty strings\n\treturn;\n\n    if (buf->bh_first.b_next == NULL)\t// first add to list\n    {\n\tbuf->bh_space = 0;\n\tbuf->bh_curr = &(buf->bh_first);\n    }\n    else if (buf->bh_curr == NULL)\t// buffer has already been read\n    {\n\tiemsg(_(e_add_to_internal_buffer_that_was_already_read_from));\n\treturn;\n    }\n    else if (buf->bh_index != 0)\n\tmch_memmove(buf->bh_first.b_next->b_str,\n\t\t    buf->bh_first.b_next->b_str + buf->bh_index,\n\t\t    STRLEN(buf->bh_first.b_next->b_str + buf->bh_index) + 1);\n    buf->bh_index = 0;\n\n    if (buf->bh_space >= (int)slen)\n    {\n\tlen = (long_u)STRLEN(buf->bh_curr->b_str);\n\tvim_strncpy(buf->bh_curr->b_str + len, s, (size_t)slen);\n\tbuf->bh_space -= slen;\n    }\n    else\n    {\n\tif (slen < MINIMAL_SIZE)\n\t    len = MINIMAL_SIZE;\n\telse\n\t    len = slen;\n\tp = alloc(offsetof(buffblock_T, b_str) + len + 1);\n\tif (p == NULL)\n\t    return; // no space, just forget it\n\tbuf->bh_space = (int)(len - slen);\n\tvim_strncpy(p->b_str, s, (size_t)slen);\n\n\tp->b_next = buf->bh_curr->b_next;\n\tbuf->bh_curr->b_next = p;\n\tbuf->bh_curr = p;\n    }\n}\n\n/*\n * Delete \"slen\" bytes from the end of \"buf\".\n * Only works when it was just added.\n */\n    static void\ndelete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len;\n\n    if (buf->bh_curr == NULL)\n\treturn;  // nothing to delete\n    len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len < slen)\n\treturn;\n\n    buf->bh_curr->b_str[len - slen] = NUL;\n    buf->bh_space += slen;\n}\n\n/*\n * Add number \"n\" to buffer \"buf\".\n */\n    static void\nadd_num_buff(buffheader_T *buf, long n)\n{\n    char_u\tnumber[32];\n\n    sprintf((char *)number, \"%ld\", n);\n    add_buff(buf, number, -1L);\n}\n\n/*\n * Add character 'c' to buffer \"buf\".\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    static void\nadd_char_buff(buffheader_T *buf, int c)\n{\n    char_u\tbytes[MB_MAXBYTES + 1];\n    int\t\tlen;\n    int\t\ti;\n    char_u\ttemp[4];\n\n    if (IS_SPECIAL(c))\n\tlen = 1;\n    else\n\tlen = (*mb_char2bytes)(c, bytes);\n    for (i = 0; i < len; ++i)\n    {\n\tif (!IS_SPECIAL(c))\n\t    c = bytes[i];\n\n\tif (IS_SPECIAL(c) || c == K_SPECIAL || c == NUL)\n\t{\n\t    // translate special key code into three byte sequence\n\t    temp[0] = K_SPECIAL;\n\t    temp[1] = K_SECOND(c);\n\t    temp[2] = K_THIRD(c);\n\t    temp[3] = NUL;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    // Translate a CSI to a CSI - KS_EXTRA - KE_CSI sequence\n\t    temp[0] = CSI;\n\t    temp[1] = KS_EXTRA;\n\t    temp[2] = (int)KE_CSI;\n\t    temp[3] = NUL;\n\t}\n#endif\n\telse\n\t{\n\t    temp[0] = c;\n\t    temp[1] = NUL;\n\t}\n\tadd_buff(buf, temp, -1L);\n    }\n}\n\n// First read ahead buffer. Used for translated commands.\nstatic buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};\n\n// Second read ahead buffer. Used for redo.\nstatic buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n\tc = read_readbuf(&readbuf2, advance);\n    return c;\n}\n\n    static int\nread_readbuf(buffheader_T *buf, int advance)\n{\n    char_u\tc;\n    buffblock_T\t*curr;\n\n    if (buf->bh_first.b_next == NULL)  // buffer is empty\n\treturn NUL;\n\n    curr = buf->bh_first.b_next;\n    c = curr->b_str[buf->bh_index];\n\n    if (advance)\n    {\n\tif (curr->b_str[++buf->bh_index] == NUL)\n\t{\n\t    buf->bh_first.b_next = curr->b_next;\n\t    vim_free(curr);\n\t    buf->bh_index = 0;\n\t}\n    }\n    return c;\n}\n\n/*\n * Prepare the read buffers for reading (if they contain something).\n */\n    static void\nstart_stuff(void)\n{\n    if (readbuf1.bh_first.b_next != NULL)\n    {\n\treadbuf1.bh_curr = &(readbuf1.bh_first);\n\treadbuf1.bh_space = 0;\n    }\n    if (readbuf2.bh_first.b_next != NULL)\n    {\n\treadbuf2.bh_curr = &(readbuf2.bh_first);\n\treadbuf2.bh_space = 0;\n    }\n}\n\n/*\n * Return TRUE if the stuff buffer is empty.\n */\n    int\nstuff_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL\n\t && readbuf2.bh_first.b_next == NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if readbuf1 is empty.  There may still be redo characters in\n * redbuf2.\n */\n    int\nreadbuf1_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL);\n}\n#endif\n\n/*\n * Set a typeahead character that won't be flushed.\n */\n    void\ntypeahead_noflush(int c)\n{\n    typeahead_char = c;\n}\n\n/*\n * Remove the contents of the stuff buffer and the mapped characters in the\n * typeahead buffer (used in case of an error).  If \"flush_typeahead\" is true,\n * flush all typeahead characters (used when interrupted by a CTRL-C).\n */\n    void\nflush_buffers(flush_buffers_T flush_typeahead)\n{\n    init_typebuf();\n\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n\n    if (flush_typeahead == FLUSH_MINIMAL)\n    {\n\t// remove mapped characters at the start only\n\ttypebuf.tb_off += typebuf.tb_maplen;\n\ttypebuf.tb_len -= typebuf.tb_maplen;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\tif (typebuf.tb_len == 0)\n\t    typebuf_was_filled = FALSE;\n#endif\n    }\n    else\n    {\n\t// remove typeahead\n\tif (flush_typeahead == FLUSH_INPUT)\n\t    // We have to get all characters, because we may delete the first\n\t    // part of an escape sequence.  In an xterm we get one char at a\n\t    // time and we have to get them all.\n\t    while (inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 10L) != 0)\n\t\t;\n\ttypebuf.tb_off = MAXMAPLEN;\n\ttypebuf.tb_len = 0;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t// Reset the flag that text received from a client or from feedkeys()\n\t// was inserted in the typeahead buffer.\n\ttypebuf_was_filled = FALSE;\n#endif\n    }\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    cmd_silent = FALSE;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * The previous contents of the redo buffer is kept in old_redobuffer.\n * This is used for the CTRL-O <.> command in insert mode.\n */\n    void\nResetRedobuff(void)\n{\n    if (block_redo)\n\treturn;\n\n    free_buff(&old_redobuff);\n    old_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n}\n\n/*\n * Discard the contents of the redo buffer and restore the previous redo\n * buffer.\n */\n    void\nCancelRedo(void)\n{\n    if (block_redo)\n\treturn;\n\n    free_buff(&redobuff);\n    redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n}\n\n/*\n * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.\n * Used before executing autocommands and user functions.\n */\n    void\nsaveRedobuff(save_redo_T *save_redo)\n{\n    char_u\t*s;\n\n    save_redo->sr_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n    save_redo->sr_old_redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n\n    // Make a copy, so that \":normal .\" in a function works.\n    s = get_buffcont(&save_redo->sr_redobuff, FALSE);\n    if (s == NULL)\n\treturn;\n\n    add_buff(&redobuff, s, -1L);\n    vim_free(s);\n}\n\n/*\n * Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.\n * Used after executing autocommands and user functions.\n */\n    void\nrestoreRedobuff(save_redo_T *save_redo)\n{\n    free_buff(&redobuff);\n    redobuff = save_redo->sr_redobuff;\n    free_buff(&old_redobuff);\n    old_redobuff = save_redo->sr_old_redobuff;\n}\n\n/*\n * Append \"s\" to the redo buffer.\n * K_SPECIAL and CSI should already have been escaped.\n */\n    void\nAppendToRedobuff(char_u *s)\n{\n    if (!block_redo)\n\tadd_buff(&redobuff, s, -1L);\n}\n\n/*\n * Append to Redo buffer literally, escaping special characters with CTRL-V.\n * K_SPECIAL and CSI are escaped as well.\n */\n    void\nAppendToRedobuffLit(\n    char_u\t*str,\n    int\t\tlen)\t    // length of \"str\" or -1 for up to the NUL\n{\n    char_u\t*s = str;\n    int\t\tc;\n    char_u\t*start;\n\n    if (block_redo)\n\treturn;\n\n    while (len < 0 ? *s != NUL : s - str < len)\n    {\n\t// Put a string of normal characters in the redo buffer (that's\n\t// faster).\n\tstart = s;\n\twhile (*s >= ' ' && *s < DEL && (len < 0 || s - str < len))\n\t    ++s;\n\n\t// Don't put '0' or '^' as last character, just in case a CTRL-D is\n\t// typed next.\n\tif (*s == NUL && (s[-1] == '0' || s[-1] == '^'))\n\t    --s;\n\tif (s > start)\n\t    add_buff(&redobuff, start, (long)(s - start));\n\n\tif (*s == NUL || (len >= 0 && s - str >= len))\n\t    break;\n\n\t// Handle a special or multibyte character.\n\tif (has_mbyte)\n\t    // Handle composing chars separately.\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\tif (c < ' ' || c == DEL || (*s == NUL && (c == '0' || c == '^')))\n\t    add_char_buff(&redobuff, Ctrl_V);\n\n\t// CTRL-V '0' must be inserted as CTRL-V 048\n\tif (*s == NUL && c == '0')\n\t    add_buff(&redobuff, (char_u *)\"048\", 3L);\n\telse\n\t    add_char_buff(&redobuff, c);\n    }\n}\n\n/*\n * Append a character to the redo buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nAppendCharToRedobuff(int c)\n{\n    if (!block_redo)\n\tadd_char_buff(&redobuff, c);\n}\n\n/*\n * Append a number to the redo buffer.\n */\n    void\nAppendNumberToRedobuff(long n)\n{\n    if (!block_redo)\n\tadd_num_buff(&redobuff, n);\n}\n\n/*\n * Append string \"s\" to the stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffReadbuff(char_u *s)\n{\n    add_buff(&readbuf1, s, -1L);\n}\n\n/*\n * Append string \"s\" to the redo stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffRedoReadbuff(char_u *s)\n{\n    add_buff(&readbuf2, s, -1L);\n}\n\n    static void\nstuffReadbuffLen(char_u *s, long len)\n{\n    add_buff(&readbuf1, s, len);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and\n * escaping other K_SPECIAL and CSI bytes.\n * Change CR, LF and ESC into a space.\n */\n    void\nstuffReadbuffSpec(char_u *s)\n{\n    int c;\n\n    while (*s != NUL)\n    {\n\tif (*s == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t{\n\t    // Insert special key literally.\n\t    stuffReadbuffLen(s, 3L);\n\t    s += 3;\n\t}\n\telse\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (c == CAR || c == NL || c == ESC)\n\t\tc = ' ';\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n#endif\n\n/*\n * Append a character to the stuff buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nstuffcharReadbuff(int c)\n{\n    add_char_buff(&readbuf1, c);\n}\n\n/*\n * Append a number to the stuff buffer.\n */\n    void\nstuffnumReadbuff(long n)\n{\n    add_num_buff(&readbuf1, n);\n}\n\n/*\n * Stuff a string into the typeahead buffer, such that edit() will insert it\n * literally (\"literally\" TRUE) or interpret is as typed characters.\n */\n    void\nstuffescaped(char_u *arg, int literally)\n{\n    int\t\tc;\n    char_u\t*start;\n\n    while (*arg != NUL)\n    {\n\t// Stuff a sequence of normal ASCII characters, that's fast.  Also\n\t// stuff K_SPECIAL to get the effect of a special key when \"literally\"\n\t// is TRUE.\n\tstart = arg;\n\twhile ((*arg >= ' ' && *arg < DEL)\n\t\t|| (*arg == K_SPECIAL && !literally))\n\t    ++arg;\n\tif (arg > start)\n\t    stuffReadbuffLen(start, (long)(arg - start));\n\n\t// stuff a single special character\n\tif (*arg != NUL)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&arg);\n\t    else\n\t\tc = *arg++;\n\t    if (literally && ((c < ' ' && c != TAB) || c == DEL))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n\n/*\n * Read a character from the redo buffer.  Translates K_SPECIAL, CSI and\n * multibyte characters.\n * The redo buffer is left as it is.\n * If init is TRUE, prepare for redo, return FAIL if nothing to redo, OK\n * otherwise.\n * If old is TRUE, use old_redobuff instead of redobuff.\n */\n    static int\nread_redo(int init, int old_redo)\n{\n    static buffblock_T\t*bp;\n    static char_u\t*p;\n    int\t\t\tc;\n    int\t\t\tn;\n    char_u\t\tbuf[MB_MAXBYTES + 1];\n    int\t\t\ti;\n\n    if (init)\n    {\n\tif (old_redo)\n\t    bp = old_redobuff.bh_first.b_next;\n\telse\n\t    bp = redobuff.bh_first.b_next;\n\tif (bp == NULL)\n\t    return FAIL;\n\tp = bp->b_str;\n\treturn OK;\n    }\n    if ((c = *p) != NUL)\n    {\n\t// Reverse the conversion done by add_char_buff()\n\t// For a multi-byte character get all the bytes and return the\n\t// converted character.\n\tif (has_mbyte && (c != K_SPECIAL || p[1] == KS_SPECIAL))\n\t    n = MB_BYTE2LEN_CHECK(c);\n\telse\n\t    n = 1;\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (c == K_SPECIAL) // special key or escaped K_SPECIAL\n\t    {\n\t\tc = TO_SPECIAL(p[1], p[2]);\n\t\tp += 2;\n\t    }\n#ifdef FEAT_GUI\n\t    if (c == CSI)\t// escaped CSI\n\t\tp += 2;\n#endif\n\t    if (*++p == NUL && bp->b_next != NULL)\n\t    {\n\t\tbp = bp->b_next;\n\t\tp = bp->b_str;\n\t    }\n\t    buf[i] = c;\n\t    if (i == n - 1)\t// last byte of a character\n\t    {\n\t\tif (n != 1)\n\t\t    c = (*mb_ptr2char)(buf);\n\t\tbreak;\n\t    }\n\t    c = *p;\n\t    if (c == NUL)\t// cannot happen?\n\t\tbreak;\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Copy the rest of the redo buffer into the stuff buffer (in a slow way).\n * If old_redo is TRUE, use old_redobuff instead of redobuff.\n * The escaped K_SPECIAL and CSI are copied without translation.\n */\n    static void\ncopy_redo(int old_redo)\n{\n    int\t    c;\n\n    while ((c = read_redo(FALSE, old_redo)) != NUL)\n\tadd_char_buff(&readbuf2, c);\n}\n\n/*\n * Stuff the redo buffer into readbuf2.\n * Insert the redo count into the command.\n * If \"old_redo\" is TRUE, the last but one command is repeated\n * instead of the last command (inserting text). This is used for\n * CTRL-O <.> in insert mode\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo(long count, int old_redo)\n{\n    int\t    c;\n\n    // init the pointers; return if nothing to redo\n    if (read_redo(TRUE, old_redo) == FAIL)\n\treturn FAIL;\n\n    c = read_redo(FALSE, old_redo);\n\n#ifdef FEAT_EVAL\n    if (c == K_SID)\n    {\n\t// Copy the <SID>{sid}; sequence\n\tadd_char_buff(&readbuf2, c);\n\tfor (;;)\n\t{\n\t    c = read_redo(FALSE, old_redo);\n\t    add_char_buff(&readbuf2, c);\n\t    if (!isdigit(c))\n\t\tbreak;\n\t}\n\tc = read_redo(FALSE, old_redo);\n    }\n#endif\n\n    // copy the buffer name, if present\n    if (c == '\"')\n    {\n\tadd_buff(&readbuf2, (char_u *)\"\\\"\", 1L);\n\tc = read_redo(FALSE, old_redo);\n\n\t// if a numbered buffer is used, increment the number\n\tif (c >= '1' && c < '9')\n\t    ++c;\n\tadd_char_buff(&readbuf2, c);\n\n\t// the expression register should be re-evaluated\n\tif (c == '=')\n\t{\n\t    add_char_buff(&readbuf2, CAR);\n\t    cmd_silent = TRUE;\n\t}\n\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    if (c == 'v')   // redo Visual\n    {\n\tVIsual = curwin->w_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_select = FALSE;\n\tVIsual_reselect = TRUE;\n\tredo_VIsual_busy = TRUE;\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    // try to enter the count (in place of a previous count)\n    if (count)\n    {\n\twhile (VIM_ISDIGIT(c))\t// skip \"old\" count\n\t    c = read_redo(FALSE, old_redo);\n\tadd_num_buff(&readbuf2, count);\n    }\n\n    // copy the rest from the redo buffer into the stuff buffer\n    add_char_buff(&readbuf2, c);\n    copy_redo(old_redo);\n    return OK;\n}\n\n/*\n * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing\n * the redo buffer into readbuf2.\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo_ins(void)\n{\n    int\t    c;\n\n    if (read_redo(TRUE, FALSE) == FAIL)\n\treturn FAIL;\n    start_stuff();\n\n    // skip the count and the command character\n    while ((c = read_redo(FALSE, FALSE)) != NUL)\n    {\n\tif (vim_strchr((char_u *)\"AaIiRrOo\", c) != NULL)\n\t{\n\t    if (c == 'O' || c == 'o')\n\t\tadd_buff(&readbuf2, NL_STR, -1L);\n\t    break;\n\t}\n    }\n\n    // copy the typed text from the redo buffer into the stuff buffer\n    copy_redo(FALSE);\n    block_redo = TRUE;\n    return OK;\n}\n\n    void\nstop_redo_ins(void)\n{\n    block_redo = FALSE;\n}\n\n/*\n * Initialize typebuf.tb_buf to point to typebuf_init.\n * alloc() cannot be used here: In out-of-memory situations it would\n * be impossible to type anything.\n */\n    static void\ninit_typebuf(void)\n{\n    if (typebuf.tb_buf != NULL)\n\treturn;\n\n    typebuf.tb_buf = typebuf_init;\n    typebuf.tb_noremap = noremapbuf_init;\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_len = 0;\n    typebuf.tb_off = MAXMAPLEN + 4;\n    typebuf.tb_change_cnt = 1;\n}\n\n/*\n * Returns TRUE when keys cannot be remapped.\n */\n    int\nnoremap_keys(void)\n{\n    return KeyNoremap & (RM_NONE|RM_SCRIPT);\n}\n\n/*\n * Insert a string in position 'offset' in the typeahead buffer (for \"@r\"\n * and \":normal\" command, vgetorpeek() and check_termcode()).\n *\n * If \"noremap\" is REMAP_YES, new string can be mapped again.\n * If \"noremap\" is REMAP_NONE, new string cannot be mapped again.\n * If \"noremap\" is REMAP_SKIP, first char of new string cannot be mapped again,\n * but abbreviations are allowed.\n * If \"noremap\" is REMAP_SCRIPT, new string cannot be mapped again, except for\n *\t\t\tscript-local mappings.\n * If \"noremap\" is > 0, that many characters of the new string cannot be mapped.\n *\n * If \"nottyped\" is TRUE, the string does not return KeyTyped (don't use when\n * \"offset\" is non-zero!).\n *\n * If \"silent\" is TRUE, cmd_silent is set when the characters are obtained.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nins_typebuf(\n    char_u\t*str,\n    int\t\tnoremap,\n    int\t\toffset,\n    int\t\tnottyped,\n    int\t\tsilent)\n{\n    char_u\t*s1, *s2;\n    int\t\tnewlen;\n    int\t\taddlen;\n    int\t\ti;\n    int\t\tnewoff;\n    int\t\tval;\n    int\t\tnrm;\n\n    init_typebuf();\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n    state_no_longer_safe(\"ins_typebuf()\");\n\n    addlen = (int)STRLEN(str);\n\n    if (offset == 0 && addlen <= typebuf.tb_off)\n    {\n\t/*\n\t * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]\n\t */\n\ttypebuf.tb_off -= addlen;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else if (typebuf.tb_len == 0 && typebuf.tb_buflen\n\t\t\t\t\t       >= addlen + 3 * (MAXMAPLEN + 4))\n    {\n\t/*\n\t * Buffer is empty and string fits in the existing buffer.\n\t * Leave some space before and after, if possible.\n\t */\n\ttypebuf.tb_off = (typebuf.tb_buflen - addlen - 3 * (MAXMAPLEN + 4)) / 2;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else\n    {\n\tint extra;\n\n\t/*\n\t * Need to allocate a new buffer.\n\t * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)\n\t * characters.  We add some extra room to avoid having to allocate too\n\t * often.\n\t */\n\tnewoff = MAXMAPLEN + 4;\n\textra = addlen + newoff + 4 * (MAXMAPLEN + 4);\n\tif (typebuf.tb_len > 2147483647 - extra)\n\t{\n\t    // string is getting too long for a 32 bit int\n\t    emsg(_(e_command_too_complex));    // also calls flush_buffers\n\t    setcursor();\n\t    return FAIL;\n\t}\n\tnewlen = typebuf.tb_len + extra;\n\ts1 = alloc(newlen);\n\tif (s1 == NULL)\t\t    // out of memory\n\t    return FAIL;\n\ts2 = alloc(newlen);\n\tif (s2 == NULL)\t\t    // out of memory\n\t{\n\t    vim_free(s1);\n\t    return FAIL;\n\t}\n\ttypebuf.tb_buflen = newlen;\n\n\t// copy the old chars, before the insertion point\n\tmch_memmove(s1 + newoff, typebuf.tb_buf + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\t// copy the new chars\n\tmch_memmove(s1 + newoff + offset, str, (size_t)addlen);\n\t// copy the old chars, after the insertion point, including the\tNUL at\n\t// the end\n\tmch_memmove(s1 + newoff + offset + addlen,\n\t\t\t\t     typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\tif (typebuf.tb_buf != typebuf_init)\n\t    vim_free(typebuf.tb_buf);\n\ttypebuf.tb_buf = s1;\n\n\tmch_memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\tmch_memmove(s2 + newoff + offset + addlen,\n\t\t   typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n\tif (typebuf.tb_noremap != noremapbuf_init)\n\t    vim_free(typebuf.tb_noremap);\n\ttypebuf.tb_noremap = s2;\n\n\ttypebuf.tb_off = newoff;\n    }\n    typebuf.tb_len += addlen;\n\n    // If noremap == REMAP_SCRIPT: do remap script-local mappings.\n    if (noremap == REMAP_SCRIPT)\n\tval = RM_SCRIPT;\n    else if (noremap == REMAP_SKIP)\n\tval = RM_ABBR;\n    else\n\tval = RM_NONE;\n\n    /*\n     * Adjust typebuf.tb_noremap[] for the new characters:\n     * If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are\n     *\t\t\t(sometimes) not remappable\n     * If noremap == REMAP_YES: all the new characters are mappable\n     * If noremap  > 0: \"noremap\" characters are not remappable, the rest\n     *\t\t\tmappable\n     */\n    if (noremap == REMAP_SKIP)\n\tnrm = 1;\n    else if (noremap < 0)\n\tnrm = addlen;\n    else\n\tnrm = noremap;\n    for (i = 0; i < addlen; ++i)\n\ttypebuf.tb_noremap[typebuf.tb_off + i + offset] =\n\t\t\t\t\t\t  (--nrm >= 0) ? val : RM_YES;\n\n    // tb_maplen and tb_silent only remember the length of mapped and/or\n    // silent mappings at the start of the buffer, assuming that a mapped\n    // sequence doesn't result in typed characters.\n    if (nottyped || typebuf.tb_maplen > offset)\n\ttypebuf.tb_maplen += addlen;\n    if (silent || typebuf.tb_silent > offset)\n    {\n\ttypebuf.tb_silent += addlen;\n\tcmd_silent = TRUE;\n    }\n    if (typebuf.tb_no_abbr_cnt && offset == 0)\t// and not used for abbrev.s\n\ttypebuf.tb_no_abbr_cnt += addlen;\n\n    return OK;\n}\n\n/*\n * Put character \"c\" back into the typeahead buffer.\n * Can be used for a character obtained by vgetc() that needs to be put back.\n * Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to\n * the char.\n * Returns the length of what was inserted.\n */\n    int\nins_char_typebuf(int c, int modifiers)\n{\n    char_u\tbuf[MB_MAXBYTES * 3 + 4];\n    int\t\tlen = special_to_buf(c, modifiers, TRUE, buf);\n\n    buf[len] = NUL;\n    (void)ins_typebuf(buf, KeyNoremap, 0, !KeyTyped, cmd_silent);\n    return len;\n}\n\n/*\n * Return TRUE if the typeahead buffer was changed (while waiting for a\n * character to arrive).  Happens when a message was received from a client or\n * from feedkeys().\n * But check in a more generic way to avoid trouble: When \"typebuf.tb_buf\"\n * changed it was reallocated and the old pointer can no longer be used.\n * Or \"typebuf.tb_off\" may have been changed and we would overwrite characters\n * that was just added.\n */\n    int\ntypebuf_changed(\n    int\t\ttb_change_cnt)\t// old value of typebuf.tb_change_cnt\n{\n    return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n#endif\n\t   ));\n}\n\n/*\n * Return TRUE if there are no characters in the typeahead buffer that have\n * not been typed (result from a mapping or come from \":normal\").\n */\n    int\ntypebuf_typed(void)\n{\n    return typebuf.tb_maplen == 0;\n}\n\n/*\n * Return the number of characters that are mapped (or not typed).\n */\n    int\ntypebuf_maplen(void)\n{\n    return typebuf.tb_maplen;\n}\n\n/*\n * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]\n */\n    void\ndel_typebuf(int len, int offset)\n{\n    int\t    i;\n\n    if (len == 0)\n\treturn;\t\t// nothing to do\n\n    typebuf.tb_len -= len;\n\n    /*\n     * Easy case: Just increase typebuf.tb_off.\n     */\n    if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)\n\t\t\t\t\t\t\t >= 3 * MAXMAPLEN + 3)\n\ttypebuf.tb_off += len;\n    /*\n     * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]\n     */\n    else\n    {\n\ti = typebuf.tb_off + offset;\n\t/*\n\t * Leave some extra room at the end to avoid reallocation.\n\t */\n\tif (typebuf.tb_off > MAXMAPLEN)\n\t{\n\t    mch_memmove(typebuf.tb_buf + MAXMAPLEN,\n\t\t\t     typebuf.tb_buf + typebuf.tb_off, (size_t)offset);\n\t    mch_memmove(typebuf.tb_noremap + MAXMAPLEN,\n\t\t\t typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);\n\t    typebuf.tb_off = MAXMAPLEN;\n\t}\n\t// adjust typebuf.tb_buf (include the NUL at the end)\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t\t\t     typebuf.tb_buf + i + len,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\t// adjust typebuf.tb_noremap[]\n\tmch_memmove(typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t\t typebuf.tb_noremap + i + len,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n    }\n\n    if (typebuf.tb_maplen > offset)\t\t// adjust tb_maplen\n    {\n\tif (typebuf.tb_maplen < offset + len)\n\t    typebuf.tb_maplen = offset;\n\telse\n\t    typebuf.tb_maplen -= len;\n    }\n    if (typebuf.tb_silent > offset)\t\t// adjust tb_silent\n    {\n\tif (typebuf.tb_silent < offset + len)\n\t    typebuf.tb_silent = offset;\n\telse\n\t    typebuf.tb_silent -= len;\n    }\n    if (typebuf.tb_no_abbr_cnt > offset)\t// adjust tb_no_abbr_cnt\n    {\n\tif (typebuf.tb_no_abbr_cnt < offset + len)\n\t    typebuf.tb_no_abbr_cnt = offset;\n\telse\n\t    typebuf.tb_no_abbr_cnt -= len;\n    }\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    // Reset the flag that text received from a client or from feedkeys()\n    // was inserted in the typeahead buffer.\n    typebuf_was_filled = FALSE;\n#endif\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * Write typed characters to script file.\n * If recording is on put the character in the recordbuffer.\n */\n    static void\ngotchars(char_u *chars, int len)\n{\n    char_u\t\t*s = chars;\n    int\t\t\ti;\n    static char_u\tbuf[4];\n    static int\t\tbuflen = 0;\n    int\t\t\ttodo = len;\n\n    while (todo--)\n    {\n\tbuf[buflen++] = *s++;\n\n\t// When receiving a special key sequence, store it until we have all\n\t// the bytes and we can decide what to do with it.\n\tif (buflen == 1 && buf[0] == K_SPECIAL)\n\t    continue;\n\tif (buflen == 2)\n\t    continue;\n\tif (buflen == 3 && buf[1] == KS_EXTRA\n\t\t       && (buf[2] == KE_FOCUSGAINED || buf[2] == KE_FOCUSLOST))\n\t{\n\t    // Drop K_FOCUSGAINED and K_FOCUSLOST, they are not useful in a\n\t    // recording.\n\t    buflen = 0;\n\t    continue;\n\t}\n\n\t// Handle one byte at a time; no translation to be done.\n\tfor (i = 0; i < buflen; ++i)\n\t    updatescript(buf[i]);\n\n\tif (reg_recording != 0)\n\t{\n\t    buf[buflen] = NUL;\n\t    add_buff(&recordbuff, buf, (long)buflen);\n\t    // remember how many chars were last recorded\n\t    last_recorded_len += buflen;\n\t}\n\tbuflen = 0;\n    }\n    may_sync_undo();\n\n#ifdef FEAT_EVAL\n    // output \"debug mode\" message next time in debug mode\n    debug_did_msg = FALSE;\n#endif\n\n    // Since characters have been typed, consider the following to be in\n    // another mapping.  Search string will be kept in history.\n    ++maptick;\n}\n\n/*\n * Undo the last gotchars() for \"len\" bytes.  To be used when putting a typed\n * character back into the typeahead buffer, thus gotchars() will be called\n * again.\n * Only affects recorded characters.\n */\n    void\nungetchars(int len)\n{\n    if (reg_recording == 0)\n\treturn;\n\n    delete_buff_tail(&recordbuff, len);\n    last_recorded_len -= len;\n}\n\n/*\n * Sync undo.  Called when typed characters are obtained from the typeahead\n * buffer, or when a menu is used.\n * Do not sync:\n * - In Insert mode, unless cursor key has been used.\n * - While reading a script file.\n * - When no_u_sync is non-zero.\n */\n    static void\nmay_sync_undo(void)\n{\n    if ((!(State & (MODE_INSERT | MODE_CMDLINE)) || arrow_used)\n\t\t\t\t\t       && scriptin[curscript] == NULL)\n\tu_sync(FALSE);\n}\n\n/*\n * Make \"typebuf\" empty and allocate new buffers.\n * Returns FAIL when out of memory.\n */\n    static int\nalloc_typebuf(void)\n{\n    typebuf.tb_buf = alloc(TYPELEN_INIT);\n    typebuf.tb_noremap = alloc(TYPELEN_INIT);\n    if (typebuf.tb_buf == NULL || typebuf.tb_noremap == NULL)\n    {\n\tfree_typebuf();\n\treturn FAIL;\n    }\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_off = MAXMAPLEN + 4;  // can insert without realloc\n    typebuf.tb_len = 0;\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    typebuf_was_filled = FALSE;\n#endif\n    return OK;\n}\n\n/*\n * Free the buffers of \"typebuf\".\n */\n    static void\nfree_typebuf(void)\n{\n    if (typebuf.tb_buf == typebuf_init)\n\tinternal_error(\"Free typebuf 1\");\n    else\n\tVIM_CLEAR(typebuf.tb_buf);\n    if (typebuf.tb_noremap == noremapbuf_init)\n\tinternal_error(\"Free typebuf 2\");\n    else\n\tVIM_CLEAR(typebuf.tb_noremap);\n}\n\n/*\n * When doing \":so! file\", the current typeahead needs to be saved, and\n * restored when \"file\" has been read completely.\n */\nstatic typebuf_T saved_typebuf[NSCRIPT];\n\n    int\nsave_typebuf(void)\n{\n    init_typebuf();\n    saved_typebuf[curscript] = typebuf;\n    // If out of memory: restore typebuf and close file.\n    if (alloc_typebuf() == FAIL)\n    {\n\tclosescript();\n\treturn FAIL;\n    }\n    return OK;\n}\n\nstatic int old_char = -1;\t// character put back by vungetc()\nstatic int old_mod_mask;\t// mod_mask for ungotten character\nstatic int old_mouse_row;\t// mouse_row related to old_char\nstatic int old_mouse_col;\t// mouse_col related to old_char\nstatic int old_KeyStuffed;\t// whether old_char was stuffed\n\nstatic int can_get_old_char(void)\n{\n    // If the old character was not stuffed and characters have been added to\n    // the stuff buffer, need to first get the stuffed characters instead.\n    return old_char != -1 && (old_KeyStuffed || stuff_empty());\n}\n\n/*\n * Save all three kinds of typeahead, so that the user must type at a prompt.\n */\n    void\nsave_typeahead(tasave_T *tp)\n{\n    tp->save_typebuf = typebuf;\n    tp->typebuf_valid = (alloc_typebuf() == OK);\n    if (!tp->typebuf_valid)\n\ttypebuf = tp->save_typebuf;\n\n    tp->old_char = old_char;\n    tp->old_mod_mask = old_mod_mask;\n    old_char = -1;\n\n    tp->save_readbuf1 = readbuf1;\n    readbuf1.bh_first.b_next = NULL;\n    tp->save_readbuf2 = readbuf2;\n    readbuf2.bh_first.b_next = NULL;\n# ifdef USE_INPUT_BUF\n    tp->save_inputbuf = get_input_buf();\n# endif\n}\n\n/*\n * Restore the typeahead to what it was before calling save_typeahead().\n * The allocated memory is freed, can only be called once!\n * When \"overwrite\" is FALSE input typed later is kept.\n */\n    void\nrestore_typeahead(tasave_T *tp, int overwrite UNUSED)\n{\n    if (tp->typebuf_valid)\n    {\n\tfree_typebuf();\n\ttypebuf = tp->save_typebuf;\n    }\n\n    old_char = tp->old_char;\n    old_mod_mask = tp->old_mod_mask;\n\n    free_buff(&readbuf1);\n    readbuf1 = tp->save_readbuf1;\n    free_buff(&readbuf2);\n    readbuf2 = tp->save_readbuf2;\n# ifdef USE_INPUT_BUF\n    set_input_buf(tp->save_inputbuf, overwrite);\n# endif\n}\n\n/*\n * Open a new script file for the \":source!\" command.\n */\n    void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t// when TRUE execute directly\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_scripts_nested_too_deep));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t// Not reading from script, also don't open one.  Warning message?\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t// already reading script\n\t++curscript;\n\t\t\t\t// use NameBuff for expanded name\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = MODE_NORMAL;\n\tmsg_scroll = FALSE;\t// no msg scrolling in Normal mode\n\trestart_edit = 0;\t// don't go to Insert mode\n\tp_im = FALSE;\t\t// don't use 'insertmode'\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    (void)vpeekc();\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}\n\n/*\n * Close the currently active input script.\n */\n    static void\nclosescript(void)\n{\n    free_typebuf();\n    typebuf = saved_typebuf[curscript];\n\n    fclose(scriptin[curscript]);\n    scriptin[curscript] = NULL;\n    if (curscript > 0)\n\t--curscript;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclose_all_scripts(void)\n{\n    while (scriptin[0] != NULL)\n\tclosescript();\n}\n#endif\n\n/*\n * Return TRUE when reading keys from a script file.\n */\n    int\nusing_script(void)\n{\n    return scriptin[curscript] != NULL;\n}\n\n/*\n * This function is called just before doing a blocking wait.  Thus after\n * waiting 'updatetime' for a character to arrive.\n */\n    void\nbefore_blocking(void)\n{\n    updatescript(0);\n#ifdef FEAT_EVAL\n    if (may_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n}\n\n/*\n * updatescript() is called when a character can be written into the script\n * file or when we have waited some time for a character (c == 0)\n *\n * All the changed memfiles are synced if c == 0 or when the number of typed\n * characters reaches 'updatecount' and 'updatecount' is non-zero.\n */\n    static void\nupdatescript(int c)\n{\n    static int\t    count = 0;\n\n    if (c && scriptout)\n\tputc(c, scriptout);\n    if (c == 0 || (p_uc > 0 && ++count >= p_uc))\n    {\n\tml_sync_all(c == 0, TRUE);\n\tcount = 0;\n    }\n}\n\n/*\n * Convert \"c\" plus \"modifiers\" to merge the effect of modifyOtherKeys into the\n * character.\n */\n    int\nmerge_modifyOtherKeys(int c_arg, int *modifiers)\n{\n    int c = c_arg;\n\n    if (*modifiers & MOD_MASK_CTRL)\n    {\n\tif ((c >= '`' && c <= 0x7f) || (c >= '@' && c <= '_'))\n\t{\n\t    c &= 0x1f;\n\t    if (c == NUL)\n\t\tc = K_ZERO;\n\t}\n\telse if (c == '6')\n\t    // CTRL-6 is equivalent to CTRL-^\n\t    c = 0x1e;\n#ifdef FEAT_GUI_GTK\n\t// These mappings look arbitrary at the first glance, but in fact\n\t// resemble quite exactly the behaviour of the GTK+ 1.2 GUI on my\n\t// machine.  The only difference is BS vs. DEL for CTRL-8 (makes\n\t// more sense and is consistent with usual terminal behaviour).\n\telse if (c == '2')\n\t    c = NUL;\n\telse if (c >= '3' && c <= '7')\n\t    c = c ^ 0x28;\n\telse if (c == '8')\n\t    c = BS;\n\telse if (c == '?')\n\t    c = DEL;\n#endif\n\tif (c != c_arg)\n\t    *modifiers &= ~MOD_MASK_CTRL;\n    }\n    if ((*modifiers & (MOD_MASK_META | MOD_MASK_ALT))\n\t    && c >= 0 && c <= 127)\n    {\n\tc += 0x80;\n\t*modifiers &= ~(MOD_MASK_META | MOD_MASK_ALT);\n    }\n    return c;\n}\n\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n    int\t\tc, c2;\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n\n#ifdef FEAT_EVAL\n    // Do garbage collection when garbagecollect() was called previously and\n    // we are now at the toplevel.\n    if (may_garbage_collect && want_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (can_get_old_char())\n    {\n\tc = old_char;\n\told_char = -1;\n\tmod_mask = old_mod_mask;\n\tmouse_row = old_mouse_row;\n\tmouse_col = old_mouse_col;\n    }\n    else\n    {\n\t// number of characters recorded from the last vgetc() call\n\tstatic int\tlast_vgetc_recorded_len = 0;\n\n\tmod_mask = 0;\n\tvgetc_mod_mask = 0;\n\tvgetc_char = 0;\n\n\t// last_recorded_len can be larger than last_vgetc_recorded_len\n\t// if peeking records more\n\tlast_recorded_len -= last_vgetc_recorded_len;\n\n\tfor (;;)\t\t// this is done twice if there are modifiers\n\t{\n\t    int did_inc = FALSE;\n\n\t    // No mapping after modifier has been read, using an input method\n\t    // and when a popup window has disabled mapping.\n\t    if (mod_mask\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t\t    || im_is_preediting()\n#endif\n#if defined(FEAT_PROP_POPUP)\n\t\t    || popup_no_mapping()\n#endif\n\t\t    )\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\t// mod_mask value may change, remember we did the increment\n\t\tdid_inc = TRUE;\n\t    }\n\t    c = vgetorpeek(TRUE);\n\t    if (did_inc)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\n\t    // Get two extra bytes for special keys, handle modifiers.\n\t    if (c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || c == CSI\n#endif\n\t       )\n\t    {\n\t\tint\t    save_allow_keys = allow_keys;\n\n\t\t++no_mapping;\n\t\tallow_keys = 0;\t\t// make sure BS is not found\n\t\tc2 = vgetorpeek(TRUE);\t// no mapping for these chars\n\t\tc = vgetorpeek(TRUE);\n\t\t--no_mapping;\n\t\tallow_keys = save_allow_keys;\n\t\tif (c2 == KS_MODIFIER)\n\t\t{\n\t\t    mod_mask = c;\n\t\t    continue;\n\t\t}\n\t\tc = TO_SPECIAL(c2, c);\n\n\t\t// K_ESC is used to avoid ambiguity with the single Esc\n\t\t// character that might be the start of an escape sequence.\n\t\t// Convert it back to a single Esc here.\n\t\tif (c == K_ESC)\n\t\t    c = ESC;\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n\t\t// Handle K_TEAROFF here, the caller of vgetc() doesn't need to\n\t\t// know that a menu was torn off\n\t\tif (\n# ifdef VIMDLL\n\t\t    gui.in_use &&\n# endif\n\t\t    c == K_TEAROFF)\n\t\t{\n\t\t    char_u\tname[200];\n\t\t    int\t\tj;\n\n\t\t    // get menu path, it ends with a <CR>\n\t\t    for (j = 0; (c = vgetorpeek(TRUE)) != '\\r'; )\n\t\t    {\n\t\t\tname[j] = c;\n\t\t\tif (j < 199)\n\t\t\t    ++j;\n\t\t    }\n\t\t    name[j] = NUL;\n\t\t    gui_make_tearoff(name);\n\t\t    continue;\n\t\t}\n#endif\n#if defined(FEAT_GUI) && defined(FEAT_GUI_GTK) && defined(FEAT_MENU)\n\t\t// GTK: <F10> normally selects the menu, but it's passed until\n\t\t// here to allow mapping it.  Intercept and invoke the GTK\n\t\t// behavior if it's not mapped.\n\t\tif (c == K_F10 && gui.menubar != NULL)\n\t\t{\n\t\t    gtk_menu_shell_select_first(\n\t\t\t\t\t   GTK_MENU_SHELL(gui.menubar), FALSE);\n\t\t    continue;\n\t\t}\n#endif\n#ifdef FEAT_GUI\n\t\t// Handle focus event here, so that the caller doesn't need to\n\t\t// know about it.  Return K_IGNORE so that we loop once (needed\n\t\t// if 'lazyredraw' is set).\n\t\tif (c == K_FOCUSGAINED || c == K_FOCUSLOST)\n\t\t{\n\t\t    ui_focus_change(c == K_FOCUSGAINED);\n\t\t    c = K_IGNORE;\n\t\t}\n\n\t\t// Translate K_CSI to CSI.  The special key is only used to\n\t\t// avoid it being recognized as the start of a special key.\n\t\tif (c == K_CSI)\n\t\t    c = CSI;\n#endif\n#ifdef FEAT_EVAL\n\t\tif (c == K_SID)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // Handle <SID>{sid};  Do up to 20 digits for safety.\n\t\t    last_used_sid = 0;\n\t\t    for (j = 0; j < 20 && isdigit(c = vgetorpeek(TRUE)); ++j)\n\t\t\tlast_used_sid = last_used_sid * 10 + (c - '0');\n\t\t    last_used_map = NULL;\n\t\t    continue;\n\t\t}\n#endif\n\t    }\n\n\t    // a keypad or special function key was not mapped, use it like\n\t    // its ASCII equivalent\n\t    switch (c)\n\t    {\n\t\tcase K_KPLUS:\tc = '+'; break;\n\t\tcase K_KMINUS:\tc = '-'; break;\n\t\tcase K_KDIVIDE:\tc = '/'; break;\n\t\tcase K_KMULTIPLY: c = '*'; break;\n\t\tcase K_KENTER:\tc = CAR; break;\n\t\tcase K_KPOINT:\n#ifdef MSWIN\n\t\t\t\t// Can be either '.' or a ',',\n\t\t\t\t// depending on the type of keypad.\n\t\t\t\tc = MapVirtualKey(VK_DECIMAL, 2); break;\n#else\n\t\t\t\tc = '.'; break;\n#endif\n\t\tcase K_K0:\tc = '0'; break;\n\t\tcase K_K1:\tc = '1'; break;\n\t\tcase K_K2:\tc = '2'; break;\n\t\tcase K_K3:\tc = '3'; break;\n\t\tcase K_K4:\tc = '4'; break;\n\t\tcase K_K5:\tc = '5'; break;\n\t\tcase K_K6:\tc = '6'; break;\n\t\tcase K_K7:\tc = '7'; break;\n\t\tcase K_K8:\tc = '8'; break;\n\t\tcase K_K9:\tc = '9'; break;\n\n\t\tcase K_XHOME:\n\t\tcase K_ZHOME:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_HOME;\n\t\t\t\tbreak;\n\t\tcase K_XEND:\n\t\tcase K_ZEND:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_END;\n\t\t\t\tbreak;\n\n\t\tcase K_XUP:\tc = K_UP; break;\n\t\tcase K_XDOWN:\tc = K_DOWN; break;\n\t\tcase K_XLEFT:\tc = K_LEFT; break;\n\t\tcase K_XRIGHT:\tc = K_RIGHT; break;\n\t    }\n\n\t    // For a multi-byte character get all the bytes and return the\n\t    // converted character.\n\t    // Note: This will loop until enough bytes are received!\n\t    if (has_mbyte && (n = MB_BYTE2LEN_CHECK(c)) > 1)\n\t    {\n\t\t++no_mapping;\n\t\tbuf[0] = c;\n\t\tfor (i = 1; i < n; ++i)\n\t\t{\n\t\t    buf[i] = vgetorpeek(TRUE);\n\t\t    if (buf[i] == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t\t    || (buf[i] == CSI)\n#endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER\n\t\t\t// sequence, which represents a K_SPECIAL (0x80),\n\t\t\t// or a CSI - KS_EXTRA - KE_CSI sequence, which\n\t\t\t// represents a CSI (0x9B),\n\t\t\t// or a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI\n\t\t\t// too.\n\t\t\tc = vgetorpeek(TRUE);\n\t\t\tif (vgetorpeek(TRUE) == KE_CSI && c == KS_EXTRA)\n\t\t\t    buf[i] = CSI;\n\t\t    }\n\t\t}\n\t\t--no_mapping;\n\t\tc = (*mb_ptr2char)(buf);\n\t    }\n\n\t    if (vgetc_char == 0)\n\t    {\n\t\tvgetc_mod_mask = mod_mask;\n\t\tvgetc_char = c;\n\t    }\n\n\t    break;\n\t}\n\n\tlast_vgetc_recorded_len = last_recorded_len;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * In the main loop \"may_garbage_collect\" can be set to do garbage\n     * collection in the first next vgetc().  It's disabled after that to\n     * avoid internally used Lists and Dicts to be freed.\n     */\n    may_garbage_collect = FALSE;\n#endif\n\n#ifdef FEAT_BEVAL_TERM\n    if (c != K_MOUSEMOVE && c != K_IGNORE && c != K_CURSORHOLD)\n    {\n\t// Don't trigger 'balloonexpr' unless only the mouse was moved.\n\tbevalexpr_due_set = FALSE;\n\tui_remove_balloon();\n    }\n#endif\n#ifdef FEAT_PROP_POPUP\n    // Only filter keys that do not come from \":normal\".  Keys from feedkeys()\n    // are filtered.\n    if ((!ex_normal_busy || in_feedkeys) && popup_do_filter(c))\n    {\n\tif (c == Ctrl_C)\n\t    got_int = FALSE;  // avoid looping\n\tc = K_IGNORE;\n    }\n#endif\n\n    // Need to process the character before we know it's safe to do something\n    // else.\n    if (c != K_IGNORE)\n\tstate_no_longer_safe(\"key typed\");\n\n    return c;\n}\n\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int\tc;\n\n    c = vgetc();\n    if (c == NUL)\n\tc = get_keystroke();\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n * Does not handle bracketed paste - do not use the result for commands.\n */\n    static int\nplain_vgetc_nopaste(void)\n{\n    int c;\n\n    do\n\tc = safe_vgetc();\n    while (c == K_IGNORE\n\t    || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n\t    || c == K_MOUSEMOVE);\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n */\n    int\nplain_vgetc(void)\n{\n    int c = plain_vgetc_nopaste();\n\n    if (c == K_PS)\n\t// Only handle the first pasted character.  Drop the rest, since we\n\t// don't know what to do with it.\n\tc = bracketed_paste(PASTE_ONE_CHAR, FALSE, NULL);\n\n    return c;\n}\n\n/*\n * Check if a character is available, such that vgetc() will not block.\n * If the next character is a special character or multi-byte, the returned\n * character is not valid!.\n * Returns NUL if no character is available.\n */\n    int\nvpeekc(void)\n{\n    if (can_get_old_char())\n\treturn old_char;\n    return vgetorpeek(FALSE);\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Like vpeekc(), but don't allow mapping.  Do allow checking for terminal\n * codes.\n */\n    int\nvpeekc_nomap(void)\n{\n    int\t\tc;\n\n    ++no_mapping;\n    ++allow_keys;\n    c = vpeekc();\n    --no_mapping;\n    --allow_keys;\n    return c;\n}\n#endif\n\n/*\n * Check if any character is available, also half an escape sequence.\n * Trick: when no typeahead found, but there is something in the typeahead\n * buffer, it must be an ESC that is recognized as the start of a key code.\n */\n    int\nvpeekc_any(void)\n{\n    int\t\tc;\n\n    c = vpeekc();\n    if (c == NUL && typebuf.tb_len > 0)\n\tc = ESC;\n    return c;\n}\n\n/*\n * Call vpeekc() without causing anything to be mapped.\n * Return TRUE if a character is available, FALSE otherwise.\n */\n    int\nchar_avail(void)\n{\n    int\t    retval;\n\n#ifdef FEAT_EVAL\n    // When test_override(\"char_avail\", 1) was called pretend there is no\n    // typeahead.\n    if (disable_char_avail_for_testing)\n\treturn FALSE;\n#endif\n    ++no_mapping;\n    retval = vpeekc();\n    --no_mapping;\n    return (retval != NUL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getchar()\" and \"getcharstr()\" functions\n */\n    static void\ngetchar_common(typval_T *argvars, typval_T *rettv)\n{\n    varnumber_T\t\tn;\n    int\t\t\terror = FALSE;\n\n    if (in_vim9script() && check_for_opt_bool_arg(argvars, 0) == FAIL)\n\treturn;\n\n#ifdef MESSAGE_QUEUE\n    // vpeekc() used to check for messages, but that caused problems, invoking\n    // a callback where it was not expected.  Some plugins use getchar(1) in a\n    // loop to await a message, therefore make sure we check for messages here.\n    parse_queued_messages();\n#endif\n\n    // Position the cursor.  Needed after a message that ends in a space.\n    windgoto(msg_row, msg_col);\n\n    ++no_mapping;\n    ++allow_keys;\n    for (;;)\n    {\n\tif (argvars[0].v_type == VAR_UNKNOWN)\n\t    // getchar(): blocking wait.\n\t    n = plain_vgetc_nopaste();\n\telse if (tv_get_bool_chk(&argvars[0], &error))\n\t    // getchar(1): only check if char avail\n\t    n = vpeekc_any();\n\telse if (error || vpeekc_any() == NUL)\n\t    // illegal argument or getchar(0) and no char avail: return zero\n\t    n = 0;\n\telse\n\t    // getchar(0) and char avail() != NUL: get a character.\n\t    // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.\n\t    n = safe_vgetc();\n\n\tif (n == K_IGNORE || n == K_MOUSEMOVE\n\t\t|| n == K_VER_SCROLLBAR || n == K_HOR_SCROLLBAR)\n\t    continue;\n\tbreak;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    set_vim_var_nr(VV_MOUSE_WIN, 0);\n    set_vim_var_nr(VV_MOUSE_WINID, 0);\n    set_vim_var_nr(VV_MOUSE_LNUM, 0);\n    set_vim_var_nr(VV_MOUSE_COL, 0);\n\n    rettv->vval.v_number = n;\n    if (n != 0 && (IS_SPECIAL(n) || mod_mask != 0))\n    {\n\tchar_u\t\ttemp[10];   // modifier: 3, mbyte-char: 6, NUL: 1\n\tint\t\ti = 0;\n\n\t// Turn a special key into three bytes, plus modifier.\n\tif (mod_mask != 0)\n\t{\n\t    temp[i++] = K_SPECIAL;\n\t    temp[i++] = KS_MODIFIER;\n\t    temp[i++] = mod_mask;\n\t}\n\tif (IS_SPECIAL(n))\n\t{\n\t    temp[i++] = K_SPECIAL;\n\t    temp[i++] = K_SECOND(n);\n\t    temp[i++] = K_THIRD(n);\n\t}\n\telse if (has_mbyte)\n\t    i += (*mb_char2bytes)(n, temp + i);\n\telse\n\t    temp[i++] = n;\n\ttemp[i++] = NUL;\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = vim_strsave(temp);\n\n\tif (is_mouse_key(n))\n\t{\n\t    int\t\trow = mouse_row;\n\t    int\t\tcol = mouse_col;\n\t    win_T\t*win;\n\t    linenr_T\tlnum;\n\t    win_T\t*wp;\n\t    int\t\twinnr = 1;\n\n\t    if (row >= 0 && col >= 0)\n\t    {\n\t\t// Find the window at the mouse coordinates and compute the\n\t\t// text position.\n\t\twin = mouse_find_win(&row, &col, FIND_POPUP);\n\t\tif (win == NULL)\n\t\t    return;\n\t\t(void)mouse_comp_pos(win, &row, &col, &lnum, NULL);\n#ifdef FEAT_PROP_POPUP\n\t\tif (WIN_IS_POPUP(win))\n\t\t    winnr = 0;\n\t\telse\n#endif\n\t\t    for (wp = firstwin; wp != win && wp != NULL;\n\t\t\t\t\t\t\t       wp = wp->w_next)\n\t\t\t++winnr;\n\t\tset_vim_var_nr(VV_MOUSE_WIN, winnr);\n\t\tset_vim_var_nr(VV_MOUSE_WINID, win->w_id);\n\t\tset_vim_var_nr(VV_MOUSE_LNUM, lnum);\n\t\tset_vim_var_nr(VV_MOUSE_COL, col + 1);\n\t    }\n\t}\n    }\n}\n\n/*\n * \"getchar()\" function\n */\n    void\nf_getchar(typval_T *argvars, typval_T *rettv)\n{\n    getchar_common(argvars, rettv);\n}\n\n/*\n * \"getcharstr()\" function\n */\n    void\nf_getcharstr(typval_T *argvars, typval_T *rettv)\n{\n    getchar_common(argvars, rettv);\n\n    if (rettv->v_type != VAR_NUMBER)\n\treturn;\n\n    char_u\t\ttemp[7];   // mbyte-char: 6, NUL: 1\n    varnumber_T\tn = rettv->vval.v_number;\n    int\t\ti = 0;\n\n    if (n != 0)\n    {\n\tif (has_mbyte)\n\t    i += (*mb_char2bytes)(n, temp + i);\n\telse\n\t    temp[i++] = n;\n    }\n    temp[i++] = NUL;\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strsave(temp);\n}\n\n/*\n * \"getcharmod()\" function\n */\n    void\nf_getcharmod(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->vval.v_number = mod_mask;\n}\n#endif // FEAT_EVAL\n\n#if defined(MESSAGE_QUEUE) || defined(PROTO)\n# define MAX_REPEAT_PARSE 8\n\n/*\n * Process messages that have been queued for netbeans or clientserver.\n * Also check if any jobs have ended.\n * These functions can call arbitrary Vim script and should only be called when\n * it is safe to do so.\n */\n    void\nparse_queued_messages(void)\n{\n    int\t    old_curwin_id;\n    int\t    old_curbuf_fnum;\n    int\t    i;\n    int\t    save_may_garbage_collect = may_garbage_collect;\n    static int entered = 0;\n    int\t    was_safe = get_was_safe_state();\n\n    // Do not handle messages while redrawing, because it may cause buffers to\n    // change or be wiped while they are being redrawn.\n    // Also bail out when parsing messages was explicitly disabled.\n    if (updating_screen || dont_parse_messages)\n\treturn;\n\n    // If memory allocation fails during startup we'll exit but curbuf or\n    // curwin could be NULL.\n    if (curbuf == NULL || curwin == NULL)\n       return;\n\n    old_curbuf_fnum = curbuf->b_fnum;\n    old_curwin_id = curwin->w_id;\n\n    ++entered;\n\n    // may_garbage_collect is set in main_loop() to do garbage collection when\n    // blocking to wait on a character.  We don't want that while parsing\n    // messages, a callback may invoke vgetc() while lists and dicts are in use\n    // in the call stack.\n    may_garbage_collect = FALSE;\n\n    // Loop when a job ended, but don't keep looping forever.\n    for (i = 0; i < MAX_REPEAT_PARSE; ++i)\n    {\n\t// For Win32 mch_breakcheck() does not check for input, do it here.\n# if (defined(MSWIN) || defined(__HAIKU__)) && defined(FEAT_JOB_CHANNEL)\n\tchannel_handle_events(FALSE);\n# endif\n\n# ifdef FEAT_NETBEANS_INTG\n\t// Process the queued netbeans messages.\n\tnetbeans_parse_messages();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n\t// Write any buffer lines still to be written.\n\tchannel_write_any_lines();\n\n\t// Process the messages queued on channels.\n\tchannel_parse_messages();\n# endif\n# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\n\t// Process the queued clientserver messages.\n\tserver_parse_messages();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n\t// Check if any jobs have ended.  If so, repeat the above to handle\n\t// changes, e.g. stdin may have been closed.\n\tif (job_check_ended())\n\t    continue;\n# endif\n# ifdef FEAT_TERMINAL\n\tfree_unused_terminals();\n# endif\n\n# ifdef FEAT_SOUND_MACOSX\n\tprocess_cfrunloop();\n# endif\n# ifdef FEAT_SOUND_CANBERRA\n\tif (has_sound_callback_in_queue())\n\t    invoke_sound_callback();\n# endif\n#ifdef SIGUSR1\n\tif (got_sigusr1)\n\t{\n\t    apply_autocmds(EVENT_SIGUSR1, NULL, NULL, FALSE, curbuf);\n\t    got_sigusr1 = FALSE;\n\t}\n#endif\n\tbreak;\n    }\n\n    // When not nested we'll go back to waiting for a typed character.  If it\n    // was safe before then this triggers a SafeStateAgain autocommand event.\n    if (entered == 1 && was_safe)\n\tmay_trigger_safestateagain();\n\n    may_garbage_collect = save_may_garbage_collect;\n\n    // If the current window or buffer changed we need to bail out of the\n    // waiting loop.  E.g. when a job exit callback closes the terminal window.\n    if (curwin->w_id != old_curwin_id || curbuf->b_fnum != old_curbuf_fnum)\n\tins_char_typebuf(K_IGNORE, 0);\n\n    --entered;\n}\n#endif\n\n\ntypedef enum {\n    map_result_fail,    // failed, break loop\n    map_result_get,     // get a character from typeahead\n    map_result_retry,   // try to map again\n    map_result_nomatch  // no matching mapping, get char\n} map_result_T;\n\n/*\n * Check if the bytes at the start of the typeahead buffer are a character used\n * in Insert mode completion.  This includes the form with a CTRL modifier.\n */\n    static int\nat_ins_compl_key(void)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    c = *p;\n\n    if (typebuf.tb_len > 3\n\t    && (c == K_SPECIAL || c == CSI)  // CSI is used by the GUI\n\t    && p[1] == KS_MODIFIER\n\t    && (p[2] & MOD_MASK_CTRL))\n\tc = p[3] & 0x1f;\n    return (ctrl_x_mode_not_default() && vim_is_ctrl_x_key(c))\n\t\t|| (compl_status_local() && (c == Ctrl_N || c == Ctrl_P));\n}\n\n/*\n * Check if typebuf.tb_buf[] contains a modifier plus key that can be changed\n * into just a key, apply that.\n * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off\n * + \"max_offset\"].\n * Return the length of the replaced bytes, 0 if nothing changed, -1 for error.\n */\n    static int\ncheck_simplify_modifier(int max_offset)\n{\n    int\t\toffset;\n    char_u\t*tp;\n\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (offset + 3 >= typebuf.tb_len)\n\t    break;\n\ttp = typebuf.tb_buf + typebuf.tb_off + offset;\n\tif ((tp[0] == K_SPECIAL || tp[0] == CSI) && tp[1] == KS_MODIFIER)\n\t{\n\t    // A modifier was not used for a mapping, apply it to ASCII keys.\n\t    // Shift would already have been applied.\n\t    int modifier = tp[2];\n\t    int\tc = tp[3];\n\t    int new_c = merge_modifyOtherKeys(c, &modifier);\n\n\t    if (new_c != c)\n\t    {\n\t\tchar_u\tnew_string[MB_MAXBYTES];\n\t\tint\tlen;\n\n\t\tif (offset == 0)\n\t\t{\n\t\t    // At the start: remember the character and mod_mask before\n\t\t    // merging, in some cases, e.g. at the hit-return prompt,\n\t\t    // they are put back in the typeahead buffer.\n\t\t    vgetc_char = c;\n\t\t    vgetc_mod_mask = tp[2];\n\t\t}\n\t\tif (IS_SPECIAL(new_c))\n\t\t{\n\t\t    new_string[0] = K_SPECIAL;\n\t\t    new_string[1] = K_SECOND(new_c);\n\t\t    new_string[2] = K_THIRD(new_c);\n\t\t    len = 3;\n\t\t}\n\t\telse\n\t\t    len = mb_char2bytes(new_c, new_string);\n\t\tif (modifier == 0)\n\t\t{\n\t\t    if (put_string_in_typebuf(offset, 4, new_string, len,\n\t\t\t\t\t\t\tNULL, 0, NULL) == FAIL)\n\t\t    return -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tp[2] = modifier;\n\t\t    if (put_string_in_typebuf(offset + 3, 1, new_string, len,\n\t\t\t\t\t\t\tNULL, 0, NULL) == FAIL)\n\t\t    return -1;\n\t\t}\n\t\treturn len;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if the terminal sends modifiers with various keys.  This is when\n * modifyOtherKeys level 2 is enabled or the kitty keyboard protocol is\n * enabled.\n */\n    static int\nkey_protocol_enabled(void)\n{\n    // If xterm has responded to XTQMODKEYS it overrules seenModifyOtherKeys.\n    int using_mok = modify_otherkeys_state != MOKS_INITIAL\n\t\t\t? modify_otherkeys_state == MOKS_ENABLED\n\t\t\t: seenModifyOtherKeys;\n    return using_mok || kitty_protocol_state == KKPS_ENABLED;\n}\n\n/*\n * Handle mappings in the typeahead buffer.\n * - When something was mapped, return map_result_retry for recursive mappings.\n * - When nothing mapped and typeahead has a character: return map_result_get.\n * - When there is no match yet, return map_result_nomatch, need to get more\n *   typeahead.\n * - On failure (out of memory) return map_result_fail.\n */\n    static int\nhandle_mapping(\n\t    int *keylenp,\n\t    int *timedout,\n\t    int *mapdepth)\n{\n    mapblock_T\t*mp = NULL;\n    mapblock_T\t*mp2;\n    mapblock_T\t*mp_match;\n    int\t\tmp_match_len = 0;\n    int\t\tmax_mlen = 0;\n    int\t\twant_termcode = 0;  // 1 if termcode expected after max_mlen\n    int\t\ttb_c1;\n    int\t\tmlen;\n#ifdef FEAT_LANGMAP\n    int\t\tnolmaplen;\n#endif\n    int\t\tkeylen = *keylenp;\n    int\t\ti;\n    int\t\tlocal_State = get_real_state();\n    int\t\tis_plug_map = FALSE;\n\n    // If typeahead starts with <Plug> then remap, even for a \"noremap\" mapping.\n    if (typebuf.tb_len >= 3\n\t    && typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t    && typebuf.tb_buf[typebuf.tb_off + 1] == KS_EXTRA\n\t    && typebuf.tb_buf[typebuf.tb_off + 2] == KE_PLUG)\n\tis_plug_map = TRUE;\n\n    /*\n     * Check for a mappable key sequence.\n     * Walk through one maphash[] list until we find an entry that matches.\n     *\n     * Don't look for mappings if:\n     * - no_mapping set: mapping disabled (e.g. for CTRL-V)\n     * - maphash_valid not set: no mappings present.\n     * - typebuf.tb_buf[typebuf.tb_off] should not be remapped\n     * - in insert or cmdline mode and 'paste' option set\n     * - waiting for \"hit return to continue\" and CR or SPACE typed\n     * - waiting for a char with --more--\n     * - in Ctrl-X mode, and we get a valid char for that mode\n     */\n    tb_c1 = typebuf.tb_buf[typebuf.tb_off];\n    if (no_mapping == 0 && is_maphash_valid()\n\t    && (no_zero_mapping == 0 || tb_c1 != '0')\n\t    && (typebuf.tb_maplen == 0 || is_plug_map\n\t\t|| (p_remap\n\t\t    && (typebuf.tb_noremap[typebuf.tb_off]\n\t\t\t\t    & (RM_NONE|RM_ABBR)) == 0))\n\t    && !(p_paste && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t    && !(State == MODE_HITRETURN && (tb_c1 == CAR || tb_c1 == ' '))\n\t    && State != MODE_ASKMORE\n\t    && State != MODE_CONFIRM\n\t    && !at_ins_compl_key())\n    {\n#ifdef FEAT_GUI\n\tif (gui.in_use && tb_c1 == CSI && typebuf.tb_len >= 2\n\t\t&& typebuf.tb_buf[typebuf.tb_off + 1] == KS_MODIFIER)\n\t{\n\t    // The GUI code sends CSI KS_MODIFIER {flags}, but mappings expect\n\t    // K_SPECIAL KS_MODIFIER {flags}.\n\t    tb_c1 = K_SPECIAL;\n\t}\n#endif\n#ifdef FEAT_LANGMAP\n\tif (tb_c1 == K_SPECIAL)\n\t    nolmaplen = 2;\n\telse\n\t{\n\t    LANGMAP_ADJUST(tb_c1, (State & (MODE_CMDLINE | MODE_INSERT)) == 0\n\t\t\t\t\t   && get_real_state() != MODE_SELECT);\n\t    nolmaplen = 0;\n\t}\n#endif\n\t// First try buffer-local mappings.\n\tmp = get_buf_maphash_list(local_State, tb_c1);\n\tmp2 = get_maphash_list(local_State, tb_c1);\n\tif (mp == NULL)\n\t{\n\t    // There are no buffer-local mappings.\n\t    mp = mp2;\n\t    mp2 = NULL;\n\t}\n\n\t/*\n\t * Loop until a partly matching mapping is found or all (local)\n\t * mappings have been checked.\n\t * The longest full match is remembered in \"mp_match\".\n\t * A full match is only accepted if there is no partly match, so \"aa\"\n\t * and \"aaa\" can both be mapped.\n\t */\n\tmp_match = NULL;\n\tmp_match_len = 0;\n\tfor ( ; mp != NULL;\n\t       mp->m_next == NULL ? (mp = mp2, mp2 = NULL) : (mp = mp->m_next))\n\t{\n\t    // Only consider an entry if the first character matches and it is\n\t    // for the current state.\n\t    // Skip \":lmap\" mappings if keys were mapped.\n\t    if (mp->m_keys[0] == tb_c1\n\t\t    && (mp->m_mode & local_State)\n\t\t    && !(mp->m_simplified && key_protocol_enabled()\n\t\t\t\t\t\t     && typebuf.tb_maplen == 0)\n\t\t    && ((mp->m_mode & MODE_LANGMAP) == 0\n\t\t\t\t\t\t    || typebuf.tb_maplen == 0))\n\t    {\n#ifdef FEAT_LANGMAP\n\t\tint\tnomap = nolmaplen;\n\t\tint\tmodifiers = 0;\n#endif\n\t\t// find the match length of this mapping\n\t\tfor (mlen = 1; mlen < typebuf.tb_len; ++mlen)\n\t\t{\n\t\t    int\tc2 = typebuf.tb_buf[typebuf.tb_off + mlen];\n#ifdef FEAT_LANGMAP\n\t\t    if (nomap > 0)\n\t\t    {\n\t\t\tif (nomap == 2 && c2 == KS_MODIFIER)\n\t\t\t    modifiers = 1;\n\t\t\telse if (nomap == 1 && modifiers == 1)\n\t\t\t    modifiers = c2;\n\t\t\t--nomap;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (c2 == K_SPECIAL)\n\t\t\t    nomap = 2;\n\t\t\telse if (merge_modifyOtherKeys(c2, &modifiers) == c2)\n\t\t\t    // Only apply 'langmap' if merging modifiers into\n\t\t\t    // the key will not result in another character,\n\t\t\t    // so that 'langmap' behaves consistently in\n\t\t\t    // different terminals and GUIs.\n\t\t\t    LANGMAP_ADJUST(c2, TRUE);\n\t\t\tmodifiers = 0;\n\t\t    }\n#endif\n\t\t    if (mp->m_keys[mlen] != c2)\n\t\t\tbreak;\n\t\t}\n\n\t\t// Don't allow mapping the first byte(s) of a multi-byte char.\n\t\t// Happens when mapping <M-a> and then changing 'encoding'.\n\t\t// Beware that 0x80 is escaped.\n\t\t{\n\t\t    char_u *p1 = mp->m_keys;\n\t\t    char_u *p2 = mb_unescape(&p1);\n\n\t\t    if (has_mbyte && p2 != NULL\n\t\t\t\t\t&& MB_BYTE2LEN(tb_c1) > mb_ptr2len(p2))\n\t\t\tmlen = 0;\n\t\t}\n\n\t\t// Check an entry whether it matches.\n\t\t// - Full match: mlen == keylen\n\t\t// - Partly match: mlen == typebuf.tb_len\n\t\tkeylen = mp->m_keylen;\n\t\tif (mlen == keylen || (mlen == typebuf.tb_len\n\t\t\t\t\t\t   && typebuf.tb_len < keylen))\n\t\t{\n\t\t    char_u  *s;\n\t\t    int\t    n;\n\n\t\t    // If only script-local mappings are allowed, check if the\n\t\t    // mapping starts with K_SNR.\n\t\t    s = typebuf.tb_noremap + typebuf.tb_off;\n\t\t    if (*s == RM_SCRIPT\n\t\t\t    && (mp->m_keys[0] != K_SPECIAL\n\t\t\t\t|| mp->m_keys[1] != KS_EXTRA\n\t\t\t\t|| mp->m_keys[2] != KE_SNR))\n\t\t\tcontinue;\n\n\t\t    // If one of the typed keys cannot be remapped, skip the\n\t\t    // entry.\n\t\t    for (n = mlen; --n >= 0; )\n\t\t\tif (*s++ & (RM_NONE|RM_ABBR))\n\t\t\t    break;\n\t\t    if (!is_plug_map && n >= 0)\n\t\t\tcontinue;\n\n\t\t    if (keylen > typebuf.tb_len)\n\t\t    {\n\t\t\tif (!*timedout && !(mp_match != NULL\n\t\t\t\t\t\t\t&& mp_match->m_nowait))\n\t\t\t{\n\t\t\t    // break at a partly match\n\t\t\t    keylen = KEYLEN_PART_MAP;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else if (keylen > mp_match_len)\n\t\t    {\n\t\t\t// found a longer match\n\t\t\tmp_match = mp;\n\t\t\tmp_match_len = keylen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    // No match; may have to check for termcode at next\n\t\t    // character.  If the first character that didn't match is\n\t\t    // K_SPECIAL then check for a termcode.  This isn't perfect\n\t\t    // but should work in most cases.\n\t\t    if (max_mlen < mlen)\n\t\t    {\n\t\t\tmax_mlen = mlen;\n\t\t\twant_termcode = mp->m_keys[mlen] == K_SPECIAL;\n\t\t    }\n\t\t    else if (max_mlen == mlen && mp->m_keys[mlen] == K_SPECIAL)\n\t\t\twant_termcode = 1;\n\t    }\n\t}\n\n\t// If no partly match found, use the longest full match.\n\tif (keylen != KEYLEN_PART_MAP && mp_match != NULL)\n\t{\n\t    mp = mp_match;\n\t    keylen = mp_match_len;\n\t}\n    }\n\n    /*\n     * Check for match with 'pastetoggle'\n     */\n    if (*p_pt != NUL && mp == NULL && (State & (MODE_INSERT | MODE_NORMAL)))\n    {\n\tfor (mlen = 0; mlen < typebuf.tb_len && p_pt[mlen]; ++mlen)\n\t    if (p_pt[mlen] != typebuf.tb_buf[typebuf.tb_off + mlen])\n\t\t    break;\n\tif (p_pt[mlen] == NUL)\t// match\n\t{\n\t    // write chars to script file(s)\n\t    if (mlen > typebuf.tb_maplen)\n\t\tgotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,\n\t\t\t\t\t\t     mlen - typebuf.tb_maplen);\n\n\t    del_typebuf(mlen, 0); // remove the chars\n\t    set_option_value_give_err((char_u *)\"paste\",\n\t\t\t\t\t\t      (long)!p_paste, NULL, 0);\n\t    if (!(State & MODE_INSERT))\n\t    {\n\t\tmsg_col = 0;\n\t\tmsg_row = Rows - 1;\n\t\tmsg_clr_eos();\t\t// clear ruler\n\t    }\n\t    status_redraw_all();\n\t    redraw_statuslines();\n\t    showmode();\n\t    setcursor();\n\t    *keylenp = keylen;\n\t    return map_result_retry;\n\t}\n\t// Need more chars for partly match.\n\tif (mlen == typebuf.tb_len)\n\t    keylen = KEYLEN_PART_KEY;\n\telse if (max_mlen < mlen)\n\t    // no match, may have to check for termcode at next character\n\t    max_mlen = mlen + 1;\n    }\n\n    // May check for a terminal code when there is no mapping or only a partial\n    // mapping.  Also check if there is a full mapping with <Esc>, unless timed\n    // out, since that is nearly always a partial match with a terminal code.\n    if ((mp == NULL || max_mlen + want_termcode > mp_match_len\n\t\t    || (mp_match_len == 1 && *mp->m_keys == ESC && !*timedout))\n\t    && keylen != KEYLEN_PART_MAP)\n    {\n\tint\tsave_keylen = keylen;\n\n\t/*\n\t * When no matching mapping found or found a non-matching mapping that\n\t * matches at least what the matching mapping matched:\n\t * Check if we have a terminal code, when:\n\t * - mapping is allowed,\n\t * - keys have not been mapped,\n\t * - and not an ESC sequence, not in insert mode or p_ek is on,\n\t * - and when not timed out,\n\t */\n\tif (no_mapping == 0 || allow_keys != 0)\n\t{\n\t    if ((typebuf.tb_maplen == 0\n\t\t    || (p_remap && typebuf.tb_noremap[\n\t\t\t\t\t\t    typebuf.tb_off] == RM_YES))\n\t\t&& !*timedout)\n\t\tkeylen = check_termcode(max_mlen + 1, NULL, 0, NULL);\n\t    else\n\t\tkeylen = 0;\n\n\t    // If no termcode matched but 'pastetoggle' matched partially\n\t    // it's like an incomplete key sequence.\n\t    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY && !*timedout)\n\t\tkeylen = KEYLEN_PART_KEY;\n\n\t    // If no termcode matched, try to include the modifier into the\n\t    // key.  This is for when modifyOtherKeys is working.\n#ifdef FEAT_TERMINAL\n\t    check_no_reduce_keys();  // may update the no_reduce_keys flag\n#endif\n\t    if (keylen == 0 && !no_reduce_keys)\n\t    {\n\t\tkeylen = check_simplify_modifier(max_mlen + 1);\n\t\tif (keylen < 0)\n\t\t    // ins_typebuf() failed\n\t\t    return map_result_fail;\n\t    }\n\n\t    // When getting a partial match, but the last characters were not\n\t    // typed, don't wait for a typed character to complete the\n\t    // termcode.  This helps a lot when a \":normal\" command ends in an\n\t    // ESC.\n\t    if (keylen < 0 && typebuf.tb_len == typebuf.tb_maplen)\n\t\tkeylen = 0;\n\t}\n\telse\n\t    keylen = 0;\n\tif (keylen == 0)\t// no matching terminal code\n\t{\n#ifdef AMIGA\n\t    // check for window bounds report\n\t    if (typebuf.tb_maplen == 0 && (typebuf.tb_buf[\n\t\t\t\t\t\ttypebuf.tb_off] & 0xff) == CSI)\n\t    {\n\t\tchar_u *s;\n\n\t\tfor (s = typebuf.tb_buf + typebuf.tb_off + 1;\n\t\t\t   s < typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len\n\t\t   && (VIM_ISDIGIT(*s) || *s == ';' || *s == ' ');\n\t\t\t++s)\n\t\t    ;\n\t\tif (*s == 'r' || *s == '|') // found one\n\t\t{\n\t\t    del_typebuf(\n\t\t\t  (int)(s + 1 - (typebuf.tb_buf + typebuf.tb_off)), 0);\n\t\t    // get size and redraw screen\n\t\t    shell_resized();\n\t\t    *keylenp = keylen;\n\t\t    return map_result_retry;\n\t\t}\n\t\tif (*s == NUL)\t    // need more characters\n\t\t    keylen = KEYLEN_PART_KEY;\n\t    }\n\t    if (keylen >= 0)\n#endif\n\t\t// When there was a matching mapping and no termcode could be\n\t\t// replaced after another one, use that mapping (loop around).\n\t\t// If there was no mapping at all use the character from the\n\t\t// typeahead buffer right here.\n\t\tif (mp == NULL)\n\t\t{\n\t\t    *keylenp = keylen;\n\t\t    return map_result_get;    // get character from typeahead\n\t\t}\n\t}\n\n\tif (keylen > 0)\t    // full matching terminal code\n\t{\n#if defined(FEAT_GUI) && defined(FEAT_MENU)\n\t    if (typebuf.tb_len >= 2\n\t\t    && typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t\t\t      && typebuf.tb_buf[typebuf.tb_off + 1] == KS_MENU)\n\t    {\n\t\tint\tidx;\n\n\t\t// Using a menu may cause a break in undo!  It's like using\n\t\t// gotchars(), but without recording or writing to a script\n\t\t// file.\n\t\tmay_sync_undo();\n\t\tdel_typebuf(3, 0);\n\t\tidx = get_menu_index(current_menu, local_State);\n\t\tif (idx != MENU_INDEX_INVALID)\n\t\t{\n\t\t    // In Select mode and a Visual mode menu is used:  Switch\n\t\t    // to Visual mode temporarily.  Append K_SELECT to switch\n\t\t    // back to Select mode.\n\t\t    if (VIsual_active && VIsual_select\n\t\t\t\t\t&& (current_menu->modes & MODE_VISUAL))\n\t\t    {\n\t\t\tVIsual_select = FALSE;\n\t\t\t(void)ins_typebuf(K_SELECT_STRING,\n\t\t\t\t\t\t   REMAP_NONE, 0, TRUE, FALSE);\n\t\t    }\n\t\t    ins_typebuf(current_menu->strings[idx],\n\t\t\t\tcurrent_menu->noremap[idx],\n\t\t\t\t0, TRUE, current_menu->silent[idx]);\n\t\t}\n\t    }\n#endif // FEAT_GUI && FEAT_MENU\n\t    *keylenp = keylen;\n\t    return map_result_retry;\t// try mapping again\n\t}\n\n\t// Partial match: get some more characters.  When a matching mapping\n\t// was found use that one.\n\tif (mp == NULL || keylen < 0)\n\t    keylen = KEYLEN_PART_KEY;\n\telse\n\t    keylen = mp_match_len;\n    }\n\n    /*\n     * complete match\n     */\n    if (keylen >= 0 && keylen <= typebuf.tb_len)\n    {\n\tchar_u *map_str;\n\n#ifdef FEAT_EVAL\n\tint\tsave_m_expr;\n\tint\tsave_m_noremap;\n\tint\tsave_m_silent;\n\tchar_u\t*save_m_keys;\n#else\n# define save_m_noremap mp->m_noremap\n# define save_m_silent mp->m_silent\n#endif\n\n\t// write chars to script file(s)\n\tif (keylen > typebuf.tb_maplen)\n\t    gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,\n\t\t\t\t\t\t   keylen - typebuf.tb_maplen);\n\n\tcmd_silent = (typebuf.tb_silent > 0);\n\tdel_typebuf(keylen, 0);\t// remove the mapped keys\n\n\t/*\n\t * Put the replacement string in front of mapstr.\n\t * The depth check catches \":map x y\" and \":map y x\".\n\t */\n\tif (++*mapdepth >= p_mmd)\n\t{\n\t    emsg(_(e_recursive_mapping));\n\t    if (State & MODE_CMDLINE)\n\t\tredrawcmdline();\n\t    else\n\t\tsetcursor();\n\t    flush_buffers(FLUSH_MINIMAL);\n\t    *mapdepth = 0;\t// for next one\n\t    *keylenp = keylen;\n\t    return map_result_fail;\n\t}\n\n\t/*\n\t * In Select mode and a Visual mode mapping is used: Switch to Visual\n\t * mode temporarily.  Append K_SELECT to switch back to Select mode.\n\t */\n\tif (VIsual_active && VIsual_select && (mp->m_mode & MODE_VISUAL))\n\t{\n\t    VIsual_select = FALSE;\n\t    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n\n#ifdef FEAT_EVAL\n\t// Copy the values from *mp that are used, because evaluating the\n\t// expression may invoke a function that redefines the mapping, thereby\n\t// making *mp invalid.\n\tsave_m_expr = mp->m_expr;\n\tsave_m_noremap = mp->m_noremap;\n\tsave_m_silent = mp->m_silent;\n\tsave_m_keys = NULL;  // only saved when needed\n\n\t/*\n\t * Handle \":map <expr>\": evaluate the {rhs} as an expression.  Also\n\t * save and restore the command line for \"normal :\".\n\t */\n\tif (mp->m_expr)\n\t{\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_may_garbage_collect = may_garbage_collect;\n\t    int was_screen_col = screen_cur_col;\n\t    int was_screen_row = screen_cur_row;\n\t    int prev_did_emsg = did_emsg;\n\n\t    vgetc_busy = 0;\n\t    may_garbage_collect = FALSE;\n\n\t    save_m_keys = vim_strsave(mp->m_keys);\n\t    map_str = eval_map_expr(mp, NUL);\n\n\t    // The mapping may do anything, but we expect it to take care of\n\t    // redrawing.  Do put the cursor back where it was.\n\t    windgoto(was_screen_row, was_screen_col);\n\t    out_flush();\n\n\t    // If an error was displayed and the expression returns an empty\n\t    // string, generate a <Nop> to allow for a redraw.\n\t    if (prev_did_emsg != did_emsg\n\t\t\t\t       && (map_str == NULL || *map_str == NUL))\n\t    {\n\t\tchar_u\tbuf[4];\n\n\t\tvim_free(map_str);\n\t\tbuf[0] = K_SPECIAL;\n\t\tbuf[1] = KS_EXTRA;\n\t\tbuf[2] = KE_IGNORE;\n\t\tbuf[3] = NUL;\n\t\tmap_str = vim_strsave(buf);\n\t\tif (State & MODE_CMDLINE)\n\t\t{\n\t\t    // redraw the command below the error\n\t\t    msg_didout = TRUE;\n\t\t    if (msg_row < cmdline_row)\n\t\t\tmsg_row = cmdline_row;\n\t\t    redrawcmd();\n\t\t}\n\t    }\n\n\t    vgetc_busy = save_vgetc_busy;\n\t    may_garbage_collect = save_may_garbage_collect;\n\t}\n\telse\n#endif\n\t    map_str = mp->m_str;\n\n\t/*\n\t * Insert the 'to' part in the typebuf.tb_buf.\n\t * If 'from' field is the same as the start of the 'to' field, don't\n\t * remap the first character (but do allow abbreviations).\n\t * If m_noremap is set, don't remap the whole 'to' part.\n\t */\n\tif (map_str == NULL)\n\t    i = FAIL;\n\telse\n\t{\n\t    int noremap;\n\n#ifdef FEAT_EVAL\n\t    last_used_map = mp;\n\t    last_used_sid = -1;\n#endif\n\t    if (save_m_noremap != REMAP_YES)\n\t\tnoremap = save_m_noremap;\n\t    else if (\n#ifdef FEAT_EVAL\n\t\tSTRNCMP(map_str, save_m_keys != NULL ? save_m_keys : mp->m_keys,\n\t\t\t\t\t\t\t\t(size_t)keylen)\n#else\n\t\tSTRNCMP(map_str, mp->m_keys, (size_t)keylen)\n#endif\n\t\t   != 0)\n\t\tnoremap = REMAP_YES;\n\t    else\n\t\tnoremap = REMAP_SKIP;\n\t    i = ins_typebuf(map_str, noremap,\n\t\t\t\t\t 0, TRUE, cmd_silent || save_m_silent);\n#ifdef FEAT_EVAL\n\t    if (save_m_expr)\n\t\tvim_free(map_str);\n#endif\n\t}\n#ifdef FEAT_EVAL\n\tvim_free(save_m_keys);\n#endif\n\t*keylenp = keylen;\n\tif (i == FAIL)\n\t    return map_result_fail;\n\treturn map_result_retry;\n    }\n\n    *keylenp = keylen;\n    return map_result_nomatch;\n}\n\n/*\n * unget one character (can only be done once!)\n * If the character was stuffed, vgetc() will get it next time it is called.\n * Otherwise vgetc() will only get it when the stuff buffer is empty.\n */\n    void\nvungetc(int c)\n{\n    old_char = c;\n    old_mod_mask = mod_mask;\n    old_mouse_row = mouse_row;\n    old_mouse_col = mouse_col;\n    old_KeyStuffed = KeyStuffed;\n}\n\n/*\n * When peeking and not getting a character, reg_executing cannot be cleared\n * yet, so set a flag to clear it later.\n */\n    static void\ncheck_end_reg_executing(int advance)\n{\n    if (reg_executing != 0 && (typebuf.tb_maplen == 0\n\t\t\t\t\t\t|| pending_end_reg_executing))\n    {\n\tif (advance)\n\t{\n\t    reg_executing = 0;\n\t    pending_end_reg_executing = FALSE;\n\t}\n\telse\n\t    pending_end_reg_executing = TRUE;\n    }\n\n}\n\n/*\n * Get a byte:\n * 1. from the stuffbuffer\n *\tThis is used for abbreviated commands like \"D\" -> \"d$\".\n *\tAlso used to redo a command for \".\".\n * 2. from the typeahead buffer\n *\tStores text obtained previously but not used yet.\n *\tAlso stores the result of mappings.\n *\tAlso used for the \":normal\" command.\n * 3. from the user\n *\tThis may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *\tReally get the character.\n *\tKeyTyped is set to TRUE in the case the user typed the key.\n *\tKeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *\tJust look whether there is a character available.\n *\tReturn NUL if not.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n    int\t\tc, c1;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tc1 = 0;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    c1 = 1;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // this looks nice when typing a dead character map\n\t\t    if ((State & MODE_CMDLINE)\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tc1 = 1;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (c1 == 1)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if (State & MODE_CMDLINE)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}\n\n/*\n * inchar() - get one character from\n *\t1. a scriptfile\n *\t2. the keyboard\n *\n *  As many characters as we can get (up to 'maxlen') are put in \"buf\" and\n *  NUL terminated (buffer length must be 'maxlen' + 1).\n *  Minimum for \"maxlen\" is 3!!!!\n *\n *  \"tb_change_cnt\" is the value of typebuf.tb_change_cnt if \"buf\" points into\n *  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received\n *  from a remote client) \"buf\" can no longer be used.  \"tb_change_cnt\" is 0\n *  otherwise.\n *\n *  If we got an interrupt all input is read until none is available.\n *\n *  If wait_time == 0  there is no waiting for the char.\n *  If wait_time == n  we wait for n msec for a character to arrive.\n *  If wait_time == -1 we wait forever for a character to arrive.\n *\n *  Return the number of obtained characters.\n *  Return -1 when end of input script reached.\n */\n    static int\ninchar(\n    char_u\t*buf,\n    int\t\tmaxlen,\n    long\twait_time)\t    // milliseconds\n{\n    int\t\tlen = 0;\t    // init for GCC\n    int\t\tretesc = FALSE;\t    // return ESC with gotint\n    int\t\tscript_char;\n    int\t\ttb_change_cnt = typebuf.tb_change_cnt;\n\n    if (wait_time == -1L || wait_time > 100L)  // flush output before waiting\n    {\n\tcursor_on();\n\tout_flush_cursor(FALSE, FALSE);\n#if defined(FEAT_GUI) && defined(FEAT_MOUSESHAPE)\n\tif (gui.in_use && postponed_mouseshape)\n\t    update_mouseshape(-1);\n#endif\n    }\n\n    /*\n     * Don't reset these when at the hit-return prompt, otherwise a endless\n     * recursive loop may result (write error in swapfile, hit-return, timeout\n     * on char wait, flush swapfile, write error....).\n     */\n    if (State != MODE_HITRETURN)\n    {\n\tdid_outofmem_msg = FALSE;   // display out of memory message (again)\n\tdid_swapwrite_msg = FALSE;  // display swap file write error again\n    }\n    undo_off = FALSE;\t\t    // restart undo now\n\n    /*\n     * Get a character from a script file if there is one.\n     * If interrupted: Stop reading script files, close them all.\n     */\n    script_char = -1;\n    while (scriptin[curscript] != NULL && script_char < 0\n#ifdef FEAT_EVAL\n\t    && !ignore_script\n#endif\n\t    )\n    {\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n\n\tif (got_int || (script_char = getc(scriptin[curscript])) < 0)\n\t{\n\t    // Reached EOF.\n\t    // Careful: closescript() frees typebuf.tb_buf[] and buf[] may\n\t    // point inside typebuf.tb_buf[].  Don't use buf[] after this!\n\t    closescript();\n\t    /*\n\t     * When reading script file is interrupted, return an ESC to get\n\t     * back to normal mode.\n\t     * Otherwise return -1, because typebuf.tb_buf[] has changed.\n\t     */\n\t    if (got_int)\n\t\tretesc = TRUE;\n\t    else\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    buf[0] = script_char;\n\t    len = 1;\n\t}\n    }\n\n    if (script_char < 0)\t// did not get a character from script\n    {\n\t/*\n\t * If we got an interrupt, skip all previously typed characters and\n\t * return TRUE if quit reading script file.\n\t * Stop reading typeahead when a single CTRL-C was read,\n\t * fill_input_buf() returns this when not able to read from stdin.\n\t * Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]\n\t * and buf may be pointing inside typebuf.tb_buf[].\n\t */\n\tif (got_int)\n\t{\n#define DUM_LEN (MAXMAPLEN * 3 + 3)\n\t    char_u\tdum[DUM_LEN + 1];\n\n\t    for (;;)\n\t    {\n\t\tlen = ui_inchar(dum, DUM_LEN, 0L, 0);\n\t\tif (len == 0 || (len == 1 && dum[0] == Ctrl_C))\n\t\t    break;\n\t    }\n\t    return retesc;\n\t}\n\n\t/*\n\t * Always flush the output characters when getting input characters\n\t * from the user and not just peeking.\n\t */\n\tif (wait_time == -1L || wait_time > 10L)\n\t    out_flush();\n\n\t/*\n\t * Fill up to a third of the buffer, because each character may be\n\t * tripled below.\n\t */\n\tlen = ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt);\n    }\n\n    // If the typebuf was changed further down, it is like nothing was added by\n    // this call.\n    if (typebuf_changed(tb_change_cnt))\n\treturn 0;\n\n    // Note the change in the typeahead buffer, this matters for when\n    // vgetorpeek() is called recursively, e.g. using getchar(1) in a timer\n    // function.\n    if (len > 0 && ++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    return fix_input_buffer(buf, len);\n}\n\n/*\n * Fix typed characters for use by vgetc() and check_termcode().\n * \"buf[]\" must have room to triple the number of bytes!\n * Returns the new length.\n */\n    int\nfix_input_buffer(char_u *buf, int len)\n{\n    int\t\ti;\n    char_u\t*p = buf;\n\n    /*\n     * Two characters are special: NUL and K_SPECIAL.\n     * When compiled With the GUI CSI is also special.\n     * Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER\n     * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER\n     * Replace       CSI by K_SPECIAL KS_EXTRA   KE_CSI\n     */\n    for (i = len; --i >= 0; ++p)\n    {\n#ifdef FEAT_GUI\n\t// When the GUI is used any character can come after a CSI, don't\n\t// escape it.\n\tif (gui.in_use && p[0] == CSI && i >= 2)\n\t{\n\t    p += 2;\n\t    i -= 2;\n\t}\n# ifndef MSWIN\n\t// When not on MS-Windows and the GUI is not used CSI needs to be\n\t// escaped.\n\telse if (!gui.in_use && p[0] == CSI)\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    *p++ = K_SPECIAL;\n\t    *p++ = KS_EXTRA;\n\t    *p = (int)KE_CSI;\n\t    len += 2;\n\t}\n# endif\n\telse\n#endif\n\tif (p[0] == NUL || (p[0] == K_SPECIAL\n\t\t    // timeout may generate K_CURSORHOLD\n\t\t    && (i < 2 || p[1] != KS_EXTRA || p[2] != (int)KE_CURSORHOLD)\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t\t    // Win32 console passes modifiers\n\t\t    && (\n# ifdef VIMDLL\n\t\t\tgui.in_use ||\n# endif\n\t\t\t(i < 2 || p[1] != KS_MODIFIER))\n#endif\n\t\t    ))\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    p[2] = K_THIRD(p[0]);\n\t    p[1] = K_SECOND(p[0]);\n\t    p[0] = K_SPECIAL;\n\t    p += 2;\n\t    len += 2;\n\t}\n    }\n    *p = NUL;\t\t// add trailing NUL\n    return len;\n}\n\n#if defined(USE_INPUT_BUF) || defined(PROTO)\n/*\n * Return TRUE when bytes are in the input buffer or in the typeahead buffer.\n * Normally the input buffer would be sufficient, but the server_to_input_buf()\n * or feedkeys() may insert characters in the typeahead buffer while we are\n * waiting for input to arrive.\n */\n    int\ninput_available(void)\n{\n    return (!vim_is_input_buf_empty()\n# if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n# endif\n\t    );\n}\n#endif\n\n/*\n * Function passed to do_cmdline() to get the command after a <Cmd> key from\n * typeahead.\n */\n    static char_u *\ngetcmdkeycmd(\n\tint\t\tpromptc UNUSED,\n\tvoid\t\t*cookie UNUSED,\n\tint\t\tindent UNUSED,\n\tgetline_opt_T\tdo_concat UNUSED)\n{\n    garray_T\tline_ga;\n    int\t\tc1 = -1;\n    int\t\tc2;\n    int\t\tcmod = 0;\n    int\t\taborted = FALSE;\n\n    ga_init2(&line_ga, 1, 32);\n\n    // no mapping for these characters\n    no_mapping++;\n\n    got_int = FALSE;\n    while (c1 != NUL && !aborted)\n    {\n\tif (ga_grow(&line_ga, 32) == FAIL)\n\t{\n\t    aborted = TRUE;\n\t    break;\n\t}\n\n\tif (vgetorpeek(FALSE) == NUL)\n\t{\n\t    // incomplete <Cmd> is an error, because there is not much the user\n\t    // could do in this state.\n\t    emsg(_(e_cmd_mapping_must_end_with_cr));\n\t    aborted = TRUE;\n\t    break;\n\t}\n\n\t// Get one character at a time.\n\tc1 = vgetorpeek(TRUE);\n\n\t// Get two extra bytes for special keys\n\tif (c1 == K_SPECIAL)\n\t{\n\t    c1 = vgetorpeek(TRUE);\n\t    c2 = vgetorpeek(TRUE);\n\t    if (c1 == KS_MODIFIER)\n\t    {\n\t\tcmod = c2;\n\t\tcontinue;\n\t    }\n\t    c1 = TO_SPECIAL(c1, c2);\n\n\t    // K_ESC is used to avoid ambiguity with the single Esc character\n\t    // that might be the start of an escape sequence.  Convert it back\n\t    // to a single Esc here.\n\t    if (c1 == K_ESC)\n\t\tc1 = ESC;\n\t}\n\tif (c1 == Ctrl_V)\n\t{\n\t    // CTRL-V is followed by octal, hex or other characters, reverses\n\t    // what AppendToRedobuffLit() does.\n\t    ++no_reduce_keys;  //  don't merge modifyOtherKeys\n\t    c1 = get_literal(TRUE);\n\t    --no_reduce_keys;\n\t}\n\n\tif (got_int)\n\t    aborted = TRUE;\n\telse if (c1 == '\\r' || c1 == '\\n')\n\t    c1 = NUL;  // end the line\n\telse if (c1 == ESC)\n\t    aborted = TRUE;\n\telse if (c1 == K_COMMAND || c1 == K_SCRIPT_COMMAND)\n\t{\n\t    // give a nicer error message for this special case\n\t    emsg(_(e_cmd_mapping_must_end_with_cr_before_second_cmd));\n\t    aborted = TRUE;\n\t}\n\telse if (IS_SPECIAL(c1))\n\t{\n\t    if (c1 == K_SNR)\n\t\tga_concat(&line_ga, (char_u *)\"<SNR>\");\n\t    else\n\t    {\n\t\tsemsg(e_cmd_mapping_must_not_include_str_key,\n\t\t\t\t\t       get_special_key_name(c1, cmod));\n\t\taborted = TRUE;\n\t    }\n\t}\n\telse\n\t    ga_append(&line_ga, c1);\n\n\tcmod = 0;\n    }\n\n    no_mapping--;\n\n    if (aborted)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If there was a mapping we get its SID.  Otherwise, use \"last_used_sid\", it\n * is set when redo'ing.\n * Put this SID in the redo buffer, so that \".\" will use the same script\n * context.\n */\n    void\nmay_add_last_used_map_to_redobuff(void)\n{\n    char_u  buf[3 + 20];\n    int\t    sid = -1;\n\n    if (last_used_map != NULL)\n\tsid = last_used_map->m_script_ctx.sc_sid;\n    if (sid < 0)\n\tsid = last_used_sid;\n\n    if (sid < 0)\n\treturn;\n\n    // <K_SID>{nr};\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = KE_SID;\n    vim_snprintf((char *)buf + 3, 20, \"%d;\", sid);\n    add_buff(&redobuff, buf, -1L);\n}\n#endif\n\n    int\ndo_cmdkey_command(int key UNUSED, int flags)\n{\n    int\t    res;\n#ifdef FEAT_EVAL\n    sctx_T  save_current_sctx = {-1, 0, 0, 0};\n\n    if (key == K_SCRIPT_COMMAND\n\t\t  && (last_used_map != NULL || SCRIPT_ID_VALID(last_used_sid)))\n    {\n\tsave_current_sctx = current_sctx;\n\tif (last_used_map != NULL)\n\t    current_sctx = last_used_map->m_script_ctx;\n\telse\n\t{\n\t    current_sctx.sc_sid = last_used_sid;\n\t    current_sctx.sc_lnum = 0;\n\t    current_sctx.sc_version = SCRIPT_ITEM(last_used_sid)->sn_version;\n\t}\n    }\n#endif\n\n    res = do_cmdline(NULL, getcmdkeycmd, NULL, flags);\n\n#ifdef FEAT_EVAL\n    if (save_current_sctx.sc_sid >= 0)\n\tcurrent_sctx = save_current_sctx;\n#endif\n\n    return res;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nreset_last_used_map(mapblock_T *mp)\n{\n    if (last_used_map != mp)\n\treturn;\n\n    last_used_map = NULL;\n    last_used_sid = -1;\n}\n#endif\n", "\" Functions about terminal shared by several tests\n\n\" Only load this script once.\nif exists('*CanRunVimInTerminal')\n  finish\nendif\n\nsource shared.vim\n\n\" For most tests we need to be able to run terminal Vim with 256 colors.  On\n\" MS-Windows the console only has 16 colors and the GUI can't run in a\n\" terminal.\nfunc CanRunVimInTerminal()\n  return has('terminal') && !has('win32')\nendfunc\n\n\" Skip the rest if there is no terminal feature at all.\nif !has('terminal')\n  finish\nendif\n\n\" Stops the shell running in terminal \"buf\".\nfunc StopShellInTerminal(buf)\n  call term_sendkeys(a:buf, \"exit\\r\")\n  let job = term_getjob(a:buf)\n  call WaitForAssert({-> assert_equal(\"dead\", job_status(job))})\n  call TermWait(a:buf)\nendfunc\n\n\" Wrapper around term_wait() to allow more time for re-runs of flaky tests\n\" The second argument is the minimum time to wait in msec, 10 if omitted.\nfunc TermWait(buf, ...)\n  let wait_time = a:0 ? a:1 : 10\n  if exists('g:run_nr')\n    if g:run_nr == 2\n      let wait_time *= 4\n    elseif g:run_nr > 2\n      let wait_time *= 10\n    endif\n  endif\n  call term_wait(a:buf, wait_time)\n\n  \" In case it wasn't set yet.\n  let g:test_is_flaky = 1\nendfunc\n\n\" Run Vim with \"arguments\" in a new terminal window.\n\" By default uses a size of 20 lines and 75 columns.\n\" Returns the buffer number of the terminal.\n\"\n\" Options is a dictionary, these items are recognized:\n\" \"keep_t_u7\" - when 1 do not make t_u7 empty (resetting t_u7 avoids clearing\n\"               parts of line 2 and 3 on the display)\n\" \"rows\" - height of the terminal window (max. 20)\n\" \"cols\" - width of the terminal window (max. 78)\n\" \"statusoff\" - number of lines the status is offset from default\n\" \"wait_for_ruler\" - if zero then don't wait for ruler to show\nfunc RunVimInTerminal(arguments, options)\n  \" If Vim doesn't exit a swap file remains, causing other tests to fail.\n  \" Remove it here.\n  call delete(\".swp\")\n\n  if exists('$COLORFGBG')\n    \" Clear $COLORFGBG to avoid 'background' being set to \"dark\", which will\n    \" only be corrected if the response to t_RB is received, which may be too\n    \" late.\n    let $COLORFGBG = ''\n  endif\n\n  \" Make a horizontal and vertical split, so that we can get exactly the right\n  \" size terminal window.  Works only when the current window is full width.\n  call assert_equal(&columns, winwidth(0))\n  split\n  vsplit\n\n  \" Always do this with 256 colors and a light background.\n  set t_Co=256 background=light\n  hi Normal ctermfg=NONE ctermbg=NONE\n\n  \" Make the window 20 lines high and 75 columns, unless told otherwise or\n  \" 'termwinsize' is set.\n  let rows = get(a:options, 'rows', 20)\n  let cols = get(a:options, 'cols', 75)\n  let statusoff = get(a:options, 'statusoff', 1)\n\n  if get(a:options, 'keep_t_u7', 0)\n    let reset_u7 = ''\n  else\n    let reset_u7 = ' --cmd \"set t_u7=\" '\n  endif\n\n  let cmd = GetVimCommandCleanTerm() .. reset_u7 .. a:arguments\n\n  let options = #{curwin: 1}\n  if &termwinsize == ''\n    let options.term_rows = rows\n    let options.term_cols = cols\n  endif\n\n  \" Accept other options whose name starts with 'term_'.\n  call extend(options, filter(copy(a:options), 'v:key =~# \"^term_\"'))\n\n  let buf = term_start(cmd, options)\n\n  if &termwinsize == ''\n    \" in the GUI we may end up with a different size, try to set it.\n    if term_getsize(buf) != [rows, cols]\n      call term_setsize(buf, rows, cols)\n    endif\n    call assert_equal([rows, cols], term_getsize(buf))\n  else\n    let rows = term_getsize(buf)[0]\n    let cols = term_getsize(buf)[1]\n  endif\n\n  call TermWait(buf)\n\n  if get(a:options, 'wait_for_ruler', 1)\n    \" Wait for \"All\" or \"Top\" of the ruler to be shown in the last line or in\n    \" the status line of the last window. This can be quite slow (e.g. when\n    \" using valgrind).\n    \" If it fails then show the terminal contents for debugging.\n    try\n      call WaitFor({-> len(term_getline(buf, rows)) >= cols - 1 || len(term_getline(buf, rows - statusoff)) >= cols - 1})\n    catch /timed out after/\n      let lines = map(range(1, rows), {key, val -> term_getline(buf, val)})\n      call assert_report('RunVimInTerminal() failed, screen contents: ' . join(lines, \"<NL>\"))\n    endtry\n  endif\n\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  return buf\nendfunc\n\n\" Stop a Vim running in terminal buffer \"buf\".\nfunc StopVimInTerminal(buf, kill = 1)\n  \" Using a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  call assert_equal(\"running\", term_getstatus(a:buf))\n\n  \" Wait for all the pending updates to terminal to complete\n  call TermWait(a:buf)\n\n  \" CTRL-O : works both in Normal mode and Insert mode to start a command line.\n  \" In Command-line it's inserted, the CTRL-U removes it again.\n  call term_sendkeys(a:buf, \"\\<C-O>:\\<C-U>qa!\\<cr>\")\n\n  \" Wait for all the pending updates to terminal to complete\n  call TermWait(a:buf)\n\n  \" Wait for the terminal to end.\n  call WaitForAssert({-> assert_equal(\"finished\", term_getstatus(a:buf))})\n\n  \" If the buffer still exists forcefully wipe it.\n  if a:kill && bufexists(a:buf)\n    exe a:buf .. 'bwipe!'\n  endif\nendfunc\n\n\" Open a terminal with a shell, assign the job to g:job and return the buffer\n\" number.\nfunc Run_shell_in_terminal(options)\n  if has('win32')\n    let buf = term_start([&shell, '/k'], a:options)\n  else\n    let buf = term_start(&shell, a:options)\n  endif\n  let g:test_is_flaky = 1\n\n  let termlist = term_list()\n  call assert_equal(1, len(termlist))\n  call assert_equal(buf, termlist[0])\n\n  let g:job = term_getjob(buf)\n  call assert_equal(v:t_job, type(g:job))\n\n  let string = string({'job': buf->term_getjob()})\n  call assert_match(\"{'job': 'process \\\\d\\\\+ run'}\", string)\n\n  \" On slower systems it may take a bit of time before the shell is ready to\n  \" accept keys.  This mainly matters when using term_sendkeys() next.\n  call TermWait(buf)\n\n  return buf\nendfunc\n\n\" Return concatenated lines in terminal.\nfunc Term_getlines(buf, lines)\n  return join(map(a:lines, 'term_getline(a:buf, v:val)'), '')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "\" Test editing line in Ex mode (see :help Q and :help gQ).\n\nsource check.vim\nsource shared.vim\n\n\" Helper function to test editing line in Q Ex mode\nfunc Ex_Q(cmd)\n  \" Is there a simpler way to test editing Ex line?\n  call feedkeys(\"Q\"\n        \\    .. \"let s:test_ex =<< END\\<CR>\"\n        \\    .. a:cmd .. \"\\<CR>\"\n        \\    .. \"END\\<CR>\"\n        \\    .. \"visual\\<CR>\", 'tx')\n  return s:test_ex[0]\nendfunc\n\n\" Helper function to test editing line in gQ Ex mode\nfunc Ex_gQ(cmd)\n  call feedkeys(\"gQ\" .. a:cmd .. \"\\<C-b>\\\"\\<CR>\", 'tx')\n  let ret = @:[1:] \" Remove leading quote.\n  call feedkeys(\"visual\\<CR>\", 'tx')\n  return ret\nendfunc\n\n\" Helper function to test editing line with both Q and gQ Ex mode.\nfunc Ex(cmd)\n return [Ex_Q(a:cmd), Ex_gQ(a:cmd)]\nendfunc\n\n\" Test editing line in Ex mode (both Q and gQ)\nfunc Test_ex_mode()\n  let encoding_save = &encoding\n  set sw=2\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call assert_equal(['bar', 'bar'],             Ex(\"foo bar\\<C-u>bar\"), e)\n    call assert_equal([\"1\\<C-u>2\", \"1\\<C-u>2\"],   Ex(\"1\\<C-v>\\<C-u>2\"), e)\n    call assert_equal([\"1\\<C-b>2\\<C-e>3\", '213'], Ex(\"1\\<C-b>2\\<C-e>3\"), e)\n    call assert_equal(['0123', '2013'],           Ex(\"01\\<Home>2\\<End>3\"), e)\n    call assert_equal(['0123', '0213'],           Ex(\"01\\<Left>2\\<Right>3\"), e)\n    call assert_equal(['01234', '0342'],          Ex(\"012\\<Left>\\<Left>\\<Insert>3\\<Insert>4\"), e)\n    call assert_equal([\"foo bar\\<C-w>\", 'foo '],  Ex(\"foo bar\\<C-w>\"), e)\n    call assert_equal(['foo', 'foo'],             Ex(\"fooba\\<Del>\\<Del>\"), e)\n    call assert_equal([\"foo\\tbar\", 'foobar'],     Ex(\"foo\\<Tab>bar\"), e)\n    call assert_equal([\"abbrev\\t\", 'abbreviate'], Ex(\"abbrev\\<Tab>\"), e)\n    call assert_equal(['    1', \"1\\<C-t>\\<C-t>\"], Ex(\"1\\<C-t>\\<C-t>\"), e)\n    call assert_equal(['  1', \"1\\<C-t>\\<C-t>\"],   Ex(\"1\\<C-t>\\<C-t>\\<C-d>\"), e)\n    call assert_equal(['  foo', '    foo'],       Ex(\"    foo\\<C-d>\"), e)\n    call assert_equal(['foo', '    foo0'],        Ex(\"    foo0\\<C-d>\"), e)\n    call assert_equal(['foo', '    foo^'],        Ex(\"    foo^\\<C-d>\"), e)\n    call assert_equal(['foo', 'foo'],\n          \\ Ex(\"\\<BS>\\<C-H>\\<Del>\\<kDel>foo\"), e)\n    \" default wildchar <Tab> interferes with this test\n    set wildchar=<c-e>\n    call assert_equal([\"a\\tb\", \"a\\tb\"],           Ex(\"a\\t\\t\\<C-H>b\"), e)\n    call assert_equal([\"\\t  mn\", \"\\tm\\<C-T>n\"],        Ex(\"\\tm\\<C-T>n\"), e)\n    set wildchar&\n  endfor\n\n  set sw&\n  let &encoding = encoding_save\nendfunc\n\n\" Test substitute confirmation prompt :%s/pat/str/c in Ex mode\nfunc Test_Ex_substitute()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  call term_sendkeys(buf, \":call setline(1, ['foo foo', 'foo foo', 'foo foo'])\\<CR>\")\n  call term_sendkeys(buf, \":set number\\<CR>\")\n  call term_sendkeys(buf, \"gQ\")\n  call WaitForAssert({-> assert_match(':', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \"%s/foo/bar/gc\\<CR>\")\n  call WaitForAssert({-> assert_match('  1 foo foo', term_getline(buf, 5))},\n        \\ 1000)\n  call WaitForAssert({-> assert_match('    ^^^', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \"N\\<CR>\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_match('    ^^^', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \"n\\<CR>\")\n  call WaitForAssert({-> assert_match('        ^^^', term_getline(buf, 6))},\n        \\ 1000)\n  call term_sendkeys(buf, \"y\\<CR>\")\n\n  call term_sendkeys(buf, \"q\\<CR>\")\n  call WaitForAssert({-> assert_match(':', term_getline(buf, 6))}, 1000)\n\n  \" Pressing enter in ex mode should print the current line\n  call term_sendkeys(buf, \"\\<CR>\")\n  call WaitForAssert({-> assert_match('  3 foo foo',\n        \\ term_getline(buf, 5))}, 1000)\n\n  call term_sendkeys(buf, \":vi\\<CR>\")\n  call WaitForAssert({-> assert_match('foo bar', term_getline(buf, 1))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for displaying lines from an empty buffer in Ex mode\nfunc Test_Ex_emptybuf()\n  new\n  call assert_fails('call feedkeys(\"Q\\<CR>\", \"xt\")', 'E749:')\n  call setline(1, \"abc\")\n  call assert_fails('call feedkeys(\"Q\\<CR>\", \"xt\")', 'E501:')\n  call assert_fails('call feedkeys(\"Q%d\\<CR>\", \"xt\")', 'E749:')\n  close!\nendfunc\n\n\" Test for the :open command\nfunc Test_open_command()\n  new\n  call setline(1, ['foo foo', 'foo bar', 'foo baz'])\n  call feedkeys(\"Qopen\\<CR>j\", 'xt')\n  call assert_equal('foo bar', getline('.'))\n  call feedkeys(\"Qopen /bar/\\<CR>\", 'xt')\n  call assert_equal(5, col('.'))\n  call assert_fails('call feedkeys(\"Qopen /baz/\\<CR>\", \"xt\")', 'E479:')\n  close!\nendfunc\n\nfunc Test_open_command_flush_line()\n  \" this was accessing freed memory: the regexp match uses a pointer to the\n  \" current line which becomes invalid when searching for the ') mark.\n  new\n  call setline(1, ['one', 'two. three'])\n  s/one/ONE\n  try\n    open /\\%')/\n  catch /E479/\n  endtry\n  bwipe!\nendfunc\n\n\" Test for :g/pat/visual to run vi commands in Ex mode\n\" This used to hang Vim before 8.2.0274.\nfunc Test_Ex_global()\n  new\n  call setline(1, ['', 'foo', 'bar', 'foo', 'bar', 'foo'])\n  call feedkeys(\"Q\\<bs>g/bar/visual\\<CR>$rxQ$ryQvisual\\<CR>j\", \"xt\")\n  call assert_equal('bax', getline(3))\n  call assert_equal('bay', getline(5))\n  bwipe!\nendfunc\n\n\" Test for pressing Ctrl-C in :append inside a loop in Ex mode\n\" This used to hang Vim\nfunc Test_Ex_append_in_loop()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  call term_sendkeys(buf, \"gQ\")\n  call term_sendkeys(buf, \"for i in range(1)\\<CR>\")\n  call term_sendkeys(buf, \"append\\<CR>\")\n  call WaitForAssert({-> assert_match(':  append', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \"\\<C-C>\")\n  \" Wait for input to be flushed\n  call term_wait(buf)\n  call term_sendkeys(buf, \"foo\\<CR>\")\n  call WaitForAssert({-> assert_match('foo', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \".\\<CR>\")\n  call WaitForAssert({-> assert_match('.', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \"endfor\\<CR>\")\n  call term_sendkeys(buf, \"vi\\<CR>\")\n  call WaitForAssert({-> assert_match('foo', term_getline(buf, 1))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" In Ex-mode, a backslash escapes a newline\nfunc Test_Ex_escape_enter()\n  call feedkeys(\"gQlet l = \\\"a\\\\\\<kEnter>b\\\"\\<cr>vi\\<cr>\", 'xt')\n  call assert_equal(\"a\\rb\", l)\nendfunc\n\n\" Test for :append! command in Ex mode\nfunc Test_Ex_append()\n  new\n  call setline(1, \"\\t   abc\")\n  call feedkeys(\"Qappend!\\npqr\\nxyz\\n.\\nvisual\\n\", 'xt')\n  call assert_equal([\"\\t   abc\", \"\\t   pqr\", \"\\t   xyz\"], getline(1, '$'))\n  close!\nendfunc\n\n\" In Ex-mode, backslashes at the end of a command should be halved.\nfunc Test_Ex_echo_backslash()\n  \" This test works only when the language is English\n  CheckEnglish\n  let bsl = '\\\\\\\\'\n  let bsl2 = '\\\\\\'\n  call assert_fails('call feedkeys(\"Qecho \" .. bsl .. \"\\nvisual\\n\", \"xt\")',\n        \\ 'E15: Invalid expression: \"\\\\\"')\n  call assert_fails('call feedkeys(\"Qecho \" .. bsl2 .. \"\\nm\\nvisual\\n\", \"xt\")',\n        \\ \"E15: Invalid expression: \\\"\\\\\\nm\\\"\")\nendfunc\n\nfunc Test_ex_mode_errors()\n  \" Not allowed to enter ex mode when text is locked\n  au InsertCharPre <buffer> normal! gQ<CR>\n  let caught_e565 = 0\n  try\n    call feedkeys(\"ix\\<esc>\", 'xt')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n    let caught_e565 = 1\n  endtry\n  call assert_equal(1, caught_e565)\n  au! InsertCharPre\n\n  new\n  au CmdLineEnter * call ExEnterFunc()\n  func ExEnterFunc()\n\n  endfunc\n  call feedkeys(\"gQvi\\r\", 'xt')\n\n  au! CmdLineEnter\n  delfunc ExEnterFunc\n  quit\nendfunc\n\nfunc Test_ex_mode_with_global()\n  CheckNotGui\n  CheckFeature timers\n\n  \" This will get stuck in Normal mode after the failed \"J\", use a timer to\n  \" get going again.\n  let lines =<< trim END\n    call ch_logfile('logfile', 'w')\n    pedit\n    func FeedQ(id)\n      call feedkeys('Q', 't')\n    endfunc\n    call timer_start(10, 'FeedQ')\n    g/^/vi|HJ\n    call writefile(['done'], 'Xdidexmode')\n    qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-e -s -S Xexmodescript'))\n  call assert_equal(['done'], readfile('Xdidexmode'))\n\n  call delete('logfile')\n  call delete('Xdidexmode')\nendfunc\n\nfunc Test_ex_mode_count_overflow()\n  \" The multiplication causes an integer overflow\n  CheckNotAsan\n\n  \" this used to cause a crash\n  let lines =<< trim END\n    call feedkeys(\"\\<Esc>Q\\<CR>\")\n    v9|9silent! vi|333333233333y32333333%O\n    call writefile(['done'], 'Xdidexmode')\n    qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-e -s -S Xexmodescript -c qa'))\n  call assert_equal(['done'], readfile('Xdidexmode'))\n\n  call delete('Xdidexmode')\nendfunc\n\nfunc Test_ex_mode_large_indent()\n  new\n  set ts=500 ai\n  call setline(1, \"\\t\")\n  exe \"normal gQi\\<CR>.\"\n  set ts=8 noai\n  bwipe!\nendfunc\n\n\" This was accessing illegal memory when using \"+\" for eap->cmd.\nfunc Test_empty_command_visual_mode()\n  let lines =<< trim END\n      r<sfile>\n      0norm0V:\u001b\n      :qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-u NONE -e -s -S Xexmodescript'))\n\n  \" This may cause a dialog to be displayed for an empty command, ignore it.\n  call delete('guidialogfile')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * getchar.c: Code related to getting a character from the user or a script\n * file, manipulations with redo buffer and stuff buffer.\n */\n\n#include \"vim.h\"\n\n/*\n * These buffers are used for storing:\n * - stuffed characters: A command that is translated into another command.\n * - redo characters: will redo the last change.\n * - recorded characters: for the \"q\" command.\n *\n * The bytes are stored like in the typeahead buffer:\n * - K_SPECIAL introduces a special key (two more bytes follow).  A literal\n *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.\n * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,\n *   otherwise switching the GUI on would make mappings invalid).\n *   A literal CSI is stored as CSI KS_EXTRA KE_CSI.\n * These translations are also done on multi-byte characters!\n *\n * Escaping CSI bytes is done by the system-specific input functions, called\n * by ui_inchar().\n * Escaping K_SPECIAL is done by inchar().\n * Un-escaping is done by vgetc().\n */\n\n#define MINIMAL_SIZE 20\t\t\t// minimal size for b_str\n\nstatic buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};\nstatic buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};\n\nstatic int typeahead_char = 0;\t\t// typeahead char that's not flushed\n\n/*\n * when block_redo is TRUE redo buffer will not be changed\n * used by edit() to repeat insertions and 'V' command for redoing\n */\nstatic int\tblock_redo = FALSE;\n\nstatic int\tKeyNoremap = 0;\t    // remapping flags\n\n/*\n * Variables used by vgetorpeek() and flush_buffers().\n *\n * typebuf.tb_buf[] contains all characters that are not consumed yet.\n * typebuf.tb_buf[typebuf.tb_off] is the first valid character.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.\n * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.\n * The head of the buffer may contain the result of mappings, abbreviations\n * and @a commands.  The length of this part is typebuf.tb_maplen.\n * typebuf.tb_silent is the part where <silent> applies.\n * After the head are characters that come from the terminal.\n * typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that\n * should not be considered for abbreviations.\n * Some parts of typebuf.tb_buf may not be mapped. These parts are remembered\n * in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and\n * contains RM_NONE for the characters that are not to be remapped.\n * typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.\n * (typebuf has been put in globals.h, because check_termcode() needs it).\n */\n#define RM_YES\t\t0\t// tb_noremap: remap\n#define RM_NONE\t\t1\t// tb_noremap: don't remap\n#define RM_SCRIPT\t2\t// tb_noremap: remap local script mappings\n#define RM_ABBR\t\t4\t// tb_noremap: don't remap, do abbrev.\n\n// typebuf.tb_buf has three parts: room in front (for result of mappings), the\n// middle for typeahead and room for new characters (which needs to be 3 *\n// MAXMAPLEN for the Amiga).\n#define TYPELEN_INIT\t(5 * (MAXMAPLEN + 3))\nstatic char_u\ttypebuf_init[TYPELEN_INIT];\t// initial typebuf.tb_buf\nstatic char_u\tnoremapbuf_init[TYPELEN_INIT];\t// initial typebuf.tb_noremap\n\nstatic int\tlast_recorded_len = 0;\t// number of last recorded chars\n\n#ifdef FEAT_EVAL\nmapblock_T\t*last_used_map = NULL;\nint\t\tlast_used_sid = -1;\n#endif\n\nstatic int\tread_readbuf(buffheader_T *buf, int advance);\nstatic void\tinit_typebuf(void);\nstatic void\tmay_sync_undo(void);\nstatic void\tfree_typebuf(void);\nstatic void\tclosescript(void);\nstatic void\tupdatescript(int c);\nstatic int\tvgetorpeek(int);\nstatic int\tinchar(char_u *buf, int maxlen, long wait_time);\n\n/*\n * Free and clear a buffer.\n */\n    static void\nfree_buff(buffheader_T *buf)\n{\n    buffblock_T\t*p, *np;\n\n    for (p = buf->bh_first.b_next; p != NULL; p = np)\n    {\n\tnp = p->b_next;\n\tvim_free(p);\n    }\n    buf->bh_first.b_next = NULL;\n    buf->bh_curr = NULL;\n}\n\n/*\n * Return the contents of a buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    static char_u *\nget_buffcont(\n    buffheader_T\t*buffer,\n    int\t\t\tdozero)\t    // count == zero is not an error\n{\n    long_u\t    count = 0;\n    char_u\t    *p = NULL;\n    char_u\t    *p2;\n    char_u\t    *str;\n    buffblock_T *bp;\n\n    // compute the total length of the string\n    for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\tcount += (long_u)STRLEN(bp->b_str);\n\n    if ((count || dozero) && (p = alloc(count + 1)) != NULL)\n    {\n\tp2 = p;\n\tfor (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)\n\t    for (str = bp->b_str; *str; )\n\t\t*p2++ = *str++;\n\t*p2 = NUL;\n    }\n    return (p);\n}\n\n/*\n * Return the contents of the record buffer as a single string\n * and clear the record buffer.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_recorded(void)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    p = get_buffcont(&recordbuff, TRUE);\n    free_buff(&recordbuff);\n\n    /*\n     * Remove the characters that were added the last time, these must be the\n     * (possibly mapped) characters that stopped the recording.\n     */\n    len = STRLEN(p);\n    if ((int)len >= last_recorded_len)\n    {\n\tlen -= last_recorded_len;\n\tp[len] = NUL;\n    }\n\n    /*\n     * When stopping recording from Insert mode with CTRL-O q, also remove the\n     * CTRL-O.\n     */\n    if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)\n\tp[len - 1] = NUL;\n\n    return (p);\n}\n\n/*\n * Return the contents of the redo buffer as a single string.\n * K_SPECIAL and CSI in the returned string are escaped.\n */\n    char_u *\nget_inserted(void)\n{\n    return get_buffcont(&redobuff, FALSE);\n}\n\n/*\n * Add string \"s\" after the current block of buffer \"buf\".\n * K_SPECIAL and CSI should have been escaped already.\n */\n    static void\nadd_buff(\n    buffheader_T\t*buf,\n    char_u\t\t*s,\n    long\t\tslen)\t// length of \"s\" or -1\n{\n    buffblock_T *p;\n    long_u\t    len;\n\n    if (slen < 0)\n\tslen = (long)STRLEN(s);\n    if (slen == 0)\t\t\t\t// don't add empty strings\n\treturn;\n\n    if (buf->bh_first.b_next == NULL)\t// first add to list\n    {\n\tbuf->bh_space = 0;\n\tbuf->bh_curr = &(buf->bh_first);\n    }\n    else if (buf->bh_curr == NULL)\t// buffer has already been read\n    {\n\tiemsg(_(e_add_to_internal_buffer_that_was_already_read_from));\n\treturn;\n    }\n    else if (buf->bh_index != 0)\n\tmch_memmove(buf->bh_first.b_next->b_str,\n\t\t    buf->bh_first.b_next->b_str + buf->bh_index,\n\t\t    STRLEN(buf->bh_first.b_next->b_str + buf->bh_index) + 1);\n    buf->bh_index = 0;\n\n    if (buf->bh_space >= (int)slen)\n    {\n\tlen = (long_u)STRLEN(buf->bh_curr->b_str);\n\tvim_strncpy(buf->bh_curr->b_str + len, s, (size_t)slen);\n\tbuf->bh_space -= slen;\n    }\n    else\n    {\n\tif (slen < MINIMAL_SIZE)\n\t    len = MINIMAL_SIZE;\n\telse\n\t    len = slen;\n\tp = alloc(offsetof(buffblock_T, b_str) + len + 1);\n\tif (p == NULL)\n\t    return; // no space, just forget it\n\tbuf->bh_space = (int)(len - slen);\n\tvim_strncpy(p->b_str, s, (size_t)slen);\n\n\tp->b_next = buf->bh_curr->b_next;\n\tbuf->bh_curr->b_next = p;\n\tbuf->bh_curr = p;\n    }\n}\n\n/*\n * Delete \"slen\" bytes from the end of \"buf\".\n * Only works when it was just added.\n */\n    static void\ndelete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len;\n\n    if (buf->bh_curr == NULL)\n\treturn;  // nothing to delete\n    len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len < slen)\n\treturn;\n\n    buf->bh_curr->b_str[len - slen] = NUL;\n    buf->bh_space += slen;\n}\n\n/*\n * Add number \"n\" to buffer \"buf\".\n */\n    static void\nadd_num_buff(buffheader_T *buf, long n)\n{\n    char_u\tnumber[32];\n\n    sprintf((char *)number, \"%ld\", n);\n    add_buff(buf, number, -1L);\n}\n\n/*\n * Add character 'c' to buffer \"buf\".\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    static void\nadd_char_buff(buffheader_T *buf, int c)\n{\n    char_u\tbytes[MB_MAXBYTES + 1];\n    int\t\tlen;\n    int\t\ti;\n    char_u\ttemp[4];\n\n    if (IS_SPECIAL(c))\n\tlen = 1;\n    else\n\tlen = (*mb_char2bytes)(c, bytes);\n    for (i = 0; i < len; ++i)\n    {\n\tif (!IS_SPECIAL(c))\n\t    c = bytes[i];\n\n\tif (IS_SPECIAL(c) || c == K_SPECIAL || c == NUL)\n\t{\n\t    // translate special key code into three byte sequence\n\t    temp[0] = K_SPECIAL;\n\t    temp[1] = K_SECOND(c);\n\t    temp[2] = K_THIRD(c);\n\t    temp[3] = NUL;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    // Translate a CSI to a CSI - KS_EXTRA - KE_CSI sequence\n\t    temp[0] = CSI;\n\t    temp[1] = KS_EXTRA;\n\t    temp[2] = (int)KE_CSI;\n\t    temp[3] = NUL;\n\t}\n#endif\n\telse\n\t{\n\t    temp[0] = c;\n\t    temp[1] = NUL;\n\t}\n\tadd_buff(buf, temp, -1L);\n    }\n}\n\n// First read ahead buffer. Used for translated commands.\nstatic buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};\n\n// Second read ahead buffer. Used for redo.\nstatic buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};\n\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n\tc = read_readbuf(&readbuf2, advance);\n    return c;\n}\n\n    static int\nread_readbuf(buffheader_T *buf, int advance)\n{\n    char_u\tc;\n    buffblock_T\t*curr;\n\n    if (buf->bh_first.b_next == NULL)  // buffer is empty\n\treturn NUL;\n\n    curr = buf->bh_first.b_next;\n    c = curr->b_str[buf->bh_index];\n\n    if (advance)\n    {\n\tif (curr->b_str[++buf->bh_index] == NUL)\n\t{\n\t    buf->bh_first.b_next = curr->b_next;\n\t    vim_free(curr);\n\t    buf->bh_index = 0;\n\t}\n    }\n    return c;\n}\n\n/*\n * Prepare the read buffers for reading (if they contain something).\n */\n    static void\nstart_stuff(void)\n{\n    if (readbuf1.bh_first.b_next != NULL)\n    {\n\treadbuf1.bh_curr = &(readbuf1.bh_first);\n\treadbuf1.bh_space = 0;\n    }\n    if (readbuf2.bh_first.b_next != NULL)\n    {\n\treadbuf2.bh_curr = &(readbuf2.bh_first);\n\treadbuf2.bh_space = 0;\n    }\n}\n\n/*\n * Return TRUE if the stuff buffer is empty.\n */\n    int\nstuff_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL\n\t && readbuf2.bh_first.b_next == NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if readbuf1 is empty.  There may still be redo characters in\n * redbuf2.\n */\n    int\nreadbuf1_empty(void)\n{\n    return (readbuf1.bh_first.b_next == NULL);\n}\n#endif\n\n/*\n * Set a typeahead character that won't be flushed.\n */\n    void\ntypeahead_noflush(int c)\n{\n    typeahead_char = c;\n}\n\n/*\n * Remove the contents of the stuff buffer and the mapped characters in the\n * typeahead buffer (used in case of an error).  If \"flush_typeahead\" is true,\n * flush all typeahead characters (used when interrupted by a CTRL-C).\n */\n    void\nflush_buffers(flush_buffers_T flush_typeahead)\n{\n    init_typebuf();\n\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n\n    if (flush_typeahead == FLUSH_MINIMAL)\n    {\n\t// remove mapped characters at the start only\n\ttypebuf.tb_off += typebuf.tb_maplen;\n\ttypebuf.tb_len -= typebuf.tb_maplen;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\tif (typebuf.tb_len == 0)\n\t    typebuf_was_filled = FALSE;\n#endif\n    }\n    else\n    {\n\t// remove typeahead\n\tif (flush_typeahead == FLUSH_INPUT)\n\t    // We have to get all characters, because we may delete the first\n\t    // part of an escape sequence.  In an xterm we get one char at a\n\t    // time and we have to get them all.\n\t    while (inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 10L) != 0)\n\t\t;\n\ttypebuf.tb_off = MAXMAPLEN;\n\ttypebuf.tb_len = 0;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t// Reset the flag that text received from a client or from feedkeys()\n\t// was inserted in the typeahead buffer.\n\ttypebuf_was_filled = FALSE;\n#endif\n    }\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    cmd_silent = FALSE;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * The previous contents of the redo buffer is kept in old_redobuffer.\n * This is used for the CTRL-O <.> command in insert mode.\n */\n    void\nResetRedobuff(void)\n{\n    if (block_redo)\n\treturn;\n\n    free_buff(&old_redobuff);\n    old_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n}\n\n/*\n * Discard the contents of the redo buffer and restore the previous redo\n * buffer.\n */\n    void\nCancelRedo(void)\n{\n    if (block_redo)\n\treturn;\n\n    free_buff(&redobuff);\n    redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n    start_stuff();\n    while (read_readbuffers(TRUE) != NUL)\n\t;\n}\n\n/*\n * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.\n * Used before executing autocommands and user functions.\n */\n    void\nsaveRedobuff(save_redo_T *save_redo)\n{\n    char_u\t*s;\n\n    save_redo->sr_redobuff = redobuff;\n    redobuff.bh_first.b_next = NULL;\n    save_redo->sr_old_redobuff = old_redobuff;\n    old_redobuff.bh_first.b_next = NULL;\n\n    // Make a copy, so that \":normal .\" in a function works.\n    s = get_buffcont(&save_redo->sr_redobuff, FALSE);\n    if (s == NULL)\n\treturn;\n\n    add_buff(&redobuff, s, -1L);\n    vim_free(s);\n}\n\n/*\n * Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.\n * Used after executing autocommands and user functions.\n */\n    void\nrestoreRedobuff(save_redo_T *save_redo)\n{\n    free_buff(&redobuff);\n    redobuff = save_redo->sr_redobuff;\n    free_buff(&old_redobuff);\n    old_redobuff = save_redo->sr_old_redobuff;\n}\n\n/*\n * Append \"s\" to the redo buffer.\n * K_SPECIAL and CSI should already have been escaped.\n */\n    void\nAppendToRedobuff(char_u *s)\n{\n    if (!block_redo)\n\tadd_buff(&redobuff, s, -1L);\n}\n\n/*\n * Append to Redo buffer literally, escaping special characters with CTRL-V.\n * K_SPECIAL and CSI are escaped as well.\n */\n    void\nAppendToRedobuffLit(\n    char_u\t*str,\n    int\t\tlen)\t    // length of \"str\" or -1 for up to the NUL\n{\n    char_u\t*s = str;\n    int\t\tc;\n    char_u\t*start;\n\n    if (block_redo)\n\treturn;\n\n    while (len < 0 ? *s != NUL : s - str < len)\n    {\n\t// Put a string of normal characters in the redo buffer (that's\n\t// faster).\n\tstart = s;\n\twhile (*s >= ' ' && *s < DEL && (len < 0 || s - str < len))\n\t    ++s;\n\n\t// Don't put '0' or '^' as last character, just in case a CTRL-D is\n\t// typed next.\n\tif (*s == NUL && (s[-1] == '0' || s[-1] == '^'))\n\t    --s;\n\tif (s > start)\n\t    add_buff(&redobuff, start, (long)(s - start));\n\n\tif (*s == NUL || (len >= 0 && s - str >= len))\n\t    break;\n\n\t// Handle a special or multibyte character.\n\tif (has_mbyte)\n\t    // Handle composing chars separately.\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\tif (c < ' ' || c == DEL || (*s == NUL && (c == '0' || c == '^')))\n\t    add_char_buff(&redobuff, Ctrl_V);\n\n\t// CTRL-V '0' must be inserted as CTRL-V 048\n\tif (*s == NUL && c == '0')\n\t    add_buff(&redobuff, (char_u *)\"048\", 3L);\n\telse\n\t    add_char_buff(&redobuff, c);\n    }\n}\n\n/*\n * Append a character to the redo buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nAppendCharToRedobuff(int c)\n{\n    if (!block_redo)\n\tadd_char_buff(&redobuff, c);\n}\n\n/*\n * Append a number to the redo buffer.\n */\n    void\nAppendNumberToRedobuff(long n)\n{\n    if (!block_redo)\n\tadd_num_buff(&redobuff, n);\n}\n\n/*\n * Append string \"s\" to the stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffReadbuff(char_u *s)\n{\n    add_buff(&readbuf1, s, -1L);\n}\n\n/*\n * Append string \"s\" to the redo stuff buffer.\n * CSI and K_SPECIAL must already have been escaped.\n */\n    void\nstuffRedoReadbuff(char_u *s)\n{\n    add_buff(&readbuf2, s, -1L);\n}\n\n    static void\nstuffReadbuffLen(char_u *s, long len)\n{\n    add_buff(&readbuf1, s, len);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and\n * escaping other K_SPECIAL and CSI bytes.\n * Change CR, LF and ESC into a space.\n */\n    void\nstuffReadbuffSpec(char_u *s)\n{\n    int c;\n\n    while (*s != NUL)\n    {\n\tif (*s == K_SPECIAL && s[1] != NUL && s[2] != NUL)\n\t{\n\t    // Insert special key literally.\n\t    stuffReadbuffLen(s, 3L);\n\t    s += 3;\n\t}\n\telse\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (c == CAR || c == NL || c == ESC)\n\t\tc = ' ';\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n#endif\n\n/*\n * Append a character to the stuff buffer.\n * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.\n */\n    void\nstuffcharReadbuff(int c)\n{\n    add_char_buff(&readbuf1, c);\n}\n\n/*\n * Append a number to the stuff buffer.\n */\n    void\nstuffnumReadbuff(long n)\n{\n    add_num_buff(&readbuf1, n);\n}\n\n/*\n * Stuff a string into the typeahead buffer, such that edit() will insert it\n * literally (\"literally\" TRUE) or interpret is as typed characters.\n */\n    void\nstuffescaped(char_u *arg, int literally)\n{\n    int\t\tc;\n    char_u\t*start;\n\n    while (*arg != NUL)\n    {\n\t// Stuff a sequence of normal ASCII characters, that's fast.  Also\n\t// stuff K_SPECIAL to get the effect of a special key when \"literally\"\n\t// is TRUE.\n\tstart = arg;\n\twhile ((*arg >= ' ' && *arg < DEL)\n\t\t|| (*arg == K_SPECIAL && !literally))\n\t    ++arg;\n\tif (arg > start)\n\t    stuffReadbuffLen(start, (long)(arg - start));\n\n\t// stuff a single special character\n\tif (*arg != NUL)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&arg);\n\t    else\n\t\tc = *arg++;\n\t    if (literally && ((c < ' ' && c != TAB) || c == DEL))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n    }\n}\n\n/*\n * Read a character from the redo buffer.  Translates K_SPECIAL, CSI and\n * multibyte characters.\n * The redo buffer is left as it is.\n * If init is TRUE, prepare for redo, return FAIL if nothing to redo, OK\n * otherwise.\n * If old is TRUE, use old_redobuff instead of redobuff.\n */\n    static int\nread_redo(int init, int old_redo)\n{\n    static buffblock_T\t*bp;\n    static char_u\t*p;\n    int\t\t\tc;\n    int\t\t\tn;\n    char_u\t\tbuf[MB_MAXBYTES + 1];\n    int\t\t\ti;\n\n    if (init)\n    {\n\tif (old_redo)\n\t    bp = old_redobuff.bh_first.b_next;\n\telse\n\t    bp = redobuff.bh_first.b_next;\n\tif (bp == NULL)\n\t    return FAIL;\n\tp = bp->b_str;\n\treturn OK;\n    }\n    if ((c = *p) != NUL)\n    {\n\t// Reverse the conversion done by add_char_buff()\n\t// For a multi-byte character get all the bytes and return the\n\t// converted character.\n\tif (has_mbyte && (c != K_SPECIAL || p[1] == KS_SPECIAL))\n\t    n = MB_BYTE2LEN_CHECK(c);\n\telse\n\t    n = 1;\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (c == K_SPECIAL) // special key or escaped K_SPECIAL\n\t    {\n\t\tc = TO_SPECIAL(p[1], p[2]);\n\t\tp += 2;\n\t    }\n#ifdef FEAT_GUI\n\t    if (c == CSI)\t// escaped CSI\n\t\tp += 2;\n#endif\n\t    if (*++p == NUL && bp->b_next != NULL)\n\t    {\n\t\tbp = bp->b_next;\n\t\tp = bp->b_str;\n\t    }\n\t    buf[i] = c;\n\t    if (i == n - 1)\t// last byte of a character\n\t    {\n\t\tif (n != 1)\n\t\t    c = (*mb_ptr2char)(buf);\n\t\tbreak;\n\t    }\n\t    c = *p;\n\t    if (c == NUL)\t// cannot happen?\n\t\tbreak;\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Copy the rest of the redo buffer into the stuff buffer (in a slow way).\n * If old_redo is TRUE, use old_redobuff instead of redobuff.\n * The escaped K_SPECIAL and CSI are copied without translation.\n */\n    static void\ncopy_redo(int old_redo)\n{\n    int\t    c;\n\n    while ((c = read_redo(FALSE, old_redo)) != NUL)\n\tadd_char_buff(&readbuf2, c);\n}\n\n/*\n * Stuff the redo buffer into readbuf2.\n * Insert the redo count into the command.\n * If \"old_redo\" is TRUE, the last but one command is repeated\n * instead of the last command (inserting text). This is used for\n * CTRL-O <.> in insert mode\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo(long count, int old_redo)\n{\n    int\t    c;\n\n    // init the pointers; return if nothing to redo\n    if (read_redo(TRUE, old_redo) == FAIL)\n\treturn FAIL;\n\n    c = read_redo(FALSE, old_redo);\n\n#ifdef FEAT_EVAL\n    if (c == K_SID)\n    {\n\t// Copy the <SID>{sid}; sequence\n\tadd_char_buff(&readbuf2, c);\n\tfor (;;)\n\t{\n\t    c = read_redo(FALSE, old_redo);\n\t    add_char_buff(&readbuf2, c);\n\t    if (!isdigit(c))\n\t\tbreak;\n\t}\n\tc = read_redo(FALSE, old_redo);\n    }\n#endif\n\n    // copy the buffer name, if present\n    if (c == '\"')\n    {\n\tadd_buff(&readbuf2, (char_u *)\"\\\"\", 1L);\n\tc = read_redo(FALSE, old_redo);\n\n\t// if a numbered buffer is used, increment the number\n\tif (c >= '1' && c < '9')\n\t    ++c;\n\tadd_char_buff(&readbuf2, c);\n\n\t// the expression register should be re-evaluated\n\tif (c == '=')\n\t{\n\t    add_char_buff(&readbuf2, CAR);\n\t    cmd_silent = TRUE;\n\t}\n\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    if (c == 'v')   // redo Visual\n    {\n\tVIsual = curwin->w_cursor;\n\tVIsual_active = TRUE;\n\tVIsual_select = FALSE;\n\tVIsual_reselect = TRUE;\n\tredo_VIsual_busy = TRUE;\n\tc = read_redo(FALSE, old_redo);\n    }\n\n    // try to enter the count (in place of a previous count)\n    if (count)\n    {\n\twhile (VIM_ISDIGIT(c))\t// skip \"old\" count\n\t    c = read_redo(FALSE, old_redo);\n\tadd_num_buff(&readbuf2, count);\n    }\n\n    // copy the rest from the redo buffer into the stuff buffer\n    add_char_buff(&readbuf2, c);\n    copy_redo(old_redo);\n    return OK;\n}\n\n/*\n * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing\n * the redo buffer into readbuf2.\n * return FAIL for failure, OK otherwise\n */\n    int\nstart_redo_ins(void)\n{\n    int\t    c;\n\n    if (read_redo(TRUE, FALSE) == FAIL)\n\treturn FAIL;\n    start_stuff();\n\n    // skip the count and the command character\n    while ((c = read_redo(FALSE, FALSE)) != NUL)\n    {\n\tif (vim_strchr((char_u *)\"AaIiRrOo\", c) != NULL)\n\t{\n\t    if (c == 'O' || c == 'o')\n\t\tadd_buff(&readbuf2, NL_STR, -1L);\n\t    break;\n\t}\n    }\n\n    // copy the typed text from the redo buffer into the stuff buffer\n    copy_redo(FALSE);\n    block_redo = TRUE;\n    return OK;\n}\n\n    void\nstop_redo_ins(void)\n{\n    block_redo = FALSE;\n}\n\n/*\n * Initialize typebuf.tb_buf to point to typebuf_init.\n * alloc() cannot be used here: In out-of-memory situations it would\n * be impossible to type anything.\n */\n    static void\ninit_typebuf(void)\n{\n    if (typebuf.tb_buf != NULL)\n\treturn;\n\n    typebuf.tb_buf = typebuf_init;\n    typebuf.tb_noremap = noremapbuf_init;\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_len = 0;\n    typebuf.tb_off = MAXMAPLEN + 4;\n    typebuf.tb_change_cnt = 1;\n}\n\n/*\n * Returns TRUE when keys cannot be remapped.\n */\n    int\nnoremap_keys(void)\n{\n    return KeyNoremap & (RM_NONE|RM_SCRIPT);\n}\n\n/*\n * Insert a string in position 'offset' in the typeahead buffer (for \"@r\"\n * and \":normal\" command, vgetorpeek() and check_termcode()).\n *\n * If \"noremap\" is REMAP_YES, new string can be mapped again.\n * If \"noremap\" is REMAP_NONE, new string cannot be mapped again.\n * If \"noremap\" is REMAP_SKIP, first char of new string cannot be mapped again,\n * but abbreviations are allowed.\n * If \"noremap\" is REMAP_SCRIPT, new string cannot be mapped again, except for\n *\t\t\tscript-local mappings.\n * If \"noremap\" is > 0, that many characters of the new string cannot be mapped.\n *\n * If \"nottyped\" is TRUE, the string does not return KeyTyped (don't use when\n * \"offset\" is non-zero!).\n *\n * If \"silent\" is TRUE, cmd_silent is set when the characters are obtained.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nins_typebuf(\n    char_u\t*str,\n    int\t\tnoremap,\n    int\t\toffset,\n    int\t\tnottyped,\n    int\t\tsilent)\n{\n    char_u\t*s1, *s2;\n    int\t\tnewlen;\n    int\t\taddlen;\n    int\t\ti;\n    int\t\tnewoff;\n    int\t\tval;\n    int\t\tnrm;\n\n    init_typebuf();\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n    state_no_longer_safe(\"ins_typebuf()\");\n\n    addlen = (int)STRLEN(str);\n\n    if (offset == 0 && addlen <= typebuf.tb_off)\n    {\n\t/*\n\t * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]\n\t */\n\ttypebuf.tb_off -= addlen;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else if (typebuf.tb_len == 0 && typebuf.tb_buflen\n\t\t\t\t\t       >= addlen + 3 * (MAXMAPLEN + 4))\n    {\n\t/*\n\t * Buffer is empty and string fits in the existing buffer.\n\t * Leave some space before and after, if possible.\n\t */\n\ttypebuf.tb_off = (typebuf.tb_buflen - addlen - 3 * (MAXMAPLEN + 4)) / 2;\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);\n    }\n    else\n    {\n\tint extra;\n\n\t/*\n\t * Need to allocate a new buffer.\n\t * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)\n\t * characters.  We add some extra room to avoid having to allocate too\n\t * often.\n\t */\n\tnewoff = MAXMAPLEN + 4;\n\textra = addlen + newoff + 4 * (MAXMAPLEN + 4);\n\tif (typebuf.tb_len > 2147483647 - extra)\n\t{\n\t    // string is getting too long for a 32 bit int\n\t    emsg(_(e_command_too_complex));    // also calls flush_buffers\n\t    setcursor();\n\t    return FAIL;\n\t}\n\tnewlen = typebuf.tb_len + extra;\n\ts1 = alloc(newlen);\n\tif (s1 == NULL)\t\t    // out of memory\n\t    return FAIL;\n\ts2 = alloc(newlen);\n\tif (s2 == NULL)\t\t    // out of memory\n\t{\n\t    vim_free(s1);\n\t    return FAIL;\n\t}\n\ttypebuf.tb_buflen = newlen;\n\n\t// copy the old chars, before the insertion point\n\tmch_memmove(s1 + newoff, typebuf.tb_buf + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\t// copy the new chars\n\tmch_memmove(s1 + newoff + offset, str, (size_t)addlen);\n\t// copy the old chars, after the insertion point, including the\tNUL at\n\t// the end\n\tmch_memmove(s1 + newoff + offset + addlen,\n\t\t\t\t     typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\tif (typebuf.tb_buf != typebuf_init)\n\t    vim_free(typebuf.tb_buf);\n\ttypebuf.tb_buf = s1;\n\n\tmch_memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,\n\t\t\t\t\t\t\t      (size_t)offset);\n\tmch_memmove(s2 + newoff + offset + addlen,\n\t\t   typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n\tif (typebuf.tb_noremap != noremapbuf_init)\n\t    vim_free(typebuf.tb_noremap);\n\ttypebuf.tb_noremap = s2;\n\n\ttypebuf.tb_off = newoff;\n    }\n    typebuf.tb_len += addlen;\n\n    // If noremap == REMAP_SCRIPT: do remap script-local mappings.\n    if (noremap == REMAP_SCRIPT)\n\tval = RM_SCRIPT;\n    else if (noremap == REMAP_SKIP)\n\tval = RM_ABBR;\n    else\n\tval = RM_NONE;\n\n    /*\n     * Adjust typebuf.tb_noremap[] for the new characters:\n     * If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are\n     *\t\t\t(sometimes) not remappable\n     * If noremap == REMAP_YES: all the new characters are mappable\n     * If noremap  > 0: \"noremap\" characters are not remappable, the rest\n     *\t\t\tmappable\n     */\n    if (noremap == REMAP_SKIP)\n\tnrm = 1;\n    else if (noremap < 0)\n\tnrm = addlen;\n    else\n\tnrm = noremap;\n    for (i = 0; i < addlen; ++i)\n\ttypebuf.tb_noremap[typebuf.tb_off + i + offset] =\n\t\t\t\t\t\t  (--nrm >= 0) ? val : RM_YES;\n\n    // tb_maplen and tb_silent only remember the length of mapped and/or\n    // silent mappings at the start of the buffer, assuming that a mapped\n    // sequence doesn't result in typed characters.\n    if (nottyped || typebuf.tb_maplen > offset)\n\ttypebuf.tb_maplen += addlen;\n    if (silent || typebuf.tb_silent > offset)\n    {\n\ttypebuf.tb_silent += addlen;\n\tcmd_silent = TRUE;\n    }\n    if (typebuf.tb_no_abbr_cnt && offset == 0)\t// and not used for abbrev.s\n\ttypebuf.tb_no_abbr_cnt += addlen;\n\n    return OK;\n}\n\n/*\n * Put character \"c\" back into the typeahead buffer.\n * Can be used for a character obtained by vgetc() that needs to be put back.\n * Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to\n * the char.\n * Returns the length of what was inserted.\n */\n    int\nins_char_typebuf(int c, int modifiers)\n{\n    char_u\tbuf[MB_MAXBYTES * 3 + 4];\n    int\t\tlen = special_to_buf(c, modifiers, TRUE, buf);\n\n    buf[len] = NUL;\n    (void)ins_typebuf(buf, KeyNoremap, 0, !KeyTyped, cmd_silent);\n    return len;\n}\n\n/*\n * Return TRUE if the typeahead buffer was changed (while waiting for a\n * character to arrive).  Happens when a message was received from a client or\n * from feedkeys().\n * But check in a more generic way to avoid trouble: When \"typebuf.tb_buf\"\n * changed it was reallocated and the old pointer can no longer be used.\n * Or \"typebuf.tb_off\" may have been changed and we would overwrite characters\n * that was just added.\n */\n    int\ntypebuf_changed(\n    int\t\ttb_change_cnt)\t// old value of typebuf.tb_change_cnt\n{\n    return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n#endif\n\t   ));\n}\n\n/*\n * Return TRUE if there are no characters in the typeahead buffer that have\n * not been typed (result from a mapping or come from \":normal\").\n */\n    int\ntypebuf_typed(void)\n{\n    return typebuf.tb_maplen == 0;\n}\n\n/*\n * Return the number of characters that are mapped (or not typed).\n */\n    int\ntypebuf_maplen(void)\n{\n    return typebuf.tb_maplen;\n}\n\n/*\n * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]\n */\n    void\ndel_typebuf(int len, int offset)\n{\n    int\t    i;\n\n    if (len == 0)\n\treturn;\t\t// nothing to do\n\n    typebuf.tb_len -= len;\n\n    /*\n     * Easy case: Just increase typebuf.tb_off.\n     */\n    if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)\n\t\t\t\t\t\t\t >= 3 * MAXMAPLEN + 3)\n\ttypebuf.tb_off += len;\n    /*\n     * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]\n     */\n    else\n    {\n\ti = typebuf.tb_off + offset;\n\t/*\n\t * Leave some extra room at the end to avoid reallocation.\n\t */\n\tif (typebuf.tb_off > MAXMAPLEN)\n\t{\n\t    mch_memmove(typebuf.tb_buf + MAXMAPLEN,\n\t\t\t     typebuf.tb_buf + typebuf.tb_off, (size_t)offset);\n\t    mch_memmove(typebuf.tb_noremap + MAXMAPLEN,\n\t\t\t typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);\n\t    typebuf.tb_off = MAXMAPLEN;\n\t}\n\t// adjust typebuf.tb_buf (include the NUL at the end)\n\tmch_memmove(typebuf.tb_buf + typebuf.tb_off + offset,\n\t\t\t\t\t\t     typebuf.tb_buf + i + len,\n\t\t\t\t       (size_t)(typebuf.tb_len - offset + 1));\n\t// adjust typebuf.tb_noremap[]\n\tmch_memmove(typebuf.tb_noremap + typebuf.tb_off + offset,\n\t\t\t\t\t\t typebuf.tb_noremap + i + len,\n\t\t\t\t\t   (size_t)(typebuf.tb_len - offset));\n    }\n\n    if (typebuf.tb_maplen > offset)\t\t// adjust tb_maplen\n    {\n\tif (typebuf.tb_maplen < offset + len)\n\t    typebuf.tb_maplen = offset;\n\telse\n\t    typebuf.tb_maplen -= len;\n    }\n    if (typebuf.tb_silent > offset)\t\t// adjust tb_silent\n    {\n\tif (typebuf.tb_silent < offset + len)\n\t    typebuf.tb_silent = offset;\n\telse\n\t    typebuf.tb_silent -= len;\n    }\n    if (typebuf.tb_no_abbr_cnt > offset)\t// adjust tb_no_abbr_cnt\n    {\n\tif (typebuf.tb_no_abbr_cnt < offset + len)\n\t    typebuf.tb_no_abbr_cnt = offset;\n\telse\n\t    typebuf.tb_no_abbr_cnt -= len;\n    }\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    // Reset the flag that text received from a client or from feedkeys()\n    // was inserted in the typeahead buffer.\n    typebuf_was_filled = FALSE;\n#endif\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n}\n\n/*\n * Write typed characters to script file.\n * If recording is on put the character in the recordbuffer.\n */\n    static void\ngotchars(char_u *chars, int len)\n{\n    char_u\t\t*s = chars;\n    int\t\t\ti;\n    static char_u\tbuf[4];\n    static int\t\tbuflen = 0;\n    int\t\t\ttodo = len;\n\n    while (todo--)\n    {\n\tbuf[buflen++] = *s++;\n\n\t// When receiving a special key sequence, store it until we have all\n\t// the bytes and we can decide what to do with it.\n\tif (buflen == 1 && buf[0] == K_SPECIAL)\n\t    continue;\n\tif (buflen == 2)\n\t    continue;\n\tif (buflen == 3 && buf[1] == KS_EXTRA\n\t\t       && (buf[2] == KE_FOCUSGAINED || buf[2] == KE_FOCUSLOST))\n\t{\n\t    // Drop K_FOCUSGAINED and K_FOCUSLOST, they are not useful in a\n\t    // recording.\n\t    buflen = 0;\n\t    continue;\n\t}\n\n\t// Handle one byte at a time; no translation to be done.\n\tfor (i = 0; i < buflen; ++i)\n\t    updatescript(buf[i]);\n\n\tif (reg_recording != 0)\n\t{\n\t    buf[buflen] = NUL;\n\t    add_buff(&recordbuff, buf, (long)buflen);\n\t    // remember how many chars were last recorded\n\t    last_recorded_len += buflen;\n\t}\n\tbuflen = 0;\n    }\n    may_sync_undo();\n\n#ifdef FEAT_EVAL\n    // output \"debug mode\" message next time in debug mode\n    debug_did_msg = FALSE;\n#endif\n\n    // Since characters have been typed, consider the following to be in\n    // another mapping.  Search string will be kept in history.\n    ++maptick;\n}\n\n/*\n * Undo the last gotchars() for \"len\" bytes.  To be used when putting a typed\n * character back into the typeahead buffer, thus gotchars() will be called\n * again.\n * Only affects recorded characters.\n */\n    void\nungetchars(int len)\n{\n    if (reg_recording == 0)\n\treturn;\n\n    delete_buff_tail(&recordbuff, len);\n    last_recorded_len -= len;\n}\n\n/*\n * Sync undo.  Called when typed characters are obtained from the typeahead\n * buffer, or when a menu is used.\n * Do not sync:\n * - In Insert mode, unless cursor key has been used.\n * - While reading a script file.\n * - When no_u_sync is non-zero.\n */\n    static void\nmay_sync_undo(void)\n{\n    if ((!(State & (MODE_INSERT | MODE_CMDLINE)) || arrow_used)\n\t\t\t\t\t       && scriptin[curscript] == NULL)\n\tu_sync(FALSE);\n}\n\n/*\n * Make \"typebuf\" empty and allocate new buffers.\n * Returns FAIL when out of memory.\n */\n    static int\nalloc_typebuf(void)\n{\n    typebuf.tb_buf = alloc(TYPELEN_INIT);\n    typebuf.tb_noremap = alloc(TYPELEN_INIT);\n    if (typebuf.tb_buf == NULL || typebuf.tb_noremap == NULL)\n    {\n\tfree_typebuf();\n\treturn FAIL;\n    }\n    typebuf.tb_buflen = TYPELEN_INIT;\n    typebuf.tb_off = MAXMAPLEN + 4;  // can insert without realloc\n    typebuf.tb_len = 0;\n    typebuf.tb_maplen = 0;\n    typebuf.tb_silent = 0;\n    typebuf.tb_no_abbr_cnt = 0;\n    if (++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n    typebuf_was_filled = FALSE;\n#endif\n    return OK;\n}\n\n/*\n * Free the buffers of \"typebuf\".\n */\n    static void\nfree_typebuf(void)\n{\n    if (typebuf.tb_buf == typebuf_init)\n\tinternal_error(\"Free typebuf 1\");\n    else\n\tVIM_CLEAR(typebuf.tb_buf);\n    if (typebuf.tb_noremap == noremapbuf_init)\n\tinternal_error(\"Free typebuf 2\");\n    else\n\tVIM_CLEAR(typebuf.tb_noremap);\n}\n\n/*\n * When doing \":so! file\", the current typeahead needs to be saved, and\n * restored when \"file\" has been read completely.\n */\nstatic typebuf_T saved_typebuf[NSCRIPT];\n\n    int\nsave_typebuf(void)\n{\n    init_typebuf();\n    saved_typebuf[curscript] = typebuf;\n    // If out of memory: restore typebuf and close file.\n    if (alloc_typebuf() == FAIL)\n    {\n\tclosescript();\n\treturn FAIL;\n    }\n    return OK;\n}\n\nstatic int old_char = -1;\t// character put back by vungetc()\nstatic int old_mod_mask;\t// mod_mask for ungotten character\nstatic int old_mouse_row;\t// mouse_row related to old_char\nstatic int old_mouse_col;\t// mouse_col related to old_char\nstatic int old_KeyStuffed;\t// whether old_char was stuffed\n\nstatic int can_get_old_char(void)\n{\n    // If the old character was not stuffed and characters have been added to\n    // the stuff buffer, need to first get the stuffed characters instead.\n    return old_char != -1 && (old_KeyStuffed || stuff_empty());\n}\n\n/*\n * Save all three kinds of typeahead, so that the user must type at a prompt.\n */\n    void\nsave_typeahead(tasave_T *tp)\n{\n    tp->save_typebuf = typebuf;\n    tp->typebuf_valid = (alloc_typebuf() == OK);\n    if (!tp->typebuf_valid)\n\ttypebuf = tp->save_typebuf;\n\n    tp->old_char = old_char;\n    tp->old_mod_mask = old_mod_mask;\n    old_char = -1;\n\n    tp->save_readbuf1 = readbuf1;\n    readbuf1.bh_first.b_next = NULL;\n    tp->save_readbuf2 = readbuf2;\n    readbuf2.bh_first.b_next = NULL;\n# ifdef USE_INPUT_BUF\n    tp->save_inputbuf = get_input_buf();\n# endif\n}\n\n/*\n * Restore the typeahead to what it was before calling save_typeahead().\n * The allocated memory is freed, can only be called once!\n * When \"overwrite\" is FALSE input typed later is kept.\n */\n    void\nrestore_typeahead(tasave_T *tp, int overwrite UNUSED)\n{\n    if (tp->typebuf_valid)\n    {\n\tfree_typebuf();\n\ttypebuf = tp->save_typebuf;\n    }\n\n    old_char = tp->old_char;\n    old_mod_mask = tp->old_mod_mask;\n\n    free_buff(&readbuf1);\n    readbuf1 = tp->save_readbuf1;\n    free_buff(&readbuf2);\n    readbuf2 = tp->save_readbuf2;\n# ifdef USE_INPUT_BUF\n    set_input_buf(tp->save_inputbuf, overwrite);\n# endif\n}\n\n/*\n * Open a new script file for the \":source!\" command.\n */\n    void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t// when TRUE execute directly\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_scripts_nested_too_deep));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t// Not reading from script, also don't open one.  Warning message?\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t// already reading script\n\t++curscript;\n\t\t\t\t// use NameBuff for expanded name\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = MODE_NORMAL;\n\tmsg_scroll = FALSE;\t// no msg scrolling in Normal mode\n\trestart_edit = 0;\t// don't go to Insert mode\n\tp_im = FALSE;\t\t// don't use 'insertmode'\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    (void)vpeekc();\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}\n\n/*\n * Close the currently active input script.\n */\n    static void\nclosescript(void)\n{\n    free_typebuf();\n    typebuf = saved_typebuf[curscript];\n\n    fclose(scriptin[curscript]);\n    scriptin[curscript] = NULL;\n    if (curscript > 0)\n\t--curscript;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclose_all_scripts(void)\n{\n    while (scriptin[0] != NULL)\n\tclosescript();\n}\n#endif\n\n/*\n * Return TRUE when reading keys from a script file.\n */\n    int\nusing_script(void)\n{\n    return scriptin[curscript] != NULL;\n}\n\n/*\n * This function is called just before doing a blocking wait.  Thus after\n * waiting 'updatetime' for a character to arrive.\n */\n    void\nbefore_blocking(void)\n{\n    updatescript(0);\n#ifdef FEAT_EVAL\n    if (may_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n}\n\n/*\n * updatescript() is called when a character can be written into the script\n * file or when we have waited some time for a character (c == 0)\n *\n * All the changed memfiles are synced if c == 0 or when the number of typed\n * characters reaches 'updatecount' and 'updatecount' is non-zero.\n */\n    static void\nupdatescript(int c)\n{\n    static int\t    count = 0;\n\n    if (c && scriptout)\n\tputc(c, scriptout);\n    if (c == 0 || (p_uc > 0 && ++count >= p_uc))\n    {\n\tml_sync_all(c == 0, TRUE);\n\tcount = 0;\n    }\n}\n\n/*\n * Convert \"c\" plus \"modifiers\" to merge the effect of modifyOtherKeys into the\n * character.\n */\n    int\nmerge_modifyOtherKeys(int c_arg, int *modifiers)\n{\n    int c = c_arg;\n\n    if (*modifiers & MOD_MASK_CTRL)\n    {\n\tif ((c >= '`' && c <= 0x7f) || (c >= '@' && c <= '_'))\n\t{\n\t    c &= 0x1f;\n\t    if (c == NUL)\n\t\tc = K_ZERO;\n\t}\n\telse if (c == '6')\n\t    // CTRL-6 is equivalent to CTRL-^\n\t    c = 0x1e;\n#ifdef FEAT_GUI_GTK\n\t// These mappings look arbitrary at the first glance, but in fact\n\t// resemble quite exactly the behaviour of the GTK+ 1.2 GUI on my\n\t// machine.  The only difference is BS vs. DEL for CTRL-8 (makes\n\t// more sense and is consistent with usual terminal behaviour).\n\telse if (c == '2')\n\t    c = NUL;\n\telse if (c >= '3' && c <= '7')\n\t    c = c ^ 0x28;\n\telse if (c == '8')\n\t    c = BS;\n\telse if (c == '?')\n\t    c = DEL;\n#endif\n\tif (c != c_arg)\n\t    *modifiers &= ~MOD_MASK_CTRL;\n    }\n    if ((*modifiers & (MOD_MASK_META | MOD_MASK_ALT))\n\t    && c >= 0 && c <= 127)\n    {\n\tc += 0x80;\n\t*modifiers &= ~(MOD_MASK_META | MOD_MASK_ALT);\n    }\n    return c;\n}\n\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n    int\t\tc, c2;\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n\n#ifdef FEAT_EVAL\n    // Do garbage collection when garbagecollect() was called previously and\n    // we are now at the toplevel.\n    if (may_garbage_collect && want_garbage_collect)\n\tgarbage_collect(FALSE);\n#endif\n\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (can_get_old_char())\n    {\n\tc = old_char;\n\told_char = -1;\n\tmod_mask = old_mod_mask;\n\tmouse_row = old_mouse_row;\n\tmouse_col = old_mouse_col;\n    }\n    else\n    {\n\t// number of characters recorded from the last vgetc() call\n\tstatic int\tlast_vgetc_recorded_len = 0;\n\n\tmod_mask = 0;\n\tvgetc_mod_mask = 0;\n\tvgetc_char = 0;\n\n\t// last_recorded_len can be larger than last_vgetc_recorded_len\n\t// if peeking records more\n\tlast_recorded_len -= last_vgetc_recorded_len;\n\n\tfor (;;)\t\t// this is done twice if there are modifiers\n\t{\n\t    int did_inc = FALSE;\n\n\t    // No mapping after modifier has been read, using an input method\n\t    // and when a popup window has disabled mapping.\n\t    if (mod_mask\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t\t    || im_is_preediting()\n#endif\n#if defined(FEAT_PROP_POPUP)\n\t\t    || popup_no_mapping()\n#endif\n\t\t    )\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\t// mod_mask value may change, remember we did the increment\n\t\tdid_inc = TRUE;\n\t    }\n\t    c = vgetorpeek(TRUE);\n\t    if (did_inc)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\n\t    // Get two extra bytes for special keys, handle modifiers.\n\t    if (c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || c == CSI\n#endif\n\t       )\n\t    {\n\t\tint\t    save_allow_keys = allow_keys;\n\n\t\t++no_mapping;\n\t\tallow_keys = 0;\t\t// make sure BS is not found\n\t\tc2 = vgetorpeek(TRUE);\t// no mapping for these chars\n\t\tc = vgetorpeek(TRUE);\n\t\t--no_mapping;\n\t\tallow_keys = save_allow_keys;\n\t\tif (c2 == KS_MODIFIER)\n\t\t{\n\t\t    mod_mask = c;\n\t\t    continue;\n\t\t}\n\t\tc = TO_SPECIAL(c2, c);\n\n\t\t// K_ESC is used to avoid ambiguity with the single Esc\n\t\t// character that might be the start of an escape sequence.\n\t\t// Convert it back to a single Esc here.\n\t\tif (c == K_ESC)\n\t\t    c = ESC;\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n\t\t// Handle K_TEAROFF here, the caller of vgetc() doesn't need to\n\t\t// know that a menu was torn off\n\t\tif (\n# ifdef VIMDLL\n\t\t    gui.in_use &&\n# endif\n\t\t    c == K_TEAROFF)\n\t\t{\n\t\t    char_u\tname[200];\n\t\t    int\t\tj;\n\n\t\t    // get menu path, it ends with a <CR>\n\t\t    for (j = 0; (c = vgetorpeek(TRUE)) != '\\r'; )\n\t\t    {\n\t\t\tname[j] = c;\n\t\t\tif (j < 199)\n\t\t\t    ++j;\n\t\t    }\n\t\t    name[j] = NUL;\n\t\t    gui_make_tearoff(name);\n\t\t    continue;\n\t\t}\n#endif\n#if defined(FEAT_GUI) && defined(FEAT_GUI_GTK) && defined(FEAT_MENU)\n\t\t// GTK: <F10> normally selects the menu, but it's passed until\n\t\t// here to allow mapping it.  Intercept and invoke the GTK\n\t\t// behavior if it's not mapped.\n\t\tif (c == K_F10 && gui.menubar != NULL)\n\t\t{\n\t\t    gtk_menu_shell_select_first(\n\t\t\t\t\t   GTK_MENU_SHELL(gui.menubar), FALSE);\n\t\t    continue;\n\t\t}\n#endif\n#ifdef FEAT_GUI\n\t\t// Handle focus event here, so that the caller doesn't need to\n\t\t// know about it.  Return K_IGNORE so that we loop once (needed\n\t\t// if 'lazyredraw' is set).\n\t\tif (c == K_FOCUSGAINED || c == K_FOCUSLOST)\n\t\t{\n\t\t    ui_focus_change(c == K_FOCUSGAINED);\n\t\t    c = K_IGNORE;\n\t\t}\n\n\t\t// Translate K_CSI to CSI.  The special key is only used to\n\t\t// avoid it being recognized as the start of a special key.\n\t\tif (c == K_CSI)\n\t\t    c = CSI;\n#endif\n#ifdef FEAT_EVAL\n\t\tif (c == K_SID)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // Handle <SID>{sid};  Do up to 20 digits for safety.\n\t\t    last_used_sid = 0;\n\t\t    for (j = 0; j < 20 && isdigit(c = vgetorpeek(TRUE)); ++j)\n\t\t\tlast_used_sid = last_used_sid * 10 + (c - '0');\n\t\t    last_used_map = NULL;\n\t\t    continue;\n\t\t}\n#endif\n\t    }\n\n\t    // a keypad or special function key was not mapped, use it like\n\t    // its ASCII equivalent\n\t    switch (c)\n\t    {\n\t\tcase K_KPLUS:\tc = '+'; break;\n\t\tcase K_KMINUS:\tc = '-'; break;\n\t\tcase K_KDIVIDE:\tc = '/'; break;\n\t\tcase K_KMULTIPLY: c = '*'; break;\n\t\tcase K_KENTER:\tc = CAR; break;\n\t\tcase K_KPOINT:\n#ifdef MSWIN\n\t\t\t\t// Can be either '.' or a ',',\n\t\t\t\t// depending on the type of keypad.\n\t\t\t\tc = MapVirtualKey(VK_DECIMAL, 2); break;\n#else\n\t\t\t\tc = '.'; break;\n#endif\n\t\tcase K_K0:\tc = '0'; break;\n\t\tcase K_K1:\tc = '1'; break;\n\t\tcase K_K2:\tc = '2'; break;\n\t\tcase K_K3:\tc = '3'; break;\n\t\tcase K_K4:\tc = '4'; break;\n\t\tcase K_K5:\tc = '5'; break;\n\t\tcase K_K6:\tc = '6'; break;\n\t\tcase K_K7:\tc = '7'; break;\n\t\tcase K_K8:\tc = '8'; break;\n\t\tcase K_K9:\tc = '9'; break;\n\n\t\tcase K_XHOME:\n\t\tcase K_ZHOME:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_HOME;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_HOME;\n\t\t\t\tbreak;\n\t\tcase K_XEND:\n\t\tcase K_ZEND:\tif (mod_mask == MOD_MASK_SHIFT)\n\t\t\t\t{\n\t\t\t\t    c = K_S_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse if (mod_mask == MOD_MASK_CTRL)\n\t\t\t\t{\n\t\t\t\t    c = K_C_END;\n\t\t\t\t    mod_mask = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    c = K_END;\n\t\t\t\tbreak;\n\n\t\tcase K_XUP:\tc = K_UP; break;\n\t\tcase K_XDOWN:\tc = K_DOWN; break;\n\t\tcase K_XLEFT:\tc = K_LEFT; break;\n\t\tcase K_XRIGHT:\tc = K_RIGHT; break;\n\t    }\n\n\t    // For a multi-byte character get all the bytes and return the\n\t    // converted character.\n\t    // Note: This will loop until enough bytes are received!\n\t    if (has_mbyte && (n = MB_BYTE2LEN_CHECK(c)) > 1)\n\t    {\n\t\t++no_mapping;\n\t\tbuf[0] = c;\n\t\tfor (i = 1; i < n; ++i)\n\t\t{\n\t\t    buf[i] = vgetorpeek(TRUE);\n\t\t    if (buf[i] == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t\t    || (buf[i] == CSI)\n#endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER\n\t\t\t// sequence, which represents a K_SPECIAL (0x80),\n\t\t\t// or a CSI - KS_EXTRA - KE_CSI sequence, which\n\t\t\t// represents a CSI (0x9B),\n\t\t\t// or a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI\n\t\t\t// too.\n\t\t\tc = vgetorpeek(TRUE);\n\t\t\tif (vgetorpeek(TRUE) == KE_CSI && c == KS_EXTRA)\n\t\t\t    buf[i] = CSI;\n\t\t    }\n\t\t}\n\t\t--no_mapping;\n\t\tc = (*mb_ptr2char)(buf);\n\t    }\n\n\t    if (vgetc_char == 0)\n\t    {\n\t\tvgetc_mod_mask = mod_mask;\n\t\tvgetc_char = c;\n\t    }\n\n\t    break;\n\t}\n\n\tlast_vgetc_recorded_len = last_recorded_len;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * In the main loop \"may_garbage_collect\" can be set to do garbage\n     * collection in the first next vgetc().  It's disabled after that to\n     * avoid internally used Lists and Dicts to be freed.\n     */\n    may_garbage_collect = FALSE;\n#endif\n\n#ifdef FEAT_BEVAL_TERM\n    if (c != K_MOUSEMOVE && c != K_IGNORE && c != K_CURSORHOLD)\n    {\n\t// Don't trigger 'balloonexpr' unless only the mouse was moved.\n\tbevalexpr_due_set = FALSE;\n\tui_remove_balloon();\n    }\n#endif\n#ifdef FEAT_PROP_POPUP\n    // Only filter keys that do not come from \":normal\".  Keys from feedkeys()\n    // are filtered.\n    if ((!ex_normal_busy || in_feedkeys) && popup_do_filter(c))\n    {\n\tif (c == Ctrl_C)\n\t    got_int = FALSE;  // avoid looping\n\tc = K_IGNORE;\n    }\n#endif\n\n    // Need to process the character before we know it's safe to do something\n    // else.\n    if (c != K_IGNORE)\n\tstate_no_longer_safe(\"key typed\");\n\n    return c;\n}\n\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int\tc;\n\n    c = vgetc();\n    if (c == NUL)\n\tc = get_keystroke();\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n * Does not handle bracketed paste - do not use the result for commands.\n */\n    static int\nplain_vgetc_nopaste(void)\n{\n    int c;\n\n    do\n\tc = safe_vgetc();\n    while (c == K_IGNORE\n\t    || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n\t    || c == K_MOUSEMOVE);\n    return c;\n}\n\n/*\n * Like safe_vgetc(), but loop to handle K_IGNORE.\n * Also ignore scrollbar events.\n */\n    int\nplain_vgetc(void)\n{\n    int c = plain_vgetc_nopaste();\n\n    if (c == K_PS)\n\t// Only handle the first pasted character.  Drop the rest, since we\n\t// don't know what to do with it.\n\tc = bracketed_paste(PASTE_ONE_CHAR, FALSE, NULL);\n\n    return c;\n}\n\n/*\n * Check if a character is available, such that vgetc() will not block.\n * If the next character is a special character or multi-byte, the returned\n * character is not valid!.\n * Returns NUL if no character is available.\n */\n    int\nvpeekc(void)\n{\n    if (can_get_old_char())\n\treturn old_char;\n    return vgetorpeek(FALSE);\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Like vpeekc(), but don't allow mapping.  Do allow checking for terminal\n * codes.\n */\n    int\nvpeekc_nomap(void)\n{\n    int\t\tc;\n\n    ++no_mapping;\n    ++allow_keys;\n    c = vpeekc();\n    --no_mapping;\n    --allow_keys;\n    return c;\n}\n#endif\n\n/*\n * Check if any character is available, also half an escape sequence.\n * Trick: when no typeahead found, but there is something in the typeahead\n * buffer, it must be an ESC that is recognized as the start of a key code.\n */\n    int\nvpeekc_any(void)\n{\n    int\t\tc;\n\n    c = vpeekc();\n    if (c == NUL && typebuf.tb_len > 0)\n\tc = ESC;\n    return c;\n}\n\n/*\n * Call vpeekc() without causing anything to be mapped.\n * Return TRUE if a character is available, FALSE otherwise.\n */\n    int\nchar_avail(void)\n{\n    int\t    retval;\n\n#ifdef FEAT_EVAL\n    // When test_override(\"char_avail\", 1) was called pretend there is no\n    // typeahead.\n    if (disable_char_avail_for_testing)\n\treturn FALSE;\n#endif\n    ++no_mapping;\n    retval = vpeekc();\n    --no_mapping;\n    return (retval != NUL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getchar()\" and \"getcharstr()\" functions\n */\n    static void\ngetchar_common(typval_T *argvars, typval_T *rettv)\n{\n    varnumber_T\t\tn;\n    int\t\t\terror = FALSE;\n\n    if (in_vim9script() && check_for_opt_bool_arg(argvars, 0) == FAIL)\n\treturn;\n\n#ifdef MESSAGE_QUEUE\n    // vpeekc() used to check for messages, but that caused problems, invoking\n    // a callback where it was not expected.  Some plugins use getchar(1) in a\n    // loop to await a message, therefore make sure we check for messages here.\n    parse_queued_messages();\n#endif\n\n    // Position the cursor.  Needed after a message that ends in a space.\n    windgoto(msg_row, msg_col);\n\n    ++no_mapping;\n    ++allow_keys;\n    for (;;)\n    {\n\tif (argvars[0].v_type == VAR_UNKNOWN)\n\t    // getchar(): blocking wait.\n\t    n = plain_vgetc_nopaste();\n\telse if (tv_get_bool_chk(&argvars[0], &error))\n\t    // getchar(1): only check if char avail\n\t    n = vpeekc_any();\n\telse if (error || vpeekc_any() == NUL)\n\t    // illegal argument or getchar(0) and no char avail: return zero\n\t    n = 0;\n\telse\n\t    // getchar(0) and char avail() != NUL: get a character.\n\t    // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.\n\t    n = safe_vgetc();\n\n\tif (n == K_IGNORE || n == K_MOUSEMOVE\n\t\t|| n == K_VER_SCROLLBAR || n == K_HOR_SCROLLBAR)\n\t    continue;\n\tbreak;\n    }\n    --no_mapping;\n    --allow_keys;\n\n    set_vim_var_nr(VV_MOUSE_WIN, 0);\n    set_vim_var_nr(VV_MOUSE_WINID, 0);\n    set_vim_var_nr(VV_MOUSE_LNUM, 0);\n    set_vim_var_nr(VV_MOUSE_COL, 0);\n\n    rettv->vval.v_number = n;\n    if (n != 0 && (IS_SPECIAL(n) || mod_mask != 0))\n    {\n\tchar_u\t\ttemp[10];   // modifier: 3, mbyte-char: 6, NUL: 1\n\tint\t\ti = 0;\n\n\t// Turn a special key into three bytes, plus modifier.\n\tif (mod_mask != 0)\n\t{\n\t    temp[i++] = K_SPECIAL;\n\t    temp[i++] = KS_MODIFIER;\n\t    temp[i++] = mod_mask;\n\t}\n\tif (IS_SPECIAL(n))\n\t{\n\t    temp[i++] = K_SPECIAL;\n\t    temp[i++] = K_SECOND(n);\n\t    temp[i++] = K_THIRD(n);\n\t}\n\telse if (has_mbyte)\n\t    i += (*mb_char2bytes)(n, temp + i);\n\telse\n\t    temp[i++] = n;\n\ttemp[i++] = NUL;\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = vim_strsave(temp);\n\n\tif (is_mouse_key(n))\n\t{\n\t    int\t\trow = mouse_row;\n\t    int\t\tcol = mouse_col;\n\t    win_T\t*win;\n\t    linenr_T\tlnum;\n\t    win_T\t*wp;\n\t    int\t\twinnr = 1;\n\n\t    if (row >= 0 && col >= 0)\n\t    {\n\t\t// Find the window at the mouse coordinates and compute the\n\t\t// text position.\n\t\twin = mouse_find_win(&row, &col, FIND_POPUP);\n\t\tif (win == NULL)\n\t\t    return;\n\t\t(void)mouse_comp_pos(win, &row, &col, &lnum, NULL);\n#ifdef FEAT_PROP_POPUP\n\t\tif (WIN_IS_POPUP(win))\n\t\t    winnr = 0;\n\t\telse\n#endif\n\t\t    for (wp = firstwin; wp != win && wp != NULL;\n\t\t\t\t\t\t\t       wp = wp->w_next)\n\t\t\t++winnr;\n\t\tset_vim_var_nr(VV_MOUSE_WIN, winnr);\n\t\tset_vim_var_nr(VV_MOUSE_WINID, win->w_id);\n\t\tset_vim_var_nr(VV_MOUSE_LNUM, lnum);\n\t\tset_vim_var_nr(VV_MOUSE_COL, col + 1);\n\t    }\n\t}\n    }\n}\n\n/*\n * \"getchar()\" function\n */\n    void\nf_getchar(typval_T *argvars, typval_T *rettv)\n{\n    getchar_common(argvars, rettv);\n}\n\n/*\n * \"getcharstr()\" function\n */\n    void\nf_getcharstr(typval_T *argvars, typval_T *rettv)\n{\n    getchar_common(argvars, rettv);\n\n    if (rettv->v_type != VAR_NUMBER)\n\treturn;\n\n    char_u\t\ttemp[7];   // mbyte-char: 6, NUL: 1\n    varnumber_T\tn = rettv->vval.v_number;\n    int\t\ti = 0;\n\n    if (n != 0)\n    {\n\tif (has_mbyte)\n\t    i += (*mb_char2bytes)(n, temp + i);\n\telse\n\t    temp[i++] = n;\n    }\n    temp[i++] = NUL;\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_strsave(temp);\n}\n\n/*\n * \"getcharmod()\" function\n */\n    void\nf_getcharmod(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->vval.v_number = mod_mask;\n}\n#endif // FEAT_EVAL\n\n#if defined(MESSAGE_QUEUE) || defined(PROTO)\n# define MAX_REPEAT_PARSE 8\n\n/*\n * Process messages that have been queued for netbeans or clientserver.\n * Also check if any jobs have ended.\n * These functions can call arbitrary Vim script and should only be called when\n * it is safe to do so.\n */\n    void\nparse_queued_messages(void)\n{\n    int\t    old_curwin_id;\n    int\t    old_curbuf_fnum;\n    int\t    i;\n    int\t    save_may_garbage_collect = may_garbage_collect;\n    static int entered = 0;\n    int\t    was_safe = get_was_safe_state();\n\n    // Do not handle messages while redrawing, because it may cause buffers to\n    // change or be wiped while they are being redrawn.\n    // Also bail out when parsing messages was explicitly disabled.\n    if (updating_screen || dont_parse_messages)\n\treturn;\n\n    // If memory allocation fails during startup we'll exit but curbuf or\n    // curwin could be NULL.\n    if (curbuf == NULL || curwin == NULL)\n       return;\n\n    old_curbuf_fnum = curbuf->b_fnum;\n    old_curwin_id = curwin->w_id;\n\n    ++entered;\n\n    // may_garbage_collect is set in main_loop() to do garbage collection when\n    // blocking to wait on a character.  We don't want that while parsing\n    // messages, a callback may invoke vgetc() while lists and dicts are in use\n    // in the call stack.\n    may_garbage_collect = FALSE;\n\n    // Loop when a job ended, but don't keep looping forever.\n    for (i = 0; i < MAX_REPEAT_PARSE; ++i)\n    {\n\t// For Win32 mch_breakcheck() does not check for input, do it here.\n# if (defined(MSWIN) || defined(__HAIKU__)) && defined(FEAT_JOB_CHANNEL)\n\tchannel_handle_events(FALSE);\n# endif\n\n# ifdef FEAT_NETBEANS_INTG\n\t// Process the queued netbeans messages.\n\tnetbeans_parse_messages();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n\t// Write any buffer lines still to be written.\n\tchannel_write_any_lines();\n\n\t// Process the messages queued on channels.\n\tchannel_parse_messages();\n# endif\n# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\n\t// Process the queued clientserver messages.\n\tserver_parse_messages();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n\t// Check if any jobs have ended.  If so, repeat the above to handle\n\t// changes, e.g. stdin may have been closed.\n\tif (job_check_ended())\n\t    continue;\n# endif\n# ifdef FEAT_TERMINAL\n\tfree_unused_terminals();\n# endif\n\n# ifdef FEAT_SOUND_MACOSX\n\tprocess_cfrunloop();\n# endif\n# ifdef FEAT_SOUND_CANBERRA\n\tif (has_sound_callback_in_queue())\n\t    invoke_sound_callback();\n# endif\n#ifdef SIGUSR1\n\tif (got_sigusr1)\n\t{\n\t    apply_autocmds(EVENT_SIGUSR1, NULL, NULL, FALSE, curbuf);\n\t    got_sigusr1 = FALSE;\n\t}\n#endif\n\tbreak;\n    }\n\n    // When not nested we'll go back to waiting for a typed character.  If it\n    // was safe before then this triggers a SafeStateAgain autocommand event.\n    if (entered == 1 && was_safe)\n\tmay_trigger_safestateagain();\n\n    may_garbage_collect = save_may_garbage_collect;\n\n    // If the current window or buffer changed we need to bail out of the\n    // waiting loop.  E.g. when a job exit callback closes the terminal window.\n    if (curwin->w_id != old_curwin_id || curbuf->b_fnum != old_curbuf_fnum)\n\tins_char_typebuf(K_IGNORE, 0);\n\n    --entered;\n}\n#endif\n\n\ntypedef enum {\n    map_result_fail,    // failed, break loop\n    map_result_get,     // get a character from typeahead\n    map_result_retry,   // try to map again\n    map_result_nomatch  // no matching mapping, get char\n} map_result_T;\n\n/*\n * Check if the bytes at the start of the typeahead buffer are a character used\n * in Insert mode completion.  This includes the form with a CTRL modifier.\n */\n    static int\nat_ins_compl_key(void)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    c = *p;\n\n    if (typebuf.tb_len > 3\n\t    && (c == K_SPECIAL || c == CSI)  // CSI is used by the GUI\n\t    && p[1] == KS_MODIFIER\n\t    && (p[2] & MOD_MASK_CTRL))\n\tc = p[3] & 0x1f;\n    return (ctrl_x_mode_not_default() && vim_is_ctrl_x_key(c))\n\t\t|| (compl_status_local() && (c == Ctrl_N || c == Ctrl_P));\n}\n\n/*\n * Check if typebuf.tb_buf[] contains a modifier plus key that can be changed\n * into just a key, apply that.\n * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off\n * + \"max_offset\"].\n * Return the length of the replaced bytes, 0 if nothing changed, -1 for error.\n */\n    static int\ncheck_simplify_modifier(int max_offset)\n{\n    int\t\toffset;\n    char_u\t*tp;\n\n    for (offset = 0; offset < max_offset; ++offset)\n    {\n\tif (offset + 3 >= typebuf.tb_len)\n\t    break;\n\ttp = typebuf.tb_buf + typebuf.tb_off + offset;\n\tif ((tp[0] == K_SPECIAL || tp[0] == CSI) && tp[1] == KS_MODIFIER)\n\t{\n\t    // A modifier was not used for a mapping, apply it to ASCII keys.\n\t    // Shift would already have been applied.\n\t    int modifier = tp[2];\n\t    int\tc = tp[3];\n\t    int new_c = merge_modifyOtherKeys(c, &modifier);\n\n\t    if (new_c != c)\n\t    {\n\t\tchar_u\tnew_string[MB_MAXBYTES];\n\t\tint\tlen;\n\n\t\tif (offset == 0)\n\t\t{\n\t\t    // At the start: remember the character and mod_mask before\n\t\t    // merging, in some cases, e.g. at the hit-return prompt,\n\t\t    // they are put back in the typeahead buffer.\n\t\t    vgetc_char = c;\n\t\t    vgetc_mod_mask = tp[2];\n\t\t}\n\t\tif (IS_SPECIAL(new_c))\n\t\t{\n\t\t    new_string[0] = K_SPECIAL;\n\t\t    new_string[1] = K_SECOND(new_c);\n\t\t    new_string[2] = K_THIRD(new_c);\n\t\t    len = 3;\n\t\t}\n\t\telse\n\t\t    len = mb_char2bytes(new_c, new_string);\n\t\tif (modifier == 0)\n\t\t{\n\t\t    if (put_string_in_typebuf(offset, 4, new_string, len,\n\t\t\t\t\t\t\tNULL, 0, NULL) == FAIL)\n\t\t    return -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tp[2] = modifier;\n\t\t    if (put_string_in_typebuf(offset + 3, 1, new_string, len,\n\t\t\t\t\t\t\tNULL, 0, NULL) == FAIL)\n\t\t    return -1;\n\t\t}\n\t\treturn len;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if the terminal sends modifiers with various keys.  This is when\n * modifyOtherKeys level 2 is enabled or the kitty keyboard protocol is\n * enabled.\n */\n    static int\nkey_protocol_enabled(void)\n{\n    // If xterm has responded to XTQMODKEYS it overrules seenModifyOtherKeys.\n    int using_mok = modify_otherkeys_state != MOKS_INITIAL\n\t\t\t? modify_otherkeys_state == MOKS_ENABLED\n\t\t\t: seenModifyOtherKeys;\n    return using_mok || kitty_protocol_state == KKPS_ENABLED;\n}\n\n/*\n * Handle mappings in the typeahead buffer.\n * - When something was mapped, return map_result_retry for recursive mappings.\n * - When nothing mapped and typeahead has a character: return map_result_get.\n * - When there is no match yet, return map_result_nomatch, need to get more\n *   typeahead.\n * - On failure (out of memory) return map_result_fail.\n */\n    static int\nhandle_mapping(\n\t    int *keylenp,\n\t    int *timedout,\n\t    int *mapdepth)\n{\n    mapblock_T\t*mp = NULL;\n    mapblock_T\t*mp2;\n    mapblock_T\t*mp_match;\n    int\t\tmp_match_len = 0;\n    int\t\tmax_mlen = 0;\n    int\t\twant_termcode = 0;  // 1 if termcode expected after max_mlen\n    int\t\ttb_c1;\n    int\t\tmlen;\n#ifdef FEAT_LANGMAP\n    int\t\tnolmaplen;\n#endif\n    int\t\tkeylen = *keylenp;\n    int\t\ti;\n    int\t\tlocal_State = get_real_state();\n    int\t\tis_plug_map = FALSE;\n\n    // If typeahead starts with <Plug> then remap, even for a \"noremap\" mapping.\n    if (typebuf.tb_len >= 3\n\t    && typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t    && typebuf.tb_buf[typebuf.tb_off + 1] == KS_EXTRA\n\t    && typebuf.tb_buf[typebuf.tb_off + 2] == KE_PLUG)\n\tis_plug_map = TRUE;\n\n    /*\n     * Check for a mappable key sequence.\n     * Walk through one maphash[] list until we find an entry that matches.\n     *\n     * Don't look for mappings if:\n     * - no_mapping set: mapping disabled (e.g. for CTRL-V)\n     * - maphash_valid not set: no mappings present.\n     * - typebuf.tb_buf[typebuf.tb_off] should not be remapped\n     * - in insert or cmdline mode and 'paste' option set\n     * - waiting for \"hit return to continue\" and CR or SPACE typed\n     * - waiting for a char with --more--\n     * - in Ctrl-X mode, and we get a valid char for that mode\n     */\n    tb_c1 = typebuf.tb_buf[typebuf.tb_off];\n    if (no_mapping == 0 && is_maphash_valid()\n\t    && (no_zero_mapping == 0 || tb_c1 != '0')\n\t    && (typebuf.tb_maplen == 0 || is_plug_map\n\t\t|| (p_remap\n\t\t    && (typebuf.tb_noremap[typebuf.tb_off]\n\t\t\t\t    & (RM_NONE|RM_ABBR)) == 0))\n\t    && !(p_paste && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t    && !(State == MODE_HITRETURN && (tb_c1 == CAR || tb_c1 == ' '))\n\t    && State != MODE_ASKMORE\n\t    && State != MODE_CONFIRM\n\t    && !at_ins_compl_key())\n    {\n#ifdef FEAT_GUI\n\tif (gui.in_use && tb_c1 == CSI && typebuf.tb_len >= 2\n\t\t&& typebuf.tb_buf[typebuf.tb_off + 1] == KS_MODIFIER)\n\t{\n\t    // The GUI code sends CSI KS_MODIFIER {flags}, but mappings expect\n\t    // K_SPECIAL KS_MODIFIER {flags}.\n\t    tb_c1 = K_SPECIAL;\n\t}\n#endif\n#ifdef FEAT_LANGMAP\n\tif (tb_c1 == K_SPECIAL)\n\t    nolmaplen = 2;\n\telse\n\t{\n\t    LANGMAP_ADJUST(tb_c1, (State & (MODE_CMDLINE | MODE_INSERT)) == 0\n\t\t\t\t\t   && get_real_state() != MODE_SELECT);\n\t    nolmaplen = 0;\n\t}\n#endif\n\t// First try buffer-local mappings.\n\tmp = get_buf_maphash_list(local_State, tb_c1);\n\tmp2 = get_maphash_list(local_State, tb_c1);\n\tif (mp == NULL)\n\t{\n\t    // There are no buffer-local mappings.\n\t    mp = mp2;\n\t    mp2 = NULL;\n\t}\n\n\t/*\n\t * Loop until a partly matching mapping is found or all (local)\n\t * mappings have been checked.\n\t * The longest full match is remembered in \"mp_match\".\n\t * A full match is only accepted if there is no partly match, so \"aa\"\n\t * and \"aaa\" can both be mapped.\n\t */\n\tmp_match = NULL;\n\tmp_match_len = 0;\n\tfor ( ; mp != NULL;\n\t       mp->m_next == NULL ? (mp = mp2, mp2 = NULL) : (mp = mp->m_next))\n\t{\n\t    // Only consider an entry if the first character matches and it is\n\t    // for the current state.\n\t    // Skip \":lmap\" mappings if keys were mapped.\n\t    if (mp->m_keys[0] == tb_c1\n\t\t    && (mp->m_mode & local_State)\n\t\t    && !(mp->m_simplified && key_protocol_enabled()\n\t\t\t\t\t\t     && typebuf.tb_maplen == 0)\n\t\t    && ((mp->m_mode & MODE_LANGMAP) == 0\n\t\t\t\t\t\t    || typebuf.tb_maplen == 0))\n\t    {\n#ifdef FEAT_LANGMAP\n\t\tint\tnomap = nolmaplen;\n\t\tint\tmodifiers = 0;\n#endif\n\t\t// find the match length of this mapping\n\t\tfor (mlen = 1; mlen < typebuf.tb_len; ++mlen)\n\t\t{\n\t\t    int\tc2 = typebuf.tb_buf[typebuf.tb_off + mlen];\n#ifdef FEAT_LANGMAP\n\t\t    if (nomap > 0)\n\t\t    {\n\t\t\tif (nomap == 2 && c2 == KS_MODIFIER)\n\t\t\t    modifiers = 1;\n\t\t\telse if (nomap == 1 && modifiers == 1)\n\t\t\t    modifiers = c2;\n\t\t\t--nomap;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (c2 == K_SPECIAL)\n\t\t\t    nomap = 2;\n\t\t\telse if (merge_modifyOtherKeys(c2, &modifiers) == c2)\n\t\t\t    // Only apply 'langmap' if merging modifiers into\n\t\t\t    // the key will not result in another character,\n\t\t\t    // so that 'langmap' behaves consistently in\n\t\t\t    // different terminals and GUIs.\n\t\t\t    LANGMAP_ADJUST(c2, TRUE);\n\t\t\tmodifiers = 0;\n\t\t    }\n#endif\n\t\t    if (mp->m_keys[mlen] != c2)\n\t\t\tbreak;\n\t\t}\n\n\t\t// Don't allow mapping the first byte(s) of a multi-byte char.\n\t\t// Happens when mapping <M-a> and then changing 'encoding'.\n\t\t// Beware that 0x80 is escaped.\n\t\t{\n\t\t    char_u *p1 = mp->m_keys;\n\t\t    char_u *p2 = mb_unescape(&p1);\n\n\t\t    if (has_mbyte && p2 != NULL\n\t\t\t\t\t&& MB_BYTE2LEN(tb_c1) > mb_ptr2len(p2))\n\t\t\tmlen = 0;\n\t\t}\n\n\t\t// Check an entry whether it matches.\n\t\t// - Full match: mlen == keylen\n\t\t// - Partly match: mlen == typebuf.tb_len\n\t\tkeylen = mp->m_keylen;\n\t\tif (mlen == keylen || (mlen == typebuf.tb_len\n\t\t\t\t\t\t   && typebuf.tb_len < keylen))\n\t\t{\n\t\t    char_u  *s;\n\t\t    int\t    n;\n\n\t\t    // If only script-local mappings are allowed, check if the\n\t\t    // mapping starts with K_SNR.\n\t\t    s = typebuf.tb_noremap + typebuf.tb_off;\n\t\t    if (*s == RM_SCRIPT\n\t\t\t    && (mp->m_keys[0] != K_SPECIAL\n\t\t\t\t|| mp->m_keys[1] != KS_EXTRA\n\t\t\t\t|| mp->m_keys[2] != KE_SNR))\n\t\t\tcontinue;\n\n\t\t    // If one of the typed keys cannot be remapped, skip the\n\t\t    // entry.\n\t\t    for (n = mlen; --n >= 0; )\n\t\t\tif (*s++ & (RM_NONE|RM_ABBR))\n\t\t\t    break;\n\t\t    if (!is_plug_map && n >= 0)\n\t\t\tcontinue;\n\n\t\t    if (keylen > typebuf.tb_len)\n\t\t    {\n\t\t\tif (!*timedout && !(mp_match != NULL\n\t\t\t\t\t\t\t&& mp_match->m_nowait))\n\t\t\t{\n\t\t\t    // break at a partly match\n\t\t\t    keylen = KEYLEN_PART_MAP;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else if (keylen > mp_match_len)\n\t\t    {\n\t\t\t// found a longer match\n\t\t\tmp_match = mp;\n\t\t\tmp_match_len = keylen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    // No match; may have to check for termcode at next\n\t\t    // character.  If the first character that didn't match is\n\t\t    // K_SPECIAL then check for a termcode.  This isn't perfect\n\t\t    // but should work in most cases.\n\t\t    if (max_mlen < mlen)\n\t\t    {\n\t\t\tmax_mlen = mlen;\n\t\t\twant_termcode = mp->m_keys[mlen] == K_SPECIAL;\n\t\t    }\n\t\t    else if (max_mlen == mlen && mp->m_keys[mlen] == K_SPECIAL)\n\t\t\twant_termcode = 1;\n\t    }\n\t}\n\n\t// If no partly match found, use the longest full match.\n\tif (keylen != KEYLEN_PART_MAP && mp_match != NULL)\n\t{\n\t    mp = mp_match;\n\t    keylen = mp_match_len;\n\t}\n    }\n\n    /*\n     * Check for match with 'pastetoggle'\n     */\n    if (*p_pt != NUL && mp == NULL && (State & (MODE_INSERT | MODE_NORMAL)))\n    {\n\tfor (mlen = 0; mlen < typebuf.tb_len && p_pt[mlen]; ++mlen)\n\t    if (p_pt[mlen] != typebuf.tb_buf[typebuf.tb_off + mlen])\n\t\t    break;\n\tif (p_pt[mlen] == NUL)\t// match\n\t{\n\t    // write chars to script file(s)\n\t    if (mlen > typebuf.tb_maplen)\n\t\tgotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,\n\t\t\t\t\t\t     mlen - typebuf.tb_maplen);\n\n\t    del_typebuf(mlen, 0); // remove the chars\n\t    set_option_value_give_err((char_u *)\"paste\",\n\t\t\t\t\t\t      (long)!p_paste, NULL, 0);\n\t    if (!(State & MODE_INSERT))\n\t    {\n\t\tmsg_col = 0;\n\t\tmsg_row = Rows - 1;\n\t\tmsg_clr_eos();\t\t// clear ruler\n\t    }\n\t    status_redraw_all();\n\t    redraw_statuslines();\n\t    showmode();\n\t    setcursor();\n\t    *keylenp = keylen;\n\t    return map_result_retry;\n\t}\n\t// Need more chars for partly match.\n\tif (mlen == typebuf.tb_len)\n\t    keylen = KEYLEN_PART_KEY;\n\telse if (max_mlen < mlen)\n\t    // no match, may have to check for termcode at next character\n\t    max_mlen = mlen + 1;\n    }\n\n    // May check for a terminal code when there is no mapping or only a partial\n    // mapping.  Also check if there is a full mapping with <Esc>, unless timed\n    // out, since that is nearly always a partial match with a terminal code.\n    if ((mp == NULL || max_mlen + want_termcode > mp_match_len\n\t\t    || (mp_match_len == 1 && *mp->m_keys == ESC && !*timedout))\n\t    && keylen != KEYLEN_PART_MAP)\n    {\n\tint\tsave_keylen = keylen;\n\n\t/*\n\t * When no matching mapping found or found a non-matching mapping that\n\t * matches at least what the matching mapping matched:\n\t * Check if we have a terminal code, when:\n\t * - mapping is allowed,\n\t * - keys have not been mapped,\n\t * - and not an ESC sequence, not in insert mode or p_ek is on,\n\t * - and when not timed out,\n\t */\n\tif (no_mapping == 0 || allow_keys != 0)\n\t{\n\t    if ((typebuf.tb_maplen == 0\n\t\t    || (p_remap && typebuf.tb_noremap[\n\t\t\t\t\t\t    typebuf.tb_off] == RM_YES))\n\t\t&& !*timedout)\n\t\tkeylen = check_termcode(max_mlen + 1, NULL, 0, NULL);\n\t    else\n\t\tkeylen = 0;\n\n\t    // If no termcode matched but 'pastetoggle' matched partially\n\t    // it's like an incomplete key sequence.\n\t    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY && !*timedout)\n\t\tkeylen = KEYLEN_PART_KEY;\n\n\t    // If no termcode matched, try to include the modifier into the\n\t    // key.  This is for when modifyOtherKeys is working.\n#ifdef FEAT_TERMINAL\n\t    check_no_reduce_keys();  // may update the no_reduce_keys flag\n#endif\n\t    if (keylen == 0 && !no_reduce_keys)\n\t    {\n\t\tkeylen = check_simplify_modifier(max_mlen + 1);\n\t\tif (keylen < 0)\n\t\t    // ins_typebuf() failed\n\t\t    return map_result_fail;\n\t    }\n\n\t    // When getting a partial match, but the last characters were not\n\t    // typed, don't wait for a typed character to complete the\n\t    // termcode.  This helps a lot when a \":normal\" command ends in an\n\t    // ESC.\n\t    if (keylen < 0 && typebuf.tb_len == typebuf.tb_maplen)\n\t\tkeylen = 0;\n\t}\n\telse\n\t    keylen = 0;\n\tif (keylen == 0)\t// no matching terminal code\n\t{\n#ifdef AMIGA\n\t    // check for window bounds report\n\t    if (typebuf.tb_maplen == 0 && (typebuf.tb_buf[\n\t\t\t\t\t\ttypebuf.tb_off] & 0xff) == CSI)\n\t    {\n\t\tchar_u *s;\n\n\t\tfor (s = typebuf.tb_buf + typebuf.tb_off + 1;\n\t\t\t   s < typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len\n\t\t   && (VIM_ISDIGIT(*s) || *s == ';' || *s == ' ');\n\t\t\t++s)\n\t\t    ;\n\t\tif (*s == 'r' || *s == '|') // found one\n\t\t{\n\t\t    del_typebuf(\n\t\t\t  (int)(s + 1 - (typebuf.tb_buf + typebuf.tb_off)), 0);\n\t\t    // get size and redraw screen\n\t\t    shell_resized();\n\t\t    *keylenp = keylen;\n\t\t    return map_result_retry;\n\t\t}\n\t\tif (*s == NUL)\t    // need more characters\n\t\t    keylen = KEYLEN_PART_KEY;\n\t    }\n\t    if (keylen >= 0)\n#endif\n\t\t// When there was a matching mapping and no termcode could be\n\t\t// replaced after another one, use that mapping (loop around).\n\t\t// If there was no mapping at all use the character from the\n\t\t// typeahead buffer right here.\n\t\tif (mp == NULL)\n\t\t{\n\t\t    *keylenp = keylen;\n\t\t    return map_result_get;    // get character from typeahead\n\t\t}\n\t}\n\n\tif (keylen > 0)\t    // full matching terminal code\n\t{\n#if defined(FEAT_GUI) && defined(FEAT_MENU)\n\t    if (typebuf.tb_len >= 2\n\t\t    && typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL\n\t\t\t      && typebuf.tb_buf[typebuf.tb_off + 1] == KS_MENU)\n\t    {\n\t\tint\tidx;\n\n\t\t// Using a menu may cause a break in undo!  It's like using\n\t\t// gotchars(), but without recording or writing to a script\n\t\t// file.\n\t\tmay_sync_undo();\n\t\tdel_typebuf(3, 0);\n\t\tidx = get_menu_index(current_menu, local_State);\n\t\tif (idx != MENU_INDEX_INVALID)\n\t\t{\n\t\t    // In Select mode and a Visual mode menu is used:  Switch\n\t\t    // to Visual mode temporarily.  Append K_SELECT to switch\n\t\t    // back to Select mode.\n\t\t    if (VIsual_active && VIsual_select\n\t\t\t\t\t&& (current_menu->modes & MODE_VISUAL))\n\t\t    {\n\t\t\tVIsual_select = FALSE;\n\t\t\t(void)ins_typebuf(K_SELECT_STRING,\n\t\t\t\t\t\t   REMAP_NONE, 0, TRUE, FALSE);\n\t\t    }\n\t\t    ins_typebuf(current_menu->strings[idx],\n\t\t\t\tcurrent_menu->noremap[idx],\n\t\t\t\t0, TRUE, current_menu->silent[idx]);\n\t\t}\n\t    }\n#endif // FEAT_GUI && FEAT_MENU\n\t    *keylenp = keylen;\n\t    return map_result_retry;\t// try mapping again\n\t}\n\n\t// Partial match: get some more characters.  When a matching mapping\n\t// was found use that one.\n\tif (mp == NULL || keylen < 0)\n\t    keylen = KEYLEN_PART_KEY;\n\telse\n\t    keylen = mp_match_len;\n    }\n\n    /*\n     * complete match\n     */\n    if (keylen >= 0 && keylen <= typebuf.tb_len)\n    {\n\tchar_u *map_str;\n\n#ifdef FEAT_EVAL\n\tint\tsave_m_expr;\n\tint\tsave_m_noremap;\n\tint\tsave_m_silent;\n\tchar_u\t*save_m_keys;\n#else\n# define save_m_noremap mp->m_noremap\n# define save_m_silent mp->m_silent\n#endif\n\n\t// write chars to script file(s)\n\tif (keylen > typebuf.tb_maplen)\n\t    gotchars(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_maplen,\n\t\t\t\t\t\t   keylen - typebuf.tb_maplen);\n\n\tcmd_silent = (typebuf.tb_silent > 0);\n\tdel_typebuf(keylen, 0);\t// remove the mapped keys\n\n\t/*\n\t * Put the replacement string in front of mapstr.\n\t * The depth check catches \":map x y\" and \":map y x\".\n\t */\n\tif (++*mapdepth >= p_mmd)\n\t{\n\t    emsg(_(e_recursive_mapping));\n\t    if (State & MODE_CMDLINE)\n\t\tredrawcmdline();\n\t    else\n\t\tsetcursor();\n\t    flush_buffers(FLUSH_MINIMAL);\n\t    *mapdepth = 0;\t// for next one\n\t    *keylenp = keylen;\n\t    return map_result_fail;\n\t}\n\n\t/*\n\t * In Select mode and a Visual mode mapping is used: Switch to Visual\n\t * mode temporarily.  Append K_SELECT to switch back to Select mode.\n\t */\n\tif (VIsual_active && VIsual_select && (mp->m_mode & MODE_VISUAL))\n\t{\n\t    VIsual_select = FALSE;\n\t    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n\n#ifdef FEAT_EVAL\n\t// Copy the values from *mp that are used, because evaluating the\n\t// expression may invoke a function that redefines the mapping, thereby\n\t// making *mp invalid.\n\tsave_m_expr = mp->m_expr;\n\tsave_m_noremap = mp->m_noremap;\n\tsave_m_silent = mp->m_silent;\n\tsave_m_keys = NULL;  // only saved when needed\n\n\t/*\n\t * Handle \":map <expr>\": evaluate the {rhs} as an expression.  Also\n\t * save and restore the command line for \"normal :\".\n\t */\n\tif (mp->m_expr)\n\t{\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_may_garbage_collect = may_garbage_collect;\n\t    int was_screen_col = screen_cur_col;\n\t    int was_screen_row = screen_cur_row;\n\t    int prev_did_emsg = did_emsg;\n\n\t    vgetc_busy = 0;\n\t    may_garbage_collect = FALSE;\n\n\t    save_m_keys = vim_strsave(mp->m_keys);\n\t    map_str = eval_map_expr(mp, NUL);\n\n\t    // The mapping may do anything, but we expect it to take care of\n\t    // redrawing.  Do put the cursor back where it was.\n\t    windgoto(was_screen_row, was_screen_col);\n\t    out_flush();\n\n\t    // If an error was displayed and the expression returns an empty\n\t    // string, generate a <Nop> to allow for a redraw.\n\t    if (prev_did_emsg != did_emsg\n\t\t\t\t       && (map_str == NULL || *map_str == NUL))\n\t    {\n\t\tchar_u\tbuf[4];\n\n\t\tvim_free(map_str);\n\t\tbuf[0] = K_SPECIAL;\n\t\tbuf[1] = KS_EXTRA;\n\t\tbuf[2] = KE_IGNORE;\n\t\tbuf[3] = NUL;\n\t\tmap_str = vim_strsave(buf);\n\t\tif (State & MODE_CMDLINE)\n\t\t{\n\t\t    // redraw the command below the error\n\t\t    msg_didout = TRUE;\n\t\t    if (msg_row < cmdline_row)\n\t\t\tmsg_row = cmdline_row;\n\t\t    redrawcmd();\n\t\t}\n\t    }\n\n\t    vgetc_busy = save_vgetc_busy;\n\t    may_garbage_collect = save_may_garbage_collect;\n\t}\n\telse\n#endif\n\t    map_str = mp->m_str;\n\n\t/*\n\t * Insert the 'to' part in the typebuf.tb_buf.\n\t * If 'from' field is the same as the start of the 'to' field, don't\n\t * remap the first character (but do allow abbreviations).\n\t * If m_noremap is set, don't remap the whole 'to' part.\n\t */\n\tif (map_str == NULL)\n\t    i = FAIL;\n\telse\n\t{\n\t    int noremap;\n\n#ifdef FEAT_EVAL\n\t    last_used_map = mp;\n\t    last_used_sid = -1;\n#endif\n\t    if (save_m_noremap != REMAP_YES)\n\t\tnoremap = save_m_noremap;\n\t    else if (\n#ifdef FEAT_EVAL\n\t\tSTRNCMP(map_str, save_m_keys != NULL ? save_m_keys : mp->m_keys,\n\t\t\t\t\t\t\t\t(size_t)keylen)\n#else\n\t\tSTRNCMP(map_str, mp->m_keys, (size_t)keylen)\n#endif\n\t\t   != 0)\n\t\tnoremap = REMAP_YES;\n\t    else\n\t\tnoremap = REMAP_SKIP;\n\t    i = ins_typebuf(map_str, noremap,\n\t\t\t\t\t 0, TRUE, cmd_silent || save_m_silent);\n#ifdef FEAT_EVAL\n\t    if (save_m_expr)\n\t\tvim_free(map_str);\n#endif\n\t}\n#ifdef FEAT_EVAL\n\tvim_free(save_m_keys);\n#endif\n\t*keylenp = keylen;\n\tif (i == FAIL)\n\t    return map_result_fail;\n\treturn map_result_retry;\n    }\n\n    *keylenp = keylen;\n    return map_result_nomatch;\n}\n\n/*\n * unget one character (can only be done once!)\n * If the character was stuffed, vgetc() will get it next time it is called.\n * Otherwise vgetc() will only get it when the stuff buffer is empty.\n */\n    void\nvungetc(int c)\n{\n    old_char = c;\n    old_mod_mask = mod_mask;\n    old_mouse_row = mouse_row;\n    old_mouse_col = mouse_col;\n    old_KeyStuffed = KeyStuffed;\n}\n\n/*\n * When peeking and not getting a character, reg_executing cannot be cleared\n * yet, so set a flag to clear it later.\n */\n    static void\ncheck_end_reg_executing(int advance)\n{\n    if (reg_executing != 0 && (typebuf.tb_maplen == 0\n\t\t\t\t\t\t|| pending_end_reg_executing))\n    {\n\tif (advance)\n\t{\n\t    reg_executing = 0;\n\t    pending_end_reg_executing = FALSE;\n\t}\n\telse\n\t    pending_end_reg_executing = TRUE;\n    }\n\n}\n\n/*\n * Get a byte:\n * 1. from the stuffbuffer\n *\tThis is used for abbreviated commands like \"D\" -> \"d$\".\n *\tAlso used to redo a command for \".\".\n * 2. from the typeahead buffer\n *\tStores text obtained previously but not used yet.\n *\tAlso stores the result of mappings.\n *\tAlso used for the \":normal\" command.\n * 3. from the user\n *\tThis may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *\tReally get the character.\n *\tKeyTyped is set to TRUE in the case the user typed the key.\n *\tKeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *\tJust look whether there is a character available.\n *\tReturn NUL if not.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n    int\t\tc;\n    int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\t\t\t\t\t// for mapping to complete or\n\t\t\t\t\t// 'ttimeoutlen' for complete key code\n    int\t\tmapdepth = 0;\t\t// check for recursive mapping\n    int\t\tmode_deleted = FALSE;   // set when mode has been deleted\n    int\t\tnew_wcol, new_wrow;\n#ifdef FEAT_GUI\n    int\t\tshape_changed = FALSE;  // adjusted cursor shape\n#endif\n    int\t\tn;\n    int\t\told_wcol, old_wrow;\n    int\t\twait_tb_len;\n\n    /*\n     * This function doesn't work very well when called recursively.  This may\n     * happen though, because of:\n     * 1. The call to add_to_showcmd().\tchar_avail() is then used to check if\n     * there is a character available, which calls this function.  In that\n     * case we must return NUL, to indicate no character is available.\n     * 2. A GUI callback function writes to the screen, causing a\n     * wait_return().\n     * Using \":normal\" can also do this, but it saves the typeahead buffer,\n     * thus it should be OK.  But don't get a key from the user then.\n     */\n    if (vgetc_busy > 0 && ex_normal_busy == 0)\n\treturn NUL;\n\n    ++vgetc_busy;\n\n    if (advance)\n    {\n\tKeyStuffed = FALSE;\n\ttypebuf_was_empty = FALSE;\n    }\n\n    init_typebuf();\n    start_stuff();\n    check_end_reg_executing(advance);\n    do\n    {\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n\tif (c != NUL && !got_int)\n\t{\n\t    if (advance)\n\t    {\n\t\t// KeyTyped = FALSE;  When the command that stuffed something\n\t\t// was typed, behave like the stuffed command was typed.\n\t\t// needed for CTRL-W CTRL-] to open a fold, for example.\n\t\tKeyStuffed = TRUE;\n\t    }\n\t    if (typebuf.tb_no_abbr_cnt == 0)\n\t\ttypebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now\n\t}\n\telse\n\t{\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n\t\tlong\twait_time;\n\t\tint\tkeylen = 0;\n\t\tint\tshowcmd_idx;\n\t\tcheck_end_reg_executing(advance);\n\t\t/*\n\t\t * ui_breakcheck() is slow, don't use it too often when\n\t\t * inside a mapping.  But call it each time for typed\n\t\t * characters.\n\t\t */\n\t\tif (typebuf.tb_maplen)\n\t\t    line_breakcheck();\n\t\telse\n\t\t    ui_breakcheck();\t\t// check for CTRL-C\n\t\tif (got_int)\n\t\t{\n\t\t    // flush all input\n\t\t    c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);\n\n\t\t    /*\n\t\t     * If inchar() returns TRUE (script file was active) or we\n\t\t     * are inside a mapping, get out of Insert mode.\n\t\t     * Otherwise we behave like having gotten a CTRL-C.\n\t\t     * As a result typing CTRL-C in insert mode will\n\t\t     * really insert a CTRL-C.\n\t\t     */\n\t\t    if ((c || typebuf.tb_maplen)\n\t\t\t\t     && (State & (MODE_INSERT | MODE_CMDLINE)))\n\t\t\tc = ESC;\n\t\t    else\n\t\t\tc = Ctrl_C;\n\t\t    flush_buffers(FLUSH_INPUT);\t// flush all typeahead\n\n\t\t    if (advance)\n\t\t    {\n\t\t\t// Also record this character, it might be needed to\n\t\t\t// get out of Insert mode.\n\t\t\t*typebuf.tb_buf = c;\n\t\t\tgotchars(typebuf.tb_buf, 1);\n\t\t    }\n\t\t    cmd_silent = FALSE;\n\n\t\t    break;\n\t\t}\n\t\telse if (typebuf.tb_len > 0)\n\t\t{\n\t\t    /*\n\t\t     * Check for a mapping in \"typebuf\".\n\t\t     */\n\t\t    map_result_T result = handle_mapping(\n\t\t\t\t\t\t&keylen, &timedout, &mapdepth);\n\n\t\t    if (result == map_result_retry)\n\t\t\t// try mapping again\n\t\t\tcontinue;\n\t\t    if (result == map_result_fail)\n\t\t    {\n\t\t\t// failed, use the outer loop\n\t\t\tc = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (result == map_result_get)\n\t\t    {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\tc = typebuf.tb_buf[typebuf.tb_off];\n\t\t\tif (advance)\t// remove chars from tb_buf\n\t\t\t{\n\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\tKeyTyped = FALSE;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t// write char to script file(s)\n\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t    }\n\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t    del_typebuf(1, 0);\n\t\t\t}\n\t\t\tbreak;  // got character, break the for loop\n\t\t    }\n\n\t\t    // not enough characters, get more\n\t\t}\n\n/*\n * get a character: 3. from the user - handle <Esc> in Insert mode\n */\n\t\t/*\n\t\t * Special case: if we get an <ESC> in Insert mode and there\n\t\t * are no more characters at once, we pretend to go out of\n\t\t * Insert mode.  This prevents the one second delay after\n\t\t * typing an <ESC>.  If we get something after all, we may\n\t\t * have to redisplay the mode. That the cursor is in the wrong\n\t\t * place does not matter.\n\t\t * Do not do this if the kitty keyboard protocol is used, every\n\t\t * <ESC> is the start of an escape sequence then.\n\t\t */\n\t\tc = 0;\n\t\tnew_wcol = curwin->w_wcol;\n\t\tnew_wrow = curwin->w_wrow;\n\t\tif (\t   advance\n\t\t\t&& typebuf.tb_len == 1\n\t\t\t&& typebuf.tb_buf[typebuf.tb_off] == ESC\n\t\t\t&& !no_mapping\n\t\t\t&& kitty_protocol_state != KKPS_ENABLED\n\t\t\t&& ex_normal_busy == 0\n\t\t\t&& typebuf.tb_maplen == 0\n\t\t\t&& (State & MODE_INSERT)\n\t\t\t&& (p_timeout\n\t\t\t    || (keylen == KEYLEN_PART_KEY && p_ttimeout))\n\t\t\t&& (c = inchar(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t       + typebuf.tb_len, 3, 25L)) == 0)\n\t\t{\n\t\t    colnr_T\tcol = 0;\n\t\t    char_u\t*ptr;\n\n\t\t    if (mode_displayed)\n\t\t    {\n\t\t\tunshowmode(TRUE);\n\t\t\tmode_deleted = TRUE;\n\t\t    }\n#ifdef FEAT_GUI\n\t\t    // may show a different cursor shape\n\t\t    if (gui.in_use && State != MODE_NORMAL && !cmd_silent)\n\t\t    {\n\t\t\tint\t    save_State;\n\n\t\t\tsave_State = State;\n\t\t\tState = MODE_NORMAL;\n\t\t\tgui_update_cursor(TRUE, FALSE);\n\t\t\tState = save_State;\n\t\t\tshape_changed = TRUE;\n\t\t    }\n#endif\n\t\t    validate_cursor();\n\t\t    old_wcol = curwin->w_wcol;\n\t\t    old_wrow = curwin->w_wrow;\n\n\t\t    // move cursor left, if possible\n\t\t    if (curwin->w_cursor.col != 0)\n\t\t    {\n\t\t\tif (curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // After auto-indenting and no text is following,\n\t\t\t    // we are expecting to truncate the trailing\n\t\t\t    // white-space, so find the last non-white\n\t\t\t    // character -- webb\n\t\t\t    if (did_ai && *skipwhite(ml_get_curline()\n\t\t\t\t\t\t+ curwin->w_cursor.col) == NUL)\n\t\t\t    {\n\t\t\t\tchartabsize_T cts;\n\n\t\t\t\tcurwin->w_wcol = 0;\n\t\t\t\tptr = ml_get_curline();\n\t\t\t\tinit_chartabsize_arg(&cts, curwin,\n\t\t\t\t\t  curwin->w_cursor.lnum, 0, ptr, ptr);\n\t\t\t\twhile (cts.cts_ptr < ptr + curwin->w_cursor.col)\n\t\t\t\t{\n\t\t\t\t    if (!VIM_ISWHITE(*cts.cts_ptr))\n\t\t\t\t\tcurwin->w_wcol = cts.cts_vcol;\n\t\t\t\t    cts.cts_vcol += lbr_chartabsize(&cts);\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tcts.cts_ptr +=\n\t\t\t\t\t\t   (*mb_ptr2len)(cts.cts_ptr);\n\t\t\t\t    else\n\t\t\t\t\t++cts.cts_ptr;\n\t\t\t\t}\n\t\t\t\tclear_chartabsize_arg(&cts);\n\n\t\t\t\tcurwin->w_wrow = curwin->w_cline_row\n\t\t\t\t\t   + curwin->w_wcol / curwin->w_width;\n\t\t\t\tcurwin->w_wcol %= curwin->w_width;\n\t\t\t\tcurwin->w_wcol += curwin_col_off();\n\t\t\t\tcol = 0;\t// no correction needed\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t--curwin->w_wcol;\n\t\t\t\tcol = curwin->w_cursor.col - 1;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (curwin->w_p_wrap && curwin->w_wrow)\n\t\t\t{\n\t\t\t    --curwin->w_wrow;\n\t\t\t    curwin->w_wcol = curwin->w_width - 1;\n\t\t\t    col = curwin->w_cursor.col - 1;\n\t\t\t}\n\t\t\tif (has_mbyte && col > 0 && curwin->w_wcol > 0)\n\t\t\t{\n\t\t\t    // Correct when the cursor is on the right halve\n\t\t\t    // of a double-wide character.\n\t\t\t    ptr = ml_get_curline();\n\t\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t\t\t    if ((*mb_ptr2cells)(ptr + col) > 1)\n\t\t\t\t--curwin->w_wcol;\n\t\t\t}\n\t\t    }\n\t\t    setcursor();\n\t\t    out_flush();\n\t\t    new_wcol = curwin->w_wcol;\n\t\t    new_wrow = curwin->w_wrow;\n\t\t    curwin->w_wcol = old_wcol;\n\t\t    curwin->w_wrow = old_wrow;\n\t\t}\n\t\tif (c < 0)\n\t\t    continue;\t// end of input script reached\n\n\t\t// Allow mapping for just typed characters. When we get here c\n\t\t// is the number of extra bytes and typebuf.tb_len is 1.\n\t\tfor (n = 1; n <= c; ++n)\n\t\t    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;\n\t\ttypebuf.tb_len += c;\n\n\t\t// buffer full, don't map\n\t\tif (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)\n\t\t{\n\t\t    timedout = TRUE;\n\t\t    continue;\n\t\t}\n\n\t\tif (ex_normal_busy > 0)\n\t\t{\n\t\t    static int tc = 0;\n\n\t\t    // No typeahead left and inside \":normal\".  Must return\n\t\t    // something to avoid getting stuck.  When an incomplete\n\t\t    // mapping is present, behave like it timed out.\n\t\t    if (typebuf.tb_len > 0)\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    // When 'insertmode' is set, ESC just beeps in Insert\n\t\t    // mode.  Use CTRL-L to make edit() return.\n\t\t    // For the command line only CTRL-C always breaks it.\n\t\t    // For the cmdline window: Alternate between ESC and\n\t\t    // CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t    // cmdline window.\n\t\t    if (p_im && (State & MODE_INSERT))\n\t\t\tc = Ctrl_L;\n#ifdef FEAT_TERMINAL\n\t\t    else if (terminal_is_active())\n\t\t\tc = K_CANCEL;\n#endif\n\t\t    else if ((State & MODE_CMDLINE)\n\t\t\t\t\t     || (cmdwin_type > 0 && tc == ESC))\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n\t\t    tc = c;\n\t\t    // set a flag to indicate this wasn't a normal char\n\t\t    if (advance)\n\t\t\ttypebuf_was_empty = TRUE;\n\n\t\t    // return from main_loop()\n\t\t    if (pending_exmode_active)\n\t\t\texmode_active = EXMODE_NORMAL;\n\n\t\t    // no chars to block abbreviation for\n\t\t    typebuf.tb_no_abbr_cnt = 0;\n\n\t\t    break;\n\t\t}\n\n/*\n * get a character: 3. from the user - update display\n */\n\t\t// In insert mode a screen update is skipped when characters\n\t\t// are still available.  But when those available characters\n\t\t// are part of a mapping, and we are going to do a blocking\n\t\t// wait here.  Need to update the screen to display the\n\t\t// changed text so far. Also for when 'lazyredraw' is set and\n\t\t// redrawing was postponed because there was something in the\n\t\t// input buffer (e.g., termresponse).\n\t\tif (((State & MODE_INSERT) != 0 || p_lz)\n\t\t\t&& (State & MODE_CMDLINE) == 0\n\t\t\t&& advance && must_redraw != 0 && !need_wait_return)\n\t\t{\n\t\t    update_screen(0);\n\t\t    setcursor(); // put cursor back where it belongs\n\t\t}\n\n\t\t/*\n\t\t * If we have a partial match (and are going to wait for more\n\t\t * input from the user), show the partially matched characters\n\t\t * to the user with showcmd.\n\t\t */\n\t\tshowcmd_idx = 0;\n\t\tint showing_partial = FALSE;\n\t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n\t\t{\n\t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t\t\t\t      || State == MODE_LANGMAP)\n\t\t\t    && State != MODE_HITRETURN)\n\t\t    {\n\t\t\t// this looks nice when typing a dead character map\n\t\t\tif (State & MODE_INSERT\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t\t{\n\t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\t    setcursor(); // put cursor back where it belongs\n\t\t\t    showing_partial = TRUE;\n\t\t\t}\n\t\t\t// need to use the col and row from above here\n\t\t\told_wcol = curwin->w_wcol;\n\t\t\told_wrow = curwin->w_wrow;\n\t\t\tcurwin->w_wcol = new_wcol;\n\t\t\tcurwin->w_wrow = new_wrow;\n\t\t\tpush_showcmd();\n\t\t\tif (typebuf.tb_len > SHOWCMD_COLS)\n\t\t\t    showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;\n\t\t\twhile (showcmd_idx < typebuf.tb_len)\n\t\t\t    (void)add_to_showcmd(\n\t\t\t       typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);\n\t\t\tcurwin->w_wcol = old_wcol;\n\t\t\tcurwin->w_wrow = old_wrow;\n\t\t    }\n\n\t\t    // This looks nice when typing a dead character map.\n\t\t    // There is no actual command line for get_number().\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t    && get_cmdline_info()->cmdbuff != NULL\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t\t\t    && cmdline_star == 0\n#endif\n\t\t\t    && ptr2cells(typebuf.tb_buf + typebuf.tb_off\n\t\t\t\t\t\t   + typebuf.tb_len - 1) == 1)\n\t\t    {\n\t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n\t\t\tshowing_partial = TRUE;\n\t\t    }\n\t\t}\n\n/*\n * get a character: 3. from the user - get it\n */\n\t\tif (typebuf.tb_len == 0)\n\t\t    // timedout may have been set if a mapping with empty RHS\n\t\t    // fully matched while longer mappings timed out.\n\t\t    timedout = FALSE;\n\n\t\tif (advance)\n\t\t{\n\t\t    if (typebuf.tb_len == 0\n\t\t\t    || !(p_timeout\n\t\t\t\t || (p_ttimeout && keylen == KEYLEN_PART_KEY)))\n\t\t\t// blocking wait\n\t\t\twait_time = -1L;\n\t\t    else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)\n\t\t\twait_time = p_ttm;\n\t\t    else\n\t\t\twait_time = p_tm;\n\t\t}\n\t\telse\n\t\t    wait_time = 0;\n\n\t\twait_tb_len = typebuf.tb_len;\n\t\tc = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,\n\t\t\ttypebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,\n\t\t\twait_time);\n\n\t\tif (showcmd_idx != 0)\n\t\t    pop_showcmd();\n\t\tif (showing_partial)\n\t\t{\n\t\t    if (State & MODE_INSERT)\n\t\t\tedit_unputchar();\n\t\t    if ((State & MODE_CMDLINE)\n\t\t\t\t\t&& get_cmdline_info()->cmdbuff != NULL)\n\t\t\tunputcmdline();\n\t\t    else\n\t\t\tsetcursor();\t// put cursor back where it belongs\n\t\t}\n\n\t\tif (c < 0)\n\t\t    continue;\t\t// end of input script reached\n\t\tif (c == NUL)\t\t// no character available\n\t\t{\n\t\t    if (!advance)\n\t\t\tbreak;\n\t\t    if (wait_tb_len > 0)\t// timed out\n\t\t    {\n\t\t\ttimedout = TRUE;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\t    // allow mapping for just typed characters\n\t\t    while (typebuf.tb_buf[typebuf.tb_off\n\t\t\t\t\t\t     + typebuf.tb_len] != NUL)\n\t\t\ttypebuf.tb_noremap[typebuf.tb_off\n\t\t\t\t\t\t + typebuf.tb_len++] = RM_YES;\n#ifdef HAVE_INPUT_METHOD\n\t\t    // Get IM status right after getting keys, not after the\n\t\t    // timeout for a mapping (focus may be lost by then).\n\t\t    vgetc_im_active = im_get_status();\n#endif\n\t\t}\n\t    }\t    // for (;;)\n\t}\t// if (!character from stuffbuf)\n\n\t// if advance is FALSE don't loop on NULs\n    } while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));\n\n    /*\n     * The \"INSERT\" message is taken care of here:\n     *\t if we return an ESC to exit insert mode, the message is deleted\n     *\t if we don't return an ESC but deleted the message before, redisplay it\n     */\n    if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))\n    {\n\tif (c == ESC && !mode_deleted && !no_mapping && mode_displayed)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // delete mode later\n\t    else\n\t\tunshowmode(FALSE);\n\t}\n\telse if (c != ESC && mode_deleted)\n\t{\n\t    if (typebuf.tb_len && !KeyTyped)\n\t\tredraw_cmdline = TRUE;\t    // show mode later\n\t    else\n\t\tshowmode();\n\t}\n    }\n#ifdef FEAT_GUI\n    // may unshow different cursor shape\n    if (gui.in_use && shape_changed)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n    if (timedout && c == ESC)\n    {\n\tchar_u nop_buf[3];\n\n\t// When recording there will be no timeout.  Add a <Nop> after the ESC\n\t// to avoid that it forms a key code with following characters.\n\tnop_buf[0] = K_SPECIAL;\n\tnop_buf[1] = KS_EXTRA;\n\tnop_buf[2] = KE_NOP;\n\tgotchars(nop_buf, 3);\n    }\n\n    --vgetc_busy;\n\n    return c;\n}\n\n/*\n * inchar() - get one character from\n *\t1. a scriptfile\n *\t2. the keyboard\n *\n *  As many characters as we can get (up to 'maxlen') are put in \"buf\" and\n *  NUL terminated (buffer length must be 'maxlen' + 1).\n *  Minimum for \"maxlen\" is 3!!!!\n *\n *  \"tb_change_cnt\" is the value of typebuf.tb_change_cnt if \"buf\" points into\n *  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received\n *  from a remote client) \"buf\" can no longer be used.  \"tb_change_cnt\" is 0\n *  otherwise.\n *\n *  If we got an interrupt all input is read until none is available.\n *\n *  If wait_time == 0  there is no waiting for the char.\n *  If wait_time == n  we wait for n msec for a character to arrive.\n *  If wait_time == -1 we wait forever for a character to arrive.\n *\n *  Return the number of obtained characters.\n *  Return -1 when end of input script reached.\n */\n    static int\ninchar(\n    char_u\t*buf,\n    int\t\tmaxlen,\n    long\twait_time)\t    // milliseconds\n{\n    int\t\tlen = 0;\t    // init for GCC\n    int\t\tretesc = FALSE;\t    // return ESC with gotint\n    int\t\tscript_char;\n    int\t\ttb_change_cnt = typebuf.tb_change_cnt;\n\n    if (wait_time == -1L || wait_time > 100L)  // flush output before waiting\n    {\n\tcursor_on();\n\tout_flush_cursor(FALSE, FALSE);\n#if defined(FEAT_GUI) && defined(FEAT_MOUSESHAPE)\n\tif (gui.in_use && postponed_mouseshape)\n\t    update_mouseshape(-1);\n#endif\n    }\n\n    /*\n     * Don't reset these when at the hit-return prompt, otherwise a endless\n     * recursive loop may result (write error in swapfile, hit-return, timeout\n     * on char wait, flush swapfile, write error....).\n     */\n    if (State != MODE_HITRETURN)\n    {\n\tdid_outofmem_msg = FALSE;   // display out of memory message (again)\n\tdid_swapwrite_msg = FALSE;  // display swap file write error again\n    }\n    undo_off = FALSE;\t\t    // restart undo now\n\n    /*\n     * Get a character from a script file if there is one.\n     * If interrupted: Stop reading script files, close them all.\n     */\n    script_char = -1;\n    while (scriptin[curscript] != NULL && script_char < 0\n#ifdef FEAT_EVAL\n\t    && !ignore_script\n#endif\n\t    )\n    {\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n\n\tif (got_int || (script_char = getc(scriptin[curscript])) < 0)\n\t{\n\t    // Reached EOF.\n\t    // Careful: closescript() frees typebuf.tb_buf[] and buf[] may\n\t    // point inside typebuf.tb_buf[].  Don't use buf[] after this!\n\t    closescript();\n\t    /*\n\t     * When reading script file is interrupted, return an ESC to get\n\t     * back to normal mode.\n\t     * Otherwise return -1, because typebuf.tb_buf[] has changed.\n\t     */\n\t    if (got_int)\n\t\tretesc = TRUE;\n\t    else\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    buf[0] = script_char;\n\t    len = 1;\n\t}\n    }\n\n    if (script_char < 0)\t// did not get a character from script\n    {\n\t/*\n\t * If we got an interrupt, skip all previously typed characters and\n\t * return TRUE if quit reading script file.\n\t * Stop reading typeahead when a single CTRL-C was read,\n\t * fill_input_buf() returns this when not able to read from stdin.\n\t * Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]\n\t * and buf may be pointing inside typebuf.tb_buf[].\n\t */\n\tif (got_int)\n\t{\n#define DUM_LEN (MAXMAPLEN * 3 + 3)\n\t    char_u\tdum[DUM_LEN + 1];\n\n\t    for (;;)\n\t    {\n\t\tlen = ui_inchar(dum, DUM_LEN, 0L, 0);\n\t\tif (len == 0 || (len == 1 && dum[0] == Ctrl_C))\n\t\t    break;\n\t    }\n\t    return retesc;\n\t}\n\n\t/*\n\t * Always flush the output characters when getting input characters\n\t * from the user and not just peeking.\n\t */\n\tif (wait_time == -1L || wait_time > 10L)\n\t    out_flush();\n\n\t/*\n\t * Fill up to a third of the buffer, because each character may be\n\t * tripled below.\n\t */\n\tlen = ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt);\n    }\n\n    // If the typebuf was changed further down, it is like nothing was added by\n    // this call.\n    if (typebuf_changed(tb_change_cnt))\n\treturn 0;\n\n    // Note the change in the typeahead buffer, this matters for when\n    // vgetorpeek() is called recursively, e.g. using getchar(1) in a timer\n    // function.\n    if (len > 0 && ++typebuf.tb_change_cnt == 0)\n\ttypebuf.tb_change_cnt = 1;\n\n    return fix_input_buffer(buf, len);\n}\n\n/*\n * Fix typed characters for use by vgetc() and check_termcode().\n * \"buf[]\" must have room to triple the number of bytes!\n * Returns the new length.\n */\n    int\nfix_input_buffer(char_u *buf, int len)\n{\n    int\t\ti;\n    char_u\t*p = buf;\n\n    /*\n     * Two characters are special: NUL and K_SPECIAL.\n     * When compiled With the GUI CSI is also special.\n     * Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER\n     * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER\n     * Replace       CSI by K_SPECIAL KS_EXTRA   KE_CSI\n     */\n    for (i = len; --i >= 0; ++p)\n    {\n#ifdef FEAT_GUI\n\t// When the GUI is used any character can come after a CSI, don't\n\t// escape it.\n\tif (gui.in_use && p[0] == CSI && i >= 2)\n\t{\n\t    p += 2;\n\t    i -= 2;\n\t}\n# ifndef MSWIN\n\t// When not on MS-Windows and the GUI is not used CSI needs to be\n\t// escaped.\n\telse if (!gui.in_use && p[0] == CSI)\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    *p++ = K_SPECIAL;\n\t    *p++ = KS_EXTRA;\n\t    *p = (int)KE_CSI;\n\t    len += 2;\n\t}\n# endif\n\telse\n#endif\n\tif (p[0] == NUL || (p[0] == K_SPECIAL\n\t\t    // timeout may generate K_CURSORHOLD\n\t\t    && (i < 2 || p[1] != KS_EXTRA || p[2] != (int)KE_CURSORHOLD)\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t\t    // Win32 console passes modifiers\n\t\t    && (\n# ifdef VIMDLL\n\t\t\tgui.in_use ||\n# endif\n\t\t\t(i < 2 || p[1] != KS_MODIFIER))\n#endif\n\t\t    ))\n\t{\n\t    mch_memmove(p + 3, p + 1, (size_t)i);\n\t    p[2] = K_THIRD(p[0]);\n\t    p[1] = K_SECOND(p[0]);\n\t    p[0] = K_SPECIAL;\n\t    p += 2;\n\t    len += 2;\n\t}\n    }\n    *p = NUL;\t\t// add trailing NUL\n    return len;\n}\n\n#if defined(USE_INPUT_BUF) || defined(PROTO)\n/*\n * Return TRUE when bytes are in the input buffer or in the typeahead buffer.\n * Normally the input buffer would be sufficient, but the server_to_input_buf()\n * or feedkeys() may insert characters in the typeahead buffer while we are\n * waiting for input to arrive.\n */\n    int\ninput_available(void)\n{\n    return (!vim_is_input_buf_empty()\n# if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    || typebuf_was_filled\n# endif\n\t    );\n}\n#endif\n\n/*\n * Function passed to do_cmdline() to get the command after a <Cmd> key from\n * typeahead.\n */\n    static char_u *\ngetcmdkeycmd(\n\tint\t\tpromptc UNUSED,\n\tvoid\t\t*cookie UNUSED,\n\tint\t\tindent UNUSED,\n\tgetline_opt_T\tdo_concat UNUSED)\n{\n    garray_T\tline_ga;\n    int\t\tc1 = -1;\n    int\t\tc2;\n    int\t\tcmod = 0;\n    int\t\taborted = FALSE;\n\n    ga_init2(&line_ga, 1, 32);\n\n    // no mapping for these characters\n    no_mapping++;\n\n    got_int = FALSE;\n    while (c1 != NUL && !aborted)\n    {\n\tif (ga_grow(&line_ga, 32) == FAIL)\n\t{\n\t    aborted = TRUE;\n\t    break;\n\t}\n\n\tif (vgetorpeek(FALSE) == NUL)\n\t{\n\t    // incomplete <Cmd> is an error, because there is not much the user\n\t    // could do in this state.\n\t    emsg(_(e_cmd_mapping_must_end_with_cr));\n\t    aborted = TRUE;\n\t    break;\n\t}\n\n\t// Get one character at a time.\n\tc1 = vgetorpeek(TRUE);\n\n\t// Get two extra bytes for special keys\n\tif (c1 == K_SPECIAL)\n\t{\n\t    c1 = vgetorpeek(TRUE);\n\t    c2 = vgetorpeek(TRUE);\n\t    if (c1 == KS_MODIFIER)\n\t    {\n\t\tcmod = c2;\n\t\tcontinue;\n\t    }\n\t    c1 = TO_SPECIAL(c1, c2);\n\n\t    // K_ESC is used to avoid ambiguity with the single Esc character\n\t    // that might be the start of an escape sequence.  Convert it back\n\t    // to a single Esc here.\n\t    if (c1 == K_ESC)\n\t\tc1 = ESC;\n\t}\n\tif (c1 == Ctrl_V)\n\t{\n\t    // CTRL-V is followed by octal, hex or other characters, reverses\n\t    // what AppendToRedobuffLit() does.\n\t    ++no_reduce_keys;  //  don't merge modifyOtherKeys\n\t    c1 = get_literal(TRUE);\n\t    --no_reduce_keys;\n\t}\n\n\tif (got_int)\n\t    aborted = TRUE;\n\telse if (c1 == '\\r' || c1 == '\\n')\n\t    c1 = NUL;  // end the line\n\telse if (c1 == ESC)\n\t    aborted = TRUE;\n\telse if (c1 == K_COMMAND || c1 == K_SCRIPT_COMMAND)\n\t{\n\t    // give a nicer error message for this special case\n\t    emsg(_(e_cmd_mapping_must_end_with_cr_before_second_cmd));\n\t    aborted = TRUE;\n\t}\n\telse if (IS_SPECIAL(c1))\n\t{\n\t    if (c1 == K_SNR)\n\t\tga_concat(&line_ga, (char_u *)\"<SNR>\");\n\t    else\n\t    {\n\t\tsemsg(e_cmd_mapping_must_not_include_str_key,\n\t\t\t\t\t       get_special_key_name(c1, cmod));\n\t\taborted = TRUE;\n\t    }\n\t}\n\telse\n\t    ga_append(&line_ga, c1);\n\n\tcmod = 0;\n    }\n\n    no_mapping--;\n\n    if (aborted)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If there was a mapping we get its SID.  Otherwise, use \"last_used_sid\", it\n * is set when redo'ing.\n * Put this SID in the redo buffer, so that \".\" will use the same script\n * context.\n */\n    void\nmay_add_last_used_map_to_redobuff(void)\n{\n    char_u  buf[3 + 20];\n    int\t    sid = -1;\n\n    if (last_used_map != NULL)\n\tsid = last_used_map->m_script_ctx.sc_sid;\n    if (sid < 0)\n\tsid = last_used_sid;\n\n    if (sid < 0)\n\treturn;\n\n    // <K_SID>{nr};\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = KE_SID;\n    vim_snprintf((char *)buf + 3, 20, \"%d;\", sid);\n    add_buff(&redobuff, buf, -1L);\n}\n#endif\n\n    int\ndo_cmdkey_command(int key UNUSED, int flags)\n{\n    int\t    res;\n#ifdef FEAT_EVAL\n    sctx_T  save_current_sctx = {-1, 0, 0, 0};\n\n    if (key == K_SCRIPT_COMMAND\n\t\t  && (last_used_map != NULL || SCRIPT_ID_VALID(last_used_sid)))\n    {\n\tsave_current_sctx = current_sctx;\n\tif (last_used_map != NULL)\n\t    current_sctx = last_used_map->m_script_ctx;\n\telse\n\t{\n\t    current_sctx.sc_sid = last_used_sid;\n\t    current_sctx.sc_lnum = 0;\n\t    current_sctx.sc_version = SCRIPT_ITEM(last_used_sid)->sn_version;\n\t}\n    }\n#endif\n\n    res = do_cmdline(NULL, getcmdkeycmd, NULL, flags);\n\n#ifdef FEAT_EVAL\n    if (save_current_sctx.sc_sid >= 0)\n\tcurrent_sctx = save_current_sctx;\n#endif\n\n    return res;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\nreset_last_used_map(mapblock_T *mp)\n{\n    if (last_used_map != mp)\n\treturn;\n\n    last_used_map = NULL;\n    last_used_sid = -1;\n}\n#endif\n", "\" Functions about terminal shared by several tests\n\n\" Only load this script once.\nif exists('*CanRunVimInTerminal')\n  finish\nendif\n\nsource shared.vim\n\n\" For most tests we need to be able to run terminal Vim with 256 colors.  On\n\" MS-Windows the console only has 16 colors and the GUI can't run in a\n\" terminal.\nfunc CanRunVimInTerminal()\n  return has('terminal') && !has('win32')\nendfunc\n\n\" Skip the rest if there is no terminal feature at all.\nif !has('terminal')\n  finish\nendif\n\n\" Stops the shell running in terminal \"buf\".\nfunc StopShellInTerminal(buf)\n  call term_sendkeys(a:buf, \"exit\\r\")\n  let job = term_getjob(a:buf)\n  call WaitForAssert({-> assert_equal(\"dead\", job_status(job))})\n  call TermWait(a:buf)\nendfunc\n\n\" Wrapper around term_wait() to allow more time for re-runs of flaky tests\n\" The second argument is the minimum time to wait in msec, 10 if omitted.\nfunc TermWait(buf, ...)\n  let wait_time = a:0 ? a:1 : 10\n  if exists('g:run_nr')\n    if g:run_nr == 2\n      let wait_time *= 4\n    elseif g:run_nr > 2\n      let wait_time *= 10\n    endif\n  endif\n  call term_wait(a:buf, wait_time)\n\n  \" In case it wasn't set yet.\n  let g:test_is_flaky = 1\nendfunc\n\n\" Run Vim with \"arguments\" in a new terminal window.\n\" By default uses a size of 20 lines and 75 columns.\n\" Returns the buffer number of the terminal.\n\"\n\" Options is a dictionary, these items are recognized:\n\" \"keep_t_u7\" - when 1 do not make t_u7 empty (resetting t_u7 avoids clearing\n\"               parts of line 2 and 3 on the display)\n\" \"rows\" - height of the terminal window (max. 20)\n\" \"cols\" - width of the terminal window (max. 78)\n\" \"statusoff\" - number of lines the status is offset from default\n\" \"wait_for_ruler\" - if zero then don't wait for ruler to show\n\" \"no_clean\" - if non-zero then remove \"--clean\" from the command\nfunc RunVimInTerminal(arguments, options)\n  \" If Vim doesn't exit a swap file remains, causing other tests to fail.\n  \" Remove it here.\n  call delete(\".swp\")\n\n  if exists('$COLORFGBG')\n    \" Clear $COLORFGBG to avoid 'background' being set to \"dark\", which will\n    \" only be corrected if the response to t_RB is received, which may be too\n    \" late.\n    let $COLORFGBG = ''\n  endif\n\n  \" Make a horizontal and vertical split, so that we can get exactly the right\n  \" size terminal window.  Works only when the current window is full width.\n  call assert_equal(&columns, winwidth(0))\n  split\n  vsplit\n\n  \" Always do this with 256 colors and a light background.\n  set t_Co=256 background=light\n  hi Normal ctermfg=NONE ctermbg=NONE\n\n  \" Make the window 20 lines high and 75 columns, unless told otherwise or\n  \" 'termwinsize' is set.\n  let rows = get(a:options, 'rows', 20)\n  let cols = get(a:options, 'cols', 75)\n  let statusoff = get(a:options, 'statusoff', 1)\n\n  if get(a:options, 'keep_t_u7', 0)\n    let reset_u7 = ''\n  else\n    let reset_u7 = ' --cmd \"set t_u7=\" '\n  endif\n\n  let cmd = GetVimCommandCleanTerm() .. reset_u7 .. a:arguments\n\n  if get(a:options, 'no_clean', 0)\n    let cmd = substitute(cmd, '--clean', '', '')\n  endif\n\n  let options = #{curwin: 1}\n  if &termwinsize == ''\n    let options.term_rows = rows\n    let options.term_cols = cols\n  endif\n\n  \" Accept other options whose name starts with 'term_'.\n  call extend(options, filter(copy(a:options), 'v:key =~# \"^term_\"'))\n\n  let buf = term_start(cmd, options)\n\n  if &termwinsize == ''\n    \" in the GUI we may end up with a different size, try to set it.\n    if term_getsize(buf) != [rows, cols]\n      call term_setsize(buf, rows, cols)\n    endif\n    call assert_equal([rows, cols], term_getsize(buf))\n  else\n    let rows = term_getsize(buf)[0]\n    let cols = term_getsize(buf)[1]\n  endif\n\n  call TermWait(buf)\n\n  if get(a:options, 'wait_for_ruler', 1)\n    \" Wait for \"All\" or \"Top\" of the ruler to be shown in the last line or in\n    \" the status line of the last window. This can be quite slow (e.g. when\n    \" using valgrind).\n    \" If it fails then show the terminal contents for debugging.\n    try\n      call WaitFor({-> len(term_getline(buf, rows)) >= cols - 1 || len(term_getline(buf, rows - statusoff)) >= cols - 1})\n    catch /timed out after/\n      let lines = map(range(1, rows), {key, val -> term_getline(buf, val)})\n      call assert_report('RunVimInTerminal() failed, screen contents: ' . join(lines, \"<NL>\"))\n    endtry\n  endif\n\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  return buf\nendfunc\n\n\" Stop a Vim running in terminal buffer \"buf\".\nfunc StopVimInTerminal(buf, kill = 1)\n  \" Using a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  call assert_equal(\"running\", term_getstatus(a:buf))\n\n  \" Wait for all the pending updates to terminal to complete\n  call TermWait(a:buf)\n\n  \" CTRL-O : works both in Normal mode and Insert mode to start a command line.\n  \" In Command-line it's inserted, the CTRL-U removes it again.\n  call term_sendkeys(a:buf, \"\\<C-O>:\\<C-U>qa!\\<cr>\")\n\n  \" Wait for all the pending updates to terminal to complete\n  call TermWait(a:buf)\n\n  \" Wait for the terminal to end.\n  call WaitForAssert({-> assert_equal(\"finished\", term_getstatus(a:buf))})\n\n  \" If the buffer still exists forcefully wipe it.\n  if a:kill && bufexists(a:buf)\n    exe a:buf .. 'bwipe!'\n  endif\nendfunc\n\n\" Open a terminal with a shell, assign the job to g:job and return the buffer\n\" number.\nfunc Run_shell_in_terminal(options)\n  if has('win32')\n    let buf = term_start([&shell, '/k'], a:options)\n  else\n    let buf = term_start(&shell, a:options)\n  endif\n  let g:test_is_flaky = 1\n\n  let termlist = term_list()\n  call assert_equal(1, len(termlist))\n  call assert_equal(buf, termlist[0])\n\n  let g:job = term_getjob(buf)\n  call assert_equal(v:t_job, type(g:job))\n\n  let string = string({'job': buf->term_getjob()})\n  call assert_match(\"{'job': 'process \\\\d\\\\+ run'}\", string)\n\n  \" On slower systems it may take a bit of time before the shell is ready to\n  \" accept keys.  This mainly matters when using term_sendkeys() next.\n  call TermWait(buf)\n\n  return buf\nendfunc\n\n\" Return concatenated lines in terminal.\nfunc Term_getlines(buf, lines)\n  return join(map(a:lines, 'term_getline(a:buf, v:val)'), '')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "\" Test editing line in Ex mode (see :help Q and :help gQ).\n\nsource check.vim\nsource shared.vim\n\n\" Helper function to test editing line in Q Ex mode\nfunc Ex_Q(cmd)\n  \" Is there a simpler way to test editing Ex line?\n  call feedkeys(\"Q\"\n        \\    .. \"let s:test_ex =<< END\\<CR>\"\n        \\    .. a:cmd .. \"\\<CR>\"\n        \\    .. \"END\\<CR>\"\n        \\    .. \"visual\\<CR>\", 'tx')\n  return s:test_ex[0]\nendfunc\n\n\" Helper function to test editing line in gQ Ex mode\nfunc Ex_gQ(cmd)\n  call feedkeys(\"gQ\" .. a:cmd .. \"\\<C-b>\\\"\\<CR>\", 'tx')\n  let ret = @:[1:] \" Remove leading quote.\n  call feedkeys(\"visual\\<CR>\", 'tx')\n  return ret\nendfunc\n\n\" Helper function to test editing line with both Q and gQ Ex mode.\nfunc Ex(cmd)\n return [Ex_Q(a:cmd), Ex_gQ(a:cmd)]\nendfunc\n\n\" Test editing line in Ex mode (both Q and gQ)\nfunc Test_ex_mode()\n  let encoding_save = &encoding\n  set sw=2\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call assert_equal(['bar', 'bar'],             Ex(\"foo bar\\<C-u>bar\"), e)\n    call assert_equal([\"1\\<C-u>2\", \"1\\<C-u>2\"],   Ex(\"1\\<C-v>\\<C-u>2\"), e)\n    call assert_equal([\"1\\<C-b>2\\<C-e>3\", '213'], Ex(\"1\\<C-b>2\\<C-e>3\"), e)\n    call assert_equal(['0123', '2013'],           Ex(\"01\\<Home>2\\<End>3\"), e)\n    call assert_equal(['0123', '0213'],           Ex(\"01\\<Left>2\\<Right>3\"), e)\n    call assert_equal(['01234', '0342'],          Ex(\"012\\<Left>\\<Left>\\<Insert>3\\<Insert>4\"), e)\n    call assert_equal([\"foo bar\\<C-w>\", 'foo '],  Ex(\"foo bar\\<C-w>\"), e)\n    call assert_equal(['foo', 'foo'],             Ex(\"fooba\\<Del>\\<Del>\"), e)\n    call assert_equal([\"foo\\tbar\", 'foobar'],     Ex(\"foo\\<Tab>bar\"), e)\n    call assert_equal([\"abbrev\\t\", 'abbreviate'], Ex(\"abbrev\\<Tab>\"), e)\n    call assert_equal(['    1', \"1\\<C-t>\\<C-t>\"], Ex(\"1\\<C-t>\\<C-t>\"), e)\n    call assert_equal(['  1', \"1\\<C-t>\\<C-t>\"],   Ex(\"1\\<C-t>\\<C-t>\\<C-d>\"), e)\n    call assert_equal(['  foo', '    foo'],       Ex(\"    foo\\<C-d>\"), e)\n    call assert_equal(['foo', '    foo0'],        Ex(\"    foo0\\<C-d>\"), e)\n    call assert_equal(['foo', '    foo^'],        Ex(\"    foo^\\<C-d>\"), e)\n    call assert_equal(['foo', 'foo'],\n          \\ Ex(\"\\<BS>\\<C-H>\\<Del>\\<kDel>foo\"), e)\n    \" default wildchar <Tab> interferes with this test\n    set wildchar=<c-e>\n    call assert_equal([\"a\\tb\", \"a\\tb\"],           Ex(\"a\\t\\t\\<C-H>b\"), e)\n    call assert_equal([\"\\t  mn\", \"\\tm\\<C-T>n\"],        Ex(\"\\tm\\<C-T>n\"), e)\n    set wildchar&\n  endfor\n\n  set sw&\n  let &encoding = encoding_save\nendfunc\n\n\" Test substitute confirmation prompt :%s/pat/str/c in Ex mode\nfunc Test_Ex_substitute()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  call term_sendkeys(buf, \":call setline(1, ['foo foo', 'foo foo', 'foo foo'])\\<CR>\")\n  call term_sendkeys(buf, \":set number\\<CR>\")\n  call term_sendkeys(buf, \"gQ\")\n  call WaitForAssert({-> assert_match(':', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \"%s/foo/bar/gc\\<CR>\")\n  call WaitForAssert({-> assert_match('  1 foo foo', term_getline(buf, 5))},\n        \\ 1000)\n  call WaitForAssert({-> assert_match('    ^^^', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \"N\\<CR>\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_match('    ^^^', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \"n\\<CR>\")\n  call WaitForAssert({-> assert_match('        ^^^', term_getline(buf, 6))},\n        \\ 1000)\n  call term_sendkeys(buf, \"y\\<CR>\")\n\n  call term_sendkeys(buf, \"q\\<CR>\")\n  call WaitForAssert({-> assert_match(':', term_getline(buf, 6))}, 1000)\n\n  \" Pressing enter in ex mode should print the current line\n  call term_sendkeys(buf, \"\\<CR>\")\n  call WaitForAssert({-> assert_match('  3 foo foo',\n        \\ term_getline(buf, 5))}, 1000)\n\n  call term_sendkeys(buf, \":vi\\<CR>\")\n  call WaitForAssert({-> assert_match('foo bar', term_getline(buf, 1))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for displaying lines from an empty buffer in Ex mode\nfunc Test_Ex_emptybuf()\n  new\n  call assert_fails('call feedkeys(\"Q\\<CR>\", \"xt\")', 'E749:')\n  call setline(1, \"abc\")\n  call assert_fails('call feedkeys(\"Q\\<CR>\", \"xt\")', 'E501:')\n  call assert_fails('call feedkeys(\"Q%d\\<CR>\", \"xt\")', 'E749:')\n  close!\nendfunc\n\n\" Test for the :open command\nfunc Test_open_command()\n  new\n  call setline(1, ['foo foo', 'foo bar', 'foo baz'])\n  call feedkeys(\"Qopen\\<CR>j\", 'xt')\n  call assert_equal('foo bar', getline('.'))\n  call feedkeys(\"Qopen /bar/\\<CR>\", 'xt')\n  call assert_equal(5, col('.'))\n  call assert_fails('call feedkeys(\"Qopen /baz/\\<CR>\", \"xt\")', 'E479:')\n  close!\nendfunc\n\nfunc Test_open_command_flush_line()\n  \" this was accessing freed memory: the regexp match uses a pointer to the\n  \" current line which becomes invalid when searching for the ') mark.\n  new\n  call setline(1, ['one', 'two. three'])\n  s/one/ONE\n  try\n    open /\\%')/\n  catch /E479/\n  endtry\n  bwipe!\nendfunc\n\n\" FIXME: this doesn't fail without the fix but hangs\nfunc Skip_Test_open_command_state()\n  \" Tricky script that failed because State was not set properly\n  let lines =<< trim END\n      !ls \u0083\n      0sc\u00eci\n      so! Xsourced\n      set t_\u00fb0=0\n      v/-/o\n  END\n  call writefile(lines, 'XopenScript', '')\n\n  let sourced = [\"!f\\u0083\\x02\\<Esc>z=0\"]\n  call writefile(sourced, 'Xsourced', 'b')\n\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('-u NONE -i NONE -n -m -X -Z -e -s -S XopenScript -c qa!', #{rows: 6, wait_for_ruler: 0, no_clean: 1})\n  sleep 3\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for :g/pat/visual to run vi commands in Ex mode\n\" This used to hang Vim before 8.2.0274.\nfunc Test_Ex_global()\n  new\n  call setline(1, ['', 'foo', 'bar', 'foo', 'bar', 'foo'])\n  call feedkeys(\"Q\\<bs>g/bar/visual\\<CR>$rxQ$ryQvisual\\<CR>j\", \"xt\")\n  call assert_equal('bax', getline(3))\n  call assert_equal('bay', getline(5))\n  bwipe!\nendfunc\n\n\" Test for pressing Ctrl-C in :append inside a loop in Ex mode\n\" This used to hang Vim\nfunc Test_Ex_append_in_loop()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  call term_sendkeys(buf, \"gQ\")\n  call term_sendkeys(buf, \"for i in range(1)\\<CR>\")\n  call term_sendkeys(buf, \"append\\<CR>\")\n  call WaitForAssert({-> assert_match(':  append', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \"\\<C-C>\")\n  \" Wait for input to be flushed\n  call term_wait(buf)\n  call term_sendkeys(buf, \"foo\\<CR>\")\n  call WaitForAssert({-> assert_match('foo', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \".\\<CR>\")\n  call WaitForAssert({-> assert_match('.', term_getline(buf, 5))}, 1000)\n  call term_sendkeys(buf, \"endfor\\<CR>\")\n  call term_sendkeys(buf, \"vi\\<CR>\")\n  call WaitForAssert({-> assert_match('foo', term_getline(buf, 1))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" In Ex-mode, a backslash escapes a newline\nfunc Test_Ex_escape_enter()\n  call feedkeys(\"gQlet l = \\\"a\\\\\\<kEnter>b\\\"\\<cr>vi\\<cr>\", 'xt')\n  call assert_equal(\"a\\rb\", l)\nendfunc\n\n\" Test for :append! command in Ex mode\nfunc Test_Ex_append()\n  new\n  call setline(1, \"\\t   abc\")\n  call feedkeys(\"Qappend!\\npqr\\nxyz\\n.\\nvisual\\n\", 'xt')\n  call assert_equal([\"\\t   abc\", \"\\t   pqr\", \"\\t   xyz\"], getline(1, '$'))\n  close!\nendfunc\n\n\" In Ex-mode, backslashes at the end of a command should be halved.\nfunc Test_Ex_echo_backslash()\n  \" This test works only when the language is English\n  CheckEnglish\n  let bsl = '\\\\\\\\'\n  let bsl2 = '\\\\\\'\n  call assert_fails('call feedkeys(\"Qecho \" .. bsl .. \"\\nvisual\\n\", \"xt\")',\n        \\ 'E15: Invalid expression: \"\\\\\"')\n  call assert_fails('call feedkeys(\"Qecho \" .. bsl2 .. \"\\nm\\nvisual\\n\", \"xt\")',\n        \\ \"E15: Invalid expression: \\\"\\\\\\nm\\\"\")\nendfunc\n\nfunc Test_ex_mode_errors()\n  \" Not allowed to enter ex mode when text is locked\n  au InsertCharPre <buffer> normal! gQ<CR>\n  let caught_e565 = 0\n  try\n    call feedkeys(\"ix\\<esc>\", 'xt')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n    let caught_e565 = 1\n  endtry\n  call assert_equal(1, caught_e565)\n  au! InsertCharPre\n\n  new\n  au CmdLineEnter * call ExEnterFunc()\n  func ExEnterFunc()\n\n  endfunc\n  call feedkeys(\"gQvi\\r\", 'xt')\n\n  au! CmdLineEnter\n  delfunc ExEnterFunc\n  quit\nendfunc\n\nfunc Test_ex_mode_with_global()\n  CheckNotGui\n  CheckFeature timers\n\n  \" This will get stuck in Normal mode after the failed \"J\", use a timer to\n  \" get going again.\n  let lines =<< trim END\n    call ch_logfile('logfile', 'w')\n    pedit\n    func FeedQ(id)\n      call feedkeys('Q', 't')\n    endfunc\n    call timer_start(10, 'FeedQ')\n    g/^/vi|HJ\n    call writefile(['done'], 'Xdidexmode')\n    qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-e -s -S Xexmodescript'))\n  call assert_equal(['done'], readfile('Xdidexmode'))\n\n  call delete('logfile')\n  call delete('Xdidexmode')\nendfunc\n\nfunc Test_ex_mode_count_overflow()\n  \" The multiplication causes an integer overflow\n  CheckNotAsan\n\n  \" this used to cause a crash\n  let lines =<< trim END\n    call feedkeys(\"\\<Esc>Q\\<CR>\")\n    v9|9silent! vi|333333233333y32333333%O\n    call writefile(['done'], 'Xdidexmode')\n    qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-e -s -S Xexmodescript -c qa'))\n  call assert_equal(['done'], readfile('Xdidexmode'))\n\n  call delete('Xdidexmode')\nendfunc\n\nfunc Test_ex_mode_large_indent()\n  new\n  set ts=500 ai\n  call setline(1, \"\\t\")\n  exe \"normal gQi\\<CR>.\"\n  set ts=8 noai\n  bwipe!\nendfunc\n\n\" This was accessing illegal memory when using \"+\" for eap->cmd.\nfunc Test_empty_command_visual_mode()\n  let lines =<< trim END\n      r<sfile>\n      0norm0V:\u001b\n      :qall!\n  END\n  call writefile(lines, 'Xexmodescript', 'D')\n  call assert_equal(1, RunVim([], [], '-u NONE -e -s -S Xexmodescript'))\n\n  \" This may cause a dialog to be displayed for an empty command, ignore it.\n  call delete('guidialogfile')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/getchar.c", "src/testdir/term_util.vim", "src/testdir/test_ex_mode.vim", "src/version.c"], "buggy_code_start_loc": [3110, 57, 136, 697], "buggy_code_end_loc": [3558, 92, 136, 697], "fixing_code_start_loc": [3110, 58, 137, 698], "fixing_code_end_loc": [3561, 98, 159, 700], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1392.", "other": {"cve": {"id": "CVE-2023-1264", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-07T22:15:10.723", "lastModified": "2023-04-02T03:15:10.810", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1392."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1392", "matchCriteriaId": "4B617E9D-94A8-48C9-8C86-8022B1E8F813"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/7ac5023a5f1a37baafbe1043645f97ba3443d9f6", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/b2989095-88f3-413a-9a39-c1c58a6e6815", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DIAKPMKJ4OZ6NYRZJO7YWMNQL2BICLYV/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X4KDAU76Z7QNSPKZX2JAJ6O7KIEOXWTL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/7ac5023a5f1a37baafbe1043645f97ba3443d9f6"}}