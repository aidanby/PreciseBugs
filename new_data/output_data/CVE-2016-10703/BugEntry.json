{"buggy_code": ["#! /usr/bin/env node\n\nvar path = require('path'),\n    fs = require('fs'),\n    url = require('url'),\n    mime = require('mime'),\n    urlJoin = require('url-join'),\n    showDir = require('./ecstatic/showdir'),\n    version = JSON.parse(\n      fs.readFileSync(__dirname + '/../package.json').toString()\n    ).version,\n    status = require('./ecstatic/status-handlers'),\n    generateEtag = require('./ecstatic/etag'),\n    optsParser = require('./ecstatic/opts');\n\nvar ecstatic = module.exports = function (dir, options) {\n  if (typeof dir !== 'string') {\n    options = dir;\n    dir = options.root;\n  }\n\n  var root = path.join(path.resolve(dir), '/'),\n      opts = optsParser(options),\n      cache = opts.cache,\n      autoIndex = opts.autoIndex,\n      baseDir = opts.baseDir,\n      defaultExt = opts.defaultExt,\n      handleError = opts.handleError,\n      headers = opts.headers,\n      serverHeader = opts.serverHeader,\n      weakEtags = opts.weakEtags,\n      handleOptionsMethod = opts.handleOptionsMethod;\n\n  opts.root = dir;\n  if (defaultExt && /^\\./.test(defaultExt)) defaultExt = defaultExt.replace(/^\\./, '');\n\n  // Support hashes and .types files in mimeTypes @since 0.8\n  if (opts.mimeTypes) {\n    try {\n      // You can pass a JSON blob here---useful for CLI use\n      opts.mimeTypes = JSON.parse(opts.mimeTypes);\n    } catch (e) {}\n    if (typeof opts.mimeTypes === 'string') {\n      mime.load(opts.mimeTypes);\n    }\n    else if (typeof opts.mimeTypes === 'object') {\n      mime.define(opts.mimeTypes);\n    }\n  }\n\n\n  return function middleware (req, res, next) {\n\n    // Strip any null bytes from the url\n    while(req.url.indexOf('%00') !== -1) {\n      req.url = req.url.replace(/\\%00/g, '');\n    }\n    // Figure out the path for the file from the given url\n    var parsed = url.parse(req.url);\n    try {\n      decodeURIComponent(req.url); // check validity of url\n      var pathname = decodePathname(parsed.pathname);\n    }\n    catch (err) {\n      return status[400](res, next, { error: err });\n    }\n\n    var file = path.normalize(\n          path.join(root,\n            path.relative(\n              path.join('/', baseDir),\n              pathname\n            )\n          )\n        ),\n        gzipped = file + '.gz';\n\n    if(serverHeader !== false) {\n      // Set common headers.\n      res.setHeader('server', 'ecstatic-'+version);\n    }\n    Object.keys(headers).forEach(function (key) {\n      res.setHeader(key, headers[key])\n    })\n\n    if (req.method === 'OPTIONS' && handleOptionsMethod) {\n      return res.end();\n    }\n\n    // TODO: This check is broken, which causes the 403 on the\n    // expected 404.\n    if (file.slice(0, root.length) !== root) {\n      return status[403](res, next);\n    }\n\n    if (req.method && (req.method !== 'GET' && req.method !== 'HEAD' )) {\n      return status[405](res, next);\n    }\n\n    function statFile() {\n      fs.stat(file, function (err, stat) {\n        if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {\n          if (req.statusCode == 404) {\n            // This means we're already trying ./404.html and can not find it.\n            // So send plain text response with 404 status code\n            status[404](res, next);\n          }\n          else if (!path.extname(parsed.pathname).length && defaultExt) {\n            // If there is no file extension in the path and we have a default\n            // extension try filename and default extension combination before rendering 404.html.\n            middleware({\n              url: parsed.pathname + '.' + defaultExt + ((parsed.search)? parsed.search:'')\n            }, res, next);\n          }\n          else {\n            // Try to serve default ./404.html\n            middleware({\n              url: (handleError ? ('/' + path.join(baseDir, '404.' + defaultExt)) : req.url),\n              statusCode: 404\n            }, res, next);\n          }\n        }\n        else if (err) {\n          status[500](res, next, { error: err });\n        }\n        else if (stat.isDirectory()) {\n          // 302 to / if necessary\n          if (!parsed.pathname.match(/\\/$/)) {\n            res.statusCode = 302;\n            res.setHeader('location', parsed.pathname + '/' +\n              (parsed.query? ('?' + parsed.query):'')\n            );\n            return res.end();\n          }\n\n          if (autoIndex) {\n            return middleware({\n              url: urlJoin(encodeURIComponent(pathname), '/index.' + defaultExt)\n            }, res, function (err) {\n              if (err) {\n                return status[500](res, next, { error: err });\n              }\n              if (opts.showDir) {\n                return showDir(opts, stat)(req, res);\n              }\n\n              return status[403](res, next);\n            });\n          }\n\n          if (opts.showDir) {\n            return showDir(opts, stat)(req, res);\n          }\n\n          status[404](res, next);\n\n        }\n        else {\n          serve(stat);\n        }\n      });\n    }\n\n    // Look for a gzipped file if this is turned on\n    if (opts.gzip && shouldCompress(req)) {\n      fs.stat(gzipped, function (err, stat) {\n        if (!err && stat.isFile()) {\n          file = gzipped;\n          return serve(stat);\n        } else {\n          statFile();\n        }\n      });\n    } else {\n      statFile();\n    }\n\n    function serve(stat) {\n      // Do a MIME lookup, fall back to octet-stream and handle gzip\n      // special case.\n      var defaultType = opts.contentType || 'application/octet-stream',\n          contentType = mime.lookup(file, defaultType),\n          charSet;\n\n      if (contentType) {\n        charSet = mime.charsets.lookup(contentType, 'utf-8');\n        if (charSet) {\n          contentType += '; charset=' + charSet;\n        }\n      }\n\n      if (path.extname(file) === '.gz') {\n        res.setHeader('Content-Encoding', 'gzip');\n\n        // strip gz ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, \".gz\"), defaultType);\n      }\n\n      var range = (req.headers && req.headers['range']);\n      if (range) {\n        var total = stat.size;\n        var parts = range.replace(/bytes=/, \"\").split(\"-\");\n        var partialstart = parts[0];\n        var partialend = parts[1];\n        var start = parseInt(partialstart, 10);\n        var end = Math.min(total-1, partialend ? parseInt(partialend, 10) : total-1);\n        var chunksize = (end-start)+1;\n        if (start > end || isNaN(start) || isNaN(end)) {\n          return status['416'](res, next);\n        }\n        var fstream = fs.createReadStream(file, {start: start, end: end});\n        fstream.on('error', function (err) {\n          status['500'](res, next, { error: err });\n        });\n        res.on('close', function () {\n           fstream.destroy();\n        });\n        res.writeHead(206, {\n          'Content-Range': 'bytes ' + start + '-' + end + '/' + total,\n          'Accept-Ranges': 'bytes',\n          'Content-Length': chunksize,\n          'Content-Type': contentType\n        });\n        fstream.pipe(res);\n        return;\n      }\n\n      // TODO: Helper for this, with default headers.\n      var lastModified = (new Date(stat.mtime)).toUTCString(),\n          etag = generateEtag(stat, weakEtags);\n      res.setHeader('last-modified', lastModified);\n      res.setHeader('etag', etag);\n\n      if (typeof cache === 'function') {\n        var requestSpecificCache = cache(pathname);\n        if (typeof requestSpecificCache === 'number') {\n          requestSpecificCache = 'max-age=' + requestSpecificCache;\n        }\n        res.setHeader('cache-control', requestSpecificCache);\n      } else {\n        res.setHeader('cache-control', cache);\n      }\n\n      // Return a 304 if necessary\n      if (shouldReturn304(req, lastModified, etag)) {\n        return status[304](res, next);\n      }\n\n      res.setHeader('content-length', stat.size);\n      res.setHeader('content-type', contentType);\n\n      // set the response statusCode if we have a request statusCode.\n      // This only can happen if we have a 404 with some kind of 404.html\n      // In all other cases where we have a file we serve the 200\n      res.statusCode = req.statusCode || 200;\n\n      if (req.method === \"HEAD\") {\n        return res.end();\n      }\n\n      var stream = fs.createReadStream(file);\n\n      stream.pipe(res);\n      stream.on('error', function (err) {\n        status['500'](res, next, { error: err });\n      });\n    }\n\n    function shouldReturn304(req, serverLastModified, serverEtag) {\n      if (!req || !req.headers) {\n        return false;\n      }\n\n      var clientModifiedSince = req.headers['if-modified-since'],\n          clientEtag = req.headers['if-none-match'];\n\n      if (!clientModifiedSince && !clientEtag) {\n        // Client did not provide any conditional caching headers\n        return false;\n      }\n\n      if (clientModifiedSince) {\n        // Catch \"illegal access\" dates that will crash v8\n        // https://github.com/jfhbrook/node-ecstatic/pull/179\n        try {\n          var clientModifiedDate = new Date(Date.parse(clientModifiedSince));\n        }\n        catch (err) { return false }\n\n        if (clientModifiedDate.toString() === 'Invalid Date') {\n          return false;\n        }\n        // If the client's copy is older than the server's, don't return 304\n        if (clientModifiedDate < new Date(serverLastModified)) {\n          return false;\n        }\n      }\n\n      if (clientEtag) {\n        // Do a strong or weak etag comparison based on setting\n        // https://www.ietf.org/rfc/rfc2616.txt Section 13.3.3\n        if (opts.weakCompare && clientEtag !== serverEtag\n          && clientEtag !== ('W/' + serverEtag) && ('W/' + clientEtag) !== serverEtag) {\n          return false;\n        } else if (!opts.weakCompare && (clientEtag !== serverEtag || clientEtag.indexOf('W/') === 0)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n};\n\necstatic.version = version;\necstatic.showDir = showDir;\n\n// Check to see if we should try to compress a file with gzip.\nfunction shouldCompress(req) {\n  var headers = req.headers;\n\n  return headers && headers['accept-encoding'] &&\n    headers['accept-encoding']\n      .split(\",\")\n      .some(function (el) {\n        return ['*','compress', 'gzip', 'deflate'].indexOf(el) != -1;\n      })\n    ;\n}\n\n// See: https://github.com/jesusabdullah/node-ecstatic/issues/109\nfunction decodePathname(pathname) {\n  var pieces = pathname.replace(/\\\\/g,\"/\").split('/');\n\n  return pieces.map(function (piece) {\n    piece = decodeURIComponent(piece);\n\n    if (process.platform === 'win32' && /\\\\/.test(piece)) {\n      throw new Error('Invalid forward slash character');\n    }\n\n    return piece;\n  }).join('/');\n}\n\nif (!module.parent) {\n  var defaults = require('./ecstatic/defaults.json')\n  var http = require('http'),\n      opts = require('minimist')(process.argv.slice(2), {\n        alias: require('./ecstatic/aliases.json'),\n        default: defaults,\n        boolean: Object.keys(defaults).filter(function (key) {\n          return typeof defaults[key] === 'boolean'\n        })\n      }),\n      envPORT = parseInt(process.env.PORT, 10),\n      port = envPORT > 1024 && envPORT <= 65536 ? envPORT : opts.port || opts.p || 8000,\n      dir = opts.root || opts._[0] || process.cwd();\n\n  if (opts.help || opts.h) {\n    var u = console.error;\n    u('usage: ecstatic [dir] {options} --port PORT');\n    u('see https://npm.im/ecstatic for more docs');\n    return;\n  }\n\n  http.createServer(ecstatic(dir, opts))\n    .listen(port, function () {\n      console.log('ecstatic serving ' + dir + ' at http://0.0.0.0:' + port);\n    });\n}\n"], "fixing_code": ["#! /usr/bin/env node\n\nvar path = require('path'),\n    fs = require('fs'),\n    url = require('url'),\n    mime = require('mime'),\n    urlJoin = require('url-join'),\n    showDir = require('./ecstatic/showdir'),\n    version = JSON.parse(\n      fs.readFileSync(__dirname + '/../package.json').toString()\n    ).version,\n    status = require('./ecstatic/status-handlers'),\n    generateEtag = require('./ecstatic/etag'),\n    optsParser = require('./ecstatic/opts');\n\nvar ecstatic = module.exports = function (dir, options) {\n  if (typeof dir !== 'string') {\n    options = dir;\n    dir = options.root;\n  }\n\n  var root = path.join(path.resolve(dir), '/'),\n      opts = optsParser(options),\n      cache = opts.cache,\n      autoIndex = opts.autoIndex,\n      baseDir = opts.baseDir,\n      defaultExt = opts.defaultExt,\n      handleError = opts.handleError,\n      headers = opts.headers,\n      serverHeader = opts.serverHeader,\n      weakEtags = opts.weakEtags,\n      handleOptionsMethod = opts.handleOptionsMethod;\n\n  opts.root = dir;\n  if (defaultExt && /^\\./.test(defaultExt)) defaultExt = defaultExt.replace(/^\\./, '');\n\n  // Support hashes and .types files in mimeTypes @since 0.8\n  if (opts.mimeTypes) {\n    try {\n      // You can pass a JSON blob here---useful for CLI use\n      opts.mimeTypes = JSON.parse(opts.mimeTypes);\n    } catch (e) {}\n    if (typeof opts.mimeTypes === 'string') {\n      mime.load(opts.mimeTypes);\n    }\n    else if (typeof opts.mimeTypes === 'object') {\n      mime.define(opts.mimeTypes);\n    }\n  }\n\n\n  return function middleware (req, res, next) {\n\n    // Strip any null bytes from the url\n    // This was at one point necessary because of an old bug in url.parse\n    //\n    // See: https://github.com/jfhbrook/node-ecstatic/issues/16#issuecomment-3039914\n    // See: https://github.com/jfhbrook/node-ecstatic/commit/43f7e72a31524f88f47e367c3cc3af710e67c9f4\n    //\n    // But this opens up a regex dos attack vector! D:\n    //\n    // Based on some research (ie asking #node-dev if this is still an issue),\n    // it's *probably* not an issue. :)\n    /*\n    while(req.url.indexOf('%00') !== -1) {\n      req.url = req.url.replace(/\\%00/g, '');\n    }\n    */\n\n    // Figure out the path for the file from the given url\n    var parsed = url.parse(req.url);\n    try {\n      decodeURIComponent(req.url); // check validity of url\n      var pathname = decodePathname(parsed.pathname);\n    }\n    catch (err) {\n      return status[400](res, next, { error: err });\n    }\n\n    var file = path.normalize(\n          path.join(root,\n            path.relative(\n              path.join('/', baseDir),\n              pathname\n            )\n          )\n        ),\n        gzipped = file + '.gz';\n\n    if(serverHeader !== false) {\n      // Set common headers.\n      res.setHeader('server', 'ecstatic-'+version);\n    }\n    Object.keys(headers).forEach(function (key) {\n      res.setHeader(key, headers[key])\n    })\n\n    if (req.method === 'OPTIONS' && handleOptionsMethod) {\n      return res.end();\n    }\n\n    // TODO: This check is broken, which causes the 403 on the\n    // expected 404.\n    if (file.slice(0, root.length) !== root) {\n      return status[403](res, next);\n    }\n\n    if (req.method && (req.method !== 'GET' && req.method !== 'HEAD' )) {\n      return status[405](res, next);\n    }\n\n    function statFile() {\n      fs.stat(file, function (err, stat) {\n        if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {\n          if (req.statusCode == 404) {\n            // This means we're already trying ./404.html and can not find it.\n            // So send plain text response with 404 status code\n            status[404](res, next);\n          }\n          else if (!path.extname(parsed.pathname).length && defaultExt) {\n            // If there is no file extension in the path and we have a default\n            // extension try filename and default extension combination before rendering 404.html.\n            middleware({\n              url: parsed.pathname + '.' + defaultExt + ((parsed.search)? parsed.search:'')\n            }, res, next);\n          }\n          else {\n            // Try to serve default ./404.html\n            middleware({\n              url: (handleError ? ('/' + path.join(baseDir, '404.' + defaultExt)) : req.url),\n              statusCode: 404\n            }, res, next);\n          }\n        }\n        else if (err) {\n          status[500](res, next, { error: err });\n        }\n        else if (stat.isDirectory()) {\n          // 302 to / if necessary\n          if (!parsed.pathname.match(/\\/$/)) {\n            res.statusCode = 302;\n            res.setHeader('location', parsed.pathname + '/' +\n              (parsed.query? ('?' + parsed.query):'')\n            );\n            return res.end();\n          }\n\n          if (autoIndex) {\n            return middleware({\n              url: urlJoin(encodeURIComponent(pathname), '/index.' + defaultExt)\n            }, res, function (err) {\n              if (err) {\n                return status[500](res, next, { error: err });\n              }\n              if (opts.showDir) {\n                return showDir(opts, stat)(req, res);\n              }\n\n              return status[403](res, next);\n            });\n          }\n\n          if (opts.showDir) {\n            return showDir(opts, stat)(req, res);\n          }\n\n          status[404](res, next);\n\n        }\n        else {\n          serve(stat);\n        }\n      });\n    }\n\n    // Look for a gzipped file if this is turned on\n    if (opts.gzip && shouldCompress(req)) {\n      fs.stat(gzipped, function (err, stat) {\n        if (!err && stat.isFile()) {\n          file = gzipped;\n          return serve(stat);\n        } else {\n          statFile();\n        }\n      });\n    } else {\n      statFile();\n    }\n\n    function serve(stat) {\n      // Do a MIME lookup, fall back to octet-stream and handle gzip\n      // special case.\n      var defaultType = opts.contentType || 'application/octet-stream',\n          contentType = mime.lookup(file, defaultType),\n          charSet;\n\n      if (contentType) {\n        charSet = mime.charsets.lookup(contentType, 'utf-8');\n        if (charSet) {\n          contentType += '; charset=' + charSet;\n        }\n      }\n\n      if (path.extname(file) === '.gz') {\n        res.setHeader('Content-Encoding', 'gzip');\n\n        // strip gz ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, \".gz\"), defaultType);\n      }\n\n      var range = (req.headers && req.headers['range']);\n      if (range) {\n        var total = stat.size;\n        var parts = range.replace(/bytes=/, \"\").split(\"-\");\n        var partialstart = parts[0];\n        var partialend = parts[1];\n        var start = parseInt(partialstart, 10);\n        var end = Math.min(total-1, partialend ? parseInt(partialend, 10) : total-1);\n        var chunksize = (end-start)+1;\n        if (start > end || isNaN(start) || isNaN(end)) {\n          return status['416'](res, next);\n        }\n        var fstream = fs.createReadStream(file, {start: start, end: end});\n        fstream.on('error', function (err) {\n          status['500'](res, next, { error: err });\n        });\n        res.on('close', function () {\n           fstream.destroy();\n        });\n        res.writeHead(206, {\n          'Content-Range': 'bytes ' + start + '-' + end + '/' + total,\n          'Accept-Ranges': 'bytes',\n          'Content-Length': chunksize,\n          'Content-Type': contentType\n        });\n        fstream.pipe(res);\n        return;\n      }\n\n      // TODO: Helper for this, with default headers.\n      var lastModified = (new Date(stat.mtime)).toUTCString(),\n          etag = generateEtag(stat, weakEtags);\n      res.setHeader('last-modified', lastModified);\n      res.setHeader('etag', etag);\n\n      if (typeof cache === 'function') {\n        var requestSpecificCache = cache(pathname);\n        if (typeof requestSpecificCache === 'number') {\n          requestSpecificCache = 'max-age=' + requestSpecificCache;\n        }\n        res.setHeader('cache-control', requestSpecificCache);\n      } else {\n        res.setHeader('cache-control', cache);\n      }\n\n      // Return a 304 if necessary\n      if (shouldReturn304(req, lastModified, etag)) {\n        return status[304](res, next);\n      }\n\n      res.setHeader('content-length', stat.size);\n      res.setHeader('content-type', contentType);\n\n      // set the response statusCode if we have a request statusCode.\n      // This only can happen if we have a 404 with some kind of 404.html\n      // In all other cases where we have a file we serve the 200\n      res.statusCode = req.statusCode || 200;\n\n      if (req.method === \"HEAD\") {\n        return res.end();\n      }\n\n      var stream = fs.createReadStream(file);\n\n      stream.pipe(res);\n      stream.on('error', function (err) {\n        status['500'](res, next, { error: err });\n      });\n    }\n\n    function shouldReturn304(req, serverLastModified, serverEtag) {\n      if (!req || !req.headers) {\n        return false;\n      }\n\n      var clientModifiedSince = req.headers['if-modified-since'],\n          clientEtag = req.headers['if-none-match'];\n\n      if (!clientModifiedSince && !clientEtag) {\n        // Client did not provide any conditional caching headers\n        return false;\n      }\n\n      if (clientModifiedSince) {\n        // Catch \"illegal access\" dates that will crash v8\n        // https://github.com/jfhbrook/node-ecstatic/pull/179\n        try {\n          var clientModifiedDate = new Date(Date.parse(clientModifiedSince));\n        }\n        catch (err) { return false }\n\n        if (clientModifiedDate.toString() === 'Invalid Date') {\n          return false;\n        }\n        // If the client's copy is older than the server's, don't return 304\n        if (clientModifiedDate < new Date(serverLastModified)) {\n          return false;\n        }\n      }\n\n      if (clientEtag) {\n        // Do a strong or weak etag comparison based on setting\n        // https://www.ietf.org/rfc/rfc2616.txt Section 13.3.3\n        if (opts.weakCompare && clientEtag !== serverEtag\n          && clientEtag !== ('W/' + serverEtag) && ('W/' + clientEtag) !== serverEtag) {\n          return false;\n        } else if (!opts.weakCompare && (clientEtag !== serverEtag || clientEtag.indexOf('W/') === 0)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n};\n\necstatic.version = version;\necstatic.showDir = showDir;\n\n// Check to see if we should try to compress a file with gzip.\nfunction shouldCompress(req) {\n  var headers = req.headers;\n\n  return headers && headers['accept-encoding'] &&\n    headers['accept-encoding']\n      .split(\",\")\n      .some(function (el) {\n        return ['*','compress', 'gzip', 'deflate'].indexOf(el) != -1;\n      })\n    ;\n}\n\n// See: https://github.com/jesusabdullah/node-ecstatic/issues/109\nfunction decodePathname(pathname) {\n  var pieces = pathname.replace(/\\\\/g,\"/\").split('/');\n\n  return pieces.map(function (piece) {\n    piece = decodeURIComponent(piece);\n\n    if (process.platform === 'win32' && /\\\\/.test(piece)) {\n      throw new Error('Invalid forward slash character');\n    }\n\n    return piece;\n  }).join('/');\n}\n\nif (!module.parent) {\n  var defaults = require('./ecstatic/defaults.json')\n  var http = require('http'),\n      opts = require('minimist')(process.argv.slice(2), {\n        alias: require('./ecstatic/aliases.json'),\n        default: defaults,\n        boolean: Object.keys(defaults).filter(function (key) {\n          return typeof defaults[key] === 'boolean'\n        })\n      }),\n      envPORT = parseInt(process.env.PORT, 10),\n      port = envPORT > 1024 && envPORT <= 65536 ? envPORT : opts.port || opts.p || 8000,\n      dir = opts.root || opts._[0] || process.cwd();\n\n  if (opts.help || opts.h) {\n    var u = console.error;\n    u('usage: ecstatic [dir] {options} --port PORT');\n    u('see https://npm.im/ecstatic for more docs');\n    return;\n  }\n\n  http.createServer(ecstatic(dir, opts))\n    .listen(port, function () {\n      console.log('ecstatic serving ' + dir + ' at http://0.0.0.0:' + port);\n    });\n}\n"], "filenames": ["lib/ecstatic.js"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [57], "fixing_code_start_loc": [55], "fixing_code_end_loc": [70], "type": "CWE-20", "message": "A regular expression Denial of Service (DoS) vulnerability in the file lib/ecstatic.js of the ecstatic npm package, before version 2.0.0, allows a remote attacker to overload and crash a server by passing a maliciously crafted string.", "other": {"cve": {"id": "CVE-2016-10703", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-14T19:29:00.197", "lastModified": "2021-03-30T23:15:13.440", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A regular expression Denial of Service (DoS) vulnerability in the file lib/ecstatic.js of the ecstatic npm package, before version 2.0.0, allows a remote attacker to overload and crash a server by passing a maliciously crafted string."}, {"lang": "es", "value": "Una vulnerabilidad de denegaci\u00f3n de servicio con expresiones regulares (ReDoS) en el archivo lib/ecstatic.js del paquete ecstatic npm, en versiones anteriores a la 2.0.0, permite que un atacante remoto sobrecargue y cierre inesperadamente un servidor pasando una cadena maliciosamente manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ecstatic_project:ecstatic:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "F03DA887-0505-4651-A24C-3098CFF7BDC8"}]}]}], "references": [{"url": "https://advisory.checkmarx.net/advisory/CX-2016-4450", "source": "cve@mitre.org"}, {"url": "https://github.com/jfhbrook/node-ecstatic/commit/71ce93988ead4b561a8592168c72143907189f01", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://www.checkmarx.com/advisories/denial-of-service-dos-vulnerability-in-ecstatic-npm-package/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jfhbrook/node-ecstatic/commit/71ce93988ead4b561a8592168c72143907189f01"}}