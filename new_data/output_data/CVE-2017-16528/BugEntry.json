{"buggy_code": ["/*\n *  ALSA sequencer device management\n *  Copyright (c) 1999 by Takashi Iwai <tiwai@suse.de>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *----------------------------------------------------------------\n *\n * This device handler separates the card driver module from sequencer\n * stuff (sequencer core, synth drivers, etc), so that user can avoid\n * to spend unnecessary resources e.g. if he needs only listening to\n * MP3s.\n *\n * The card (or lowlevel) driver creates a sequencer device entry\n * via snd_seq_device_new().  This is an entry pointer to communicate\n * with the sequencer device \"driver\", which is involved with the\n * actual part to communicate with the sequencer core.\n * Each sequencer device entry has an id string and the corresponding\n * driver with the same id is loaded when required.  For example,\n * lowlevel codes to access emu8000 chip on sbawe card are included in\n * emu8000-synth module.  To activate this module, the hardware\n * resources like i/o port are passed via snd_seq_device argument.\n *\n */\n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/seq_device.h>\n#include <sound/seq_kernel.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA sequencer device management\");\nMODULE_LICENSE(\"GPL\");\n\n/*\n * bus definition\n */\nstatic int snd_seq_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_seq_driver *sdrv = to_seq_drv(drv);\n\n\treturn strcmp(sdrv->id, sdev->id) == 0 &&\n\t\tsdrv->argsize == sdev->argsize;\n}\n\nstatic struct bus_type snd_seq_bus_type = {\n\t.name = \"snd_seq\",\n\t.match = snd_seq_bus_match,\n};\n\n/*\n * proc interface -- just for compatibility\n */\n#ifdef CONFIG_SND_PROC_FS\nstatic struct snd_info_entry *info_entry;\n\nstatic int print_dev_info(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_info_buffer *buffer = data;\n\n\tsnd_iprintf(buffer, \"snd-%s,%s,%d\\n\", sdev->id,\n\t\t    dev->driver ? \"loaded\" : \"empty\",\n\t\t    dev->driver ? 1 : 0);\n\treturn 0;\n}\n\nstatic void snd_seq_device_info(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tbus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);\n}\n#endif\n\n/*\n * load all registered drivers (called from seq_clientmgr.c)\n */\n\n#ifdef CONFIG_MODULES\n/* flag to block auto-loading */\nstatic atomic_t snd_seq_in_init = ATOMIC_INIT(1); /* blocked as default */\n\nstatic int request_seq_drv(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (!dev->driver)\n\t\trequest_module(\"snd-%s\", sdev->id);\n\treturn 0;\n}\n\nstatic void autoload_drivers(struct work_struct *work)\n{\n\t/* avoid reentrance */\n\tif (atomic_inc_return(&snd_seq_in_init) == 1)\n\t\tbus_for_each_dev(&snd_seq_bus_type, NULL, NULL,\n\t\t\t\t request_seq_drv);\n\tatomic_dec(&snd_seq_in_init);\n}\n\nstatic DECLARE_WORK(autoload_work, autoload_drivers);\n\nstatic void queue_autoload_drivers(void)\n{\n\tschedule_work(&autoload_work);\n}\n\nvoid snd_seq_autoload_init(void)\n{\n\tatomic_dec(&snd_seq_in_init);\n#ifdef CONFIG_SND_SEQUENCER_MODULE\n\t/* initial autoload only when snd-seq is a module */\n\tqueue_autoload_drivers();\n#endif\n}\nEXPORT_SYMBOL(snd_seq_autoload_init);\n\nvoid snd_seq_autoload_exit(void)\n{\n\tatomic_inc(&snd_seq_in_init);\n}\nEXPORT_SYMBOL(snd_seq_autoload_exit);\n\nvoid snd_seq_device_load_drivers(void)\n{\n\tqueue_autoload_drivers();\n\tflush_work(&autoload_work);\n}\nEXPORT_SYMBOL(snd_seq_device_load_drivers);\n#else\n#define queue_autoload_drivers() /* NOP */\n#endif\n\n/*\n * device management\n */\nstatic int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_register(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tint err;\n\n\terr = device_add(&dev->dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (!dev->dev.driver)\n\t\tqueue_autoload_drivers();\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tdevice_del(&dev->dev);\n\treturn 0;\n}\n\nstatic void snd_seq_dev_release(struct device *dev)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (sdev->private_free)\n\t\tsdev->private_free(sdev);\n\tkfree(sdev);\n}\n\n/*\n * register a sequencer device\n * card = card info\n * device = device number (if any)\n * id = id of driver\n * result = return pointer (NULL allowed if unnecessary)\n */\nint snd_seq_device_new(struct snd_card *card, int device, const char *id,\n\t\t       int argsize, struct snd_seq_device **result)\n{\n\tstruct snd_seq_device *dev;\n\tint err;\n\tstatic struct snd_device_ops dops = {\n\t\t.dev_free = snd_seq_device_dev_free,\n\t\t.dev_register = snd_seq_device_dev_register,\n\t\t.dev_disconnect = snd_seq_device_dev_disconnect,\n\t};\n\n\tif (result)\n\t\t*result = NULL;\n\n\tif (snd_BUG_ON(!id))\n\t\treturn -EINVAL;\n\n\tdev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* set up device info */\n\tdev->card = card;\n\tdev->device = device;\n\tdev->id = id;\n\tdev->argsize = argsize;\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.parent = &card->card_dev;\n\tdev->dev.bus = &snd_seq_bus_type;\n\tdev->dev.release = snd_seq_dev_release;\n\tdev_set_name(&dev->dev, \"%s-%d-%d\", dev->id, card->number, device);\n\n\t/* add this device to the list */\n\terr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\n\tif (err < 0) {\n\t\tput_device(&dev->dev);\n\t\treturn err;\n\t}\n\t\n\tif (result)\n\t\t*result = dev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_device_new);\n\n/*\n * driver registration\n */\nint __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)\n{\n\tif (WARN_ON(!drv->driver.name || !drv->id))\n\t\treturn -EINVAL;\n\tdrv->driver.bus = &snd_seq_bus_type;\n\tdrv->driver.owner = mod;\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__snd_seq_driver_register);\n\nvoid snd_seq_driver_unregister(struct snd_seq_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(snd_seq_driver_unregister);\n\n/*\n * module part\n */\n\nstatic int __init seq_dev_proc_init(void)\n{\n#ifdef CONFIG_SND_PROC_FS\n\tinfo_entry = snd_info_create_module_entry(THIS_MODULE, \"drivers\",\n\t\t\t\t\t\t  snd_seq_root);\n\tif (info_entry == NULL)\n\t\treturn -ENOMEM;\n\tinfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\n\tinfo_entry->c.text.read = snd_seq_device_info;\n\tif (snd_info_register(info_entry) < 0) {\n\t\tsnd_info_free_entry(info_entry);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __init alsa_seq_device_init(void)\n{\n\tint err;\n\n\terr = bus_register(&snd_seq_bus_type);\n\tif (err < 0)\n\t\treturn err;\n\terr = seq_dev_proc_init();\n\tif (err < 0)\n\t\tbus_unregister(&snd_seq_bus_type);\n\treturn err;\n}\n\nstatic void __exit alsa_seq_device_exit(void)\n{\n#ifdef CONFIG_MODULES\n\tcancel_work_sync(&autoload_work);\n#endif\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_info_free_entry(info_entry);\n#endif\n\tbus_unregister(&snd_seq_bus_type);\n}\n\nsubsys_initcall(alsa_seq_device_init)\nmodule_exit(alsa_seq_device_exit)\n"], "fixing_code": ["/*\n *  ALSA sequencer device management\n *  Copyright (c) 1999 by Takashi Iwai <tiwai@suse.de>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *----------------------------------------------------------------\n *\n * This device handler separates the card driver module from sequencer\n * stuff (sequencer core, synth drivers, etc), so that user can avoid\n * to spend unnecessary resources e.g. if he needs only listening to\n * MP3s.\n *\n * The card (or lowlevel) driver creates a sequencer device entry\n * via snd_seq_device_new().  This is an entry pointer to communicate\n * with the sequencer device \"driver\", which is involved with the\n * actual part to communicate with the sequencer core.\n * Each sequencer device entry has an id string and the corresponding\n * driver with the same id is loaded when required.  For example,\n * lowlevel codes to access emu8000 chip on sbawe card are included in\n * emu8000-synth module.  To activate this module, the hardware\n * resources like i/o port are passed via snd_seq_device argument.\n *\n */\n\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/seq_device.h>\n#include <sound/seq_kernel.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA sequencer device management\");\nMODULE_LICENSE(\"GPL\");\n\n/*\n * bus definition\n */\nstatic int snd_seq_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_seq_driver *sdrv = to_seq_drv(drv);\n\n\treturn strcmp(sdrv->id, sdev->id) == 0 &&\n\t\tsdrv->argsize == sdev->argsize;\n}\n\nstatic struct bus_type snd_seq_bus_type = {\n\t.name = \"snd_seq\",\n\t.match = snd_seq_bus_match,\n};\n\n/*\n * proc interface -- just for compatibility\n */\n#ifdef CONFIG_SND_PROC_FS\nstatic struct snd_info_entry *info_entry;\n\nstatic int print_dev_info(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_info_buffer *buffer = data;\n\n\tsnd_iprintf(buffer, \"snd-%s,%s,%d\\n\", sdev->id,\n\t\t    dev->driver ? \"loaded\" : \"empty\",\n\t\t    dev->driver ? 1 : 0);\n\treturn 0;\n}\n\nstatic void snd_seq_device_info(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tbus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);\n}\n#endif\n\n/*\n * load all registered drivers (called from seq_clientmgr.c)\n */\n\n#ifdef CONFIG_MODULES\n/* flag to block auto-loading */\nstatic atomic_t snd_seq_in_init = ATOMIC_INIT(1); /* blocked as default */\n\nstatic int request_seq_drv(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (!dev->driver)\n\t\trequest_module(\"snd-%s\", sdev->id);\n\treturn 0;\n}\n\nstatic void autoload_drivers(struct work_struct *work)\n{\n\t/* avoid reentrance */\n\tif (atomic_inc_return(&snd_seq_in_init) == 1)\n\t\tbus_for_each_dev(&snd_seq_bus_type, NULL, NULL,\n\t\t\t\t request_seq_drv);\n\tatomic_dec(&snd_seq_in_init);\n}\n\nstatic DECLARE_WORK(autoload_work, autoload_drivers);\n\nstatic void queue_autoload_drivers(void)\n{\n\tschedule_work(&autoload_work);\n}\n\nvoid snd_seq_autoload_init(void)\n{\n\tatomic_dec(&snd_seq_in_init);\n#ifdef CONFIG_SND_SEQUENCER_MODULE\n\t/* initial autoload only when snd-seq is a module */\n\tqueue_autoload_drivers();\n#endif\n}\nEXPORT_SYMBOL(snd_seq_autoload_init);\n\nvoid snd_seq_autoload_exit(void)\n{\n\tatomic_inc(&snd_seq_in_init);\n}\nEXPORT_SYMBOL(snd_seq_autoload_exit);\n\nvoid snd_seq_device_load_drivers(void)\n{\n\tqueue_autoload_drivers();\n\tflush_work(&autoload_work);\n}\nEXPORT_SYMBOL(snd_seq_device_load_drivers);\n#define cancel_autoload_drivers()\tcancel_work_sync(&autoload_work)\n#else\n#define queue_autoload_drivers() /* NOP */\n#define cancel_autoload_drivers() /* NOP */\n#endif\n\n/*\n * device management\n */\nstatic int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_register(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tint err;\n\n\terr = device_add(&dev->dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (!dev->dev.driver)\n\t\tqueue_autoload_drivers();\n\treturn 0;\n}\n\nstatic int snd_seq_device_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tdevice_del(&dev->dev);\n\treturn 0;\n}\n\nstatic void snd_seq_dev_release(struct device *dev)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (sdev->private_free)\n\t\tsdev->private_free(sdev);\n\tkfree(sdev);\n}\n\n/*\n * register a sequencer device\n * card = card info\n * device = device number (if any)\n * id = id of driver\n * result = return pointer (NULL allowed if unnecessary)\n */\nint snd_seq_device_new(struct snd_card *card, int device, const char *id,\n\t\t       int argsize, struct snd_seq_device **result)\n{\n\tstruct snd_seq_device *dev;\n\tint err;\n\tstatic struct snd_device_ops dops = {\n\t\t.dev_free = snd_seq_device_dev_free,\n\t\t.dev_register = snd_seq_device_dev_register,\n\t\t.dev_disconnect = snd_seq_device_dev_disconnect,\n\t};\n\n\tif (result)\n\t\t*result = NULL;\n\n\tif (snd_BUG_ON(!id))\n\t\treturn -EINVAL;\n\n\tdev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* set up device info */\n\tdev->card = card;\n\tdev->device = device;\n\tdev->id = id;\n\tdev->argsize = argsize;\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.parent = &card->card_dev;\n\tdev->dev.bus = &snd_seq_bus_type;\n\tdev->dev.release = snd_seq_dev_release;\n\tdev_set_name(&dev->dev, \"%s-%d-%d\", dev->id, card->number, device);\n\n\t/* add this device to the list */\n\terr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\n\tif (err < 0) {\n\t\tput_device(&dev->dev);\n\t\treturn err;\n\t}\n\t\n\tif (result)\n\t\t*result = dev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_device_new);\n\n/*\n * driver registration\n */\nint __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)\n{\n\tif (WARN_ON(!drv->driver.name || !drv->id))\n\t\treturn -EINVAL;\n\tdrv->driver.bus = &snd_seq_bus_type;\n\tdrv->driver.owner = mod;\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__snd_seq_driver_register);\n\nvoid snd_seq_driver_unregister(struct snd_seq_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(snd_seq_driver_unregister);\n\n/*\n * module part\n */\n\nstatic int __init seq_dev_proc_init(void)\n{\n#ifdef CONFIG_SND_PROC_FS\n\tinfo_entry = snd_info_create_module_entry(THIS_MODULE, \"drivers\",\n\t\t\t\t\t\t  snd_seq_root);\n\tif (info_entry == NULL)\n\t\treturn -ENOMEM;\n\tinfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\n\tinfo_entry->c.text.read = snd_seq_device_info;\n\tif (snd_info_register(info_entry) < 0) {\n\t\tsnd_info_free_entry(info_entry);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __init alsa_seq_device_init(void)\n{\n\tint err;\n\n\terr = bus_register(&snd_seq_bus_type);\n\tif (err < 0)\n\t\treturn err;\n\terr = seq_dev_proc_init();\n\tif (err < 0)\n\t\tbus_unregister(&snd_seq_bus_type);\n\treturn err;\n}\n\nstatic void __exit alsa_seq_device_exit(void)\n{\n#ifdef CONFIG_MODULES\n\tcancel_work_sync(&autoload_work);\n#endif\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_info_free_entry(info_entry);\n#endif\n\tbus_unregister(&snd_seq_bus_type);\n}\n\nsubsys_initcall(alsa_seq_device_init)\nmodule_exit(alsa_seq_device_exit)\n"], "filenames": ["sound/core/seq_device.c"], "buggy_code_start_loc": [150], "buggy_code_end_loc": [161], "fixing_code_start_loc": [151], "fixing_code_end_loc": [165], "type": "CWE-416", "message": "sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16528", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.850", "lastModified": "2018-04-07T01:29:03.030", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "sound/core/seq_device.c en el kernel de Linux, en versiones anteriores a la 4.13.4, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (uso de memoria previamente liberada snd_rawmidi_dev_seq_free y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.3", "matchCriteriaId": "FA1E2C32-ED0D-4E2B-A313-448CC0545ED2"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/kuZzDHGkQu8/5du20rZEAAAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57"}}