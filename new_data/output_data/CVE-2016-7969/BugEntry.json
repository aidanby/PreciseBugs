{"buggy_code": ["/*\n * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>\n *\n * This file is part of libass.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"config.h\"\n#include \"ass_compat.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"ass_render.h\"\n#include \"ass_parse.h\"\n#include \"ass_shaper.h\"\n\n#define MAX_GLYPHS_INITIAL 1024\n#define MAX_LINES_INITIAL 64\n#define MAX_BITMAPS_INITIAL 16\n#define MAX_SUB_BITMAPS_INITIAL 64\n#define SUBPIXEL_MASK 63\n#define SUBPIXEL_ACCURACY 7\n\n\nASS_Renderer *ass_renderer_init(ASS_Library *library)\n{\n    int error;\n    FT_Library ft;\n    ASS_Renderer *priv = 0;\n    int vmajor, vminor, vpatch;\n\n    error = FT_Init_FreeType(&ft);\n    if (error) {\n        ass_msg(library, MSGL_FATAL, \"%s failed\", \"FT_Init_FreeType\");\n        goto ass_init_exit;\n    }\n\n    FT_Library_Version(ft, &vmajor, &vminor, &vpatch);\n    ass_msg(library, MSGL_V, \"Raster: FreeType %d.%d.%d\",\n           vmajor, vminor, vpatch);\n\n    priv = calloc(1, sizeof(ASS_Renderer));\n    if (!priv) {\n        FT_Done_FreeType(ft);\n        goto ass_init_exit;\n    }\n\n    priv->library = library;\n    priv->ftlibrary = ft;\n    // images_root and related stuff is zero-filled in calloc\n\n#if (defined(__i386__) || defined(__x86_64__)) && CONFIG_ASM\n    if (has_avx2())\n        priv->engine = &ass_bitmap_engine_avx2;\n    else if (has_sse2())\n        priv->engine = &ass_bitmap_engine_sse2;\n    else\n        priv->engine = &ass_bitmap_engine_c;\n#else\n    priv->engine = &ass_bitmap_engine_c;\n#endif\n\n#if CONFIG_RASTERIZER\n    rasterizer_init(&priv->rasterizer, 16);\n#endif\n\n    priv->cache.font_cache = ass_font_cache_create();\n    priv->cache.bitmap_cache = ass_bitmap_cache_create();\n    priv->cache.composite_cache = ass_composite_cache_create();\n    priv->cache.outline_cache = ass_outline_cache_create();\n    priv->cache.glyph_max = GLYPH_CACHE_MAX;\n    priv->cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;\n    priv->cache.composite_max_size = COMPOSITE_CACHE_MAX_SIZE;\n\n    priv->text_info.max_bitmaps = MAX_BITMAPS_INITIAL;\n    priv->text_info.max_glyphs = MAX_GLYPHS_INITIAL;\n    priv->text_info.max_lines = MAX_LINES_INITIAL;\n    priv->text_info.n_bitmaps = 0;\n    priv->text_info.combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));\n    priv->text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));\n    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));\n\n    priv->settings.font_size_coeff = 1.;\n    priv->settings.selective_style_overrides = ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;\n\n    priv->shaper = ass_shaper_new(0);\n    ass_shaper_info(library);\n#ifdef CONFIG_HARFBUZZ\n    priv->settings.shaper = ASS_SHAPING_COMPLEX;\n#else\n    priv->settings.shaper = ASS_SHAPING_SIMPLE;\n#endif\n\n  ass_init_exit:\n    if (priv)\n        ass_msg(library, MSGL_V, \"Initialized\");\n    else\n        ass_msg(library, MSGL_ERR, \"Initialization failed\");\n\n    return priv;\n}\n\nvoid ass_renderer_done(ASS_Renderer *render_priv)\n{\n    ass_frame_unref(render_priv->images_root);\n    ass_frame_unref(render_priv->prev_images_root);\n\n    ass_cache_done(render_priv->cache.composite_cache);\n    ass_cache_done(render_priv->cache.bitmap_cache);\n    ass_cache_done(render_priv->cache.outline_cache);\n    ass_shaper_free(render_priv->shaper);\n    ass_cache_done(render_priv->cache.font_cache);\n\n#if CONFIG_RASTERIZER\n    rasterizer_done(&render_priv->rasterizer);\n#endif\n\n    if (render_priv->state.stroker) {\n        FT_Stroker_Done(render_priv->state.stroker);\n        render_priv->state.stroker = 0;\n    }\n    if (render_priv->fontselect)\n        ass_fontselect_free(render_priv->fontselect);\n    if (render_priv->ftlibrary)\n        FT_Done_FreeType(render_priv->ftlibrary);\n    free(render_priv->eimg);\n    free(render_priv->text_info.glyphs);\n    free(render_priv->text_info.lines);\n\n    free(render_priv->text_info.combined_bitmaps);\n\n    free(render_priv->settings.default_font);\n    free(render_priv->settings.default_family);\n\n    free(render_priv->user_override_style.FontName);\n\n    free(render_priv);\n}\n\n/**\n * \\brief Create a new ASS_Image\n * Parameters are the same as ASS_Image fields.\n */\nstatic ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,\n                                 int bitmap_h, int stride, int dst_x,\n                                 int dst_y, uint32_t color,\n                                 CompositeHashValue *source)\n{\n    ASS_ImagePriv *img = malloc(sizeof(ASS_ImagePriv));\n    if (!img) {\n        if (!source)\n            ass_aligned_free(bitmap);\n        return NULL;\n    }\n\n    img->result.w = bitmap_w;\n    img->result.h = bitmap_h;\n    img->result.stride = stride;\n    img->result.bitmap = bitmap;\n    img->result.color = color;\n    img->result.dst_x = dst_x;\n    img->result.dst_y = dst_y;\n\n    img->source = source;\n    ass_cache_inc_ref(source);\n    img->ref_count = 0;\n\n    return &img->result;\n}\n\n/**\n * \\brief Mapping between script and screen coordinates\n */\nstatic double x2scr_pos(ASS_Renderer *render_priv, double x)\n{\n    return x * render_priv->orig_width / render_priv->font_scale_x / render_priv->track->PlayResX +\n        render_priv->settings.left_margin;\n}\nstatic double x2scr(ASS_Renderer *render_priv, double x)\n{\n    if (render_priv->state.explicit)\n        return x2scr_pos(render_priv, x);\n    return x * render_priv->orig_width_nocrop / render_priv->font_scale_x /\n        render_priv->track->PlayResX +\n        FFMAX(render_priv->settings.left_margin, 0);\n}\nstatic double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)\n{\n    return x * render_priv->orig_width / render_priv->track->PlayResX +\n        render_priv->settings.left_margin;\n}\nstatic double x2scr_scaled(ASS_Renderer *render_priv, double x)\n{\n    if (render_priv->state.explicit)\n        return x2scr_pos_scaled(render_priv, x);\n    return x * render_priv->orig_width_nocrop /\n        render_priv->track->PlayResX +\n        FFMAX(render_priv->settings.left_margin, 0);\n}\n/**\n * \\brief Mapping between script and screen coordinates\n */\nstatic double y2scr_pos(ASS_Renderer *render_priv, double y)\n{\n    return y * render_priv->orig_height / render_priv->track->PlayResY +\n        render_priv->settings.top_margin;\n}\nstatic double y2scr(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    return y * render_priv->orig_height_nocrop /\n        render_priv->track->PlayResY +\n        FFMAX(render_priv->settings.top_margin, 0);\n}\n\n// the same for toptitles\nstatic double y2scr_top(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    if (render_priv->settings.use_margins)\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY;\n    else\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0);\n}\n// the same for subtitles\nstatic double y2scr_sub(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    if (render_priv->settings.use_margins)\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0)\n            + FFMAX(render_priv->settings.bottom_margin, 0);\n    else\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0);\n}\n\n/*\n * \\brief Convert bitmap glyphs into ASS_Image list with inverse clipping\n *\n * Inverse clipping with the following strategy:\n * - find rectangle from (x0, y0) to (cx0, y1)\n * - find rectangle from (cx0, y0) to (cx1, cy0)\n * - find rectangle from (cx0, cy1) to (cx1, y1)\n * - find rectangle from (cx1, y0) to (x1, y1)\n * These rectangles can be invalid and in this case are discarded.\n * Afterwards, they are clipped against the screen coordinates.\n * In an additional pass, the rectangles need to be split up left/right for\n * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).\n */\nstatic ASS_Image **render_glyph_i(ASS_Renderer *render_priv,\n                                  Bitmap *bm, int dst_x, int dst_y,\n                                  uint32_t color, uint32_t color2, int brk,\n                                  ASS_Image **tail, unsigned type,\n                                  CompositeHashValue *source)\n{\n    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;\n    Rect r[4];\n    ASS_Image *img;\n\n    dst_x += bm->left;\n    dst_y += bm->top;\n\n    // we still need to clip against screen boundaries\n    zx = x2scr_pos_scaled(render_priv, 0);\n    zy = y2scr_pos(render_priv, 0);\n    sx = x2scr_pos_scaled(render_priv, render_priv->track->PlayResX);\n    sy = y2scr_pos(render_priv, render_priv->track->PlayResY);\n\n    x0 = 0;\n    y0 = 0;\n    x1 = bm->w;\n    y1 = bm->h;\n    cx0 = render_priv->state.clip_x0 - dst_x;\n    cy0 = render_priv->state.clip_y0 - dst_y;\n    cx1 = render_priv->state.clip_x1 - dst_x;\n    cy1 = render_priv->state.clip_y1 - dst_y;\n\n    // calculate rectangles and discard invalid ones while we're at it.\n    i = 0;\n    r[i].x0 = x0;\n    r[i].y0 = y0;\n    r[i].x1 = (cx0 > x1) ? x1 : cx0;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx0 < 0) ? x0 : cx0;\n    r[i].y0 = y0;\n    r[i].x1 = (cx1 > x1) ? x1 : cx1;\n    r[i].y1 = (cy0 > y1) ? y1 : cy0;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx0 < 0) ? x0 : cx0;\n    r[i].y0 = (cy1 < 0) ? y0 : cy1;\n    r[i].x1 = (cx1 > x1) ? x1 : cx1;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx1 < 0) ? x0 : cx1;\n    r[i].y0 = y0;\n    r[i].x1 = x1;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n\n    // clip each rectangle to screen coordinates\n    for (j = 0; j < i; j++) {\n        r[j].x0 = (r[j].x0 + dst_x < zx) ? zx - dst_x : r[j].x0;\n        r[j].y0 = (r[j].y0 + dst_y < zy) ? zy - dst_y : r[j].y0;\n        r[j].x1 = (r[j].x1 + dst_x > sx) ? sx - dst_x : r[j].x1;\n        r[j].y1 = (r[j].y1 + dst_y > sy) ? sy - dst_y : r[j].y1;\n    }\n\n    // draw the rectangles\n    for (j = 0; j < i; j++) {\n        int lbrk = brk;\n        // kick out rectangles that are invalid now\n        if (r[j].x1 <= r[j].x0 || r[j].y1 <= r[j].y0)\n            continue;\n        // split up into left and right for karaoke, if needed\n        if (lbrk > r[j].x0) {\n            if (lbrk > r[j].x1) lbrk = r[j].x1;\n            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + r[j].x0,\n                                 lbrk - r[j].x0, r[j].y1 - r[j].y0, bm->stride,\n                                 dst_x + r[j].x0, dst_y + r[j].y0, color, source);\n            if (!img) break;\n            img->type = type;\n            *tail = img;\n            tail = &img->next;\n        }\n        if (lbrk < r[j].x1) {\n            if (lbrk < r[j].x0) lbrk = r[j].x0;\n            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + lbrk,\n                                 r[j].x1 - lbrk, r[j].y1 - r[j].y0, bm->stride,\n                                 dst_x + lbrk, dst_y + r[j].y0, color2, source);\n            if (!img) break;\n            img->type = type;\n            *tail = img;\n            tail = &img->next;\n        }\n    }\n\n    return tail;\n}\n\n/**\n * \\brief convert bitmap glyph into ASS_Image struct(s)\n * \\param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY\n * \\param dst_x bitmap x coordinate in video frame\n * \\param dst_y bitmap y coordinate in video frame\n * \\param color first color, RGBA\n * \\param color2 second color, RGBA\n * \\param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right\n * \\param tail pointer to the last image's next field, head of the generated list should be stored here\n * \\return pointer to the new list tail\n * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.\n */\nstatic ASS_Image **\nrender_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,\n             uint32_t color, uint32_t color2, int brk, ASS_Image **tail,\n             unsigned type, CompositeHashValue *source)\n{\n    // Inverse clipping in use?\n    if (render_priv->state.clip_mode)\n        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,\n                              brk, tail, type, source);\n\n    // brk is relative to dst_x\n    // color = color left of brk\n    // color2 = color right of brk\n    int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap\n    int clip_x0, clip_y0, clip_x1, clip_y1;\n    int tmp;\n    ASS_Image *img;\n\n    dst_x += bm->left;\n    dst_y += bm->top;\n    brk -= bm->left;\n\n    // clipping\n    clip_x0 = FFMINMAX(render_priv->state.clip_x0, 0, render_priv->width);\n    clip_y0 = FFMINMAX(render_priv->state.clip_y0, 0, render_priv->height);\n    clip_x1 = FFMINMAX(render_priv->state.clip_x1, 0, render_priv->width);\n    clip_y1 = FFMINMAX(render_priv->state.clip_y1, 0, render_priv->height);\n    b_x0 = 0;\n    b_y0 = 0;\n    b_x1 = bm->w;\n    b_y1 = bm->h;\n\n    tmp = dst_x - clip_x0;\n    if (tmp < 0) {\n        b_x0 = -tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = dst_y - clip_y0;\n    if (tmp < 0) {\n        b_y0 = -tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = clip_x1 - dst_x - bm->w;\n    if (tmp < 0) {\n        b_x1 = bm->w + tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = clip_y1 - dst_y - bm->h;\n    if (tmp < 0) {\n        b_y1 = bm->h + tmp;\n        render_priv->state.has_clips = 1;\n    }\n\n    if ((b_y0 >= b_y1) || (b_x0 >= b_x1))\n        return tail;\n\n    if (brk > b_x0) {           // draw left part\n        if (brk > b_x1)\n            brk = b_x1;\n        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + b_x0,\n                             brk - b_x0, b_y1 - b_y0, bm->stride,\n                             dst_x + b_x0, dst_y + b_y0, color, source);\n        if (!img) return tail;\n        img->type = type;\n        *tail = img;\n        tail = &img->next;\n    }\n    if (brk < b_x1) {           // draw right part\n        if (brk < b_x0)\n            brk = b_x0;\n        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + brk,\n                             b_x1 - brk, b_y1 - b_y0, bm->stride,\n                             dst_x + brk, dst_y + b_y0, color2, source);\n        if (!img) return tail;\n        img->type = type;\n        *tail = img;\n        tail = &img->next;\n    }\n    return tail;\n}\n\n// Calculate bitmap memory footprint\nstatic inline size_t bitmap_size(Bitmap *bm)\n{\n    return bm ? sizeof(Bitmap) + bm->stride * bm->h : 0;\n}\n\n/**\n * Iterate through a list of bitmaps and blend with clip vector, if\n * applicable. The blended bitmaps are added to a free list which is freed\n * at the start of a new frame.\n */\nstatic void blend_vector_clip(ASS_Renderer *render_priv,\n                              ASS_Image *head)\n{\n    ASS_Drawing *drawing = render_priv->state.clip_drawing;\n    if (!drawing)\n        return;\n\n    // Try to get mask from cache\n    BitmapHashKey key;\n    memset(&key, 0, sizeof(key));\n    key.type = BITMAP_CLIP;\n    key.u.clip.text = drawing->text;\n\n    BitmapHashValue *val;\n    if (!ass_cache_get(render_priv->cache.bitmap_cache, &key, &val)) {\n        if (!val)\n            return;\n        val->bm = val->bm_o = NULL;\n\n        // Not found in cache, parse and rasterize it\n        ASS_Outline *outline = ass_drawing_parse(drawing, 1);\n        if (!outline) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"Clip vector parsing failed. Skipping.\");\n            ass_cache_commit(val, sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n            ass_cache_dec_ref(val);\n            return;\n        }\n\n        // We need to translate the clip according to screen borders\n        if (render_priv->settings.left_margin != 0 ||\n            render_priv->settings.top_margin != 0) {\n            FT_Vector trans = {\n                .x = int_to_d6(render_priv->settings.left_margin),\n                .y = -int_to_d6(render_priv->settings.top_margin),\n            };\n            outline_translate(outline, trans.x, trans.y);\n        }\n\n        val->bm = outline_to_bitmap(render_priv, outline, 0);\n        ass_cache_commit(val, bitmap_size(val->bm) +\n                         sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n    }\n\n    Bitmap *clip_bm = val->bm;\n    if (!clip_bm) {\n        ass_cache_dec_ref(val);\n        return;\n    }\n\n    // Iterate through bitmaps and blend/clip them\n    for (ASS_Image *cur = head; cur; cur = cur->next) {\n        int left, top, right, bottom, w, h;\n        int ax, ay, aw, ah, as;\n        int bx, by, bw, bh, bs;\n        int aleft, atop, bleft, btop;\n        unsigned char *abuffer, *bbuffer, *nbuffer;\n\n        render_priv->state.has_clips = 1;\n\n        abuffer = cur->bitmap;\n        bbuffer = clip_bm->buffer;\n        ax = cur->dst_x;\n        ay = cur->dst_y;\n        aw = cur->w;\n        ah = cur->h;\n        as = cur->stride;\n        bx = clip_bm->left;\n        by = clip_bm->top;\n        bw = clip_bm->w;\n        bh = clip_bm->h;\n        bs = clip_bm->stride;\n\n        // Calculate overlap coordinates\n        left = (ax > bx) ? ax : bx;\n        top = (ay > by) ? ay : by;\n        right = ((ax + aw) < (bx + bw)) ? (ax + aw) : (bx + bw);\n        bottom = ((ay + ah) < (by + bh)) ? (ay + ah) : (by + bh);\n        aleft = left - ax;\n        atop = top - ay;\n        w = right - left;\n        h = bottom - top;\n        bleft = left - bx;\n        btop = top - by;\n\n        if (render_priv->state.clip_drawing_mode) {\n            // Inverse clip\n            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||\n                ay > by + bh || !h || !w) {\n                continue;\n            }\n\n            // Allocate new buffer and add to free list\n            nbuffer = ass_aligned_alloc(32, as * ah, false);\n            if (!nbuffer)\n                break;\n\n            // Blend together\n            memcpy(nbuffer, abuffer, ((ah - 1) * as) + aw);\n            render_priv->engine->sub_bitmaps(nbuffer + atop * as + aleft, as,\n                                             bbuffer + btop * bs + bleft, bs,\n                                             h, w);\n        } else {\n            // Regular clip\n            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||\n                ay > by + bh || !h || !w) {\n                cur->w = cur->h = cur->stride = 0;\n                continue;\n            }\n\n            // Allocate new buffer and add to free list\n            unsigned align = (w >= 16) ? 16 : ((w >= 8) ? 8 : 1);\n            unsigned ns = ass_align(align, w);\n            nbuffer = ass_aligned_alloc(align, ns * h, false);\n            if (!nbuffer)\n                break;\n\n            // Blend together\n            render_priv->engine->mul_bitmaps(nbuffer, ns,\n                                             abuffer + atop * as + aleft, as,\n                                             bbuffer + btop * bs + bleft, bs,\n                                             w, h);\n            cur->dst_x += aleft;\n            cur->dst_y += atop;\n            cur->w = w;\n            cur->h = h;\n            cur->stride = ns;\n        }\n\n        cur->bitmap = nbuffer;\n        ASS_ImagePriv *priv = (ASS_ImagePriv *) cur;\n        ass_cache_dec_ref(priv->source);\n        priv->source = NULL;\n    }\n\n    ass_cache_dec_ref(val);\n}\n\n/**\n * \\brief Convert TextInfo struct to ASS_Image list\n * Splits glyphs in halves when needed (for \\kf karaoke).\n */\nstatic ASS_Image *render_text(ASS_Renderer *render_priv)\n{\n    ASS_Image *head;\n    ASS_Image **tail = &head;\n    unsigned n_bitmaps = render_priv->text_info.n_bitmaps;\n    CombinedBitmapInfo *bitmaps = render_priv->text_info.combined_bitmaps;\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm_s || render_priv->state.border_style == 4)\n            continue;\n\n        tail =\n            render_glyph(render_priv, info->bm_s, info->x, info->y, info->c[3], 0,\n                         1000000, tail, IMAGE_TYPE_SHADOW, info->image);\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm_o)\n            continue;\n\n        if ((info->effect_type == EF_KARAOKE_KO)\n                && (info->effect_timing <= info->first_pos_x)) {\n            // do nothing\n        } else {\n            tail =\n                render_glyph(render_priv, info->bm_o, info->x, info->y, info->c[2],\n                             0, 1000000, tail, IMAGE_TYPE_OUTLINE, info->image);\n        }\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm)\n            continue;\n\n        if ((info->effect_type == EF_KARAOKE)\n                || (info->effect_type == EF_KARAOKE_KO)) {\n            if (info->effect_timing > info->first_pos_x)\n                tail =\n                    render_glyph(render_priv, info->bm, info->x, info->y,\n                                 info->c[0], 0, 1000000, tail,\n                                 IMAGE_TYPE_CHARACTER, info->image);\n            else\n                tail =\n                    render_glyph(render_priv, info->bm, info->x, info->y,\n                                 info->c[1], 0, 1000000, tail,\n                                 IMAGE_TYPE_CHARACTER, info->image);\n        } else if (info->effect_type == EF_KARAOKE_KF) {\n            tail =\n                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],\n                             info->c[1], info->effect_timing, tail,\n                             IMAGE_TYPE_CHARACTER, info->image);\n        } else\n            tail =\n                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],\n                             0, 1000000, tail, IMAGE_TYPE_CHARACTER, info->image);\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++)\n        ass_cache_dec_ref(bitmaps[i].image);\n\n    *tail = 0;\n    blend_vector_clip(render_priv, head);\n\n    return head;\n}\n\nstatic void compute_string_bbox(TextInfo *text, DBBox *bbox)\n{\n    int i;\n\n    if (text->length > 0) {\n        bbox->xMin = 32000;\n        bbox->xMax = -32000;\n        bbox->yMin = -1 * text->lines[0].asc + d6_to_double(text->glyphs[0].pos.y);\n        bbox->yMax = text->height - text->lines[0].asc +\n                     d6_to_double(text->glyphs[0].pos.y);\n\n        for (i = 0; i < text->length; ++i) {\n            GlyphInfo *info = text->glyphs + i;\n            if (info->skip) continue;\n            double s = d6_to_double(info->pos.x);\n            double e = s + d6_to_double(info->cluster_advance.x);\n            bbox->xMin = FFMIN(bbox->xMin, s);\n            bbox->xMax = FFMAX(bbox->xMax, e);\n        }\n    } else\n        bbox->xMin = bbox->xMax = bbox->yMin = bbox->yMax = 0.;\n}\n\nstatic ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,\n                                                   ASS_Style *rstyle)\n{\n    // The script style is the one the event was declared with.\n    ASS_Style *script = render_priv->track->styles +\n                        render_priv->state.event->Style;\n    // The user style was set with ass_set_selective_style_override().\n    ASS_Style *user = &render_priv->user_override_style;\n    ASS_Style *new = &render_priv->state.override_style_temp_storage;\n    int explicit = event_has_hard_overrides(render_priv->state.event->Text) ||\n                   render_priv->state.evt_type != EVENT_NORMAL;\n    int requested = render_priv->settings.selective_style_overrides;\n    double scale;\n\n    user->Name = \"OverrideStyle\"; // name insignificant\n\n    // Either the event's style, or the style forced with a \\r tag.\n    if (!rstyle)\n        rstyle = script;\n\n    // Create a new style that contains a mix of the original style and\n    // user_style (the user's override style). Copy only fields from the\n    // script's style that are deemed necessary.\n    *new = *rstyle;\n\n    render_priv->state.explicit = explicit;\n\n    render_priv->state.apply_font_scale =\n        !explicit || !(requested & ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);\n\n    // On positioned events, do not apply most overrides.\n    if (explicit)\n        requested = 0;\n\n    if (requested & ASS_OVERRIDE_BIT_STYLE)\n        requested |= ASS_OVERRIDE_BIT_FONT_NAME |\n                     ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS |\n                     ASS_OVERRIDE_BIT_COLORS |\n                     ASS_OVERRIDE_BIT_BORDER |\n                     ASS_OVERRIDE_BIT_ATTRIBUTES;\n\n    // Copies fields even not covered by any of the other bits.\n    if (requested & ASS_OVERRIDE_FULL_STYLE)\n        *new = *user;\n\n    // The user style is supposed to be independent of the script resolution.\n    // Treat the user style's values as if they were specified for a script with\n    // PlayResY=288, and rescale the values to the current script.\n    scale = render_priv->track->PlayResY / 288.0;\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS) {\n        new->FontSize = user->FontSize * scale;\n        new->Spacing = user->Spacing * scale;\n        new->ScaleX = user->ScaleX;\n        new->ScaleY = user->ScaleY;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_NAME) {\n        new->FontName = user->FontName;\n        new->treat_fontname_as_pattern = user->treat_fontname_as_pattern;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_COLORS) {\n        new->PrimaryColour = user->PrimaryColour;\n        new->SecondaryColour = user->SecondaryColour;\n        new->OutlineColour = user->OutlineColour;\n        new->BackColour = user->BackColour;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ATTRIBUTES) {\n        new->Bold = user->Bold;\n        new->Italic = user->Italic;\n        new->Underline = user->Underline;\n        new->StrikeOut = user->StrikeOut;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_BORDER) {\n        new->BorderStyle = user->BorderStyle;\n        new->Outline = user->Outline * scale;\n        new->Shadow = user->Shadow * scale;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ALIGNMENT)\n        new->Alignment = user->Alignment;\n\n    if (requested & ASS_OVERRIDE_BIT_MARGINS) {\n        new->MarginL = user->MarginL;\n        new->MarginR = user->MarginR;\n        new->MarginV = user->MarginV;\n    }\n\n    if (!new->FontName)\n        new->FontName = rstyle->FontName;\n\n    render_priv->state.style = new;\n    render_priv->state.overrides = requested;\n\n    return new;\n}\n\nstatic void init_font_scale(ASS_Renderer *render_priv)\n{\n    ASS_Settings *settings_priv = &render_priv->settings;\n\n    render_priv->font_scale = ((double) render_priv->orig_height) /\n                              render_priv->track->PlayResY;\n    if (settings_priv->storage_height)\n        render_priv->blur_scale = ((double) render_priv->orig_height) /\n            settings_priv->storage_height;\n    else\n        render_priv->blur_scale = 1.;\n    if (render_priv->track->ScaledBorderAndShadow)\n        render_priv->border_scale =\n            ((double) render_priv->orig_height) /\n            render_priv->track->PlayResY;\n    else\n        render_priv->border_scale = render_priv->blur_scale;\n    if (!settings_priv->storage_height)\n        render_priv->blur_scale = render_priv->border_scale;\n\n    if (render_priv->state.apply_font_scale) {\n        render_priv->font_scale *= settings_priv->font_size_coeff;\n        render_priv->border_scale *= settings_priv->font_size_coeff;\n        render_priv->blur_scale *= settings_priv->font_size_coeff;\n    }\n}\n\n/**\n * \\brief partially reset render_context to style values\n * Works like {\\r}: resets some style overrides\n */\nvoid reset_render_context(ASS_Renderer *render_priv, ASS_Style *style)\n{\n    style = handle_selective_style_overrides(render_priv, style);\n\n    init_font_scale(render_priv);\n\n    render_priv->state.c[0] = style->PrimaryColour;\n    render_priv->state.c[1] = style->SecondaryColour;\n    render_priv->state.c[2] = style->OutlineColour;\n    render_priv->state.c[3] = style->BackColour;\n    render_priv->state.flags =\n        (style->Underline ? DECO_UNDERLINE : 0) |\n        (style->StrikeOut ? DECO_STRIKETHROUGH : 0);\n    render_priv->state.font_size = style->FontSize;\n\n    free(render_priv->state.family);\n    render_priv->state.family = NULL;\n    render_priv->state.family = strdup(style->FontName);\n    render_priv->state.treat_family_as_pattern =\n        style->treat_fontname_as_pattern;\n    render_priv->state.bold = style->Bold;\n    render_priv->state.italic = style->Italic;\n    update_font(render_priv);\n\n    render_priv->state.border_style = style->BorderStyle;\n    render_priv->state.border_x = style->Outline;\n    render_priv->state.border_y = style->Outline;\n    change_border(render_priv, render_priv->state.border_x, render_priv->state.border_y);\n    render_priv->state.scale_x = style->ScaleX;\n    render_priv->state.scale_y = style->ScaleY;\n    render_priv->state.hspacing = style->Spacing;\n    render_priv->state.be = 0;\n    render_priv->state.blur = style->Blur;\n    render_priv->state.shadow_x = style->Shadow;\n    render_priv->state.shadow_y = style->Shadow;\n    render_priv->state.frx = render_priv->state.fry = 0.;\n    render_priv->state.frz = M_PI * style->Angle / 180.;\n    render_priv->state.fax = render_priv->state.fay = 0.;\n    render_priv->state.font_encoding = style->Encoding;\n}\n\n/**\n * \\brief Start new event. Reset render_priv->state.\n */\nstatic void\ninit_render_context(ASS_Renderer *render_priv, ASS_Event *event)\n{\n    render_priv->state.event = event;\n    render_priv->state.parsed_tags = 0;\n    render_priv->state.has_clips = 0;\n    render_priv->state.evt_type = EVENT_NORMAL;\n\n    reset_render_context(render_priv, NULL);\n    render_priv->state.wrap_style = render_priv->track->WrapStyle;\n\n    render_priv->state.alignment = render_priv->state.style->Alignment;\n    render_priv->state.pos_x = 0;\n    render_priv->state.pos_y = 0;\n    render_priv->state.org_x = 0;\n    render_priv->state.org_y = 0;\n    render_priv->state.have_origin = 0;\n    render_priv->state.clip_x0 = 0;\n    render_priv->state.clip_y0 = 0;\n    render_priv->state.clip_x1 = render_priv->track->PlayResX;\n    render_priv->state.clip_y1 = render_priv->track->PlayResY;\n    render_priv->state.clip_mode = 0;\n    render_priv->state.detect_collisions = 1;\n    render_priv->state.fade = 0;\n    render_priv->state.drawing_scale = 0;\n    render_priv->state.pbo = 0;\n    render_priv->state.effect_type = EF_NONE;\n    render_priv->state.effect_timing = 0;\n    render_priv->state.effect_skip_timing = 0;\n\n    apply_transition_effects(render_priv, event);\n}\n\nstatic void free_render_context(ASS_Renderer *render_priv)\n{\n    ass_cache_dec_ref(render_priv->state.font);\n    free(render_priv->state.family);\n    ass_drawing_free(render_priv->state.clip_drawing);\n\n    render_priv->state.font = NULL;\n    render_priv->state.family = NULL;\n    render_priv->state.clip_drawing = NULL;\n\n    TextInfo *text_info = &render_priv->text_info;\n    for (int n = 0; n < text_info->length; n++)\n        ass_drawing_free(text_info->glyphs[n].drawing);\n    text_info->length = 0;\n}\n\n/*\n * Replace the outline of a glyph by a contour which makes up a simple\n * opaque rectangle.\n */\nstatic void draw_opaque_box(ASS_Renderer *render_priv, GlyphInfo *info,\n                            int asc, int desc, ASS_Outline *ol,\n                            FT_Vector advance, int sx, int sy)\n{\n    int adv = advance.x;\n    double scale_y = info->orig_scale_y;\n    double scale_x = info->orig_scale_x;\n\n    // to avoid gaps\n    sx = FFMAX(64, sx);\n    sy = FFMAX(64, sy);\n\n    // Emulate the WTFish behavior of VSFilter, i.e. double-scale\n    // the sizes of the opaque box.\n    adv += double_to_d6(info->hspacing * render_priv->font_scale * scale_x);\n    adv *= scale_x;\n    sx *= scale_x;\n    sy *= scale_y;\n    desc *= scale_y;\n    desc += asc * (scale_y - 1.0);\n\n    FT_Vector points[4] = {\n        { .x = -sx,         .y = asc + sy },\n        { .x = adv + sx,    .y = asc + sy },\n        { .x = adv + sx,    .y = -desc - sy },\n        { .x = -sx,         .y = -desc - sy },\n    };\n\n    ol->n_points = ol->n_contours = 0;\n    if (!outline_alloc(ol, 4, 1))\n        return;\n    for (int i = 0; i < 4; ++i) {\n        ol->points[ol->n_points] = points[i];\n        ol->tags[ol->n_points++] = 1;\n    }\n    ol->contours[ol->n_contours++] = ol->n_points - 1;\n}\n\n/*\n * Stroke an outline glyph in x/y direction.  Applies various fixups to get\n * around limitations of the FreeType stroker.\n */\nstatic void stroke_outline(ASS_Renderer *render_priv, ASS_Outline *outline,\n                           int sx, int sy)\n{\n    if (sx <= 0 && sy <= 0)\n        return;\n\n    fix_freetype_stroker(outline, sx, sy);\n\n    size_t n_points = outline->n_points;\n    if (n_points > SHRT_MAX) {\n        ass_msg(render_priv->library, MSGL_WARN, \"Too many outline points: %d\",\n                outline->n_points);\n        n_points = SHRT_MAX;\n    }\n\n    size_t n_contours = FFMIN(outline->n_contours, SHRT_MAX);\n    short contours_small[EFFICIENT_CONTOUR_COUNT];\n    short *contours = contours_small;\n    short *contours_large = NULL;\n    if (n_contours > EFFICIENT_CONTOUR_COUNT) {\n        contours_large = malloc(n_contours * sizeof(short));\n        if (!contours_large)\n            return;\n        contours = contours_large;\n    }\n    for (size_t i = 0; i < n_contours; ++i)\n        contours[i] = FFMIN(outline->contours[i], n_points - 1);\n\n    FT_Outline ftol;\n    ftol.n_points = n_points;\n    ftol.n_contours = n_contours;\n    ftol.points = outline->points;\n    ftol.tags = outline->tags;\n    ftol.contours = contours;\n    ftol.flags = 0;\n\n    // Borders are equal; use the regular stroker\n    if (sx == sy && render_priv->state.stroker) {\n        int error;\n        FT_StrokerBorder border = FT_Outline_GetOutsideBorder(&ftol);\n        error = FT_Stroker_ParseOutline(render_priv->state.stroker, &ftol, 0);\n        if (error) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"FT_Stroker_ParseOutline failed, error: %d\", error);\n        }\n        unsigned new_points, new_contours;\n        error = FT_Stroker_GetBorderCounts(render_priv->state.stroker, border,\n                &new_points, &new_contours);\n        if (error) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"FT_Stroker_GetBorderCounts failed, error: %d\", error);\n        }\n        outline_free(outline);\n        outline->n_points = outline->n_contours = 0;\n        if (new_contours > FFMAX(EFFICIENT_CONTOUR_COUNT, n_contours)) {\n            if (!ASS_REALLOC_ARRAY(contours_large, new_contours)) {\n                free(contours_large);\n                return;\n            }\n        }\n        n_points = new_points;\n        n_contours = new_contours;\n        if (!outline_alloc(outline, n_points, n_contours)) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"Not enough memory for border outline\");\n            free(contours_large);\n            return;\n        }\n        ftol.n_points = ftol.n_contours = 0;\n        ftol.points = outline->points;\n        ftol.tags = outline->tags;\n\n        FT_Stroker_ExportBorder(render_priv->state.stroker, border, &ftol);\n\n        outline->n_points = n_points;\n        outline->n_contours = n_contours;\n        for (size_t i = 0; i < n_contours; ++i)\n            outline->contours[i] = (unsigned short) contours[i];\n\n    // \"Stroke\" with the outline emboldener (in two passes if needed).\n    // The outlines look uglier, but the emboldening never adds any points\n    } else {\n#if (FREETYPE_MAJOR > 2) || \\\n    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 4)) || \\\n    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 4) && (FREETYPE_PATCH >= 10))\n        FT_Outline_EmboldenXY(&ftol, sx * 2, sy * 2);\n        FT_Outline_Translate(&ftol, -sx, -sy);\n#else\n        int i;\n        FT_Outline nol;\n\n        FT_Outline_New(render_priv->ftlibrary, ftol.n_points,\n                       ftol.n_contours, &nol);\n        FT_Outline_Copy(&ftol, &nol);\n\n        FT_Outline_Embolden(&ftol, sx * 2);\n        FT_Outline_Translate(&ftol, -sx, -sx);\n        FT_Outline_Embolden(&nol, sy * 2);\n        FT_Outline_Translate(&nol, -sy, -sy);\n\n        for (i = 0; i < ftol.n_points; i++)\n            ftol.points[i].y = nol.points[i].y;\n\n        FT_Outline_Done(render_priv->ftlibrary, &nol);\n#endif\n    }\n\n    free(contours_large);\n}\n\n/**\n * \\brief Prepare glyph hash\n */\nstatic void\nfill_glyph_hash(ASS_Renderer *priv, OutlineHashKey *outline_key,\n                GlyphInfo *info)\n{\n    if (info->drawing) {\n        DrawingHashKey *key = &outline_key->u.drawing;\n        outline_key->type = OUTLINE_DRAWING;\n        key->scale_x = double_to_d16(info->scale_x);\n        key->scale_y = double_to_d16(info->scale_y);\n        key->outline.x = double_to_d16(info->border_x);\n        key->outline.y = double_to_d16(info->border_y);\n        key->border_style = info->border_style;\n        // hpacing only matters for opaque box borders (see draw_opaque_box),\n        // so for normal borders, maximize cache utility by ignoring it\n        key->hspacing =\n            info->border_style == 3 ? double_to_d16(info->hspacing) : 0;\n        key->hash = info->drawing->hash;\n        key->text = info->drawing->text;\n        key->pbo = info->drawing->pbo;\n        key->scale = info->drawing->scale;\n    } else {\n        GlyphHashKey *key = &outline_key->u.glyph;\n        outline_key->type = OUTLINE_GLYPH;\n        key->font = info->font;\n        key->size = info->font_size;\n        key->face_index = info->face_index;\n        key->glyph_index = info->glyph_index;\n        key->bold = info->bold;\n        key->italic = info->italic;\n        key->scale_x = double_to_d16(info->scale_x);\n        key->scale_y = double_to_d16(info->scale_y);\n        key->outline.x = double_to_d16(info->border_x);\n        key->outline.y = double_to_d16(info->border_y);\n        key->flags = info->flags;\n        key->border_style = info->border_style;\n        key->hspacing =\n            info->border_style == 3 ? double_to_d16(info->hspacing) : 0;\n    }\n}\n\n/**\n * \\brief Prepare combined-bitmap hash\n */\nstatic void fill_composite_hash(CompositeHashKey *hk, CombinedBitmapInfo *info)\n{\n    hk->filter = info->filter;\n    hk->bitmap_count = info->bitmap_count;\n    hk->bitmaps = info->bitmaps;\n}\n\n/**\n * \\brief Get normal and outline (border) glyphs\n * \\param info out: struct filled with extracted data\n * Tries to get both glyphs from cache.\n * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,\n * and add them to cache.\n * The glyphs are returned in info->glyph and info->outline_glyph\n */\nstatic void\nget_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)\n{\n    memset(&info->hash_key, 0, sizeof(info->hash_key));\n\n    OutlineHashKey key;\n    OutlineHashValue *val;\n    fill_glyph_hash(priv, &key, info);\n    if (!ass_cache_get(priv->cache.outline_cache, &key, &val)) {\n        if (!val)\n            return;\n        memset(val, 0, sizeof(*val));\n\n        if (info->drawing) {\n            ASS_Drawing *drawing = info->drawing;\n            ass_drawing_hash(drawing);\n            if(!ass_drawing_parse(drawing, 0)) {\n                ass_cache_commit(val, 1);\n                ass_cache_dec_ref(val);\n                return;\n            }\n            val->outline = outline_copy(&drawing->outline);\n            val->advance.x = drawing->advance.x;\n            val->advance.y = drawing->advance.y;\n            val->asc = drawing->asc;\n            val->desc = drawing->desc;\n        } else {\n            ass_face_set_size(info->font->faces[info->face_index],\n                              info->font_size);\n            ass_font_set_transform(info->font, info->scale_x,\n                                   info->scale_y, NULL);\n            FT_Glyph glyph =\n                ass_font_get_glyph(info->font,\n                        info->symbol, info->face_index, info->glyph_index,\n                        priv->settings.hinting, info->flags);\n            if (glyph != NULL) {\n                val->outline = outline_convert(&((FT_OutlineGlyph) glyph)->outline);\n                if (priv->settings.shaper == ASS_SHAPING_SIMPLE) {\n                    val->advance.x = d16_to_d6(glyph->advance.x);\n                    val->advance.y = d16_to_d6(glyph->advance.y);\n                }\n                FT_Done_Glyph(glyph);\n                ass_font_get_asc_desc(info->font, info->symbol,\n                                      &val->asc, &val->desc);\n                val->asc  *= info->scale_y;\n                val->desc *= info->scale_y;\n            }\n        }\n\n        if (!val->outline) {\n            ass_cache_commit(val, 1);\n            ass_cache_dec_ref(val);\n            return;\n        }\n\n        outline_get_cbox(val->outline, &val->bbox_scaled);\n\n        if (info->border_style == 3) {\n            val->border = calloc(1, sizeof(ASS_Outline));\n            if (!val->border) {\n                outline_free(val->outline);\n                free(val->outline);\n                val->outline = NULL;\n                ass_cache_commit(val, 1);\n                ass_cache_dec_ref(val);\n                return;\n            }\n\n            FT_Vector advance;\n            if (priv->settings.shaper == ASS_SHAPING_SIMPLE || info->drawing)\n                advance = val->advance;\n            else\n                advance = info->advance;\n\n            draw_opaque_box(priv, info, val->asc, val->desc, val->border, advance,\n                    double_to_d6(info->border_x * priv->border_scale),\n                    double_to_d6(info->border_y * priv->border_scale));\n\n        } else if ((info->border_x > 0 || info->border_y > 0)\n                && double_to_d6(info->scale_x) && double_to_d6(info->scale_y)) {\n\n            change_border(priv, info->border_x, info->border_y);\n            val->border = outline_copy(val->outline);\n            stroke_outline(priv, val->border,\n                    double_to_d6(info->border_x * priv->border_scale),\n                    double_to_d6(info->border_y * priv->border_scale));\n        }\n\n        ass_cache_commit(val, 1);\n    }\n\n    if (!val->outline) {\n        ass_cache_dec_ref(val);\n        return;\n    }\n\n    info->hash_key.u.outline.outline = val;\n    info->outline = val->outline;\n    info->border = val->border;\n    info->bbox = val->bbox_scaled;\n    if (info->drawing || priv->settings.shaper == ASS_SHAPING_SIMPLE) {\n        info->cluster_advance.x = info->advance.x = val->advance.x;\n        info->cluster_advance.y = info->advance.y = val->advance.y;\n    }\n    info->asc = val->asc;\n    info->desc = val->desc;\n}\n\n/**\n * \\brief Apply transformation to outline points of a glyph\n * Applies rotations given by frx, fry and frz and projects the points back\n * onto the screen plane.\n */\nstatic void\ntransform_3d_points(FT_Vector shift, ASS_Outline *outline, double frx, double fry,\n                    double frz, double fax, double fay, double scale,\n                    int yshift)\n{\n    double sx = sin(frx);\n    double sy = sin(fry);\n    double sz = sin(frz);\n    double cx = cos(frx);\n    double cy = cos(fry);\n    double cz = cos(frz);\n    FT_Vector *p = outline->points;\n    double x, y, z, xx, yy, zz;\n    int dist;\n\n    dist = 20000 * scale;\n    for (size_t i = 0; i < outline->n_points; ++i) {\n        x = (double) p[i].x + shift.x + (fax * (yshift - p[i].y));\n        y = (double) p[i].y + shift.y + (-fay * p[i].x);\n        z = 0.;\n\n        xx = x * cz + y * sz;\n        yy = -(x * sz - y * cz);\n        zz = z;\n\n        x = xx;\n        y = yy * cx + zz * sx;\n        z = yy * sx - zz * cx;\n\n        xx = x * cy + z * sy;\n        yy = y;\n        zz = x * sy - z * cy;\n\n        zz = FFMAX(zz, 1000 - dist);\n\n        x = (xx * dist) / (zz + dist);\n        y = (yy * dist) / (zz + dist);\n        p[i].x = x - shift.x + 0.5;\n        p[i].y = y - shift.y + 0.5;\n    }\n}\n\n/**\n * \\brief Apply 3d transformation to several objects\n * \\param shift FreeType vector\n * \\param glyph FreeType glyph\n * \\param glyph2 FreeType glyph\n * \\param frx x-axis rotation angle\n * \\param fry y-axis rotation angle\n * \\param frz z-axis rotation angle\n * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.\n */\nstatic void\ntransform_3d(FT_Vector shift, ASS_Outline *outline, ASS_Outline *border,\n             double frx, double fry, double frz, double fax, double fay,\n             double scale, int yshift)\n{\n    frx = -frx;\n    frz = -frz;\n    if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {\n        if (outline)\n            transform_3d_points(shift, outline, frx, fry, frz,\n                                fax, fay, scale, yshift);\n\n        if (border)\n            transform_3d_points(shift, border, frx, fry, frz,\n                                fax, fay, scale, yshift);\n    }\n}\n\n/**\n * \\brief Get bitmaps for a glyph\n * \\param info glyph info\n * Tries to get glyph bitmaps from bitmap cache.\n * If they can't be found, they are generated by rotating and rendering the glyph.\n * After that, bitmaps are added to the cache.\n * They are returned in info->bm (glyph), info->bm_o (outline) and info->bm_s (shadow).\n */\nstatic void\nget_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)\n{\n    if (!info->outline || info->symbol == '\\n' || info->symbol == 0 || info->skip)\n        return;\n\n    BitmapHashValue *val;\n    OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n    if (ass_cache_get(render_priv->cache.bitmap_cache, &info->hash_key, &val)) {\n        info->image = val;\n        return;\n    }\n    if (!val)\n        return;\n\n    ASS_Outline *outline = outline_copy(info->outline);\n    ASS_Outline *border  = outline_copy(info->border);\n\n    // calculating rotation shift vector (from rotation origin to the glyph basepoint)\n    FT_Vector shift = { key->shift_x, key->shift_y };\n    double scale_x = render_priv->font_scale_x;\n    double fax_scaled = info->fax / info->scale_y * info->scale_x;\n    double fay_scaled = info->fay / info->scale_x * info->scale_y;\n\n    // apply rotation\n    // use blur_scale because, like blurs, VSFilter forgets to scale this\n    transform_3d(shift, outline, border,\n                 info->frx, info->fry, info->frz, fax_scaled,\n                 fay_scaled, render_priv->blur_scale, info->asc);\n\n    // PAR correction scaling\n    FT_Matrix m = { double_to_d16(scale_x), 0,\n                    0, double_to_d16(1.0) };\n\n    // subpixel shift\n    if (outline) {\n        if (scale_x != 1.0)\n            outline_transform(outline, &m);\n        outline_translate(outline, key->advance.x, -key->advance.y);\n    }\n    if (border) {\n        if (scale_x != 1.0)\n            outline_transform(border, &m);\n        outline_translate(border, key->advance.x, -key->advance.y);\n    }\n\n    // render glyph\n    int error = outline_to_bitmap2(render_priv, outline, border,\n                                   &val->bm, &val->bm_o);\n    if (error)\n        info->symbol = 0;\n\n    ass_cache_commit(val, bitmap_size(val->bm) + bitmap_size(val->bm_o) +\n                     sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n    info->image = val;\n\n    outline_free(outline);\n    free(outline);\n    outline_free(border);\n    free(border);\n}\n\n/**\n * This function goes through text_info and calculates text parameters.\n * The following text_info fields are filled:\n *   height\n *   lines[].height\n *   lines[].asc\n *   lines[].desc\n */\nstatic void measure_text(ASS_Renderer *render_priv)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    int cur_line = 0;\n    double max_asc = 0., max_desc = 0.;\n    GlyphInfo *last = NULL;\n    int i;\n    int empty_line = 1;\n    text_info->height = 0.;\n    for (i = 0; i < text_info->length + 1; ++i) {\n        if ((i == text_info->length) || text_info->glyphs[i].linebreak) {\n            if (empty_line && cur_line > 0 && last) {\n                max_asc = d6_to_double(last->asc) / 2.0;\n                max_desc = d6_to_double(last->desc) / 2.0;\n            }\n            text_info->lines[cur_line].asc = max_asc;\n            text_info->lines[cur_line].desc = max_desc;\n            text_info->height += max_asc + max_desc;\n            cur_line++;\n            max_asc = max_desc = 0.;\n            empty_line = 1;\n        }\n        if (i < text_info->length) {\n            GlyphInfo *cur = text_info->glyphs + i;\n            if (d6_to_double(cur->asc) > max_asc)\n                max_asc = d6_to_double(cur->asc);\n            if (d6_to_double(cur->desc) > max_desc)\n                max_desc = d6_to_double(cur->desc);\n            if (cur->symbol != '\\n' && cur->symbol != 0) {\n                empty_line = 0;\n                last = cur;\n            }\n        }\n    }\n    text_info->height +=\n        (text_info->n_lines -\n         1) * render_priv->settings.line_spacing;\n}\n\n/**\n * Mark extra whitespace for later removal.\n */\n#define IS_WHITESPACE(x) ((x->symbol == ' ' || x->symbol == '\\n') \\\n                          && !x->linebreak)\nstatic void trim_whitespace(ASS_Renderer *render_priv)\n{\n    int i, j;\n    GlyphInfo *cur;\n    TextInfo *ti = &render_priv->text_info;\n\n    // Mark trailing spaces\n    i = ti->length - 1;\n    cur = ti->glyphs + i;\n    while (i && IS_WHITESPACE(cur)) {\n        cur->skip++;\n        cur = ti->glyphs + --i;\n    }\n\n    // Mark leading whitespace\n    i = 0;\n    cur = ti->glyphs;\n    while (i < ti->length && IS_WHITESPACE(cur)) {\n        cur->skip++;\n        cur = ti->glyphs + ++i;\n    }\n\n    // Mark all extraneous whitespace inbetween\n    for (i = 0; i < ti->length; ++i) {\n        cur = ti->glyphs + i;\n        if (cur->linebreak) {\n            // Mark whitespace before\n            j = i - 1;\n            cur = ti->glyphs + j;\n            while (j && IS_WHITESPACE(cur)) {\n                cur->skip++;\n                cur = ti->glyphs + --j;\n            }\n            // A break itself can contain a whitespace, too\n            cur = ti->glyphs + i;\n            if (cur->symbol == ' ' || cur->symbol == '\\n') {\n                cur->skip++;\n                // Mark whitespace after\n                j = i + 1;\n                cur = ti->glyphs + j;\n                while (j < ti->length && IS_WHITESPACE(cur)) {\n                    cur->skip++;\n                    cur = ti->glyphs + ++j;\n                }\n                i = j - 1;\n            }\n        }\n    }\n}\n#undef IS_WHITESPACE\n\n/**\n * \\brief rearrange text between lines\n * \\param max_text_width maximal text line width in pixels\n * The algo is similar to the one in libvo/sub.c:\n * 1. Place text, wrapping it when current line is full\n * 2. Try moving words from the end of a line to the beginning of the next one while it reduces\n * the difference in lengths between this two lines.\n * The result may not be optimal, but usually is good enough.\n *\n * FIXME: implement style 0 and 3 correctly\n */\nstatic void\nwrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)\n{\n    int i;\n    GlyphInfo *cur, *s1, *e1, *s2, *s3;\n    int last_space;\n    int break_type;\n    int exit;\n    double pen_shift_x;\n    double pen_shift_y;\n    int cur_line;\n    int run_offset;\n    TextInfo *text_info = &render_priv->text_info;\n\n    last_space = -1;\n    text_info->n_lines = 1;\n    break_type = 0;\n    s1 = text_info->glyphs;     // current line start\n    for (i = 0; i < text_info->length; ++i) {\n        int break_at = -1;\n        double s_offset, len;\n        cur = text_info->glyphs + i;\n        s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);\n        len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;\n\n        if (cur->symbol == '\\n') {\n            break_type = 2;\n            break_at = i;\n            ass_msg(render_priv->library, MSGL_DBG2,\n                    \"forced line break at %d\", break_at);\n        } else if (cur->symbol == ' ') {\n            last_space = i;\n        } else if (len >= max_text_width\n                   && (render_priv->state.wrap_style != 2)) {\n            break_type = 1;\n            break_at = last_space;\n            if (break_at >= 0)\n                ass_msg(render_priv->library, MSGL_DBG2, \"line break at %d\",\n                        break_at);\n        }\n\n        if (break_at != -1) {\n            // need to use one more line\n            // marking break_at+1 as start of a new line\n            int lead = break_at + 1;    // the first symbol of the new line\n            if (text_info->n_lines >= text_info->max_lines) {\n                // Raise maximum number of lines\n                text_info->max_lines *= 2;\n                text_info->lines = realloc(text_info->lines,\n                                           sizeof(LineInfo) *\n                                           text_info->max_lines);\n            }\n            if (lead < text_info->length) {\n                text_info->glyphs[lead].linebreak = break_type;\n                last_space = -1;\n                s1 = text_info->glyphs + lead;\n                text_info->n_lines++;\n            }\n        }\n    }\n#define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))\n    exit = 0;\n    while (!exit && render_priv->state.wrap_style != 1) {\n        exit = 1;\n        s3 = text_info->glyphs;\n        s1 = s2 = 0;\n        for (i = 0; i <= text_info->length; ++i) {\n            cur = text_info->glyphs + i;\n            if ((i == text_info->length) || cur->linebreak) {\n                s1 = s2;\n                s2 = s3;\n                s3 = cur;\n                if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'\n                    double l1, l2, l1_new, l2_new;\n                    GlyphInfo *w = s2;\n\n                    do {\n                        --w;\n                    } while ((w > s1) && (w->symbol == ' '));\n                    while ((w > s1) && (w->symbol != ' ')) {\n                        --w;\n                    }\n                    e1 = w;\n                    while ((e1 > s1) && (e1->symbol == ' ')) {\n                        --e1;\n                    }\n                    if (w->symbol == ' ')\n                        ++w;\n\n                    l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -\n                        (s1->bbox.xMin + s1->pos.x));\n                    l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -\n                        (s2->bbox.xMin + s2->pos.x));\n                    l1_new = d6_to_double(\n                        (e1->bbox.xMax + e1->pos.x) -\n                        (s1->bbox.xMin + s1->pos.x));\n                    l2_new = d6_to_double(\n                        ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -\n                        (w->bbox.xMin + w->pos.x));\n\n                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {\n                        w->linebreak = 1;\n                        s2->linebreak = 0;\n                        exit = 0;\n                    }\n                }\n            }\n            if (i == text_info->length)\n                break;\n        }\n\n    }\n    assert(text_info->n_lines >= 1);\n#undef DIFF\n\n    measure_text(render_priv);\n    trim_whitespace(render_priv);\n\n    cur_line = 1;\n    run_offset = 0;\n\n    i = 0;\n    cur = text_info->glyphs + i;\n    while (i < text_info->length && cur->skip)\n        cur = text_info->glyphs + ++i;\n    pen_shift_x = d6_to_double(-cur->pos.x);\n    pen_shift_y = 0.;\n\n    for (i = 0; i < text_info->length; ++i) {\n        cur = text_info->glyphs + i;\n        if (cur->linebreak) {\n            while (i < text_info->length && cur->skip && cur->symbol != '\\n')\n                cur = text_info->glyphs + ++i;\n            double height =\n                text_info->lines[cur_line - 1].desc +\n                text_info->lines[cur_line].asc;\n            text_info->lines[cur_line - 1].len = i -\n                text_info->lines[cur_line - 1].offset;\n            text_info->lines[cur_line].offset = i;\n            cur_line++;\n            run_offset++;\n            pen_shift_x = d6_to_double(-cur->pos.x);\n            pen_shift_y += height + render_priv->settings.line_spacing;\n        }\n        cur->pos.x += double_to_d6(pen_shift_x);\n        cur->pos.y += double_to_d6(pen_shift_y);\n    }\n    text_info->lines[cur_line - 1].len =\n        text_info->length - text_info->lines[cur_line - 1].offset;\n\n#if 0\n    // print line info\n    for (i = 0; i < text_info->n_lines; i++) {\n        printf(\"line %d offset %d length %d\\n\", i, text_info->lines[i].offset,\n                text_info->lines[i].len);\n    }\n#endif\n}\n\n/**\n * \\brief Calculate base point for positioning and rotation\n * \\param bbox text bbox\n * \\param alignment alignment\n * \\param bx, by out: base point coordinates\n */\nstatic void get_base_point(DBBox *bbox, int alignment, double *bx, double *by)\n{\n    const int halign = alignment & 3;\n    const int valign = alignment & 12;\n    if (bx)\n        switch (halign) {\n        case HALIGN_LEFT:\n            *bx = bbox->xMin;\n            break;\n        case HALIGN_CENTER:\n            *bx = (bbox->xMax + bbox->xMin) / 2.0;\n            break;\n        case HALIGN_RIGHT:\n            *bx = bbox->xMax;\n            break;\n        }\n    if (by)\n        switch (valign) {\n        case VALIGN_TOP:\n            *by = bbox->yMin;\n            break;\n        case VALIGN_CENTER:\n            *by = (bbox->yMax + bbox->yMin) / 2.0;\n            break;\n        case VALIGN_SUB:\n            *by = bbox->yMax;\n            break;\n        }\n}\n\n/**\n * Prepare bitmap hash key of a glyph\n */\nstatic void\nfill_bitmap_hash(ASS_Renderer *priv, GlyphInfo *info,\n                 OutlineBitmapHashKey *hash_key)\n{\n    hash_key->frx = rot_key(info->frx);\n    hash_key->fry = rot_key(info->fry);\n    hash_key->frz = rot_key(info->frz);\n    hash_key->fax = double_to_d16(info->fax);\n    hash_key->fay = double_to_d16(info->fay);\n}\n\n/**\n * \\brief Adjust the glyph's font size and scale factors to ensure smooth\n *  scaling and handle pathological font sizes. The main problem here is\n *  freetype's grid fitting, which destroys animations by font size, or will\n *  result in incorrect final text size if font sizes are very small and\n *  scale factors very large. See Google Code issue #46.\n * \\param priv guess what\n * \\param glyph the glyph to be modified\n */\nstatic void\nfix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)\n{\n    double ft_size;\n    if (priv->settings.hinting == ASS_HINTING_NONE) {\n        // arbitrary, not too small to prevent grid fitting rounding effects\n        // XXX: this is a rather crude hack\n        ft_size = 256.0;\n    } else {\n        // If hinting is enabled, we want to pass the real font size\n        // to freetype. Normalize scale_y to 1.0.\n        ft_size = glyph->scale_y * glyph->font_size;\n    }\n    glyph->scale_x = glyph->scale_x * glyph->font_size / ft_size;\n    glyph->scale_y = glyph->scale_y * glyph->font_size / ft_size;\n    glyph->font_size = ft_size;\n}\n\n /**\n  * \\brief Checks whether a glyph should start a new bitmap run\n  * \\param info Pointer to new GlyphInfo to check\n  * \\param current_info Pointer to CombinedBitmapInfo for current run (may be NULL)\n  * \\return 1 if a new run should be started\n  */\nstatic int is_new_bm_run(GlyphInfo *info, GlyphInfo *last)\n{\n    // FIXME: Don't break on glyph substitutions\n    return !last || info->effect || info->drawing || last->drawing ||\n        strcmp(last->font->desc.family, info->font->desc.family) ||\n        last->font->desc.vertical != info->font->desc.vertical ||\n        last->face_index != info->face_index ||\n        last->font_size != info->font_size ||\n        last->c[0] != info->c[0] ||\n        last->c[1] != info->c[1] ||\n        last->c[2] != info->c[2] ||\n        last->c[3] != info->c[3] ||\n        last->be != info->be ||\n        last->blur != info->blur ||\n        last->shadow_x != info->shadow_x ||\n        last->shadow_y != info->shadow_y ||\n        last->frx != info->frx ||\n        last->fry != info->fry ||\n        last->frz != info->frz ||\n        last->fax != info->fax ||\n        last->fay != info->fay ||\n        last->scale_x != info->scale_x ||\n        last->scale_y != info->scale_y ||\n        last->border_style != info->border_style ||\n        last->border_x != info->border_x ||\n        last->border_y != info->border_y ||\n        last->hspacing != info->hspacing ||\n        last->italic != info->italic ||\n        last->bold != info->bold ||\n        last->flags != info->flags;\n}\n\nstatic void make_shadow_bitmap(CombinedBitmapInfo *info, ASS_Renderer *render_priv)\n{\n    if (!(info->filter.flags & FILTER_NONZERO_SHADOW)) {\n        if (info->bm && info->bm_o && !(info->filter.flags & FILTER_BORDER_STYLE_3)) {\n            fix_outline(info->bm, info->bm_o);\n        } else if (info->bm_o && !(info->filter.flags & FILTER_NONZERO_BORDER)) {\n            ass_free_bitmap(info->bm_o);\n            info->bm_o = 0;\n        }\n        return;\n    }\n\n    // Create shadow and fix outline as needed\n    if (info->bm && info->bm_o && !(info->filter.flags & FILTER_BORDER_STYLE_3)) {\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm_o);\n        fix_outline(info->bm, info->bm_o);\n    } else if (info->bm_o && (info->filter.flags & FILTER_NONZERO_BORDER)) {\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm_o);\n    } else if (info->bm_o) {\n        info->bm_s = info->bm_o;\n        info->bm_o = 0;\n    } else if (info->bm)\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm);\n\n    if (!info->bm_s)\n        return;\n\n    // Works right even for negative offsets\n    // '>>' rounds toward negative infinity, '&' returns correct remainder\n    info->bm_s->left += info->filter.shadow.x >> 6;\n    info->bm_s->top  += info->filter.shadow.y >> 6;\n    shift_bitmap(info->bm_s, info->filter.shadow.x & SUBPIXEL_MASK, info->filter.shadow.y & SUBPIXEL_MASK);\n}\n\n// Parse event text.\n// Fill render_priv->text_info.\nstatic int parse_events(ASS_Renderer *render_priv, ASS_Event *event)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    ASS_Drawing *drawing = NULL;\n    unsigned code;\n    char *p, *q;\n    int i;\n\n    p = event->Text;\n\n    // Event parsing.\n    while (1) {\n        // get next char, executing style override\n        // this affects render_context\n        code = 0;\n        while (*p) {\n            if ((*p == '{') && (q = strchr(p, '}'))) {\n                while (p < q)\n                    p = parse_tag(render_priv, p, q, 1.);\n                assert(*p == '}');\n                p++;\n            } else if (render_priv->state.drawing_scale) {\n                q = p;\n                if (*p == '{')\n                    q++;\n                while ((*q != '{') && (*q != 0))\n                    q++;\n                if (!drawing) {\n                    drawing = ass_drawing_new(render_priv->library,\n                                              render_priv->ftlibrary);\n                    if (!drawing)\n                        return 1;\n                }\n                ass_drawing_set_text(drawing, p, q - p);\n                code = 0xfffc; // object replacement character\n                p = q;\n                break;\n            } else {\n                code = get_next_char(render_priv, &p);\n                break;\n            }\n        }\n\n        if (code == 0)\n            break;\n\n        // face could have been changed in get_next_char\n        if (!render_priv->state.font) {\n            free_render_context(render_priv);\n            ass_drawing_free(drawing);\n            return 1;\n        }\n\n        if (text_info->length >= text_info->max_glyphs) {\n            // Raise maximum number of glyphs\n            text_info->max_glyphs *= 2;\n            text_info->glyphs =\n                realloc(text_info->glyphs,\n                        sizeof(GlyphInfo) * text_info->max_glyphs);\n        }\n\n        GlyphInfo *info = &text_info->glyphs[text_info->length];\n\n        // Clear current GlyphInfo\n        memset(info, 0, sizeof(GlyphInfo));\n\n        // Parse drawing\n        if (drawing && drawing->text) {\n            drawing->scale_x = render_priv->state.scale_x *\n                                     render_priv->font_scale;\n            drawing->scale_y = render_priv->state.scale_y *\n                                     render_priv->font_scale;\n            drawing->scale = render_priv->state.drawing_scale;\n            drawing->pbo = render_priv->state.pbo;\n            info->drawing = drawing;\n            drawing = NULL;\n        }\n\n        // Fill glyph information\n        info->symbol = code;\n        info->font = render_priv->state.font;\n        if (!info->drawing)\n            ass_cache_inc_ref(info->font);\n        for (i = 0; i < 4; ++i) {\n            uint32_t clr = render_priv->state.c[i];\n            // VSFilter compatibility: apply fade only when it's positive\n            if (render_priv->state.fade > 0)\n                change_alpha(&clr,\n                             mult_alpha(_a(clr), render_priv->state.fade), 1.);\n            info->c[i] = clr;\n        }\n\n        info->effect_type = render_priv->state.effect_type;\n        info->effect_timing = render_priv->state.effect_timing;\n        info->effect_skip_timing = render_priv->state.effect_skip_timing;\n        info->font_size =\n            render_priv->state.font_size * render_priv->font_scale;\n        info->be = render_priv->state.be;\n        info->blur = render_priv->state.blur;\n        info->shadow_x = render_priv->state.shadow_x;\n        info->shadow_y = render_priv->state.shadow_y;\n        info->scale_x = info->orig_scale_x = render_priv->state.scale_x;\n        info->scale_y = info->orig_scale_y = render_priv->state.scale_y;\n        info->border_style = render_priv->state.border_style;\n        info->border_x= render_priv->state.border_x;\n        info->border_y = render_priv->state.border_y;\n        info->hspacing = render_priv->state.hspacing;\n        info->bold = render_priv->state.bold;\n        info->italic = render_priv->state.italic;\n        info->flags = render_priv->state.flags;\n        info->frx = render_priv->state.frx;\n        info->fry = render_priv->state.fry;\n        info->frz = render_priv->state.frz;\n        info->fax = render_priv->state.fax;\n        info->fay = render_priv->state.fay;\n\n        if (!info->drawing)\n            fix_glyph_scaling(render_priv, info);\n\n        text_info->length++;\n\n        render_priv->state.effect_type = EF_NONE;\n        render_priv->state.effect_timing = 0;\n        render_priv->state.effect_skip_timing = 0;\n    }\n\n    ass_drawing_free(drawing);\n\n    return 0;\n}\n\n// Process render_priv->text_info and load glyph outlines.\nstatic void retrieve_glyphs(ASS_Renderer *render_priv)\n{\n    GlyphInfo *glyphs = render_priv->text_info.glyphs;\n    int i;\n\n    for (i = 0; i < render_priv->text_info.length; i++) {\n        GlyphInfo *info = glyphs + i;\n        while (info) {\n            get_outline_glyph(render_priv, info);\n            info = info->next;\n        }\n        info = glyphs + i;\n\n        // Add additional space after italic to non-italic style changes\n        if (i && glyphs[i - 1].italic && !info->italic) {\n            int back = i - 1;\n            GlyphInfo *og = &glyphs[back];\n            while (back && og->bbox.xMax - og->bbox.xMin == 0\n                    && og->italic)\n                og = &glyphs[--back];\n            if (og->bbox.xMax > og->cluster_advance.x)\n                og->cluster_advance.x = og->bbox.xMax;\n        }\n\n        // add horizontal letter spacing\n        info->cluster_advance.x += double_to_d6(info->hspacing *\n                render_priv->font_scale * info->orig_scale_x);\n\n        // add displacement for vertical shearing\n        info->cluster_advance.y += (info->fay / info->scale_x * info->scale_y) * info->cluster_advance.x;\n    }\n}\n\n// Preliminary layout (for line wrapping)\nstatic void preliminary_layout(ASS_Renderer *render_priv)\n{\n    FT_Vector pen;\n    int i;\n\n    pen.x = 0;\n    pen.y = 0;\n    for (i = 0; i < render_priv->text_info.length; i++) {\n        GlyphInfo *info = render_priv->text_info.glyphs + i;\n        FT_Vector cluster_pen = pen;\n        while (info) {\n            info->pos.x = cluster_pen.x;\n            info->pos.y = cluster_pen.y;\n\n            cluster_pen.x += info->advance.x;\n            cluster_pen.y += info->advance.y;\n\n            // fill bitmap hash\n            info->hash_key.type = BITMAP_OUTLINE;\n            fill_bitmap_hash(render_priv, info, &info->hash_key.u.outline);\n\n            info = info->next;\n        }\n        info = render_priv->text_info.glyphs + i;\n        pen.x += info->cluster_advance.x;\n        pen.y += info->cluster_advance.y;\n    }\n}\n\n// Reorder text into visual order\nstatic void reorder_text(ASS_Renderer *render_priv)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    FT_Vector pen;\n    int i;\n\n    FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv->shaper, text_info);\n    if (!cmap) {\n        ass_msg(render_priv->library, MSGL_ERR, \"Failed to reorder text\");\n        ass_shaper_cleanup(render_priv->shaper, text_info);\n        free_render_context(render_priv);\n        return;\n    }\n\n    // Reposition according to the map\n    pen.x = 0;\n    pen.y = 0;\n    int lineno = 1;\n    double last_pen_x = 0;\n    double last_fay = 0;\n    for (i = 0; i < text_info->length; i++) {\n        GlyphInfo *info = text_info->glyphs + cmap[i];\n        if (text_info->glyphs[i].linebreak) {\n            pen.y -= (last_fay / info->scale_x * info->scale_y) * (pen.x - last_pen_x);\n            last_pen_x = pen.x = 0;\n            pen.y += double_to_d6(text_info->lines[lineno-1].desc);\n            pen.y += double_to_d6(text_info->lines[lineno].asc);\n            pen.y += double_to_d6(render_priv->settings.line_spacing);\n            lineno++;\n        }\n        else if (last_fay != info->fay) {\n            pen.y -= (last_fay / info->scale_x * info->scale_y) * (pen.x - last_pen_x);\n            last_pen_x = pen.x;\n        }\n        last_fay = info->fay;\n        if (info->skip) continue;\n        FT_Vector cluster_pen = pen;\n        while (info) {\n            info->pos.x = info->offset.x + cluster_pen.x;\n            info->pos.y = info->offset.y + cluster_pen.y;\n            cluster_pen.x += info->advance.x;\n            cluster_pen.y += info->advance.y;\n            info = info->next;\n        }\n        info = text_info->glyphs + cmap[i];\n        pen.x += info->cluster_advance.x;\n        pen.y += info->cluster_advance.y;\n    }\n}\n\nstatic void align_lines(ASS_Renderer *render_priv, double max_text_width)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    GlyphInfo *glyphs = text_info->glyphs;\n    int i, j;\n    double width = 0;\n    int last_break = -1;\n    int halign = render_priv->state.alignment & 3;\n\n    if (render_priv->state.evt_type == EVENT_HSCROLL)\n        return;\n\n    for (i = 0; i <= text_info->length; ++i) {   // (text_info->length + 1) is the end of the last line\n        if ((i == text_info->length) || glyphs[i].linebreak) {\n            double shift = 0;\n            if (halign == HALIGN_LEFT) {    // left aligned, no action\n                shift = 0;\n            } else if (halign == HALIGN_RIGHT) {    // right aligned\n                shift = max_text_width - width;\n            } else if (halign == HALIGN_CENTER) {   // centered\n                shift = (max_text_width - width) / 2.0;\n            }\n            for (j = last_break + 1; j < i; ++j) {\n                GlyphInfo *info = glyphs + j;\n                while (info) {\n                    info->pos.x += double_to_d6(shift);\n                    info = info->next;\n                }\n            }\n            last_break = i - 1;\n            width = 0;\n        }\n        if (i < text_info->length && !glyphs[i].skip &&\n                glyphs[i].symbol != '\\n' && glyphs[i].symbol != 0) {\n            width += d6_to_double(glyphs[i].cluster_advance.x);\n        }\n    }\n}\n\nstatic void calculate_rotation_params(ASS_Renderer *render_priv, DBBox *bbox,\n                                      double device_x, double device_y)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    DVector center;\n    int i;\n\n    if (render_priv->state.have_origin) {\n        center.x = x2scr(render_priv, render_priv->state.org_x);\n        center.y = y2scr(render_priv, render_priv->state.org_y);\n    } else {\n        double bx = 0., by = 0.;\n        get_base_point(bbox, render_priv->state.alignment, &bx, &by);\n        center.x = device_x + bx;\n        center.y = device_y + by;\n    }\n\n    for (i = 0; i < text_info->length; ++i) {\n        GlyphInfo *info = text_info->glyphs + i;\n        while (info) {\n            OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n\n            if (key->frx || key->fry || key->frz || key->fax || key->fay) {\n                key->shift_x = info->pos.x + double_to_d6(device_x - center.x);\n                key->shift_y = -(info->pos.y + double_to_d6(device_y - center.y));\n            } else {\n                key->shift_x = 0;\n                key->shift_y = 0;\n            }\n            info = info->next;\n        }\n    }\n}\n\n\nstatic inline void rectangle_reset(Rectangle *rect)\n{\n    rect->x_min = rect->y_min = INT_MAX;\n    rect->x_max = rect->y_max = INT_MIN;\n}\n\nstatic inline void rectangle_combine(Rectangle *rect, const Bitmap *bm, int x, int y)\n{\n    rect->x_min = FFMIN(rect->x_min, x + bm->left);\n    rect->y_min = FFMIN(rect->y_min, y + bm->top);\n    rect->x_max = FFMAX(rect->x_max, x + bm->left + bm->w);\n    rect->y_max = FFMAX(rect->y_max, y + bm->top + bm->h);\n}\n\n// Convert glyphs to bitmaps, combine them, apply blur, generate shadows.\nstatic void render_and_combine_glyphs(ASS_Renderer *render_priv,\n                                      double device_x, double device_y)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    int left = render_priv->settings.left_margin;\n    device_x = (device_x - left) * render_priv->font_scale_x + left;\n    unsigned nb_bitmaps = 0;\n    char linebreak = 0;\n    CombinedBitmapInfo *combined_info = text_info->combined_bitmaps;\n    CombinedBitmapInfo *current_info = NULL;\n    GlyphInfo *last_info = NULL;\n    for (int i = 0; i < text_info->length; i++) {\n        GlyphInfo *info = text_info->glyphs + i;\n        if (info->linebreak) linebreak = 1;\n        if (info->skip) {\n            for (; info; info = info->next)\n                ass_cache_dec_ref(info->hash_key.u.outline.outline);\n            continue;\n        }\n        for (; info; info = info->next) {\n            OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n\n            info->pos.x = double_to_d6(device_x + d6_to_double(info->pos.x) * render_priv->font_scale_x);\n            info->pos.y = double_to_d6(device_y) + info->pos.y;\n            key->advance.x = info->pos.x & (SUBPIXEL_MASK & ~SUBPIXEL_ACCURACY);\n            key->advance.y = info->pos.y & (SUBPIXEL_MASK & ~SUBPIXEL_ACCURACY);\n            int x = info->pos.x >> 6, y = info->pos.y >> 6;\n            get_bitmap_glyph(render_priv, info);\n\n            if(linebreak || is_new_bm_run(info, last_info)) {\n                linebreak = 0;\n                last_info = NULL;\n                if (nb_bitmaps >= text_info->max_bitmaps) {\n                    size_t new_size = 2 * text_info->max_bitmaps;\n                    if (!ASS_REALLOC_ARRAY(text_info->combined_bitmaps, new_size)) {\n                        ass_cache_dec_ref(info->image);\n                        continue;\n                    }\n                    text_info->max_bitmaps = new_size;\n                    combined_info = text_info->combined_bitmaps;\n                }\n                current_info = &combined_info[nb_bitmaps];\n\n                memcpy(&current_info->c, &info->c, sizeof(info->c));\n                current_info->effect_type = info->effect_type;\n                current_info->effect_timing = info->effect_timing;\n                current_info->first_pos_x = info->bbox.xMax >> 6;\n\n                current_info->filter.flags = 0;\n                if (info->border_style == 3)\n                    current_info->filter.flags |= FILTER_BORDER_STYLE_3;\n                if (info->border_x || info->border_y)\n                    current_info->filter.flags |= FILTER_NONZERO_BORDER;\n                if (info->shadow_x || info->shadow_y)\n                    current_info->filter.flags |= FILTER_NONZERO_SHADOW;\n                // VSFilter compatibility: invisible fill and no border?\n                // In this case no shadow is supposed to be rendered.\n                if (info->border || (info->c[0] & 0xFF) != 0xFF)\n                    current_info->filter.flags |= FILTER_DRAW_SHADOW;\n\n                current_info->filter.be = info->be;\n                current_info->filter.blur = 2 * info->blur * render_priv->blur_scale;\n                current_info->filter.shadow.x = double_to_d6(info->shadow_x * render_priv->border_scale);\n                current_info->filter.shadow.y = double_to_d6(info->shadow_y * render_priv->border_scale);\n\n                current_info->x = current_info->y = INT_MAX;\n                rectangle_reset(&current_info->rect);\n                rectangle_reset(&current_info->rect_o);\n                current_info->n_bm = current_info->n_bm_o = 0;\n                current_info->bm = current_info->bm_o = current_info->bm_s = NULL;\n                current_info->image = NULL;\n\n                current_info->bitmap_count = current_info->max_bitmap_count = 0;\n                current_info->bitmaps = malloc(MAX_SUB_BITMAPS_INITIAL * sizeof(BitmapRef));\n                if (!current_info->bitmaps) {\n                    ass_cache_dec_ref(info->image);\n                    continue;\n                }\n                current_info->max_bitmap_count = MAX_SUB_BITMAPS_INITIAL;\n\n                nb_bitmaps++;\n            }\n            last_info = info;\n\n            if (!info->image || !current_info) {\n                ass_cache_dec_ref(info->image);\n                continue;\n            }\n\n            if (current_info->bitmap_count >= current_info->max_bitmap_count) {\n                size_t new_size = 2 * current_info->max_bitmap_count;\n                if (!ASS_REALLOC_ARRAY(current_info->bitmaps, new_size)) {\n                    ass_cache_dec_ref(info->image);\n                    continue;\n                }\n                current_info->max_bitmap_count = new_size;\n            }\n            current_info->bitmaps[current_info->bitmap_count].image = info->image;\n            current_info->bitmaps[current_info->bitmap_count].x = x;\n            current_info->bitmaps[current_info->bitmap_count].y = y;\n            current_info->bitmap_count++;\n\n            current_info->x = FFMIN(current_info->x, x);\n            current_info->y = FFMIN(current_info->y, y);\n            if (info->image->bm) {\n                rectangle_combine(&current_info->rect, info->image->bm, x, y);\n                current_info->n_bm++;\n            }\n            if (info->image->bm_o) {\n                rectangle_combine(&current_info->rect_o, info->image->bm_o, x, y);\n                current_info->n_bm_o++;\n            }\n        }\n    }\n\n    for (int i = 0; i < nb_bitmaps; i++) {\n        CombinedBitmapInfo *info = &combined_info[i];\n        for (int j = 0; j < info->bitmap_count; j++) {\n            info->bitmaps[j].x -= info->x;\n            info->bitmaps[j].y -= info->y;\n        }\n\n        CompositeHashKey hk;\n        CompositeHashValue *hv;\n        fill_composite_hash(&hk, info);\n        if (ass_cache_get(render_priv->cache.composite_cache, &hk, &hv)) {\n            info->bm = hv->bm;\n            info->bm_o = hv->bm_o;\n            info->bm_s = hv->bm_s;\n            info->image = hv;\n            continue;\n        }\n        if (!hv)\n            continue;\n\n        int bord = be_padding(info->filter.be);\n        if (!bord && info->n_bm == 1) {\n            for (int j = 0; j < info->bitmap_count; j++) {\n                if (!info->bitmaps[j].image->bm)\n                    continue;\n                info->bm = copy_bitmap(render_priv->engine, info->bitmaps[j].image->bm);\n                if (info->bm) {\n                    info->bm->left += info->bitmaps[j].x;\n                    info->bm->top  += info->bitmaps[j].y;\n                }\n                break;\n            }\n        } else if (info->n_bm) {\n            info->bm = alloc_bitmap(render_priv->engine,\n                                    info->rect.x_max - info->rect.x_min + 2 * bord,\n                                    info->rect.y_max - info->rect.y_min + 2 * bord, true);\n            Bitmap *dst = info->bm;\n            if (dst) {\n                dst->left = info->rect.x_min - info->x - bord;\n                dst->top  = info->rect.y_min - info->y - bord;\n                for (int j = 0; j < info->bitmap_count; j++) {\n                    Bitmap *src = info->bitmaps[j].image->bm;\n                    if (!src)\n                        continue;\n                    int x = info->bitmaps[j].x + src->left - dst->left;\n                    int y = info->bitmaps[j].y + src->top  - dst->top;\n                    assert(x >= 0 && x + src->w <= dst->w);\n                    assert(y >= 0 && y + src->h <= dst->h);\n                    unsigned char *buf = dst->buffer + y * dst->stride + x;\n                    render_priv->engine->add_bitmaps(buf, dst->stride,\n                                                     src->buffer, src->stride,\n                                                     src->h, src->w);\n                }\n            }\n        }\n        if (!bord && info->n_bm_o == 1) {\n            for (int j = 0; j < info->bitmap_count; j++) {\n                if (!info->bitmaps[j].image->bm_o)\n                    continue;\n                info->bm_o = copy_bitmap(render_priv->engine, info->bitmaps[j].image->bm_o);\n                if (info->bm_o) {\n                    info->bm_o->left += info->bitmaps[j].x;\n                    info->bm_o->top  += info->bitmaps[j].y;\n                }\n                break;\n            }\n        } else if (info->n_bm_o) {\n            info->bm_o = alloc_bitmap(render_priv->engine,\n                                      info->rect_o.x_max - info->rect_o.x_min + 2 * bord,\n                                      info->rect_o.y_max - info->rect_o.y_min + 2 * bord,\n                                      true);\n            Bitmap *dst = info->bm_o;\n            if (dst) {\n                dst->left = info->rect_o.x_min - info->x - bord;\n                dst->top  = info->rect_o.y_min - info->y - bord;\n                for (int j = 0; j < info->bitmap_count; j++) {\n                    Bitmap *src = info->bitmaps[j].image->bm_o;\n                    if (!src)\n                        continue;\n                    int x = info->bitmaps[j].x + src->left - dst->left;\n                    int y = info->bitmaps[j].y + src->top  - dst->top;\n                    assert(x >= 0 && x + src->w <= dst->w);\n                    assert(y >= 0 && y + src->h <= dst->h);\n                    unsigned char *buf = dst->buffer + y * dst->stride + x;\n                    render_priv->engine->add_bitmaps(buf, dst->stride,\n                                                     src->buffer, src->stride,\n                                                     src->h, src->w);\n                }\n            }\n        }\n\n        if (info->bm || info->bm_o) {\n            ass_synth_blur(render_priv->engine, info->filter.flags & FILTER_BORDER_STYLE_3,\n                           info->filter.be, info->filter.blur, info->bm, info->bm_o);\n            if (info->filter.flags & FILTER_DRAW_SHADOW)\n                make_shadow_bitmap(info, render_priv);\n        }\n\n        hv->bm = info->bm;\n        hv->bm_o = info->bm_o;\n        hv->bm_s = info->bm_s;\n        ass_cache_commit(hv, bitmap_size(hv->bm) +\n                         bitmap_size(hv->bm_o) + bitmap_size(hv->bm_s) +\n                         sizeof(CompositeHashKey) + sizeof(CompositeHashValue));\n        info->image = hv;\n    }\n\n    text_info->n_bitmaps = nb_bitmaps;\n}\n\nstatic void add_background(ASS_Renderer *render_priv, EventImages *event_images)\n{\n    void *nbuffer = ass_aligned_alloc(1, event_images->width * event_images->height, false);\n    if (!nbuffer)\n        return;\n    memset(nbuffer, 0xFF, event_images->width * event_images->height);\n    ASS_Image *img = my_draw_bitmap(nbuffer, event_images->width,\n                                    event_images->height,\n                                    event_images->width,\n                                    event_images->left,\n                                    event_images->top,\n                                    render_priv->state.c[3], NULL);\n    if (img) {\n        img->next = event_images->imgs;\n        event_images->imgs = img;\n    }\n}\n\n/**\n * \\brief Main ass rendering function, glues everything together\n * \\param event event to render\n * \\param event_images struct containing resulting images, will also be initialized\n * Process event, appending resulting ASS_Image's to images_root.\n */\nstatic int\nass_render_event(ASS_Renderer *render_priv, ASS_Event *event,\n                 EventImages *event_images)\n{\n    DBBox bbox;\n    int MarginL, MarginR, MarginV;\n    int valign;\n    double device_x = 0;\n    double device_y = 0;\n    TextInfo *text_info = &render_priv->text_info;\n\n    if (event->Style >= render_priv->track->n_styles) {\n        ass_msg(render_priv->library, MSGL_WARN, \"No style found\");\n        return 1;\n    }\n    if (!event->Text) {\n        ass_msg(render_priv->library, MSGL_WARN, \"Empty event\");\n        return 1;\n    }\n\n    free_render_context(render_priv);\n    init_render_context(render_priv, event);\n\n    if (parse_events(render_priv, event))\n        return 1;\n\n    if (text_info->length == 0) {\n        // no valid symbols in the event; this can be smth like {comment}\n        free_render_context(render_priv);\n        return 1;\n    }\n\n    // Find shape runs and shape text\n    ass_shaper_set_base_direction(render_priv->shaper,\n            resolve_base_direction(render_priv->state.font_encoding));\n    ass_shaper_find_runs(render_priv->shaper, render_priv, text_info->glyphs,\n            text_info->length);\n    if (ass_shaper_shape(render_priv->shaper, text_info) < 0) {\n        ass_msg(render_priv->library, MSGL_ERR, \"Failed to shape text\");\n        free_render_context(render_priv);\n        return 1;\n    }\n\n    retrieve_glyphs(render_priv);\n\n    preliminary_layout(render_priv);\n\n    // depends on glyph x coordinates being monotonous, so it should be done before line wrap\n    process_karaoke_effects(render_priv);\n\n    valign = render_priv->state.alignment & 12;\n\n    MarginL =\n        (event->MarginL) ? event->MarginL : render_priv->state.style->MarginL;\n    MarginR =\n        (event->MarginR) ? event->MarginR : render_priv->state.style->MarginR;\n    MarginV =\n        (event->MarginV) ? event->MarginV : render_priv->state.style->MarginV;\n\n    // calculate max length of a line\n    double max_text_width =\n        x2scr(render_priv, render_priv->track->PlayResX - MarginR) -\n        x2scr(render_priv, MarginL);\n\n    // wrap lines\n    if (render_priv->state.evt_type != EVENT_HSCROLL) {\n        // rearrange text in several lines\n        wrap_lines_smart(render_priv, max_text_width);\n    } else {\n        // no breaking or wrapping, everything in a single line\n        text_info->lines[0].offset = 0;\n        text_info->lines[0].len = text_info->length;\n        text_info->n_lines = 1;\n        measure_text(render_priv);\n    }\n\n    reorder_text(render_priv);\n\n    align_lines(render_priv, max_text_width);\n\n    // determing text bounding box\n    compute_string_bbox(text_info, &bbox);\n\n    // determine device coordinates for text\n\n    // x coordinate for everything except positioned events\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_VSCROLL) {\n        device_x = x2scr(render_priv, MarginL);\n    } else if (render_priv->state.evt_type == EVENT_HSCROLL) {\n        if (render_priv->state.scroll_direction == SCROLL_RL)\n            device_x =\n                x2scr(render_priv,\n                      render_priv->track->PlayResX -\n                      render_priv->state.scroll_shift);\n        else if (render_priv->state.scroll_direction == SCROLL_LR)\n            device_x =\n                x2scr(render_priv,\n                      render_priv->state.scroll_shift) - (bbox.xMax -\n                                                          bbox.xMin);\n    }\n\n    // y coordinate for everything except positioned events\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_HSCROLL) {\n        if (valign == VALIGN_TOP) {     // toptitle\n            device_y =\n                y2scr_top(render_priv,\n                          MarginV) + text_info->lines[0].asc;\n        } else if (valign == VALIGN_CENTER) {   // midtitle\n            double scr_y =\n                y2scr(render_priv, render_priv->track->PlayResY / 2.0);\n            device_y = scr_y - (bbox.yMax + bbox.yMin) / 2.0;\n        } else {                // subtitle\n            double line_pos = render_priv->state.explicit ?\n                0 : render_priv->settings.line_position;\n            double scr_top, scr_bottom, scr_y0;\n            if (valign != VALIGN_SUB)\n                ass_msg(render_priv->library, MSGL_V,\n                       \"Invalid valign, assuming 0 (subtitle)\");\n            scr_bottom =\n                y2scr_sub(render_priv,\n                          render_priv->track->PlayResY - MarginV);\n            scr_top = y2scr_top(render_priv, 0); //xxx not always 0?\n            device_y = scr_bottom + (scr_top - scr_bottom) * line_pos / 100.0;\n            device_y -= text_info->height;\n            device_y += text_info->lines[0].asc;\n            // clip to top to avoid confusion if line_position is very high,\n            // turning the subtitle into a toptitle\n            // also, don't change behavior if line_position is not used\n            scr_y0 = scr_top + text_info->lines[0].asc;\n            if (device_y < scr_y0 && line_pos > 0) {\n                device_y = scr_y0;\n            }\n        }\n    } else if (render_priv->state.evt_type == EVENT_VSCROLL) {\n        if (render_priv->state.scroll_direction == SCROLL_TB)\n            device_y =\n                y2scr(render_priv,\n                      render_priv->state.clip_y0 +\n                      render_priv->state.scroll_shift) - (bbox.yMax -\n                                                          bbox.yMin);\n        else if (render_priv->state.scroll_direction == SCROLL_BT)\n            device_y =\n                y2scr(render_priv,\n                      render_priv->state.clip_y1 -\n                      render_priv->state.scroll_shift);\n    }\n\n    // positioned events are totally different\n    if (render_priv->state.evt_type == EVENT_POSITIONED) {\n        double base_x = 0;\n        double base_y = 0;\n        get_base_point(&bbox, render_priv->state.alignment, &base_x, &base_y);\n        device_x =\n            x2scr_pos(render_priv, render_priv->state.pos_x) - base_x;\n        device_y =\n            y2scr_pos(render_priv, render_priv->state.pos_y) - base_y;\n    }\n\n    // fix clip coordinates (they depend on alignment)\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_HSCROLL ||\n        render_priv->state.evt_type == EVENT_VSCROLL) {\n        render_priv->state.clip_x0 =\n            x2scr_scaled(render_priv, render_priv->state.clip_x0);\n        render_priv->state.clip_x1 =\n            x2scr_scaled(render_priv, render_priv->state.clip_x1);\n        if (valign == VALIGN_TOP) {\n            render_priv->state.clip_y0 =\n                y2scr_top(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr_top(render_priv, render_priv->state.clip_y1);\n        } else if (valign == VALIGN_CENTER) {\n            render_priv->state.clip_y0 =\n                y2scr(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr(render_priv, render_priv->state.clip_y1);\n        } else if (valign == VALIGN_SUB) {\n            render_priv->state.clip_y0 =\n                y2scr_sub(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr_sub(render_priv, render_priv->state.clip_y1);\n        }\n    } else if (render_priv->state.evt_type == EVENT_POSITIONED) {\n        render_priv->state.clip_x0 =\n            x2scr_pos_scaled(render_priv, render_priv->state.clip_x0);\n        render_priv->state.clip_x1 =\n            x2scr_pos_scaled(render_priv, render_priv->state.clip_x1);\n        render_priv->state.clip_y0 =\n            y2scr_pos(render_priv, render_priv->state.clip_y0);\n        render_priv->state.clip_y1 =\n            y2scr_pos(render_priv, render_priv->state.clip_y1);\n    }\n\n    if (render_priv->state.explicit) {\n        // we still need to clip against screen boundaries\n        double zx = x2scr_pos_scaled(render_priv, 0);\n        double zy = y2scr_pos(render_priv, 0);\n        double sx = x2scr_pos_scaled(render_priv, render_priv->track->PlayResX);\n        double sy = y2scr_pos(render_priv, render_priv->track->PlayResY);\n\n        render_priv->state.clip_x0 = render_priv->state.clip_x0 < zx ? zx : render_priv->state.clip_x0;\n        render_priv->state.clip_y0 = render_priv->state.clip_y0 < zy ? zy : render_priv->state.clip_y0;\n        render_priv->state.clip_x1 = render_priv->state.clip_x1 > sx ? sx : render_priv->state.clip_x1;\n        render_priv->state.clip_y1 = render_priv->state.clip_y1 > sy ? sy : render_priv->state.clip_y1;\n    }\n\n    calculate_rotation_params(render_priv, &bbox, device_x, device_y);\n\n    render_and_combine_glyphs(render_priv, device_x, device_y);\n\n    memset(event_images, 0, sizeof(*event_images));\n    event_images->top = device_y - text_info->lines[0].asc;\n    event_images->height = text_info->height;\n    event_images->left =\n        (device_x + bbox.xMin * render_priv->font_scale_x) + 0.5;\n    event_images->width =\n        (bbox.xMax - bbox.xMin) * render_priv->font_scale_x + 0.5;\n    event_images->detect_collisions = render_priv->state.detect_collisions;\n    event_images->shift_direction = (valign == VALIGN_TOP) ? 1 : -1;\n    event_images->event = event;\n    event_images->imgs = render_text(render_priv);\n\n    if (render_priv->state.border_style == 4)\n        add_background(render_priv, event_images);\n\n    ass_shaper_cleanup(render_priv->shaper, text_info);\n    free_render_context(render_priv);\n\n    return 0;\n}\n\n/**\n * \\brief Check cache limits and reset cache if they are exceeded\n */\nstatic void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)\n{\n    ass_cache_cut(cache->composite_cache, cache->composite_max_size);\n    ass_cache_cut(cache->bitmap_cache, cache->bitmap_max_size);\n    ass_cache_cut(cache->outline_cache, cache->glyph_max);\n}\n\n/**\n * \\brief Start a new frame\n */\nstatic int\nass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,\n                long long now)\n{\n    ASS_Settings *settings_priv = &render_priv->settings;\n\n    if (!render_priv->settings.frame_width\n        && !render_priv->settings.frame_height)\n        return 1;               // library not initialized\n\n    if (!render_priv->fontselect)\n        return 1;\n\n    if (render_priv->library != track->library)\n        return 1;\n\n    if (track->n_events == 0)\n        return 1;               // nothing to do\n\n    render_priv->track = track;\n    render_priv->time = now;\n\n    ass_lazy_track_init(render_priv->library, render_priv->track);\n\n    ass_shaper_set_kerning(render_priv->shaper, track->Kerning);\n    ass_shaper_set_language(render_priv->shaper, track->Language);\n    ass_shaper_set_level(render_priv->shaper, render_priv->settings.shaper);\n\n    // PAR correction\n    double par = render_priv->settings.par;\n    if (par == 0.) {\n        if (settings_priv->frame_width && settings_priv->frame_height &&\n            settings_priv->storage_width && settings_priv->storage_height) {\n            double dar = ((double) settings_priv->frame_width) /\n                         settings_priv->frame_height;\n            double sar = ((double) settings_priv->storage_width) /\n                         settings_priv->storage_height;\n            par = sar / dar;\n        } else\n            par = 1.0;\n    }\n    render_priv->font_scale_x = par;\n\n    render_priv->prev_images_root = render_priv->images_root;\n    render_priv->images_root = NULL;\n\n    check_cache_limits(render_priv, &render_priv->cache);\n\n    return 0;\n}\n\nstatic int cmp_event_layer(const void *p1, const void *p2)\n{\n    ASS_Event *e1 = ((EventImages *) p1)->event;\n    ASS_Event *e2 = ((EventImages *) p2)->event;\n    if (e1->Layer < e2->Layer)\n        return -1;\n    if (e1->Layer > e2->Layer)\n        return 1;\n    if (e1->ReadOrder < e2->ReadOrder)\n        return -1;\n    if (e1->ReadOrder > e2->ReadOrder)\n        return 1;\n    return 0;\n}\n\nstatic ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,\n                                       ASS_Event *event)\n{\n    if (!event->render_priv) {\n        event->render_priv = calloc(1, sizeof(ASS_RenderPriv));\n        if (!event->render_priv)\n            return NULL;\n    }\n    if (render_priv->render_id != event->render_priv->render_id) {\n        memset(event->render_priv, 0, sizeof(ASS_RenderPriv));\n        event->render_priv->render_id = render_priv->render_id;\n    }\n\n    return event->render_priv;\n}\n\nstatic int overlap(Segment *s1, Segment *s2)\n{\n    if (s1->a >= s2->b || s2->a >= s1->b ||\n        s1->ha >= s2->hb || s2->ha >= s1->hb)\n        return 0;\n    return 1;\n}\n\nstatic int cmp_segment(const void *p1, const void *p2)\n{\n    return ((Segment *) p1)->a - ((Segment *) p2)->a;\n}\n\nstatic void\nshift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)\n{\n    ASS_Image *cur = ei->imgs;\n    while (cur) {\n        cur->dst_y += shift;\n        // clip top and bottom\n        if (cur->dst_y < 0) {\n            int clip = -cur->dst_y;\n            cur->h -= clip;\n            cur->bitmap += clip * cur->stride;\n            cur->dst_y = 0;\n        }\n        if (cur->dst_y + cur->h >= render_priv->height) {\n            int clip = cur->dst_y + cur->h - render_priv->height;\n            cur->h -= clip;\n        }\n        if (cur->h <= 0) {\n            cur->h = 0;\n            cur->dst_y = 0;\n        }\n        cur = cur->next;\n    }\n    ei->top += shift;\n}\n\n// dir: 1 - move down\n//      -1 - move up\nstatic int fit_segment(Segment *s, Segment *fixed, int *cnt, int dir)\n{\n    int i;\n    int shift = 0;\n\n    if (dir == 1)               // move down\n        for (i = 0; i < *cnt; ++i) {\n            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||\n                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)\n                continue;\n            shift = fixed[i].b - s->a;\n    } else                      // dir == -1, move up\n        for (i = *cnt - 1; i >= 0; --i) {\n            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||\n                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)\n                continue;\n            shift = fixed[i].a - s->b;\n        }\n\n    fixed[*cnt].a = s->a + shift;\n    fixed[*cnt].b = s->b + shift;\n    fixed[*cnt].ha = s->ha;\n    fixed[*cnt].hb = s->hb;\n    (*cnt)++;\n    qsort(fixed, *cnt, sizeof(Segment), cmp_segment);\n\n    return shift;\n}\n\nstatic void\nfix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)\n{\n    Segment *used = ass_realloc_array(NULL, cnt, sizeof(*used));\n    int cnt_used = 0;\n    int i, j;\n\n    if (!used)\n        return;\n\n    // fill used[] with fixed events\n    for (i = 0; i < cnt; ++i) {\n        ASS_RenderPriv *priv;\n        if (!imgs[i].detect_collisions)\n            continue;\n        priv = get_render_priv(render_priv, imgs[i].event);\n        if (priv && priv->height > 0) { // it's a fixed event\n            Segment s;\n            s.a = priv->top;\n            s.b = priv->top + priv->height;\n            s.ha = priv->left;\n            s.hb = priv->left + priv->width;\n            if (priv->height != imgs[i].height) {       // no, it's not\n                ass_msg(render_priv->library, MSGL_WARN,\n                        \"Event height has changed\");\n                priv->top = 0;\n                priv->height = 0;\n                priv->left = 0;\n                priv->width = 0;\n            }\n            for (j = 0; j < cnt_used; ++j)\n                if (overlap(&s, used + j)) {    // no, it's not\n                    priv->top = 0;\n                    priv->height = 0;\n                    priv->left = 0;\n                    priv->width = 0;\n                }\n            if (priv->height > 0) {     // still a fixed event\n                used[cnt_used].a = priv->top;\n                used[cnt_used].b = priv->top + priv->height;\n                used[cnt_used].ha = priv->left;\n                used[cnt_used].hb = priv->left + priv->width;\n                cnt_used++;\n                shift_event(render_priv, imgs + i, priv->top - imgs[i].top);\n            }\n        }\n    }\n    qsort(used, cnt_used, sizeof(Segment), cmp_segment);\n\n    // try to fit other events in free spaces\n    for (i = 0; i < cnt; ++i) {\n        ASS_RenderPriv *priv;\n        if (!imgs[i].detect_collisions)\n            continue;\n        priv = get_render_priv(render_priv, imgs[i].event);\n        if (priv && priv->height == 0) {        // not a fixed event\n            int shift;\n            Segment s;\n            s.a = imgs[i].top;\n            s.b = imgs[i].top + imgs[i].height;\n            s.ha = imgs[i].left;\n            s.hb = imgs[i].left + imgs[i].width;\n            shift = fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);\n            if (shift)\n                shift_event(render_priv, imgs + i, shift);\n            // make it fixed\n            priv->top = imgs[i].top;\n            priv->height = imgs[i].height;\n            priv->left = imgs[i].left;\n            priv->width = imgs[i].width;\n        }\n\n    }\n\n    free(used);\n}\n\n/**\n * \\brief compare two images\n * \\param i1 first image\n * \\param i2 second image\n * \\return 0 if identical, 1 if different positions, 2 if different content\n */\nstatic int ass_image_compare(ASS_Image *i1, ASS_Image *i2)\n{\n    if (i1->w != i2->w)\n        return 2;\n    if (i1->h != i2->h)\n        return 2;\n    if (i1->stride != i2->stride)\n        return 2;\n    if (i1->color != i2->color)\n        return 2;\n    if (i1->bitmap != i2->bitmap)\n        return 2;\n    if (i1->dst_x != i2->dst_x)\n        return 1;\n    if (i1->dst_y != i2->dst_y)\n        return 1;\n    return 0;\n}\n\n/**\n * \\brief compare current and previous image list\n * \\param priv library handle\n * \\return 0 if identical, 1 if different positions, 2 if different content\n */\nstatic int ass_detect_change(ASS_Renderer *priv)\n{\n    ASS_Image *img, *img2;\n    int diff;\n\n    if (priv->state.has_clips)\n        return 2;\n\n    img = priv->prev_images_root;\n    img2 = priv->images_root;\n    diff = 0;\n    while (img && diff < 2) {\n        ASS_Image *next, *next2;\n        next = img->next;\n        if (img2) {\n            int d = ass_image_compare(img, img2);\n            if (d > diff)\n                diff = d;\n            next2 = img2->next;\n        } else {\n            // previous list is shorter\n            diff = 2;\n            break;\n        }\n        img = next;\n        img2 = next2;\n    }\n\n    // is the previous list longer?\n    if (img2)\n        diff = 2;\n\n    return diff;\n}\n\n/**\n * \\brief render a frame\n * \\param priv library handle\n * \\param track track\n * \\param now current video timestamp (ms)\n * \\param detect_change a value describing how the new images differ from the previous ones will be written here:\n *        0 if identical, 1 if different positions, 2 if different content.\n *        Can be NULL, in that case no detection is performed.\n */\nASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,\n                            long long now, int *detect_change)\n{\n    int i, cnt, rc;\n    EventImages *last;\n    ASS_Image **tail;\n\n    // init frame\n    rc = ass_start_frame(priv, track, now);\n    if (rc != 0) {\n        if (detect_change) {\n            *detect_change = 2;\n        }\n        return NULL;\n    }\n\n    // render events separately\n    cnt = 0;\n    for (i = 0; i < track->n_events; ++i) {\n        ASS_Event *event = track->events + i;\n        if ((event->Start <= now)\n            && (now < (event->Start + event->Duration))) {\n            if (cnt >= priv->eimg_size) {\n                priv->eimg_size += 100;\n                priv->eimg =\n                    realloc(priv->eimg,\n                            priv->eimg_size * sizeof(EventImages));\n            }\n            rc = ass_render_event(priv, event, priv->eimg + cnt);\n            if (!rc)\n                ++cnt;\n        }\n    }\n\n    // sort by layer\n    qsort(priv->eimg, cnt, sizeof(EventImages), cmp_event_layer);\n\n    // call fix_collisions for each group of events with the same layer\n    last = priv->eimg;\n    for (i = 1; i < cnt; ++i)\n        if (last->event->Layer != priv->eimg[i].event->Layer) {\n            fix_collisions(priv, last, priv->eimg + i - last);\n            last = priv->eimg + i;\n        }\n    if (cnt > 0)\n        fix_collisions(priv, last, priv->eimg + cnt - last);\n\n    // concat lists\n    tail = &priv->images_root;\n    for (i = 0; i < cnt; ++i) {\n        ASS_Image *cur = priv->eimg[i].imgs;\n        while (cur) {\n            *tail = cur;\n            tail = &cur->next;\n            cur = cur->next;\n        }\n    }\n    ass_frame_ref(priv->images_root);\n\n    if (detect_change)\n        *detect_change = ass_detect_change(priv);\n\n    // free the previous image list\n    ass_frame_unref(priv->prev_images_root);\n    priv->prev_images_root = NULL;\n\n    return priv->images_root;\n}\n\n/**\n * \\brief Add reference to a frame image list.\n * \\param image_list image list returned by ass_render_frame()\n */\nvoid ass_frame_ref(ASS_Image *img)\n{\n    if (!img)\n        return;\n    ((ASS_ImagePriv *) img)->ref_count++;\n}\n\n/**\n * \\brief Release reference to a frame image list.\n * \\param image_list image list returned by ass_render_frame()\n */\nvoid ass_frame_unref(ASS_Image *img)\n{\n    if (!img || --((ASS_ImagePriv *) img)->ref_count)\n        return;\n    do {\n        ASS_ImagePriv *priv = (ASS_ImagePriv *) img;\n        img = img->next;\n        if (priv->source)\n            ass_cache_dec_ref(priv->source);\n        else\n            ass_aligned_free(priv->result.bitmap);\n        free(priv);\n    } while (img);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>\n *\n * This file is part of libass.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"config.h\"\n#include \"ass_compat.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"ass_render.h\"\n#include \"ass_parse.h\"\n#include \"ass_shaper.h\"\n\n#define MAX_GLYPHS_INITIAL 1024\n#define MAX_LINES_INITIAL 64\n#define MAX_BITMAPS_INITIAL 16\n#define MAX_SUB_BITMAPS_INITIAL 64\n#define SUBPIXEL_MASK 63\n#define SUBPIXEL_ACCURACY 7\n\n\nASS_Renderer *ass_renderer_init(ASS_Library *library)\n{\n    int error;\n    FT_Library ft;\n    ASS_Renderer *priv = 0;\n    int vmajor, vminor, vpatch;\n\n    error = FT_Init_FreeType(&ft);\n    if (error) {\n        ass_msg(library, MSGL_FATAL, \"%s failed\", \"FT_Init_FreeType\");\n        goto ass_init_exit;\n    }\n\n    FT_Library_Version(ft, &vmajor, &vminor, &vpatch);\n    ass_msg(library, MSGL_V, \"Raster: FreeType %d.%d.%d\",\n           vmajor, vminor, vpatch);\n\n    priv = calloc(1, sizeof(ASS_Renderer));\n    if (!priv) {\n        FT_Done_FreeType(ft);\n        goto ass_init_exit;\n    }\n\n    priv->library = library;\n    priv->ftlibrary = ft;\n    // images_root and related stuff is zero-filled in calloc\n\n#if (defined(__i386__) || defined(__x86_64__)) && CONFIG_ASM\n    if (has_avx2())\n        priv->engine = &ass_bitmap_engine_avx2;\n    else if (has_sse2())\n        priv->engine = &ass_bitmap_engine_sse2;\n    else\n        priv->engine = &ass_bitmap_engine_c;\n#else\n    priv->engine = &ass_bitmap_engine_c;\n#endif\n\n#if CONFIG_RASTERIZER\n    rasterizer_init(&priv->rasterizer, 16);\n#endif\n\n    priv->cache.font_cache = ass_font_cache_create();\n    priv->cache.bitmap_cache = ass_bitmap_cache_create();\n    priv->cache.composite_cache = ass_composite_cache_create();\n    priv->cache.outline_cache = ass_outline_cache_create();\n    priv->cache.glyph_max = GLYPH_CACHE_MAX;\n    priv->cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;\n    priv->cache.composite_max_size = COMPOSITE_CACHE_MAX_SIZE;\n\n    priv->text_info.max_bitmaps = MAX_BITMAPS_INITIAL;\n    priv->text_info.max_glyphs = MAX_GLYPHS_INITIAL;\n    priv->text_info.max_lines = MAX_LINES_INITIAL;\n    priv->text_info.n_bitmaps = 0;\n    priv->text_info.combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));\n    priv->text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));\n    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));\n\n    priv->settings.font_size_coeff = 1.;\n    priv->settings.selective_style_overrides = ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;\n\n    priv->shaper = ass_shaper_new(0);\n    ass_shaper_info(library);\n#ifdef CONFIG_HARFBUZZ\n    priv->settings.shaper = ASS_SHAPING_COMPLEX;\n#else\n    priv->settings.shaper = ASS_SHAPING_SIMPLE;\n#endif\n\n  ass_init_exit:\n    if (priv)\n        ass_msg(library, MSGL_V, \"Initialized\");\n    else\n        ass_msg(library, MSGL_ERR, \"Initialization failed\");\n\n    return priv;\n}\n\nvoid ass_renderer_done(ASS_Renderer *render_priv)\n{\n    ass_frame_unref(render_priv->images_root);\n    ass_frame_unref(render_priv->prev_images_root);\n\n    ass_cache_done(render_priv->cache.composite_cache);\n    ass_cache_done(render_priv->cache.bitmap_cache);\n    ass_cache_done(render_priv->cache.outline_cache);\n    ass_shaper_free(render_priv->shaper);\n    ass_cache_done(render_priv->cache.font_cache);\n\n#if CONFIG_RASTERIZER\n    rasterizer_done(&render_priv->rasterizer);\n#endif\n\n    if (render_priv->state.stroker) {\n        FT_Stroker_Done(render_priv->state.stroker);\n        render_priv->state.stroker = 0;\n    }\n    if (render_priv->fontselect)\n        ass_fontselect_free(render_priv->fontselect);\n    if (render_priv->ftlibrary)\n        FT_Done_FreeType(render_priv->ftlibrary);\n    free(render_priv->eimg);\n    free(render_priv->text_info.glyphs);\n    free(render_priv->text_info.lines);\n\n    free(render_priv->text_info.combined_bitmaps);\n\n    free(render_priv->settings.default_font);\n    free(render_priv->settings.default_family);\n\n    free(render_priv->user_override_style.FontName);\n\n    free(render_priv);\n}\n\n/**\n * \\brief Create a new ASS_Image\n * Parameters are the same as ASS_Image fields.\n */\nstatic ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,\n                                 int bitmap_h, int stride, int dst_x,\n                                 int dst_y, uint32_t color,\n                                 CompositeHashValue *source)\n{\n    ASS_ImagePriv *img = malloc(sizeof(ASS_ImagePriv));\n    if (!img) {\n        if (!source)\n            ass_aligned_free(bitmap);\n        return NULL;\n    }\n\n    img->result.w = bitmap_w;\n    img->result.h = bitmap_h;\n    img->result.stride = stride;\n    img->result.bitmap = bitmap;\n    img->result.color = color;\n    img->result.dst_x = dst_x;\n    img->result.dst_y = dst_y;\n\n    img->source = source;\n    ass_cache_inc_ref(source);\n    img->ref_count = 0;\n\n    return &img->result;\n}\n\n/**\n * \\brief Mapping between script and screen coordinates\n */\nstatic double x2scr_pos(ASS_Renderer *render_priv, double x)\n{\n    return x * render_priv->orig_width / render_priv->font_scale_x / render_priv->track->PlayResX +\n        render_priv->settings.left_margin;\n}\nstatic double x2scr(ASS_Renderer *render_priv, double x)\n{\n    if (render_priv->state.explicit)\n        return x2scr_pos(render_priv, x);\n    return x * render_priv->orig_width_nocrop / render_priv->font_scale_x /\n        render_priv->track->PlayResX +\n        FFMAX(render_priv->settings.left_margin, 0);\n}\nstatic double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)\n{\n    return x * render_priv->orig_width / render_priv->track->PlayResX +\n        render_priv->settings.left_margin;\n}\nstatic double x2scr_scaled(ASS_Renderer *render_priv, double x)\n{\n    if (render_priv->state.explicit)\n        return x2scr_pos_scaled(render_priv, x);\n    return x * render_priv->orig_width_nocrop /\n        render_priv->track->PlayResX +\n        FFMAX(render_priv->settings.left_margin, 0);\n}\n/**\n * \\brief Mapping between script and screen coordinates\n */\nstatic double y2scr_pos(ASS_Renderer *render_priv, double y)\n{\n    return y * render_priv->orig_height / render_priv->track->PlayResY +\n        render_priv->settings.top_margin;\n}\nstatic double y2scr(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    return y * render_priv->orig_height_nocrop /\n        render_priv->track->PlayResY +\n        FFMAX(render_priv->settings.top_margin, 0);\n}\n\n// the same for toptitles\nstatic double y2scr_top(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    if (render_priv->settings.use_margins)\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY;\n    else\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0);\n}\n// the same for subtitles\nstatic double y2scr_sub(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    if (render_priv->settings.use_margins)\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0)\n            + FFMAX(render_priv->settings.bottom_margin, 0);\n    else\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0);\n}\n\n/*\n * \\brief Convert bitmap glyphs into ASS_Image list with inverse clipping\n *\n * Inverse clipping with the following strategy:\n * - find rectangle from (x0, y0) to (cx0, y1)\n * - find rectangle from (cx0, y0) to (cx1, cy0)\n * - find rectangle from (cx0, cy1) to (cx1, y1)\n * - find rectangle from (cx1, y0) to (x1, y1)\n * These rectangles can be invalid and in this case are discarded.\n * Afterwards, they are clipped against the screen coordinates.\n * In an additional pass, the rectangles need to be split up left/right for\n * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).\n */\nstatic ASS_Image **render_glyph_i(ASS_Renderer *render_priv,\n                                  Bitmap *bm, int dst_x, int dst_y,\n                                  uint32_t color, uint32_t color2, int brk,\n                                  ASS_Image **tail, unsigned type,\n                                  CompositeHashValue *source)\n{\n    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;\n    Rect r[4];\n    ASS_Image *img;\n\n    dst_x += bm->left;\n    dst_y += bm->top;\n\n    // we still need to clip against screen boundaries\n    zx = x2scr_pos_scaled(render_priv, 0);\n    zy = y2scr_pos(render_priv, 0);\n    sx = x2scr_pos_scaled(render_priv, render_priv->track->PlayResX);\n    sy = y2scr_pos(render_priv, render_priv->track->PlayResY);\n\n    x0 = 0;\n    y0 = 0;\n    x1 = bm->w;\n    y1 = bm->h;\n    cx0 = render_priv->state.clip_x0 - dst_x;\n    cy0 = render_priv->state.clip_y0 - dst_y;\n    cx1 = render_priv->state.clip_x1 - dst_x;\n    cy1 = render_priv->state.clip_y1 - dst_y;\n\n    // calculate rectangles and discard invalid ones while we're at it.\n    i = 0;\n    r[i].x0 = x0;\n    r[i].y0 = y0;\n    r[i].x1 = (cx0 > x1) ? x1 : cx0;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx0 < 0) ? x0 : cx0;\n    r[i].y0 = y0;\n    r[i].x1 = (cx1 > x1) ? x1 : cx1;\n    r[i].y1 = (cy0 > y1) ? y1 : cy0;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx0 < 0) ? x0 : cx0;\n    r[i].y0 = (cy1 < 0) ? y0 : cy1;\n    r[i].x1 = (cx1 > x1) ? x1 : cx1;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n    r[i].x0 = (cx1 < 0) ? x0 : cx1;\n    r[i].y0 = y0;\n    r[i].x1 = x1;\n    r[i].y1 = y1;\n    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;\n\n    // clip each rectangle to screen coordinates\n    for (j = 0; j < i; j++) {\n        r[j].x0 = (r[j].x0 + dst_x < zx) ? zx - dst_x : r[j].x0;\n        r[j].y0 = (r[j].y0 + dst_y < zy) ? zy - dst_y : r[j].y0;\n        r[j].x1 = (r[j].x1 + dst_x > sx) ? sx - dst_x : r[j].x1;\n        r[j].y1 = (r[j].y1 + dst_y > sy) ? sy - dst_y : r[j].y1;\n    }\n\n    // draw the rectangles\n    for (j = 0; j < i; j++) {\n        int lbrk = brk;\n        // kick out rectangles that are invalid now\n        if (r[j].x1 <= r[j].x0 || r[j].y1 <= r[j].y0)\n            continue;\n        // split up into left and right for karaoke, if needed\n        if (lbrk > r[j].x0) {\n            if (lbrk > r[j].x1) lbrk = r[j].x1;\n            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + r[j].x0,\n                                 lbrk - r[j].x0, r[j].y1 - r[j].y0, bm->stride,\n                                 dst_x + r[j].x0, dst_y + r[j].y0, color, source);\n            if (!img) break;\n            img->type = type;\n            *tail = img;\n            tail = &img->next;\n        }\n        if (lbrk < r[j].x1) {\n            if (lbrk < r[j].x0) lbrk = r[j].x0;\n            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + lbrk,\n                                 r[j].x1 - lbrk, r[j].y1 - r[j].y0, bm->stride,\n                                 dst_x + lbrk, dst_y + r[j].y0, color2, source);\n            if (!img) break;\n            img->type = type;\n            *tail = img;\n            tail = &img->next;\n        }\n    }\n\n    return tail;\n}\n\n/**\n * \\brief convert bitmap glyph into ASS_Image struct(s)\n * \\param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY\n * \\param dst_x bitmap x coordinate in video frame\n * \\param dst_y bitmap y coordinate in video frame\n * \\param color first color, RGBA\n * \\param color2 second color, RGBA\n * \\param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right\n * \\param tail pointer to the last image's next field, head of the generated list should be stored here\n * \\return pointer to the new list tail\n * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.\n */\nstatic ASS_Image **\nrender_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,\n             uint32_t color, uint32_t color2, int brk, ASS_Image **tail,\n             unsigned type, CompositeHashValue *source)\n{\n    // Inverse clipping in use?\n    if (render_priv->state.clip_mode)\n        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,\n                              brk, tail, type, source);\n\n    // brk is relative to dst_x\n    // color = color left of brk\n    // color2 = color right of brk\n    int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap\n    int clip_x0, clip_y0, clip_x1, clip_y1;\n    int tmp;\n    ASS_Image *img;\n\n    dst_x += bm->left;\n    dst_y += bm->top;\n    brk -= bm->left;\n\n    // clipping\n    clip_x0 = FFMINMAX(render_priv->state.clip_x0, 0, render_priv->width);\n    clip_y0 = FFMINMAX(render_priv->state.clip_y0, 0, render_priv->height);\n    clip_x1 = FFMINMAX(render_priv->state.clip_x1, 0, render_priv->width);\n    clip_y1 = FFMINMAX(render_priv->state.clip_y1, 0, render_priv->height);\n    b_x0 = 0;\n    b_y0 = 0;\n    b_x1 = bm->w;\n    b_y1 = bm->h;\n\n    tmp = dst_x - clip_x0;\n    if (tmp < 0) {\n        b_x0 = -tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = dst_y - clip_y0;\n    if (tmp < 0) {\n        b_y0 = -tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = clip_x1 - dst_x - bm->w;\n    if (tmp < 0) {\n        b_x1 = bm->w + tmp;\n        render_priv->state.has_clips = 1;\n    }\n    tmp = clip_y1 - dst_y - bm->h;\n    if (tmp < 0) {\n        b_y1 = bm->h + tmp;\n        render_priv->state.has_clips = 1;\n    }\n\n    if ((b_y0 >= b_y1) || (b_x0 >= b_x1))\n        return tail;\n\n    if (brk > b_x0) {           // draw left part\n        if (brk > b_x1)\n            brk = b_x1;\n        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + b_x0,\n                             brk - b_x0, b_y1 - b_y0, bm->stride,\n                             dst_x + b_x0, dst_y + b_y0, color, source);\n        if (!img) return tail;\n        img->type = type;\n        *tail = img;\n        tail = &img->next;\n    }\n    if (brk < b_x1) {           // draw right part\n        if (brk < b_x0)\n            brk = b_x0;\n        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + brk,\n                             b_x1 - brk, b_y1 - b_y0, bm->stride,\n                             dst_x + brk, dst_y + b_y0, color2, source);\n        if (!img) return tail;\n        img->type = type;\n        *tail = img;\n        tail = &img->next;\n    }\n    return tail;\n}\n\n// Calculate bitmap memory footprint\nstatic inline size_t bitmap_size(Bitmap *bm)\n{\n    return bm ? sizeof(Bitmap) + bm->stride * bm->h : 0;\n}\n\n/**\n * Iterate through a list of bitmaps and blend with clip vector, if\n * applicable. The blended bitmaps are added to a free list which is freed\n * at the start of a new frame.\n */\nstatic void blend_vector_clip(ASS_Renderer *render_priv,\n                              ASS_Image *head)\n{\n    ASS_Drawing *drawing = render_priv->state.clip_drawing;\n    if (!drawing)\n        return;\n\n    // Try to get mask from cache\n    BitmapHashKey key;\n    memset(&key, 0, sizeof(key));\n    key.type = BITMAP_CLIP;\n    key.u.clip.text = drawing->text;\n\n    BitmapHashValue *val;\n    if (!ass_cache_get(render_priv->cache.bitmap_cache, &key, &val)) {\n        if (!val)\n            return;\n        val->bm = val->bm_o = NULL;\n\n        // Not found in cache, parse and rasterize it\n        ASS_Outline *outline = ass_drawing_parse(drawing, 1);\n        if (!outline) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"Clip vector parsing failed. Skipping.\");\n            ass_cache_commit(val, sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n            ass_cache_dec_ref(val);\n            return;\n        }\n\n        // We need to translate the clip according to screen borders\n        if (render_priv->settings.left_margin != 0 ||\n            render_priv->settings.top_margin != 0) {\n            FT_Vector trans = {\n                .x = int_to_d6(render_priv->settings.left_margin),\n                .y = -int_to_d6(render_priv->settings.top_margin),\n            };\n            outline_translate(outline, trans.x, trans.y);\n        }\n\n        val->bm = outline_to_bitmap(render_priv, outline, 0);\n        ass_cache_commit(val, bitmap_size(val->bm) +\n                         sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n    }\n\n    Bitmap *clip_bm = val->bm;\n    if (!clip_bm) {\n        ass_cache_dec_ref(val);\n        return;\n    }\n\n    // Iterate through bitmaps and blend/clip them\n    for (ASS_Image *cur = head; cur; cur = cur->next) {\n        int left, top, right, bottom, w, h;\n        int ax, ay, aw, ah, as;\n        int bx, by, bw, bh, bs;\n        int aleft, atop, bleft, btop;\n        unsigned char *abuffer, *bbuffer, *nbuffer;\n\n        render_priv->state.has_clips = 1;\n\n        abuffer = cur->bitmap;\n        bbuffer = clip_bm->buffer;\n        ax = cur->dst_x;\n        ay = cur->dst_y;\n        aw = cur->w;\n        ah = cur->h;\n        as = cur->stride;\n        bx = clip_bm->left;\n        by = clip_bm->top;\n        bw = clip_bm->w;\n        bh = clip_bm->h;\n        bs = clip_bm->stride;\n\n        // Calculate overlap coordinates\n        left = (ax > bx) ? ax : bx;\n        top = (ay > by) ? ay : by;\n        right = ((ax + aw) < (bx + bw)) ? (ax + aw) : (bx + bw);\n        bottom = ((ay + ah) < (by + bh)) ? (ay + ah) : (by + bh);\n        aleft = left - ax;\n        atop = top - ay;\n        w = right - left;\n        h = bottom - top;\n        bleft = left - bx;\n        btop = top - by;\n\n        if (render_priv->state.clip_drawing_mode) {\n            // Inverse clip\n            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||\n                ay > by + bh || !h || !w) {\n                continue;\n            }\n\n            // Allocate new buffer and add to free list\n            nbuffer = ass_aligned_alloc(32, as * ah, false);\n            if (!nbuffer)\n                break;\n\n            // Blend together\n            memcpy(nbuffer, abuffer, ((ah - 1) * as) + aw);\n            render_priv->engine->sub_bitmaps(nbuffer + atop * as + aleft, as,\n                                             bbuffer + btop * bs + bleft, bs,\n                                             h, w);\n        } else {\n            // Regular clip\n            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||\n                ay > by + bh || !h || !w) {\n                cur->w = cur->h = cur->stride = 0;\n                continue;\n            }\n\n            // Allocate new buffer and add to free list\n            unsigned align = (w >= 16) ? 16 : ((w >= 8) ? 8 : 1);\n            unsigned ns = ass_align(align, w);\n            nbuffer = ass_aligned_alloc(align, ns * h, false);\n            if (!nbuffer)\n                break;\n\n            // Blend together\n            render_priv->engine->mul_bitmaps(nbuffer, ns,\n                                             abuffer + atop * as + aleft, as,\n                                             bbuffer + btop * bs + bleft, bs,\n                                             w, h);\n            cur->dst_x += aleft;\n            cur->dst_y += atop;\n            cur->w = w;\n            cur->h = h;\n            cur->stride = ns;\n        }\n\n        cur->bitmap = nbuffer;\n        ASS_ImagePriv *priv = (ASS_ImagePriv *) cur;\n        ass_cache_dec_ref(priv->source);\n        priv->source = NULL;\n    }\n\n    ass_cache_dec_ref(val);\n}\n\n/**\n * \\brief Convert TextInfo struct to ASS_Image list\n * Splits glyphs in halves when needed (for \\kf karaoke).\n */\nstatic ASS_Image *render_text(ASS_Renderer *render_priv)\n{\n    ASS_Image *head;\n    ASS_Image **tail = &head;\n    unsigned n_bitmaps = render_priv->text_info.n_bitmaps;\n    CombinedBitmapInfo *bitmaps = render_priv->text_info.combined_bitmaps;\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm_s || render_priv->state.border_style == 4)\n            continue;\n\n        tail =\n            render_glyph(render_priv, info->bm_s, info->x, info->y, info->c[3], 0,\n                         1000000, tail, IMAGE_TYPE_SHADOW, info->image);\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm_o)\n            continue;\n\n        if ((info->effect_type == EF_KARAOKE_KO)\n                && (info->effect_timing <= info->first_pos_x)) {\n            // do nothing\n        } else {\n            tail =\n                render_glyph(render_priv, info->bm_o, info->x, info->y, info->c[2],\n                             0, 1000000, tail, IMAGE_TYPE_OUTLINE, info->image);\n        }\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++) {\n        CombinedBitmapInfo *info = &bitmaps[i];\n        if (!info->bm)\n            continue;\n\n        if ((info->effect_type == EF_KARAOKE)\n                || (info->effect_type == EF_KARAOKE_KO)) {\n            if (info->effect_timing > info->first_pos_x)\n                tail =\n                    render_glyph(render_priv, info->bm, info->x, info->y,\n                                 info->c[0], 0, 1000000, tail,\n                                 IMAGE_TYPE_CHARACTER, info->image);\n            else\n                tail =\n                    render_glyph(render_priv, info->bm, info->x, info->y,\n                                 info->c[1], 0, 1000000, tail,\n                                 IMAGE_TYPE_CHARACTER, info->image);\n        } else if (info->effect_type == EF_KARAOKE_KF) {\n            tail =\n                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],\n                             info->c[1], info->effect_timing, tail,\n                             IMAGE_TYPE_CHARACTER, info->image);\n        } else\n            tail =\n                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],\n                             0, 1000000, tail, IMAGE_TYPE_CHARACTER, info->image);\n    }\n\n    for (unsigned i = 0; i < n_bitmaps; i++)\n        ass_cache_dec_ref(bitmaps[i].image);\n\n    *tail = 0;\n    blend_vector_clip(render_priv, head);\n\n    return head;\n}\n\nstatic void compute_string_bbox(TextInfo *text, DBBox *bbox)\n{\n    int i;\n\n    if (text->length > 0) {\n        bbox->xMin = 32000;\n        bbox->xMax = -32000;\n        bbox->yMin = -1 * text->lines[0].asc + d6_to_double(text->glyphs[0].pos.y);\n        bbox->yMax = text->height - text->lines[0].asc +\n                     d6_to_double(text->glyphs[0].pos.y);\n\n        for (i = 0; i < text->length; ++i) {\n            GlyphInfo *info = text->glyphs + i;\n            if (info->skip) continue;\n            double s = d6_to_double(info->pos.x);\n            double e = s + d6_to_double(info->cluster_advance.x);\n            bbox->xMin = FFMIN(bbox->xMin, s);\n            bbox->xMax = FFMAX(bbox->xMax, e);\n        }\n    } else\n        bbox->xMin = bbox->xMax = bbox->yMin = bbox->yMax = 0.;\n}\n\nstatic ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,\n                                                   ASS_Style *rstyle)\n{\n    // The script style is the one the event was declared with.\n    ASS_Style *script = render_priv->track->styles +\n                        render_priv->state.event->Style;\n    // The user style was set with ass_set_selective_style_override().\n    ASS_Style *user = &render_priv->user_override_style;\n    ASS_Style *new = &render_priv->state.override_style_temp_storage;\n    int explicit = event_has_hard_overrides(render_priv->state.event->Text) ||\n                   render_priv->state.evt_type != EVENT_NORMAL;\n    int requested = render_priv->settings.selective_style_overrides;\n    double scale;\n\n    user->Name = \"OverrideStyle\"; // name insignificant\n\n    // Either the event's style, or the style forced with a \\r tag.\n    if (!rstyle)\n        rstyle = script;\n\n    // Create a new style that contains a mix of the original style and\n    // user_style (the user's override style). Copy only fields from the\n    // script's style that are deemed necessary.\n    *new = *rstyle;\n\n    render_priv->state.explicit = explicit;\n\n    render_priv->state.apply_font_scale =\n        !explicit || !(requested & ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);\n\n    // On positioned events, do not apply most overrides.\n    if (explicit)\n        requested = 0;\n\n    if (requested & ASS_OVERRIDE_BIT_STYLE)\n        requested |= ASS_OVERRIDE_BIT_FONT_NAME |\n                     ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS |\n                     ASS_OVERRIDE_BIT_COLORS |\n                     ASS_OVERRIDE_BIT_BORDER |\n                     ASS_OVERRIDE_BIT_ATTRIBUTES;\n\n    // Copies fields even not covered by any of the other bits.\n    if (requested & ASS_OVERRIDE_FULL_STYLE)\n        *new = *user;\n\n    // The user style is supposed to be independent of the script resolution.\n    // Treat the user style's values as if they were specified for a script with\n    // PlayResY=288, and rescale the values to the current script.\n    scale = render_priv->track->PlayResY / 288.0;\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS) {\n        new->FontSize = user->FontSize * scale;\n        new->Spacing = user->Spacing * scale;\n        new->ScaleX = user->ScaleX;\n        new->ScaleY = user->ScaleY;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_FONT_NAME) {\n        new->FontName = user->FontName;\n        new->treat_fontname_as_pattern = user->treat_fontname_as_pattern;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_COLORS) {\n        new->PrimaryColour = user->PrimaryColour;\n        new->SecondaryColour = user->SecondaryColour;\n        new->OutlineColour = user->OutlineColour;\n        new->BackColour = user->BackColour;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ATTRIBUTES) {\n        new->Bold = user->Bold;\n        new->Italic = user->Italic;\n        new->Underline = user->Underline;\n        new->StrikeOut = user->StrikeOut;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_BORDER) {\n        new->BorderStyle = user->BorderStyle;\n        new->Outline = user->Outline * scale;\n        new->Shadow = user->Shadow * scale;\n    }\n\n    if (requested & ASS_OVERRIDE_BIT_ALIGNMENT)\n        new->Alignment = user->Alignment;\n\n    if (requested & ASS_OVERRIDE_BIT_MARGINS) {\n        new->MarginL = user->MarginL;\n        new->MarginR = user->MarginR;\n        new->MarginV = user->MarginV;\n    }\n\n    if (!new->FontName)\n        new->FontName = rstyle->FontName;\n\n    render_priv->state.style = new;\n    render_priv->state.overrides = requested;\n\n    return new;\n}\n\nstatic void init_font_scale(ASS_Renderer *render_priv)\n{\n    ASS_Settings *settings_priv = &render_priv->settings;\n\n    render_priv->font_scale = ((double) render_priv->orig_height) /\n                              render_priv->track->PlayResY;\n    if (settings_priv->storage_height)\n        render_priv->blur_scale = ((double) render_priv->orig_height) /\n            settings_priv->storage_height;\n    else\n        render_priv->blur_scale = 1.;\n    if (render_priv->track->ScaledBorderAndShadow)\n        render_priv->border_scale =\n            ((double) render_priv->orig_height) /\n            render_priv->track->PlayResY;\n    else\n        render_priv->border_scale = render_priv->blur_scale;\n    if (!settings_priv->storage_height)\n        render_priv->blur_scale = render_priv->border_scale;\n\n    if (render_priv->state.apply_font_scale) {\n        render_priv->font_scale *= settings_priv->font_size_coeff;\n        render_priv->border_scale *= settings_priv->font_size_coeff;\n        render_priv->blur_scale *= settings_priv->font_size_coeff;\n    }\n}\n\n/**\n * \\brief partially reset render_context to style values\n * Works like {\\r}: resets some style overrides\n */\nvoid reset_render_context(ASS_Renderer *render_priv, ASS_Style *style)\n{\n    style = handle_selective_style_overrides(render_priv, style);\n\n    init_font_scale(render_priv);\n\n    render_priv->state.c[0] = style->PrimaryColour;\n    render_priv->state.c[1] = style->SecondaryColour;\n    render_priv->state.c[2] = style->OutlineColour;\n    render_priv->state.c[3] = style->BackColour;\n    render_priv->state.flags =\n        (style->Underline ? DECO_UNDERLINE : 0) |\n        (style->StrikeOut ? DECO_STRIKETHROUGH : 0);\n    render_priv->state.font_size = style->FontSize;\n\n    free(render_priv->state.family);\n    render_priv->state.family = NULL;\n    render_priv->state.family = strdup(style->FontName);\n    render_priv->state.treat_family_as_pattern =\n        style->treat_fontname_as_pattern;\n    render_priv->state.bold = style->Bold;\n    render_priv->state.italic = style->Italic;\n    update_font(render_priv);\n\n    render_priv->state.border_style = style->BorderStyle;\n    render_priv->state.border_x = style->Outline;\n    render_priv->state.border_y = style->Outline;\n    change_border(render_priv, render_priv->state.border_x, render_priv->state.border_y);\n    render_priv->state.scale_x = style->ScaleX;\n    render_priv->state.scale_y = style->ScaleY;\n    render_priv->state.hspacing = style->Spacing;\n    render_priv->state.be = 0;\n    render_priv->state.blur = style->Blur;\n    render_priv->state.shadow_x = style->Shadow;\n    render_priv->state.shadow_y = style->Shadow;\n    render_priv->state.frx = render_priv->state.fry = 0.;\n    render_priv->state.frz = M_PI * style->Angle / 180.;\n    render_priv->state.fax = render_priv->state.fay = 0.;\n    render_priv->state.font_encoding = style->Encoding;\n}\n\n/**\n * \\brief Start new event. Reset render_priv->state.\n */\nstatic void\ninit_render_context(ASS_Renderer *render_priv, ASS_Event *event)\n{\n    render_priv->state.event = event;\n    render_priv->state.parsed_tags = 0;\n    render_priv->state.has_clips = 0;\n    render_priv->state.evt_type = EVENT_NORMAL;\n\n    reset_render_context(render_priv, NULL);\n    render_priv->state.wrap_style = render_priv->track->WrapStyle;\n\n    render_priv->state.alignment = render_priv->state.style->Alignment;\n    render_priv->state.pos_x = 0;\n    render_priv->state.pos_y = 0;\n    render_priv->state.org_x = 0;\n    render_priv->state.org_y = 0;\n    render_priv->state.have_origin = 0;\n    render_priv->state.clip_x0 = 0;\n    render_priv->state.clip_y0 = 0;\n    render_priv->state.clip_x1 = render_priv->track->PlayResX;\n    render_priv->state.clip_y1 = render_priv->track->PlayResY;\n    render_priv->state.clip_mode = 0;\n    render_priv->state.detect_collisions = 1;\n    render_priv->state.fade = 0;\n    render_priv->state.drawing_scale = 0;\n    render_priv->state.pbo = 0;\n    render_priv->state.effect_type = EF_NONE;\n    render_priv->state.effect_timing = 0;\n    render_priv->state.effect_skip_timing = 0;\n\n    apply_transition_effects(render_priv, event);\n}\n\nstatic void free_render_context(ASS_Renderer *render_priv)\n{\n    ass_cache_dec_ref(render_priv->state.font);\n    free(render_priv->state.family);\n    ass_drawing_free(render_priv->state.clip_drawing);\n\n    render_priv->state.font = NULL;\n    render_priv->state.family = NULL;\n    render_priv->state.clip_drawing = NULL;\n\n    TextInfo *text_info = &render_priv->text_info;\n    for (int n = 0; n < text_info->length; n++)\n        ass_drawing_free(text_info->glyphs[n].drawing);\n    text_info->length = 0;\n}\n\n/*\n * Replace the outline of a glyph by a contour which makes up a simple\n * opaque rectangle.\n */\nstatic void draw_opaque_box(ASS_Renderer *render_priv, GlyphInfo *info,\n                            int asc, int desc, ASS_Outline *ol,\n                            FT_Vector advance, int sx, int sy)\n{\n    int adv = advance.x;\n    double scale_y = info->orig_scale_y;\n    double scale_x = info->orig_scale_x;\n\n    // to avoid gaps\n    sx = FFMAX(64, sx);\n    sy = FFMAX(64, sy);\n\n    // Emulate the WTFish behavior of VSFilter, i.e. double-scale\n    // the sizes of the opaque box.\n    adv += double_to_d6(info->hspacing * render_priv->font_scale * scale_x);\n    adv *= scale_x;\n    sx *= scale_x;\n    sy *= scale_y;\n    desc *= scale_y;\n    desc += asc * (scale_y - 1.0);\n\n    FT_Vector points[4] = {\n        { .x = -sx,         .y = asc + sy },\n        { .x = adv + sx,    .y = asc + sy },\n        { .x = adv + sx,    .y = -desc - sy },\n        { .x = -sx,         .y = -desc - sy },\n    };\n\n    ol->n_points = ol->n_contours = 0;\n    if (!outline_alloc(ol, 4, 1))\n        return;\n    for (int i = 0; i < 4; ++i) {\n        ol->points[ol->n_points] = points[i];\n        ol->tags[ol->n_points++] = 1;\n    }\n    ol->contours[ol->n_contours++] = ol->n_points - 1;\n}\n\n/*\n * Stroke an outline glyph in x/y direction.  Applies various fixups to get\n * around limitations of the FreeType stroker.\n */\nstatic void stroke_outline(ASS_Renderer *render_priv, ASS_Outline *outline,\n                           int sx, int sy)\n{\n    if (sx <= 0 && sy <= 0)\n        return;\n\n    fix_freetype_stroker(outline, sx, sy);\n\n    size_t n_points = outline->n_points;\n    if (n_points > SHRT_MAX) {\n        ass_msg(render_priv->library, MSGL_WARN, \"Too many outline points: %d\",\n                outline->n_points);\n        n_points = SHRT_MAX;\n    }\n\n    size_t n_contours = FFMIN(outline->n_contours, SHRT_MAX);\n    short contours_small[EFFICIENT_CONTOUR_COUNT];\n    short *contours = contours_small;\n    short *contours_large = NULL;\n    if (n_contours > EFFICIENT_CONTOUR_COUNT) {\n        contours_large = malloc(n_contours * sizeof(short));\n        if (!contours_large)\n            return;\n        contours = contours_large;\n    }\n    for (size_t i = 0; i < n_contours; ++i)\n        contours[i] = FFMIN(outline->contours[i], n_points - 1);\n\n    FT_Outline ftol;\n    ftol.n_points = n_points;\n    ftol.n_contours = n_contours;\n    ftol.points = outline->points;\n    ftol.tags = outline->tags;\n    ftol.contours = contours;\n    ftol.flags = 0;\n\n    // Borders are equal; use the regular stroker\n    if (sx == sy && render_priv->state.stroker) {\n        int error;\n        FT_StrokerBorder border = FT_Outline_GetOutsideBorder(&ftol);\n        error = FT_Stroker_ParseOutline(render_priv->state.stroker, &ftol, 0);\n        if (error) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"FT_Stroker_ParseOutline failed, error: %d\", error);\n        }\n        unsigned new_points, new_contours;\n        error = FT_Stroker_GetBorderCounts(render_priv->state.stroker, border,\n                &new_points, &new_contours);\n        if (error) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"FT_Stroker_GetBorderCounts failed, error: %d\", error);\n        }\n        outline_free(outline);\n        outline->n_points = outline->n_contours = 0;\n        if (new_contours > FFMAX(EFFICIENT_CONTOUR_COUNT, n_contours)) {\n            if (!ASS_REALLOC_ARRAY(contours_large, new_contours)) {\n                free(contours_large);\n                return;\n            }\n        }\n        n_points = new_points;\n        n_contours = new_contours;\n        if (!outline_alloc(outline, n_points, n_contours)) {\n            ass_msg(render_priv->library, MSGL_WARN,\n                    \"Not enough memory for border outline\");\n            free(contours_large);\n            return;\n        }\n        ftol.n_points = ftol.n_contours = 0;\n        ftol.points = outline->points;\n        ftol.tags = outline->tags;\n\n        FT_Stroker_ExportBorder(render_priv->state.stroker, border, &ftol);\n\n        outline->n_points = n_points;\n        outline->n_contours = n_contours;\n        for (size_t i = 0; i < n_contours; ++i)\n            outline->contours[i] = (unsigned short) contours[i];\n\n    // \"Stroke\" with the outline emboldener (in two passes if needed).\n    // The outlines look uglier, but the emboldening never adds any points\n    } else {\n#if (FREETYPE_MAJOR > 2) || \\\n    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 4)) || \\\n    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 4) && (FREETYPE_PATCH >= 10))\n        FT_Outline_EmboldenXY(&ftol, sx * 2, sy * 2);\n        FT_Outline_Translate(&ftol, -sx, -sy);\n#else\n        int i;\n        FT_Outline nol;\n\n        FT_Outline_New(render_priv->ftlibrary, ftol.n_points,\n                       ftol.n_contours, &nol);\n        FT_Outline_Copy(&ftol, &nol);\n\n        FT_Outline_Embolden(&ftol, sx * 2);\n        FT_Outline_Translate(&ftol, -sx, -sx);\n        FT_Outline_Embolden(&nol, sy * 2);\n        FT_Outline_Translate(&nol, -sy, -sy);\n\n        for (i = 0; i < ftol.n_points; i++)\n            ftol.points[i].y = nol.points[i].y;\n\n        FT_Outline_Done(render_priv->ftlibrary, &nol);\n#endif\n    }\n\n    free(contours_large);\n}\n\n/**\n * \\brief Prepare glyph hash\n */\nstatic void\nfill_glyph_hash(ASS_Renderer *priv, OutlineHashKey *outline_key,\n                GlyphInfo *info)\n{\n    if (info->drawing) {\n        DrawingHashKey *key = &outline_key->u.drawing;\n        outline_key->type = OUTLINE_DRAWING;\n        key->scale_x = double_to_d16(info->scale_x);\n        key->scale_y = double_to_d16(info->scale_y);\n        key->outline.x = double_to_d16(info->border_x);\n        key->outline.y = double_to_d16(info->border_y);\n        key->border_style = info->border_style;\n        // hpacing only matters for opaque box borders (see draw_opaque_box),\n        // so for normal borders, maximize cache utility by ignoring it\n        key->hspacing =\n            info->border_style == 3 ? double_to_d16(info->hspacing) : 0;\n        key->hash = info->drawing->hash;\n        key->text = info->drawing->text;\n        key->pbo = info->drawing->pbo;\n        key->scale = info->drawing->scale;\n    } else {\n        GlyphHashKey *key = &outline_key->u.glyph;\n        outline_key->type = OUTLINE_GLYPH;\n        key->font = info->font;\n        key->size = info->font_size;\n        key->face_index = info->face_index;\n        key->glyph_index = info->glyph_index;\n        key->bold = info->bold;\n        key->italic = info->italic;\n        key->scale_x = double_to_d16(info->scale_x);\n        key->scale_y = double_to_d16(info->scale_y);\n        key->outline.x = double_to_d16(info->border_x);\n        key->outline.y = double_to_d16(info->border_y);\n        key->flags = info->flags;\n        key->border_style = info->border_style;\n        key->hspacing =\n            info->border_style == 3 ? double_to_d16(info->hspacing) : 0;\n    }\n}\n\n/**\n * \\brief Prepare combined-bitmap hash\n */\nstatic void fill_composite_hash(CompositeHashKey *hk, CombinedBitmapInfo *info)\n{\n    hk->filter = info->filter;\n    hk->bitmap_count = info->bitmap_count;\n    hk->bitmaps = info->bitmaps;\n}\n\n/**\n * \\brief Get normal and outline (border) glyphs\n * \\param info out: struct filled with extracted data\n * Tries to get both glyphs from cache.\n * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,\n * and add them to cache.\n * The glyphs are returned in info->glyph and info->outline_glyph\n */\nstatic void\nget_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)\n{\n    memset(&info->hash_key, 0, sizeof(info->hash_key));\n\n    OutlineHashKey key;\n    OutlineHashValue *val;\n    fill_glyph_hash(priv, &key, info);\n    if (!ass_cache_get(priv->cache.outline_cache, &key, &val)) {\n        if (!val)\n            return;\n        memset(val, 0, sizeof(*val));\n\n        if (info->drawing) {\n            ASS_Drawing *drawing = info->drawing;\n            ass_drawing_hash(drawing);\n            if(!ass_drawing_parse(drawing, 0)) {\n                ass_cache_commit(val, 1);\n                ass_cache_dec_ref(val);\n                return;\n            }\n            val->outline = outline_copy(&drawing->outline);\n            val->advance.x = drawing->advance.x;\n            val->advance.y = drawing->advance.y;\n            val->asc = drawing->asc;\n            val->desc = drawing->desc;\n        } else {\n            ass_face_set_size(info->font->faces[info->face_index],\n                              info->font_size);\n            ass_font_set_transform(info->font, info->scale_x,\n                                   info->scale_y, NULL);\n            FT_Glyph glyph =\n                ass_font_get_glyph(info->font,\n                        info->symbol, info->face_index, info->glyph_index,\n                        priv->settings.hinting, info->flags);\n            if (glyph != NULL) {\n                val->outline = outline_convert(&((FT_OutlineGlyph) glyph)->outline);\n                if (priv->settings.shaper == ASS_SHAPING_SIMPLE) {\n                    val->advance.x = d16_to_d6(glyph->advance.x);\n                    val->advance.y = d16_to_d6(glyph->advance.y);\n                }\n                FT_Done_Glyph(glyph);\n                ass_font_get_asc_desc(info->font, info->symbol,\n                                      &val->asc, &val->desc);\n                val->asc  *= info->scale_y;\n                val->desc *= info->scale_y;\n            }\n        }\n\n        if (!val->outline) {\n            ass_cache_commit(val, 1);\n            ass_cache_dec_ref(val);\n            return;\n        }\n\n        outline_get_cbox(val->outline, &val->bbox_scaled);\n\n        if (info->border_style == 3) {\n            val->border = calloc(1, sizeof(ASS_Outline));\n            if (!val->border) {\n                outline_free(val->outline);\n                free(val->outline);\n                val->outline = NULL;\n                ass_cache_commit(val, 1);\n                ass_cache_dec_ref(val);\n                return;\n            }\n\n            FT_Vector advance;\n            if (priv->settings.shaper == ASS_SHAPING_SIMPLE || info->drawing)\n                advance = val->advance;\n            else\n                advance = info->advance;\n\n            draw_opaque_box(priv, info, val->asc, val->desc, val->border, advance,\n                    double_to_d6(info->border_x * priv->border_scale),\n                    double_to_d6(info->border_y * priv->border_scale));\n\n        } else if ((info->border_x > 0 || info->border_y > 0)\n                && double_to_d6(info->scale_x) && double_to_d6(info->scale_y)) {\n\n            change_border(priv, info->border_x, info->border_y);\n            val->border = outline_copy(val->outline);\n            stroke_outline(priv, val->border,\n                    double_to_d6(info->border_x * priv->border_scale),\n                    double_to_d6(info->border_y * priv->border_scale));\n        }\n\n        ass_cache_commit(val, 1);\n    }\n\n    if (!val->outline) {\n        ass_cache_dec_ref(val);\n        return;\n    }\n\n    info->hash_key.u.outline.outline = val;\n    info->outline = val->outline;\n    info->border = val->border;\n    info->bbox = val->bbox_scaled;\n    if (info->drawing || priv->settings.shaper == ASS_SHAPING_SIMPLE) {\n        info->cluster_advance.x = info->advance.x = val->advance.x;\n        info->cluster_advance.y = info->advance.y = val->advance.y;\n    }\n    info->asc = val->asc;\n    info->desc = val->desc;\n}\n\n/**\n * \\brief Apply transformation to outline points of a glyph\n * Applies rotations given by frx, fry and frz and projects the points back\n * onto the screen plane.\n */\nstatic void\ntransform_3d_points(FT_Vector shift, ASS_Outline *outline, double frx, double fry,\n                    double frz, double fax, double fay, double scale,\n                    int yshift)\n{\n    double sx = sin(frx);\n    double sy = sin(fry);\n    double sz = sin(frz);\n    double cx = cos(frx);\n    double cy = cos(fry);\n    double cz = cos(frz);\n    FT_Vector *p = outline->points;\n    double x, y, z, xx, yy, zz;\n    int dist;\n\n    dist = 20000 * scale;\n    for (size_t i = 0; i < outline->n_points; ++i) {\n        x = (double) p[i].x + shift.x + (fax * (yshift - p[i].y));\n        y = (double) p[i].y + shift.y + (-fay * p[i].x);\n        z = 0.;\n\n        xx = x * cz + y * sz;\n        yy = -(x * sz - y * cz);\n        zz = z;\n\n        x = xx;\n        y = yy * cx + zz * sx;\n        z = yy * sx - zz * cx;\n\n        xx = x * cy + z * sy;\n        yy = y;\n        zz = x * sy - z * cy;\n\n        zz = FFMAX(zz, 1000 - dist);\n\n        x = (xx * dist) / (zz + dist);\n        y = (yy * dist) / (zz + dist);\n        p[i].x = x - shift.x + 0.5;\n        p[i].y = y - shift.y + 0.5;\n    }\n}\n\n/**\n * \\brief Apply 3d transformation to several objects\n * \\param shift FreeType vector\n * \\param glyph FreeType glyph\n * \\param glyph2 FreeType glyph\n * \\param frx x-axis rotation angle\n * \\param fry y-axis rotation angle\n * \\param frz z-axis rotation angle\n * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.\n */\nstatic void\ntransform_3d(FT_Vector shift, ASS_Outline *outline, ASS_Outline *border,\n             double frx, double fry, double frz, double fax, double fay,\n             double scale, int yshift)\n{\n    frx = -frx;\n    frz = -frz;\n    if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {\n        if (outline)\n            transform_3d_points(shift, outline, frx, fry, frz,\n                                fax, fay, scale, yshift);\n\n        if (border)\n            transform_3d_points(shift, border, frx, fry, frz,\n                                fax, fay, scale, yshift);\n    }\n}\n\n/**\n * \\brief Get bitmaps for a glyph\n * \\param info glyph info\n * Tries to get glyph bitmaps from bitmap cache.\n * If they can't be found, they are generated by rotating and rendering the glyph.\n * After that, bitmaps are added to the cache.\n * They are returned in info->bm (glyph), info->bm_o (outline) and info->bm_s (shadow).\n */\nstatic void\nget_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)\n{\n    if (!info->outline || info->symbol == '\\n' || info->symbol == 0 || info->skip)\n        return;\n\n    BitmapHashValue *val;\n    OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n    if (ass_cache_get(render_priv->cache.bitmap_cache, &info->hash_key, &val)) {\n        info->image = val;\n        return;\n    }\n    if (!val)\n        return;\n\n    ASS_Outline *outline = outline_copy(info->outline);\n    ASS_Outline *border  = outline_copy(info->border);\n\n    // calculating rotation shift vector (from rotation origin to the glyph basepoint)\n    FT_Vector shift = { key->shift_x, key->shift_y };\n    double scale_x = render_priv->font_scale_x;\n    double fax_scaled = info->fax / info->scale_y * info->scale_x;\n    double fay_scaled = info->fay / info->scale_x * info->scale_y;\n\n    // apply rotation\n    // use blur_scale because, like blurs, VSFilter forgets to scale this\n    transform_3d(shift, outline, border,\n                 info->frx, info->fry, info->frz, fax_scaled,\n                 fay_scaled, render_priv->blur_scale, info->asc);\n\n    // PAR correction scaling\n    FT_Matrix m = { double_to_d16(scale_x), 0,\n                    0, double_to_d16(1.0) };\n\n    // subpixel shift\n    if (outline) {\n        if (scale_x != 1.0)\n            outline_transform(outline, &m);\n        outline_translate(outline, key->advance.x, -key->advance.y);\n    }\n    if (border) {\n        if (scale_x != 1.0)\n            outline_transform(border, &m);\n        outline_translate(border, key->advance.x, -key->advance.y);\n    }\n\n    // render glyph\n    int error = outline_to_bitmap2(render_priv, outline, border,\n                                   &val->bm, &val->bm_o);\n    if (error)\n        info->symbol = 0;\n\n    ass_cache_commit(val, bitmap_size(val->bm) + bitmap_size(val->bm_o) +\n                     sizeof(BitmapHashKey) + sizeof(BitmapHashValue));\n    info->image = val;\n\n    outline_free(outline);\n    free(outline);\n    outline_free(border);\n    free(border);\n}\n\n/**\n * This function goes through text_info and calculates text parameters.\n * The following text_info fields are filled:\n *   height\n *   lines[].height\n *   lines[].asc\n *   lines[].desc\n */\nstatic void measure_text(ASS_Renderer *render_priv)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    int cur_line = 0;\n    double max_asc = 0., max_desc = 0.;\n    GlyphInfo *last = NULL;\n    int i;\n    int empty_line = 1;\n    text_info->height = 0.;\n    for (i = 0; i < text_info->length + 1; ++i) {\n        if ((i == text_info->length) || text_info->glyphs[i].linebreak) {\n            if (empty_line && cur_line > 0 && last) {\n                max_asc = d6_to_double(last->asc) / 2.0;\n                max_desc = d6_to_double(last->desc) / 2.0;\n            }\n            text_info->lines[cur_line].asc = max_asc;\n            text_info->lines[cur_line].desc = max_desc;\n            text_info->height += max_asc + max_desc;\n            cur_line++;\n            max_asc = max_desc = 0.;\n            empty_line = 1;\n        }\n        if (i < text_info->length) {\n            GlyphInfo *cur = text_info->glyphs + i;\n            if (d6_to_double(cur->asc) > max_asc)\n                max_asc = d6_to_double(cur->asc);\n            if (d6_to_double(cur->desc) > max_desc)\n                max_desc = d6_to_double(cur->desc);\n            if (cur->symbol != '\\n' && cur->symbol != 0) {\n                empty_line = 0;\n                last = cur;\n            }\n        }\n    }\n    text_info->height +=\n        (text_info->n_lines -\n         1) * render_priv->settings.line_spacing;\n}\n\n/**\n * Mark extra whitespace for later removal.\n */\n#define IS_WHITESPACE(x) ((x->symbol == ' ' || x->symbol == '\\n') \\\n                          && !x->linebreak)\nstatic void trim_whitespace(ASS_Renderer *render_priv)\n{\n    int i, j;\n    GlyphInfo *cur;\n    TextInfo *ti = &render_priv->text_info;\n\n    // Mark trailing spaces\n    i = ti->length - 1;\n    cur = ti->glyphs + i;\n    while (i && IS_WHITESPACE(cur)) {\n        cur->skip++;\n        cur = ti->glyphs + --i;\n    }\n\n    // Mark leading whitespace\n    i = 0;\n    cur = ti->glyphs;\n    while (i < ti->length && IS_WHITESPACE(cur)) {\n        cur->skip++;\n        cur = ti->glyphs + ++i;\n    }\n\n    // Mark all extraneous whitespace inbetween\n    for (i = 0; i < ti->length; ++i) {\n        cur = ti->glyphs + i;\n        if (cur->linebreak) {\n            // Mark whitespace before\n            j = i - 1;\n            cur = ti->glyphs + j;\n            while (j && IS_WHITESPACE(cur)) {\n                cur->skip++;\n                cur = ti->glyphs + --j;\n            }\n            // A break itself can contain a whitespace, too\n            cur = ti->glyphs + i;\n            if (cur->symbol == ' ' || cur->symbol == '\\n') {\n                cur->skip++;\n                // Mark whitespace after\n                j = i + 1;\n                cur = ti->glyphs + j;\n                while (j < ti->length && IS_WHITESPACE(cur)) {\n                    cur->skip++;\n                    cur = ti->glyphs + ++j;\n                }\n                i = j - 1;\n            }\n        }\n    }\n}\n#undef IS_WHITESPACE\n\n/**\n * \\brief rearrange text between lines\n * \\param max_text_width maximal text line width in pixels\n * The algo is similar to the one in libvo/sub.c:\n * 1. Place text, wrapping it when current line is full\n * 2. Try moving words from the end of a line to the beginning of the next one while it reduces\n * the difference in lengths between this two lines.\n * The result may not be optimal, but usually is good enough.\n *\n * FIXME: implement style 0 and 3 correctly\n */\nstatic void\nwrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)\n{\n    int i;\n    GlyphInfo *cur, *s1, *e1, *s2, *s3;\n    int last_space;\n    int break_type;\n    int exit;\n    double pen_shift_x;\n    double pen_shift_y;\n    int cur_line;\n    int run_offset;\n    TextInfo *text_info = &render_priv->text_info;\n\n    last_space = -1;\n    text_info->n_lines = 1;\n    break_type = 0;\n    s1 = text_info->glyphs;     // current line start\n    for (i = 0; i < text_info->length; ++i) {\n        int break_at = -1;\n        double s_offset, len;\n        cur = text_info->glyphs + i;\n        s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);\n        len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;\n\n        if (cur->symbol == '\\n') {\n            break_type = 2;\n            break_at = i;\n            ass_msg(render_priv->library, MSGL_DBG2,\n                    \"forced line break at %d\", break_at);\n        } else if (cur->symbol == ' ') {\n            last_space = i;\n        } else if (len >= max_text_width\n                   && (render_priv->state.wrap_style != 2)) {\n            break_type = 1;\n            break_at = last_space;\n            if (break_at >= 0)\n                ass_msg(render_priv->library, MSGL_DBG2, \"line break at %d\",\n                        break_at);\n        }\n\n        if (break_at != -1) {\n            // need to use one more line\n            // marking break_at+1 as start of a new line\n            int lead = break_at + 1;    // the first symbol of the new line\n            if (text_info->n_lines >= text_info->max_lines) {\n                // Raise maximum number of lines\n                text_info->max_lines *= 2;\n                text_info->lines = realloc(text_info->lines,\n                                           sizeof(LineInfo) *\n                                           text_info->max_lines);\n            }\n            if (lead < text_info->length) {\n                text_info->glyphs[lead].linebreak = break_type;\n                last_space = -1;\n                s1 = text_info->glyphs + lead;\n                text_info->n_lines++;\n            }\n        }\n    }\n#define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))\n    exit = 0;\n    while (!exit && render_priv->state.wrap_style != 1) {\n        exit = 1;\n        s3 = text_info->glyphs;\n        s1 = s2 = 0;\n        for (i = 0; i <= text_info->length; ++i) {\n            cur = text_info->glyphs + i;\n            if ((i == text_info->length) || cur->linebreak) {\n                s1 = s2;\n                s2 = s3;\n                s3 = cur;\n                if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'\n                    double l1, l2, l1_new, l2_new;\n                    GlyphInfo *w = s2;\n\n                    do {\n                        --w;\n                    } while ((w > s1) && (w->symbol == ' '));\n                    while ((w > s1) && (w->symbol != ' ')) {\n                        --w;\n                    }\n                    e1 = w;\n                    while ((e1 > s1) && (e1->symbol == ' ')) {\n                        --e1;\n                    }\n                    if (w->symbol == ' ')\n                        ++w;\n\n                    l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -\n                        (s1->bbox.xMin + s1->pos.x));\n                    l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -\n                        (s2->bbox.xMin + s2->pos.x));\n                    l1_new = d6_to_double(\n                        (e1->bbox.xMax + e1->pos.x) -\n                        (s1->bbox.xMin + s1->pos.x));\n                    l2_new = d6_to_double(\n                        ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -\n                        (w->bbox.xMin + w->pos.x));\n\n                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {\n                        if (w->linebreak || w == text_info->glyphs)\n                            text_info->n_lines--;\n                        if (w != text_info->glyphs)\n                            w->linebreak = 1;\n                        s2->linebreak = 0;\n                        exit = 0;\n                    }\n                }\n            }\n            if (i == text_info->length)\n                break;\n        }\n\n    }\n    assert(text_info->n_lines >= 1);\n#undef DIFF\n\n    measure_text(render_priv);\n    trim_whitespace(render_priv);\n\n    cur_line = 1;\n    run_offset = 0;\n\n    i = 0;\n    cur = text_info->glyphs + i;\n    while (i < text_info->length && cur->skip)\n        cur = text_info->glyphs + ++i;\n    pen_shift_x = d6_to_double(-cur->pos.x);\n    pen_shift_y = 0.;\n\n    for (i = 0; i < text_info->length; ++i) {\n        cur = text_info->glyphs + i;\n        if (cur->linebreak) {\n            while (i < text_info->length && cur->skip && cur->symbol != '\\n')\n                cur = text_info->glyphs + ++i;\n            double height =\n                text_info->lines[cur_line - 1].desc +\n                text_info->lines[cur_line].asc;\n            text_info->lines[cur_line - 1].len = i -\n                text_info->lines[cur_line - 1].offset;\n            text_info->lines[cur_line].offset = i;\n            cur_line++;\n            run_offset++;\n            pen_shift_x = d6_to_double(-cur->pos.x);\n            pen_shift_y += height + render_priv->settings.line_spacing;\n        }\n        cur->pos.x += double_to_d6(pen_shift_x);\n        cur->pos.y += double_to_d6(pen_shift_y);\n    }\n    text_info->lines[cur_line - 1].len =\n        text_info->length - text_info->lines[cur_line - 1].offset;\n\n#if 0\n    // print line info\n    for (i = 0; i < text_info->n_lines; i++) {\n        printf(\"line %d offset %d length %d\\n\", i, text_info->lines[i].offset,\n                text_info->lines[i].len);\n    }\n#endif\n}\n\n/**\n * \\brief Calculate base point for positioning and rotation\n * \\param bbox text bbox\n * \\param alignment alignment\n * \\param bx, by out: base point coordinates\n */\nstatic void get_base_point(DBBox *bbox, int alignment, double *bx, double *by)\n{\n    const int halign = alignment & 3;\n    const int valign = alignment & 12;\n    if (bx)\n        switch (halign) {\n        case HALIGN_LEFT:\n            *bx = bbox->xMin;\n            break;\n        case HALIGN_CENTER:\n            *bx = (bbox->xMax + bbox->xMin) / 2.0;\n            break;\n        case HALIGN_RIGHT:\n            *bx = bbox->xMax;\n            break;\n        }\n    if (by)\n        switch (valign) {\n        case VALIGN_TOP:\n            *by = bbox->yMin;\n            break;\n        case VALIGN_CENTER:\n            *by = (bbox->yMax + bbox->yMin) / 2.0;\n            break;\n        case VALIGN_SUB:\n            *by = bbox->yMax;\n            break;\n        }\n}\n\n/**\n * Prepare bitmap hash key of a glyph\n */\nstatic void\nfill_bitmap_hash(ASS_Renderer *priv, GlyphInfo *info,\n                 OutlineBitmapHashKey *hash_key)\n{\n    hash_key->frx = rot_key(info->frx);\n    hash_key->fry = rot_key(info->fry);\n    hash_key->frz = rot_key(info->frz);\n    hash_key->fax = double_to_d16(info->fax);\n    hash_key->fay = double_to_d16(info->fay);\n}\n\n/**\n * \\brief Adjust the glyph's font size and scale factors to ensure smooth\n *  scaling and handle pathological font sizes. The main problem here is\n *  freetype's grid fitting, which destroys animations by font size, or will\n *  result in incorrect final text size if font sizes are very small and\n *  scale factors very large. See Google Code issue #46.\n * \\param priv guess what\n * \\param glyph the glyph to be modified\n */\nstatic void\nfix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)\n{\n    double ft_size;\n    if (priv->settings.hinting == ASS_HINTING_NONE) {\n        // arbitrary, not too small to prevent grid fitting rounding effects\n        // XXX: this is a rather crude hack\n        ft_size = 256.0;\n    } else {\n        // If hinting is enabled, we want to pass the real font size\n        // to freetype. Normalize scale_y to 1.0.\n        ft_size = glyph->scale_y * glyph->font_size;\n    }\n    glyph->scale_x = glyph->scale_x * glyph->font_size / ft_size;\n    glyph->scale_y = glyph->scale_y * glyph->font_size / ft_size;\n    glyph->font_size = ft_size;\n}\n\n /**\n  * \\brief Checks whether a glyph should start a new bitmap run\n  * \\param info Pointer to new GlyphInfo to check\n  * \\param current_info Pointer to CombinedBitmapInfo for current run (may be NULL)\n  * \\return 1 if a new run should be started\n  */\nstatic int is_new_bm_run(GlyphInfo *info, GlyphInfo *last)\n{\n    // FIXME: Don't break on glyph substitutions\n    return !last || info->effect || info->drawing || last->drawing ||\n        strcmp(last->font->desc.family, info->font->desc.family) ||\n        last->font->desc.vertical != info->font->desc.vertical ||\n        last->face_index != info->face_index ||\n        last->font_size != info->font_size ||\n        last->c[0] != info->c[0] ||\n        last->c[1] != info->c[1] ||\n        last->c[2] != info->c[2] ||\n        last->c[3] != info->c[3] ||\n        last->be != info->be ||\n        last->blur != info->blur ||\n        last->shadow_x != info->shadow_x ||\n        last->shadow_y != info->shadow_y ||\n        last->frx != info->frx ||\n        last->fry != info->fry ||\n        last->frz != info->frz ||\n        last->fax != info->fax ||\n        last->fay != info->fay ||\n        last->scale_x != info->scale_x ||\n        last->scale_y != info->scale_y ||\n        last->border_style != info->border_style ||\n        last->border_x != info->border_x ||\n        last->border_y != info->border_y ||\n        last->hspacing != info->hspacing ||\n        last->italic != info->italic ||\n        last->bold != info->bold ||\n        last->flags != info->flags;\n}\n\nstatic void make_shadow_bitmap(CombinedBitmapInfo *info, ASS_Renderer *render_priv)\n{\n    if (!(info->filter.flags & FILTER_NONZERO_SHADOW)) {\n        if (info->bm && info->bm_o && !(info->filter.flags & FILTER_BORDER_STYLE_3)) {\n            fix_outline(info->bm, info->bm_o);\n        } else if (info->bm_o && !(info->filter.flags & FILTER_NONZERO_BORDER)) {\n            ass_free_bitmap(info->bm_o);\n            info->bm_o = 0;\n        }\n        return;\n    }\n\n    // Create shadow and fix outline as needed\n    if (info->bm && info->bm_o && !(info->filter.flags & FILTER_BORDER_STYLE_3)) {\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm_o);\n        fix_outline(info->bm, info->bm_o);\n    } else if (info->bm_o && (info->filter.flags & FILTER_NONZERO_BORDER)) {\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm_o);\n    } else if (info->bm_o) {\n        info->bm_s = info->bm_o;\n        info->bm_o = 0;\n    } else if (info->bm)\n        info->bm_s = copy_bitmap(render_priv->engine, info->bm);\n\n    if (!info->bm_s)\n        return;\n\n    // Works right even for negative offsets\n    // '>>' rounds toward negative infinity, '&' returns correct remainder\n    info->bm_s->left += info->filter.shadow.x >> 6;\n    info->bm_s->top  += info->filter.shadow.y >> 6;\n    shift_bitmap(info->bm_s, info->filter.shadow.x & SUBPIXEL_MASK, info->filter.shadow.y & SUBPIXEL_MASK);\n}\n\n// Parse event text.\n// Fill render_priv->text_info.\nstatic int parse_events(ASS_Renderer *render_priv, ASS_Event *event)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    ASS_Drawing *drawing = NULL;\n    unsigned code;\n    char *p, *q;\n    int i;\n\n    p = event->Text;\n\n    // Event parsing.\n    while (1) {\n        // get next char, executing style override\n        // this affects render_context\n        code = 0;\n        while (*p) {\n            if ((*p == '{') && (q = strchr(p, '}'))) {\n                while (p < q)\n                    p = parse_tag(render_priv, p, q, 1.);\n                assert(*p == '}');\n                p++;\n            } else if (render_priv->state.drawing_scale) {\n                q = p;\n                if (*p == '{')\n                    q++;\n                while ((*q != '{') && (*q != 0))\n                    q++;\n                if (!drawing) {\n                    drawing = ass_drawing_new(render_priv->library,\n                                              render_priv->ftlibrary);\n                    if (!drawing)\n                        return 1;\n                }\n                ass_drawing_set_text(drawing, p, q - p);\n                code = 0xfffc; // object replacement character\n                p = q;\n                break;\n            } else {\n                code = get_next_char(render_priv, &p);\n                break;\n            }\n        }\n\n        if (code == 0)\n            break;\n\n        // face could have been changed in get_next_char\n        if (!render_priv->state.font) {\n            free_render_context(render_priv);\n            ass_drawing_free(drawing);\n            return 1;\n        }\n\n        if (text_info->length >= text_info->max_glyphs) {\n            // Raise maximum number of glyphs\n            text_info->max_glyphs *= 2;\n            text_info->glyphs =\n                realloc(text_info->glyphs,\n                        sizeof(GlyphInfo) * text_info->max_glyphs);\n        }\n\n        GlyphInfo *info = &text_info->glyphs[text_info->length];\n\n        // Clear current GlyphInfo\n        memset(info, 0, sizeof(GlyphInfo));\n\n        // Parse drawing\n        if (drawing && drawing->text) {\n            drawing->scale_x = render_priv->state.scale_x *\n                                     render_priv->font_scale;\n            drawing->scale_y = render_priv->state.scale_y *\n                                     render_priv->font_scale;\n            drawing->scale = render_priv->state.drawing_scale;\n            drawing->pbo = render_priv->state.pbo;\n            info->drawing = drawing;\n            drawing = NULL;\n        }\n\n        // Fill glyph information\n        info->symbol = code;\n        info->font = render_priv->state.font;\n        if (!info->drawing)\n            ass_cache_inc_ref(info->font);\n        for (i = 0; i < 4; ++i) {\n            uint32_t clr = render_priv->state.c[i];\n            // VSFilter compatibility: apply fade only when it's positive\n            if (render_priv->state.fade > 0)\n                change_alpha(&clr,\n                             mult_alpha(_a(clr), render_priv->state.fade), 1.);\n            info->c[i] = clr;\n        }\n\n        info->effect_type = render_priv->state.effect_type;\n        info->effect_timing = render_priv->state.effect_timing;\n        info->effect_skip_timing = render_priv->state.effect_skip_timing;\n        info->font_size =\n            render_priv->state.font_size * render_priv->font_scale;\n        info->be = render_priv->state.be;\n        info->blur = render_priv->state.blur;\n        info->shadow_x = render_priv->state.shadow_x;\n        info->shadow_y = render_priv->state.shadow_y;\n        info->scale_x = info->orig_scale_x = render_priv->state.scale_x;\n        info->scale_y = info->orig_scale_y = render_priv->state.scale_y;\n        info->border_style = render_priv->state.border_style;\n        info->border_x= render_priv->state.border_x;\n        info->border_y = render_priv->state.border_y;\n        info->hspacing = render_priv->state.hspacing;\n        info->bold = render_priv->state.bold;\n        info->italic = render_priv->state.italic;\n        info->flags = render_priv->state.flags;\n        info->frx = render_priv->state.frx;\n        info->fry = render_priv->state.fry;\n        info->frz = render_priv->state.frz;\n        info->fax = render_priv->state.fax;\n        info->fay = render_priv->state.fay;\n\n        if (!info->drawing)\n            fix_glyph_scaling(render_priv, info);\n\n        text_info->length++;\n\n        render_priv->state.effect_type = EF_NONE;\n        render_priv->state.effect_timing = 0;\n        render_priv->state.effect_skip_timing = 0;\n    }\n\n    ass_drawing_free(drawing);\n\n    return 0;\n}\n\n// Process render_priv->text_info and load glyph outlines.\nstatic void retrieve_glyphs(ASS_Renderer *render_priv)\n{\n    GlyphInfo *glyphs = render_priv->text_info.glyphs;\n    int i;\n\n    for (i = 0; i < render_priv->text_info.length; i++) {\n        GlyphInfo *info = glyphs + i;\n        while (info) {\n            get_outline_glyph(render_priv, info);\n            info = info->next;\n        }\n        info = glyphs + i;\n\n        // Add additional space after italic to non-italic style changes\n        if (i && glyphs[i - 1].italic && !info->italic) {\n            int back = i - 1;\n            GlyphInfo *og = &glyphs[back];\n            while (back && og->bbox.xMax - og->bbox.xMin == 0\n                    && og->italic)\n                og = &glyphs[--back];\n            if (og->bbox.xMax > og->cluster_advance.x)\n                og->cluster_advance.x = og->bbox.xMax;\n        }\n\n        // add horizontal letter spacing\n        info->cluster_advance.x += double_to_d6(info->hspacing *\n                render_priv->font_scale * info->orig_scale_x);\n\n        // add displacement for vertical shearing\n        info->cluster_advance.y += (info->fay / info->scale_x * info->scale_y) * info->cluster_advance.x;\n    }\n}\n\n// Preliminary layout (for line wrapping)\nstatic void preliminary_layout(ASS_Renderer *render_priv)\n{\n    FT_Vector pen;\n    int i;\n\n    pen.x = 0;\n    pen.y = 0;\n    for (i = 0; i < render_priv->text_info.length; i++) {\n        GlyphInfo *info = render_priv->text_info.glyphs + i;\n        FT_Vector cluster_pen = pen;\n        while (info) {\n            info->pos.x = cluster_pen.x;\n            info->pos.y = cluster_pen.y;\n\n            cluster_pen.x += info->advance.x;\n            cluster_pen.y += info->advance.y;\n\n            // fill bitmap hash\n            info->hash_key.type = BITMAP_OUTLINE;\n            fill_bitmap_hash(render_priv, info, &info->hash_key.u.outline);\n\n            info = info->next;\n        }\n        info = render_priv->text_info.glyphs + i;\n        pen.x += info->cluster_advance.x;\n        pen.y += info->cluster_advance.y;\n    }\n}\n\n// Reorder text into visual order\nstatic void reorder_text(ASS_Renderer *render_priv)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    FT_Vector pen;\n    int i;\n\n    FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv->shaper, text_info);\n    if (!cmap) {\n        ass_msg(render_priv->library, MSGL_ERR, \"Failed to reorder text\");\n        ass_shaper_cleanup(render_priv->shaper, text_info);\n        free_render_context(render_priv);\n        return;\n    }\n\n    // Reposition according to the map\n    pen.x = 0;\n    pen.y = 0;\n    int lineno = 1;\n    double last_pen_x = 0;\n    double last_fay = 0;\n    for (i = 0; i < text_info->length; i++) {\n        GlyphInfo *info = text_info->glyphs + cmap[i];\n        if (text_info->glyphs[i].linebreak) {\n            pen.y -= (last_fay / info->scale_x * info->scale_y) * (pen.x - last_pen_x);\n            last_pen_x = pen.x = 0;\n            pen.y += double_to_d6(text_info->lines[lineno-1].desc);\n            pen.y += double_to_d6(text_info->lines[lineno].asc);\n            pen.y += double_to_d6(render_priv->settings.line_spacing);\n            lineno++;\n        }\n        else if (last_fay != info->fay) {\n            pen.y -= (last_fay / info->scale_x * info->scale_y) * (pen.x - last_pen_x);\n            last_pen_x = pen.x;\n        }\n        last_fay = info->fay;\n        if (info->skip) continue;\n        FT_Vector cluster_pen = pen;\n        while (info) {\n            info->pos.x = info->offset.x + cluster_pen.x;\n            info->pos.y = info->offset.y + cluster_pen.y;\n            cluster_pen.x += info->advance.x;\n            cluster_pen.y += info->advance.y;\n            info = info->next;\n        }\n        info = text_info->glyphs + cmap[i];\n        pen.x += info->cluster_advance.x;\n        pen.y += info->cluster_advance.y;\n    }\n}\n\nstatic void align_lines(ASS_Renderer *render_priv, double max_text_width)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    GlyphInfo *glyphs = text_info->glyphs;\n    int i, j;\n    double width = 0;\n    int last_break = -1;\n    int halign = render_priv->state.alignment & 3;\n\n    if (render_priv->state.evt_type == EVENT_HSCROLL)\n        return;\n\n    for (i = 0; i <= text_info->length; ++i) {   // (text_info->length + 1) is the end of the last line\n        if ((i == text_info->length) || glyphs[i].linebreak) {\n            double shift = 0;\n            if (halign == HALIGN_LEFT) {    // left aligned, no action\n                shift = 0;\n            } else if (halign == HALIGN_RIGHT) {    // right aligned\n                shift = max_text_width - width;\n            } else if (halign == HALIGN_CENTER) {   // centered\n                shift = (max_text_width - width) / 2.0;\n            }\n            for (j = last_break + 1; j < i; ++j) {\n                GlyphInfo *info = glyphs + j;\n                while (info) {\n                    info->pos.x += double_to_d6(shift);\n                    info = info->next;\n                }\n            }\n            last_break = i - 1;\n            width = 0;\n        }\n        if (i < text_info->length && !glyphs[i].skip &&\n                glyphs[i].symbol != '\\n' && glyphs[i].symbol != 0) {\n            width += d6_to_double(glyphs[i].cluster_advance.x);\n        }\n    }\n}\n\nstatic void calculate_rotation_params(ASS_Renderer *render_priv, DBBox *bbox,\n                                      double device_x, double device_y)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    DVector center;\n    int i;\n\n    if (render_priv->state.have_origin) {\n        center.x = x2scr(render_priv, render_priv->state.org_x);\n        center.y = y2scr(render_priv, render_priv->state.org_y);\n    } else {\n        double bx = 0., by = 0.;\n        get_base_point(bbox, render_priv->state.alignment, &bx, &by);\n        center.x = device_x + bx;\n        center.y = device_y + by;\n    }\n\n    for (i = 0; i < text_info->length; ++i) {\n        GlyphInfo *info = text_info->glyphs + i;\n        while (info) {\n            OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n\n            if (key->frx || key->fry || key->frz || key->fax || key->fay) {\n                key->shift_x = info->pos.x + double_to_d6(device_x - center.x);\n                key->shift_y = -(info->pos.y + double_to_d6(device_y - center.y));\n            } else {\n                key->shift_x = 0;\n                key->shift_y = 0;\n            }\n            info = info->next;\n        }\n    }\n}\n\n\nstatic inline void rectangle_reset(Rectangle *rect)\n{\n    rect->x_min = rect->y_min = INT_MAX;\n    rect->x_max = rect->y_max = INT_MIN;\n}\n\nstatic inline void rectangle_combine(Rectangle *rect, const Bitmap *bm, int x, int y)\n{\n    rect->x_min = FFMIN(rect->x_min, x + bm->left);\n    rect->y_min = FFMIN(rect->y_min, y + bm->top);\n    rect->x_max = FFMAX(rect->x_max, x + bm->left + bm->w);\n    rect->y_max = FFMAX(rect->y_max, y + bm->top + bm->h);\n}\n\n// Convert glyphs to bitmaps, combine them, apply blur, generate shadows.\nstatic void render_and_combine_glyphs(ASS_Renderer *render_priv,\n                                      double device_x, double device_y)\n{\n    TextInfo *text_info = &render_priv->text_info;\n    int left = render_priv->settings.left_margin;\n    device_x = (device_x - left) * render_priv->font_scale_x + left;\n    unsigned nb_bitmaps = 0;\n    char linebreak = 0;\n    CombinedBitmapInfo *combined_info = text_info->combined_bitmaps;\n    CombinedBitmapInfo *current_info = NULL;\n    GlyphInfo *last_info = NULL;\n    for (int i = 0; i < text_info->length; i++) {\n        GlyphInfo *info = text_info->glyphs + i;\n        if (info->linebreak) linebreak = 1;\n        if (info->skip) {\n            for (; info; info = info->next)\n                ass_cache_dec_ref(info->hash_key.u.outline.outline);\n            continue;\n        }\n        for (; info; info = info->next) {\n            OutlineBitmapHashKey *key = &info->hash_key.u.outline;\n\n            info->pos.x = double_to_d6(device_x + d6_to_double(info->pos.x) * render_priv->font_scale_x);\n            info->pos.y = double_to_d6(device_y) + info->pos.y;\n            key->advance.x = info->pos.x & (SUBPIXEL_MASK & ~SUBPIXEL_ACCURACY);\n            key->advance.y = info->pos.y & (SUBPIXEL_MASK & ~SUBPIXEL_ACCURACY);\n            int x = info->pos.x >> 6, y = info->pos.y >> 6;\n            get_bitmap_glyph(render_priv, info);\n\n            if(linebreak || is_new_bm_run(info, last_info)) {\n                linebreak = 0;\n                last_info = NULL;\n                if (nb_bitmaps >= text_info->max_bitmaps) {\n                    size_t new_size = 2 * text_info->max_bitmaps;\n                    if (!ASS_REALLOC_ARRAY(text_info->combined_bitmaps, new_size)) {\n                        ass_cache_dec_ref(info->image);\n                        continue;\n                    }\n                    text_info->max_bitmaps = new_size;\n                    combined_info = text_info->combined_bitmaps;\n                }\n                current_info = &combined_info[nb_bitmaps];\n\n                memcpy(&current_info->c, &info->c, sizeof(info->c));\n                current_info->effect_type = info->effect_type;\n                current_info->effect_timing = info->effect_timing;\n                current_info->first_pos_x = info->bbox.xMax >> 6;\n\n                current_info->filter.flags = 0;\n                if (info->border_style == 3)\n                    current_info->filter.flags |= FILTER_BORDER_STYLE_3;\n                if (info->border_x || info->border_y)\n                    current_info->filter.flags |= FILTER_NONZERO_BORDER;\n                if (info->shadow_x || info->shadow_y)\n                    current_info->filter.flags |= FILTER_NONZERO_SHADOW;\n                // VSFilter compatibility: invisible fill and no border?\n                // In this case no shadow is supposed to be rendered.\n                if (info->border || (info->c[0] & 0xFF) != 0xFF)\n                    current_info->filter.flags |= FILTER_DRAW_SHADOW;\n\n                current_info->filter.be = info->be;\n                current_info->filter.blur = 2 * info->blur * render_priv->blur_scale;\n                current_info->filter.shadow.x = double_to_d6(info->shadow_x * render_priv->border_scale);\n                current_info->filter.shadow.y = double_to_d6(info->shadow_y * render_priv->border_scale);\n\n                current_info->x = current_info->y = INT_MAX;\n                rectangle_reset(&current_info->rect);\n                rectangle_reset(&current_info->rect_o);\n                current_info->n_bm = current_info->n_bm_o = 0;\n                current_info->bm = current_info->bm_o = current_info->bm_s = NULL;\n                current_info->image = NULL;\n\n                current_info->bitmap_count = current_info->max_bitmap_count = 0;\n                current_info->bitmaps = malloc(MAX_SUB_BITMAPS_INITIAL * sizeof(BitmapRef));\n                if (!current_info->bitmaps) {\n                    ass_cache_dec_ref(info->image);\n                    continue;\n                }\n                current_info->max_bitmap_count = MAX_SUB_BITMAPS_INITIAL;\n\n                nb_bitmaps++;\n            }\n            last_info = info;\n\n            if (!info->image || !current_info) {\n                ass_cache_dec_ref(info->image);\n                continue;\n            }\n\n            if (current_info->bitmap_count >= current_info->max_bitmap_count) {\n                size_t new_size = 2 * current_info->max_bitmap_count;\n                if (!ASS_REALLOC_ARRAY(current_info->bitmaps, new_size)) {\n                    ass_cache_dec_ref(info->image);\n                    continue;\n                }\n                current_info->max_bitmap_count = new_size;\n            }\n            current_info->bitmaps[current_info->bitmap_count].image = info->image;\n            current_info->bitmaps[current_info->bitmap_count].x = x;\n            current_info->bitmaps[current_info->bitmap_count].y = y;\n            current_info->bitmap_count++;\n\n            current_info->x = FFMIN(current_info->x, x);\n            current_info->y = FFMIN(current_info->y, y);\n            if (info->image->bm) {\n                rectangle_combine(&current_info->rect, info->image->bm, x, y);\n                current_info->n_bm++;\n            }\n            if (info->image->bm_o) {\n                rectangle_combine(&current_info->rect_o, info->image->bm_o, x, y);\n                current_info->n_bm_o++;\n            }\n        }\n    }\n\n    for (int i = 0; i < nb_bitmaps; i++) {\n        CombinedBitmapInfo *info = &combined_info[i];\n        for (int j = 0; j < info->bitmap_count; j++) {\n            info->bitmaps[j].x -= info->x;\n            info->bitmaps[j].y -= info->y;\n        }\n\n        CompositeHashKey hk;\n        CompositeHashValue *hv;\n        fill_composite_hash(&hk, info);\n        if (ass_cache_get(render_priv->cache.composite_cache, &hk, &hv)) {\n            info->bm = hv->bm;\n            info->bm_o = hv->bm_o;\n            info->bm_s = hv->bm_s;\n            info->image = hv;\n            continue;\n        }\n        if (!hv)\n            continue;\n\n        int bord = be_padding(info->filter.be);\n        if (!bord && info->n_bm == 1) {\n            for (int j = 0; j < info->bitmap_count; j++) {\n                if (!info->bitmaps[j].image->bm)\n                    continue;\n                info->bm = copy_bitmap(render_priv->engine, info->bitmaps[j].image->bm);\n                if (info->bm) {\n                    info->bm->left += info->bitmaps[j].x;\n                    info->bm->top  += info->bitmaps[j].y;\n                }\n                break;\n            }\n        } else if (info->n_bm) {\n            info->bm = alloc_bitmap(render_priv->engine,\n                                    info->rect.x_max - info->rect.x_min + 2 * bord,\n                                    info->rect.y_max - info->rect.y_min + 2 * bord, true);\n            Bitmap *dst = info->bm;\n            if (dst) {\n                dst->left = info->rect.x_min - info->x - bord;\n                dst->top  = info->rect.y_min - info->y - bord;\n                for (int j = 0; j < info->bitmap_count; j++) {\n                    Bitmap *src = info->bitmaps[j].image->bm;\n                    if (!src)\n                        continue;\n                    int x = info->bitmaps[j].x + src->left - dst->left;\n                    int y = info->bitmaps[j].y + src->top  - dst->top;\n                    assert(x >= 0 && x + src->w <= dst->w);\n                    assert(y >= 0 && y + src->h <= dst->h);\n                    unsigned char *buf = dst->buffer + y * dst->stride + x;\n                    render_priv->engine->add_bitmaps(buf, dst->stride,\n                                                     src->buffer, src->stride,\n                                                     src->h, src->w);\n                }\n            }\n        }\n        if (!bord && info->n_bm_o == 1) {\n            for (int j = 0; j < info->bitmap_count; j++) {\n                if (!info->bitmaps[j].image->bm_o)\n                    continue;\n                info->bm_o = copy_bitmap(render_priv->engine, info->bitmaps[j].image->bm_o);\n                if (info->bm_o) {\n                    info->bm_o->left += info->bitmaps[j].x;\n                    info->bm_o->top  += info->bitmaps[j].y;\n                }\n                break;\n            }\n        } else if (info->n_bm_o) {\n            info->bm_o = alloc_bitmap(render_priv->engine,\n                                      info->rect_o.x_max - info->rect_o.x_min + 2 * bord,\n                                      info->rect_o.y_max - info->rect_o.y_min + 2 * bord,\n                                      true);\n            Bitmap *dst = info->bm_o;\n            if (dst) {\n                dst->left = info->rect_o.x_min - info->x - bord;\n                dst->top  = info->rect_o.y_min - info->y - bord;\n                for (int j = 0; j < info->bitmap_count; j++) {\n                    Bitmap *src = info->bitmaps[j].image->bm_o;\n                    if (!src)\n                        continue;\n                    int x = info->bitmaps[j].x + src->left - dst->left;\n                    int y = info->bitmaps[j].y + src->top  - dst->top;\n                    assert(x >= 0 && x + src->w <= dst->w);\n                    assert(y >= 0 && y + src->h <= dst->h);\n                    unsigned char *buf = dst->buffer + y * dst->stride + x;\n                    render_priv->engine->add_bitmaps(buf, dst->stride,\n                                                     src->buffer, src->stride,\n                                                     src->h, src->w);\n                }\n            }\n        }\n\n        if (info->bm || info->bm_o) {\n            ass_synth_blur(render_priv->engine, info->filter.flags & FILTER_BORDER_STYLE_3,\n                           info->filter.be, info->filter.blur, info->bm, info->bm_o);\n            if (info->filter.flags & FILTER_DRAW_SHADOW)\n                make_shadow_bitmap(info, render_priv);\n        }\n\n        hv->bm = info->bm;\n        hv->bm_o = info->bm_o;\n        hv->bm_s = info->bm_s;\n        ass_cache_commit(hv, bitmap_size(hv->bm) +\n                         bitmap_size(hv->bm_o) + bitmap_size(hv->bm_s) +\n                         sizeof(CompositeHashKey) + sizeof(CompositeHashValue));\n        info->image = hv;\n    }\n\n    text_info->n_bitmaps = nb_bitmaps;\n}\n\nstatic void add_background(ASS_Renderer *render_priv, EventImages *event_images)\n{\n    void *nbuffer = ass_aligned_alloc(1, event_images->width * event_images->height, false);\n    if (!nbuffer)\n        return;\n    memset(nbuffer, 0xFF, event_images->width * event_images->height);\n    ASS_Image *img = my_draw_bitmap(nbuffer, event_images->width,\n                                    event_images->height,\n                                    event_images->width,\n                                    event_images->left,\n                                    event_images->top,\n                                    render_priv->state.c[3], NULL);\n    if (img) {\n        img->next = event_images->imgs;\n        event_images->imgs = img;\n    }\n}\n\n/**\n * \\brief Main ass rendering function, glues everything together\n * \\param event event to render\n * \\param event_images struct containing resulting images, will also be initialized\n * Process event, appending resulting ASS_Image's to images_root.\n */\nstatic int\nass_render_event(ASS_Renderer *render_priv, ASS_Event *event,\n                 EventImages *event_images)\n{\n    DBBox bbox;\n    int MarginL, MarginR, MarginV;\n    int valign;\n    double device_x = 0;\n    double device_y = 0;\n    TextInfo *text_info = &render_priv->text_info;\n\n    if (event->Style >= render_priv->track->n_styles) {\n        ass_msg(render_priv->library, MSGL_WARN, \"No style found\");\n        return 1;\n    }\n    if (!event->Text) {\n        ass_msg(render_priv->library, MSGL_WARN, \"Empty event\");\n        return 1;\n    }\n\n    free_render_context(render_priv);\n    init_render_context(render_priv, event);\n\n    if (parse_events(render_priv, event))\n        return 1;\n\n    if (text_info->length == 0) {\n        // no valid symbols in the event; this can be smth like {comment}\n        free_render_context(render_priv);\n        return 1;\n    }\n\n    // Find shape runs and shape text\n    ass_shaper_set_base_direction(render_priv->shaper,\n            resolve_base_direction(render_priv->state.font_encoding));\n    ass_shaper_find_runs(render_priv->shaper, render_priv, text_info->glyphs,\n            text_info->length);\n    if (ass_shaper_shape(render_priv->shaper, text_info) < 0) {\n        ass_msg(render_priv->library, MSGL_ERR, \"Failed to shape text\");\n        free_render_context(render_priv);\n        return 1;\n    }\n\n    retrieve_glyphs(render_priv);\n\n    preliminary_layout(render_priv);\n\n    // depends on glyph x coordinates being monotonous, so it should be done before line wrap\n    process_karaoke_effects(render_priv);\n\n    valign = render_priv->state.alignment & 12;\n\n    MarginL =\n        (event->MarginL) ? event->MarginL : render_priv->state.style->MarginL;\n    MarginR =\n        (event->MarginR) ? event->MarginR : render_priv->state.style->MarginR;\n    MarginV =\n        (event->MarginV) ? event->MarginV : render_priv->state.style->MarginV;\n\n    // calculate max length of a line\n    double max_text_width =\n        x2scr(render_priv, render_priv->track->PlayResX - MarginR) -\n        x2scr(render_priv, MarginL);\n\n    // wrap lines\n    if (render_priv->state.evt_type != EVENT_HSCROLL) {\n        // rearrange text in several lines\n        wrap_lines_smart(render_priv, max_text_width);\n    } else {\n        // no breaking or wrapping, everything in a single line\n        text_info->lines[0].offset = 0;\n        text_info->lines[0].len = text_info->length;\n        text_info->n_lines = 1;\n        measure_text(render_priv);\n    }\n\n    reorder_text(render_priv);\n\n    align_lines(render_priv, max_text_width);\n\n    // determing text bounding box\n    compute_string_bbox(text_info, &bbox);\n\n    // determine device coordinates for text\n\n    // x coordinate for everything except positioned events\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_VSCROLL) {\n        device_x = x2scr(render_priv, MarginL);\n    } else if (render_priv->state.evt_type == EVENT_HSCROLL) {\n        if (render_priv->state.scroll_direction == SCROLL_RL)\n            device_x =\n                x2scr(render_priv,\n                      render_priv->track->PlayResX -\n                      render_priv->state.scroll_shift);\n        else if (render_priv->state.scroll_direction == SCROLL_LR)\n            device_x =\n                x2scr(render_priv,\n                      render_priv->state.scroll_shift) - (bbox.xMax -\n                                                          bbox.xMin);\n    }\n\n    // y coordinate for everything except positioned events\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_HSCROLL) {\n        if (valign == VALIGN_TOP) {     // toptitle\n            device_y =\n                y2scr_top(render_priv,\n                          MarginV) + text_info->lines[0].asc;\n        } else if (valign == VALIGN_CENTER) {   // midtitle\n            double scr_y =\n                y2scr(render_priv, render_priv->track->PlayResY / 2.0);\n            device_y = scr_y - (bbox.yMax + bbox.yMin) / 2.0;\n        } else {                // subtitle\n            double line_pos = render_priv->state.explicit ?\n                0 : render_priv->settings.line_position;\n            double scr_top, scr_bottom, scr_y0;\n            if (valign != VALIGN_SUB)\n                ass_msg(render_priv->library, MSGL_V,\n                       \"Invalid valign, assuming 0 (subtitle)\");\n            scr_bottom =\n                y2scr_sub(render_priv,\n                          render_priv->track->PlayResY - MarginV);\n            scr_top = y2scr_top(render_priv, 0); //xxx not always 0?\n            device_y = scr_bottom + (scr_top - scr_bottom) * line_pos / 100.0;\n            device_y -= text_info->height;\n            device_y += text_info->lines[0].asc;\n            // clip to top to avoid confusion if line_position is very high,\n            // turning the subtitle into a toptitle\n            // also, don't change behavior if line_position is not used\n            scr_y0 = scr_top + text_info->lines[0].asc;\n            if (device_y < scr_y0 && line_pos > 0) {\n                device_y = scr_y0;\n            }\n        }\n    } else if (render_priv->state.evt_type == EVENT_VSCROLL) {\n        if (render_priv->state.scroll_direction == SCROLL_TB)\n            device_y =\n                y2scr(render_priv,\n                      render_priv->state.clip_y0 +\n                      render_priv->state.scroll_shift) - (bbox.yMax -\n                                                          bbox.yMin);\n        else if (render_priv->state.scroll_direction == SCROLL_BT)\n            device_y =\n                y2scr(render_priv,\n                      render_priv->state.clip_y1 -\n                      render_priv->state.scroll_shift);\n    }\n\n    // positioned events are totally different\n    if (render_priv->state.evt_type == EVENT_POSITIONED) {\n        double base_x = 0;\n        double base_y = 0;\n        get_base_point(&bbox, render_priv->state.alignment, &base_x, &base_y);\n        device_x =\n            x2scr_pos(render_priv, render_priv->state.pos_x) - base_x;\n        device_y =\n            y2scr_pos(render_priv, render_priv->state.pos_y) - base_y;\n    }\n\n    // fix clip coordinates (they depend on alignment)\n    if (render_priv->state.evt_type == EVENT_NORMAL ||\n        render_priv->state.evt_type == EVENT_HSCROLL ||\n        render_priv->state.evt_type == EVENT_VSCROLL) {\n        render_priv->state.clip_x0 =\n            x2scr_scaled(render_priv, render_priv->state.clip_x0);\n        render_priv->state.clip_x1 =\n            x2scr_scaled(render_priv, render_priv->state.clip_x1);\n        if (valign == VALIGN_TOP) {\n            render_priv->state.clip_y0 =\n                y2scr_top(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr_top(render_priv, render_priv->state.clip_y1);\n        } else if (valign == VALIGN_CENTER) {\n            render_priv->state.clip_y0 =\n                y2scr(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr(render_priv, render_priv->state.clip_y1);\n        } else if (valign == VALIGN_SUB) {\n            render_priv->state.clip_y0 =\n                y2scr_sub(render_priv, render_priv->state.clip_y0);\n            render_priv->state.clip_y1 =\n                y2scr_sub(render_priv, render_priv->state.clip_y1);\n        }\n    } else if (render_priv->state.evt_type == EVENT_POSITIONED) {\n        render_priv->state.clip_x0 =\n            x2scr_pos_scaled(render_priv, render_priv->state.clip_x0);\n        render_priv->state.clip_x1 =\n            x2scr_pos_scaled(render_priv, render_priv->state.clip_x1);\n        render_priv->state.clip_y0 =\n            y2scr_pos(render_priv, render_priv->state.clip_y0);\n        render_priv->state.clip_y1 =\n            y2scr_pos(render_priv, render_priv->state.clip_y1);\n    }\n\n    if (render_priv->state.explicit) {\n        // we still need to clip against screen boundaries\n        double zx = x2scr_pos_scaled(render_priv, 0);\n        double zy = y2scr_pos(render_priv, 0);\n        double sx = x2scr_pos_scaled(render_priv, render_priv->track->PlayResX);\n        double sy = y2scr_pos(render_priv, render_priv->track->PlayResY);\n\n        render_priv->state.clip_x0 = render_priv->state.clip_x0 < zx ? zx : render_priv->state.clip_x0;\n        render_priv->state.clip_y0 = render_priv->state.clip_y0 < zy ? zy : render_priv->state.clip_y0;\n        render_priv->state.clip_x1 = render_priv->state.clip_x1 > sx ? sx : render_priv->state.clip_x1;\n        render_priv->state.clip_y1 = render_priv->state.clip_y1 > sy ? sy : render_priv->state.clip_y1;\n    }\n\n    calculate_rotation_params(render_priv, &bbox, device_x, device_y);\n\n    render_and_combine_glyphs(render_priv, device_x, device_y);\n\n    memset(event_images, 0, sizeof(*event_images));\n    event_images->top = device_y - text_info->lines[0].asc;\n    event_images->height = text_info->height;\n    event_images->left =\n        (device_x + bbox.xMin * render_priv->font_scale_x) + 0.5;\n    event_images->width =\n        (bbox.xMax - bbox.xMin) * render_priv->font_scale_x + 0.5;\n    event_images->detect_collisions = render_priv->state.detect_collisions;\n    event_images->shift_direction = (valign == VALIGN_TOP) ? 1 : -1;\n    event_images->event = event;\n    event_images->imgs = render_text(render_priv);\n\n    if (render_priv->state.border_style == 4)\n        add_background(render_priv, event_images);\n\n    ass_shaper_cleanup(render_priv->shaper, text_info);\n    free_render_context(render_priv);\n\n    return 0;\n}\n\n/**\n * \\brief Check cache limits and reset cache if they are exceeded\n */\nstatic void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)\n{\n    ass_cache_cut(cache->composite_cache, cache->composite_max_size);\n    ass_cache_cut(cache->bitmap_cache, cache->bitmap_max_size);\n    ass_cache_cut(cache->outline_cache, cache->glyph_max);\n}\n\n/**\n * \\brief Start a new frame\n */\nstatic int\nass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,\n                long long now)\n{\n    ASS_Settings *settings_priv = &render_priv->settings;\n\n    if (!render_priv->settings.frame_width\n        && !render_priv->settings.frame_height)\n        return 1;               // library not initialized\n\n    if (!render_priv->fontselect)\n        return 1;\n\n    if (render_priv->library != track->library)\n        return 1;\n\n    if (track->n_events == 0)\n        return 1;               // nothing to do\n\n    render_priv->track = track;\n    render_priv->time = now;\n\n    ass_lazy_track_init(render_priv->library, render_priv->track);\n\n    ass_shaper_set_kerning(render_priv->shaper, track->Kerning);\n    ass_shaper_set_language(render_priv->shaper, track->Language);\n    ass_shaper_set_level(render_priv->shaper, render_priv->settings.shaper);\n\n    // PAR correction\n    double par = render_priv->settings.par;\n    if (par == 0.) {\n        if (settings_priv->frame_width && settings_priv->frame_height &&\n            settings_priv->storage_width && settings_priv->storage_height) {\n            double dar = ((double) settings_priv->frame_width) /\n                         settings_priv->frame_height;\n            double sar = ((double) settings_priv->storage_width) /\n                         settings_priv->storage_height;\n            par = sar / dar;\n        } else\n            par = 1.0;\n    }\n    render_priv->font_scale_x = par;\n\n    render_priv->prev_images_root = render_priv->images_root;\n    render_priv->images_root = NULL;\n\n    check_cache_limits(render_priv, &render_priv->cache);\n\n    return 0;\n}\n\nstatic int cmp_event_layer(const void *p1, const void *p2)\n{\n    ASS_Event *e1 = ((EventImages *) p1)->event;\n    ASS_Event *e2 = ((EventImages *) p2)->event;\n    if (e1->Layer < e2->Layer)\n        return -1;\n    if (e1->Layer > e2->Layer)\n        return 1;\n    if (e1->ReadOrder < e2->ReadOrder)\n        return -1;\n    if (e1->ReadOrder > e2->ReadOrder)\n        return 1;\n    return 0;\n}\n\nstatic ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,\n                                       ASS_Event *event)\n{\n    if (!event->render_priv) {\n        event->render_priv = calloc(1, sizeof(ASS_RenderPriv));\n        if (!event->render_priv)\n            return NULL;\n    }\n    if (render_priv->render_id != event->render_priv->render_id) {\n        memset(event->render_priv, 0, sizeof(ASS_RenderPriv));\n        event->render_priv->render_id = render_priv->render_id;\n    }\n\n    return event->render_priv;\n}\n\nstatic int overlap(Segment *s1, Segment *s2)\n{\n    if (s1->a >= s2->b || s2->a >= s1->b ||\n        s1->ha >= s2->hb || s2->ha >= s1->hb)\n        return 0;\n    return 1;\n}\n\nstatic int cmp_segment(const void *p1, const void *p2)\n{\n    return ((Segment *) p1)->a - ((Segment *) p2)->a;\n}\n\nstatic void\nshift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)\n{\n    ASS_Image *cur = ei->imgs;\n    while (cur) {\n        cur->dst_y += shift;\n        // clip top and bottom\n        if (cur->dst_y < 0) {\n            int clip = -cur->dst_y;\n            cur->h -= clip;\n            cur->bitmap += clip * cur->stride;\n            cur->dst_y = 0;\n        }\n        if (cur->dst_y + cur->h >= render_priv->height) {\n            int clip = cur->dst_y + cur->h - render_priv->height;\n            cur->h -= clip;\n        }\n        if (cur->h <= 0) {\n            cur->h = 0;\n            cur->dst_y = 0;\n        }\n        cur = cur->next;\n    }\n    ei->top += shift;\n}\n\n// dir: 1 - move down\n//      -1 - move up\nstatic int fit_segment(Segment *s, Segment *fixed, int *cnt, int dir)\n{\n    int i;\n    int shift = 0;\n\n    if (dir == 1)               // move down\n        for (i = 0; i < *cnt; ++i) {\n            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||\n                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)\n                continue;\n            shift = fixed[i].b - s->a;\n    } else                      // dir == -1, move up\n        for (i = *cnt - 1; i >= 0; --i) {\n            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||\n                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)\n                continue;\n            shift = fixed[i].a - s->b;\n        }\n\n    fixed[*cnt].a = s->a + shift;\n    fixed[*cnt].b = s->b + shift;\n    fixed[*cnt].ha = s->ha;\n    fixed[*cnt].hb = s->hb;\n    (*cnt)++;\n    qsort(fixed, *cnt, sizeof(Segment), cmp_segment);\n\n    return shift;\n}\n\nstatic void\nfix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)\n{\n    Segment *used = ass_realloc_array(NULL, cnt, sizeof(*used));\n    int cnt_used = 0;\n    int i, j;\n\n    if (!used)\n        return;\n\n    // fill used[] with fixed events\n    for (i = 0; i < cnt; ++i) {\n        ASS_RenderPriv *priv;\n        if (!imgs[i].detect_collisions)\n            continue;\n        priv = get_render_priv(render_priv, imgs[i].event);\n        if (priv && priv->height > 0) { // it's a fixed event\n            Segment s;\n            s.a = priv->top;\n            s.b = priv->top + priv->height;\n            s.ha = priv->left;\n            s.hb = priv->left + priv->width;\n            if (priv->height != imgs[i].height) {       // no, it's not\n                ass_msg(render_priv->library, MSGL_WARN,\n                        \"Event height has changed\");\n                priv->top = 0;\n                priv->height = 0;\n                priv->left = 0;\n                priv->width = 0;\n            }\n            for (j = 0; j < cnt_used; ++j)\n                if (overlap(&s, used + j)) {    // no, it's not\n                    priv->top = 0;\n                    priv->height = 0;\n                    priv->left = 0;\n                    priv->width = 0;\n                }\n            if (priv->height > 0) {     // still a fixed event\n                used[cnt_used].a = priv->top;\n                used[cnt_used].b = priv->top + priv->height;\n                used[cnt_used].ha = priv->left;\n                used[cnt_used].hb = priv->left + priv->width;\n                cnt_used++;\n                shift_event(render_priv, imgs + i, priv->top - imgs[i].top);\n            }\n        }\n    }\n    qsort(used, cnt_used, sizeof(Segment), cmp_segment);\n\n    // try to fit other events in free spaces\n    for (i = 0; i < cnt; ++i) {\n        ASS_RenderPriv *priv;\n        if (!imgs[i].detect_collisions)\n            continue;\n        priv = get_render_priv(render_priv, imgs[i].event);\n        if (priv && priv->height == 0) {        // not a fixed event\n            int shift;\n            Segment s;\n            s.a = imgs[i].top;\n            s.b = imgs[i].top + imgs[i].height;\n            s.ha = imgs[i].left;\n            s.hb = imgs[i].left + imgs[i].width;\n            shift = fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);\n            if (shift)\n                shift_event(render_priv, imgs + i, shift);\n            // make it fixed\n            priv->top = imgs[i].top;\n            priv->height = imgs[i].height;\n            priv->left = imgs[i].left;\n            priv->width = imgs[i].width;\n        }\n\n    }\n\n    free(used);\n}\n\n/**\n * \\brief compare two images\n * \\param i1 first image\n * \\param i2 second image\n * \\return 0 if identical, 1 if different positions, 2 if different content\n */\nstatic int ass_image_compare(ASS_Image *i1, ASS_Image *i2)\n{\n    if (i1->w != i2->w)\n        return 2;\n    if (i1->h != i2->h)\n        return 2;\n    if (i1->stride != i2->stride)\n        return 2;\n    if (i1->color != i2->color)\n        return 2;\n    if (i1->bitmap != i2->bitmap)\n        return 2;\n    if (i1->dst_x != i2->dst_x)\n        return 1;\n    if (i1->dst_y != i2->dst_y)\n        return 1;\n    return 0;\n}\n\n/**\n * \\brief compare current and previous image list\n * \\param priv library handle\n * \\return 0 if identical, 1 if different positions, 2 if different content\n */\nstatic int ass_detect_change(ASS_Renderer *priv)\n{\n    ASS_Image *img, *img2;\n    int diff;\n\n    if (priv->state.has_clips)\n        return 2;\n\n    img = priv->prev_images_root;\n    img2 = priv->images_root;\n    diff = 0;\n    while (img && diff < 2) {\n        ASS_Image *next, *next2;\n        next = img->next;\n        if (img2) {\n            int d = ass_image_compare(img, img2);\n            if (d > diff)\n                diff = d;\n            next2 = img2->next;\n        } else {\n            // previous list is shorter\n            diff = 2;\n            break;\n        }\n        img = next;\n        img2 = next2;\n    }\n\n    // is the previous list longer?\n    if (img2)\n        diff = 2;\n\n    return diff;\n}\n\n/**\n * \\brief render a frame\n * \\param priv library handle\n * \\param track track\n * \\param now current video timestamp (ms)\n * \\param detect_change a value describing how the new images differ from the previous ones will be written here:\n *        0 if identical, 1 if different positions, 2 if different content.\n *        Can be NULL, in that case no detection is performed.\n */\nASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,\n                            long long now, int *detect_change)\n{\n    int i, cnt, rc;\n    EventImages *last;\n    ASS_Image **tail;\n\n    // init frame\n    rc = ass_start_frame(priv, track, now);\n    if (rc != 0) {\n        if (detect_change) {\n            *detect_change = 2;\n        }\n        return NULL;\n    }\n\n    // render events separately\n    cnt = 0;\n    for (i = 0; i < track->n_events; ++i) {\n        ASS_Event *event = track->events + i;\n        if ((event->Start <= now)\n            && (now < (event->Start + event->Duration))) {\n            if (cnt >= priv->eimg_size) {\n                priv->eimg_size += 100;\n                priv->eimg =\n                    realloc(priv->eimg,\n                            priv->eimg_size * sizeof(EventImages));\n            }\n            rc = ass_render_event(priv, event, priv->eimg + cnt);\n            if (!rc)\n                ++cnt;\n        }\n    }\n\n    // sort by layer\n    qsort(priv->eimg, cnt, sizeof(EventImages), cmp_event_layer);\n\n    // call fix_collisions for each group of events with the same layer\n    last = priv->eimg;\n    for (i = 1; i < cnt; ++i)\n        if (last->event->Layer != priv->eimg[i].event->Layer) {\n            fix_collisions(priv, last, priv->eimg + i - last);\n            last = priv->eimg + i;\n        }\n    if (cnt > 0)\n        fix_collisions(priv, last, priv->eimg + cnt - last);\n\n    // concat lists\n    tail = &priv->images_root;\n    for (i = 0; i < cnt; ++i) {\n        ASS_Image *cur = priv->eimg[i].imgs;\n        while (cur) {\n            *tail = cur;\n            tail = &cur->next;\n            cur = cur->next;\n        }\n    }\n    ass_frame_ref(priv->images_root);\n\n    if (detect_change)\n        *detect_change = ass_detect_change(priv);\n\n    // free the previous image list\n    ass_frame_unref(priv->prev_images_root);\n    priv->prev_images_root = NULL;\n\n    return priv->images_root;\n}\n\n/**\n * \\brief Add reference to a frame image list.\n * \\param image_list image list returned by ass_render_frame()\n */\nvoid ass_frame_ref(ASS_Image *img)\n{\n    if (!img)\n        return;\n    ((ASS_ImagePriv *) img)->ref_count++;\n}\n\n/**\n * \\brief Release reference to a frame image list.\n * \\param image_list image list returned by ass_render_frame()\n */\nvoid ass_frame_unref(ASS_Image *img)\n{\n    if (!img || --((ASS_ImagePriv *) img)->ref_count)\n        return;\n    do {\n        ASS_ImagePriv *priv = (ASS_ImagePriv *) img;\n        img = img->next;\n        if (priv->source)\n            ass_cache_dec_ref(priv->source);\n        else\n            ass_aligned_free(priv->result.bitmap);\n        free(priv);\n    } while (img);\n}\n"], "filenames": ["libass/ass_render.c"], "buggy_code_start_loc": [1611], "buggy_code_end_loc": [1612], "fixing_code_start_loc": [1611], "fixing_code_end_loc": [1615], "type": "CWE-125", "message": "The wrap_lines_smart function in ass_render.c in libass before 0.13.4 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors, related to \"0/3 line wrapping equalization.\"", "other": {"cve": {"id": "CVE-2016-7969", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-03T16:59:00.560", "lastModified": "2020-10-14T18:16:17.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The wrap_lines_smart function in ass_render.c in libass before 0.13.4 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors, related to \"0/3 line wrapping equalization.\""}, {"lang": "es", "value": "La funci\u00f3n wrap_lines_smart en ass_render.c en libass en versiones anteriores a 0.13.4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de vectores no especificados, relacionados con \"0/3 ecualizaci\u00f3n de envoltura de l\u00ednea\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libass_project:libass:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.13.3", "matchCriteriaId": "4CBD3C82-6F32-4279-84C4-88E8F0AA8CD4"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-12/msg00068.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/05/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93358", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1381960", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libass/libass/commit/f4f48950788b91c6a30029cc28a240b834713ea7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/libass/libass/releases/tag/0.13.4", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KW6DNERYHPI5Y6SQYU3XKTVSCOWMIHUC/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R7JJ2SGVOX6UQQIRMVC3QACJLKHE2PYN/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VUOUOK3VULMMZTNSCRFCNPDAPDWAVK7X/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-25", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/libass/libass/commit/f4f48950788b91c6a30029cc28a240b834713ea7"}}