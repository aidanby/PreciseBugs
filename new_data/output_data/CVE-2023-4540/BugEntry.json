{"buggy_code": ["local cqueues = require \"cqueues\"\nlocal monotime = cqueues.monotime\nlocal cc = require \"cqueues.condition\"\nlocal ce = require \"cqueues.errno\"\nlocal new_fifo = require \"fifo\"\nlocal lpeg = require \"lpeg\"\nlocal http_patts = require \"lpeg_patterns.http\"\nlocal new_headers = require \"http.headers\".new\nlocal reason_phrases = require \"http.h1_reason_phrases\"\nlocal stream_common = require \"http.stream_common\"\nlocal util = require \"http.util\"\nlocal has_zlib, zlib = pcall(require, \"http.zlib\")\n\n--[[ Maximum amount of data to read during shutdown before giving up on a clean stream shutdown\n500KB seems is a round number that is:\n  - larger than most bandwidth-delay products\n  - larger than most dynamically generated http documents]]\nlocal clean_shutdown_limit = 500*1024\n\nlocal EOF = lpeg.P(-1)\nlocal Connection = lpeg.Ct(http_patts.Connection) * EOF\nlocal Content_Encoding = lpeg.Ct(http_patts.Content_Encoding) * EOF\nlocal Transfer_Encoding = lpeg.Ct(http_patts.Transfer_Encoding) * EOF\nlocal TE = lpeg.Ct(http_patts.TE) * EOF\n\nlocal function has(list, val)\n\tif list then\n\t\tfor i=1, #list do\n\t\t\tif list[i] == val then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\n\nlocal function has_any(list, val, ...)\n\tif has(list, val) then\n\t\treturn true\n\telseif (...) then\n\t\treturn has(list, ...)\n\telse\n\t\treturn false\n\tend\nend\n\nlocal stream_methods = {\n\tuse_zlib = has_zlib;\n\tmax_header_lines = 100;\n}\nfor k,v in pairs(stream_common.methods) do\n\tstream_methods[k] = v\nend\nlocal stream_mt = {\n\t__name = \"http.h1_stream\";\n\t__index = stream_methods;\n}\n\nfunction stream_mt:__tostring()\n\treturn string.format(\"http.h1_stream{connection=%s;state=%q}\",\n\t\ttostring(self.connection), self.state)\nend\n\nlocal function new_stream(connection)\n\tlocal self = setmetatable({\n\t\tconnection = connection;\n\t\ttype = connection.type;\n\n\t\tstate = \"idle\";\n\t\tstats_sent = 0;\n\t\tstats_recv = 0;\n\n\t\tpipeline_cond = cc.new(); -- signalled when stream reaches front of pipeline\n\n\t\treq_method = nil; -- string\n\t\tpeer_version = nil; -- 1.0 or 1.1\n\t\thas_main_headers = false;\n\t\theaders_in_progress = nil;\n\t\theaders_fifo = new_fifo();\n\t\theaders_cond = cc.new();\n\t\tchunk_fifo = new_fifo();\n\t\tchunk_cond = cc.new();\n\t\tbody_write_type = nil; -- \"closed\", \"chunked\", \"length\" or \"missing\"\n\t\tbody_write_left = nil; -- integer: only set when body_write_type == \"length\"\n\t\tbody_write_deflate_encoding = nil;\n\t\tbody_write_deflate = nil; -- nil or stateful deflate closure\n\t\tbody_read_type = nil;\n\t\tbody_read_inflate = nil;\n\t\tclose_when_done = nil; -- boolean\n\t}, stream_mt)\n\treturn self\nend\n\nlocal valid_states = {\n\t[\"idle\"] = 1; -- initial\n\t[\"open\"] = 2; -- have sent or received headers; haven't sent body yet\n\t[\"half closed (local)\"] = 3; -- have sent whole body\n\t[\"half closed (remote)\"] = 3; -- have received whole body\n\t[\"closed\"] = 4; -- complete\n}\nfunction stream_methods:set_state(new)\n\tlocal new_order = assert(valid_states[new])\n\tlocal old = self.state\n\tif new_order <= valid_states[old] then\n\t\terror(\"invalid state progression ('\"..old..\"' to '\"..new..\"')\")\n\tend\n\tlocal have_lock, want_no_lock\n\tlocal blocking_pipeline, notify_pipeline\n\tif self.type == \"server\" then\n\t\t-- If we have just finished reading the request then remove our read lock\n\t\thave_lock = old == \"idle\" or old == \"open\" or old == \"half closed (local)\"\n\t\twant_no_lock = new == \"half closed (remote)\" or new == \"closed\"\n\t\t-- If we have just finished writing the response\n\t\tblocking_pipeline = old == \"idle\" or old == \"open\" or old == \"half closed (remote)\"\n\t\tnotify_pipeline = blocking_pipeline and (new == \"half closed (local)\" or new == \"closed\")\n\telse -- client\n\t\t-- If we have just finished writing the request then remove our write lock\n\t\thave_lock = old == \"open\" or old == \"half closed (remote)\"\n\t\twant_no_lock = new == \"half closed (local)\" or new == \"closed\"\n\t\t-- If we have just finished reading the response;\n\t\tblocking_pipeline = old == \"idle\" or old == \"open\" or old == \"half closed (local)\"\n\t\tnotify_pipeline = blocking_pipeline and (new == \"half closed (remote)\" or new == \"closed\")\n\tend\n\tself.state = new\n\tif have_lock then\n\t\tassert(self.connection.req_locked == self)\n\t\tif want_no_lock then\n\t\t\tself.connection.req_locked = nil\n\t\t\tself.connection.req_cond:signal(1)\n\t\tend\n\tend\n\tlocal pipeline_empty\n\tif notify_pipeline then\n\t\tassert(self.connection.pipeline:pop() == self)\n\t\tlocal next_stream = self.connection.pipeline:peek()\n\t\tif next_stream then\n\t\t\tpipeline_empty = false\n\t\t\tnext_stream.pipeline_cond:signal()\n\t\telse\n\t\t\tpipeline_empty = true\n\t\tend\n\telse\n\t\tpipeline_empty = not blocking_pipeline\n\tend\n\tif self.close_when_done then\n\t\tif new == \"half closed (remote)\" then\n\t\t\tself.connection:shutdown(\"r\")\n\t\telseif new == \"half closed (local)\" and self.type == \"server\" then\n\t\t\t-- NOTE: Do not shutdown(\"w\") the socket when a client moves to\n\t\t\t-- \"half closed (local)\", many servers will close a connection\n\t\t\t-- immediately if a client closes their write stream\n\t\t\tself.connection:shutdown(\"w\")\n\t\telseif new == \"closed\" then\n\t\t\tself.connection:shutdown()\n\t\tend\n\tend\n\tif want_no_lock and pipeline_empty then\n\t\tself.connection:onidle()(self.connection)\n\tend\nend\n\nlocal bad_request_headers = new_headers()\nbad_request_headers:append(\":status\", \"400\")\nlocal server_error_headers = new_headers()\nserver_error_headers:append(\":status\", \"503\")\nfunction stream_methods:shutdown()\n\tif self.state == \"idle\" then\n\t\tself:set_state(\"closed\")\n\telse\n\t\tif self.type == \"server\" and (self.state == \"open\" or self.state == \"half closed (remote)\") then\n\t\t\t-- Make sure we're at the front of the pipeline\n\t\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\t\t-- FIXME: shouldn't have time-taking operation here\n\t\t\t\tself.pipeline_cond:wait() -- wait without a timeout should never fail\n\t\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\t\tend\n\t\t\tif not self.body_write_type then\n\t\t\t\t-- Can send an automatic error response\n\t\t\t\tlocal error_headers\n\t\t\t\tif self.connection:error(\"r\") == ce.EILSEQ then\n\t\t\t\t\terror_headers = bad_request_headers\n\t\t\t\telse\n\t\t\t\t\terror_headers = server_error_headers\n\t\t\t\tend\n\t\t\t\tself:write_headers(error_headers, true, 0)\n\t\t\tend\n\t\tend\n\t\t-- read any remaining available response and get out of the way\n\t\tlocal start = self.stats_recv\n\t\twhile (self.state == \"open\" or self.state == \"half closed (local)\") and (self.stats_recv - start) < clean_shutdown_limit do\n\t\t\tif not self:step(0) then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tif self.state ~= \"closed\" then\n\t\t\t-- This is a bad situation: we are trying to shutdown a connection that has the body partially sent\n\t\t\t-- Especially in the case of Connection: close, where closing indicates EOF,\n\t\t\t-- this will result in a client only getting a partial response.\n\t\t\t-- Could also end up here if a client sending headers fails.\n\t\t\tif self.connection.socket then\n\t\t\t\tself.connection.socket:shutdown()\n\t\t\tend\n\t\t\tself:set_state(\"closed\")\n\t\tend\n\tend\n\treturn true\nend\n\nfunction stream_methods:step(timeout)\n\tif self.state == \"open\" or self.state == \"half closed (local)\" or (self.state == \"idle\" and self.type == \"server\") then\n\t\tif self.connection.socket == nil then\n\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\tend\n\t\tif not self.has_main_headers then\n\t\t\tlocal headers, err, errno = self:read_headers(timeout)\n\t\t\tif headers == nil then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.headers_fifo:push(headers)\n\t\t\tself.headers_cond:signal(1)\n\t\t\treturn true\n\t\tend\n\t\tif self.body_read_left ~= 0 then\n\t\t\tlocal chunk, err, errno = self:read_next_chunk(timeout)\n\t\t\tif chunk == nil then\n\t\t\t\tif err == nil then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.chunk_fifo:push(chunk)\n\t\t\tself.chunk_cond:signal()\n\t\t\treturn true\n\t\tend\n\t\tif self.body_read_type == \"chunked\" then\n\t\t\tlocal trailers, err, errno = self:read_headers(timeout)\n\t\t\tif trailers == nil then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.headers_fifo:push(trailers)\n\t\t\tself.headers_cond:signal(1)\n\t\t\treturn true\n\t\tend\n\tend\n\tif self.state == \"half closed (remote)\" then\n\t\treturn nil, ce.strerror(ce.EIO), ce.EIO\n\tend\n\treturn true\nend\n\n-- read_headers may be called more than once for a stream\n-- e.g. for 100 Continue\n-- this function *should never throw* under normal operation\nfunction stream_methods:read_headers(timeout)\n\tlocal deadline = timeout and (monotime()+timeout)\n\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\treturn nil\n\tend\n\tlocal status_code\n\tlocal is_trailers = self.body_read_type == \"chunked\"\n\tlocal headers = self.headers_in_progress\n\tif not headers then\n\t\tif is_trailers then\n\t\t\theaders = new_headers()\n\t\telseif self.type == \"server\" then\n\t\t\tif self.state == \"half closed (local)\" then\n\t\t\t\treturn nil\n\t\t\tend\n\t\t\tlocal method, target, httpversion = self.connection:read_request_line(0)\n\t\t\tif method == nil then\n\t\t\t\tif httpversion == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn nil, target, httpversion\n\t\t\tend\n\t\t\tself.req_method = method\n\t\t\tself.peer_version = httpversion\n\t\t\theaders = new_headers()\n\t\t\theaders:append(\":method\", method)\n\t\t\tif method == \"CONNECT\" then\n\t\t\t\theaders:append(\":authority\", target)\n\t\t\telse\n\t\t\t\theaders:append(\":path\", target)\n\t\t\tend\n\t\t\theaders:append(\":scheme\", self:checktls() and \"https\" or \"http\")\n\t\t\tself:set_state(\"open\")\n\t\telse -- client\n\t\t\t-- Make sure we're at front of connection pipeline\n\t\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\t\tif cqueues.poll(self.pipeline_cond, timeout) == timeout then\n\t\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\t\tend\n\t\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\t\tend\n\t\t\tlocal httpversion, reason_phrase\n\t\t\thttpversion, status_code, reason_phrase = self.connection:read_status_line(0)\n\t\t\tif httpversion == nil then\n\t\t\t\tif reason_phrase == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\telseif status_code == nil then\n\t\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\t\tend\n\t\t\t\treturn nil, status_code, reason_phrase\n\t\t\tend\n\t\t\tself.peer_version = httpversion\n\t\t\theaders = new_headers()\n\t\t\theaders:append(\":status\", status_code)\n\t\t\t-- reason phase intentionally does not exist in HTTP2; discard for consistency\n\t\tend\n\t\tself.headers_in_progress = headers\n\telse\n\t\tif not is_trailers and self.type == \"client\" then\n\t\t\tstatus_code = headers:get(\":status\")\n\t\tend\n\tend\n\n\t-- Use while loop for lua 5.1 compatibility\n\twhile true do\n\t\tif headers:len() >= self.max_header_lines then\n\t\t\treturn nil, ce.strerror(ce.E2BIG), ce.E2BIG\n\t\tend\n\t\tlocal k, v, errno = self.connection:read_header(0)\n\t\tif k == nil then\n\t\t\tif v ~= nil then\n\t\t\t\tif errno == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn nil, v, errno\n\t\t\tend\n\t\t\tbreak -- Success: End of headers.\n\t\tend\n\t\tk = k:lower() -- normalise to lower case\n\t\tif k == \"host\" and not is_trailers then\n\t\t\tk = \":authority\"\n\t\tend\n\t\theaders:append(k, v)\n\tend\n\n\tdo\n\t\tlocal ok, err, errno = self.connection:read_headers_done(0)\n\t\tif ok == nil then\n\t\t\tif errno == ce.ETIMEDOUT then\n\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\tend\n\t\t\telseif err == nil then\n\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\tend\n\t\t\treturn nil, err, errno\n\t\tend\n\t\tself.headers_in_progress = nil\n\t\tself.has_main_headers = status_code == nil or status_code:sub(1,1) ~= \"1\" or status_code == \"101\"\n\tend\n\n\tdo -- if client is sends `Connection: close`, server knows it can close at end of response\n\t\tlocal h = headers:get_comma_separated(\"connection\")\n\t\tif h then\n\t\t\tlocal connection_header = Connection:match(h)\n\t\t\tif connection_header and has(connection_header, \"close\") then\n\t\t\t\tself.close_when_done = true\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Now guess if there's a body...\n\t-- RFC 7230 Section 3.3.3\n\tlocal no_body\n\tif is_trailers then\n\t\t-- there cannot be a body after trailers\n\t\tno_body = true\n\telseif self.type == \"client\" and (\n\t\tself.req_method == \"HEAD\"\n\t\tor status_code == \"204\"\n\t\tor status_code == \"304\"\n\t) then\n\t\tno_body = true\n\telseif self.type == \"client\" and (\n\t\tstatus_code:sub(1,1) == \"1\"\n\t) then\n\t\t-- note: different to spec:\n\t\t-- we don't want to go into body reading mode;\n\t\t-- we want to stay in header modes\n\t\tno_body = false\n\t\tif status_code == \"101\" then\n\t\t\tself.body_read_type = \"close\"\n\t\tend\n\telseif headers:has(\"transfer-encoding\") then\n\t\tno_body = false\n\t\tlocal transfer_encoding = Transfer_Encoding:match(headers:get_comma_separated(\"transfer-encoding\"))\n\t\tlocal n = #transfer_encoding\n\t\tlocal last_transfer_encoding = transfer_encoding[n][1]\n\t\tif last_transfer_encoding == \"chunked\" then\n\t\t\tself.body_read_type = \"chunked\"\n\t\t\tn = n - 1\n\t\t\tif n == 0 then\n\t\t\t\tlast_transfer_encoding = nil\n\t\t\telse\n\t\t\t\tlast_transfer_encoding = transfer_encoding[n][1]\n\t\t\tend\n\t\telse\n\t\t\tself.body_read_type = \"close\"\n\t\tend\n\t\tif last_transfer_encoding == \"gzip\" or last_transfer_encoding == \"deflate\" or last_transfer_encoding == \"x-gzip\" then\n\t\t\tself.body_read_inflate = zlib.inflate()\n\t\t\tn = n - 1\n\t\tend\n\t\tif n > 0 then\n\t\t\treturn nil, \"unknown transfer-encoding\"\n\t\tend\n\telseif headers:has(\"content-length\") then\n\t\tlocal cl = tonumber(headers:get(\"content-length\"), 10)\n\t\tif cl == nil then\n\t\t\treturn nil, \"invalid content-length\"\n\t\tend\n\t\tif cl == 0 then\n\t\t\tno_body = true\n\t\telse\n\t\t\tno_body = false\n\t\t\tself.body_read_type = \"length\"\n\t\t\tself.body_read_left = cl\n\t\tend\n\telseif self.type == \"server\" then\n\t\t-- A request defaults to no body\n\t\tno_body = true\n\telse -- client\n\t\tno_body = false\n\t\tself.body_read_type = \"close\"\n\tend\n\tif self.use_zlib and self.type == \"server\" and self.state == \"open\" and not is_trailers and headers:has(\"te\") then\n\t\tlocal te = TE:match(headers:get_comma_separated(\"te\"))\n\t\tfor _, v in ipairs(te) do\n\t\t\tlocal tcoding = v[1]\n\t\t\tif (tcoding == \"gzip\" or tcoding == \"x-gzip\" or tcoding == \"deflate\") and v.q ~= 0 then\n\t\t\t\tv.q = nil\n\t\t\t\tself.body_write_deflate_encoding = v\n\t\t\t\tself.body_write_deflate = zlib.deflate()\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tif no_body then\n\t\tif self.state == \"open\" then\n\t\t\tself:set_state(\"half closed (remote)\")\n\t\telse -- self.state == \"half closed (local)\"\n\t\t\tself:set_state(\"closed\")\n\t\tend\n\tend\n\treturn headers\nend\n\nfunction stream_methods:get_headers(timeout)\n\tif self.headers_fifo:length() > 0 then\n\t\treturn self.headers_fifo:pop()\n\telse\n\t\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\t\treturn nil\n\t\tend\n\t\tlocal deadline = timeout and monotime()+timeout\n\t\tlocal ok, err, errno = self:step(timeout)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\t\treturn self:get_headers(deadline and deadline-monotime())\n\tend\nend\n\nlocal ignore_fields = {\n\t[\":authority\"] = true;\n\t[\":method\"] = true;\n\t[\":path\"] = true;\n\t[\":scheme\"] = true;\n\t[\":status\"] = true;\n\t[\":protocol\"] = true; -- from RFC 8441\n\t-- fields written manually in :write_headers\n\t[\"connection\"] = true;\n\t[\"content-length\"] = true;\n\t[\"transfer-encoding\"] = true;\n}\n-- Writes the given headers to the stream; optionally ends the stream at end of headers\n--\n-- We're free to insert any of the \"Hop-by-hop\" headers (as listed in RFC 2616 Section 13.5.1)\n-- Do this by directly writing the headers, rather than adding them to the passed headers object,\n-- as we don't want to modify the caller owned object.\n-- Note from RFC 7230 Appendix 2:\n--     \"hop-by-hop\" header fields are required to appear in the Connection header field;\n--     just because they're defined as hop-by-hop doesn't exempt them.\nfunction stream_methods:write_headers(headers, end_stream, timeout)\n\tlocal deadline = timeout and (monotime()+timeout)\n\tassert(headers, \"missing argument: headers\")\n\t-- Validate up front\n\tlocal connection_header do\n\t\tlocal h = headers:get_comma_separated(\"connection\")\n\t\tif h then\n\t\t\tconnection_header = Connection:match(h)\n\t\t\tif not connection_header then\n\t\t\t\terror(\"invalid connection header\")\n\t\t\tend\n\t\telse\n\t\t\tconnection_header = {}\n\t\tend\n\tend\n\tlocal transfer_encoding_header do\n\t\tlocal h = headers:get_comma_separated(\"transfer-encoding\")\n\t\tif h then\n\t\t\ttransfer_encoding_header = Transfer_Encoding:match(h)\n\t\t\tif not transfer_encoding_header then\n\t\t\t\terror(\"invalid transfer-encoding header\")\n\t\t\tend\n\t\tend\n\tend\n\tassert(type(end_stream) == \"boolean\", \"'end_stream' MUST be a boolean\")\n\tif self.state == \"closed\" or self.state == \"half closed (local)\" or self.connection.socket == nil then\n\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\tend\n\tlocal status_code, method\n\tlocal is_trailers\n\tif self.body_write_type == \"chunked\" then\n\t\t-- we are writing trailers; close off body\n\t\tis_trailers = true\n\t\tlocal ok, err, errno = self.connection:write_body_last_chunk(nil, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\telseif self.type == \"server\" then\n\t\tif self.state == \"idle\" then\n\t\t\terror(\"cannot write headers when stream is idle\")\n\t\tend\n\t\tstatus_code = headers:get(\":status\")\n\t\t-- RFC 7231 Section 6.2:\n\t\t-- Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.\n\t\tif status_code and status_code:sub(1,1) == \"1\" and self.peer_version < 1.1 then\n\t\t\terror(\"a server MUST NOT send a 1xx response to an HTTP/1.0 client\")\n\t\tend\n\t\t-- Make sure we're at the front of the pipeline\n\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\theaders = headers:clone() -- don't want user to edit it and send wrong headers\n\t\t\tif cqueues.poll(self.pipeline_cond, timeout) == timeout then\n\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\tend\n\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\tend\n\t\tif status_code then\n\t\t\t-- Should send status line\n\t\t\tlocal reason_phrase = reason_phrases[status_code]\n\t\t\tlocal version = math.min(self.connection.version, self.peer_version)\n\t\t\tlocal ok, err, errno = self.connection:write_status_line(version, status_code, reason_phrase, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\tend\n\telse -- client\n\t\tif self.state == \"idle\" then\n\t\t\tmethod = assert(headers:get(\":method\"), \"missing method\")\n\t\t\tself.req_method = method\n\t\t\tlocal target\n\t\t\tif method == \"CONNECT\" then\n\t\t\t\ttarget = assert(headers:get(\":authority\"), \"missing authority\")\n\t\t\t\tassert(not headers:has(\":path\"), \"CONNECT requests should not have a path\")\n\t\t\telse\n\t\t\t\t-- RFC 7230 Section 5.4: A client MUST send a Host header field in all HTTP/1.1 request messages.\n\t\t\t\tassert(self.connection.version < 1.1 or headers:has(\":authority\"), \"missing authority\")\n\t\t\t\ttarget = assert(headers:get(\":path\"), \"missing path\")\n\t\t\tend\n\t\t\tif self.connection.req_locked then\n\t\t\t\t-- Wait until previous request has been fully written\n\t\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\t\theaders = headers:clone() -- don't want user to edit it and send wrong headers\n\t\t\t\tif cqueues.poll(self.connection.req_cond, timeout) == timeout then\n\t\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\t\tend\n\t\t\t\tassert(self.connection.req_locked == nil)\n\t\t\tend\n\t\t\tself.connection.pipeline:push(self)\n\t\t\tself.connection.req_locked = self\n\t\t\t-- write request line\n\t\t\tlocal ok, err, errno = self.connection:write_request_line(method, target, self.connection.version, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself:set_state(\"open\")\n\t\telse\n\t\t\tassert(self.state == \"open\")\n\t\tend\n\tend\n\n\tlocal cl = headers:get(\"content-length\") -- ignore subsequent content-length values\n\tlocal add_te_gzip = false\n\tif self.req_method == \"CONNECT\" and (self.type == \"client\" or status_code == \"200\") then\n\t\t-- successful CONNECT requests always continue until the connection is closed\n\t\tself.body_write_type = \"close\"\n\t\tself.close_when_done = true\n\t\tif self.type == \"server\" and (cl or transfer_encoding_header) then\n\t\t\t-- RFC 7231 Section 4.3.6:\n\t\t\t-- A server MUST NOT send any Transfer-Encoding or Content-Length header\n\t\t\t-- fields in a 2xx (Successful) response to CONNECT.\n\t\t\terror(\"Content-Length and Transfer-Encoding not allowed with successful CONNECT response\")\n\t\tend\n\telseif self.type == \"server\" and status_code and status_code:sub(1, 1) == \"1\" then\n\t\tassert(not end_stream, \"cannot end stream directly after 1xx status code\")\n\t\t-- A server MUST NOT send a Content-Length header field in any response\n\t\t-- with a status code of 1xx (Informational) or 204 (No Content)\n\t\tif cl then\n\t\t\terror(\"Content-Length not allowed in response with 1xx status code\")\n\t\tend\n\t\tif status_code == \"101\" then\n\t\t\tself.body_write_type = \"switched protocol\"\n\t\tend\n\telseif not self.body_write_type then -- only figure out how to send the body if we haven't figured it out yet... TODO: use better check\n\t\tif self.close_when_done == nil then\n\t\t\tif self.connection.version == 1.0 or (self.type == \"server\" and self.peer_version == 1.0) then\n\t\t\t\tself.close_when_done = not has(connection_header, \"keep-alive\")\n\t\t\telse\n\t\t\t\tself.close_when_done = has(connection_header, \"close\")\n\t\t\tend\n\t\tend\n\t\tif cl then\n\t\t\t-- RFC 7230 Section 3.3.2:\n\t\t\t-- A sender MUST NOT send a Content-Length header field in any\n\t\t\t-- message that contains a Transfer-Encoding header field.\n\t\t\tif transfer_encoding_header then\n\t\t\t\terror(\"Content-Length not allowed in message with a transfer-encoding\")\n\t\t\telseif self.type == \"server\" then\n\t\t\t\t-- A server MUST NOT send a Content-Length header field in any response\n\t\t\t\t-- with a status code of 1xx (Informational) or 204 (No Content)\n\t\t\t\tif status_code == \"204\" then\n\t\t\t\t\terror(\"Content-Length not allowed in response with 204 status code\")\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif end_stream then\n\t\t\t-- Make sure 'end_stream' is respected\n\t\t\tif self.type == \"server\" and (self.req_method == \"HEAD\" or status_code == \"304\") then\n\t\t\t\tself.body_write_type = \"missing\"\n\t\t\telseif transfer_encoding_header then\n\t\t\t\tif transfer_encoding_header[#transfer_encoding_header][1] == \"chunked\" then\n\t\t\t\t\t-- Set body type to chunked so that we know how to end the stream\n\t\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\t\telse\n\t\t\t\t\terror(\"unknown transfer-encoding\")\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- By adding `content-length: 0` we can be sure that our peer won't wait for a body\n\t\t\t\t-- This is somewhat suggested in RFC 7231 section 8.1.2\n\t\t\t\tif cl then -- might already have content-length: 0\n\t\t\t\t\tassert(cl:match(\"^ *0+ *$\"), \"cannot end stream after headers if you have a non-zero content-length\")\n\t\t\t\telseif self.type ~= \"client\" or (method ~= \"GET\" and method ~= \"HEAD\") then\n\t\t\t\t\tcl = \"0\"\n\t\t\t\tend\n\t\t\t\tself.body_write_type = \"length\"\n\t\t\t\tself.body_write_left = 0\n\t\t\tend\n\t\telse\n\t\t\t-- The order of these checks matter:\n\t\t\t\t-- chunked must be checked first, as it totally changes the body format\n\t\t\t\t-- content-length is next\n\t\t\t\t-- closing the connection is ordered after length\n\t\t\t\t\t-- this potentially means an early EOF can be caught if a connection\n\t\t\t\t\t-- closure occurs before body size reaches the specified length\n\t\t\t\t-- for HTTP/1.1, we can fall-back to a chunked encoding\n\t\t\t\t\t-- chunked is mandatory to implement in HTTP/1.1\n\t\t\t\t\t-- this requires amending the transfer-encoding header\n\t\t\t\t-- for an HTTP/1.0 server, we fall-back to closing the connection at the end of the stream\n\t\t\t\t-- else is an HTTP/1.0 client with `connection: keep-alive` but no other header indicating the body form.\n\t\t\t\t\t-- this cannot be reasonably handled, so throw an error.\n\t\t\tif transfer_encoding_header and transfer_encoding_header[#transfer_encoding_header][1] == \"chunked\" then\n\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\telseif cl then\n\t\t\t\tself.body_write_type = \"length\"\n\t\t\t\tself.body_write_left = assert(tonumber(cl, 10), \"invalid content-length\")\n\t\t\telseif self.close_when_done then -- ordered after length delimited\n\t\t\t\tself.body_write_type = \"close\"\n\t\t\telseif self.connection.version == 1.1 and (self.type == \"client\" or self.peer_version == 1.1) then\n\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\t\t-- transfer-encodings are ordered. we need to make sure we place \"chunked\" last\n\t\t\t\tif not transfer_encoding_header then\n\t\t\t\t\ttransfer_encoding_header = {nil} -- preallocate\n\t\t\t\tend\n\t\t\t\ttable.insert(transfer_encoding_header, {\"chunked\"})\n\t\t\telseif self.type == \"server\" then\n\t\t\t\t-- default for servers if they don't send a particular header\n\t\t\t\tself.body_write_type = \"close\"\n\t\t\t\tself.close_when_done = true\n\t\t\telse\n\t\t\t\terror(\"a client cannot send a body with connection: keep-alive without indicating body delimiter in headers\")\n\t\t\tend\n\t\tend\n\t\t-- Add 'Connection: close' header if we're going to close after\n\t\tif self.close_when_done and not has(connection_header, \"close\") then\n\t\t\ttable.insert(connection_header, \"close\")\n\t\tend\n\t\tif self.use_zlib then\n\t\t\tif self.type == \"client\" then\n\t\t\t\t-- If we support zlib; add a \"te\" header indicating we support the gzip transfer-encoding\n\t\t\t\tadd_te_gzip = true\n\t\t\telse -- server\n\t\t\t\t-- Whether to use transfer-encoding: gzip\n\t\t\t\tif self.body_write_deflate -- only use if client sent the TE header allowing it\n\t\t\t\t\tand not cl -- not allowed to use both content-length *and* transfer-encoding\n\t\t\t\t\tand not end_stream -- no point encoding body if there isn't one\n\t\t\t\t\tand not has_any(Content_Encoding:match(headers:get_comma_separated(\"content-encoding\") or \"\"), \"gzip\", \"x-gzip\", \"deflate\")\n\t\t\t\t\t-- don't bother if content-encoding is already gzip/deflate\n\t\t\t\t\t-- TODO: need to take care of quality suffixes (\"deflate; q=0.5\")\n\t\t\t\tthen\n\t\t\t\t\tif transfer_encoding_header then\n\t\t\t\t\t\tlocal n = #transfer_encoding_header\n\t\t\t\t\t\t-- Possibly need to insert before \"chunked\"\n\t\t\t\t\t\tif transfer_encoding_header[n][1] == \"chunked\" then\n\t\t\t\t\t\t\ttransfer_encoding_header[n+1] = transfer_encoding_header[n]\n\t\t\t\t\t\t\ttransfer_encoding_header[n] = self.body_write_deflate_encoding\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttransfer_encoding_header[n+1] = self.body_write_deflate_encoding\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ttransfer_encoding_header = {self.body_write_deflate_encoding}\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t-- discard the encoding context (if there was one)\n\t\t\t\t\tself.body_write_deflate_encoding = nil\n\t\t\t\t\tself.body_write_deflate = nil\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tfor name, value in headers:each() do\n\t\tif not ignore_fields[name] then\n\t\t\tlocal ok, err, errno = self.connection:write_header(name, value, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\telseif name == \":authority\" then\n\t\t\t-- for CONNECT requests, :authority is the path\n\t\t\tif self.req_method ~= \"CONNECT\" then\n\t\t\t\t-- otherwise it's the Host header\n\t\t\t\tlocal ok, err, errno = self.connection:write_header(\"host\", value, 0)\n\t\t\t\tif not ok then\n\t\t\t\t\treturn nil, err, errno\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tif add_te_gzip then\n\t\t-- Doesn't matter if it gets added more than once.\n\t\tif not has(connection_header, \"te\") then\n\t\t\ttable.insert(connection_header, \"te\")\n\t\tend\n\t\tlocal ok, err, errno = self.connection:write_header(\"te\", \"gzip, deflate\", 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\t-- Write transfer-encoding, content-length and connection headers separately\n\tif transfer_encoding_header and transfer_encoding_header[1] then\n\t\t-- Add to connection header\n\t\tif not has(connection_header, \"transfer-encoding\") then\n\t\t\ttable.insert(connection_header, \"transfer-encoding\")\n\t\tend\n\t\tlocal value = {}\n\t\tfor i, v in ipairs(transfer_encoding_header) do\n\t\t\tlocal params = {v[1]}\n\t\t\tfor k, vv in pairs(v) do\n\t\t\t\tif type(k) == \"string\" then\n\t\t\t\t\tparams[#params+1] = k .. \"=\" .. util.maybe_quote(vv)\n\t\t\t\tend\n\t\t\tend\n\t\t\tvalue[i] = table.concat(params, \";\")\n\t\tend\n\t\tvalue = table.concat(value, \",\")\n\t\tlocal ok, err, errno = self.connection:write_header(\"transfer-encoding\", value, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\telseif cl then\n\t\tlocal ok, err, errno = self.connection:write_header(\"content-length\", cl, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\tif connection_header and connection_header[1] then\n\t\tlocal value = table.concat(connection_header, \",\")\n\t\tlocal ok, err, errno = self.connection:write_header(\"connection\", value, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\n\tdo\n\t\tlocal ok, err, errno = self.connection:write_headers_done(deadline and (deadline-monotime()))\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\n\tif end_stream then\n\t\tif is_trailers then\n\t\t\tif self.state == \"half closed (remote)\" then\n\t\t\t\tself:set_state(\"closed\")\n\t\t\telse\n\t\t\t\tself:set_state(\"half closed (local)\")\n\t\t\tend\n\t\telse\n\t\t\tlocal ok, err, errno = self:write_chunk(\"\", true)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\tend\n\tend\n\n\treturn true\nend\n\nfunction stream_methods:read_next_chunk(timeout)\n\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\treturn nil\n\tend\n\tlocal end_stream\n\tlocal chunk, err, errno\n\tif self.body_read_type == \"chunked\" then\n\t\tlocal deadline = timeout and (monotime()+timeout)\n\t\tif self.body_read_left == 0 then\n\t\t\tchunk = false\n\t\telse\n\t\t\tchunk, err, errno = self.connection:read_body_chunk(timeout)\n\t\tend\n\t\tif chunk == false then\n\t\t\t-- last chunk, :read_headers should be called to get trailers\n\t\t\tself.body_read_left = 0\n\t\t\t-- for API compat: attempt to read trailers\n\t\t\tlocal ok\n\t\t\tok, err, errno = self:step(deadline and deadline-monotime())\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\treturn nil\n\t\telse\n\t\t\tend_stream = false\n\t\t\tif chunk == nil and err == nil then\n\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\tend\n\t\tend\n\telseif self.body_read_type == \"length\" then\n\t\tlocal length_n = self.body_read_left\n\t\tif length_n > 0 then\n\t\t\t-- Read *upto* length_n bytes\n\t\t\t-- This function only has to read chunks; not the whole body\n\t\t\tchunk, err, errno = self.connection:read_body_by_length(-length_n, timeout)\n\t\t\tif chunk ~= nil then\n\t\t\t\tself.body_read_left = length_n - #chunk\n\t\t\t\tend_stream = (self.body_read_left == 0)\n\t\t\tend\n\t\telseif length_n == 0 then\n\t\t\tchunk = \"\"\n\t\t\tend_stream = true\n\t\telse\n\t\t\terror(\"invalid length: \"..tostring(length_n))\n\t\tend\n\telseif self.body_read_type == \"close\" then\n\t\t-- Use a big negative number instead of *a. see https://github.com/wahern/cqueues/issues/89\n\t\tchunk, err, errno = self.connection:read_body_by_length(-0x80000000, timeout)\n\t\tend_stream = chunk == nil and err == nil\n\telseif self.body_read_type == nil then\n\t\t-- Might get here if haven't read headers yet, or if only headers so far have been 1xx codes\n\t\tlocal deadline = timeout and (monotime()+timeout)\n\t\tlocal headers\n\t\theaders, err, errno = self:read_headers(timeout)\n\t\tif not headers then\n\t\t\treturn nil, err, errno\n\t\tend\n\t\tself.headers_fifo:push(headers)\n\t\tself.headers_cond:signal(1)\n\t\treturn self:get_next_chunk(deadline and deadline-monotime())\n\telse\n\t\terror(\"unknown body read type\")\n\tend\n\tif chunk then\n\t\tif self.body_read_inflate then\n\t\t\tchunk = self.body_read_inflate(chunk, end_stream)\n\t\tend\n\t\tself.stats_recv = self.stats_recv + #chunk\n\tend\n\tif end_stream then\n\t\tif self.state == \"half closed (local)\" then\n\t\t\tself:set_state(\"closed\")\n\t\telse\n\t\t\tself:set_state(\"half closed (remote)\")\n\t\tend\n\tend\n\treturn chunk, err, errno\nend\n\nfunction stream_methods:get_next_chunk(timeout)\n\tif self.chunk_fifo:length() > 0 then\n\t\treturn self.chunk_fifo:pop()\n\tend\n\treturn self:read_next_chunk(timeout)\nend\n\nfunction stream_methods:unget(str)\n\tself.chunk_fifo:insert(1, str)\n\tself.chunk_cond:signal()\n\treturn true\nend\n\nlocal empty_headers = new_headers()\nfunction stream_methods:write_chunk(chunk, end_stream, timeout)\n\tif self.state == \"idle\" then\n\t\terror(\"cannot write chunk when stream is \" .. self.state)\n\telseif self.state == \"closed\" or self.state == \"half closed (local)\" or self.connection.socket == nil then\n\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\telseif self.body_write_type == nil then\n\t\terror(\"cannot write body before headers\")\n\tend\n\tif self.type == \"client\" then\n\t\tassert(self.connection.req_locked == self)\n\telse\n\t\tassert(self.connection.pipeline:peek() == self)\n\tend\n\tlocal orig_size = #chunk\n\tif self.body_write_deflate then\n\t\tchunk = self.body_write_deflate(chunk, end_stream)\n\tend\n\tif #chunk > 0 then\n\t\tif self.body_write_type == \"chunked\" then\n\t\t\tlocal deadline = timeout and monotime()+timeout\n\t\t\tlocal ok, err, errno = self.connection:write_body_chunk(chunk, nil, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\ttimeout = deadline and (deadline-monotime())\n\t\telseif self.body_write_type == \"length\" then\n\t\t\tassert(self.body_write_left >= #chunk, \"invalid content-length\")\n\t\t\tlocal ok, err, errno = self.connection:write_body_plain(chunk, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.body_write_left = self.body_write_left - #chunk\n\t\telseif self.body_write_type == \"close\" then\n\t\t\tlocal ok, err, errno = self.connection:write_body_plain(chunk, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\telseif self.body_write_type ~= \"missing\" then\n\t\t\terror(\"unknown body writing method\")\n\t\tend\n\tend\n\tself.stats_sent = self.stats_sent + orig_size\n\tif end_stream then\n\t\tif self.body_write_type == \"chunked\" then\n\t\t\treturn self:write_headers(empty_headers, true, timeout)\n\t\telseif self.body_write_type == \"length\" then\n\t\t\tassert(self.body_write_left == 0, \"invalid content-length\")\n\t\tend\n\t\tif self.state == \"half closed (remote)\" then\n\t\t\tself:set_state(\"closed\")\n\t\telse\n\t\t\tself:set_state(\"half closed (local)\")\n\t\tend\n\tend\n\treturn true\nend\n\nreturn {\n\tnew = new_stream;\n\tmethods = stream_methods;\n\tmt = stream_mt;\n}\n", "describe(\"http1 stream\", function()\n\tlocal h1_connection = require \"http.h1_connection\"\n\tlocal new_headers = require \"http.headers\".new\n\tlocal cqueues = require \"cqueues\"\n\tlocal ca = require \"cqueues.auxlib\"\n\tlocal cc = require \"cqueues.condition\"\n\tlocal ce = require \"cqueues.errno\"\n\tlocal cs = require \"cqueues.socket\"\n\tlocal function new_pair(version)\n\t\tlocal s, c = ca.assert(cs.pair())\n\t\ts = h1_connection.new(s, \"server\", version)\n\t\tc = h1_connection.new(c, \"client\", version)\n\t\treturn s, c\n\tend\n\tit(\"allows resuming :read_headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tclient = client:take_socket()\n\t\tassert(client:xwrite(\"GET / HTTP/1.1\\r\\n\", \"n\"))\n\t\tlocal stream = server:get_next_incoming_stream()\n\t\tassert.same(ce.ETIMEDOUT, select(3, stream:read_headers(0.001)))\n\t\tassert(client:xwrite(\"Foo: bar\\r\\n\", \"n\"))\n\t\tassert.same(ce.ETIMEDOUT, select(3, stream:read_headers(0.001)))\n\t\tassert(client:xwrite(\"\\r\\n\", \"n\"))\n\t\tlocal h = assert(stream:read_headers(0.01))\n\t\tassert.same(\"/\", h:get(\":path\"))\n\t\tassert.same(\"bar\", h:get(\"foo\"))\n\tend)\n\tit(\"Writing to a shutdown connection returns EPIPE\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tclient:shutdown()\n\t\tlocal headers = new_headers()\n\t\theaders:append(\":method\", \"GET\")\n\t\theaders:append(\":scheme\", \"http\")\n\t\theaders:append(\":authority\", \"myauthority\")\n\t\theaders:append(\":path\", \"/a\")\n\t\tassert.same(ce.EPIPE, select(3, stream:write_headers(headers, true)))\n\t\tclient:close()\n\t\tserver:close()\n\tend)\n\tit(\"shutdown of an open server stream sends an automatic 503\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tlocal res_headers = assert(stream:get_headers())\n\t\t\tassert.same(\"503\", res_headers:get(\":status\"))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"shutdown of an open server stream with client protocol errors sends an automatic 400\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tassert(client:write_request_line(\"GET\", \"/\", 1.1))\n\t\t\tassert(client.socket:xwrite(\":not a valid header\\r\\n\", \"bn\"))\n\t\t\tlocal _, status_code = assert(client:read_status_line())\n\t\t\tassert.same(\"400\", status_code)\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(ce.EILSEQ, select(3, stream:get_headers()))\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\":unget returns truthy value on success\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tassert.truthy(stream:unget(\"foo\"))\n\t\tassert.same(\"foo\", stream:get_next_chunk())\n\t\tclient:close()\n\t\tserver:close()\n\tend)\n\tit(\"doesn't hang when :shutdown is called when waiting for headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tlocal headers = new_headers()\n\t\theaders:append(\":method\", \"GET\")\n\t\theaders:append(\":scheme\", \"http\")\n\t\theaders:append(\":authority\", \"myauthority\")\n\t\theaders:append(\":path\", \"/a\")\n\t\tassert(stream:write_headers(headers, true))\n\t\tlocal cq = cqueues.new():wrap(function()\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, 0.01)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"inserts connection: close if the connection is going to be closed afterwards\", function()\n\t\tlocal server, client = new_pair(1.0)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tlocal res_headers = assert(stream:get_headers())\n\t\t\tassert.same(\"close\", res_headers:get(\"connection\"))\n\t\t\tassert.same({}, {stream:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tlocal res_headers = new_headers()\n\t\t\tres_headers:append(\":status\", \"200\")\n\t\t\tassert(stream:write_headers(res_headers, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"returns multiple chunks on slow 'connection: close' bodies\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tassert(stream:get_headers())\n\t\t\tassert.same(\"foo\", stream:get_next_chunk())\n\t\t\tassert.same(\"bar\", stream:get_next_chunk())\n\t\t\tassert.same({}, {stream:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tlocal res_headers = new_headers()\n\t\t\tres_headers:append(\":status\", \"200\")\n\t\t\tres_headers:append(\"connection\", \"close\")\n\t\t\tassert(stream:write_headers(res_headers, false))\n\t\t\tassert(stream:write_chunk(\"foo\", false))\n\t\t\tcqueues.sleep(0.1)\n\t\t\tassert(stream:write_chunk(\"bar\", true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"queues up trailers and returns them from :get_headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal headers = new_headers()\n\t\t\theaders:append(\":method\", \"GET\")\n\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\theaders:append(\":path\", \"/a\")\n\t\t\theaders:append(\"transfer-encoding\", \"chunked\")\n\t\t\tassert(stream:write_headers(headers, false))\n\t\t\tlocal trailers = new_headers()\n\t\t\ttrailers:append(\"foo\", \"bar\")\n\t\t\tassert(stream:write_headers(trailers, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tassert.same(\"\", assert(stream:get_body_as_string()))\n\t\t\t-- check remote end has completed (and hence the following :get_headers won't be reading from socket)\n\t\t\tassert.same(\"half closed (remote)\", stream.state)\n\t\t\tlocal trailers = assert(stream:get_headers())\n\t\t\tassert.same(\"bar\", trailers:get(\"foo\"))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"doesn't return from last get_next_chunk until trailers are read\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tassert(client:write_request_line(\"GET\", \"/a\", client.version, TEST_TIMEOUT))\n\t\tassert(client:write_header(\"transfer-encoding\", \"chunked\", TEST_TIMEOUT))\n\t\tassert(client:write_headers_done(TEST_TIMEOUT))\n\t\tassert(client:write_body_chunk(\"foo\", nil, TEST_TIMEOUT))\n\t\tassert(client:write_body_last_chunk(nil, TEST_TIMEOUT))\n\t\tassert(client:write_header(\"sometrailer\", \"bar\", TEST_TIMEOUT))\n\t\tassert(client:flush(TEST_TIMEOUT))\n\t\tlocal server_stream = server:get_next_incoming_stream(0.01)\n\t\tassert(server_stream:get_headers(0.01))\n\t\tassert.same(\"foo\", server_stream:get_next_chunk(0.01))\n\t\t-- Shouldn't return `nil` (indicating EOF) until trailers are completely read.\n\t\tassert.same(ce.ETIMEDOUT, select(3, server_stream:get_next_chunk(0.01)))\n\t\tassert.same(ce.ETIMEDOUT, select(3, server_stream:get_headers(0.01)))\n\t\tassert(client:write_headers_done(TEST_TIMEOUT))\n\t\tassert.same({}, {server_stream:get_next_chunk(0.01)})\n\t\tlocal trailers = assert(server_stream:get_headers(0))\n\t\tassert.same(\"bar\", trailers:get(\"sometrailer\"))\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"waits for trailers when :get_headers is run in a second thread\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal headers = new_headers()\n\t\t\theaders:append(\":method\", \"GET\")\n\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\theaders:append(\":path\", \"/a\")\n\t\t\theaders:append(\"transfer-encoding\", \"chunked\")\n\t\t\tassert(stream:write_headers(headers, false))\n\t\t\tlocal trailers = new_headers()\n\t\t\ttrailers:append(\"foo\", \"bar\")\n\t\t\tassert(stream:write_headers(trailers, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tcqueues.running():wrap(function()\n\t\t\t\tlocal trailers = assert(stream:get_headers())\n\t\t\t\tassert.same(\"bar\", trailers:get(\"foo\"))\n\t\t\tend)\n\t\t\tcqueues.sleep(0.1)\n\t\t\tassert.same(\"\", assert(stream:get_body_as_string()))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"Can read content-length delimited stream\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tdo\n\t\t\t\tlocal stream = client:new_stream()\n\t\t\t\tlocal headers = new_headers()\n\t\t\t\theaders:append(\":method\", \"GET\")\n\t\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\t\theaders:append(\":path\", \"/a\")\n\t\t\t\theaders:append(\"content-length\", \"100\")\n\t\t\t\tassert(stream:write_headers(headers, false))\n\t\t\t\tassert(stream:write_chunk((\"b\"):rep(100), true))\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal stream = client:new_stream()\n\t\t\t\tlocal headers = new_headers()\n\t\t\t\theaders:append(\":method\", \"GET\")\n\t\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\t\theaders:append(\":path\", \"/b\")\n\t\t\t\theaders:append(\"content-length\", \"0\")\n\t\t\t\tassert(stream:write_headers(headers, true))\n\t\t\tend\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tdo\n\t\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\t\tlocal headers = assert(stream:read_headers())\n\t\t\t\tlocal body = assert(stream:get_body_as_string())\n\t\t\t\tassert.same(100, tonumber(headers:get(\"content-length\")))\n\t\t\t\tassert.same(100, #body)\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\t\tlocal headers = assert(stream:read_headers())\n\t\t\t\tlocal body = assert(stream:get_body_as_string())\n\t\t\t\tassert.same(0, tonumber(headers:get(\"content-length\")))\n\t\t\t\tassert.same(0, #body)\n\t\t\tend\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"allows pipelining\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tlocal streams = {}\n\t\tcq:wrap(function()\n\t\t\tlocal x = server:get_next_incoming_stream()\n\t\t\tlocal xh = assert(x:read_headers())\n\t\t\twhile x:get_next_chunk() do end\n\t\t\tstreams[xh:get(\":path\")] = x\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal y = server:get_next_incoming_stream()\n\t\t\tlocal yh = assert(y:read_headers())\n\t\t\twhile y:get_next_chunk() do end\n\t\t\tstreams[yh:get(\":path\")] = y\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal z = server:get_next_incoming_stream()\n\t\t\tlocal zh = assert(z:read_headers())\n\t\t\twhile z:get_next_chunk() do end\n\t\t\tstreams[zh:get(\":path\")] = z\n\t\tend)\n\t\tlocal client_sync = cc.new()\n\t\tcq:wrap(function()\n\t\t\tif client_sync then client_sync:wait() end\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal ah = new_headers()\n\t\t\tah:append(\":method\", \"GET\")\n\t\t\tah:append(\":scheme\", \"http\")\n\t\t\tah:append(\":authority\", \"myauthority\")\n\t\t\tah:append(\":path\", \"/a\")\n\t\t\tassert(a:write_headers(ah, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tclient_sync:signal(); client_sync = nil;\n\t\t\tlocal b = client:new_stream()\n\t\t\tlocal bh = new_headers()\n\t\t\tbh:append(\":method\", \"POST\")\n\t\t\tbh:append(\":scheme\", \"http\")\n\t\t\tbh:append(\":authority\", \"myauthority\")\n\t\t\tbh:append(\":path\", \"/b\")\n\t\t\tassert(b:write_headers(bh, false))\n\t\t\tcqueues.sleep(0.01)\n\t\t\tassert(b:write_chunk(\"this is some POST data\", true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal c = client:new_stream()\n\t\t\tlocal ch = new_headers()\n\t\t\tch:append(\":method\", \"GET\")\n\t\t\tch:append(\":scheme\", \"http\")\n\t\t\tch:append(\":authority\", \"myauthority\")\n\t\t\tch:append(\":path\", \"/c\")\n\t\t\tassert(c:write_headers(ch, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\t-- All requests read; now for responses\n\t\t-- Don't want /a to be first.\n\t\tlocal server_sync = cc.new()\n\t\tcq:wrap(function()\n\t\t\tif server_sync then server_sync:wait() end\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/a\"]:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tserver_sync:signal(); server_sync = nil;\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/b\"]:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tif server_sync then server_sync:wait() end\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/c\"]:write_headers(h, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"modifying pipelined headers doesn't affect what's sent\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal b = client:new_stream()\n\t\t\tlocal c = client:new_stream()\n\n\t\t\tdo\n\t\t\t\tlocal h = new_headers()\n\t\t\t\th:append(\":method\", \"POST\")\n\t\t\t\th:append(\":scheme\", \"http\")\n\t\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\t\th:append(\":path\", \"/\")\n\t\t\t\th:upsert(\"id\", \"a\")\n\t\t\t\tassert(a:write_headers(h, false))\n\t\t\t\tcq:wrap(function()\n\t\t\t\t\tcq:wrap(function()\n\t\t\t\t\t\tcq:wrap(function()\n\t\t\t\t\t\t\tassert(a:write_chunk(\"a\", true))\n\t\t\t\t\t\tend)\n\t\t\t\t\t\th:upsert(\"id\", \"c\")\n\t\t\t\t\t\tassert(c:write_headers(h, false))\n\t\t\t\t\t\tassert(c:write_chunk(\"c\", true))\n\t\t\t\t\tend)\n\t\t\t\t\th:upsert(\"id\", \"b\")\n\t\t\t\t\tassert(b:write_headers(h, false))\n\t\t\t\t\tassert(b:write_chunk(\"b\", true))\n\t\t\t\tend)\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(a:get_headers())\n\t\t\t\tassert.same(\"a\", h:get \"id\")\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(b:get_headers())\n\t\t\t\tassert.same(\"b\", h:get \"id\")\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(c:get_headers())\n\t\t\t\tassert.same(\"c\", h:get \"id\")\n\t\t\tend\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\n\t\t\tlocal a = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"a\", assert(a:get_headers()):get \"id\")\n\t\t\tassert.same(\"a\", a:get_body_as_string())\n\t\t\tcq:wrap(function()\n\t\t\t\th:upsert(\"id\", \"a\")\n\t\t\t\tassert(a:write_headers(h, true))\n\t\t\tend)\n\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"b\", assert(b:get_headers()):get \"id\")\n\t\t\tassert.same(\"b\", b:get_body_as_string())\n\t\t\th:upsert(\"id\", \"b\")\n\t\t\tassert(b:write_headers(h, true))\n\n\t\t\tlocal c = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"c\", assert(c:get_headers()):get \"id\")\n\t\t\tassert.same(\"c\", c:get_body_as_string())\n\t\t\tassert(c:get_headers())\n\t\t\th:upsert(\"id\", \"c\")\n\t\t\tassert(c:write_headers(h, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"allows 100 continue\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":method\", \"POST\")\n\t\t\th:append(\":scheme\", \"http\")\n\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\th:append(\":path\", \"/a\")\n\t\t\th:append(\"expect\", \"100-continue\")\n\t\t\tassert(a:write_headers(h, false))\n\t\t\tassert(assert(a:get_headers()):get(\":status\") == \"100\")\n\t\t\tassert(a:write_chunk(\"body\", true))\n\t\t\tassert(assert(a:get_headers()):get(\":status\") == \"200\")\n\t\t\tassert(a:get_next_chunk() == \"done\")\n\t\t\tassert.same({}, {a:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tassert(b:get_headers())\n\t\t\tassert(b:write_continue())\n\t\t\tassert(b:get_next_chunk() == \"body\")\n\t\t\tassert.same({}, {b:get_next_chunk()})\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(b:write_headers(h, false))\n\t\t\tassert(b:write_chunk(\"done\", true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"doesn't allow sending body before headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":method\", \"GET\")\n\t\t\th:append(\":scheme\", \"http\")\n\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\th:append(\":path\", \"/\")\n\t\t\tassert(a:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tb.use_zlib = false\n\t\t\tassert(b:get_headers())\n\t\t\tassert.has.errors(function() b:write_chunk(\"\", true) end)\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\nend)\n"], "fixing_code": ["local cqueues = require \"cqueues\"\nlocal monotime = cqueues.monotime\nlocal cc = require \"cqueues.condition\"\nlocal ce = require \"cqueues.errno\"\nlocal new_fifo = require \"fifo\"\nlocal lpeg = require \"lpeg\"\nlocal http_patts = require \"lpeg_patterns.http\"\nlocal new_headers = require \"http.headers\".new\nlocal reason_phrases = require \"http.h1_reason_phrases\"\nlocal stream_common = require \"http.stream_common\"\nlocal util = require \"http.util\"\nlocal has_zlib, zlib = pcall(require, \"http.zlib\")\n\n--[[ Maximum amount of data to read during shutdown before giving up on a clean stream shutdown\n500KB seems is a round number that is:\n  - larger than most bandwidth-delay products\n  - larger than most dynamically generated http documents]]\nlocal clean_shutdown_limit = 500*1024\n\nlocal EOF = lpeg.P(-1)\nlocal Connection = lpeg.Ct(http_patts.Connection) * EOF\nlocal Content_Encoding = lpeg.Ct(http_patts.Content_Encoding) * EOF\nlocal Transfer_Encoding = lpeg.Ct(http_patts.Transfer_Encoding) * EOF\nlocal TE = lpeg.Ct(http_patts.TE) * EOF\n\nlocal function has(list, val)\n\tif list then\n\t\tfor i=1, #list do\n\t\t\tif list[i] == val then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\n\nlocal function has_any(list, val, ...)\n\tif has(list, val) then\n\t\treturn true\n\telseif (...) then\n\t\treturn has(list, ...)\n\telse\n\t\treturn false\n\tend\nend\n\nlocal stream_methods = {\n\tuse_zlib = has_zlib;\n\tmax_header_lines = 100;\n}\nfor k,v in pairs(stream_common.methods) do\n\tstream_methods[k] = v\nend\nlocal stream_mt = {\n\t__name = \"http.h1_stream\";\n\t__index = stream_methods;\n}\n\nfunction stream_mt:__tostring()\n\treturn string.format(\"http.h1_stream{connection=%s;state=%q}\",\n\t\ttostring(self.connection), self.state)\nend\n\nlocal function new_stream(connection)\n\tlocal self = setmetatable({\n\t\tconnection = connection;\n\t\ttype = connection.type;\n\n\t\tstate = \"idle\";\n\t\tstats_sent = 0;\n\t\tstats_recv = 0;\n\n\t\tpipeline_cond = cc.new(); -- signalled when stream reaches front of pipeline\n\n\t\treq_method = nil; -- string\n\t\tpeer_version = nil; -- 1.0 or 1.1\n\t\thas_main_headers = false;\n\t\theaders_in_progress = nil;\n\t\theaders_fifo = new_fifo();\n\t\theaders_cond = cc.new();\n\t\tchunk_fifo = new_fifo();\n\t\tchunk_cond = cc.new();\n\t\tbody_write_type = nil; -- \"closed\", \"chunked\", \"length\" or \"missing\"\n\t\tbody_write_left = nil; -- integer: only set when body_write_type == \"length\"\n\t\tbody_write_deflate_encoding = nil;\n\t\tbody_write_deflate = nil; -- nil or stateful deflate closure\n\t\tbody_read_type = nil;\n\t\tbody_read_inflate = nil;\n\t\tclose_when_done = nil; -- boolean\n\t}, stream_mt)\n\treturn self\nend\n\nlocal valid_states = {\n\t[\"idle\"] = 1; -- initial\n\t[\"open\"] = 2; -- have sent or received headers; haven't sent body yet\n\t[\"half closed (local)\"] = 3; -- have sent whole body\n\t[\"half closed (remote)\"] = 3; -- have received whole body\n\t[\"closed\"] = 4; -- complete\n}\nfunction stream_methods:set_state(new)\n\tlocal new_order = assert(valid_states[new])\n\tlocal old = self.state\n\tif new_order <= valid_states[old] then\n\t\terror(\"invalid state progression ('\"..old..\"' to '\"..new..\"')\")\n\tend\n\tlocal have_lock, want_no_lock\n\tlocal blocking_pipeline, notify_pipeline\n\tif self.type == \"server\" then\n\t\t-- If we have just finished reading the request then remove our read lock\n\t\thave_lock = old == \"idle\" or old == \"open\" or old == \"half closed (local)\"\n\t\twant_no_lock = new == \"half closed (remote)\" or new == \"closed\"\n\t\t-- If we have just finished writing the response\n\t\tblocking_pipeline = old == \"idle\" or old == \"open\" or old == \"half closed (remote)\"\n\t\tnotify_pipeline = blocking_pipeline and (new == \"half closed (local)\" or new == \"closed\")\n\telse -- client\n\t\t-- If we have just finished writing the request then remove our write lock\n\t\thave_lock = old == \"open\" or old == \"half closed (remote)\"\n\t\twant_no_lock = new == \"half closed (local)\" or new == \"closed\"\n\t\t-- If we have just finished reading the response;\n\t\tblocking_pipeline = old == \"idle\" or old == \"open\" or old == \"half closed (local)\"\n\t\tnotify_pipeline = blocking_pipeline and (new == \"half closed (remote)\" or new == \"closed\")\n\tend\n\tself.state = new\n\tif have_lock then\n\t\tassert(self.connection.req_locked == self)\n\t\tif want_no_lock then\n\t\t\tself.connection.req_locked = nil\n\t\t\tself.connection.req_cond:signal(1)\n\t\tend\n\tend\n\tlocal pipeline_empty\n\tif notify_pipeline then\n\t\tassert(self.connection.pipeline:pop() == self)\n\t\tlocal next_stream = self.connection.pipeline:peek()\n\t\tif next_stream then\n\t\t\tpipeline_empty = false\n\t\t\tnext_stream.pipeline_cond:signal()\n\t\telse\n\t\t\tpipeline_empty = true\n\t\tend\n\telse\n\t\tpipeline_empty = not blocking_pipeline\n\tend\n\tif self.close_when_done then\n\t\tif new == \"half closed (remote)\" then\n\t\t\tself.connection:shutdown(\"r\")\n\t\telseif new == \"half closed (local)\" and self.type == \"server\" then\n\t\t\t-- NOTE: Do not shutdown(\"w\") the socket when a client moves to\n\t\t\t-- \"half closed (local)\", many servers will close a connection\n\t\t\t-- immediately if a client closes their write stream\n\t\t\tself.connection:shutdown(\"w\")\n\t\telseif new == \"closed\" then\n\t\t\tself.connection:shutdown()\n\t\tend\n\tend\n\tif want_no_lock and pipeline_empty then\n\t\tself.connection:onidle()(self.connection)\n\tend\nend\n\nlocal bad_request_headers = new_headers()\nbad_request_headers:append(\":status\", \"400\")\nlocal server_error_headers = new_headers()\nserver_error_headers:append(\":status\", \"503\")\nfunction stream_methods:shutdown()\n\tif self.state == \"idle\" then\n\t\tself:set_state(\"closed\")\n\telse\n\t\tif self.type == \"server\" and (self.state == \"open\" or self.state == \"half closed (remote)\") then\n\t\t\t-- Make sure we're at the front of the pipeline\n\t\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\t\t-- FIXME: shouldn't have time-taking operation here\n\t\t\t\tself.pipeline_cond:wait() -- wait without a timeout should never fail\n\t\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\t\tend\n\t\t\tif not self.body_write_type then\n\t\t\t\t-- Can send an automatic error response\n\t\t\t\tlocal error_headers\n\t\t\t\tif self.connection:error(\"r\") == ce.EILSEQ then\n\t\t\t\t\terror_headers = bad_request_headers\n\t\t\t\telse\n\t\t\t\t\terror_headers = server_error_headers\n\t\t\t\tend\n\t\t\t\tself:write_headers(error_headers, true, 0)\n\t\t\tend\n\t\tend\n\t\t-- read any remaining available response and get out of the way\n\t\tlocal start = self.stats_recv\n\t\twhile (self.state == \"open\" or self.state == \"half closed (local)\") and (self.stats_recv - start) < clean_shutdown_limit do\n\t\t\tif not self:step(0) then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tif self.state ~= \"closed\" then\n\t\t\t-- This is a bad situation: we are trying to shutdown a connection that has the body partially sent\n\t\t\t-- Especially in the case of Connection: close, where closing indicates EOF,\n\t\t\t-- this will result in a client only getting a partial response.\n\t\t\t-- Could also end up here if a client sending headers fails.\n\t\t\tif self.connection.socket then\n\t\t\t\tself.connection.socket:shutdown()\n\t\t\tend\n\t\t\tself:set_state(\"closed\")\n\t\tend\n\tend\n\treturn true\nend\n\nfunction stream_methods:step(timeout)\n\tif self.state == \"open\" or self.state == \"half closed (local)\" or (self.state == \"idle\" and self.type == \"server\") then\n\t\tif self.connection.socket == nil then\n\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\tend\n\t\tif not self.has_main_headers then\n\t\t\tlocal headers, err, errno = self:read_headers(timeout)\n\t\t\tif headers == nil then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.headers_fifo:push(headers)\n\t\t\tself.headers_cond:signal(1)\n\t\t\treturn true\n\t\tend\n\t\tif self.body_read_left ~= 0 then\n\t\t\tlocal chunk, err, errno = self:read_next_chunk(timeout)\n\t\t\tif chunk == nil then\n\t\t\t\tif err == nil then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.chunk_fifo:push(chunk)\n\t\t\tself.chunk_cond:signal()\n\t\t\treturn true\n\t\tend\n\t\tif self.body_read_type == \"chunked\" then\n\t\t\tlocal trailers, err, errno = self:read_headers(timeout)\n\t\t\tif trailers == nil then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.headers_fifo:push(trailers)\n\t\t\tself.headers_cond:signal(1)\n\t\t\treturn true\n\t\tend\n\tend\n\tif self.state == \"half closed (remote)\" then\n\t\treturn nil, ce.strerror(ce.EIO), ce.EIO\n\tend\n\treturn true\nend\n\n-- read_headers may be called more than once for a stream\n-- e.g. for 100 Continue\n-- this function *should never throw* under normal operation\nfunction stream_methods:read_headers(timeout)\n\tlocal deadline = timeout and (monotime()+timeout)\n\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\treturn nil\n\tend\n\tlocal status_code\n\tlocal is_trailers = self.body_read_type == \"chunked\"\n\tlocal headers = self.headers_in_progress\n\tif not headers then\n\t\tif is_trailers then\n\t\t\theaders = new_headers()\n\t\telseif self.type == \"server\" then\n\t\t\tif self.state == \"half closed (local)\" then\n\t\t\t\treturn nil\n\t\t\tend\n\t\t\tlocal method, target, httpversion = self.connection:read_request_line(0)\n\t\t\tif method == nil then\n\t\t\t\tif httpversion == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn nil, target, httpversion\n\t\t\tend\n\t\t\tself.req_method = method\n\t\t\tself.peer_version = httpversion\n\t\t\theaders = new_headers()\n\t\t\theaders:append(\":method\", method)\n\t\t\tif method == \"CONNECT\" then\n\t\t\t\theaders:append(\":authority\", target)\n\t\t\telse\n\t\t\t\theaders:append(\":path\", target)\n\t\t\tend\n\t\t\theaders:append(\":scheme\", self:checktls() and \"https\" or \"http\")\n\t\t\tself:set_state(\"open\")\n\t\telse -- client\n\t\t\t-- Make sure we're at front of connection pipeline\n\t\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\t\tif cqueues.poll(self.pipeline_cond, timeout) == timeout then\n\t\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\t\tend\n\t\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\t\tend\n\t\t\tlocal httpversion, reason_phrase\n\t\t\thttpversion, status_code, reason_phrase = self.connection:read_status_line(0)\n\t\t\tif httpversion == nil then\n\t\t\t\tif reason_phrase == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\telseif status_code == nil then\n\t\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\t\tend\n\t\t\t\treturn nil, status_code, reason_phrase\n\t\t\tend\n\t\t\tself.peer_version = httpversion\n\t\t\theaders = new_headers()\n\t\t\theaders:append(\":status\", status_code)\n\t\t\t-- reason phase intentionally does not exist in HTTP2; discard for consistency\n\t\tend\n\t\tself.headers_in_progress = headers\n\telse\n\t\tif not is_trailers and self.type == \"client\" then\n\t\t\tstatus_code = headers:get(\":status\")\n\t\tend\n\tend\n\n\t-- Use while loop for lua 5.1 compatibility\n\twhile true do\n\t\tif headers:len() >= self.max_header_lines then\n\t\t\treturn nil, ce.strerror(ce.E2BIG), ce.E2BIG\n\t\tend\n\t\tlocal k, v, errno = self.connection:read_header(0)\n\t\tif k == nil then\n\t\t\tif v ~= nil then\n\t\t\t\tif errno == ce.ETIMEDOUT then\n\t\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn nil, v, errno\n\t\t\tend\n\t\t\tbreak -- Success: End of headers.\n\t\tend\n\t\tk = k:lower() -- normalise to lower case\n\t\tif k == \"host\" and not is_trailers then\n\t\t\tk = \":authority\"\n\t\tend\n\t\theaders:append(k, v)\n\tend\n\n\tdo\n\t\tlocal ok, err, errno = self.connection:read_headers_done(0)\n\t\tif ok == nil then\n\t\t\tif errno == ce.ETIMEDOUT then\n\t\t\t\ttimeout = deadline and deadline-monotime()\n\t\t\t\tif cqueues.poll(self.connection.socket, timeout) ~= timeout then\n\t\t\t\t\treturn self:read_headers(deadline and deadline-monotime())\n\t\t\t\tend\n\t\t\telseif err == nil then\n\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\tend\n\t\t\treturn nil, err, errno\n\t\tend\n\t\tself.headers_in_progress = nil\n\t\tself.has_main_headers = status_code == nil or status_code:sub(1,1) ~= \"1\" or status_code == \"101\"\n\tend\n\n\tdo -- if client is sends `Connection: close`, server knows it can close at end of response\n\t\tlocal h = headers:get_comma_separated(\"connection\")\n\t\tif h then\n\t\t\tlocal connection_header = Connection:match(h)\n\t\t\tif connection_header and has(connection_header, \"close\") then\n\t\t\t\tself.close_when_done = true\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Now guess if there's a body...\n\t-- RFC 7230 Section 3.3.3\n\tlocal no_body\n\tif is_trailers then\n\t\t-- there cannot be a body after trailers\n\t\tno_body = true\n\telseif self.type == \"client\" and (\n\t\tself.req_method == \"HEAD\"\n\t\tor status_code == \"204\"\n\t\tor status_code == \"304\"\n\t) then\n\t\tno_body = true\n\telseif self.type == \"client\" and (\n\t\tstatus_code:sub(1,1) == \"1\"\n\t) then\n\t\t-- note: different to spec:\n\t\t-- we don't want to go into body reading mode;\n\t\t-- we want to stay in header modes\n\t\tno_body = false\n\t\tif status_code == \"101\" then\n\t\t\tself.body_read_type = \"close\"\n\t\tend\n\telseif headers:has(\"transfer-encoding\") then\n\t\tno_body = false\n\t\tlocal transfer_encoding = Transfer_Encoding:match(headers:get_comma_separated(\"transfer-encoding\"))\n\t\tlocal n = #transfer_encoding\n\t\tlocal last_transfer_encoding = transfer_encoding[n][1]\n\t\tif last_transfer_encoding == \"chunked\" then\n\t\t\tself.body_read_type = \"chunked\"\n\t\t\tn = n - 1\n\t\t\tif n == 0 then\n\t\t\t\tlast_transfer_encoding = nil\n\t\t\telse\n\t\t\t\tlast_transfer_encoding = transfer_encoding[n][1]\n\t\t\tend\n\t\telse\n\t\t\tself.body_read_type = \"close\"\n\t\tend\n\t\tif last_transfer_encoding == \"gzip\" or last_transfer_encoding == \"deflate\" or last_transfer_encoding == \"x-gzip\" then\n\t\t\tself.body_read_inflate = zlib.inflate()\n\t\t\tn = n - 1\n\t\tend\n\t\tif n > 0 then\n\t\t\treturn nil, \"unknown transfer-encoding\"\n\t\tend\n\telseif headers:has(\"content-length\") then\n\t\tlocal cl = tonumber(headers:get(\"content-length\"), 10)\n\t\tif cl == nil then\n\t\t\treturn nil, \"invalid content-length\"\n\t\tend\n\t\tif cl == 0 then\n\t\t\tno_body = true\n\t\telse\n\t\t\tno_body = false\n\t\t\tself.body_read_type = \"length\"\n\t\t\tself.body_read_left = cl\n\t\tend\n\telseif self.type == \"server\" then\n\t\t-- A request defaults to no body\n\t\tno_body = true\n\telse -- client\n\t\tno_body = false\n\t\tself.body_read_type = \"close\"\n\tend\n\tif self.use_zlib and self.type == \"server\" and self.state == \"open\" and not is_trailers and headers:has(\"te\") then\n\t\tlocal te = TE:match(headers:get_comma_separated(\"te\"))\n\t\tfor _, v in ipairs(te) do\n\t\t\tlocal tcoding = v[1]\n\t\t\tif (tcoding == \"gzip\" or tcoding == \"x-gzip\" or tcoding == \"deflate\") and v.q ~= 0 then\n\t\t\t\tv.q = nil\n\t\t\t\tself.body_write_deflate_encoding = v\n\t\t\t\tself.body_write_deflate = zlib.deflate()\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tif no_body then\n\t\tif self.state == \"open\" then\n\t\t\tself:set_state(\"half closed (remote)\")\n\t\telse -- self.state == \"half closed (local)\"\n\t\t\tself:set_state(\"closed\")\n\t\tend\n\tend\n\treturn headers\nend\n\nfunction stream_methods:get_headers(timeout)\n\tif self.headers_fifo:length() > 0 then\n\t\treturn self.headers_fifo:pop()\n\telse\n\t\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\t\treturn nil\n\t\tend\n\t\tlocal deadline = timeout and monotime()+timeout\n\t\tlocal ok, err, errno = self:step(timeout)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\t\treturn self:get_headers(deadline and deadline-monotime())\n\tend\nend\n\nlocal ignore_fields = {\n\t[\":authority\"] = true;\n\t[\":method\"] = true;\n\t[\":path\"] = true;\n\t[\":scheme\"] = true;\n\t[\":status\"] = true;\n\t[\":protocol\"] = true; -- from RFC 8441\n\t-- fields written manually in :write_headers\n\t[\"connection\"] = true;\n\t[\"content-length\"] = true;\n\t[\"transfer-encoding\"] = true;\n}\n-- Writes the given headers to the stream; optionally ends the stream at end of headers\n--\n-- We're free to insert any of the \"Hop-by-hop\" headers (as listed in RFC 2616 Section 13.5.1)\n-- Do this by directly writing the headers, rather than adding them to the passed headers object,\n-- as we don't want to modify the caller owned object.\n-- Note from RFC 7230 Appendix 2:\n--     \"hop-by-hop\" header fields are required to appear in the Connection header field;\n--     just because they're defined as hop-by-hop doesn't exempt them.\nfunction stream_methods:write_headers(headers, end_stream, timeout)\n\tlocal deadline = timeout and (monotime()+timeout)\n\tassert(headers, \"missing argument: headers\")\n\t-- Validate up front\n\tlocal connection_header do\n\t\tlocal h = headers:get_comma_separated(\"connection\")\n\t\tif h then\n\t\t\tconnection_header = Connection:match(h)\n\t\t\tif not connection_header then\n\t\t\t\terror(\"invalid connection header\")\n\t\t\tend\n\t\telse\n\t\t\tconnection_header = {}\n\t\tend\n\tend\n\tlocal transfer_encoding_header do\n\t\tlocal h = headers:get_comma_separated(\"transfer-encoding\")\n\t\tif h then\n\t\t\ttransfer_encoding_header = Transfer_Encoding:match(h)\n\t\t\tif not transfer_encoding_header then\n\t\t\t\terror(\"invalid transfer-encoding header\")\n\t\t\tend\n\t\tend\n\tend\n\tassert(type(end_stream) == \"boolean\", \"'end_stream' MUST be a boolean\")\n\tif self.state == \"closed\" or self.state == \"half closed (local)\" or self.connection.socket == nil then\n\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\tend\n\tlocal status_code, method\n\tlocal is_trailers\n\tif self.body_write_type == \"chunked\" then\n\t\t-- we are writing trailers; close off body\n\t\tis_trailers = true\n\t\tlocal ok, err, errno = self.connection:write_body_last_chunk(nil, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\telseif self.type == \"server\" then\n\t\tif self.state == \"idle\" then\n\t\t\terror(\"cannot write headers when stream is idle\")\n\t\tend\n\t\tstatus_code = headers:get(\":status\")\n\t\t-- RFC 7231 Section 6.2:\n\t\t-- Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.\n\t\tif status_code and status_code:sub(1,1) == \"1\" and self.peer_version < 1.1 then\n\t\t\terror(\"a server MUST NOT send a 1xx response to an HTTP/1.0 client\")\n\t\tend\n\t\t-- Make sure we're at the front of the pipeline\n\t\tif self.connection.pipeline:peek() ~= self then\n\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\theaders = headers:clone() -- don't want user to edit it and send wrong headers\n\t\t\tif cqueues.poll(self.pipeline_cond, timeout) == timeout then\n\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\tend\n\t\t\tassert(self.connection.pipeline:peek() == self)\n\t\tend\n\t\tif status_code then\n\t\t\t-- Should send status line\n\t\t\tlocal reason_phrase = reason_phrases[status_code]\n\t\t\tlocal version = math.min(self.connection.version, self.peer_version)\n\t\t\tlocal ok, err, errno = self.connection:write_status_line(version, status_code, reason_phrase, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\tend\n\telse -- client\n\t\tif self.state == \"idle\" then\n\t\t\tmethod = assert(headers:get(\":method\"), \"missing method\")\n\t\t\tself.req_method = method\n\t\t\tlocal target\n\t\t\tif method == \"CONNECT\" then\n\t\t\t\ttarget = assert(headers:get(\":authority\"), \"missing authority\")\n\t\t\t\tassert(not headers:has(\":path\"), \"CONNECT requests should not have a path\")\n\t\t\telse\n\t\t\t\t-- RFC 7230 Section 5.4: A client MUST send a Host header field in all HTTP/1.1 request messages.\n\t\t\t\tassert(self.connection.version < 1.1 or headers:has(\":authority\"), \"missing authority\")\n\t\t\t\ttarget = assert(headers:get(\":path\"), \"missing path\")\n\t\t\tend\n\t\t\tif self.connection.req_locked then\n\t\t\t\t-- Wait until previous request has been fully written\n\t\t\t\tassert(cqueues.running(), \"cannot wait for condition if not within a cqueues coroutine\")\n\t\t\t\theaders = headers:clone() -- don't want user to edit it and send wrong headers\n\t\t\t\tif cqueues.poll(self.connection.req_cond, timeout) == timeout then\n\t\t\t\t\treturn nil, ce.strerror(ce.ETIMEDOUT), ce.ETIMEDOUT\n\t\t\t\tend\n\t\t\t\tassert(self.connection.req_locked == nil)\n\t\t\tend\n\t\t\tself.connection.pipeline:push(self)\n\t\t\tself.connection.req_locked = self\n\t\t\t-- write request line\n\t\t\tlocal ok, err, errno = self.connection:write_request_line(method, target, self.connection.version, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself:set_state(\"open\")\n\t\telse\n\t\t\tassert(self.state == \"open\")\n\t\tend\n\tend\n\n\tlocal cl = headers:get(\"content-length\") -- ignore subsequent content-length values\n\tlocal add_te_gzip = false\n\tif self.req_method == \"CONNECT\" and (self.type == \"client\" or status_code == \"200\") then\n\t\t-- successful CONNECT requests always continue until the connection is closed\n\t\tself.body_write_type = \"close\"\n\t\tself.close_when_done = true\n\t\tif self.type == \"server\" and (cl or transfer_encoding_header) then\n\t\t\t-- RFC 7231 Section 4.3.6:\n\t\t\t-- A server MUST NOT send any Transfer-Encoding or Content-Length header\n\t\t\t-- fields in a 2xx (Successful) response to CONNECT.\n\t\t\terror(\"Content-Length and Transfer-Encoding not allowed with successful CONNECT response\")\n\t\tend\n\telseif self.type == \"server\" and status_code and status_code:sub(1, 1) == \"1\" then\n\t\tassert(not end_stream, \"cannot end stream directly after 1xx status code\")\n\t\t-- A server MUST NOT send a Content-Length header field in any response\n\t\t-- with a status code of 1xx (Informational) or 204 (No Content)\n\t\tif cl then\n\t\t\terror(\"Content-Length not allowed in response with 1xx status code\")\n\t\tend\n\t\tif status_code == \"101\" then\n\t\t\tself.body_write_type = \"switched protocol\"\n\t\tend\n\telseif not self.body_write_type then -- only figure out how to send the body if we haven't figured it out yet... TODO: use better check\n\t\tif self.close_when_done == nil then\n\t\t\tif self.connection.version == 1.0 or (self.type == \"server\" and self.peer_version == 1.0) then\n\t\t\t\tself.close_when_done = not has(connection_header, \"keep-alive\")\n\t\t\telse\n\t\t\t\tself.close_when_done = has(connection_header, \"close\")\n\t\t\tend\n\t\tend\n\t\tif cl then\n\t\t\t-- RFC 7230 Section 3.3.2:\n\t\t\t-- A sender MUST NOT send a Content-Length header field in any\n\t\t\t-- message that contains a Transfer-Encoding header field.\n\t\t\tif transfer_encoding_header then\n\t\t\t\terror(\"Content-Length not allowed in message with a transfer-encoding\")\n\t\t\telseif self.type == \"server\" then\n\t\t\t\t-- A server MUST NOT send a Content-Length header field in any response\n\t\t\t\t-- with a status code of 1xx (Informational) or 204 (No Content)\n\t\t\t\tif status_code == \"204\" then\n\t\t\t\t\terror(\"Content-Length not allowed in response with 204 status code\")\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif end_stream then\n\t\t\t-- Make sure 'end_stream' is respected\n\t\t\tif self.type == \"server\" and (self.req_method == \"HEAD\" or status_code == \"304\") then\n\t\t\t\tself.body_write_type = \"missing\"\n\t\t\telseif transfer_encoding_header then\n\t\t\t\tif transfer_encoding_header[#transfer_encoding_header][1] == \"chunked\" then\n\t\t\t\t\t-- Set body type to chunked so that we know how to end the stream\n\t\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\t\telse\n\t\t\t\t\terror(\"unknown transfer-encoding\")\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- By adding `content-length: 0` we can be sure that our peer won't wait for a body\n\t\t\t\t-- This is somewhat suggested in RFC 7231 section 8.1.2\n\t\t\t\tif cl then -- might already have content-length: 0\n\t\t\t\t\tassert(cl:match(\"^ *0+ *$\"), \"cannot end stream after headers if you have a non-zero content-length\")\n\t\t\t\telseif self.type ~= \"client\" or (method ~= \"GET\" and method ~= \"HEAD\") then\n\t\t\t\t\tcl = \"0\"\n\t\t\t\tend\n\t\t\t\tself.body_write_type = \"length\"\n\t\t\t\tself.body_write_left = 0\n\t\t\tend\n\t\telse\n\t\t\t-- The order of these checks matter:\n\t\t\t\t-- chunked must be checked first, as it totally changes the body format\n\t\t\t\t-- content-length is next\n\t\t\t\t-- closing the connection is ordered after length\n\t\t\t\t\t-- this potentially means an early EOF can be caught if a connection\n\t\t\t\t\t-- closure occurs before body size reaches the specified length\n\t\t\t\t-- for HTTP/1.1, we can fall-back to a chunked encoding\n\t\t\t\t\t-- chunked is mandatory to implement in HTTP/1.1\n\t\t\t\t\t-- this requires amending the transfer-encoding header\n\t\t\t\t-- for an HTTP/1.0 server, we fall-back to closing the connection at the end of the stream\n\t\t\t\t-- else is an HTTP/1.0 client with `connection: keep-alive` but no other header indicating the body form.\n\t\t\t\t\t-- this cannot be reasonably handled, so throw an error.\n\t\t\tif transfer_encoding_header and transfer_encoding_header[#transfer_encoding_header][1] == \"chunked\" then\n\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\telseif cl then\n\t\t\t\tself.body_write_type = \"length\"\n\t\t\t\tself.body_write_left = assert(tonumber(cl, 10), \"invalid content-length\")\n\t\t\telseif self.close_when_done then -- ordered after length delimited\n\t\t\t\tself.body_write_type = \"close\"\n\t\t\telseif self.connection.version == 1.1 and (self.type == \"client\" or self.peer_version == 1.1) then\n\t\t\t\tself.body_write_type = \"chunked\"\n\t\t\t\t-- transfer-encodings are ordered. we need to make sure we place \"chunked\" last\n\t\t\t\tif not transfer_encoding_header then\n\t\t\t\t\ttransfer_encoding_header = {nil} -- preallocate\n\t\t\t\tend\n\t\t\t\ttable.insert(transfer_encoding_header, {\"chunked\"})\n\t\t\telseif self.type == \"server\" then\n\t\t\t\t-- default for servers if they don't send a particular header\n\t\t\t\tself.body_write_type = \"close\"\n\t\t\t\tself.close_when_done = true\n\t\t\telse\n\t\t\t\terror(\"a client cannot send a body with connection: keep-alive without indicating body delimiter in headers\")\n\t\t\tend\n\t\tend\n\t\t-- Add 'Connection: close' header if we're going to close after\n\t\tif self.close_when_done and not has(connection_header, \"close\") then\n\t\t\ttable.insert(connection_header, \"close\")\n\t\tend\n\t\tif self.use_zlib then\n\t\t\tif self.type == \"client\" then\n\t\t\t\t-- If we support zlib; add a \"te\" header indicating we support the gzip transfer-encoding\n\t\t\t\tadd_te_gzip = true\n\t\t\telse -- server\n\t\t\t\t-- Whether to use transfer-encoding: gzip\n\t\t\t\tif self.body_write_deflate -- only use if client sent the TE header allowing it\n\t\t\t\t\tand not cl -- not allowed to use both content-length *and* transfer-encoding\n\t\t\t\t\tand not end_stream -- no point encoding body if there isn't one\n\t\t\t\t\tand not has_any(Content_Encoding:match(headers:get_comma_separated(\"content-encoding\") or \"\"), \"gzip\", \"x-gzip\", \"deflate\")\n\t\t\t\t\t-- don't bother if content-encoding is already gzip/deflate\n\t\t\t\t\t-- TODO: need to take care of quality suffixes (\"deflate; q=0.5\")\n\t\t\t\tthen\n\t\t\t\t\tif transfer_encoding_header then\n\t\t\t\t\t\tlocal n = #transfer_encoding_header\n\t\t\t\t\t\t-- Possibly need to insert before \"chunked\"\n\t\t\t\t\t\tif transfer_encoding_header[n][1] == \"chunked\" then\n\t\t\t\t\t\t\ttransfer_encoding_header[n+1] = transfer_encoding_header[n]\n\t\t\t\t\t\t\ttransfer_encoding_header[n] = self.body_write_deflate_encoding\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttransfer_encoding_header[n+1] = self.body_write_deflate_encoding\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ttransfer_encoding_header = {self.body_write_deflate_encoding}\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t-- discard the encoding context (if there was one)\n\t\t\t\t\tself.body_write_deflate_encoding = nil\n\t\t\t\t\tself.body_write_deflate = nil\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tfor name, value in headers:each() do\n\t\tif not ignore_fields[name] then\n\t\t\tlocal ok, err, errno = self.connection:write_header(name, value, 0)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\telseif name == \":authority\" then\n\t\t\t-- for CONNECT requests, :authority is the path\n\t\t\tif self.req_method ~= \"CONNECT\" then\n\t\t\t\t-- otherwise it's the Host header\n\t\t\t\tlocal ok, err, errno = self.connection:write_header(\"host\", value, 0)\n\t\t\t\tif not ok then\n\t\t\t\t\treturn nil, err, errno\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tif add_te_gzip then\n\t\t-- Doesn't matter if it gets added more than once.\n\t\tif not has(connection_header, \"te\") then\n\t\t\ttable.insert(connection_header, \"te\")\n\t\tend\n\t\tlocal ok, err, errno = self.connection:write_header(\"te\", \"gzip, deflate\", 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\t-- Write transfer-encoding, content-length and connection headers separately\n\tif transfer_encoding_header and transfer_encoding_header[1] then\n\t\t-- Add to connection header\n\t\tif not has(connection_header, \"transfer-encoding\") then\n\t\t\ttable.insert(connection_header, \"transfer-encoding\")\n\t\tend\n\t\tlocal value = {}\n\t\tfor i, v in ipairs(transfer_encoding_header) do\n\t\t\tlocal params = {v[1]}\n\t\t\tfor k, vv in pairs(v) do\n\t\t\t\tif type(k) == \"string\" then\n\t\t\t\t\tparams[#params+1] = k .. \"=\" .. util.maybe_quote(vv)\n\t\t\t\tend\n\t\t\tend\n\t\t\tvalue[i] = table.concat(params, \";\")\n\t\tend\n\t\tvalue = table.concat(value, \",\")\n\t\tlocal ok, err, errno = self.connection:write_header(\"transfer-encoding\", value, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\telseif cl then\n\t\tlocal ok, err, errno = self.connection:write_header(\"content-length\", cl, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\tif connection_header and connection_header[1] then\n\t\tlocal value = table.concat(connection_header, \",\")\n\t\tlocal ok, err, errno = self.connection:write_header(\"connection\", value, 0)\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\n\tdo\n\t\tlocal ok, err, errno = self.connection:write_headers_done(deadline and (deadline-monotime()))\n\t\tif not ok then\n\t\t\treturn nil, err, errno\n\t\tend\n\tend\n\n\tif end_stream then\n\t\tif is_trailers then\n\t\t\tif self.state == \"half closed (remote)\" then\n\t\t\t\tself:set_state(\"closed\")\n\t\t\telse\n\t\t\t\tself:set_state(\"half closed (local)\")\n\t\t\tend\n\t\telse\n\t\t\tlocal ok, err, errno = self:write_chunk(\"\", true)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\tend\n\tend\n\n\treturn true\nend\n\nfunction stream_methods:read_next_chunk(timeout)\n\tif self.state == \"closed\" or self.state == \"half closed (remote)\" then\n\t\treturn nil\n\tend\n\tlocal end_stream\n\tlocal chunk, err, errno\n\tif self.body_read_type == \"chunked\" then\n\t\tlocal deadline = timeout and (monotime()+timeout)\n\t\tif self.body_read_left == 0 then\n\t\t\tchunk = false\n\t\telse\n\t\t\tchunk, err, errno = self.connection:read_body_chunk(timeout)\n\t\tend\n\t\tif chunk == false then\n\t\t\t-- last chunk, :read_headers should be called to get trailers\n\t\t\tself.body_read_left = 0\n\t\t\t-- for API compat: attempt to read trailers\n\t\t\tlocal ok\n\t\t\tok, err, errno = self:step(deadline and deadline-monotime())\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\treturn nil\n\t\telse\n\t\t\tend_stream = false\n\t\t\tif chunk == nil and err == nil then\n\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\tend\n\t\tend\n\telseif self.body_read_type == \"length\" then\n\t\tlocal length_n = self.body_read_left\n\t\tif length_n > 0 then\n\t\t\t-- Read *upto* length_n bytes\n\t\t\t-- This function only has to read chunks; not the whole body\n\t\t\tchunk, err, errno = self.connection:read_body_by_length(-length_n, timeout)\n\t\t\tif chunk ~= nil then\n\t\t\t\tself.body_read_left = length_n - #chunk\n\t\t\t\tend_stream = (self.body_read_left == 0)\n\t\t\telseif err == nil then\n\t\t\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\t\t\tend\n\t\telseif length_n == 0 then\n\t\t\tchunk = \"\"\n\t\t\tend_stream = true\n\t\telse\n\t\t\terror(\"invalid length: \"..tostring(length_n))\n\t\tend\n\telseif self.body_read_type == \"close\" then\n\t\t-- Use a big negative number instead of *a. see https://github.com/wahern/cqueues/issues/89\n\t\tchunk, err, errno = self.connection:read_body_by_length(-0x80000000, timeout)\n\t\tend_stream = chunk == nil and err == nil\n\telseif self.body_read_type == nil then\n\t\t-- Might get here if haven't read headers yet, or if only headers so far have been 1xx codes\n\t\tlocal deadline = timeout and (monotime()+timeout)\n\t\tlocal headers\n\t\theaders, err, errno = self:read_headers(timeout)\n\t\tif not headers then\n\t\t\treturn nil, err, errno\n\t\tend\n\t\tself.headers_fifo:push(headers)\n\t\tself.headers_cond:signal(1)\n\t\treturn self:get_next_chunk(deadline and deadline-monotime())\n\telse\n\t\terror(\"unknown body read type\")\n\tend\n\tif chunk then\n\t\tif self.body_read_inflate then\n\t\t\tchunk = self.body_read_inflate(chunk, end_stream)\n\t\tend\n\t\tself.stats_recv = self.stats_recv + #chunk\n\tend\n\tif end_stream then\n\t\tif self.state == \"half closed (local)\" then\n\t\t\tself:set_state(\"closed\")\n\t\telse\n\t\t\tself:set_state(\"half closed (remote)\")\n\t\tend\n\tend\n\treturn chunk, err, errno\nend\n\nfunction stream_methods:get_next_chunk(timeout)\n\tif self.chunk_fifo:length() > 0 then\n\t\treturn self.chunk_fifo:pop()\n\tend\n\treturn self:read_next_chunk(timeout)\nend\n\nfunction stream_methods:unget(str)\n\tself.chunk_fifo:insert(1, str)\n\tself.chunk_cond:signal()\n\treturn true\nend\n\nlocal empty_headers = new_headers()\nfunction stream_methods:write_chunk(chunk, end_stream, timeout)\n\tif self.state == \"idle\" then\n\t\terror(\"cannot write chunk when stream is \" .. self.state)\n\telseif self.state == \"closed\" or self.state == \"half closed (local)\" or self.connection.socket == nil then\n\t\treturn nil, ce.strerror(ce.EPIPE), ce.EPIPE\n\telseif self.body_write_type == nil then\n\t\terror(\"cannot write body before headers\")\n\tend\n\tif self.type == \"client\" then\n\t\tassert(self.connection.req_locked == self)\n\telse\n\t\tassert(self.connection.pipeline:peek() == self)\n\tend\n\tlocal orig_size = #chunk\n\tif self.body_write_deflate then\n\t\tchunk = self.body_write_deflate(chunk, end_stream)\n\tend\n\tif #chunk > 0 then\n\t\tif self.body_write_type == \"chunked\" then\n\t\t\tlocal deadline = timeout and monotime()+timeout\n\t\t\tlocal ok, err, errno = self.connection:write_body_chunk(chunk, nil, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\ttimeout = deadline and (deadline-monotime())\n\t\telseif self.body_write_type == \"length\" then\n\t\t\tassert(self.body_write_left >= #chunk, \"invalid content-length\")\n\t\t\tlocal ok, err, errno = self.connection:write_body_plain(chunk, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\t\tself.body_write_left = self.body_write_left - #chunk\n\t\telseif self.body_write_type == \"close\" then\n\t\t\tlocal ok, err, errno = self.connection:write_body_plain(chunk, timeout)\n\t\t\tif not ok then\n\t\t\t\treturn nil, err, errno\n\t\t\tend\n\t\telseif self.body_write_type ~= \"missing\" then\n\t\t\terror(\"unknown body writing method\")\n\t\tend\n\tend\n\tself.stats_sent = self.stats_sent + orig_size\n\tif end_stream then\n\t\tif self.body_write_type == \"chunked\" then\n\t\t\treturn self:write_headers(empty_headers, true, timeout)\n\t\telseif self.body_write_type == \"length\" then\n\t\t\tassert(self.body_write_left == 0, \"invalid content-length\")\n\t\tend\n\t\tif self.state == \"half closed (remote)\" then\n\t\t\tself:set_state(\"closed\")\n\t\telse\n\t\t\tself:set_state(\"half closed (local)\")\n\t\tend\n\tend\n\treturn true\nend\n\nreturn {\n\tnew = new_stream;\n\tmethods = stream_methods;\n\tmt = stream_mt;\n}\n", "describe(\"http1 stream\", function()\n\tlocal h1_connection = require \"http.h1_connection\"\n\tlocal new_headers = require \"http.headers\".new\n\tlocal cqueues = require \"cqueues\"\n\tlocal ca = require \"cqueues.auxlib\"\n\tlocal cc = require \"cqueues.condition\"\n\tlocal ce = require \"cqueues.errno\"\n\tlocal cs = require \"cqueues.socket\"\n\tlocal function new_pair(version)\n\t\tlocal s, c = ca.assert(cs.pair())\n\t\ts = h1_connection.new(s, \"server\", version)\n\t\tc = h1_connection.new(c, \"client\", version)\n\t\treturn s, c\n\tend\n\tit(\"allows resuming :read_headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tclient = client:take_socket()\n\t\tassert(client:xwrite(\"GET / HTTP/1.1\\r\\n\", \"n\"))\n\t\tlocal stream = server:get_next_incoming_stream()\n\t\tassert.same(ce.ETIMEDOUT, select(3, stream:read_headers(0.001)))\n\t\tassert(client:xwrite(\"Foo: bar\\r\\n\", \"n\"))\n\t\tassert.same(ce.ETIMEDOUT, select(3, stream:read_headers(0.001)))\n\t\tassert(client:xwrite(\"\\r\\n\", \"n\"))\n\t\tlocal h = assert(stream:read_headers(0.01))\n\t\tassert.same(\"/\", h:get(\":path\"))\n\t\tassert.same(\"bar\", h:get(\"foo\"))\n\tend)\n\tit(\"Writing to a shutdown connection returns EPIPE\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tclient:shutdown()\n\t\tlocal headers = new_headers()\n\t\theaders:append(\":method\", \"GET\")\n\t\theaders:append(\":scheme\", \"http\")\n\t\theaders:append(\":authority\", \"myauthority\")\n\t\theaders:append(\":path\", \"/a\")\n\t\tassert.same(ce.EPIPE, select(3, stream:write_headers(headers, true)))\n\t\tclient:close()\n\t\tserver:close()\n\tend)\n\tit(\"shutdown of an open server stream sends an automatic 503\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tlocal res_headers = assert(stream:get_headers())\n\t\t\tassert.same(\"503\", res_headers:get(\":status\"))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"shutdown of an open server stream with client protocol errors sends an automatic 400\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tassert(client:write_request_line(\"GET\", \"/\", 1.1))\n\t\t\tassert(client.socket:xwrite(\":not a valid header\\r\\n\", \"bn\"))\n\t\t\tlocal _, status_code = assert(client:read_status_line())\n\t\t\tassert.same(\"400\", status_code)\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(ce.EILSEQ, select(3, stream:get_headers()))\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\":unget returns truthy value on success\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tassert.truthy(stream:unget(\"foo\"))\n\t\tassert.same(\"foo\", stream:get_next_chunk())\n\t\tclient:close()\n\t\tserver:close()\n\tend)\n\tit(\"doesn't hang when :shutdown is called when waiting for headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal stream = client:new_stream()\n\t\tlocal headers = new_headers()\n\t\theaders:append(\":method\", \"GET\")\n\t\theaders:append(\":scheme\", \"http\")\n\t\theaders:append(\":authority\", \"myauthority\")\n\t\theaders:append(\":path\", \"/a\")\n\t\tassert(stream:write_headers(headers, true))\n\t\tlocal cq = cqueues.new():wrap(function()\n\t\t\tstream:shutdown()\n\t\tend)\n\t\tassert_loop(cq, 0.01)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"inserts connection: close if the connection is going to be closed afterwards\", function()\n\t\tlocal server, client = new_pair(1.0)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tlocal res_headers = assert(stream:get_headers())\n\t\t\tassert.same(\"close\", res_headers:get(\"connection\"))\n\t\t\tassert.same({}, {stream:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tlocal res_headers = new_headers()\n\t\t\tres_headers:append(\":status\", \"200\")\n\t\t\tassert(stream:write_headers(res_headers, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"returns multiple chunks on slow 'connection: close' bodies\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal req_headers = new_headers()\n\t\t\treq_headers:append(\":method\", \"GET\")\n\t\t\treq_headers:append(\":scheme\", \"http\")\n\t\t\treq_headers:append(\":authority\", \"myauthority\")\n\t\t\treq_headers:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(req_headers, true))\n\t\t\tassert(stream:get_headers())\n\t\t\tassert.same(\"foo\", stream:get_next_chunk())\n\t\t\tassert.same(\"bar\", stream:get_next_chunk())\n\t\t\tassert.same({}, {stream:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tlocal res_headers = new_headers()\n\t\t\tres_headers:append(\":status\", \"200\")\n\t\t\tres_headers:append(\"connection\", \"close\")\n\t\t\tassert(stream:write_headers(res_headers, false))\n\t\t\tassert(stream:write_chunk(\"foo\", false))\n\t\t\tcqueues.sleep(0.1)\n\t\t\tassert(stream:write_chunk(\"bar\", true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"queues up trailers and returns them from :get_headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal headers = new_headers()\n\t\t\theaders:append(\":method\", \"GET\")\n\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\theaders:append(\":path\", \"/a\")\n\t\t\theaders:append(\"transfer-encoding\", \"chunked\")\n\t\t\tassert(stream:write_headers(headers, false))\n\t\t\tlocal trailers = new_headers()\n\t\t\ttrailers:append(\"foo\", \"bar\")\n\t\t\tassert(stream:write_headers(trailers, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tassert.same(\"\", assert(stream:get_body_as_string()))\n\t\t\t-- check remote end has completed (and hence the following :get_headers won't be reading from socket)\n\t\t\tassert.same(\"half closed (remote)\", stream.state)\n\t\t\tlocal trailers = assert(stream:get_headers())\n\t\t\tassert.same(\"bar\", trailers:get(\"foo\"))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"doesn't return from last get_next_chunk until trailers are read\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tassert(client:write_request_line(\"GET\", \"/a\", client.version, TEST_TIMEOUT))\n\t\tassert(client:write_header(\"transfer-encoding\", \"chunked\", TEST_TIMEOUT))\n\t\tassert(client:write_headers_done(TEST_TIMEOUT))\n\t\tassert(client:write_body_chunk(\"foo\", nil, TEST_TIMEOUT))\n\t\tassert(client:write_body_last_chunk(nil, TEST_TIMEOUT))\n\t\tassert(client:write_header(\"sometrailer\", \"bar\", TEST_TIMEOUT))\n\t\tassert(client:flush(TEST_TIMEOUT))\n\t\tlocal server_stream = server:get_next_incoming_stream(0.01)\n\t\tassert(server_stream:get_headers(0.01))\n\t\tassert.same(\"foo\", server_stream:get_next_chunk(0.01))\n\t\t-- Shouldn't return `nil` (indicating EOF) until trailers are completely read.\n\t\tassert.same(ce.ETIMEDOUT, select(3, server_stream:get_next_chunk(0.01)))\n\t\tassert.same(ce.ETIMEDOUT, select(3, server_stream:get_headers(0.01)))\n\t\tassert(client:write_headers_done(TEST_TIMEOUT))\n\t\tassert.same({}, {server_stream:get_next_chunk(0.01)})\n\t\tlocal trailers = assert(server_stream:get_headers(0))\n\t\tassert.same(\"bar\", trailers:get(\"sometrailer\"))\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"waits for trailers when :get_headers is run in a second thread\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal headers = new_headers()\n\t\t\theaders:append(\":method\", \"GET\")\n\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\theaders:append(\":path\", \"/a\")\n\t\t\theaders:append(\"transfer-encoding\", \"chunked\")\n\t\t\tassert(stream:write_headers(headers, false))\n\t\t\tlocal trailers = new_headers()\n\t\t\ttrailers:append(\"foo\", \"bar\")\n\t\t\tassert(stream:write_headers(trailers, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tcqueues.running():wrap(function()\n\t\t\t\tlocal trailers = assert(stream:get_headers())\n\t\t\t\tassert.same(\"bar\", trailers:get(\"foo\"))\n\t\t\tend)\n\t\t\tcqueues.sleep(0.1)\n\t\t\tassert.same(\"\", assert(stream:get_body_as_string()))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"Can read content-length delimited stream\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tdo\n\t\t\t\tlocal stream = client:new_stream()\n\t\t\t\tlocal headers = new_headers()\n\t\t\t\theaders:append(\":method\", \"GET\")\n\t\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\t\theaders:append(\":path\", \"/a\")\n\t\t\t\theaders:append(\"content-length\", \"100\")\n\t\t\t\tassert(stream:write_headers(headers, false))\n\t\t\t\tassert(stream:write_chunk((\"b\"):rep(100), true))\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal stream = client:new_stream()\n\t\t\t\tlocal headers = new_headers()\n\t\t\t\theaders:append(\":method\", \"GET\")\n\t\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\t\theaders:append(\":path\", \"/b\")\n\t\t\t\theaders:append(\"content-length\", \"0\")\n\t\t\t\tassert(stream:write_headers(headers, true))\n\t\t\tend\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tdo\n\t\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\t\tlocal headers = assert(stream:read_headers())\n\t\t\t\tlocal body = assert(stream:get_body_as_string())\n\t\t\t\tassert.same(100, tonumber(headers:get(\"content-length\")))\n\t\t\t\tassert.same(100, #body)\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\t\tlocal headers = assert(stream:read_headers())\n\t\t\t\tlocal body = assert(stream:get_body_as_string())\n\t\t\t\tassert.same(0, tonumber(headers:get(\"content-length\")))\n\t\t\t\tassert.same(0, #body)\n\t\t\tend\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"Doesn't hang when a content-length delimited stream is closed\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal stream = client:new_stream()\n\t\t\tlocal headers = new_headers()\n\t\t\theaders:append(\":method\", \"GET\")\n\t\t\theaders:append(\":scheme\", \"http\")\n\t\t\theaders:append(\":authority\", \"myauthority\")\n\t\t\theaders:append(\":path\", \"/a\")\n\t\t\tassert(stream:write_headers(headers, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal stream = server:get_next_incoming_stream()\n\t\t\tassert(stream:get_headers())\n\t\t\tlocal res_headers = new_headers()\n\t\t\tres_headers:append(\":status\", \"200\")\n\t\t\tres_headers:append(\"content-length\", \"100\")\n\t\t\tassert(stream:write_headers(res_headers, false))\n\t\t\tassert(stream:write_chunk(\"foo\", false))\n\t\t\tassert(stream:shutdown())\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"allows pipelining\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tlocal streams = {}\n\t\tcq:wrap(function()\n\t\t\tlocal x = server:get_next_incoming_stream()\n\t\t\tlocal xh = assert(x:read_headers())\n\t\t\twhile x:get_next_chunk() do end\n\t\t\tstreams[xh:get(\":path\")] = x\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal y = server:get_next_incoming_stream()\n\t\t\tlocal yh = assert(y:read_headers())\n\t\t\twhile y:get_next_chunk() do end\n\t\t\tstreams[yh:get(\":path\")] = y\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal z = server:get_next_incoming_stream()\n\t\t\tlocal zh = assert(z:read_headers())\n\t\t\twhile z:get_next_chunk() do end\n\t\t\tstreams[zh:get(\":path\")] = z\n\t\tend)\n\t\tlocal client_sync = cc.new()\n\t\tcq:wrap(function()\n\t\t\tif client_sync then client_sync:wait() end\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal ah = new_headers()\n\t\t\tah:append(\":method\", \"GET\")\n\t\t\tah:append(\":scheme\", \"http\")\n\t\t\tah:append(\":authority\", \"myauthority\")\n\t\t\tah:append(\":path\", \"/a\")\n\t\t\tassert(a:write_headers(ah, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tclient_sync:signal(); client_sync = nil;\n\t\t\tlocal b = client:new_stream()\n\t\t\tlocal bh = new_headers()\n\t\t\tbh:append(\":method\", \"POST\")\n\t\t\tbh:append(\":scheme\", \"http\")\n\t\t\tbh:append(\":authority\", \"myauthority\")\n\t\t\tbh:append(\":path\", \"/b\")\n\t\t\tassert(b:write_headers(bh, false))\n\t\t\tcqueues.sleep(0.01)\n\t\t\tassert(b:write_chunk(\"this is some POST data\", true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal c = client:new_stream()\n\t\t\tlocal ch = new_headers()\n\t\t\tch:append(\":method\", \"GET\")\n\t\t\tch:append(\":scheme\", \"http\")\n\t\t\tch:append(\":authority\", \"myauthority\")\n\t\t\tch:append(\":path\", \"/c\")\n\t\t\tassert(c:write_headers(ch, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\t-- All requests read; now for responses\n\t\t-- Don't want /a to be first.\n\t\tlocal server_sync = cc.new()\n\t\tcq:wrap(function()\n\t\t\tif server_sync then server_sync:wait() end\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/a\"]:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tserver_sync:signal(); server_sync = nil;\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/b\"]:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tif server_sync then server_sync:wait() end\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(streams[\"/c\"]:write_headers(h, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"modifying pipelined headers doesn't affect what's sent\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal b = client:new_stream()\n\t\t\tlocal c = client:new_stream()\n\n\t\t\tdo\n\t\t\t\tlocal h = new_headers()\n\t\t\t\th:append(\":method\", \"POST\")\n\t\t\t\th:append(\":scheme\", \"http\")\n\t\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\t\th:append(\":path\", \"/\")\n\t\t\t\th:upsert(\"id\", \"a\")\n\t\t\t\tassert(a:write_headers(h, false))\n\t\t\t\tcq:wrap(function()\n\t\t\t\t\tcq:wrap(function()\n\t\t\t\t\t\tcq:wrap(function()\n\t\t\t\t\t\t\tassert(a:write_chunk(\"a\", true))\n\t\t\t\t\t\tend)\n\t\t\t\t\t\th:upsert(\"id\", \"c\")\n\t\t\t\t\t\tassert(c:write_headers(h, false))\n\t\t\t\t\t\tassert(c:write_chunk(\"c\", true))\n\t\t\t\t\tend)\n\t\t\t\t\th:upsert(\"id\", \"b\")\n\t\t\t\t\tassert(b:write_headers(h, false))\n\t\t\t\t\tassert(b:write_chunk(\"b\", true))\n\t\t\t\tend)\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(a:get_headers())\n\t\t\t\tassert.same(\"a\", h:get \"id\")\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(b:get_headers())\n\t\t\t\tassert.same(\"b\", h:get \"id\")\n\t\t\tend\n\t\t\tdo\n\t\t\t\tlocal h = assert(c:get_headers())\n\t\t\t\tassert.same(\"c\", h:get \"id\")\n\t\t\tend\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\n\t\t\tlocal a = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"a\", assert(a:get_headers()):get \"id\")\n\t\t\tassert.same(\"a\", a:get_body_as_string())\n\t\t\tcq:wrap(function()\n\t\t\t\th:upsert(\"id\", \"a\")\n\t\t\t\tassert(a:write_headers(h, true))\n\t\t\tend)\n\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"b\", assert(b:get_headers()):get \"id\")\n\t\t\tassert.same(\"b\", b:get_body_as_string())\n\t\t\th:upsert(\"id\", \"b\")\n\t\t\tassert(b:write_headers(h, true))\n\n\t\t\tlocal c = assert(server:get_next_incoming_stream())\n\t\t\tassert.same(\"c\", assert(c:get_headers()):get \"id\")\n\t\t\tassert.same(\"c\", c:get_body_as_string())\n\t\t\tassert(c:get_headers())\n\t\t\th:upsert(\"id\", \"c\")\n\t\t\tassert(c:write_headers(h, true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"allows 100 continue\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":method\", \"POST\")\n\t\t\th:append(\":scheme\", \"http\")\n\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\th:append(\":path\", \"/a\")\n\t\t\th:append(\"expect\", \"100-continue\")\n\t\t\tassert(a:write_headers(h, false))\n\t\t\tassert(assert(a:get_headers()):get(\":status\") == \"100\")\n\t\t\tassert(a:write_chunk(\"body\", true))\n\t\t\tassert(assert(a:get_headers()):get(\":status\") == \"200\")\n\t\t\tassert(a:get_next_chunk() == \"done\")\n\t\t\tassert.same({}, {a:get_next_chunk()})\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tassert(b:get_headers())\n\t\t\tassert(b:write_continue())\n\t\t\tassert(b:get_next_chunk() == \"body\")\n\t\t\tassert.same({}, {b:get_next_chunk()})\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":status\", \"200\")\n\t\t\tassert(b:write_headers(h, false))\n\t\t\tassert(b:write_chunk(\"done\", true))\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\n\tit(\"doesn't allow sending body before headers\", function()\n\t\tlocal server, client = new_pair(1.1)\n\t\tlocal cq = cqueues.new()\n\t\tcq:wrap(function()\n\t\t\tlocal a = client:new_stream()\n\t\t\tlocal h = new_headers()\n\t\t\th:append(\":method\", \"GET\")\n\t\t\th:append(\":scheme\", \"http\")\n\t\t\th:append(\":authority\", \"myauthority\")\n\t\t\th:append(\":path\", \"/\")\n\t\t\tassert(a:write_headers(h, true))\n\t\tend)\n\t\tcq:wrap(function()\n\t\t\tlocal b = assert(server:get_next_incoming_stream())\n\t\t\tb.use_zlib = false\n\t\t\tassert(b:get_headers())\n\t\t\tassert.has.errors(function() b:write_chunk(\"\", true) end)\n\t\tend)\n\t\tassert_loop(cq, TEST_TIMEOUT)\n\t\tassert.truthy(cq:empty())\n\t\tserver:close()\n\t\tclient:close()\n\tend)\nend)\n"], "filenames": ["http/h1_stream.lua", "spec/h1_stream_spec.lua"], "buggy_code_start_loc": [863, 291], "buggy_code_end_loc": [863, 291], "fixing_code_start_loc": [864, 292], "fixing_code_end_loc": [866, 319], "type": "CWE-755", "message": "Improper Handling of Exceptional Conditions vulnerability in Daurnimator lua-http library allows Excessive Allocation and a denial of service (DoS) attack to be executed by sending a properly crafted request to the server. \n\nThis issue affects lua-http: all versions before commit ddab283.", "other": {"cve": {"id": "CVE-2023-4540", "sourceIdentifier": "cvd@cert.pl", "published": "2023-09-05T08:15:40.017", "lastModified": "2023-10-13T01:30:13.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Handling of Exceptional Conditions vulnerability in Daurnimator lua-http library allows Excessive Allocation and a denial of service (DoS) attack to be executed by sending a properly crafted request to the server. \n\nThis issue affects lua-http: all versions before commit ddab283."}, {"lang": "es", "value": "Una vulnerabilidad de Manejo Inadecuado de Condiciones Excepcionales en la librer\u00eda lua-http de Daurnimator permite la asignaci\u00f3n excesiva y la ejecuci\u00f3n de un ataque de Denegaci\u00f3n de Servicio (DoS)  mediante el env\u00edo de una petici\u00f3n correctamente manipulada al servidor. Este problema afecta a lua-http: todas las versiones anteriores al commit ddab283. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "cvd@cert.pl", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:daurnimator:lua-http:0.4:*:*:*:*:lua:*:*", "matchCriteriaId": "D337EBD6-A704-44C0-8533-1EA9B5366780"}]}]}], "references": [{"url": "https://cert.pl/posts/2023/09/CVE-2023-4540/", "source": "cvd@cert.pl", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/daurnimator/lua-http/commit/ddab2835c583d45dec62680ca8d3cbde55e0bae6", "source": "cvd@cert.pl", "tags": ["Patch"]}, {"url": "https://https://cert.pl/en/posts/2023/09/CVE-2023-4540/", "source": "cvd@cert.pl", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/daurnimator/lua-http/commit/ddab2835c583d45dec62680ca8d3cbde55e0bae6"}}