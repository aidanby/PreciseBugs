{"buggy_code": ["#include \"Limelight-internal.h\"\n#include \"Rtsp.h\"\n\n#define RTSP_CONNECT_TIMEOUT_SEC 10\n#define RTSP_RECEIVE_TIMEOUT_SEC 15\n#define RTSP_RETRY_DELAY_MS 500\n\nstatic int currentSeqNumber;\nstatic char rtspTargetUrl[256];\nstatic char* sessionIdString;\nstatic bool hasSessionId;\nstatic int rtspClientVersion;\nstatic char urlAddr[URLSAFESTRING_LEN];\nstatic bool useEnet;\nstatic char* controlStreamId;\n\nstatic SOCKET sock = INVALID_SOCKET;\nstatic ENetHost* client;\nstatic ENetPeer* peer;\n\n#define CHAR_TO_INT(x) ((x) - '0')\n#define CHAR_IS_DIGIT(x) ((x) >= '0' && (x) <= '9')\n\n// Create RTSP Option\nstatic POPTION_ITEM createOptionItem(char* option, char* content)\n{\n    POPTION_ITEM item = malloc(sizeof(*item));\n    if (item == NULL) {\n        return NULL;\n    }\n\n    item->option = strdup(option);\n    if (item->option == NULL) {\n        free(item);\n        return NULL;\n    }\n\n    item->content = strdup(content);\n    if (item->content == NULL) {\n        free(item->option);\n        free(item);\n        return NULL;\n    }\n\n    item->next = NULL;\n    item->flags = FLAG_ALLOCATED_OPTION_FIELDS;\n\n    return item;\n}\n\n// Add an option to the RTSP Message\nstatic bool addOption(PRTSP_MESSAGE msg, char* option, char* content)\n{\n    POPTION_ITEM item = createOptionItem(option, content);\n    if (item == NULL) {\n        return false;\n    }\n\n    insertOption(&msg->options, item);\n    msg->flags |= FLAG_ALLOCATED_OPTION_ITEMS;\n\n    return true;\n}\n\n// Create an RTSP Request\nstatic bool initializeRtspRequest(PRTSP_MESSAGE msg, char* command, char* target)\n{\n    char sequenceNumberStr[16];\n    char clientVersionStr[16];\n\n    // FIXME: Hacked CSeq attribute due to RTSP parser bug\n    createRtspRequest(msg, NULL, 0, command, target, \"RTSP/1.0\",\n        0, NULL, NULL, 0);\n\n    snprintf(sequenceNumberStr, sizeof(sequenceNumberStr), \"%d\", currentSeqNumber++);\n    snprintf(clientVersionStr, sizeof(clientVersionStr), \"%d\", rtspClientVersion);\n    if (!addOption(msg, \"CSeq\", sequenceNumberStr) ||\n        !addOption(msg, \"X-GS-ClientVersion\", clientVersionStr) ||\n        (!useEnet && !addOption(msg, \"Host\", urlAddr))) {\n        freeMessage(msg);\n        return false;\n    }\n\n    return true;\n}\n\n// Send RTSP message and get response over ENet\nstatic bool transactRtspMessageEnet(PRTSP_MESSAGE request, PRTSP_MESSAGE response, bool expectingPayload, int* error) {\n    ENetEvent event;\n    char* serializedMessage;\n    int messageLen;\n    int offset;\n    ENetPacket* packet;\n    char* payload;\n    int payloadLength;\n    bool ret;\n    char* responseBuffer;\n\n    *error = -1;\n    ret = false;\n    responseBuffer = NULL;\n\n    // We're going to handle the payload separately, so temporarily set the payload to NULL\n    payload = request->payload;\n    payloadLength = request->payloadLength;\n    request->payload = NULL;\n    request->payloadLength = 0;\n    \n    // Serialize the RTSP message into a message buffer\n    serializedMessage = serializeRtspMessage(request, &messageLen);\n    if (serializedMessage == NULL) {\n        goto Exit;\n    }\n    \n    // Create the reliable packet that describes our outgoing message\n    packet = enet_packet_create(serializedMessage, messageLen, ENET_PACKET_FLAG_RELIABLE);\n    if (packet == NULL) {\n        goto Exit;\n    }\n    \n    // Send the message\n    if (enet_peer_send(peer, 0, packet) < 0) {\n        enet_packet_destroy(packet);\n        goto Exit;\n    }\n    enet_host_flush(client);\n\n    // If we have a payload to send, we'll need to send that separately\n    if (payload != NULL) {\n        packet = enet_packet_create(payload, payloadLength, ENET_PACKET_FLAG_RELIABLE);\n        if (packet == NULL) {\n            goto Exit;\n        }\n\n        // Send the payload\n        if (enet_peer_send(peer, 0, packet) < 0) {\n            enet_packet_destroy(packet);\n            goto Exit;\n        }\n        \n        enet_host_flush(client);\n    }\n    \n    // Wait for a reply\n    if (serviceEnetHost(client, &event, RTSP_RECEIVE_TIMEOUT_SEC * 1000) <= 0 ||\n        event.type != ENET_EVENT_TYPE_RECEIVE) {\n        Limelog(\"Failed to receive RTSP reply\\n\");\n        goto Exit;\n    }\n\n    responseBuffer = malloc(event.packet->dataLength);\n    if (responseBuffer == NULL) {\n        Limelog(\"Failed to allocate RTSP response buffer\\n\");\n        enet_packet_destroy(event.packet);\n        goto Exit;\n    }\n\n    // Copy the data out and destroy the packet\n    memcpy(responseBuffer, event.packet->data, event.packet->dataLength);\n    offset = (int) event.packet->dataLength;\n    enet_packet_destroy(event.packet);\n\n    // Wait for the payload if we're expecting some\n    if (expectingPayload) {\n        // The payload comes in a second packet\n        if (serviceEnetHost(client, &event, RTSP_RECEIVE_TIMEOUT_SEC * 1000) <= 0 ||\n            event.type != ENET_EVENT_TYPE_RECEIVE) {\n            Limelog(\"Failed to receive RTSP reply payload\\n\");\n            goto Exit;\n        }\n\n        responseBuffer = extendBuffer(responseBuffer, event.packet->dataLength + offset);\n        if (responseBuffer == NULL) {\n            Limelog(\"Failed to extend RTSP response buffer\\n\");\n            enet_packet_destroy(event.packet);\n            goto Exit;\n        }\n\n        // Copy the payload out to the end of the response buffer and destroy the packet\n        memcpy(&responseBuffer[offset], event.packet->data, event.packet->dataLength);\n        offset += (int) event.packet->dataLength;\n        enet_packet_destroy(event.packet);\n    }\n        \n    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {\n        // Successfully parsed response\n        ret = true;\n    }\n    else {\n        Limelog(\"Failed to parse RTSP response\\n\");\n    }\n\nExit:\n    // Swap back the payload pointer to avoid leaking memory later\n    request->payload = payload;\n    request->payloadLength = payloadLength;\n\n    // Free the serialized buffer\n    if (serializedMessage != NULL) {\n        free(serializedMessage);\n    }\n\n    // Free the response buffer\n    if (responseBuffer != NULL) {\n        free(responseBuffer);\n    }\n\n    return ret;\n}\n\n// Send RTSP message and get response over TCP\nstatic bool transactRtspMessageTcp(PRTSP_MESSAGE request, PRTSP_MESSAGE response, int* error) {\n    SOCK_RET err;\n    bool ret;\n    int offset;\n    char* serializedMessage = NULL;\n    int messageLen;\n    char* responseBuffer;\n    int responseBufferSize;\n    int connectRetries;\n\n    *error = -1;\n    ret = false;\n    responseBuffer = NULL;\n    connectRetries = 0;\n\n    // Retry up to 10 seconds if we receive ECONNREFUSED errors from the host PC.\n    // This can happen with GFE 3.22 when initially launching a session because it\n    // returns HTTP 200 OK for the /launch request before the RTSP handshake port\n    // is listening.\n    do {\n        sock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, RtspPortNumber, RTSP_CONNECT_TIMEOUT_SEC);\n        if (sock == INVALID_SOCKET) {\n            *error = LastSocketError();\n            if (*error == ECONNREFUSED) {\n                // Try again after 500 ms on ECONNREFUSED\n                PltSleepMs(RTSP_RETRY_DELAY_MS);\n            }\n            else {\n                // Fail if we get some other error\n                break;\n            }\n        }\n        else {\n            // We successfully connected\n            break;\n        }\n    } while (connectRetries++ < (RTSP_CONNECT_TIMEOUT_SEC * 1000) / RTSP_RETRY_DELAY_MS && !ConnectionInterrupted);\n    if (sock == INVALID_SOCKET) {\n        return ret;\n    }\n\n    serializedMessage = serializeRtspMessage(request, &messageLen);\n    if (serializedMessage == NULL) {\n        closeSocket(sock);\n        sock = INVALID_SOCKET;\n        return ret;\n    }\n\n    // Send our message split into smaller chunks to avoid MTU issues.\n    // enableNoDelay() must have been called for sendMtuSafe() to work.\n    enableNoDelay(sock);\n    err = sendMtuSafe(sock, serializedMessage, messageLen);\n    if (err == SOCKET_ERROR) {\n        *error = LastSocketError();\n        Limelog(\"Failed to send RTSP message: %d\\n\", *error);\n        goto Exit;\n    }\n\n    // Read the response until the server closes the connection\n    offset = 0;\n    responseBufferSize = 0;\n    for (;;) {\n        struct pollfd pfd;\n\n        if (offset >= responseBufferSize) {\n            responseBufferSize = offset + 16384;\n            responseBuffer = extendBuffer(responseBuffer, responseBufferSize);\n            if (responseBuffer == NULL) {\n                Limelog(\"Failed to allocate RTSP response buffer\\n\");\n                goto Exit;\n            }\n        }\n\n        pfd.fd = sock;\n        pfd.events = POLLIN;\n        err = pollSockets(&pfd, 1, RTSP_RECEIVE_TIMEOUT_SEC * 1000);\n        if (err == 0) {\n            *error = ETIMEDOUT;\n            Limelog(\"RTSP request timed out\\n\");\n            goto Exit;\n        }\n        else if (err < 0) {\n            *error = LastSocketError();\n            Limelog(\"Failed to wait for RTSP response: %d\\n\", *error);\n            goto Exit;\n        }\n\n        err = recv(sock, &responseBuffer[offset], responseBufferSize - offset, 0);\n        if (err < 0) {\n            // Error reading\n            *error = LastSocketError();\n            Limelog(\"Failed to read RTSP response: %d\\n\", *error);\n            goto Exit;\n        }\n        else if (err == 0) {\n            // Done reading\n            break;\n        }\n        else {\n            offset += err;\n        }\n    }\n\n    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {\n        // Successfully parsed response\n        ret = true;\n    }\n    else {\n        Limelog(\"Failed to parse RTSP response\\n\");\n    }\n\nExit:\n    if (serializedMessage != NULL) {\n        free(serializedMessage);\n    }\n\n    if (responseBuffer != NULL) {\n        free(responseBuffer);\n    }\n\n    closeSocket(sock);\n    sock = INVALID_SOCKET;\n    return ret;\n}\n\nstatic bool transactRtspMessage(PRTSP_MESSAGE request, PRTSP_MESSAGE response, bool expectingPayload, int* error) {\n    if (ConnectionInterrupted) {\n        *error = -1;\n        return false;\n    }\n\n    if (useEnet) {\n        return transactRtspMessageEnet(request, response, expectingPayload, error);\n    }\n    else {\n        return transactRtspMessageTcp(request, response, error);\n    }\n}\n\n// Send RTSP OPTIONS request\nstatic bool requestOptions(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"OPTIONS\", rtspTargetUrl);\n    if (ret) {\n        ret = transactRtspMessage(&request, response, false, error);\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP DESCRIBE request\nstatic bool requestDescribe(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"DESCRIBE\", rtspTargetUrl);\n    if (ret) {\n        if (addOption(&request, \"Accept\",\n            \"application/sdp\") &&\n            addOption(&request, \"If-Modified-Since\",\n                \"Thu, 01 Jan 1970 00:00:00 GMT\")) {\n            ret = transactRtspMessage(&request, response, true, error);\n        }\n        else {\n            ret = false;\n        }\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP SETUP request\nstatic bool setupStream(PRTSP_MESSAGE response, char* target, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n    char* transportValue;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"SETUP\", target);\n    if (ret) {\n        if (hasSessionId) {\n            if (!addOption(&request, \"Session\", sessionIdString)) {\n                ret = false;\n                goto FreeMessage;\n            }\n        }\n\n        if (AppVersionQuad[0] >= 6) {\n            // It looks like GFE doesn't care what we say our port is but\n            // we need to give it some port to successfully complete the\n            // handshake process.\n            transportValue = \"unicast;X-GS-ClientPort=50000-50001\";\n        }\n        else {\n            transportValue = \" \";\n        }\n        \n        if (addOption(&request, \"Transport\", transportValue) &&\n            addOption(&request, \"If-Modified-Since\",\n                \"Thu, 01 Jan 1970 00:00:00 GMT\")) {\n            ret = transactRtspMessage(&request, response, false, error);\n        }\n        else {\n            ret = false;\n        }\n\n    FreeMessage:\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP PLAY request\nstatic bool playStream(PRTSP_MESSAGE response, char* target, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"PLAY\", target);\n    if (ret != 0) {\n        if (addOption(&request, \"Session\", sessionIdString)) {\n            ret = transactRtspMessage(&request, response, false, error);\n        }\n        else {\n            ret = false;\n        }\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP ANNOUNCE message\nstatic bool sendVideoAnnounce(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n    int payloadLength;\n    char payloadLengthStr[16];\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"ANNOUNCE\",\n                                APP_VERSION_AT_LEAST(7, 1, 431) ? controlStreamId : \"streamid=video\");\n    if (ret) {\n        ret = false;\n\n        if (!addOption(&request, \"Session\", sessionIdString) ||\n            !addOption(&request, \"Content-type\", \"application/sdp\")) {\n            goto FreeMessage;\n        }\n\n        request.payload = getSdpPayloadForStreamConfig(rtspClientVersion, &payloadLength);\n        if (request.payload == NULL) {\n            goto FreeMessage;\n        }\n        request.flags |= FLAG_ALLOCATED_PAYLOAD;\n        request.payloadLength = payloadLength;\n\n        snprintf(payloadLengthStr, sizeof(payloadLengthStr), \"%d\", payloadLength);\n        if (!addOption(&request, \"Content-length\", payloadLengthStr)) {\n            goto FreeMessage;\n        }\n\n        ret = transactRtspMessage(&request, response, false, error);\n\n    FreeMessage:\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\nstatic int parseOpusConfigFromParamString(char* paramStr, int channelCount, POPUS_MULTISTREAM_CONFIGURATION opusConfig) {\n    int i;\n\n    // Set channel count (included in the prefix, so not parsed below)\n    opusConfig->channelCount = channelCount;\n\n    // Parse the remaining data from the surround-params value\n    if (!CHAR_IS_DIGIT(*paramStr)) {\n        Limelog(\"Invalid stream count: %c\\n\", *paramStr);\n        return -1;\n    }\n    opusConfig->streams = CHAR_TO_INT(*paramStr);\n    paramStr++;\n\n    if (!CHAR_IS_DIGIT(*paramStr)) {\n        Limelog(\"Invalid coupled stream count: %c\\n\", *paramStr);\n        return -2;\n    }\n    opusConfig->coupledStreams = CHAR_TO_INT(*paramStr);\n    paramStr++;\n\n    for (i = 0; i < opusConfig->channelCount; i++) {\n        if (!CHAR_IS_DIGIT(*paramStr)) {\n            Limelog(\"Invalid mapping value at %d: %c\\n\", i, *paramStr);\n            return -3;\n        }\n\n        opusConfig->mapping[i] = CHAR_TO_INT(*paramStr);\n        paramStr++;\n    }\n\n    return 0;\n}\n\n// Parse the server port from the Transport header\n// Example: unicast;server_port=48000-48001;source=192.168.35.177\nstatic bool parseServerPortFromTransport(PRTSP_MESSAGE response, uint16_t* port) {\n    char* transport;\n    char* portStart;\n\n    transport = getOptionContent(response->options, \"Transport\");\n    if (transport == NULL) {\n        return false;\n    }\n\n    // Look for the server_port= entry in the Transport option\n    portStart = strstr(transport, \"server_port=\");\n    if (portStart == NULL) {\n        return false;\n    }\n\n    // Skip the prefix\n    portStart += strlen(\"server_port=\");\n\n    // Validate the port number\n    long int rawPort = strtol(portStart, NULL, 10);\n    if (rawPort <= 0 || rawPort > 65535) {\n        return false;\n    }\n\n    *port = (uint16_t)rawPort;\n    return true;\n}\n\n// Parses the Opus configuration from an RTSP DESCRIBE response\nstatic int parseOpusConfigurations(PRTSP_MESSAGE response) {\n    HighQualitySurroundSupported = false;\n    memset(&NormalQualityOpusConfig, 0, sizeof(NormalQualityOpusConfig));\n    memset(&HighQualityOpusConfig, 0, sizeof(HighQualityOpusConfig));\n\n    // Sample rate is always 48 KHz\n    HighQualityOpusConfig.sampleRate = NormalQualityOpusConfig.sampleRate = 48000;\n\n    // Stereo doesn't have any surround-params elements in the RTSP data\n    if (CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) == 2) {\n        NormalQualityOpusConfig.channelCount = 2;\n        NormalQualityOpusConfig.streams = 1;\n        NormalQualityOpusConfig.coupledStreams = 1;\n        NormalQualityOpusConfig.mapping[0] = 0;\n        NormalQualityOpusConfig.mapping[1] = 1;\n    }\n    else {\n        char paramsPrefix[128];\n        char* paramStart;\n        int err;\n        int channelCount;\n\n        channelCount = CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration);\n\n        // Find the correct audio parameter value\n        snprintf(paramsPrefix, sizeof(paramsPrefix), \"a=fmtp:97 surround-params=%d\", channelCount);\n        paramStart = strstr(response->payload, paramsPrefix);\n        if (paramStart) {\n            // Skip the prefix\n            paramStart += strlen(paramsPrefix);\n\n            // Parse the normal quality Opus config\n            err = parseOpusConfigFromParamString(paramStart, channelCount, &NormalQualityOpusConfig);\n            if (err != 0) {\n                return err;\n            }\n\n            // GFE's normal-quality channel mapping differs from the one our clients use.\n            // They use FL FR C RL RR SL SR LFE, but we use FL FR C LFE RL RR SL SR. We'll need\n            // to swap the mappings to match the expected values.\n            if (channelCount == 6 || channelCount == 8) {\n                OPUS_MULTISTREAM_CONFIGURATION originalMapping = NormalQualityOpusConfig;\n\n                // LFE comes after C\n                NormalQualityOpusConfig.mapping[3] = originalMapping.mapping[channelCount - 1];\n\n                // Slide everything else up\n                memcpy(&NormalQualityOpusConfig.mapping[4],\n                       &originalMapping.mapping[3],\n                       channelCount - 4);\n            }\n\n            // If this configuration is compatible with high quality mode, we may have another\n            // matching surround-params value for high quality mode.\n            paramStart = strstr(paramStart, paramsPrefix);\n            if (paramStart) {\n                // Skip the prefix\n                paramStart += strlen(paramsPrefix);\n\n                // Parse the high quality Opus config\n                err = parseOpusConfigFromParamString(paramStart, channelCount, &HighQualityOpusConfig);\n                if (err != 0) {\n                    return err;\n                }\n\n                // We can request high quality audio\n                HighQualitySurroundSupported = true;\n            }\n        }\n        else {\n            Limelog(\"No surround parameters found for channel count: %d\\n\", channelCount);\n\n            // It's unknown whether all GFE versions that supported surround sound included these\n            // surround sound parameters. In case they didn't, we'll specifically handle 5.1 surround\n            // sound using a hardcoded configuration like we used to before this parsing code existed.\n            //\n            // It is not necessary to provide HighQualityOpusConfig here because high quality mode\n            // can only be enabled from seeing the required \"surround-params=\" value, so there's no\n            // chance it could regress from implementing this parser.\n            if (channelCount == 6) {\n                NormalQualityOpusConfig.channelCount = 6;\n                NormalQualityOpusConfig.streams = 4;\n                NormalQualityOpusConfig.coupledStreams = 2;\n                NormalQualityOpusConfig.mapping[0] = 0;\n                NormalQualityOpusConfig.mapping[1] = 4;\n                NormalQualityOpusConfig.mapping[2] = 1;\n                NormalQualityOpusConfig.mapping[3] = 5;\n                NormalQualityOpusConfig.mapping[4] = 2;\n                NormalQualityOpusConfig.mapping[5] = 3;\n            }\n            else {\n                // We don't have a hardcoded fallback mapping, so we have no choice but to fail.\n                return -4;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n\n    // Create a copy that we can modify\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n\n    // If we have a v6 address, we want to stop one character after the closing ]\n    // If we have a v4 address, we want to stop at the port separator\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n\n    // Count the prefix length to skip past the initial rtsp:// or rtspru:// part\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n\n    // If we hit the end of the string prior to parsing the prefix, we cannot proceed\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n\n    // Look for a slash at the end of the host portion of the URL (may not be present)\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n\n    // Check for a v6 address first since they also have colons\n    if (v6EscapeEndChar) {\n        // Terminate the string at the next character\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        // Terminate the string prior to the port separator\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        // Terminate the string prior to the path separator\n        *urlPathSeparator = 0;\n    }\n\n    strcpy(destination, rtspUrlScratchBuffer + prefixLen);\n\n    free(rtspUrlScratchBuffer);\n    return true;\n}\n\n// SDP attributes are in the form:\n// a=x-nv-bwe.bwuSafeZoneLowLimit:70\\r\\n\nbool parseSdpAttributeToUInt(const char* payload, const char* name, unsigned int* val) {\n    // Find the entry for the specified attribute name\n    char* attribute = strstr(payload, name);\n    if (!attribute) {\n        return false;\n    }\n\n    // Locate the start of the value\n    char* valst = strstr(attribute, \":\");\n    if (!valst) {\n        return false;\n    }\n\n    // Read the integer up to the newline at the end of the SDP attribute\n    *val = strtoul(valst + 1, NULL, 0);\n\n    return true;\n}\n\nbool parseSdpAttributeToInt(const char* payload, const char* name, int* val) {\n    // Find the entry for the specified attribute name\n    char* attribute = strstr(payload, name);\n    if (!attribute) {\n        return false;\n    }\n\n    // Locate the start of the value\n    char* valst = strstr(attribute, \":\");\n    if (!valst) {\n        return false;\n    }\n\n    // Read the integer up to the newline at the end of the SDP attribute\n    *val = strtol(valst + 1, NULL, 0);\n\n    return true;\n}\n\n// Perform RTSP Handshake with the streaming server machine as part of the connection process\nint performRtspHandshake(PSERVER_INFORMATION serverInfo) {\n    int ret;\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    // Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control/13/0\" : \"streamid=control/1/0\";\n    AudioEncryptionEnabled = false;\n\n    // HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    // fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    // that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    // thinks you are remote (target address != any local address).\n    //\n    // We will enable high quality audio if the following are all true:\n    // 1. Video bitrate is higher than 15 Mbps (to ensure most bandwidth is reserved for video)\n    // 2. The audio decoder has not declared that it is slow\n    // 3. The stream is either local or not surround sound (to prevent MTU issues over the Internet)\n    LC_ASSERT(StreamConfig.streamingRemotely != STREAM_CFG_AUTO);\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0 &&\n            (StreamConfig.streamingRemotely != STREAM_CFG_REMOTE || CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) <= 2)) {\n        // If we have an RTSP URL string and it was successfully parsed, use that string\n        if (serverInfo->rtspSessionUrl != NULL && parseUrlAddrFromRtspUrlString(serverInfo->rtspSessionUrl, urlAddr)) {\n            strcpy(rtspTargetUrl, serverInfo->rtspSessionUrl);\n        }\n        else {\n            // If an RTSP URL string was not provided or failed to parse, we will construct one now as best we can.\n            //\n            // NB: If the remote address is not a LAN address, the host will likely not enable high quality\n            // audio since it only does that for local streaming normally. We can avoid this limitation,\n            // but only if the caller gave us the RTSP session URL that it received from the host during launch.\n            addrToUrlSafeString(&RemoteAddr, urlAddr, sizeof(urlAddr));\n            sprintf(rtspTargetUrl, \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n        }\n    }\n    else {\n        PltSafeStrcpy(urlAddr, sizeof(urlAddr), \"0.0.0.0\");\n        sprintf(rtspTargetUrl, \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    }\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;\n            break;\n        case 6:\n            // Gen 6 has never been seen in the wild\n            rtspClientVersion = 13;\n            break;\n        case 7:\n        default:\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    // Setup ENet if required by this GFE version\n    if (useEnet) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, RtspPortNumber);\n        \n        // Create a client that can use 1 outgoing connection and 1 channel\n        client = enet_host_create(RemoteAddr.ss_family, NULL, 1, 1, 0, 0);\n        if (client == NULL) {\n            return -1;\n        }\n    \n        // Connect to the host\n        peer = enet_host_connect(client, &address, 1, 0);\n        if (peer == NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n            return -1;\n        }\n    \n        // Wait for the connect to complete\n        if (serviceEnetHost(client, &event, RTSP_CONNECT_TIMEOUT_SEC * 1000) <= 0 ||\n            event.type != ENET_EVENT_TYPE_CONNECT) {\n            Limelog(\"RTSP: Failed to connect to UDP port %u\\n\", RtspPortNumber);\n            enet_peer_reset(peer);\n            peer = NULL;\n            enet_host_destroy(client);\n            client = NULL;\n            return -1;\n        }\n\n        // Ensure the connect verify ACK is sent immediately\n        enet_host_flush(client);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!requestOptions(&response, &error)) {\n            Limelog(\"RTSP OPTIONS request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP OPTIONS request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!requestDescribe(&response, &error)) {\n            Limelog(\"RTSP DESCRIBE request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP DESCRIBE request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n        \n        if ((StreamConfig.supportedVideoFormats & VIDEO_FORMAT_MASK_AV1) && strstr(response.payload, \"AV1/90000\")) {\n            if ((serverInfo->serverCodecModeSupport & SCM_AV1_MAIN10) && (StreamConfig.supportedVideoFormats & VIDEO_FORMAT_AV1_MAIN10)) {\n                NegotiatedVideoFormat = VIDEO_FORMAT_AV1_MAIN10;\n            }\n            else {\n                NegotiatedVideoFormat = VIDEO_FORMAT_AV1_MAIN8;\n\n                // Apply bitrate adjustment for SDR AV1 if the client requested one\n                if (StreamConfig.av1BitratePercentageMultiplier != 0) {\n                    StreamConfig.bitrate *= StreamConfig.av1BitratePercentageMultiplier;\n                    StreamConfig.bitrate /= 100;\n                }\n            }\n        }\n        else if ((StreamConfig.supportedVideoFormats & VIDEO_FORMAT_MASK_H265) && strstr(response.payload, \"sprop-parameter-sets=AAAAAU\")) {\n            // The RTSP DESCRIBE reply will contain a collection of SDP media attributes that\n            // describe the various supported video stream formats and include the SPS, PPS,\n            // and VPS (if applicable). We will use this information to determine whether the\n            // server can support HEVC. For some reason, they still set the MIME type of the HEVC\n            // format to H264, so we can't just look for the HEVC MIME type. What we'll do instead is\n            // look for the base 64 encoded VPS NALU prefix that is unique to the HEVC bitstream.\n            if ((serverInfo->serverCodecModeSupport & SCM_HEVC_MAIN10) && (StreamConfig.supportedVideoFormats & VIDEO_FORMAT_H265_MAIN10)) {\n                NegotiatedVideoFormat = VIDEO_FORMAT_H265_MAIN10;\n            }\n            else {\n                NegotiatedVideoFormat = VIDEO_FORMAT_H265;\n\n                // Apply bitrate adjustment for SDR HEVC if the client requested one\n                if (StreamConfig.hevcBitratePercentageMultiplier != 0) {\n                    StreamConfig.bitrate *= StreamConfig.hevcBitratePercentageMultiplier;\n                    StreamConfig.bitrate /= 100;\n                }\n            }\n        }\n        else {\n            NegotiatedVideoFormat = VIDEO_FORMAT_H264;\n\n            // Dimensions over 4096 are only supported with HEVC on NVENC\n            if (StreamConfig.width > 4096 || StreamConfig.height > 4096) {\n                Limelog(\"WARNING: Host PC doesn't support HEVC. Streaming at resolutions above 4K using H.264 will likely fail!\\n\");\n            }\n        }\n\n        // Look for the SDP attribute that indicates we're dealing with a server that supports RFI\n        ReferenceFrameInvalidationSupported = strstr(response.payload, \"x-nv-video[0].refPicInvalidation\") != NULL;\n        if (!ReferenceFrameInvalidationSupported) {\n            Limelog(\"Reference frame invalidation is not supported by this host\\n\");\n        }\n\n        // Look for the Sunshine feature flags in the SDP attributes\n        if (!parseSdpAttributeToUInt(response.payload, \"x-ss-general.featureFlags\", &SunshineFeatureFlags)) {\n            SunshineFeatureFlags = 0;\n        }\n\n        // Parse the Opus surround parameters out of the RTSP DESCRIBE response.\n        ret = parseOpusConfigurations(&response);\n        if (ret != 0) {\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        char* sessionId;\n        char* pingPayload;\n        int error = -1;\n        char* strtokCtx = NULL;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=audio/0/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the audio port out of the RTSP SETUP response\n        LC_ASSERT(AudioPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &AudioPortNumber)) {\n            // Use the well known port if parsing fails\n            AudioPortNumber = 48000;\n\n            Limelog(\"Audio port: %u (RTSP parsing failed)\\n\", AudioPortNumber);\n        }\n        else {\n            Limelog(\"Audio port: %u\\n\", AudioPortNumber);\n        }\n\n        // Parse the Sunshine ping payload protocol extension if present\n        memset(&AudioPingPayload, 0, sizeof(AudioPingPayload));\n        pingPayload = getOptionContent(response.options, \"X-SS-Ping-Payload\");\n        if (pingPayload != NULL && strlen(pingPayload) == sizeof(AudioPingPayload.payload)) {\n            memcpy(AudioPingPayload.payload, pingPayload, sizeof(AudioPingPayload.payload));\n        }\n\n        // Let the audio stream know the port number is now finalized.\n        // NB: This is needed because audio stream init happens before RTSP,\n        // which is not the case for the video stream.\n        notifyAudioPortNegotiationComplete();\n\n        sessionId = getOptionContent(response.options, \"Session\");\n\n        if (sessionId == NULL) {\n            Limelog(\"RTSP SETUP streamid=audio is missing session attribute\\n\");\n            ret = -1;\n            goto Exit;\n        }\n\n        // Given there is a non-null session id, get the\n        // first token of the session until \";\", which \n        // resolves any 454 session not found errors on\n        // standard RTSP server implementations.\n        // (i.e - sessionId = \"DEADBEEFCAFE;timeout = 90\") \n        sessionIdString = strdup(strtok_r(sessionId, \";\", &strtokCtx));\n        if (sessionIdString == NULL) {\n            Limelog(\"Failed to duplicate session ID string\\n\");\n            ret = -1;\n            goto Exit;\n        }\n\n        hasSessionId = true;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n        char* pingPayload;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=video/0/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the Sunshine ping payload protocol extension if present\n        memset(&VideoPingPayload, 0, sizeof(VideoPingPayload));\n        pingPayload = getOptionContent(response.options, \"X-SS-Ping-Payload\");\n        if (pingPayload != NULL && strlen(pingPayload) == sizeof(VideoPingPayload.payload)) {\n            memcpy(VideoPingPayload.payload, pingPayload, sizeof(VideoPingPayload.payload));\n        }\n\n        // Parse the video port out of the RTSP SETUP response\n        LC_ASSERT(VideoPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &VideoPortNumber)) {\n            // Use the well known port if parsing fails\n            VideoPortNumber = 47998;\n\n            Limelog(\"Video port: %u (RTSP parsing failed)\\n\", VideoPortNumber);\n        }\n        else {\n            Limelog(\"Video port: %u\\n\", VideoPortNumber);\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (AppVersionQuad[0] >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         controlStreamId,\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the control port out of the RTSP SETUP response\n        LC_ASSERT(ControlPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &ControlPortNumber)) {\n            // Use the well known port if parsing fails\n            ControlPortNumber = 47999;\n\n            Limelog(\"Control port: %u (RTSP parsing failed)\\n\", ControlPortNumber);\n        }\n        else {\n            Limelog(\"Control port: %u\\n\", ControlPortNumber);\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!sendVideoAnnounce(&response, &error)) {\n            Limelog(\"RTSP ANNOUNCE request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP ANNOUNCE request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    // GFE 3.22 uses a single PLAY message\n    if (APP_VERSION_AT_LEAST(7, 1, 431)) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!playStream(&response, \"/\", &error)) {\n            Limelog(\"RTSP PLAY request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP PLAY failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    else {\n        {\n            RTSP_MESSAGE response;\n            int error = -1;\n\n            if (!playStream(&response, \"streamid=video\", &error)) {\n                Limelog(\"RTSP PLAY streamid=video request failed: %d\\n\", error);\n                ret = error;\n                goto Exit;\n            }\n\n            if (response.message.response.statusCode != 200) {\n                Limelog(\"RTSP PLAY streamid=video failed: %d\\n\",\n                    response.message.response.statusCode);\n                ret = response.message.response.statusCode;\n                goto Exit;\n            }\n\n            freeMessage(&response);\n        }\n\n        {\n            RTSP_MESSAGE response;\n            int error = -1;\n\n            if (!playStream(&response, \"streamid=audio\", &error)) {\n                Limelog(\"RTSP PLAY streamid=audio request failed: %d\\n\", error);\n                ret = error;\n                goto Exit;\n            }\n\n            if (response.message.response.statusCode != 200) {\n                Limelog(\"RTSP PLAY streamid=audio failed: %d\\n\",\n                    response.message.response.statusCode);\n                ret = response.message.response.statusCode;\n                goto Exit;\n            }\n\n            freeMessage(&response);\n        }\n    }\n\n    \n    ret = 0;\n    \nExit:\n    // Cleanup the ENet stuff\n    if (useEnet) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        \n        if (client != NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n        }\n    }\n\n    if (sessionIdString != NULL) {\n        free(sessionIdString);\n        sessionIdString = NULL;\n    }\n\n    return ret;\n}\n"], "fixing_code": ["#include \"Limelight-internal.h\"\n#include \"Rtsp.h\"\n\n#define RTSP_CONNECT_TIMEOUT_SEC 10\n#define RTSP_RECEIVE_TIMEOUT_SEC 15\n#define RTSP_RETRY_DELAY_MS 500\n\nstatic int currentSeqNumber;\nstatic char rtspTargetUrl[256];\nstatic char* sessionIdString;\nstatic bool hasSessionId;\nstatic int rtspClientVersion;\nstatic char urlAddr[URLSAFESTRING_LEN];\nstatic bool useEnet;\nstatic char* controlStreamId;\n\nstatic SOCKET sock = INVALID_SOCKET;\nstatic ENetHost* client;\nstatic ENetPeer* peer;\n\n#define CHAR_TO_INT(x) ((x) - '0')\n#define CHAR_IS_DIGIT(x) ((x) >= '0' && (x) <= '9')\n\n// Create RTSP Option\nstatic POPTION_ITEM createOptionItem(char* option, char* content)\n{\n    POPTION_ITEM item = malloc(sizeof(*item));\n    if (item == NULL) {\n        return NULL;\n    }\n\n    item->option = strdup(option);\n    if (item->option == NULL) {\n        free(item);\n        return NULL;\n    }\n\n    item->content = strdup(content);\n    if (item->content == NULL) {\n        free(item->option);\n        free(item);\n        return NULL;\n    }\n\n    item->next = NULL;\n    item->flags = FLAG_ALLOCATED_OPTION_FIELDS;\n\n    return item;\n}\n\n// Add an option to the RTSP Message\nstatic bool addOption(PRTSP_MESSAGE msg, char* option, char* content)\n{\n    POPTION_ITEM item = createOptionItem(option, content);\n    if (item == NULL) {\n        return false;\n    }\n\n    insertOption(&msg->options, item);\n    msg->flags |= FLAG_ALLOCATED_OPTION_ITEMS;\n\n    return true;\n}\n\n// Create an RTSP Request\nstatic bool initializeRtspRequest(PRTSP_MESSAGE msg, char* command, char* target)\n{\n    char sequenceNumberStr[16];\n    char clientVersionStr[16];\n\n    // FIXME: Hacked CSeq attribute due to RTSP parser bug\n    createRtspRequest(msg, NULL, 0, command, target, \"RTSP/1.0\",\n        0, NULL, NULL, 0);\n\n    snprintf(sequenceNumberStr, sizeof(sequenceNumberStr), \"%d\", currentSeqNumber++);\n    snprintf(clientVersionStr, sizeof(clientVersionStr), \"%d\", rtspClientVersion);\n    if (!addOption(msg, \"CSeq\", sequenceNumberStr) ||\n        !addOption(msg, \"X-GS-ClientVersion\", clientVersionStr) ||\n        (!useEnet && !addOption(msg, \"Host\", urlAddr))) {\n        freeMessage(msg);\n        return false;\n    }\n\n    return true;\n}\n\n// Send RTSP message and get response over ENet\nstatic bool transactRtspMessageEnet(PRTSP_MESSAGE request, PRTSP_MESSAGE response, bool expectingPayload, int* error) {\n    ENetEvent event;\n    char* serializedMessage;\n    int messageLen;\n    int offset;\n    ENetPacket* packet;\n    char* payload;\n    int payloadLength;\n    bool ret;\n    char* responseBuffer;\n\n    *error = -1;\n    ret = false;\n    responseBuffer = NULL;\n\n    // We're going to handle the payload separately, so temporarily set the payload to NULL\n    payload = request->payload;\n    payloadLength = request->payloadLength;\n    request->payload = NULL;\n    request->payloadLength = 0;\n    \n    // Serialize the RTSP message into a message buffer\n    serializedMessage = serializeRtspMessage(request, &messageLen);\n    if (serializedMessage == NULL) {\n        goto Exit;\n    }\n    \n    // Create the reliable packet that describes our outgoing message\n    packet = enet_packet_create(serializedMessage, messageLen, ENET_PACKET_FLAG_RELIABLE);\n    if (packet == NULL) {\n        goto Exit;\n    }\n    \n    // Send the message\n    if (enet_peer_send(peer, 0, packet) < 0) {\n        enet_packet_destroy(packet);\n        goto Exit;\n    }\n    enet_host_flush(client);\n\n    // If we have a payload to send, we'll need to send that separately\n    if (payload != NULL) {\n        packet = enet_packet_create(payload, payloadLength, ENET_PACKET_FLAG_RELIABLE);\n        if (packet == NULL) {\n            goto Exit;\n        }\n\n        // Send the payload\n        if (enet_peer_send(peer, 0, packet) < 0) {\n            enet_packet_destroy(packet);\n            goto Exit;\n        }\n        \n        enet_host_flush(client);\n    }\n    \n    // Wait for a reply\n    if (serviceEnetHost(client, &event, RTSP_RECEIVE_TIMEOUT_SEC * 1000) <= 0 ||\n        event.type != ENET_EVENT_TYPE_RECEIVE) {\n        Limelog(\"Failed to receive RTSP reply\\n\");\n        goto Exit;\n    }\n\n    responseBuffer = malloc(event.packet->dataLength);\n    if (responseBuffer == NULL) {\n        Limelog(\"Failed to allocate RTSP response buffer\\n\");\n        enet_packet_destroy(event.packet);\n        goto Exit;\n    }\n\n    // Copy the data out and destroy the packet\n    memcpy(responseBuffer, event.packet->data, event.packet->dataLength);\n    offset = (int) event.packet->dataLength;\n    enet_packet_destroy(event.packet);\n\n    // Wait for the payload if we're expecting some\n    if (expectingPayload) {\n        // The payload comes in a second packet\n        if (serviceEnetHost(client, &event, RTSP_RECEIVE_TIMEOUT_SEC * 1000) <= 0 ||\n            event.type != ENET_EVENT_TYPE_RECEIVE) {\n            Limelog(\"Failed to receive RTSP reply payload\\n\");\n            goto Exit;\n        }\n\n        responseBuffer = extendBuffer(responseBuffer, event.packet->dataLength + offset);\n        if (responseBuffer == NULL) {\n            Limelog(\"Failed to extend RTSP response buffer\\n\");\n            enet_packet_destroy(event.packet);\n            goto Exit;\n        }\n\n        // Copy the payload out to the end of the response buffer and destroy the packet\n        memcpy(&responseBuffer[offset], event.packet->data, event.packet->dataLength);\n        offset += (int) event.packet->dataLength;\n        enet_packet_destroy(event.packet);\n    }\n        \n    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {\n        // Successfully parsed response\n        ret = true;\n    }\n    else {\n        Limelog(\"Failed to parse RTSP response\\n\");\n    }\n\nExit:\n    // Swap back the payload pointer to avoid leaking memory later\n    request->payload = payload;\n    request->payloadLength = payloadLength;\n\n    // Free the serialized buffer\n    if (serializedMessage != NULL) {\n        free(serializedMessage);\n    }\n\n    // Free the response buffer\n    if (responseBuffer != NULL) {\n        free(responseBuffer);\n    }\n\n    return ret;\n}\n\n// Send RTSP message and get response over TCP\nstatic bool transactRtspMessageTcp(PRTSP_MESSAGE request, PRTSP_MESSAGE response, int* error) {\n    SOCK_RET err;\n    bool ret;\n    int offset;\n    char* serializedMessage = NULL;\n    int messageLen;\n    char* responseBuffer;\n    int responseBufferSize;\n    int connectRetries;\n\n    *error = -1;\n    ret = false;\n    responseBuffer = NULL;\n    connectRetries = 0;\n\n    // Retry up to 10 seconds if we receive ECONNREFUSED errors from the host PC.\n    // This can happen with GFE 3.22 when initially launching a session because it\n    // returns HTTP 200 OK for the /launch request before the RTSP handshake port\n    // is listening.\n    do {\n        sock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, RtspPortNumber, RTSP_CONNECT_TIMEOUT_SEC);\n        if (sock == INVALID_SOCKET) {\n            *error = LastSocketError();\n            if (*error == ECONNREFUSED) {\n                // Try again after 500 ms on ECONNREFUSED\n                PltSleepMs(RTSP_RETRY_DELAY_MS);\n            }\n            else {\n                // Fail if we get some other error\n                break;\n            }\n        }\n        else {\n            // We successfully connected\n            break;\n        }\n    } while (connectRetries++ < (RTSP_CONNECT_TIMEOUT_SEC * 1000) / RTSP_RETRY_DELAY_MS && !ConnectionInterrupted);\n    if (sock == INVALID_SOCKET) {\n        return ret;\n    }\n\n    serializedMessage = serializeRtspMessage(request, &messageLen);\n    if (serializedMessage == NULL) {\n        closeSocket(sock);\n        sock = INVALID_SOCKET;\n        return ret;\n    }\n\n    // Send our message split into smaller chunks to avoid MTU issues.\n    // enableNoDelay() must have been called for sendMtuSafe() to work.\n    enableNoDelay(sock);\n    err = sendMtuSafe(sock, serializedMessage, messageLen);\n    if (err == SOCKET_ERROR) {\n        *error = LastSocketError();\n        Limelog(\"Failed to send RTSP message: %d\\n\", *error);\n        goto Exit;\n    }\n\n    // Read the response until the server closes the connection\n    offset = 0;\n    responseBufferSize = 0;\n    for (;;) {\n        struct pollfd pfd;\n\n        if (offset >= responseBufferSize) {\n            responseBufferSize = offset + 16384;\n            responseBuffer = extendBuffer(responseBuffer, responseBufferSize);\n            if (responseBuffer == NULL) {\n                Limelog(\"Failed to allocate RTSP response buffer\\n\");\n                goto Exit;\n            }\n        }\n\n        pfd.fd = sock;\n        pfd.events = POLLIN;\n        err = pollSockets(&pfd, 1, RTSP_RECEIVE_TIMEOUT_SEC * 1000);\n        if (err == 0) {\n            *error = ETIMEDOUT;\n            Limelog(\"RTSP request timed out\\n\");\n            goto Exit;\n        }\n        else if (err < 0) {\n            *error = LastSocketError();\n            Limelog(\"Failed to wait for RTSP response: %d\\n\", *error);\n            goto Exit;\n        }\n\n        err = recv(sock, &responseBuffer[offset], responseBufferSize - offset, 0);\n        if (err < 0) {\n            // Error reading\n            *error = LastSocketError();\n            Limelog(\"Failed to read RTSP response: %d\\n\", *error);\n            goto Exit;\n        }\n        else if (err == 0) {\n            // Done reading\n            break;\n        }\n        else {\n            offset += err;\n        }\n    }\n\n    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {\n        // Successfully parsed response\n        ret = true;\n    }\n    else {\n        Limelog(\"Failed to parse RTSP response\\n\");\n    }\n\nExit:\n    if (serializedMessage != NULL) {\n        free(serializedMessage);\n    }\n\n    if (responseBuffer != NULL) {\n        free(responseBuffer);\n    }\n\n    closeSocket(sock);\n    sock = INVALID_SOCKET;\n    return ret;\n}\n\nstatic bool transactRtspMessage(PRTSP_MESSAGE request, PRTSP_MESSAGE response, bool expectingPayload, int* error) {\n    if (ConnectionInterrupted) {\n        *error = -1;\n        return false;\n    }\n\n    if (useEnet) {\n        return transactRtspMessageEnet(request, response, expectingPayload, error);\n    }\n    else {\n        return transactRtspMessageTcp(request, response, error);\n    }\n}\n\n// Send RTSP OPTIONS request\nstatic bool requestOptions(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"OPTIONS\", rtspTargetUrl);\n    if (ret) {\n        ret = transactRtspMessage(&request, response, false, error);\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP DESCRIBE request\nstatic bool requestDescribe(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"DESCRIBE\", rtspTargetUrl);\n    if (ret) {\n        if (addOption(&request, \"Accept\",\n            \"application/sdp\") &&\n            addOption(&request, \"If-Modified-Since\",\n                \"Thu, 01 Jan 1970 00:00:00 GMT\")) {\n            ret = transactRtspMessage(&request, response, true, error);\n        }\n        else {\n            ret = false;\n        }\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP SETUP request\nstatic bool setupStream(PRTSP_MESSAGE response, char* target, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n    char* transportValue;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"SETUP\", target);\n    if (ret) {\n        if (hasSessionId) {\n            if (!addOption(&request, \"Session\", sessionIdString)) {\n                ret = false;\n                goto FreeMessage;\n            }\n        }\n\n        if (AppVersionQuad[0] >= 6) {\n            // It looks like GFE doesn't care what we say our port is but\n            // we need to give it some port to successfully complete the\n            // handshake process.\n            transportValue = \"unicast;X-GS-ClientPort=50000-50001\";\n        }\n        else {\n            transportValue = \" \";\n        }\n        \n        if (addOption(&request, \"Transport\", transportValue) &&\n            addOption(&request, \"If-Modified-Since\",\n                \"Thu, 01 Jan 1970 00:00:00 GMT\")) {\n            ret = transactRtspMessage(&request, response, false, error);\n        }\n        else {\n            ret = false;\n        }\n\n    FreeMessage:\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP PLAY request\nstatic bool playStream(PRTSP_MESSAGE response, char* target, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"PLAY\", target);\n    if (ret != 0) {\n        if (addOption(&request, \"Session\", sessionIdString)) {\n            ret = transactRtspMessage(&request, response, false, error);\n        }\n        else {\n            ret = false;\n        }\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\n// Send RTSP ANNOUNCE message\nstatic bool sendVideoAnnounce(PRTSP_MESSAGE response, int* error) {\n    RTSP_MESSAGE request;\n    bool ret;\n    int payloadLength;\n    char payloadLengthStr[16];\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"ANNOUNCE\",\n                                APP_VERSION_AT_LEAST(7, 1, 431) ? controlStreamId : \"streamid=video\");\n    if (ret) {\n        ret = false;\n\n        if (!addOption(&request, \"Session\", sessionIdString) ||\n            !addOption(&request, \"Content-type\", \"application/sdp\")) {\n            goto FreeMessage;\n        }\n\n        request.payload = getSdpPayloadForStreamConfig(rtspClientVersion, &payloadLength);\n        if (request.payload == NULL) {\n            goto FreeMessage;\n        }\n        request.flags |= FLAG_ALLOCATED_PAYLOAD;\n        request.payloadLength = payloadLength;\n\n        snprintf(payloadLengthStr, sizeof(payloadLengthStr), \"%d\", payloadLength);\n        if (!addOption(&request, \"Content-length\", payloadLengthStr)) {\n            goto FreeMessage;\n        }\n\n        ret = transactRtspMessage(&request, response, false, error);\n\n    FreeMessage:\n        freeMessage(&request);\n    }\n\n    return ret;\n}\n\nstatic int parseOpusConfigFromParamString(char* paramStr, int channelCount, POPUS_MULTISTREAM_CONFIGURATION opusConfig) {\n    int i;\n\n    // Set channel count (included in the prefix, so not parsed below)\n    opusConfig->channelCount = channelCount;\n\n    // Parse the remaining data from the surround-params value\n    if (!CHAR_IS_DIGIT(*paramStr)) {\n        Limelog(\"Invalid stream count: %c\\n\", *paramStr);\n        return -1;\n    }\n    opusConfig->streams = CHAR_TO_INT(*paramStr);\n    paramStr++;\n\n    if (!CHAR_IS_DIGIT(*paramStr)) {\n        Limelog(\"Invalid coupled stream count: %c\\n\", *paramStr);\n        return -2;\n    }\n    opusConfig->coupledStreams = CHAR_TO_INT(*paramStr);\n    paramStr++;\n\n    for (i = 0; i < opusConfig->channelCount; i++) {\n        if (!CHAR_IS_DIGIT(*paramStr)) {\n            Limelog(\"Invalid mapping value at %d: %c\\n\", i, *paramStr);\n            return -3;\n        }\n\n        opusConfig->mapping[i] = CHAR_TO_INT(*paramStr);\n        paramStr++;\n    }\n\n    return 0;\n}\n\n// Parse the server port from the Transport header\n// Example: unicast;server_port=48000-48001;source=192.168.35.177\nstatic bool parseServerPortFromTransport(PRTSP_MESSAGE response, uint16_t* port) {\n    char* transport;\n    char* portStart;\n\n    transport = getOptionContent(response->options, \"Transport\");\n    if (transport == NULL) {\n        return false;\n    }\n\n    // Look for the server_port= entry in the Transport option\n    portStart = strstr(transport, \"server_port=\");\n    if (portStart == NULL) {\n        return false;\n    }\n\n    // Skip the prefix\n    portStart += strlen(\"server_port=\");\n\n    // Validate the port number\n    long int rawPort = strtol(portStart, NULL, 10);\n    if (rawPort <= 0 || rawPort > 65535) {\n        return false;\n    }\n\n    *port = (uint16_t)rawPort;\n    return true;\n}\n\n// Parses the Opus configuration from an RTSP DESCRIBE response\nstatic int parseOpusConfigurations(PRTSP_MESSAGE response) {\n    HighQualitySurroundSupported = false;\n    memset(&NormalQualityOpusConfig, 0, sizeof(NormalQualityOpusConfig));\n    memset(&HighQualityOpusConfig, 0, sizeof(HighQualityOpusConfig));\n\n    // Sample rate is always 48 KHz\n    HighQualityOpusConfig.sampleRate = NormalQualityOpusConfig.sampleRate = 48000;\n\n    // Stereo doesn't have any surround-params elements in the RTSP data\n    if (CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) == 2) {\n        NormalQualityOpusConfig.channelCount = 2;\n        NormalQualityOpusConfig.streams = 1;\n        NormalQualityOpusConfig.coupledStreams = 1;\n        NormalQualityOpusConfig.mapping[0] = 0;\n        NormalQualityOpusConfig.mapping[1] = 1;\n    }\n    else {\n        char paramsPrefix[128];\n        char* paramStart;\n        int err;\n        int channelCount;\n\n        channelCount = CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration);\n\n        // Find the correct audio parameter value\n        snprintf(paramsPrefix, sizeof(paramsPrefix), \"a=fmtp:97 surround-params=%d\", channelCount);\n        paramStart = strstr(response->payload, paramsPrefix);\n        if (paramStart) {\n            // Skip the prefix\n            paramStart += strlen(paramsPrefix);\n\n            // Parse the normal quality Opus config\n            err = parseOpusConfigFromParamString(paramStart, channelCount, &NormalQualityOpusConfig);\n            if (err != 0) {\n                return err;\n            }\n\n            // GFE's normal-quality channel mapping differs from the one our clients use.\n            // They use FL FR C RL RR SL SR LFE, but we use FL FR C LFE RL RR SL SR. We'll need\n            // to swap the mappings to match the expected values.\n            if (channelCount == 6 || channelCount == 8) {\n                OPUS_MULTISTREAM_CONFIGURATION originalMapping = NormalQualityOpusConfig;\n\n                // LFE comes after C\n                NormalQualityOpusConfig.mapping[3] = originalMapping.mapping[channelCount - 1];\n\n                // Slide everything else up\n                memcpy(&NormalQualityOpusConfig.mapping[4],\n                       &originalMapping.mapping[3],\n                       channelCount - 4);\n            }\n\n            // If this configuration is compatible with high quality mode, we may have another\n            // matching surround-params value for high quality mode.\n            paramStart = strstr(paramStart, paramsPrefix);\n            if (paramStart) {\n                // Skip the prefix\n                paramStart += strlen(paramsPrefix);\n\n                // Parse the high quality Opus config\n                err = parseOpusConfigFromParamString(paramStart, channelCount, &HighQualityOpusConfig);\n                if (err != 0) {\n                    return err;\n                }\n\n                // We can request high quality audio\n                HighQualitySurroundSupported = true;\n            }\n        }\n        else {\n            Limelog(\"No surround parameters found for channel count: %d\\n\", channelCount);\n\n            // It's unknown whether all GFE versions that supported surround sound included these\n            // surround sound parameters. In case they didn't, we'll specifically handle 5.1 surround\n            // sound using a hardcoded configuration like we used to before this parsing code existed.\n            //\n            // It is not necessary to provide HighQualityOpusConfig here because high quality mode\n            // can only be enabled from seeing the required \"surround-params=\" value, so there's no\n            // chance it could regress from implementing this parser.\n            if (channelCount == 6) {\n                NormalQualityOpusConfig.channelCount = 6;\n                NormalQualityOpusConfig.streams = 4;\n                NormalQualityOpusConfig.coupledStreams = 2;\n                NormalQualityOpusConfig.mapping[0] = 0;\n                NormalQualityOpusConfig.mapping[1] = 4;\n                NormalQualityOpusConfig.mapping[2] = 1;\n                NormalQualityOpusConfig.mapping[3] = 5;\n                NormalQualityOpusConfig.mapping[4] = 2;\n                NormalQualityOpusConfig.mapping[5] = 3;\n            }\n            else {\n                // We don't have a hardcoded fallback mapping, so we have no choice but to fail.\n                return -4;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n\n    // Create a copy that we can modify\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n\n    // If we have a v6 address, we want to stop one character after the closing ]\n    // If we have a v4 address, we want to stop at the port separator\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n\n    // Count the prefix length to skip past the initial rtsp:// or rtspru:// part\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n\n    // If we hit the end of the string prior to parsing the prefix, we cannot proceed\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n\n    // Look for a slash at the end of the host portion of the URL (may not be present)\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n\n    // Check for a v6 address first since they also have colons\n    if (v6EscapeEndChar) {\n        // Terminate the string at the next character\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        // Terminate the string prior to the port separator\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        // Terminate the string prior to the path separator\n        *urlPathSeparator = 0;\n    }\n\n    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n    destination[destinationLength - 1] = '\\0';\n\n    free(rtspUrlScratchBuffer);\n    return true;\n}\n\n// SDP attributes are in the form:\n// a=x-nv-bwe.bwuSafeZoneLowLimit:70\\r\\n\nbool parseSdpAttributeToUInt(const char* payload, const char* name, unsigned int* val) {\n    // Find the entry for the specified attribute name\n    char* attribute = strstr(payload, name);\n    if (!attribute) {\n        return false;\n    }\n\n    // Locate the start of the value\n    char* valst = strstr(attribute, \":\");\n    if (!valst) {\n        return false;\n    }\n\n    // Read the integer up to the newline at the end of the SDP attribute\n    *val = strtoul(valst + 1, NULL, 0);\n\n    return true;\n}\n\nbool parseSdpAttributeToInt(const char* payload, const char* name, int* val) {\n    // Find the entry for the specified attribute name\n    char* attribute = strstr(payload, name);\n    if (!attribute) {\n        return false;\n    }\n\n    // Locate the start of the value\n    char* valst = strstr(attribute, \":\");\n    if (!valst) {\n        return false;\n    }\n\n    // Read the integer up to the newline at the end of the SDP attribute\n    *val = strtol(valst + 1, NULL, 0);\n\n    return true;\n}\n\n// Perform RTSP Handshake with the streaming server machine as part of the connection process\nint performRtspHandshake(PSERVER_INFORMATION serverInfo) {\n    int ret;\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    // Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control/13/0\" : \"streamid=control/1/0\";\n    AudioEncryptionEnabled = false;\n\n    // HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    // fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    // that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    // thinks you are remote (target address != any local address).\n    //\n    // We will enable high quality audio if the following are all true:\n    // 1. Video bitrate is higher than 15 Mbps (to ensure most bandwidth is reserved for video)\n    // 2. The audio decoder has not declared that it is slow\n    // 3. The stream is either local or not surround sound (to prevent MTU issues over the Internet)\n    LC_ASSERT(StreamConfig.streamingRemotely != STREAM_CFG_AUTO);\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0 &&\n            (StreamConfig.streamingRemotely != STREAM_CFG_REMOTE || CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) <= 2)) {\n        // If we have an RTSP URL string and it was successfully parsed, use that string\n        if (serverInfo->rtspSessionUrl != NULL && parseUrlAddrFromRtspUrlString(serverInfo->rtspSessionUrl, urlAddr, sizeof(urlAddr))) {\n            strcpy(rtspTargetUrl, serverInfo->rtspSessionUrl);\n        }\n        else {\n            // If an RTSP URL string was not provided or failed to parse, we will construct one now as best we can.\n            //\n            // NB: If the remote address is not a LAN address, the host will likely not enable high quality\n            // audio since it only does that for local streaming normally. We can avoid this limitation,\n            // but only if the caller gave us the RTSP session URL that it received from the host during launch.\n            addrToUrlSafeString(&RemoteAddr, urlAddr, sizeof(urlAddr));\n\t\t\tsnprintf(rtspTargetUrl, sizeof(rtspTargetUrl), \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n        }\n    }\n    else {\n        PltSafeStrcpy(urlAddr, sizeof(urlAddr), \"0.0.0.0\");\n\t\tsnprintf(rtspTargetUrl, sizeof(rtspTargetUrl), \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    }\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;\n            break;\n        case 6:\n            // Gen 6 has never been seen in the wild\n            rtspClientVersion = 13;\n            break;\n        case 7:\n        default:\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    // Setup ENet if required by this GFE version\n    if (useEnet) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, RtspPortNumber);\n        \n        // Create a client that can use 1 outgoing connection and 1 channel\n        client = enet_host_create(RemoteAddr.ss_family, NULL, 1, 1, 0, 0);\n        if (client == NULL) {\n            return -1;\n        }\n    \n        // Connect to the host\n        peer = enet_host_connect(client, &address, 1, 0);\n        if (peer == NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n            return -1;\n        }\n    \n        // Wait for the connect to complete\n        if (serviceEnetHost(client, &event, RTSP_CONNECT_TIMEOUT_SEC * 1000) <= 0 ||\n            event.type != ENET_EVENT_TYPE_CONNECT) {\n            Limelog(\"RTSP: Failed to connect to UDP port %u\\n\", RtspPortNumber);\n            enet_peer_reset(peer);\n            peer = NULL;\n            enet_host_destroy(client);\n            client = NULL;\n            return -1;\n        }\n\n        // Ensure the connect verify ACK is sent immediately\n        enet_host_flush(client);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!requestOptions(&response, &error)) {\n            Limelog(\"RTSP OPTIONS request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP OPTIONS request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!requestDescribe(&response, &error)) {\n            Limelog(\"RTSP DESCRIBE request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP DESCRIBE request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n        \n        if ((StreamConfig.supportedVideoFormats & VIDEO_FORMAT_MASK_AV1) && strstr(response.payload, \"AV1/90000\")) {\n            if ((serverInfo->serverCodecModeSupport & SCM_AV1_MAIN10) && (StreamConfig.supportedVideoFormats & VIDEO_FORMAT_AV1_MAIN10)) {\n                NegotiatedVideoFormat = VIDEO_FORMAT_AV1_MAIN10;\n            }\n            else {\n                NegotiatedVideoFormat = VIDEO_FORMAT_AV1_MAIN8;\n\n                // Apply bitrate adjustment for SDR AV1 if the client requested one\n                if (StreamConfig.av1BitratePercentageMultiplier != 0) {\n                    StreamConfig.bitrate *= StreamConfig.av1BitratePercentageMultiplier;\n                    StreamConfig.bitrate /= 100;\n                }\n            }\n        }\n        else if ((StreamConfig.supportedVideoFormats & VIDEO_FORMAT_MASK_H265) && strstr(response.payload, \"sprop-parameter-sets=AAAAAU\")) {\n            // The RTSP DESCRIBE reply will contain a collection of SDP media attributes that\n            // describe the various supported video stream formats and include the SPS, PPS,\n            // and VPS (if applicable). We will use this information to determine whether the\n            // server can support HEVC. For some reason, they still set the MIME type of the HEVC\n            // format to H264, so we can't just look for the HEVC MIME type. What we'll do instead is\n            // look for the base 64 encoded VPS NALU prefix that is unique to the HEVC bitstream.\n            if ((serverInfo->serverCodecModeSupport & SCM_HEVC_MAIN10) && (StreamConfig.supportedVideoFormats & VIDEO_FORMAT_H265_MAIN10)) {\n                NegotiatedVideoFormat = VIDEO_FORMAT_H265_MAIN10;\n            }\n            else {\n                NegotiatedVideoFormat = VIDEO_FORMAT_H265;\n\n                // Apply bitrate adjustment for SDR HEVC if the client requested one\n                if (StreamConfig.hevcBitratePercentageMultiplier != 0) {\n                    StreamConfig.bitrate *= StreamConfig.hevcBitratePercentageMultiplier;\n                    StreamConfig.bitrate /= 100;\n                }\n            }\n        }\n        else {\n            NegotiatedVideoFormat = VIDEO_FORMAT_H264;\n\n            // Dimensions over 4096 are only supported with HEVC on NVENC\n            if (StreamConfig.width > 4096 || StreamConfig.height > 4096) {\n                Limelog(\"WARNING: Host PC doesn't support HEVC. Streaming at resolutions above 4K using H.264 will likely fail!\\n\");\n            }\n        }\n\n        // Look for the SDP attribute that indicates we're dealing with a server that supports RFI\n        ReferenceFrameInvalidationSupported = strstr(response.payload, \"x-nv-video[0].refPicInvalidation\") != NULL;\n        if (!ReferenceFrameInvalidationSupported) {\n            Limelog(\"Reference frame invalidation is not supported by this host\\n\");\n        }\n\n        // Look for the Sunshine feature flags in the SDP attributes\n        if (!parseSdpAttributeToUInt(response.payload, \"x-ss-general.featureFlags\", &SunshineFeatureFlags)) {\n            SunshineFeatureFlags = 0;\n        }\n\n        // Parse the Opus surround parameters out of the RTSP DESCRIBE response.\n        ret = parseOpusConfigurations(&response);\n        if (ret != 0) {\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        char* sessionId;\n        char* pingPayload;\n        int error = -1;\n        char* strtokCtx = NULL;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=audio/0/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the audio port out of the RTSP SETUP response\n        LC_ASSERT(AudioPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &AudioPortNumber)) {\n            // Use the well known port if parsing fails\n            AudioPortNumber = 48000;\n\n            Limelog(\"Audio port: %u (RTSP parsing failed)\\n\", AudioPortNumber);\n        }\n        else {\n            Limelog(\"Audio port: %u\\n\", AudioPortNumber);\n        }\n\n        // Parse the Sunshine ping payload protocol extension if present\n        memset(&AudioPingPayload, 0, sizeof(AudioPingPayload));\n        pingPayload = getOptionContent(response.options, \"X-SS-Ping-Payload\");\n        if (pingPayload != NULL && strlen(pingPayload) == sizeof(AudioPingPayload.payload)) {\n            memcpy(AudioPingPayload.payload, pingPayload, sizeof(AudioPingPayload.payload));\n        }\n\n        // Let the audio stream know the port number is now finalized.\n        // NB: This is needed because audio stream init happens before RTSP,\n        // which is not the case for the video stream.\n        notifyAudioPortNegotiationComplete();\n\n        sessionId = getOptionContent(response.options, \"Session\");\n\n        if (sessionId == NULL) {\n            Limelog(\"RTSP SETUP streamid=audio is missing session attribute\\n\");\n            ret = -1;\n            goto Exit;\n        }\n\n        // Given there is a non-null session id, get the\n        // first token of the session until \";\", which \n        // resolves any 454 session not found errors on\n        // standard RTSP server implementations.\n        // (i.e - sessionId = \"DEADBEEFCAFE;timeout = 90\") \n        sessionIdString = strdup(strtok_r(sessionId, \";\", &strtokCtx));\n        if (sessionIdString == NULL) {\n            Limelog(\"Failed to duplicate session ID string\\n\");\n            ret = -1;\n            goto Exit;\n        }\n\n        hasSessionId = true;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n        char* pingPayload;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=video/0/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the Sunshine ping payload protocol extension if present\n        memset(&VideoPingPayload, 0, sizeof(VideoPingPayload));\n        pingPayload = getOptionContent(response.options, \"X-SS-Ping-Payload\");\n        if (pingPayload != NULL && strlen(pingPayload) == sizeof(VideoPingPayload.payload)) {\n            memcpy(VideoPingPayload.payload, pingPayload, sizeof(VideoPingPayload.payload));\n        }\n\n        // Parse the video port out of the RTSP SETUP response\n        LC_ASSERT(VideoPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &VideoPortNumber)) {\n            // Use the well known port if parsing fails\n            VideoPortNumber = 47998;\n\n            Limelog(\"Video port: %u (RTSP parsing failed)\\n\", VideoPortNumber);\n        }\n        else {\n            Limelog(\"Video port: %u\\n\", VideoPortNumber);\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (AppVersionQuad[0] >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         controlStreamId,\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        // Parse the control port out of the RTSP SETUP response\n        LC_ASSERT(ControlPortNumber == 0);\n        if (!parseServerPortFromTransport(&response, &ControlPortNumber)) {\n            // Use the well known port if parsing fails\n            ControlPortNumber = 47999;\n\n            Limelog(\"Control port: %u (RTSP parsing failed)\\n\", ControlPortNumber);\n        }\n        else {\n            Limelog(\"Control port: %u\\n\", ControlPortNumber);\n        }\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!sendVideoAnnounce(&response, &error)) {\n            Limelog(\"RTSP ANNOUNCE request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP ANNOUNCE request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n\n    // GFE 3.22 uses a single PLAY message\n    if (APP_VERSION_AT_LEAST(7, 1, 431)) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!playStream(&response, \"/\", &error)) {\n            Limelog(\"RTSP PLAY request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP PLAY failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    else {\n        {\n            RTSP_MESSAGE response;\n            int error = -1;\n\n            if (!playStream(&response, \"streamid=video\", &error)) {\n                Limelog(\"RTSP PLAY streamid=video request failed: %d\\n\", error);\n                ret = error;\n                goto Exit;\n            }\n\n            if (response.message.response.statusCode != 200) {\n                Limelog(\"RTSP PLAY streamid=video failed: %d\\n\",\n                    response.message.response.statusCode);\n                ret = response.message.response.statusCode;\n                goto Exit;\n            }\n\n            freeMessage(&response);\n        }\n\n        {\n            RTSP_MESSAGE response;\n            int error = -1;\n\n            if (!playStream(&response, \"streamid=audio\", &error)) {\n                Limelog(\"RTSP PLAY streamid=audio request failed: %d\\n\", error);\n                ret = error;\n                goto Exit;\n            }\n\n            if (response.message.response.statusCode != 200) {\n                Limelog(\"RTSP PLAY streamid=audio failed: %d\\n\",\n                    response.message.response.statusCode);\n                ret = response.message.response.statusCode;\n                goto Exit;\n            }\n\n            freeMessage(&response);\n        }\n    }\n\n    \n    ret = 0;\n    \nExit:\n    // Cleanup the ENet stuff\n    if (useEnet) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        \n        if (client != NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n        }\n    }\n\n    if (sessionIdString != NULL) {\n        free(sessionIdString);\n        sessionIdString = NULL;\n    }\n\n    return ret;\n}\n"], "filenames": ["src/RtspConnection.c"], "buggy_code_start_loc": [660], "buggy_code_end_loc": [793], "fixing_code_start_loc": [660], "fixing_code_end_loc": [794], "type": "CWE-120", "message": "Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit 50c0a51b10ecc5b3415ea78c21d96d679e2288f9 due to unmitigated usage of unsafe C functions and improper bounds checking. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client, or achieve remote code execution (RCE) on the client (with insufficient exploit mitigations or if mitigations can be bypassed). The bug was addressed in commit 02b7742f4d19631024bd766bd2bb76715780004e.", "other": {"cve": {"id": "CVE-2023-42799", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T17:15:07.257", "lastModified": "2023-12-20T14:46:20.553", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit 50c0a51b10ecc5b3415ea78c21d96d679e2288f9 due to unmitigated usage of unsafe C functions and improper bounds checking. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client, or achieve remote code execution (RCE) on the client (with insufficient exploit mitigations or if mitigations can be bypassed). The bug was addressed in commit 02b7742f4d19631024bd766bd2bb76715780004e."}, {"lang": "es", "value": "Moonlight-common-c contiene el c\u00f3digo principal del cliente GameStream compartido entre los clientes Moonlight. Moonlight-common-c es vulnerable al desbordamiento del b\u00fafer a partir de el commit 50c0a51b10ecc5b3415ea78c21d96d679e2288f9 debido al uso absoluto de funciones C inseguras y a una verificaci\u00f3n de los l\u00edmites inadecuada. Un servidor de transmisi\u00f3n de juegos malicioso podr\u00eda aprovechar una vulnerabilidad de desbordamiento del b\u00fafer para bloquear un cliente de luz nocturna o lograr la ejecuci\u00f3n remota de c\u00f3digo (RCE) en el cliente (con mitigaciones de explotaci\u00f3n insuficientes o si se pueden evitar las mitigaciones). El error se solucion\u00f3 en el commit 02b7742f4d19631024bd766bd2bb76715780004e."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight-common-c:*:*:*:*:*:*:*:*", "versionStartIncluding": "2022-11-04", "versionEndExcluding": "2023-10-06", "matchCriteriaId": "EE5D99F2-FFB5-4239-855B-2CDAE0210FE3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:iphone_os:*:*", "versionStartIncluding": "8.4.0", "versionEndIncluding": "8.5.0", "matchCriteriaId": "730ABEDB-A45B-487D-90E5-58188F33021E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:tvos:*:*", "versionStartIncluding": "8.4.0", "versionEndIncluding": "8.5.0", "matchCriteriaId": "F8DC3BA3-941C-40D2-AD1B-AF7971D99672"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:android:*:*", "versionStartIncluding": "10.10", "versionEndIncluding": "11.0", "matchCriteriaId": "6D8BB0A6-B219-4AFF-BE01-BC0546DAAF91"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:0.10.22:*:*:*:*:chrome:*:*", "matchCriteriaId": "E50A8A78-8606-49DD-8D95-3AE7DFBA3E87"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_embedded:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9E1F448D-0CFE-4DAE-A119-8AF4F8FD48EF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_xbox:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.12.0", "versionEndIncluding": "1.14.40", "matchCriteriaId": "BFE72448-E647-43F9-A72C-F86118596EE3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_tv:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.5.4", "versionEndIncluding": "1.5.27", "matchCriteriaId": "38BDA766-E56D-496D-BC16-AD2026E04A7F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_switch:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.13", "versionEndIncluding": "0.13.3", "matchCriteriaId": "5FFADEE0-F587-4444-AE6F-323E20808042"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight_vita:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.2", "versionEndIncluding": "0.9.3", "matchCriteriaId": "EFAF4088-233D-46FA-A031-ACCF0D7FF78F"}]}]}], "references": [{"url": "https://github.com/moonlight-stream/moonlight-common-c/commit/02b7742f4d19631024bd766bd2bb76715780004e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moonlight-stream/moonlight-common-c/commit/50c0a51b10ecc5b3415ea78c21d96d679e2288f9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moonlight-stream/moonlight-common-c/security/advisories/GHSA-r8cf-45f4-vf8m", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moonlight-stream/moonlight-common-c/commit/02b7742f4d19631024bd766bd2bb76715780004e"}}