{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  DDDD                               %\n%                            P   P  C      D   D                              %\n%                            PPPP   C      D   D                              %\n%                            P      C      D   D                              %\n%                            P       CCCC  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                     Read/Write Photo CD Image Format                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage recovers the Huffman encoded luminance and chrominance\n%  deltas.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n%        unsigned char *chroma1,unsigned char *chroma2)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o luma: the address of a character buffer that contains the\n%      luminance information.\n%\n%    o chroma1: the address of a character buffer that contains the\n%      chrominance information.\n%\n%    o chroma2: the address of a character buffer that contains the\n%      chrominance information.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCD() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCD.\n%\n%  The format of the IsPCD method is:\n%\n%      MagickBooleanType IsPCD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCD(const unsigned char *magick,const size_t length)\n{\n  if (length < 2052)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+2048,\"PCD_\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCDImage() reads a Photo CD image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.  Much of the PCD decoder was derived from\n%  the program hpcdtoppm(1) by Hadmut Danisch.\n%\n%  The format of the ReadPCDImage method is:\n%\n%      image=ReadPCDImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *OverviewImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *montage_image;\n\n  MontageInfo\n    *montage_info;\n\n  register Image\n    *p;\n\n  /*\n    Create the PCD Overview image.\n  */\n  for (p=image; p != (Image *) NULL; p=p->next)\n  {\n    (void) DeleteImageProperty(p,\"label\");\n    (void) SetImageProperty(p,\"label\",DefaultTileLabel,exception);\n  }\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  (void) CopyMagickString(montage_info->filename,image_info->filename,\n    MagickPathExtent);\n  montage_image=MontageImageList(image_info,montage_info,image,exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  if (montage_image == (Image *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImageList(image);\n  return(montage_image);\n}\n\nstatic void Upsample(const size_t width,const size_t height,\n  const size_t scaled_width,unsigned char *pixels)\n{\n  register ssize_t\n    x,\n    y;\n\n  register unsigned char\n    *p,\n    *q,\n    *r;\n\n  /*\n    Create a new image that is a integral size greater than an existing one.\n  */\n  assert(pixels != (unsigned char *) NULL);\n  for (y=0; y < (ssize_t) height; y++)\n  {\n    p=pixels+(height-1-y)*scaled_width+(width-1);\n    q=pixels+((height-1-y) << 1)*scaled_width+((width-1) << 1);\n    *q=(*p);\n    *(q+1)=(*(p));\n    for (x=1; x < (ssize_t) width; x++)\n    {\n      p--;\n      q-=2;\n      *q=(*p);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+1))+1) >> 1);\n    }\n  }\n  for (y=0; y < (ssize_t) (height-1); y++)\n  {\n    p=pixels+((size_t) y << 1)*scaled_width;\n    q=p+scaled_width;\n    r=q+scaled_width;\n    for (x=0; x < (ssize_t) (width-1); x++)\n    {\n      *q=(unsigned char) ((((size_t) *p)+((size_t) *r)+1) >> 1);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+2))+\n        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);\n      q+=2;\n      p+=2;\n      r+=2;\n    }\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n  }\n  p=pixels+(2*height-2)*scaled_width;\n  q=pixels+(2*height-1)*scaled_width;\n  (void) memcpy(q,p,(size_t) (2*width));\n}\n\nstatic Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCDException(exception,message) \\\n{ \\\n  if (header != (unsigned char *) NULL) \\\n    header=(unsigned char *) RelinquishMagickMemory(header); \\\n  if (luma != (unsigned char *) NULL) \\\n    luma=(unsigned char *) RelinquishMagickMemory(luma); \\\n  if (chroma2 != (unsigned char *) NULL) \\\n    chroma2=(unsigned char *) RelinquishMagickMemory(chroma2); \\\n  if (chroma1 != (unsigned char *) NULL) \\\n    chroma1=(unsigned char *) RelinquishMagickMemory(chroma1); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) NULL;\n  chroma2=(unsigned char *) NULL;\n  luma=(unsigned char *) NULL;\n  count=ReadBlob(image,3*0x800,header);\n  if (count != (3*0x800))\n    ThrowPCDException(CorruptImageError,\"ImproperImageHeader\");\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0))\n    ThrowPCDException(CorruptImageError,\"ImproperImageHeader\");\n  rotate=header[0x0e02] & 0x03;\n  number_images=((header[10] << 8) | header[11]) & 0xffff;\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  if ((overview != 0) &&\n      (AcquireMagickResource(ListLengthResource,number_images) == MagickFalse))\n    ThrowPCDException(ResourceLimitError,\"ListLengthExceedsLimit\");\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowPCDException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    ThrowPCDException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(chroma1,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*chroma1));\n  (void) memset(chroma2,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*chroma2));\n  (void) memset(luma,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*luma));\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    if (ReadBlobByte(image) == EOF)\n      ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n  if (overview != 0)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n          if (EOFBlob(image) != MagickFalse)\n            ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        if (EOFBlob(image) != MagickFalse)\n          break;\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n      return(OverviewImage(image_info,GetFirstImageInList(image),exception));\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n    if (EOFBlob(image) != MagickFalse)\n      ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2,exception);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2,exception);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n      SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n      SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  if (image_info->scene != 0)\n    for (i=0; i < (ssize_t) image_info->scene; i++)\n      AppendImageToList(&image,CloneImage(image,0,0,MagickTrue,exception));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCDImage() adds attributes for the PCD image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCDImage method is:\n%\n%      size_t RegisterPCDImage(void)\n%\n*/\nModuleExport size_t RegisterPCDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCD\",\"PCD\",\"Photo CD\");\n  entry->decoder=(DecodeImageHandler *) ReadPCDImage;\n  entry->encoder=(EncodeImageHandler *) WritePCDImage;\n  entry->magick=(IsImageFormatHandler *) IsPCD;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PCD\",\"PCDS\",\"Photo CD\");\n  entry->decoder=(DecodeImageHandler *) ReadPCDImage;\n  entry->encoder=(EncodeImageHandler *) WritePCDImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCDImage() removes format registrations made by the\n%  PCD module from the list of supported formats.\n%\n%  The format of the UnregisterPCDImage method is:\n%\n%      UnregisterPCDImage(void)\n%\n*/\nModuleExport void UnregisterPCDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCD\");\n  (void) UnregisterMagickInfo(\"PCDS\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCDImage() writes an image in the Photo CD encoded image format.\n%\n%  The format of the WritePCDImage method is:\n%\n%      MagickBooleanType WritePCDImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType WritePCDTile(Image *image,const char *page_geometry,\n  const size_t tile_columns,const size_t tile_rows,ExceptionInfo *exception)\n{\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *downsample_image,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  register const Quantum\n    *p,\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Scale image to tile size.\n  */\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  if ((geometry.width % 2) != 0)\n    geometry.width--;\n  if ((geometry.height % 2) != 0)\n    geometry.height--;\n  tile_image=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,\n    exception);\n  if (tile_image == (Image *) NULL)\n    return(MagickFalse);\n  flags=ParseGeometry(page_geometry,&geometry_info);\n  geometry.width=(size_t) geometry_info.rho;\n  geometry.height=(size_t) geometry_info.sigma;\n  if ((flags & SigmaValue) == 0)\n    geometry.height=geometry.width;\n  if ((tile_image->columns != geometry.width) ||\n      (tile_image->rows != geometry.height))\n    {\n      Image\n        *bordered_image;\n\n      RectangleInfo\n        border_info;\n\n      /*\n        Put a border around the image.\n      */\n      border_info.width=(geometry.width-tile_image->columns+1) >> 1;\n      border_info.height=(geometry.height-tile_image->rows+1) >> 1;\n      bordered_image=BorderImage(tile_image,&border_info,image->compose,\n        exception);\n      if (bordered_image == (Image *) NULL)\n        return(MagickFalse);\n      tile_image=DestroyImage(tile_image);\n      tile_image=bordered_image;\n    }\n  if ((tile_image->columns != tile_columns) || (tile_image->rows != tile_rows))\n    {\n      Image\n        *resize_image;\n\n      resize_image=ResizeImage(tile_image,tile_columns,tile_rows,\n        tile_image->filter,exception);\n      if (resize_image != (Image *) NULL)\n        {\n          tile_image=DestroyImage(tile_image);\n          tile_image=resize_image;\n        }\n    }\n  (void) TransformImageColorspace(tile_image,YCCColorspace,exception);\n  downsample_image=ResizeImage(tile_image,tile_image->columns/2,\n    tile_image->rows/2,TriangleFilter,exception);\n  if (downsample_image == (Image *) NULL)\n    return(MagickFalse);\n  /*\n    Write tile to PCD file.\n  */\n  for (y=0; y < (ssize_t) tile_image->rows; y+=2)\n  {\n    p=GetVirtualPixels(tile_image,0,y,tile_image->columns,2,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) (tile_image->columns << 1); x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(tile_image,p)));\n      p+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelGreen(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelBlue(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    status=SetImageProgress(image,SaveImageTag,y,tile_image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  for (i=0; i < 0x800; i++)\n    (void) WriteBlobByte(image,'\\0');\n  downsample_image=DestroyImage(downsample_image);\n  tile_image=DestroyImage(tile_image);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType WritePCDImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *pcd_image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  pcd_image=image;\n  if (image->columns < image->rows)\n    {\n      Image\n        *rotate_image;\n\n      /*\n        Rotate portrait to landscape.\n      */\n      rotate_image=RotateImage(image,90.0,exception);\n      if (rotate_image == (Image *) NULL)\n        return(MagickFalse);\n      pcd_image=rotate_image;\n      DestroyBlob(rotate_image);\n      pcd_image->blob=ReferenceBlob(image->blob);\n    }\n  /*\n    Open output image file.\n  */\n  status=OpenBlob(image_info,pcd_image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      if (pcd_image != image)\n        pcd_image=DestroyImage(pcd_image);\n      return(status);\n    }\n  if (IssRGBCompatibleColorspace(pcd_image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(pcd_image,sRGBColorspace,exception);\n  /*\n    Write PCD image header.\n  */\n  for (i=0; i < 32; i++)\n    (void) WriteBlobByte(pcd_image,0xff);\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x0e);\n  for (i=0; i < 8; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x01);\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x05);\n  for (i=0; i < 8; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x0A);\n  for (i=0; i < 36; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x01);\n  for (i=0; i < 1944; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  (void) WriteBlob(pcd_image,7,(const unsigned char *) \"PCD_IPI\");\n  (void) WriteBlobByte(pcd_image,0x06);\n  for (i=0; i < 1530; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  if (image->columns < image->rows)\n    (void) WriteBlobByte(pcd_image,'\\1');\n  else\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < (3*0x800-1539); i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  /*\n    Write PCD tiles.\n  */\n  status=WritePCDTile(pcd_image,\"768x512>\",192,128,exception);\n  status=WritePCDTile(pcd_image,\"768x512>\",384,256,exception);\n  status=WritePCDTile(pcd_image,\"768x512>\",768,512,exception);\n  (void) CloseBlob(pcd_image);\n  if (pcd_image != image)\n    pcd_image=DestroyImage(pcd_image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  DDDD                               %\n%                            P   P  C      D   D                              %\n%                            PPPP   C      D   D                              %\n%                            P      C      D   D                              %\n%                            P       CCCC  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                     Read/Write Photo CD Image Format                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage recovers the Huffman encoded luminance and chrominance\n%  deltas.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n%        unsigned char *chroma1,unsigned char *chroma2)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o luma: the address of a character buffer that contains the\n%      luminance information.\n%\n%    o chroma1: the address of a character buffer that contains the\n%      chrominance information.\n%\n%    o chroma2: the address of a character buffer that contains the\n%      chrominance information.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        for (j=0; j < i; j++)\n          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          for (j=0; j <= i; j++)\n            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCD() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCD.\n%\n%  The format of the IsPCD method is:\n%\n%      MagickBooleanType IsPCD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCD(const unsigned char *magick,const size_t length)\n{\n  if (length < 2052)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+2048,\"PCD_\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCDImage() reads a Photo CD image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.  Much of the PCD decoder was derived from\n%  the program hpcdtoppm(1) by Hadmut Danisch.\n%\n%  The format of the ReadPCDImage method is:\n%\n%      image=ReadPCDImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *OverviewImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *montage_image;\n\n  MontageInfo\n    *montage_info;\n\n  register Image\n    *p;\n\n  /*\n    Create the PCD Overview image.\n  */\n  for (p=image; p != (Image *) NULL; p=p->next)\n  {\n    (void) DeleteImageProperty(p,\"label\");\n    (void) SetImageProperty(p,\"label\",DefaultTileLabel,exception);\n  }\n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  (void) CopyMagickString(montage_info->filename,image_info->filename,\n    MagickPathExtent);\n  montage_image=MontageImageList(image_info,montage_info,image,exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  if (montage_image == (Image *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  image=DestroyImageList(image);\n  return(montage_image);\n}\n\nstatic void Upsample(const size_t width,const size_t height,\n  const size_t scaled_width,unsigned char *pixels)\n{\n  register ssize_t\n    x,\n    y;\n\n  register unsigned char\n    *p,\n    *q,\n    *r;\n\n  /*\n    Create a new image that is a integral size greater than an existing one.\n  */\n  assert(pixels != (unsigned char *) NULL);\n  for (y=0; y < (ssize_t) height; y++)\n  {\n    p=pixels+(height-1-y)*scaled_width+(width-1);\n    q=pixels+((height-1-y) << 1)*scaled_width+((width-1) << 1);\n    *q=(*p);\n    *(q+1)=(*(p));\n    for (x=1; x < (ssize_t) width; x++)\n    {\n      p--;\n      q-=2;\n      *q=(*p);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+1))+1) >> 1);\n    }\n  }\n  for (y=0; y < (ssize_t) (height-1); y++)\n  {\n    p=pixels+((size_t) y << 1)*scaled_width;\n    q=p+scaled_width;\n    r=q+scaled_width;\n    for (x=0; x < (ssize_t) (width-1); x++)\n    {\n      *q=(unsigned char) ((((size_t) *p)+((size_t) *r)+1) >> 1);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+2))+\n        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);\n      q+=2;\n      p+=2;\n      r+=2;\n    }\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n  }\n  p=pixels+(2*height-2)*scaled_width;\n  q=pixels+(2*height-1)*scaled_width;\n  (void) memcpy(q,p,(size_t) (2*width));\n}\n\nstatic Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCDException(exception,message) \\\n{ \\\n  if (header != (unsigned char *) NULL) \\\n    header=(unsigned char *) RelinquishMagickMemory(header); \\\n  if (luma != (unsigned char *) NULL) \\\n    luma=(unsigned char *) RelinquishMagickMemory(luma); \\\n  if (chroma2 != (unsigned char *) NULL) \\\n    chroma2=(unsigned char *) RelinquishMagickMemory(chroma2); \\\n  if (chroma1 != (unsigned char *) NULL) \\\n    chroma1=(unsigned char *) RelinquishMagickMemory(chroma1); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) NULL;\n  chroma2=(unsigned char *) NULL;\n  luma=(unsigned char *) NULL;\n  count=ReadBlob(image,3*0x800,header);\n  if (count != (3*0x800))\n    ThrowPCDException(CorruptImageError,\"ImproperImageHeader\");\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0))\n    ThrowPCDException(CorruptImageError,\"ImproperImageHeader\");\n  rotate=header[0x0e02] & 0x03;\n  number_images=((header[10] << 8) | header[11]) & 0xffff;\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  if ((overview != 0) &&\n      (AcquireMagickResource(ListLengthResource,number_images) == MagickFalse))\n    ThrowPCDException(ResourceLimitError,\"ListLengthExceedsLimit\");\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowPCDException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    ThrowPCDException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(chroma1,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*chroma1));\n  (void) memset(chroma2,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*chroma2));\n  (void) memset(luma,0,(image->columns+1UL)*image->rows*\n    10*sizeof(*luma));\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    if (ReadBlobByte(image) == EOF)\n      ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n  if (overview != 0)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n          if (EOFBlob(image) != MagickFalse)\n            ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        if (EOFBlob(image) != MagickFalse)\n          break;\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n      return(OverviewImage(image_info,GetFirstImageInList(image),exception));\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n    if (EOFBlob(image) != MagickFalse)\n      ThrowPCDException(CorruptImageError,\"UnexpectedEndOfFile\");\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2,exception);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2,exception);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n      SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n      SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  if (image_info->scene != 0)\n    for (i=0; i < (ssize_t) image_info->scene; i++)\n      AppendImageToList(&image,CloneImage(image,0,0,MagickTrue,exception));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCDImage() adds attributes for the PCD image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCDImage method is:\n%\n%      size_t RegisterPCDImage(void)\n%\n*/\nModuleExport size_t RegisterPCDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCD\",\"PCD\",\"Photo CD\");\n  entry->decoder=(DecodeImageHandler *) ReadPCDImage;\n  entry->encoder=(EncodeImageHandler *) WritePCDImage;\n  entry->magick=(IsImageFormatHandler *) IsPCD;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PCD\",\"PCDS\",\"Photo CD\");\n  entry->decoder=(DecodeImageHandler *) ReadPCDImage;\n  entry->encoder=(EncodeImageHandler *) WritePCDImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCDImage() removes format registrations made by the\n%  PCD module from the list of supported formats.\n%\n%  The format of the UnregisterPCDImage method is:\n%\n%      UnregisterPCDImage(void)\n%\n*/\nModuleExport void UnregisterPCDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCD\");\n  (void) UnregisterMagickInfo(\"PCDS\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCDImage() writes an image in the Photo CD encoded image format.\n%\n%  The format of the WritePCDImage method is:\n%\n%      MagickBooleanType WritePCDImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType WritePCDTile(Image *image,const char *page_geometry,\n  const size_t tile_columns,const size_t tile_rows,ExceptionInfo *exception)\n{\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *downsample_image,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  register const Quantum\n    *p,\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Scale image to tile size.\n  */\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  if ((geometry.width % 2) != 0)\n    geometry.width--;\n  if ((geometry.height % 2) != 0)\n    geometry.height--;\n  tile_image=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,\n    exception);\n  if (tile_image == (Image *) NULL)\n    return(MagickFalse);\n  flags=ParseGeometry(page_geometry,&geometry_info);\n  geometry.width=(size_t) geometry_info.rho;\n  geometry.height=(size_t) geometry_info.sigma;\n  if ((flags & SigmaValue) == 0)\n    geometry.height=geometry.width;\n  if ((tile_image->columns != geometry.width) ||\n      (tile_image->rows != geometry.height))\n    {\n      Image\n        *bordered_image;\n\n      RectangleInfo\n        border_info;\n\n      /*\n        Put a border around the image.\n      */\n      border_info.width=(geometry.width-tile_image->columns+1) >> 1;\n      border_info.height=(geometry.height-tile_image->rows+1) >> 1;\n      bordered_image=BorderImage(tile_image,&border_info,image->compose,\n        exception);\n      if (bordered_image == (Image *) NULL)\n        return(MagickFalse);\n      tile_image=DestroyImage(tile_image);\n      tile_image=bordered_image;\n    }\n  if ((tile_image->columns != tile_columns) || (tile_image->rows != tile_rows))\n    {\n      Image\n        *resize_image;\n\n      resize_image=ResizeImage(tile_image,tile_columns,tile_rows,\n        tile_image->filter,exception);\n      if (resize_image != (Image *) NULL)\n        {\n          tile_image=DestroyImage(tile_image);\n          tile_image=resize_image;\n        }\n    }\n  (void) TransformImageColorspace(tile_image,YCCColorspace,exception);\n  downsample_image=ResizeImage(tile_image,tile_image->columns/2,\n    tile_image->rows/2,TriangleFilter,exception);\n  if (downsample_image == (Image *) NULL)\n    return(MagickFalse);\n  /*\n    Write tile to PCD file.\n  */\n  for (y=0; y < (ssize_t) tile_image->rows; y+=2)\n  {\n    p=GetVirtualPixels(tile_image,0,y,tile_image->columns,2,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) (tile_image->columns << 1); x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(tile_image,p)));\n      p+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelGreen(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelBlue(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    status=SetImageProgress(image,SaveImageTag,y,tile_image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  for (i=0; i < 0x800; i++)\n    (void) WriteBlobByte(image,'\\0');\n  downsample_image=DestroyImage(downsample_image);\n  tile_image=DestroyImage(tile_image);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType WritePCDImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *pcd_image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  pcd_image=image;\n  if (image->columns < image->rows)\n    {\n      Image\n        *rotate_image;\n\n      /*\n        Rotate portrait to landscape.\n      */\n      rotate_image=RotateImage(image,90.0,exception);\n      if (rotate_image == (Image *) NULL)\n        return(MagickFalse);\n      pcd_image=rotate_image;\n      DestroyBlob(rotate_image);\n      pcd_image->blob=ReferenceBlob(image->blob);\n    }\n  /*\n    Open output image file.\n  */\n  status=OpenBlob(image_info,pcd_image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      if (pcd_image != image)\n        pcd_image=DestroyImage(pcd_image);\n      return(status);\n    }\n  if (IssRGBCompatibleColorspace(pcd_image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(pcd_image,sRGBColorspace,exception);\n  /*\n    Write PCD image header.\n  */\n  for (i=0; i < 32; i++)\n    (void) WriteBlobByte(pcd_image,0xff);\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x0e);\n  for (i=0; i < 8; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x01);\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x05);\n  for (i=0; i < 8; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x0A);\n  for (i=0; i < 36; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < 4; i++)\n    (void) WriteBlobByte(pcd_image,0x01);\n  for (i=0; i < 1944; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  (void) WriteBlob(pcd_image,7,(const unsigned char *) \"PCD_IPI\");\n  (void) WriteBlobByte(pcd_image,0x06);\n  for (i=0; i < 1530; i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  if (image->columns < image->rows)\n    (void) WriteBlobByte(pcd_image,'\\1');\n  else\n    (void) WriteBlobByte(pcd_image,'\\0');\n  for (i=0; i < (3*0x800-1539); i++)\n    (void) WriteBlobByte(pcd_image,'\\0');\n  /*\n    Write PCD tiles.\n  */\n  status=WritePCDTile(pcd_image,\"768x512>\",192,128,exception);\n  status=WritePCDTile(pcd_image,\"768x512>\",384,256,exception);\n  status=WritePCDTile(pcd_image,\"768x512>\",768,512,exception);\n  (void) CloseBlob(pcd_image);\n  if (pcd_image != image)\n    pcd_image=DestroyImage(pcd_image);\n  return(status);\n}\n"], "filenames": ["coders/pcd.c"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [220], "fixing_code_start_loc": [210], "fixing_code_end_loc": [225], "type": "CWE-401", "message": "In ImageMagick before 7.0.8-25, some memory leaks exist in DecodeImage in coders/pcd.c.", "other": {"cve": {"id": "CVE-2019-7175", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-07T23:29:01.597", "lastModified": "2021-04-28T17:01:07.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick before 7.0.8-25, some memory leaks exist in DecodeImage in coders/pcd.c."}, {"lang": "es", "value": "En ImageMagick, en versiones anteriores a la 7.0.8-25, hay fugas de memoria en DecodeImage en coders/pcd.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-25", "matchCriteriaId": "E982CE9C-89F7-4A5D-B036-A9A483493D5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-25", "matchCriteriaId": "2F7DF2A1-ADDE-48C4-BD39-CCA15D0D767A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00034.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00006.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1450", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae"}}