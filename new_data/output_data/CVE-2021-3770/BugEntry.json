{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * indent.c: Indentation related functions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_VARTABS) || defined(PROTO)\n\n/*\n * Set the integer values corresponding to the string setting of 'vartabstop'.\n * \"array\" will be set, caller must free it if needed.\n */\n    int\ntabstop_set(char_u *var, int **array)\n{\n    int valcount = 1;\n    int t;\n    char_u *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn TRUE;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    emsg(_(e_invarg));\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\temsg(_(e_invarg));\n\treturn FALSE;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FALSE;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\t(*array)[t++] = atoi((char *)cp);\n\twhile (*cp  != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return TRUE;\n}\n\n/*\n * Calculate the number of screen spaces a tab will occupy.\n * If \"vts\" is set then the tab widths are taken from that array,\n * otherwise the value of ts is used.\n */\n    int\ntabstop_padding(colnr_T col, int ts_arg, int *vts)\n{\n    int\t\tts = ts_arg == 0 ? 8 : ts_arg;\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\tpadding = 0;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn ts - (col % ts);\n\n    tabcount = vts[0];\n\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    padding = (int)(tabcol - col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((col - tabcol) % vts[tabcount]);\n\n    return padding;\n}\n\n/*\n * Find the size of the tab that covers a particular column.\n */\n    int\ntabstop_at(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\ttab_size = 0;\n\n    if (vts == 0 || vts[0] == 0)\n\treturn ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    tab_size = vts[t];\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\ttab_size = vts[tabcount];\n\n    return tab_size;\n}\n\n/*\n * Find the column on which a tab starts.\n */\n    colnr_T\ntabstop_start(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int         excess;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn (col / ts) * ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t    return tabcol - vts[t];\n    }\n\n    excess = tabcol % vts[tabcount];\n    return excess + ((col - excess) / vts[tabcount]) * vts[tabcount];\n}\n\n/*\n * Find the number of tabs and spaces necessary to get from one column\n * to another.\n */\n    void\ntabstop_fromto(\n\tcolnr_T start_col,\n\tcolnr_T end_col,\n\tint\tts_arg,\n\tint\t*vts,\n\tint\t*ntabs,\n\tint\t*nspcs)\n{\n    int\t\tspaces = end_col - start_col;\n    colnr_T\ttabcol = 0;\n    int\t\tpadding = 0;\n    int\t\ttabcount;\n    int\t\tt;\n    int\t\tts = ts_arg == 0 ? curbuf->b_p_ts : ts_arg;\n\n    if (vts == NULL || vts[0] == 0)\n    {\n\tint tabs = 0;\n\tint initspc = 0;\n\n\tinitspc = ts - (start_col % ts);\n\tif (spaces >= initspc)\n\t{\n\t    spaces -= initspc;\n\t    tabs++;\n\t}\n\ttabs += spaces / ts;\n\tspaces -= (spaces / ts) * ts;\n\n\t*ntabs = tabs;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    // Find the padding needed to reach the next tabstop.\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > start_col)\n\t{\n\t    padding = (int)(tabcol - start_col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((start_col - tabcol) % vts[tabcount]);\n\n    // If the space needed is less than the padding no tabs can be used.\n    if (spaces < padding)\n    {\n\t*ntabs = 0;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    *ntabs = 1;\n    spaces -= padding;\n\n    // At least one tab has been used. See if any more will fit.\n    while (spaces != 0 && ++t <= tabcount)\n    {\n\tpadding = vts[t];\n\tif (spaces < padding)\n\t{\n\t    *nspcs = spaces;\n\t    return;\n\t}\n\t++*ntabs;\n\tspaces -= padding;\n    }\n\n    *ntabs += spaces / vts[tabcount];\n    *nspcs =  spaces % vts[tabcount];\n}\n\n/*\n * See if two tabstop arrays contain the same values.\n */\n    static int\ntabstop_eq(int *ts1, int *ts2)\n{\n    int\t\tt;\n\n    if ((ts1 == 0 && ts2) || (ts1 && ts2 == 0))\n\treturn FALSE;\n    if (ts1 == ts2)\n\treturn TRUE;\n    if (ts1[0] != ts2[0])\n\treturn FALSE;\n\n    for (t = 1; t <= ts1[0]; ++t)\n\tif (ts1[t] != ts2[t])\n\t    return FALSE;\n\n    return TRUE;\n}\n\n# if defined(FEAT_BEVAL) || defined(PROTO)\n/*\n * Copy a tabstop array, allocating space for the new array.\n */\n    int *\ntabstop_copy(int *oldts)\n{\n    int\t\t*newts;\n    int\t\tt;\n\n    if (oldts == NULL)\n\treturn NULL;\n    newts = ALLOC_MULT(int, oldts[0] + 1);\n    if (newts != NULL)\n\tfor (t = 0; t <= oldts[0]; ++t)\n\t    newts[t] = oldts[t];\n    return newts;\n}\n# endif\n\n/*\n * Return a count of the number of tabstops.\n */\n    int\ntabstop_count(int *ts)\n{\n    return ts != NULL ? ts[0] : 0;\n}\n\n/*\n * Return the first tabstop, or 8 if there are no tabstops defined.\n */\n    int\ntabstop_first(int *ts)\n{\n    return ts != NULL ? ts[1] : 8;\n}\n\n#endif\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\n    long\nget_sw_value(buf_T *buf)\n{\n    return get_sw_value_col(buf, 0);\n}\n\n/*\n * Idem, using \"pos\".\n */\n    static long\nget_sw_value_pos(buf_T *buf, pos_T *pos)\n{\n    pos_T save_cursor = curwin->w_cursor;\n    long sw_value;\n\n    curwin->w_cursor = *pos;\n    sw_value = get_sw_value_col(buf, get_nolist_virtcol());\n    curwin->w_cursor = save_cursor;\n    return sw_value;\n}\n\n/*\n * Idem, using the first non-black in the current line.\n */\n    long\nget_sw_value_indent(buf_T *buf)\n{\n    pos_T pos = curwin->w_cursor;\n\n    pos.col = getwhitecols_curline();\n    return get_sw_value_pos(buf, &pos);\n}\n\n/*\n * Idem, using virtual column \"col\".\n */\n    long\nget_sw_value_col(buf_T *buf, colnr_T col UNUSED)\n{\n    return buf->b_p_sw ? buf->b_p_sw :\n#ifdef FEAT_VARTABS\n\ttabstop_at(col, buf->b_p_ts, buf->b_p_vts_array);\n#else\n\tbuf->b_p_ts;\n#endif\n}\n\n/*\n * Return the effective softtabstop value for the current buffer, using the\n * 'shiftwidth' value when 'softtabstop' is negative.\n */\n    long\nget_sts_value(void)\n{\n    return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n}\n\n/*\n * Count the size (in window cells) of the indent in the current line.\n */\n    int\nget_indent(void)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_curline(), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n/*\n * Count the size (in window cells) of the indent in line \"lnum\".\n */\n    int\nget_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Count the size (in window cells) of the indent in line \"lnum\" of buffer\n * \"buf\".\n */\n    int\nget_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}\n#endif\n\n/*\n * count the size (in window cells) of the indent in line \"ptr\", with\n * 'tabstop' at \"ts\"\n */\n    int\nget_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) // if TRUE, count only screen size for tabs\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\t// count a tab for what it is worth\n\t\tcount += ts - (count % ts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n\n#ifdef FEAT_VARTABS\n/*\n * Count the size (in window cells) of the indent in line \"ptr\", using\n * variable tabstops.\n * if \"list\" is TRUE, count only screen size for tabs.\n */\n    int\nget_indent_str_vtab(char_u *ptr, int ts, int *vts, int list)\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)    // count a tab for what it is worth\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += tabstop_padding(count, ts, vts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n#endif\n\n/*\n * Set the indent of the current line.\n * Leaves the cursor on the first non-blank in the line.\n * Caller must take care of undo.\n * \"flags\":\n *\tSIN_CHANGED:\tcall changed_bytes() if the line was changed.\n *\tSIN_INSERT:\tinsert the indent in front of the line.\n *\tSIN_UNDO:\tsave line for undo before changing it.\n * Returns TRUE if the line was changed.\n */\n    int\nset_indent(\n    int\t\tsize,\t\t    // measured in spaces\n    int\t\tflags)\n{\n    char_u\t*p;\n    char_u\t*newline;\n    char_u\t*oldline;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\t    // measured in characters\n    int\t\tline_len;\n    int\t\tdoit = FALSE;\n    int\t\tind_done = 0;\t    // measured in spaces\n#ifdef FEAT_VARTABS\n    int\t\tind_col = 0;\n#endif\n    int\t\ttab_pad;\n    int\t\tretval = FALSE;\n    int\t\torig_char_len = -1; // number of initial whitespace chars when\n\t\t\t\t    // 'et' and 'pi' are both set\n\n    // First check if there is anything to do and compute the number of\n    // characters needed for the indent.\n    todo = size;\n    ind_len = 0;\n    p = oldline = ml_get_curline();\n\n    // Calculate the buffer size for the new indent, and check to see if it\n    // isn't already set\n\n    // if 'expandtab' isn't set: use TABs; if both 'expandtab' and\n    // 'preserveindent' are set count the number of characters at the\n    // beginning of the line to be copied\n    if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    ind_done = 0;\n\n\t    // count as many characters as we can use\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ++ind_len;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_len;\n\t\t    ++ind_done;\n\t\t}\n\t\t++p;\n\t    }\n\n#ifdef FEAT_VARTABS\n\t    // These diverge from this point.\n\t    ind_col = ind_done;\n#endif\n\t    // Set initial number of whitespace chars to copy if we are\n\t    // preserving indent but expandtab is set\n\t    if (curbuf->b_p_et)\n\t\torig_char_len = ind_len;\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad && orig_char_len == -1)\n\t    {\n\t\tdoit = TRUE;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\t// ind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t}\n\n\t// count tabs required for indent\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= tab_pad;\n\t    ++ind_len;\n\t    ind_col += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= (int)curbuf->b_p_ts;\n\t    ++ind_len;\n\t    // ind_done += (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    // count spaces required for indent\n    while (todo > 0)\n    {\n\tif (*p != ' ')\n\t    doit = TRUE;\n\telse\n\t    ++p;\n\t--todo;\n\t++ind_len;\n\t// ++ind_done;\n    }\n\n    // Return if the indent is OK already.\n    if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))\n\treturn FALSE;\n\n    // Allocate memory for the new line.\n    if (flags & SIN_INSERT)\n\tp = oldline;\n    else\n\tp = skipwhite(p);\n    line_len = (int)STRLEN(p) + 1;\n\n    // If 'preserveindent' and 'expandtab' are both set keep the original\n    // characters and allocate accordingly.  We will fill the rest with spaces\n    // after the if (!curbuf->b_p_et) below.\n    if (orig_char_len != -1)\n    {\n\tnewline = alloc(orig_char_len + size - ind_done + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ttodo = size - ind_done;\n\tind_len = orig_char_len + todo;    // Set total length of indent in\n\t\t\t\t\t   // characters, which may have been\n\t\t\t\t\t   // undercounted until now\n\tp = oldline;\n\ts = newline;\n\twhile (orig_char_len > 0)\n\t{\n\t    *s++ = *p++;\n\t    orig_char_len--;\n\t}\n\n\t// Skip over any additional white space (useful when newindent is less\n\t// than old)\n\twhile (VIM_ISWHITE(*p))\n\t    ++p;\n\n    }\n    else\n    {\n\ttodo = size;\n\tnewline = alloc(ind_len + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ts = newline;\n    }\n\n    // Put the characters in the new line.\n    // if 'expandtab' isn't set: use TABs\n    if (!curbuf->b_p_et)\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    p = oldline;\n\t    ind_done = 0;\n\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_done;\n\t\t}\n\t\t*s++ = *p++;\n\t    }\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad)\n\t    {\n\t\t*s++ = TAB;\n\t\ttodo -= tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_done += tab_pad;\n#endif\n\t    }\n\n\t    p = skipwhite(p);\n\t}\n\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    *s++ = TAB;\n\t    todo -= tab_pad;\n\t    ind_done += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    *s++ = TAB;\n\t    todo -= (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    while (todo > 0)\n    {\n\t*s++ = ' ';\n\t--todo;\n    }\n    mch_memmove(s, p, (size_t)line_len);\n\n    // Replace the line (unless undo fails).\n    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)\n    {\n\tcolnr_T old_offset = (colnr_T)(p - oldline);\n\tcolnr_T new_offset = (colnr_T)(s - newline);\n\n\t// this may free \"newline\"\n\tml_replace(curwin->w_cursor.lnum, newline, FALSE);\n\tif (flags & SIN_CHANGED)\n\t    changed_bytes(curwin->w_cursor.lnum, 0);\n\n\t// Correct saved cursor position if it is in this line.\n\tif (saved_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    if (saved_cursor.col >= old_offset)\n\t\t// cursor was after the indent, adjust for the number of\n\t\t// bytes added/removed\n\t\tsaved_cursor.col += ind_len - old_offset;\n\t    else if (saved_cursor.col >= new_offset)\n\t\t// cursor was in the indent, and is now after it, put it back\n\t\t// at the start of the indent (replacing spaces with TAB)\n\t\tsaved_cursor.col = new_offset;\n\t}\n#ifdef FEAT_PROP_POPUP\n\t{\n\t    int added = ind_len - old_offset;\n\n\t    // When increasing indent this behaves like spaces were inserted at\n\t    // the old indent, when decreasing indent it behaves like spaces\n\t    // were deleted at the new indent.\n\t    adjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t  added > 0 ? old_offset : (colnr_T)ind_len, added, 0);\n\t}\n#endif\n\tretval = TRUE;\n    }\n    else\n\tvim_free(newline);\n\n    curwin->w_cursor.col = ind_len;\n    return retval;\n}\n\n/*\n * Return the indent of the current line after a number.  Return -1 if no\n * number was found.  Used for 'n' in 'formatoptions': numbered list.\n * Since a pattern is used it can actually handle more than numbers.\n */\n    int\nget_number_indent(linenr_T lnum)\n{\n    colnr_T\tcol;\n    pos_T\tpos;\n\n    regmatch_T\tregmatch;\n    int\t\tlead_len = 0;\t// length of comment leader\n\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn -1;\n    pos.lnum = 0;\n\n    // In format_lines() (i.e. not insert mode), fo+=q is needed too...\n    if ((State & INSERT) || has_format_option(FO_Q_COMS))\n\tlead_len = get_leader_len(ml_get(lnum), NULL, FALSE, TRUE);\n\n    regmatch.regprog = vim_regcomp(curbuf->b_p_flp, RE_MAGIC);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = FALSE;\n\n\t// vim_regexec() expects a pointer to a line.  This lets us\n\t// start matching for the flp beyond any comment leader...\n\tif (vim_regexec(&regmatch, ml_get(lnum) + lead_len, (colnr_T)0))\n\t{\n\t    pos.lnum = lnum;\n\t    pos.col = (colnr_T)(*regmatch.endp - ml_get(lnum));\n\t    pos.coladd = 0;\n\t}\n\tvim_regfree(regmatch.regprog);\n    }\n\n    if (pos.lnum == 0 || *ml_get_pos(&pos) == NUL)\n\treturn -1;\n    getvcol(curwin, &pos, &col, NULL, NULL);\n    return (int)col;\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * This is called when 'breakindentopt' is changed and when a window is\n * initialized.\n */\n    int\nbriopt_check(win_T *wp)\n{\n    char_u\t*p;\n    int\t\tbri_shift = 0;\n    long\tbri_min = 20;\n    int\t\tbri_sbr = FALSE;\n    int\t\tbri_list = 0;\n\n    p = wp->w_p_briopt;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"shift:\", 6) == 0\n\t\t && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))\n\t{\n\t    p += 6;\n\t    bri_shift = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"min:\", 4) == 0 && VIM_ISDIGIT(p[4]))\n\t{\n\t    p += 4;\n\t    bri_min = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"sbr\", 3) == 0)\n\t{\n\t    p += 3;\n\t    bri_sbr = TRUE;\n\t}\n\telse if (STRNCMP(p, \"list:\", 5) == 0)\n\t{\n\t    p += 5;\n\t    bri_list = getdigits(&p);\n\t}\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    wp->w_briopt_shift = bri_shift;\n    wp->w_briopt_min   = bri_min;\n    wp->w_briopt_sbr   = bri_sbr;\n    wp->w_briopt_list  = bri_list;\n\n    return OK;\n}\n\n/*\n * Return appropriate space number for breakindent, taking influencing\n * parameters into account. Window must be specified, since it is not\n * necessarily always the current one.\n */\n    int\nget_breakindent_win(\n    win_T\t*wp,\n    char_u\t*line) // start of the line\n{\n    static int\t    prev_indent = 0;  // cached indent value\n    static long\t    prev_ts     = 0L; // cached tabstop value\n    static char_u   *prev_line = NULL; // cached pointer to line\n    static varnumber_T prev_tick = 0;   // changedtick of cached value\n# ifdef FEAT_VARTABS\n    static int      *prev_vts = NULL;    // cached vartabs values\n# endif\n    int\t\t    bri = 0;\n    // window width minus window margin space, i.e. what rests for text\n    const int\t    eff_wwidth = wp->w_width\n\t\t\t    - ((wp->w_p_nu || wp->w_p_rnu)\n\t\t\t\t&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)\n\t\t\t\t\t\t? number_width(wp) + 1 : 0);\n\n    // used cached indent, unless pointer or 'tabstop' changed\n    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts\n\t    || prev_tick != CHANGEDTICK(wp->w_buffer)\n# ifdef FEAT_VARTABS\n\t    || prev_vts != wp->w_buffer->b_p_vts_array\n# endif\n\t)\n    {\n\tprev_line = line;\n\tprev_ts = wp->w_buffer->b_p_ts;\n\tprev_tick = CHANGEDTICK(wp->w_buffer);\n# ifdef FEAT_VARTABS\n\tprev_vts = wp->w_buffer->b_p_vts_array;\n\tprev_indent = get_indent_str_vtab(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array, wp->w_p_list);\n# else\n\tprev_indent = get_indent_str(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts, wp->w_p_list);\n# endif\n    }\n    bri = prev_indent + wp->w_briopt_shift;\n\n    // Add offset for number column, if 'n' is in 'cpoptions'\n    bri += win_col_off2(wp);\n\n    // add additional indent for numbered lists\n    if (wp->w_briopt_list != 0)\n    {\n\tregmatch_T\t    regmatch;\n\n\tregmatch.regprog = vim_regcomp(curbuf->b_p_flp,\n\t\t\t\t   RE_MAGIC + RE_STRING + RE_AUTO + RE_STRICT);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = FALSE;\n\t    if (vim_regexec(&regmatch, line, 0))\n\t    {\n\t\tif (wp->w_briopt_list > 0)\n\t\t    bri += wp->w_briopt_list;\n\t\telse\n\t\t    bri = (*regmatch.endp - *regmatch.startp);\n\t    }\n\t    vim_regfree(regmatch.regprog);\n\t}\n    }\n\n    // indent minus the length of the showbreak string\n    if (wp->w_briopt_sbr)\n\tbri -= vim_strsize(get_showbreak_value(wp));\n\n\n    // never indent past left window margin\n    if (bri < 0)\n\tbri = 0;\n\n    // always leave at least bri_min characters on the left,\n    // if text width is sufficient\n    else if (bri > eff_wwidth - wp->w_briopt_min)\n\tbri = (eff_wwidth - wp->w_briopt_min < 0)\n\t\t\t\t\t   ? 0 : eff_wwidth - wp->w_briopt_min;\n\n    return bri;\n}\n#endif\n\n/*\n * When extra == 0: Return TRUE if the cursor is before or on the first\n *\t\t    non-blank in the line.\n * When extra == 1: Return TRUE if the cursor is before the first non-blank in\n *\t\t    the line.\n */\n    int\ninindent(int extra)\n{\n    char_u\t*ptr;\n    colnr_T\tcol;\n\n    for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)\n\t++ptr;\n    if (col >= curwin->w_cursor.col + extra)\n\treturn TRUE;\n    else\n\treturn FALSE;\n}\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * op_reindent - handle reindenting a block of lines.\n */\n    void\nop_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n\n    // Don't even try when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    for (i = oap->line_count; --i >= 0 && !got_int; )\n    {\n\t// it's a slow thing to do, so give feedback so there's no worry that\n\t// the computer's just hung.\n\n\tif (i > 1\n\t\t&& (i % 50 == 0 || i == oap->line_count - 1)\n\t\t&& oap->line_count > p_report)\n\t    smsg(_(\"%ld lines to indent... \"), i);\n\n\t// Be vi-compatible: For lisp indenting the first line is not\n\t// indented, unless there is only one line.\n# ifdef FEAT_LISP\n\tif (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t    || how != get_lisp_indent)\n# endif\n\t{\n\t    l = skipwhite(ml_get_curline());\n\t    if (*l == NUL)\t\t    // empty or blank line\n\t\tamount = 0;\n\t    else\n\t\tamount = how();\t\t    // get the indent for this line\n\n\t    if (amount >= 0 && set_indent(amount, SIN_UNDO))\n\t    {\n\t\t// did change the indent, call changed_lines() later\n\t\tif (first_changed == 0)\n\t\t    first_changed = curwin->w_cursor.lnum;\n\t\tlast_changed = curwin->w_cursor.lnum;\n\t    }\n\t}\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;  // make sure it's valid\n    }\n\n    // put cursor on first non-blank of indented line\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n\n    // Mark changed lines so that they will be redrawn.  When Visual\n    // highlighting was present, need to continue until the last line.  When\n    // there is no change still need to remove the Visual highlighting.\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set '[ and '] marks\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}\n#endif // defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\n    int\npreprocs_left(void)\n{\n    return\n# ifdef FEAT_SMARTINDENT\n#  ifdef FEAT_CINDENT\n\t(curbuf->b_p_si && !curbuf->b_p_cin) ||\n#  else\n\tcurbuf->b_p_si\n#  endif\n# endif\n# ifdef FEAT_CINDENT\n\t(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)\n\t\t\t\t\t   && curbuf->b_ind_hash_comment == 0)\n# endif\n\t;\n}\n#endif\n\n#ifdef FEAT_SMARTINDENT\n/*\n * Try to do some very smart auto-indenting.\n * Used when inserting a \"normal\" character.\n */\n    void\nins_try_si(int c)\n{\n    pos_T\t*pos, old_pos;\n    char_u\t*ptr;\n    int\t\ti;\n    int\t\ttemp;\n\n    // do some very smart indenting when entering '{' or '}'\n    if (((did_si || can_si_back) && c == '{') || (can_si && c == '}'))\n    {\n\t// for '}' set indent equal to indent of line containing matching '{'\n\tif (c == '}' && (pos = findmatch(NULL, '{')) != NULL)\n\t{\n\t    old_pos = curwin->w_cursor;\n\t    // If the matching '{' has a ')' immediately before it (ignoring\n\t    // white-space), then line up with the start of the line\n\t    // containing the matching '(' if there is one.  This handles the\n\t    // case where an \"if (..\\n..) {\" statement continues over multiple\n\t    // lines -- webb\n\t    ptr = ml_get(pos->lnum);\n\t    i = pos->col;\n\t    if (i > 0)\t\t// skip blanks before '{'\n\t\twhile (--i > 0 && VIM_ISWHITE(ptr[i]))\n\t\t    ;\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = i;\n\t    if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)\n\t\tcurwin->w_cursor = *pos;\n\t    i = get_indent();\n\t    curwin->w_cursor = old_pos;\n\t    if (State & VREPLACE_FLAG)\n\t\tchange_indent(INDENT_SET, i, FALSE, NUL, TRUE);\n\t    else\n\t\t(void)set_indent(i, SIN_CHANGED);\n\t}\n\telse if (curwin->w_cursor.col > 0)\n\t{\n\t    // when inserting '{' after \"O\" reduce indent, but not\n\t    // more than indent of previous line\n\t    temp = TRUE;\n\t    if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1)\n\t    {\n\t\told_pos = curwin->w_cursor;\n\t\ti = get_indent();\n\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    ptr = skipwhite(ml_get(--(curwin->w_cursor.lnum)));\n\n\t\t    // ignore empty lines and lines starting with '#'.\n\t\t    if (*ptr != '#' && *ptr != NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (get_indent() >= i)\n\t\t    temp = FALSE;\n\t\tcurwin->w_cursor = old_pos;\n\t    }\n\t    if (temp)\n\t\tshift_line(TRUE, FALSE, 1, TRUE);\n\t}\n    }\n\n    // set indent of '#' always to 0\n    if (curwin->w_cursor.col > 0 && can_si && c == '#')\n    {\n\t// remember current indent for next line\n\told_indent = get_indent();\n\t(void)set_indent(0, SIN_CHANGED);\n    }\n\n    // Adjust ai_col, the char at this position can be deleted.\n    if (ai_col > curwin->w_cursor.col)\n\tai_col = curwin->w_cursor.col;\n}\n#endif\n\n/*\n * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).\n * Keep the cursor on the same character.\n * type == INDENT_INC\tincrease indent (for CTRL-T or <Tab>)\n * type == INDENT_DEC\tdecrease indent (for CTRL-D)\n * type == INDENT_SET\tset indent to \"amount\"\n * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).\n */\n    void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}\n\n/*\n * Copy the indent from ptr to the current line (and fill to size)\n * Leaves the cursor on the first non-blank in the line.\n * Returns TRUE if the line was changed.\n */\n    int\ncopy_indent(int size, char_u *src)\n{\n    char_u\t*p = NULL;\n    char_u\t*line = NULL;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\n    int\t\tline_len = 0;\n    int\t\ttab_pad;\n    int\t\tind_done;\n    int\t\tround;\n#ifdef FEAT_VARTABS\n    int\t\tind_col;\n#endif\n\n    // Round 1: compute the number of characters needed for the indent\n    // Round 2: copy the characters.\n    for (round = 1; round <= 2; ++round)\n    {\n\ttodo = size;\n\tind_len = 0;\n\tind_done = 0;\n#ifdef FEAT_VARTABS\n\tind_col = 0;\n#endif\n\ts = src;\n\n\t// Count/copy the usable portion of the source line\n\twhile (todo > 0 && VIM_ISWHITE(*s))\n\t{\n\t    if (*s == TAB)\n\t    {\n#ifdef FEAT_VARTABS\n\t\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\ttab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t// Stop if this tab will overshoot the target\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\tind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t    else\n\t    {\n\t\t--todo;\n\t\t++ind_done;\n#ifdef FEAT_VARTABS\n\t\t++ind_col;\n#endif\n\t    }\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = *s;\n\t    ++s;\n\t}\n\n\t// Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\ttab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\tif (todo >= tab_pad && !curbuf->b_p_et)\n\t{\n\t    todo -= tab_pad;\n\t    ++ind_len;\n#ifdef FEAT_VARTABS\n\t    ind_col += tab_pad;\n#endif\n\t    if (p != NULL)\n\t\t*p++ = TAB;\n\t}\n\n\t// Add tabs required for indent\n\tif (!curbuf->b_p_et)\n\t{\n#ifdef FEAT_VARTABS\n\t    for (;;)\n\t    {\n\t\ttab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\tind_col += tab_pad;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#else\n\t    while (todo >= (int)curbuf->b_p_ts)\n\t    {\n\t\ttodo -= (int)curbuf->b_p_ts;\n\t\t++ind_len;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#endif\n\t}\n\n\t// Count/add spaces required for indent\n\twhile (todo > 0)\n\t{\n\t    --todo;\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = ' ';\n\t}\n\n\tif (p == NULL)\n\t{\n\t    // Allocate memory for the result: the copied indent, new indent\n\t    // and the rest of the line.\n\t    line_len = (int)STRLEN(ml_get_curline()) + 1;\n\t    line = alloc(ind_len + line_len);\n\t    if (line == NULL)\n\t\treturn FALSE;\n\t    p = line;\n\t}\n    }\n\n    // Append the original line\n    mch_memmove(p, ml_get_curline(), (size_t)line_len);\n\n    // Replace the line\n    ml_replace(curwin->w_cursor.lnum, line, FALSE);\n\n    // Put the cursor after the indent.\n    curwin->w_cursor.col = ind_len;\n    return TRUE;\n}\n\n/*\n * \":retab\".\n */\n    void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (!tabstop_set(eap->arg, &new_vts_array))\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    new_ts = getdigits(&(eap->arg));\n    if (new_ts < 0)\n    {\n\temsg(_(e_positive));\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interr));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}\n\n#if (defined(FEAT_CINDENT) && defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get indent level from 'indentexpr'.\n */\n    int\nget_expr_indent(void)\n{\n    int\t\tindent = -1;\n    char_u\t*inde_copy;\n    pos_T\tsave_pos;\n    colnr_T\tsave_curswant;\n    int\t\tsave_set_curswant;\n    int\t\tsave_State;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"indentexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    // Save and restore cursor position and curswant, in case it was changed\n    // via :normal commands\n    save_pos = curwin->w_cursor;\n    save_curswant = curwin->w_curswant;\n    save_set_curswant = curwin->w_set_curswant;\n    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n\n    // Need to make a copy, the 'indentexpr' option could be changed while\n    // evaluating it.\n    inde_copy = vim_strsave(curbuf->b_p_inde);\n    if (inde_copy != NULL)\n    {\n\tindent = (int)eval_to_number(inde_copy);\n\tvim_free(inde_copy);\n    }\n\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n\n    // Restore the cursor position so that 'indentexpr' doesn't need to.\n    // Pretend to be in Insert mode, allow cursor past end of line for \"o\"\n    // command.\n    save_State = State;\n    State = INSERT;\n    curwin->w_cursor = save_pos;\n    curwin->w_curswant = save_curswant;\n    curwin->w_set_curswant = save_set_curswant;\n    check_cursor();\n    State = save_State;\n\n    // Reset did_throw, unless 'debug' has \"throw\" and inside a try/catch.\n    if (did_throw && (vim_strchr(p_debug, 't') == NULL || trylevel == 0))\n    {\n\thandle_did_throw();\n\tdid_throw = FALSE;\n    }\n\n    // If there is an error, just keep the current indent.\n    if (indent < 0)\n\tindent = get_indent();\n\n    return indent;\n}\n#endif\n\n#if defined(FEAT_LISP) || defined(PROTO)\n\n    static int\nlisp_match(char_u *p)\n{\n    char_u\tbuf[LSIZE];\n    int\t\tlen;\n    char_u\t*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;\n\n    while (*word != NUL)\n    {\n\t(void)copy_option_part(&word, buf, LSIZE, \",\");\n\tlen = (int)STRLEN(buf);\n\tif (STRNCMP(buf, p, len) == 0 && p[len] == ' ')\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * When 'p' is present in 'cpoptions, a Vi compatible method is used.\n * The incompatible newer method is quite a bit better at indenting\n * code in lisp-like languages than the traditional one; it's still\n * mostly heuristics however -- Dirk van Deun, dirk@rave.org\n *\n * TODO:\n * Findmatch() should be adapted for lisp, also to make showmatch\n * work correctly: now (v5.3) it seems all C/C++ oriented:\n * - it does not recognize the #\\( and #\\) notations as character literals\n * - it doesn't know about comments starting with a semicolon\n * - it incorrectly interprets '(' as a character literal\n * All this messes up get_lisp_indent in some rare cases.\n * Update from Sergey Khorev:\n * I tried to fix the first two issues.\n */\n    int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}\n#endif // FEAT_LISP\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Re-indent the current line, based on the current contents of it and the\n * surrounding lines. Fixing the cursor position seems really easy -- I'm very\n * confused what all the part that handles Control-T is doing that I'm not.\n * \"get_the_indent\" should be get_c_indent, get_expr_indent or get_lisp_indent.\n */\n\n    void\nfixthisline(int (*get_the_indent)(void))\n{\n    int amount = get_the_indent();\n\n    if (amount >= 0)\n    {\n\tchange_indent(INDENT_SET, amount, FALSE, 0, TRUE);\n\tif (linewhite(curwin->w_cursor.lnum))\n\t    did_ai = TRUE;\t// delete the indent if the line stays empty\n    }\n}\n\n    void\nfix_indent(void)\n{\n    if (p_paste)\n\treturn;\n# ifdef FEAT_LISP\n    if (curbuf->b_p_lisp && curbuf->b_p_ai)\n\tfixthisline(get_lisp_indent);\n# endif\n# if defined(FEAT_LISP) && defined(FEAT_CINDENT)\n    else\n# endif\n# ifdef FEAT_CINDENT\n\tif (cindent_on())\n\t    do_c_expr_indent();\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"indent()\" function\n */\n    void\nf_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n\trettv->vval.v_number = -1;\n}\n\n/*\n * \"lispindent(lnum)\" function\n */\n    void\nf_lispindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_LISP\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_lisp_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else\n#endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in structs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/quickref.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n * - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag, add a\n *   comment at the help for the 'compatible' option.\n */\n\n#define IN_OPTION_C\n#include \"vim.h\"\n#include \"optiondefs.h\"\n\nstatic void set_options_default(int opt_flags);\nstatic void set_string_default_esc(char *name, char_u *val, int escape);\nstatic char_u *find_dup_item(char_u *origval, char_u *newval, long_u flags);\nstatic char_u *option_expand(int opt_idx, char_u *val);\nstatic void didset_options(void);\nstatic void didset_options2(void);\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic long_u *insecure_flag(int opt_idx, int opt_flags);\n#else\n# define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)\n#endif\nstatic char *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);\nstatic char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen, int opt_flags);\nstatic int find_key_option(char_u *arg_arg, int has_lt);\nstatic void showoptions(int all, int opt_flags);\nstatic int optval_default(struct vimoption *, char_u *varp, int compatible);\nstatic void showoneopt(struct vimoption *, int opt_flags);\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, long_u flags);\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep);\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value);\nstatic int istermoption(struct vimoption *p);\nstatic char_u *get_varp_scope(struct vimoption *p, int opt_flags);\nstatic char_u *get_varp(struct vimoption *);\nstatic void check_win_options(win_T *win);\nstatic void option_value2string(struct vimoption *, int opt_flags);\nstatic void check_winopt(winopt_T *wop);\nstatic int wc_use_keyname(char_u *varp, long *wcp);\nstatic void paste_option_changed(void);\nstatic void compatible_set(void);\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n * If \"clean_arg\" is TRUE Vim was started with --clean.\n */\n    void\nset_init_1(int clean_arg)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n    long_u\tn;\n\n#ifdef FEAT_LANGMAP\n    langmap_init();\n#endif\n\n    // Be Vi compatible by default\n    p_cp = TRUE;\n\n    // Use POSIX compatibility when $VIM_POSIX is set.\n    if (mch_getenv((char_u *)\"VIM_POSIX\") != NULL)\n    {\n\tset_string_default(\"cpo\", (char_u *)CPO_ALL);\n\tset_string_default(\"shm\", (char_u *)SHM_POSIX);\n    }\n\n    /*\n     * Find default value for 'shell' option.\n     * Don't use it if it is empty.\n     */\n    if (((p = mch_getenv((char_u *)\"SHELL\")) != NULL && *p != NUL)\n#if defined(MSWIN)\n\t    || ((p = mch_getenv((char_u *)\"COMSPEC\")) != NULL && *p != NUL)\n\t    || ((p = (char_u *)default_shell()) != NULL && *p != NUL)\n#endif\n\t    )\n#if defined(MSWIN)\n    {\n\t// For MS-Windows put the path in quotes instead of escaping spaces.\n\tchar_u\t    *cmd;\n\tsize_t\t    len;\n\n\tif (vim_strchr(p, ' ') != NULL)\n\t{\n\t    len = STRLEN(p) + 3;  // two quotes and a trailing NUL\n\t    cmd = alloc(len);\n\t    if (cmd != NULL)\n\t    {\n\t\tvim_snprintf((char *)cmd, len, \"\\\"%s\\\"\", p);\n\t\tset_string_default(\"sh\", cmd);\n\t\tvim_free(cmd);\n\t    }\n\t}\n\telse\n\t    set_string_default(\"sh\", p);\n    }\n#else\n\tset_string_default_esc(\"sh\", p, TRUE);\n#endif\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Set the default for 'backupskip' to include environment variables for\n     * temp files.\n     */\n    {\n# ifdef UNIX\n\tstatic char\t*(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n\tstatic char\t*(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n\tint\t\tlen;\n\tgarray_T\tga;\n\tint\t\tmustfree;\n\tchar_u\t\t*item;\n\n\topt_idx = findoption((char_u *)\"backupskip\");\n\n\tga_init2(&ga, 1, 100);\n\tfor (n = 0; n < (long)ARRAY_LENGTH(names); ++n)\n\t{\n\t    mustfree = FALSE;\n# ifdef UNIX\n\t    if (*names[n] == NUL)\n#  ifdef MACOS_X\n\t\tp = (char_u *)\"/private/tmp\";\n#  else\n\t\tp = (char_u *)\"/tmp\";\n#  endif\n\t    else\n# endif\n\t\tp = vim_getenv((char_u *)names[n], &mustfree);\n\t    if (p != NULL && *p != NUL)\n\t    {\n\t\t// First time count the NUL, otherwise count the ','.\n\t\tlen = (int)STRLEN(p) + 3;\n\t\titem = alloc(len);\n\t\tSTRCPY(item, p);\n\t\tadd_pathsep(item);\n\t\tSTRCAT(item, \"*\");\n\t\tif (find_dup_item(ga.ga_data, item, options[opt_idx].flags)\n\t\t\t\t\t\t\t\t\t== NULL\n\t\t\t&& ga_grow(&ga, len) == OK)\n\t\t{\n\t\t    if (ga.ga_len > 0)\n\t\t\tSTRCAT(ga.ga_data, \",\");\n\t\t    STRCAT(ga.ga_data, item);\n\t\t    ga.ga_len += len;\n\t\t}\n\t\tvim_free(item);\n\t    }\n\t    if (mustfree)\n\t\tvim_free(p);\n\t}\n\tif (ga.ga_data != NULL)\n\t{\n\t    set_string_default(\"bsk\", ga.ga_data);\n\t    vim_free(ga.ga_data);\n\t}\n    }\n#endif\n\n    /*\n     * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n     */\n    opt_idx = findoption((char_u *)\"maxmemtot\");\n    if (opt_idx >= 0)\n    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\tif (options[opt_idx].def_val[VI_DEFAULT] == (char_u *)0L)\n#endif\n\t{\n#ifdef HAVE_AVAIL_MEM\n\t    // Use amount of memory available at this moment.\n\t    n = (mch_avail_mem(FALSE) >> 1);\n#else\n# ifdef HAVE_TOTAL_MEM\n\t    // Use amount of memory available to Vim.\n\t    n = (mch_total_mem(FALSE) >> 1);\n# else\n\t    n = (0x7fffffff >> 11);\n# endif\n#endif\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    opt_idx = findoption((char_u *)\"maxmem\");\n\t    if (opt_idx >= 0)\n\t    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\t\tif ((long)(long_i)options[opt_idx].def_val[VI_DEFAULT] > (long)n\n\t\t  || (long)(long_i)options[opt_idx].def_val[VI_DEFAULT] == 0L)\n#endif\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SEARCHPATH\n    {\n\tchar_u\t*cdpath;\n\tchar_u\t*buf;\n\tint\ti;\n\tint\tj;\n\tint\tmustfree = FALSE;\n\n\t// Initialize the 'cdpath' option's default value.\n\tcdpath = vim_getenv((char_u *)\"CDPATH\", &mustfree);\n\tif (cdpath != NULL)\n\t{\n\t    buf = alloc((STRLEN(cdpath) << 1) + 2);\n\t    if (buf != NULL)\n\t    {\n\t\tbuf[0] = ',';\t    // start with \",\", current dir first\n\t\tj = 1;\n\t\tfor (i = 0; cdpath[i] != NUL; ++i)\n\t\t{\n\t\t    if (vim_ispathlistsep(cdpath[i]))\n\t\t\tbuf[j++] = ',';\n\t\t    else\n\t\t    {\n\t\t\tif (cdpath[i] == ' ' || cdpath[i] == ',')\n\t\t\t    buf[j++] = '\\\\';\n\t\t\tbuf[j++] = cdpath[i];\n\t\t    }\n\t\t}\n\t\tbuf[j] = NUL;\n\t\topt_idx = findoption((char_u *)\"cdpath\");\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = buf;\n\t\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t}\n\t\telse\n\t\t    vim_free(buf); // cannot happen\n\t    }\n\t    if (mustfree)\n\t\tvim_free(cdpath);\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT) && (defined(MSWIN) || defined(VMS) || defined(EBCDIC) || defined(MAC) || defined(hpux))\n    // Set print encoding on platforms that don't default to latin1\n    set_string_default(\"penc\",\n# if defined(MSWIN)\n\t\t       (char_u *)\"cp1252\"\n# else\n#  ifdef VMS\n\t\t       (char_u *)\"dec-mcs\"\n#  else\n#   ifdef EBCDIC\n\t\t       (char_u *)\"ebcdic-uk\"\n#   else\n#    ifdef MAC\n\t\t       (char_u *)\"mac-roman\"\n#    else // HPUX\n\t\t       (char_u *)\"hp-roman8\"\n#    endif\n#   endif\n#  endif\n# endif\n\t\t       );\n#endif\n\n#ifdef FEAT_POSTSCRIPT\n    // 'printexpr' must be allocated to be able to evaluate it.\n    set_string_default(\"pexpr\",\n# if defined(MSWIN)\n\t    (char_u *)\"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \\\"' . &printdevice . '\\\"'))) . delete(v:fname_in)\"\n# else\n#  ifdef VMS\n\t    (char_u *)\"system('print/delete' . (&printdevice == '' ? '' : ' /queue=' . &printdevice) . ' ' . v:fname_in)\"\n\n#  else\n\t    (char_u *)\"system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error\"\n#  endif\n# endif\n\t    );\n#endif\n\n    /*\n     * Set all the options (except the terminal options) to their default\n     * value.  Also set the global value for local options.\n     */\n    set_options_default(0);\n\n#ifdef CLEAN_RUNTIMEPATH\n    if (clean_arg)\n    {\n\topt_idx = findoption((char_u *)\"runtimepath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_rtp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n\topt_idx = findoption((char_u *)\"packpath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_pp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    if (found_reverse_arg)\n\tset_option_value((char_u *)\"bg\", 0L, (char_u *)\"dark\", 0);\n#endif\n\n    curbuf->b_p_initialized = TRUE;\n    curbuf->b_p_ar = -1;\t// no local 'autoread' value\n    curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    check_buf_options(curbuf);\n    check_win_options(curwin);\n    check_options();\n\n    // Must be before option_expand(), because that one needs vim_isIDc()\n    didset_options();\n\n#ifdef FEAT_SPELL\n    // Use the current chartab for the generic chartab. This is not in\n    // didset_options() because it only depends on 'encoding'.\n    init_spell_chartab();\n#endif\n\n    /*\n     * Expand environment variables and things like \"~\" for the defaults.\n     * If option_expand() returns non-NULL the variable is expanded.  This can\n     * only happen for non-indirect options.\n     * Also set the default to the expanded value, so \":set\" does not list\n     * them.\n     * Don't set the P_ALLOCED flag, because we don't want to free the\n     * default.\n     */\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tif ((options[opt_idx].flags & P_GETTEXT)\n\t\t\t\t\t      && options[opt_idx].var != NULL)\n\t    p = (char_u *)_(*(char **)options[opt_idx].var);\n\telse\n\t    p = option_expand(opt_idx, NULL);\n\tif (p != NULL && (p = vim_strsave(p)) != NULL)\n\t{\n\t    *(char_u **)options[opt_idx].var = p;\n\t    // VIMEXP\n\t    // Defaults for all expanded options are currently the same for Vi\n\t    // and Vim.  When this changes, add some code here!  Also need to\n\t    // split P_DEF_ALLOCED in two.\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n\n    save_file_ff(curbuf);\t// Buffer is unchanged\n\n#if defined(FEAT_ARABIC)\n    // Detect use of mlterm.\n    // Mlterm is a terminal emulator akin to xterm that has some special\n    // abilities (bidi namely).\n    // NOTE: mlterm's author is being asked to 'set' a variable\n    //       instead of an environment variable due to inheritance.\n    if (mch_getenv((char_u *)\"MLTERM\") != NULL)\n\tset_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n#endif\n\n    didset_options2();\n\n# if defined(MSWIN) && defined(FEAT_GETTEXT)\n    /*\n     * If $LANG isn't set, try to get a good value for it.  This makes the\n     * right language be used automatically.  Don't do this for English.\n     */\n    if (mch_getenv((char_u *)\"LANG\") == NULL)\n    {\n\tchar\tbuf[20];\n\n\t// Could use LOCALE_SISO639LANGNAME, but it's not in Win95.\n\t// LOCALE_SABBREVLANGNAME gives us three letters, like \"enu\", we use\n\t// only the first two.\n\tn = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME,\n\t\t\t\t\t\t\t     (LPTSTR)buf, 20);\n\tif (n >= 2 && STRNICMP(buf, \"en\", 2) != 0)\n\t{\n\t    // There are a few exceptions (probably more)\n\t    if (STRNICMP(buf, \"cht\", 3) == 0 || STRNICMP(buf, \"zht\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_TW\");\n\t    else if (STRNICMP(buf, \"chs\", 3) == 0\n\t\t\t\t\t      || STRNICMP(buf, \"zhc\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_CN\");\n\t    else if (STRNICMP(buf, \"jp\", 2) == 0)\n\t\tSTRCPY(buf, \"ja\");\n\t    else\n\t\tbuf[2] = NUL;\t\t// truncate to two-letter code\n\t    vim_setenv((char_u *)\"LANG\", (char_u *)buf);\n\t}\n    }\n# else\n#  ifdef MACOS_CONVERT\n    // Moved to os_mac_conv.c to avoid dependency problems.\n    mac_lang_init();\n#  endif\n# endif\n\n# ifdef MSWIN\n    // MS-Windows has builtin support for conversion to and from Unicode, using\n    // \"utf-8\" for 'encoding' should work best for most users.\n    p = vim_strsave((char_u *)ENC_DFLT);\n# else\n    // enc_locale() will try to find the encoding of the current locale.\n    // This works best for properly configured systems, old and new.\n    p = enc_locale();\n# endif\n    if (p != NULL)\n    {\n\tchar_u *save_enc;\n\n\t// Try setting 'encoding' and check if the value is valid.\n\t// If not, go back to the default encoding.\n\tsave_enc = p_enc;\n\tp_enc = p;\n\tif (STRCMP(p_enc, \"gb18030\") == 0)\n\t{\n\t    // We don't support \"gb18030\", but \"cp936\" is a good substitute\n\t    // for practical purposes, thus use that.  It's not an alias to\n\t    // still support conversion between gb18030 and utf-8.\n\t    p_enc = vim_strsave((char_u *)\"cp936\");\n\t    vim_free(p);\n\t}\n\tif (mb_init() == NULL)\n\t{\n\t    opt_idx = findoption((char_u *)\"encoding\");\n\t    if (opt_idx >= 0)\n\t    {\n\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_enc;\n\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t    }\n\n#if defined(MSWIN) || defined(MACOS_X) || defined(VMS)\n\t    if (STRCMP(p_enc, \"latin1\") == 0 || enc_utf8)\n\t    {\n\t\t// Adjust the default for 'isprint' and 'iskeyword' to match\n\t\t// latin1.  Also set the defaults for when 'nocompatible' is\n\t\t// set.\n\t\tset_string_option_direct((char_u *)\"isp\", -1,\n\t\t\t\t\t      ISP_LATIN1, OPT_FREE, SID_NONE);\n\t\tset_string_option_direct((char_u *)\"isk\", -1,\n\t\t\t\t\t      ISK_LATIN1, OPT_FREE, SID_NONE);\n\t\topt_idx = findoption((char_u *)\"isp\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISP_LATIN1;\n\t\topt_idx = findoption((char_u *)\"isk\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISK_LATIN1;\n\t\t(void)init_chartab();\n\t    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    // Win32 console: When GetACP() returns a different value from\n\t    // GetConsoleCP() set 'termencoding'.\n\t    if (\n# ifdef VIMDLL\n\t       (!gui.in_use && !gui.starting) &&\n# endif\n\t        GetACP() != GetConsoleCP())\n\t    {\n\t\tchar\tbuf[50];\n\n\t\t// Win32 console: In ConPTY, GetConsoleCP() returns zero.\n\t\t// Use an alternative value.\n\t\tif (GetConsoleCP() == 0)\n\t\t    sprintf(buf, \"cp%ld\", (long)GetACP());\n\t\telse\n\t\t    sprintf(buf, \"cp%ld\", (long)GetConsoleCP());\n\t\tp_tenc = vim_strsave((char_u *)buf);\n\t\tif (p_tenc != NULL)\n\t\t{\n\t\t    opt_idx = findoption((char_u *)\"termencoding\");\n\t\t    if (opt_idx >= 0)\n\t\t    {\n\t\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_tenc;\n\t\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t    }\n\t\t    convert_setup(&input_conv, p_tenc, p_enc);\n\t\t    convert_setup(&output_conv, p_enc, p_tenc);\n\t\t}\n\t\telse\n\t\t    p_tenc = empty_option;\n\t    }\n#endif\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    init_homedir();\n#endif\n\t}\n\telse\n\t{\n\t    vim_free(p_enc);\n\t    p_enc = save_enc;\n\t}\n    }\n\n#ifdef FEAT_MULTI_LANG\n    // Set the default for 'helplang'.\n    set_helplang_default(get_mess_lang());\n#endif\n}\n\nstatic char_u *fencs_utf8_default = (char_u *)\"ucs-bom,utf-8,default,latin1\";\n\n/*\n * Set the \"fileencodings\" option to the default value for when 'encoding' is\n * utf-8.\n */\n    void\nset_fencs_unicode()\n{\n    set_string_option_direct((char_u *)\"fencs\", -1, fencs_utf8_default,\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\n    static void\nset_option_default(\n    int\t\topt_idx,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tcompatible)\t// use Vi default value\n{\n    char_u\t*varp;\t\t// pointer to variable for current option\n    int\t\tdvi;\t\t// index in def_val[]\n    long_u\tflags;\n    long_u\t*flagsp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n    varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n    flags = options[opt_idx].flags;\n    if (varp != NULL)\t    // skip hidden option, nothing to do for it\n    {\n\tdvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n\tif (flags & P_STRING)\n\t{\n\t    // 'fencs' default value depends on 'encoding'\n\t    if (options[opt_idx].var == (char_u *)&p_fencs && enc_utf8)\n\t\tset_fencs_unicode();\n\t    // Use set_string_option_direct() for local options to handle\n\t    // freeing and allocating the value.\n\t    else if (options[opt_idx].indir != PV_NONE)\n\t\tset_string_option_direct(NULL, opt_idx,\n\t\t\t\t options[opt_idx].def_val[dvi], opt_flags, 0);\n\t    else\n\t    {\n\t\tif ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n\t\t    free_string_option(*(char_u **)(varp));\n\t\t*(char_u **)varp = options[opt_idx].def_val[dvi];\n\t\toptions[opt_idx].flags &= ~P_ALLOCED;\n\t    }\n\t}\n\telse if (flags & P_NUM)\n\t{\n\t    if (options[opt_idx].indir == PV_SCROLL)\n\t\twin_comp_scroll(curwin);\n\t    else\n\t    {\n\t\tlong def_val = (long)(long_i)options[opt_idx].def_val[dvi];\n\n\t\tif ((long *)varp == &curwin->w_p_so\n\t\t\t|| (long *)varp == &curwin->w_p_siso)\n\t\t    // 'scrolloff' and 'sidescrolloff' local values have a\n\t\t    // different default value than the global default.\n\t\t    *(long *)varp = -1;\n\t\telse\n\t\t    *(long *)varp = def_val;\n\t\t// May also set global value for local option.\n\t\tif (both)\n\t\t    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\tdef_val;\n\t    }\n\t}\n\telse\t// P_BOOL\n\t{\n\t    // the cast to long is required for Manx C, long_i is needed for\n\t    // MSVC\n\t    *(int *)varp = (int)(long)(long_i)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n\t    // 'modeline' defaults to off for root\n\t    if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n\t\t*(int *)varp = FALSE;\n#endif\n\t    // May also set global value for local option.\n\t    if (both)\n\t\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\t*(int *)varp;\n\t}\n\n\t// The default value is not insecure.\n\tflagsp = insecure_flag(opt_idx, opt_flags);\n\t*flagsp = *flagsp & ~P_INSECURE;\n    }\n\n#ifdef FEAT_EVAL\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n * When \"opt_flags\" is non-zero skip 'encoding'.\n */\n    static void\nset_options_default(\n    int\t\topt_flags)\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\ti;\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (!(options[i].flags & P_NODEFAULT)\n\t\t&& (opt_flags == 0\n\t\t    || (options[i].var != (char_u *)&p_enc\n# if defined(FEAT_CRYPT)\n\t\t\t&& options[i].var != (char_u *)&p_cm\n\t\t\t&& options[i].var != (char_u *)&p_key\n# endif\n\t\t\t)))\n\t    set_option_default(i, opt_flags, p_cp);\n\n    // The 'scroll' option must be computed for all windows.\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\twin_comp_scroll(wp);\n#ifdef FEAT_CINDENT\n    parse_cino(curbuf);\n#endif\n}\n\n/*\n * Set the Vi-default value of a string option.\n * Used for 'sh', 'backupskip' and 'term'.\n * When \"escape\" is TRUE escape spaces with a backslash.\n */\n    static void\nset_string_default_esc(char *name, char_u *val, int escape)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n\n    if (escape && vim_strchr(val, ' ') != NULL)\n\tp = vim_strsave_escaped(val, (char_u *)\" \");\n    else\n\tp = vim_strsave(val);\n    if (p != NULL)\t\t// we don't want a NULL\n    {\n\topt_idx = findoption((char_u *)name);\n\tif (opt_idx >= 0)\n\t{\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n}\n\n    void\nset_string_default(char *name, char_u *val)\n{\n    set_string_default_esc(name, val, FALSE);\n}\n\n/*\n * For an option value that contains comma separated items, find \"newval\" in\n * \"origval\".  Return NULL if not found.\n */\n    static char_u *\nfind_dup_item(char_u *origval, char_u *newval, long_u flags)\n{\n    int\t    bs = 0;\n    size_t  newlen;\n    char_u  *s;\n\n    if (origval == NULL)\n\treturn NULL;\n\n    newlen = STRLEN(newval);\n    for (s = origval; *s != NUL; ++s)\n    {\n\tif ((!(flags & P_COMMA)\n\t\t    || s == origval\n\t\t    || (s[-1] == ',' && !(bs & 1)))\n\t\t&& STRNCMP(s, newval, newlen) == 0\n\t\t&& (!(flags & P_COMMA)\n\t\t    || s[newlen] == ','\n\t\t    || s[newlen] == NUL))\n\t    return s;\n\t// Count backslashes.  Only a comma with an even number of backslashes\n\t// or a single backslash preceded by a comma before it is recognized as\n\t// a separator.\n\tif ((s > origval + 1\n\t\t    && s[-1] == '\\\\'\n\t\t    && s[-2] != ',')\n\t\t|| (s == origval + 1\n\t\t    && s[-1] == '\\\\'))\n\t    ++bs;\n\telse\n\t    bs = 0;\n    }\n    return NULL;\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\n    void\nset_number_default(char *name, long val)\n{\n    int\t\topt_idx;\n\n    opt_idx = findoption((char_u *)name);\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n}\n\n/*\n * Set all window-local and buffer-local options to the Vim default.\n * local-global options will use the global value.\n * When \"do_buffer\" is FALSE don't set buffer-local options.\n */\n    void\nset_local_options_default(win_T *wp, int do_buffer)\n{\n    win_T\t*save_curwin = curwin;\n    int\t\ti;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    block_autocmds();\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tstruct vimoption    *p = &(options[i]);\n\tchar_u\t\t    *varp = get_varp_scope(p, OPT_LOCAL);\n\n\tif (p->indir != PV_NONE\n\t\t&& (do_buffer || (p->indir & PV_BUF) == 0)\n\t\t&& !(options[i].flags & P_NODEFAULT)\n\t\t&& !optval_default(p, varp, FALSE))\n\t    set_option_default(i, OPT_FREE|OPT_LOCAL, FALSE);\n    }\n\n    unblock_autocmds();\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all options.\n */\n    void\nfree_all_options(void)\n{\n    int\t\ti;\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tif (options[i].indir == PV_NONE)\n\t{\n\t    // global option: free value and default value.\n\t    if ((options[i].flags & P_ALLOCED) && options[i].var != NULL)\n\t\tfree_string_option(*(char_u **)options[i].var);\n\t    if (options[i].flags & P_DEF_ALLOCED)\n\t\tfree_string_option(options[i].def_val[VI_DEFAULT]);\n\t}\n\telse if (options[i].var != VAR_WIN\n\t\t&& (options[i].flags & P_STRING))\n\t    // buffer-local option: free global value\n\t    clear_string_option((char_u **)options[i].var);\n    }\n}\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\n    void\nset_init_2(void)\n{\n    int\t\tidx;\n\n    /*\n     * 'scroll' defaults to half the window height. The stored default is zero,\n     * which results in the actual value computed from the window height.\n     */\n    idx = findoption((char_u *)\"scroll\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n\tset_option_default(idx, OPT_LOCAL, p_cp);\n    comp_col();\n\n    /*\n     * 'window' is only for backwards compatibility with Vi.\n     * Default is Rows - 1.\n     */\n    if (!option_was_set((char_u *)\"window\"))\n\tp_window = Rows - 1;\n    set_number_default(\"window\", Rows - 1);\n\n    // For DOS console the default is always black.\n#if !((defined(MSWIN)) && !defined(FEAT_GUI))\n    /*\n     * If 'background' wasn't set by the user, try guessing the value,\n     * depending on the terminal name.  Only need to check for terminals\n     * with a dark background, that can handle color.\n     */\n    idx = findoption((char_u *)\"bg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET)\n\t\t\t\t\t\t && *term_bg_default() == 'd')\n    {\n\tset_string_option_direct(NULL, idx, (char_u *)\"dark\", OPT_FREE, 0);\n\t// don't mark it as set, when starting the GUI it may be\n\t// changed again\n\toptions[idx].flags &= ~P_WAS_SET;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    parse_shape_opt(SHAPE_CURSOR); // set cursor shapes from 'guicursor'\n#endif\n#ifdef FEAT_MOUSESHAPE\n    parse_shape_opt(SHAPE_MOUSE);  // set mouse shapes from 'mouseshape'\n#endif\n#ifdef FEAT_PRINTER\n    (void)parse_printoptions();\t    // parse 'printoptions' default value\n#endif\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\n    void\nset_init_3(void)\n{\n#if defined(UNIX) || defined(MSWIN)\n/*\n * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n * This is done after other initializations, where 'shell' might have been\n * set, but only if they have not been set before.\n */\n    char_u  *p;\n    int\t    idx_srr;\n    int\t    do_srr;\n# ifdef FEAT_QUICKFIX\n    int\t    idx_sp;\n    int\t    do_sp;\n# endif\n\n    idx_srr = findoption((char_u *)\"srr\");\n    if (idx_srr < 0)\n\tdo_srr = FALSE;\n    else\n\tdo_srr = !(options[idx_srr].flags & P_WAS_SET);\n# ifdef FEAT_QUICKFIX\n    idx_sp = findoption((char_u *)\"sp\");\n    if (idx_sp < 0)\n\tdo_sp = FALSE;\n    else\n\tdo_sp = !(options[idx_sp].flags & P_WAS_SET);\n# endif\n    p = get_isolated_shell_name();\n    if (p != NULL)\n    {\n\t/*\n\t * Default for p_sp is \"| tee\", for p_srr is \">\".\n\t * For known shells it is changed here to include stderr.\n\t */\n\tif (\t   fnamecmp(p, \"csh\") == 0\n\t\t|| fnamecmp(p, \"tcsh\") == 0\n# if defined(MSWIN)\t// also check with .exe extension\n\t\t|| fnamecmp(p, \"csh.exe\") == 0\n\t\t|| fnamecmp(p, \"tcsh.exe\") == 0\n# endif\n\t   )\n\t{\n# if defined(FEAT_QUICKFIX)\n\t    if (do_sp)\n\t    {\n#  ifdef MSWIN\n\t\tp_sp = (char_u *)\">&\";\n#  else\n\t\tp_sp = (char_u *)\"|& tee\";\n#  endif\n\t\toptions[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t    }\n# endif\n\t    if (do_srr)\n\t    {\n\t\tp_srr = (char_u *)\">&\";\n\t\toptions[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t    }\n\t}\n# ifdef MSWIN\n\t// Windows PowerShell output is UTF-16 with BOM so re-encode to the\n\t// current codepage.\n\telse if (   fnamecmp(p, \"powershell\") == 0\n\t\t    || fnamecmp(p, \"powershell.exe\") == 0\n\t\t)\n\t{\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n\t\t    p_sp = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t}\n#endif\n\telse\n\t    // Always use POSIX shell style redirection if we reach this\n\t    if (       fnamecmp(p, \"sh\") == 0\n\t\t    || fnamecmp(p, \"ksh\") == 0\n\t\t    || fnamecmp(p, \"mksh\") == 0\n\t\t    || fnamecmp(p, \"pdksh\") == 0\n\t\t    || fnamecmp(p, \"zsh\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta\") == 0\n\t\t    || fnamecmp(p, \"bash\") == 0\n\t\t    || fnamecmp(p, \"fish\") == 0\n\t\t    || fnamecmp(p, \"ash\") == 0\n\t\t    || fnamecmp(p, \"dash\") == 0\n\t\t    || fnamecmp(p, \"pwsh\") == 0\n# ifdef MSWIN\n\t\t    || fnamecmp(p, \"cmd\") == 0\n\t\t    || fnamecmp(p, \"sh.exe\") == 0\n\t\t    || fnamecmp(p, \"ksh.exe\") == 0\n\t\t    || fnamecmp(p, \"mksh.exe\") == 0\n\t\t    || fnamecmp(p, \"pdksh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta.exe\") == 0\n\t\t    || fnamecmp(p, \"bash.exe\") == 0\n\t\t    || fnamecmp(p, \"cmd.exe\") == 0\n\t\t    || fnamecmp(p, \"dash.exe\") == 0\n\t\t    || fnamecmp(p, \"pwsh.exe\") == 0\n# endif\n\t\t    )\n\t    {\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n#  ifdef MSWIN\n\t\t    p_sp = (char_u *)\">%s 2>&1\";\n#  else\n\t\t    if (fnamecmp(p, \"pwsh\") == 0)\n\t\t\tp_sp = (char_u *)\">%s 2>&1\";\n\t\t    else\n\t\t\tp_sp = (char_u *)\"2>&1| tee\";\n#  endif\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\">%s 2>&1\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t    }\n\tvim_free(p);\n    }\n#endif\n\n#if defined(MSWIN)\n    /*\n     * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the\n     * 'shell' option.\n     * This is done after other initializations, where 'shell' might have been\n     * set, but only if they have not been set before.\n     * Default values depend on shell (cmd.exe is default shell):\n     *\n     *\t\t\t    p_shcf\tp_sxq\n     * cmd.exe          -   \"/c\"\t\"(\"\n     * powershell.exe   -   \"-Command\"\t\"\\\"\"\n     * pwsh.exe\t\t-   \"-c\"\t\"\\\"\"\n     * \"sh\" like shells -   \"-c\"\t\"\\\"\"\n     *\n     * For Win32 p_sxq is set instead of p_shq to include shell redirection.\n     */\n    if (strstr((char *)gettail(p_sh), \"powershell\") != NULL)\n    {\n\tint\tidx_opt;\n\n\tidx_opt = findoption((char_u *)\"shcf\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u*)\"-Command\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\tidx_opt = findoption((char_u *)\"sxq\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u*)\"\\\"\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"sh\") != NULL)\n    {\n\tint\tidx3;\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"-c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\t// Somehow Win32 requires the quotes around the redirection too\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"\\\"\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"cmd.exe\") != NULL)\n    {\n\tint\tidx3;\n\n\t/*\n\t * cmd.exe on Windows will strip the first and last double quote given\n\t * on the command line, e.g. most of the time things like:\n\t *   cmd /c \"my path/to/echo\" \"my args to echo\"\n\t * become:\n\t *   my path/to/echo\" \"my args to echo\n\t * when executed.\n\t *\n\t * To avoid this, set shellxquote to surround the command in\n\t * parenthesis.  This appears to make most commands work, without\n\t * breaking commands that worked previously, such as\n\t * '\"path with spaces/cmd\" \"a&b\"'.\n\t */\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"(\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"/c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n    }\n#endif\n\n    if (BUFEMPTY())\n    {\n\tint idx_ffs = findoption((char_u *)\"ffs\");\n\n\t// Apply the first entry of 'fileformats' to the initial buffer.\n\tif (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET))\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n#ifdef FEAT_TITLE\n    set_title_defaults();\n#endif\n}\n\n#if defined(FEAT_MULTI_LANG) || defined(PROTO)\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\n    void\nset_helplang_default(char_u *lang)\n{\n    int\t\tidx;\n\n    if (lang == NULL || STRLEN(lang) < 2)\t// safety check\n\treturn;\n    idx = findoption((char_u *)\"hlg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    {\n\tif (options[idx].flags & P_ALLOCED)\n\t    free_string_option(p_hlg);\n\tp_hlg = vim_strsave(lang);\n\tif (p_hlg == NULL)\n\t    p_hlg = empty_option;\n\telse\n\t{\n\t    // zh_CN becomes \"cn\", zh_TW becomes \"tw\"\n\t    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)\n\t    {\n\t\tp_hlg[0] = TOLOWER_ASC(p_hlg[3]);\n\t\tp_hlg[1] = TOLOWER_ASC(p_hlg[4]);\n\t    }\n\t    // any C like setting, such as C.UTF-8, becomes \"en\"\n\t    else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')\n\t    {\n\t\tp_hlg[0] = 'e';\n\t\tp_hlg[1] = 'n';\n\t    }\n\t    p_hlg[2] = NUL;\n\t}\n\toptions[idx].flags |= P_ALLOCED;\n    }\n}\n#endif\n\n#ifdef FEAT_TITLE\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\n    void\nset_title_defaults(void)\n{\n    int\t    idx1;\n    long    val;\n\n    /*\n     * If GUI is (going to be) used, we can always set the window title and\n     * icon name.  Saves a bit of time, because the X11 display server does\n     * not need to be contacted.\n     */\n    idx1 = findoption((char_u *)\"title\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_title();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_title = val;\n    }\n    idx1 = findoption((char_u *)\"icon\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_icon();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_icon = val;\n    }\n}\n#endif\n\n    void\nex_set(exarg_T *eap)\n{\n    int\t\tflags = 0;\n\n    if (eap->cmdidx == CMD_setlocal)\n\tflags = OPT_LOCAL;\n    else if (eap->cmdidx == CMD_setglobal)\n\tflags = OPT_GLOBAL;\n#if defined(FEAT_EVAL) && defined(FEAT_BROWSE)\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && flags == 0)\n\tex_options(eap);\n    else\n#endif\n    {\n\tif (eap->forceit)\n\t    flags |= OPT_ONECOLUMN;\n\t(void)do_set(eap->arg, flags);\n    }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL   for \":setglobal\"\n * OPT_LOCAL    for \":setlocal\" and a modeline\n * OPT_MODELINE for a modeline\n * OPT_WINONLY  to only set window-local options\n * OPT_NOWIN\tto skip setting window-local options\n *\n * returns FAIL if an error is detected, OK otherwise\n */\n    int\ndo_set(\n    char_u\t*arg_start,\t// option string (may be written to!)\n    int\t\topt_flags)\n{\n    char_u\t*arg = arg_start;\n    int\t\topt_idx;\n    char\t*errmsg;\n    char\terrbuf[80];\n    char_u\t*startarg;\n    int\t\tprefix;\t// 1: nothing, 0: \"no\", 2: \"inv\" in front of name\n    int\t\tnextchar;\t    // next non-white char after option name\n    int\t\tafterchar;\t    // character just after option name\n    int\t\tlen;\n    int\t\ti;\n    varnumber_T\tvalue;\n    int\t\tkey;\n    long_u\tflags;\t\t    // flags for current option\n    char_u\t*varp = NULL;\t    // pointer to variable for current option\n    int\t\tdid_show = FALSE;   // already showed one value\n    int\t\tadding;\t\t    // \"opt+=arg\"\n    int\t\tprepending;\t    // \"opt^=arg\"\n    int\t\tremoving;\t    // \"opt-=arg\"\n    int\t\tcp_val = 0;\n    char_u\tkey_name[2];\n\n    if (*arg == NUL)\n    {\n\tshowoptions(0, opt_flags);\n\tdid_show = TRUE;\n\tgoto theend;\n    }\n\n    while (*arg != NUL)\t\t// loop to process all options\n    {\n\terrmsg = NULL;\n\tstartarg = arg;\t\t// remember for error message\n\n\tif (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n\t\t\t\t\t\t&& !(opt_flags & OPT_MODELINE))\n\t{\n\t    /*\n\t     * \":set all\"  show all options.\n\t     * \":set all&\" set all options to their default value.\n\t     */\n\t    arg += 3;\n\t    if (*arg == '&')\n\t    {\n\t\t++arg;\n\t\t// Only for :set command set global value of local options.\n\t\tset_options_default(OPT_FREE | opt_flags);\n\t\tdidset_options();\n\t\tdidset_options2();\n\t\tredraw_all_later(CLEAR);\n\t    }\n\t    else\n\t    {\n\t\tshowoptions(1, opt_flags);\n\t\tdid_show = TRUE;\n\t    }\n\t}\n\telse if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))\n\t{\n\t    showoptions(2, opt_flags);\n\t    show_termcodes();\n\t    did_show = TRUE;\n\t    arg += 7;\n\t}\n\telse\n\t{\n\t    prefix = 1;\n\t    if (STRNCMP(arg, \"no\", 2) == 0 && STRNCMP(arg, \"novice\", 6) != 0)\n\t    {\n\t\tprefix = 0;\n\t\targ += 2;\n\t    }\n\t    else if (STRNCMP(arg, \"inv\", 3) == 0)\n\t    {\n\t\tprefix = 2;\n\t\targ += 3;\n\t    }\n\n\t    // find end of name\n\t    key = 0;\n\t    if (*arg == '<')\n\t    {\n\t\topt_idx = -1;\n\t\t// look out for <t_>;>\n\t\tif (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n\t\t    len = 5;\n\t\telse\n\t\t{\n\t\t    len = 1;\n\t\t    while (arg[len] != NUL && arg[len] != '>')\n\t\t\t++len;\n\t\t}\n\t\tif (arg[len] != '>')\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    goto skip;\n\t\t}\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\tif (arg[1] == 't' && arg[2] == '_') // could be term code\n\t\t    opt_idx = findoption(arg + 1);\n\t\targ[len++] = '>';\t\t    // restore '>'\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg + 1, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\t/*\n\t\t * The two characters after \"t_\" may not be alphanumeric.\n\t\t */\n\t\tif (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\t\t    len = 4;\n\t\telse\n\t\t    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')\n\t\t\t++len;\n\t\tnextchar = arg[len];\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\topt_idx = findoption(arg);\n\t\targ[len] = nextchar;\t\t    // restore nextchar\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg, FALSE);\n\t    }\n\n\t    // remember character after option name\n\t    afterchar = arg[len];\n\n\t    if (in_vim9script())\n\t    {\n\t\tchar_u *p = skipwhite(arg + len);\n\n\t\t// disallow white space before =val, +=val, -=val, ^=val\n\t\tif (p > arg + len && (p[0] == '='\n\t\t\t|| (vim_strchr((char_u *)\"+-^\", p[0]) != NULL\n\t\t\t\t\t\t\t      && p[1] == '=')))\n\t\t{\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\t    arg = p;\n\t\t    startarg = p;\n\t\t    goto skip;\n\t\t}\n\t    }\n\t    else\n\t\t// skip white space, allow \":set ai  ?\", \":set hlsearch  !\"\n\t\twhile (VIM_ISWHITE(arg[len]))\n\t\t    ++len;\n\n\t    adding = FALSE;\n\t    prepending = FALSE;\n\t    removing = FALSE;\n\t    if (arg[len] != NUL && arg[len + 1] == '=')\n\t    {\n\t\tif (arg[len] == '+')\n\t\t{\n\t\t    adding = TRUE;\t\t// \"+=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '^')\n\t\t{\n\t\t    prepending = TRUE;\t\t// \"^=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '-')\n\t\t{\n\t\t    removing = TRUE;\t\t// \"-=\"\n\t\t    ++len;\n\t\t}\n\t    }\n\t    nextchar = arg[len];\n\n\t    if (opt_idx == -1 && key == 0)\t// found a mismatch: skip\n\t    {\n\t\tif (in_vim9script() && arg > arg_start\n\t\t\t\t  && vim_strchr((char_u *)\"!&<\", *arg) != NULL)\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\telse\n\t\t    errmsg = N_(\"E518: Unknown option\");\n\t\tgoto skip;\n\t    }\n\n\t    if (opt_idx >= 0)\n\t    {\n\t\tif (options[opt_idx].var == NULL)   // hidden option: skip\n\t\t{\n\t\t    // Only give an error message when requesting the value of\n\t\t    // a hidden option, ignore setting it.\n\t\t    if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n\t\t\t    && (!(options[opt_idx].flags & P_BOOL)\n\t\t\t\t|| nextchar == '?'))\n\t\t\terrmsg = N_(\"E519: Option not supported\");\n\t\t    goto skip;\n\t\t}\n\n\t\tflags = options[opt_idx].flags;\n\t\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    }\n\t    else\n\t    {\n\t\tflags = P_STRING;\n\t\tif (key < 0)\n\t\t{\n\t\t    key_name[0] = KEY2TERMCAP0(key);\n\t\t    key_name[1] = KEY2TERMCAP1(key);\n\t\t}\n\t\telse\n\t\t{\n\t\t    key_name[0] = KS_KEY;\n\t\t    key_name[1] = (key & 0xff);\n\t\t}\n\t    }\n\n\t    // Skip all options that are not window-local (used when showing\n\t    // an already loaded buffer in a window).\n\t    if ((opt_flags & OPT_WINONLY)\n\t\t\t  && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n\t\tgoto skip;\n\n\t    // Skip all options that are window-local (used for :vimgrep).\n\t    if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n\t\t\t\t\t   && options[opt_idx].var == VAR_WIN)\n\t\tgoto skip;\n\n\t    // Disallow changing some options from modelines.\n\t    if (opt_flags & OPT_MODELINE)\n\t    {\n\t\tif (flags & (P_SECURE | P_NO_ML))\n\t\t{\n\t\t    errmsg = N_(\"E520: Not allowed in a modeline\");\n\t\t    goto skip;\n\t\t}\n\t\tif ((flags & P_MLE) && !p_mle)\n\t\t{\n\t\t    errmsg = N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\");\n\t\t    goto skip;\n\t\t}\n#ifdef FEAT_DIFF\n\t\t// In diff mode some options are overruled.  This avoids that\n\t\t// 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n\t\t// \"wrap\" gets set.\n\t\tif (curwin->w_p_diff\n\t\t\t&& opt_idx >= 0  // shut up coverity warning\n\t\t\t&& (\n#ifdef FEAT_FOLDING\n\t\t\t    options[opt_idx].indir == PV_FDM ||\n#endif\n\t\t\t    options[opt_idx].indir == PV_WRAP))\n\t\t    goto skip;\n#endif\n\t    }\n\n#ifdef HAVE_SANDBOX\n\t    // Disallow changing some options in the sandbox\n\t    if (sandbox != 0 && (flags & P_SECURE))\n\t    {\n\t\terrmsg = e_not_allowed_in_sandbox;\n\t\tgoto skip;\n\t    }\n#endif\n\n\t    if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL)\n\t    {\n\t\targ += len;\n\t\tcp_val = p_cp;\n\t\tif (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')\n\t\t{\n\t\t    if (arg[3] == 'm')\t// \"opt&vim\": set to Vim default\n\t\t    {\n\t\t\tcp_val = FALSE;\n\t\t\targ += 3;\n\t\t    }\n\t\t    else\t\t// \"opt&vi\": set to Vi default\n\t\t    {\n\t\t\tcp_val = TRUE;\n\t\t\targ += 2;\n\t\t    }\n\t\t}\n\t\tif (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n\t\t\t&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))\n\t\t{\n\t\t    errmsg = e_trailing;\n\t\t    goto skip;\n\t\t}\n\t    }\n\n\t    /*\n\t     * allow '=' and ':' for historical reasons (MSDOS command.com\n\t     * allows only one '=' character per \"set\" command line. grrr. (jw)\n\t     */\n\t    if (nextchar == '?'\n\t\t    || (prefix == 1\n\t\t\t&& vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t&& !(flags & P_BOOL)))\n\t    {\n\t\t/*\n\t\t * print value\n\t\t */\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    did_show = TRUE;\t    // remember that we did a line\n\t\t}\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    showoneopt(&options[opt_idx], opt_flags);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0)\n\t\t    {\n\t\t\t// Mention where the option was last set.\n\t\t\tif (varp == options[opt_idx].var)\n\t\t\t    last_set_msg(options[opt_idx].script_ctx);\n\t\t\telse if ((int)options[opt_idx].indir & PV_WIN)\n\t\t\t    last_set_msg(curwin->w_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t\telse if ((int)options[opt_idx].indir & PV_BUF)\n\t\t\t    last_set_msg(curbuf->b_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t    *p;\n\n\t\t    p = find_termcode(key_name);\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\terrmsg = N_(\"E846: Key code not set\");\n\t\t\tgoto skip;\n\t\t    }\n\t\t    else\n\t\t\t(void)show_one_termcode(key_name, p, TRUE);\n\t\t}\n\t\tif (nextchar != '?'\n\t\t\t&& nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t    errmsg = e_trailing;\n\t    }\n\t    else\n\t    {\n\t\tint value_is_replaced = !prepending && !adding && !removing;\n\t\tint value_checked = FALSE;\n\n\t\tif (flags & P_BOOL)\t\t    // boolean\n\t\t{\n\t\t    if (nextchar == '=' || nextchar == ':')\n\t\t    {\n\t\t\terrmsg = e_invarg;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    /*\n\t\t     * \":set opt!\": invert\n\t\t     * \":set opt&\": reset to default value\n\t\t     * \":set opt<\": reset to global value\n\t\t     */\n\t\t    if (nextchar == '!')\n\t\t\tvalue = *(int *)(varp) ^ 1;\n\t\t    else if (nextchar == '&')\n\t\t\tvalue = (int)(long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t    else if (nextchar == '<')\n\t\t    {\n\t\t\t// For 'autoread' -1 means to use global value.\n\t\t\tif ((int *)varp == &curbuf->b_p_ar\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t    value = -1;\n\t\t\telse\n\t\t\t    value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t  OPT_GLOBAL);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * \":set invopt\": invert\n\t\t\t * \":set opt\" or \":set noopt\": set or reset\n\t\t\t */\n\t\t\tif (nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t\t{\n\t\t\t    errmsg = e_trailing;\n\t\t\t    goto skip;\n\t\t\t}\n\t\t\tif (prefix == 2)\t// inv\n\t\t\t    value = *(int *)(varp) ^ 1;\n\t\t\telse\n\t\t\t    value = prefix;\n\t\t    }\n\n\t\t    errmsg = set_bool_option(opt_idx, varp, (int)value,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t\t}\n\t\telse\t\t\t\t    // numeric or string\n\t\t{\n\t\t    if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t\t\t\t\t       || prefix != 1)\n\t\t    {\n\t\t\terrmsg = e_invarg;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    if (flags & P_NUM)\t\t    // numeric\n\t\t    {\n\t\t\t/*\n\t\t\t * Different ways to set a number option:\n\t\t\t * &\t    set to default value\n\t\t\t * <\t    set to global value\n\t\t\t * <xx>\t    accept special key codes for 'wildchar'\n\t\t\t * c\t    accept any non-digit for 'wildchar'\n\t\t\t * [-]0-9   set number\n\t\t\t * other    error\n\t\t\t */\n\t\t\t++arg;\n\t\t\tif (nextchar == '&')\n\t\t\t    value = (long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\telse if (nextchar == '<')\n\t\t\t{\n\t\t\t    // For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n\t\t\t    // use the global value.\n\t\t\t    if ((long *)varp == &curbuf->b_p_ul\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t\tvalue = NO_LOCAL_UNDOLEVEL;\n\t\t\t    else\n\t\t\t\tvalue = *(long *)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL);\n\t\t\t}\n\t\t\telse if (((long *)varp == &p_wc\n\t\t\t\t    || (long *)varp == &p_wcm)\n\t\t\t\t&& (*arg == '<'\n\t\t\t\t    || *arg == '^'\n\t\t\t\t    || (*arg != NUL\n\t\t\t\t\t&& (!arg[1] || VIM_ISWHITE(arg[1]))\n\t\t\t\t\t&& !VIM_ISDIGIT(*arg))))\n\t\t\t{\n\t\t\t    value = string_to_key(arg, FALSE);\n\t\t\t    if (value == 0 && (long *)varp != &p_wcm)\n\t\t\t    {\n\t\t\t\terrmsg = e_invarg;\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (*arg == '-' || VIM_ISDIGIT(*arg))\n\t\t\t{\n\t\t\t    // Allow negative (for 'undolevels'), octal and\n\t\t\t    // hex numbers.\n\t\t\t    vim_str2nr(arg, NULL, &i, STR2NR_ALL,\n\t\t\t\t\t\t     &value, NULL, 0, TRUE);\n\t\t\t    if (i == 0 || (arg[i] != NUL\n\t\t\t\t\t\t      && !VIM_ISWHITE(arg[i])))\n\t\t\t    {\n\t\t\t\terrmsg = N_(\"E521: Number required after =\");\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    errmsg = N_(\"E521: Number required after =\");\n\t\t\t    goto skip;\n\t\t\t}\n\n\t\t\tif (adding)\n\t\t\t    value = *(long *)varp + value;\n\t\t\tif (prepending)\n\t\t\t    value = *(long *)varp * value;\n\t\t\tif (removing)\n\t\t\t    value = *(long *)varp - value;\n\t\t\terrmsg = set_num_option(opt_idx, varp, value,\n\t\t\t\t\t   errbuf, sizeof(errbuf), opt_flags);\n\t\t    }\n\t\t    else if (opt_idx >= 0)\t\t    // string\n\t\t    {\n\t\t\tchar_u\t  *save_arg = NULL;\n\t\t\tchar_u\t  *s = NULL;\n\t\t\tchar_u\t  *oldval = NULL; // previous value if *varp\n\t\t\tchar_u\t  *newval;\n\t\t\tchar_u\t  *origval = NULL;\n\t\t\tchar_u\t  *origval_l = NULL;\n\t\t\tchar_u\t  *origval_g = NULL;\n#if defined(FEAT_EVAL)\n\t\t\tchar_u\t  *saved_origval = NULL;\n\t\t\tchar_u\t  *saved_origval_l = NULL;\n\t\t\tchar_u\t  *saved_origval_g = NULL;\n\t\t\tchar_u\t  *saved_newval = NULL;\n#endif\n\t\t\tunsigned  newlen;\n\t\t\tint\t  comma;\n\t\t\tint\t  new_value_alloced;\t// new string option\n\t\t\t\t\t\t\t// was allocated\n\n\t\t\t// When using \":set opt=val\" for a global option\n\t\t\t// with a local value the local value will be\n\t\t\t// reset, use the global value here.\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t\t\t    varp = options[opt_idx].var;\n\n\t\t\t// The old value is kept until we are sure that the\n\t\t\t// new value is valid.\n\t\t\toldval = *(char_u **)varp;\n\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t\t\t{\n\t\t\t    origval_l = *(char_u **)get_varp_scope(\n\t\t\t\t\t       &(options[opt_idx]), OPT_LOCAL);\n\t\t\t    origval_g = *(char_u **)get_varp_scope(\n\t\t\t\t\t      &(options[opt_idx]), OPT_GLOBAL);\n\n\t\t\t    // A global-local string option might have an empty\n\t\t\t    // option as value to indicate that the global\n\t\t\t    // value should be used.\n\t\t\t    if (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t\t  && origval_l == empty_option)\n\t\t\t\torigval_l = origval_g;\n\t\t\t}\n\n\t\t\t// When setting the local value of a global\n\t\t\t// option, the old value may be the global value.\n\t\t\tif (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t       && (opt_flags & OPT_LOCAL))\n\t\t\t    origval = *(char_u **)get_varp(\n\t\t\t\t\t\t       &options[opt_idx]);\n\t\t\telse\n\t\t\t    origval = oldval;\n\n\t\t\tif (nextchar == '&')\t// set to default val\n\t\t\t{\n\t\t\t    newval = options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\t    if ((char_u **)varp == &p_bg)\n\t\t\t    {\n\t\t\t\t// guess the value of 'background'\n#ifdef FEAT_GUI\n\t\t\t\tif (gui.in_use)\n\t\t\t\t    newval = gui_bg_default();\n\t\t\t\telse\n#endif\n\t\t\t\t    newval = term_bg_default();\n\t\t\t    }\n\t\t\t    else if ((char_u **)varp == &p_fencs && enc_utf8)\n\t\t\t\tnewval = fencs_utf8_default;\n\n\t\t\t    // expand environment variables and ~ (since the\n\t\t\t    // default value was already expanded, only\n\t\t\t    // required when an environment variable was set\n\t\t\t    // later\n\t\t\t    if (newval == NULL)\n\t\t\t\tnewval = empty_option;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = newval;\n\t\t\t\tnewval = vim_strsave(s);\n\t\t\t    }\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse if (nextchar == '<')\t// set to global val\n\t\t\t{\n\t\t\t    newval = vim_strsave(*(char_u **)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL));\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg;\t// jump to after the '=' or ':'\n\n\t\t\t    /*\n\t\t\t     * Set 'keywordprg' to \":help\" if an empty\n\t\t\t     * value was passed to :set by the user.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    if (varp == (char_u *)&p_kp\n\t\t\t\t\t      && (*arg == NUL || *arg == ' '))\n\t\t\t    {\n\t\t\t\tSTRCPY(errbuf, \":help\");\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'backspace' number to string, for\n\t\t\t     * adding, prepending and removing string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_bs\n\t\t\t\t\t && VIM_ISDIGIT(**(char_u **)varp))\n\t\t\t    {\n\t\t\t\ti = getdigits((char_u **)varp);\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\t    case 0:\n\t\t\t\t\t*(char_u **)varp = empty_option;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 1:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t      (char_u *)\"indent,eol\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 2:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,start\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 3:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,nostop\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvim_free(oldval);\n\t\t\t\tif (origval == oldval)\n\t\t\t\t    origval = *(char_u **)varp;\n\t\t\t\tif (origval_l == oldval)\n\t\t\t\t    origval_l = *(char_u **)varp;\n\t\t\t\tif (origval_g == oldval)\n\t\t\t\t    origval_g = *(char_u **)varp;\n\t\t\t\toldval = *(char_u **)varp;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'whichwrap' number to string, for\n\t\t\t     * backwards compatibility with Vim 3.0.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_ww\n\t\t\t\t\t\t\t && VIM_ISDIGIT(*arg))\n\t\t\t    {\n\t\t\t\t*errbuf = NUL;\n\t\t\t\ti = getdigits(&arg);\n\t\t\t\tif (i & 1)\n\t\t\t\t    STRCAT(errbuf, \"b,\");\n\t\t\t\tif (i & 2)\n\t\t\t\t    STRCAT(errbuf, \"s,\");\n\t\t\t\tif (i & 4)\n\t\t\t\t    STRCAT(errbuf, \"h,l,\");\n\t\t\t\tif (i & 8)\n\t\t\t\t    STRCAT(errbuf, \"<,>,\");\n\t\t\t\tif (i & 16)\n\t\t\t\t    STRCAT(errbuf, \"[,],\");\n\t\t\t\tif (*errbuf != NUL)\t// remove trailing ,\n\t\t\t\t    errbuf[STRLEN(errbuf) - 1] = NUL;\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Remove '>' before 'dir' and 'bdir', for\n\t\t\t     * backwards compatibility with version 3.0\n\t\t\t     */\n\t\t\t    else if (  *arg == '>'\n\t\t\t\t    && (varp == (char_u *)&p_dir\n\t\t\t\t\t    || varp == (char_u *)&p_bdir))\n\t\t\t    {\n\t\t\t\t++arg;\n\t\t\t    }\n\n\t\t\t    /*\n\t\t\t     * Copy the new string into allocated memory.\n\t\t\t     * Can't use set_string_option_direct(), because\n\t\t\t     * we need to remove the backslashes.\n\t\t\t     */\n\t\t\t    // get a bit too much\n\t\t\t    newlen = (unsigned)STRLEN(arg) + 1;\n\t\t\t    if (adding || prepending || removing)\n\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t    newval = alloc(newlen);\n\t\t\t    if (newval == NULL)  // out of mem, don't change\n\t\t\t\tbreak;\n\t\t\t    s = newval;\n\n\t\t\t    /*\n\t\t\t     * Copy the string, skip over escaped chars.\n\t\t\t     * For MS-DOS and WIN32 backslashes before normal\n\t\t\t     * file name characters are not removed, and keep\n\t\t\t     * backslash at start, for \"\\\\machine\\path\", but\n\t\t\t     * do remove it for \"\\\\\\\\machine\\\\path\".\n\t\t\t     * The reverse is found in ExpandOldSetting().\n\t\t\t     */\n\t\t\t    while (*arg && !VIM_ISWHITE(*arg))\n\t\t\t    {\n\t\t\t\tif (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t\t&& !((flags & P_EXPAND)\n\t\t\t\t\t\t&& vim_isfilec(arg[1])\n\t\t\t\t\t\t&& !VIM_ISWHITE(arg[1])\n\t\t\t\t\t\t&& (arg[1] != '\\\\'\n\t\t\t\t\t\t    || (s == newval\n\t\t\t\t\t\t\t&& arg[2] != '\\\\')))\n#endif\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t    ++arg;\t// remove backslash\n\t\t\t\tif (has_mbyte\n\t\t\t\t\t&& (i = (*mb_ptr2len)(arg)) > 1)\n\t\t\t\t{\n\t\t\t\t    // copy multibyte char\n\t\t\t\t    mch_memmove(s, arg, (size_t)i);\n\t\t\t\t    arg += i;\n\t\t\t\t    s += i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    *s++ = *arg++;\n\t\t\t    }\n\t\t\t    *s = NUL;\n\n\t\t\t    /*\n\t\t\t     * Expand environment variables and ~.\n\t\t\t     * Don't do it when adding without inserting a\n\t\t\t     * comma.\n\t\t\t     */\n\t\t\t    if (!(adding || prepending || removing)\n\t\t\t\t\t\t\t || (flags & P_COMMA))\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s != NULL)\n\t\t\t\t{\n\t\t\t\t    vim_free(newval);\n\t\t\t\t    newlen = (unsigned)STRLEN(s) + 1;\n\t\t\t\t    if (adding || prepending || removing)\n\t\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t\t    newval = alloc(newlen);\n\t\t\t\t    if (newval == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t    STRCPY(newval, s);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // locate newval[] in origval[] when removing it\n\t\t\t    // and when adding to avoid duplicates\n\t\t\t    i = 0;\t// init for GCC\n\t\t\t    if (removing || (flags & P_NODUP))\n\t\t\t    {\n\t\t\t\ti = (int)STRLEN(newval);\n\t\t\t\ts = find_dup_item(origval, newval, flags);\n\n\t\t\t\t// do not add if already there\n\t\t\t\tif ((adding || prepending) && s != NULL)\n\t\t\t\t{\n\t\t\t\t    prepending = FALSE;\n\t\t\t\t    adding = FALSE;\n\t\t\t\t    STRCPY(newval, origval);\n\t\t\t\t}\n\n\t\t\t\t// if no duplicate, move pointer to end of\n\t\t\t\t// original value\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = origval + (int)STRLEN(origval);\n\t\t\t    }\n\n\t\t\t    // concatenate the two strings; add a ',' if\n\t\t\t    // needed\n\t\t\t    if (adding || prepending)\n\t\t\t    {\n\t\t\t\tcomma = ((flags & P_COMMA) && *origval != NUL\n\t\t\t\t\t\t\t   && *newval != NUL);\n\t\t\t\tif (adding)\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(origval);\n\t\t\t\t    // strip a trailing comma, would get 2\n\t\t\t\t    if (comma && i > 1\n\t\t\t\t\t  && (flags & P_ONECOMMA) == P_ONECOMMA\n\t\t\t\t\t  && origval[i - 1] == ','\n\t\t\t\t\t  && origval[i - 2] != '\\\\')\n\t\t\t\t\ti--;\n\t\t\t\t    mch_memmove(newval + i + comma, newval,\n\t\t\t\t\t\t\t  STRLEN(newval) + 1);\n\t\t\t\t    mch_memmove(newval, origval, (size_t)i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(newval);\n\t\t\t\t    STRMOVE(newval + i + comma, origval);\n\t\t\t\t}\n\t\t\t\tif (comma)\n\t\t\t\t    newval[i] = ',';\n\t\t\t    }\n\n\t\t\t    // Remove newval[] from origval[]. (Note: \"i\" has\n\t\t\t    // been set above and is used here).\n\t\t\t    if (removing)\n\t\t\t    {\n\t\t\t\tSTRCPY(newval, origval);\n\t\t\t\tif (*s)\n\t\t\t\t{\n\t\t\t\t    // may need to remove a comma\n\t\t\t\t    if (flags & P_COMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (s == origval)\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma after string\n\t\t\t\t\t    if (s[i] == ',')\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma before string\n\t\t\t\t\t    --s;\n\t\t\t\t\t    ++i;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    STRMOVE(newval + (s - origval), s + i);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (flags & P_FLAGLIST)\n\t\t\t    {\n\t\t\t\t// Remove flags that appear twice.\n\t\t\t\tfor (s = newval; *s;)\n\t\t\t\t{\n\t\t\t\t    // if options have P_FLAGLIST and\n\t\t\t\t    // P_ONECOMMA such as 'whichwrap'\n\t\t\t\t    if (flags & P_ONECOMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (*s != ',' && *(s + 1) == ','\n\t\t\t\t\t      && vim_strchr(s + 2, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    // Remove the duplicated value and\n\t\t\t\t\t    // the next comma.\n\t\t\t\t\t    STRMOVE(s, s + 2);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tif ((!(flags & P_COMMA) || *s != ',')\n\t\t\t\t\t      && vim_strchr(s + 1, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    STRMOVE(s, s + 1);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    ++s;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (save_arg != NULL)   // number for 'whichwrap'\n\t\t\t\targ = save_arg;\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set the new value.\n\t\t\t */\n\t\t\t*(char_u **)(varp) = newval;\n\n#if defined(FEAT_EVAL)\n\t\t\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t\t\t&& options[opt_idx].indir != PV_KEY\n# endif\n\t\t\t\t\t  && origval != NULL && newval != NULL)\n\t\t\t{\n\t\t\t    // origval may be freed by\n\t\t\t    // did_set_string_option(), make a copy.\n\t\t\t    saved_origval = vim_strsave(origval);\n\t\t\t    // newval (and varp) may become invalid if the\n\t\t\t    // buffer is closed by autocommands.\n\t\t\t    saved_newval = vim_strsave(newval);\n\t\t\t    if (origval_l != NULL)\n\t\t\t\tsaved_origval_l = vim_strsave(origval_l);\n\t\t\t    if (origval_g != NULL)\n\t\t\t\tsaved_origval_g = vim_strsave(origval_g);\n\t\t\t}\n#endif\n\n\t\t\t{\n\t\t\t    long_u *p = insecure_flag(opt_idx, opt_flags);\n\t\t\t    int\t    secure_saved = secure;\n\n\t\t\t    // When an option is set in the sandbox, from a\n\t\t\t    // modeline or in secure mode, then deal with side\n\t\t\t    // effects in secure mode.  Also when the value was\n\t\t\t    // set with the P_INSECURE flag and is not\n\t\t\t    // completely replaced.\n\t\t\t    if ((opt_flags & OPT_MODELINE)\n#ifdef HAVE_SANDBOX\n\t\t\t\t  || sandbox != 0\n#endif\n\t\t\t\t  || (!value_is_replaced && (*p & P_INSECURE)))\n\t\t\t\tsecure = 1;\n\n\t\t\t    // Handle side effects, and set the global value\n\t\t\t    // for \":set\" on local options. Note: when setting\n\t\t\t    // 'syntax' or 'filetype' autocommands may be\n\t\t\t    // triggered that can cause havoc.\n\t\t\t    errmsg = did_set_string_option(\n\t\t\t\t    opt_idx, (char_u **)varp,\n\t\t\t\t    new_value_alloced, oldval, errbuf,\n\t\t\t\t    opt_flags, &value_checked);\n\n\t\t\t    secure = secure_saved;\n\t\t\t}\n\n#if defined(FEAT_EVAL)\n\t\t\tif (errmsg == NULL)\n\t\t\t    trigger_optionsset_string(\n\t\t\t\t    opt_idx, opt_flags, saved_origval,\n\t\t\t\t    saved_origval_l, saved_origval_g,\n\t\t\t\t    saved_newval);\n\t\t\tvim_free(saved_origval);\n\t\t\tvim_free(saved_origval_l);\n\t\t\tvim_free(saved_origval_g);\n\t\t\tvim_free(saved_newval);\n#endif\n\t\t\t// If error detected, print the error message.\n\t\t\tif (errmsg != NULL)\n\t\t\t    goto skip;\n\t\t    }\n\t\t    else\t    // key code option\n\t\t    {\n\t\t\tchar_u\t    *p;\n\n\t\t\tif (nextchar == '&')\n\t\t\t{\n\t\t\t    if (add_termcap_entry(key_name, TRUE) == FAIL)\n\t\t\t\terrmsg = N_(\"E522: Not found in termcap\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg; // jump to after the '=' or ':'\n\t\t\t    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)\n\t\t\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t\t\t    ++p;\n\t\t\t    nextchar = *p;\n\t\t\t    *p = NUL;\n\t\t\t    add_termcode(key_name, arg, FALSE);\n\t\t\t    *p = nextchar;\n\t\t\t}\n\t\t\tif (full_screen)\n\t\t\t    ttest(FALSE);\n\t\t\tredraw_all_later(CLEAR);\n\t\t    }\n\t\t}\n\n\t\tif (opt_idx >= 0)\n\t\t    did_set_option(\n\t\t\t opt_idx, opt_flags, value_is_replaced, value_checked);\n\t    }\n\nskip:\n\t    /*\n\t     * Advance to next argument.\n\t     * - skip until a blank found, taking care of backslashes\n\t     * - skip blanks\n\t     * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n\t     */\n\t    for (i = 0; i < 2 ; ++i)\n\t    {\n\t\twhile (*arg != NUL && !VIM_ISWHITE(*arg))\n\t\t    if (*arg++ == '\\\\' && *arg != NUL)\n\t\t\t++arg;\n\t\targ = skipwhite(arg);\n\t\tif (*arg != '=')\n\t\t    break;\n\t    }\n\t}\n\n\tif (errmsg != NULL)\n\t{\n\t    vim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);\n\t    i = (int)STRLEN(IObuff) + 2;\n\t    if (i + (arg - startarg) < IOSIZE)\n\t    {\n\t\t// append the argument with the error\n\t\tSTRCAT(IObuff, \": \");\n\t\tmch_memmove(IObuff + i, startarg, (arg - startarg));\n\t\tIObuff[i + (arg - startarg)] = NUL;\n\t    }\n\t    // make sure all characters are printable\n\t    trans_characters(IObuff, IOSIZE);\n\n\t    ++no_wait_return;\t\t// wait_return done later\n\t    emsg((char *)IObuff);\t// show error highlighted\n\t    --no_wait_return;\n\n\t    return FAIL;\n\t}\n\n\targ = skipwhite(arg);\n    }\n\ntheend:\n    if (silent_mode && did_show)\n    {\n\t// After displaying option values in silent mode.\n\tsilent_mode = FALSE;\n\tinfo_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = TRUE;\n\tinfo_message = FALSE;\t// use mch_msg(), not mch_errmsg()\n    }\n\n    return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\n    void\ndid_set_option(\n    int\t    opt_idx,\n    int\t    opt_flags,\t    // possibly with OPT_MODELINE\n    int\t    new_value,\t    // value was replaced completely\n    int\t    value_checked)  // value was checked to be safe, no need to set the\n\t\t\t    // P_INSECURE flag.\n{\n    long_u\t*p;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n    // When an option is set in the sandbox, from a modeline or in secure mode\n    // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n    // flag.\n    p = insecure_flag(opt_idx, opt_flags);\n    if (!value_checked && (secure\n#ifdef HAVE_SANDBOX\n\t    || sandbox != 0\n#endif\n\t    || (opt_flags & OPT_MODELINE)))\n\t*p = *p | P_INSECURE;\n    else if (new_value)\n\t*p = *p & ~P_INSECURE;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n * When \"multi_byte\" is TRUE allow for multi-byte characters.\n */\n    int\nstring_to_key(char_u *arg, int multi_byte)\n{\n    if (*arg == '<')\n\treturn find_key_option(arg + 1, TRUE);\n    if (*arg == '^')\n\treturn Ctrl_chr(arg[1]);\n    if (multi_byte)\n\treturn PTR2CHAR(arg);\n    return *arg;\n}\n\n#ifdef FEAT_TITLE\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call mch_restore_title() to get\n * the old value back.\n */\n    void\ndid_set_title(void)\n{\n    if (starting != NO_SCREEN\n#ifdef FEAT_GUI\n\t    && !gui.starting\n#endif\n\t\t\t\t)\n\tmaketitle();\n}\n#endif\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\n    void\nset_options_bin(\n    int\t\toldval,\n    int\t\tnewval,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    /*\n     * The option values that are changed when 'bin' changes are\n     * copied when 'bin is set and restored when 'bin' is reset.\n     */\n    if (newval)\n    {\n\tif (!oldval)\t\t// switched on\n\t{\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t    {\n\t\tcurbuf->b_p_tw_nobin = curbuf->b_p_tw;\n\t\tcurbuf->b_p_wm_nobin = curbuf->b_p_wm;\n\t\tcurbuf->b_p_ml_nobin = curbuf->b_p_ml;\n\t\tcurbuf->b_p_et_nobin = curbuf->b_p_et;\n\t    }\n\t    if (!(opt_flags & OPT_LOCAL))\n\t    {\n\t\tp_tw_nobin = p_tw;\n\t\tp_wm_nobin = p_wm;\n\t\tp_ml_nobin = p_ml;\n\t\tp_et_nobin = p_et;\n\t    }\n\t}\n\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = 0;\t// no automatic line wrap\n\t    curbuf->b_p_wm = 0;\t// no automatic line wrap\n\t    curbuf->b_p_ml = 0;\t// no modelines\n\t    curbuf->b_p_et = 0;\t// no expandtab\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = 0;\n\t    p_wm = 0;\n\t    p_ml = FALSE;\n\t    p_et = FALSE;\n\t    p_bin = TRUE;\t// needed when called for the \"-b\" argument\n\t}\n    }\n    else if (oldval)\t\t// switched off\n    {\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n\t    curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n\t    curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n\t    curbuf->b_p_et = curbuf->b_p_et_nobin;\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = p_tw_nobin;\n\t    p_wm = p_wm_nobin;\n\t    p_ml = p_ml_nobin;\n\t    p_et = p_et_nobin;\n\t}\n    }\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\n    static char_u *\noption_expand(int opt_idx, char_u *val)\n{\n    // if option doesn't need expansion nothing to do\n    if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n\treturn NULL;\n\n    // If val is longer than MAXPATHL no meaningful expansion can be done,\n    // expand_env() would truncate the string.\n    if (val != NULL && STRLEN(val) > MAXPATHL)\n\treturn NULL;\n\n    if (val == NULL)\n\tval = *(char_u **)options[opt_idx].var;\n\n    /*\n     * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n     * Escape spaces when expanding 'tags', they are used to separate file\n     * names.\n     * For 'spellsuggest' expand after \"file:\".\n     */\n    expand_env_esc(val, NameBuff, MAXPATHL,\n\t    (char_u **)options[opt_idx].var == &p_tags, FALSE,\n#ifdef FEAT_SPELL\n\t    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n#endif\n\t\t\t\t  NULL);\n    if (STRCMP(NameBuff, val) == 0)   // they are the same\n\treturn NULL;\n\n    return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    static void\ndidset_options(void)\n{\n    // initialize the table for 'iskeyword' et.al.\n    (void)init_chartab();\n\n    didset_string_options();\n\n#ifdef FEAT_SPELL\n    (void)spell_check_msm();\n    (void)spell_check_sps();\n    (void)compile_cap_prog(curwin->w_s);\n    (void)did_set_spell_option(TRUE);\n#endif\n#ifdef FEAT_CMDWIN\n    // set cedit_key\n    (void)check_cedit();\n#endif\n#ifdef FEAT_LINEBREAK\n    // initialize the table for 'breakat'.\n    fill_breakat_flags();\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * More side effects of setting options.\n */\n    static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\n    void\ncheck_options(void)\n{\n    int\t\topt_idx;\n\n    for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n\tif ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n\t    check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Return the option index found by a pointer into term_strings[].\n * Return -1 if not found.\n */\n    int\nget_term_opt_idx(char_u **p)\n{\n    int opt_idx;\n\n    for (opt_idx = 1; options[opt_idx].fullname != NULL; opt_idx++)\n\tif (options[opt_idx].var == (char_u *)p)\n\t    return opt_idx;\n    return -1; // cannot happen: didn't find it!\n}\n\n/*\n * Mark a terminal option as allocated, found by a pointer into term_strings[].\n * Return the option index or -1 if not found.\n */\n    int\nset_term_option_alloced(char_u **p)\n{\n    int\t\topt_idx = get_term_opt_idx(p);\n\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_ALLOCED;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\n    int\nwas_set_insecurely(char_u *opt, int opt_flags)\n{\n    int\t    idx = findoption(opt);\n    long_u  *flagp;\n\n    if (idx >= 0)\n    {\n\tflagp = insecure_flag(idx, opt_flags);\n\treturn (*flagp & P_INSECURE) != 0;\n    }\n    internal_error(\"was_set_insecurely()\");\n    return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n * NOTE: Caller must make sure that \"curwin\" is set to the window from which\n * the option is used.\n */\n    static long_u *\ninsecure_flag(int opt_idx, int opt_flags)\n{\n    if (opt_flags & OPT_LOCAL)\n\tswitch ((int)options[opt_idx].indir)\n\t{\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:\treturn &curwin->w_p_stl_flags;\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_FOLDING\n\t    case PV_FDE:\treturn &curwin->w_p_fde_flags;\n\t    case PV_FDT:\treturn &curwin->w_p_fdt_flags;\n# endif\n# ifdef FEAT_BEVAL\n\t    case PV_BEXPR:\treturn &curbuf->b_p_bexpr_flags;\n# endif\n# if defined(FEAT_CINDENT)\n\t    case PV_INDE:\treturn &curbuf->b_p_inde_flags;\n# endif\n\t    case PV_FEX:\treturn &curbuf->b_p_fex_flags;\n# ifdef FEAT_FIND_ID\n\t    case PV_INEX:\treturn &curbuf->b_p_inex_flags;\n# endif\n#endif\n\t}\n\n    // Nothing special, return global flags field.\n    return &options[opt_idx].flags;\n}\n#endif\n\n#if defined(FEAT_TITLE) || defined(PROTO)\n/*\n * Redraw the window title and/or tab page text later.\n */\nvoid redraw_titles(void)\n{\n    need_maketitle = TRUE;\n    redraw_tabline = TRUE;\n}\n#endif\n\n/*\n * Return TRUE if \"val\" is a valid name: only consists of alphanumeric ASCII\n * characters or characters in \"allowed\".\n */\n    int\nvalid_name(char_u *val, char *allowed)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)allowed, *s) == NULL)\n\t    return FALSE;\n    return TRUE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set the script_ctx for an option, taking care of setting the buffer- or\n * window-local value.\n */\n    void\nset_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)\n{\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tindir = (int)options[opt_idx].indir;\n    sctx_T\tnew_script_ctx = script_ctx;\n\n    // Modeline already has the line number set.\n    if (!(opt_flags & OPT_MODELINE))\n\tnew_script_ctx.sc_lnum += SOURCING_LNUM;\n\n    // Remember where the option was set.  For local options need to do that\n    // in the buffer or window structure.\n    if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n\toptions[opt_idx].script_ctx = new_script_ctx;\n    if (both || (opt_flags & OPT_LOCAL))\n    {\n\tif (indir & PV_BUF)\n\t    curbuf->b_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\telse if (indir & PV_WIN)\n\t    curwin->w_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n    }\n}\n\n/*\n * Set the script_ctx for a termcap option.\n * \"name\" must be the two character code, e.g. \"RV\".\n * When \"name\" is NULL use \"opt_idx\".\n */\n    void\nset_term_option_sctx_idx(char *name, int opt_idx)\n{\n    char_u  buf[5];\n    int\t    idx;\n\n    if (name == NULL)\n\tidx = opt_idx;\n    else\n    {\n\tbuf[0] = 't';\n\tbuf[1] = '_';\n\tbuf[2] = name[0];\n\tbuf[3] = name[1];\n\tbuf[4] = 0;\n\tidx = findoption(buf);\n    }\n    if (idx >= 0)\n\tset_option_sctx_idx(idx, OPT_GLOBAL, current_sctx);\n}\n#endif\n\n#if defined(FEAT_EVAL)\n/*\n * Apply the OptionSet autocommand.\n */\n    static void\napply_optionset_autocmd(\n\tint\topt_idx,\n\tlong\topt_flags,\n\tlong\toldval,\n\tlong\toldval_g,\n\tlong\tnewval,\n\tchar\t*errmsg)\n{\n    char_u buf_old[12], buf_old_global[12], buf_new[12], buf_type[12];\n\n    // Don't do this while starting up, failure or recursively.\n    if (starting || errmsg != NULL || *get_vim_var_str(VV_OPTION_TYPE) != NUL)\n\treturn;\n\n    vim_snprintf((char *)buf_old, sizeof(buf_old), \"%ld\", oldval);\n    vim_snprintf((char *)buf_old_global, sizeof(buf_old_global), \"%ld\",\n\t\t\t\t\t\t\toldval_g);\n    vim_snprintf((char *)buf_new, sizeof(buf_new), \"%ld\", newval);\n    vim_snprintf((char *)buf_type, sizeof(buf_type), \"%s\",\n\t\t\t\t(opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    if (opt_flags & OPT_LOCAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    if (opt_flags & OPT_GLOBAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);\n    }\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);\n    }\n    if (opt_flags & OPT_MODELINE)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    apply_autocmds(EVENT_OPTIONSET, (char_u *)options[opt_idx].fullname,\n\t    NULL, FALSE, NULL);\n    reset_v_option_vars();\n}\n#endif\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_bool_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    int\t\tvalue,\t\t\t// new value\n    int\t\topt_flags)\t\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\told_value = *(int *)varp;\n#if defined(FEAT_EVAL)\n    int\t\told_global_value = 0;\n#endif\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_secure;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *(int *)varp = value;\t    // set the new value\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n    /*\n     * Handle side effects of changing a bool option.\n     */\n\n    // 'compatible'\n    if ((int *)varp == &p_cp)\n\tcompatible_set();\n\n#ifdef FEAT_LANGMAP\n    if ((int *)varp == &p_lrm)\n\t// 'langremap' -> !'langnoremap'\n\tp_lnr = !p_lrm;\n    else if ((int *)varp == &p_lnr)\n\t// 'langnoremap' -> !'langremap'\n\tp_lrm = !p_lnr;\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if ((int *)varp == &curwin->w_p_cul && !value && old_value)\n\treset_cursorline();\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n    // 'undofile'\n    else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf)\n    {\n\t// Only take action when the option was set. When reset we do not\n\t// delete the undo file, the option may be set again without making\n\t// any changes in between.\n\tif (curbuf->b_p_udf || p_udf)\n\t{\n\t    char_u\thash[UNDO_HASH_SIZE];\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    FOR_ALL_BUFFERS(curbuf)\n\t    {\n\t\t// When 'undofile' is set globally: for every buffer, otherwise\n\t\t// only for the current buffer: Try to read in the undofile,\n\t\t// if one exists, the buffer wasn't changed and the buffer was\n\t\t// loaded\n\t\tif ((curbuf == save_curbuf\n\t\t\t\t|| (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n\t\t\t&& !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n#ifdef FEAT_CRYPT\n\t\t    if (crypt_get_method_nr(curbuf) == CRYPT_M_SOD)\n\t\t\tcontinue;\n#endif\n\t\t    u_compute_hash(hash);\n\t\t    u_read_undo(NULL, hash, curbuf->b_fname);\n\t\t}\n\t    }\n\t    curbuf = save_curbuf;\n\t}\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_p_ro)\n    {\n\t// when 'readonly' is reset globally, also reset readonlymode\n\tif (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n\t    readonlymode = FALSE;\n\n\t// when 'readonly' is set may give W10 again\n\tif (curbuf->b_p_ro)\n\t    curbuf->b_did_warn = FALSE;\n\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n    }\n\n#ifdef FEAT_GUI\n    else if ((int *)varp == &p_mh)\n    {\n\tif (!p_mh)\n\t    gui_mch_mousehide(FALSE);\n    }\n#endif\n\n    // when 'modifiable' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_ma)\n    {\n# ifdef FEAT_TERMINAL\n\t// Cannot set 'modifiable' when in Terminal mode.\n\tif (curbuf->b_p_ma && (term_in_normal_mode() || (bt_terminal(curbuf)\n\t\t      && curbuf->b_term != NULL && !term_is_finished(curbuf))))\n\t{\n\t    curbuf->b_p_ma = FALSE;\n\t    return N_(\"E946: Cannot make a terminal with running job modifiable\");\n\t}\n# endif\n# ifdef FEAT_TITLE\n\tredraw_titles();\n# endif\n    }\n#ifdef FEAT_TITLE\n    // when 'endofline' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_eol)\n    {\n\tredraw_titles();\n    }\n    // when 'fixeol' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_fixeol)\n    {\n\tredraw_titles();\n    }\n    // when 'bomb' is changed, redraw the window title and tab page text\n    else if ((int *)varp == &curbuf->b_p_bomb)\n    {\n\tredraw_titles();\n    }\n#endif\n\n    // when 'bin' is set also set some other options\n    else if ((int *)varp == &curbuf->b_p_bin)\n    {\n\tset_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n    }\n\n    // when 'buflisted' changes, trigger autocommands\n    else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl)\n    {\n\tapply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n\t\t\t\t\t\t    NULL, NULL, TRUE, curbuf);\n    }\n\n    // when 'swf' is set, create swapfile, when reset remove swapfile\n    else if ((int *)varp == &curbuf->b_p_swf)\n    {\n\tif (curbuf->b_p_swf && p_uc)\n\t    ml_open_file(curbuf);\t\t// create the swap file\n\telse\n\t    // no need to reset curbuf->b_may_swap, ml_open_file() will check\n\t    // buf->b_p_swf\n\t    mf_close_file(curbuf, TRUE);\t// remove the swap file\n    }\n\n    // when 'terse' is set change 'shortmess'\n    else if ((int *)varp == &p_terse)\n    {\n\tchar_u\t*p;\n\n\tp = vim_strchr(p_shm, SHM_SEARCH);\n\n\t// insert 's' in p_shm\n\tif (p_terse && p == NULL)\n\t{\n\t    STRCPY(IObuff, p_shm);\n\t    STRCAT(IObuff, \"s\");\n\t    set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n\t}\n\t// remove 's' from p_shm\n\telse if (!p_terse && p != NULL)\n\t    STRMOVE(p, p + 1);\n    }\n\n    // when 'paste' is set or reset also change other options\n    else if ((int *)varp == &p_paste)\n    {\n\tpaste_option_changed();\n    }\n\n    // when 'insertmode' is set from an autocommand need to do work here\n    else if ((int *)varp == &p_im)\n    {\n\tif (p_im)\n\t{\n\t    if ((State & INSERT) == 0)\n\t\tneed_start_insertmode = TRUE;\n\t    stop_insert_mode = FALSE;\n\t}\n\t// only reset if it was set previously\n\telse if (old_value)\n\t{\n\t    need_start_insertmode = FALSE;\n\t    stop_insert_mode = TRUE;\n\t    if (restart_edit != 0 && mode_displayed)\n\t\tclear_cmdline = TRUE;\t// remove \"(insert)\"\n\t    restart_edit = 0;\n\t}\n    }\n\n    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw\n    else if ((int *)varp == &p_ic && p_hls)\n    {\n\tredraw_all_later(SOME_VALID);\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // when 'hlsearch' is set or reset: reset no_hlsearch\n    else if ((int *)varp == &p_hls)\n    {\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    // when 'scrollbind' is set: snapshot the current position to avoid a jump\n    // at the end of normal_cmd()\n    else if ((int *)varp == &curwin->w_p_scb)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    do_check_scrollbind(FALSE);\n\t    curwin->w_scbind_pos = curwin->w_topline;\n\t}\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // There can be only one window with 'previewwindow' set.\n    else if ((int *)varp == &curwin->w_p_pvw)\n    {\n\tif (curwin->w_p_pvw)\n\t{\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t\tif (win->w_p_pvw && win != curwin)\n\t\t{\n\t\t    curwin->w_p_pvw = FALSE;\n\t\t    return N_(\"E590: A preview window already exists\");\n\t\t}\n\t}\n    }\n#endif\n\n    // when 'textmode' is set or reset also change 'fileformat'\n    else if ((int *)varp == &curbuf->b_p_tx)\n    {\n\tset_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);\n    }\n\n    // when 'textauto' is set or reset also change 'fileformats'\n    else if ((int *)varp == &p_ta)\n    {\n\tset_string_option_direct((char_u *)\"ffs\", -1,\n\t\t\t\t p_ta ? (char_u *)DFLT_FFS_VIM : (char_u *)\"\",\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n    }\n\n    /*\n     * When 'lisp' option changes include/exclude '-' in\n     * keyword characters.\n     */\n#ifdef FEAT_LISP\n    else if (varp == (char_u *)&(curbuf->b_p_lisp))\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\t    // ignore errors\n    }\n#endif\n\n#ifdef FEAT_TITLE\n    // when 'title' changed, may need to change the title; same for 'icon'\n    else if ((int *)varp == &p_title || (int *)varp == &p_icon)\n    {\n\tdid_set_title();\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_changed)\n    {\n\tif (!value)\n\t    save_file_ff(curbuf);\t// Buffer is unchanged\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n\tmodified_was_set = value;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    else if ((int *)varp == &p_ssl)\n    {\n\tif (p_ssl)\n\t{\n\t    psepc = '/';\n\t    psepcN = '\\\\';\n\t    pseps[0] = '/';\n\t}\n\telse\n\t{\n\t    psepc = '\\\\';\n\t    psepcN = '/';\n\t    pseps[0] = '\\\\';\n\t}\n\n\t// need to adjust the file name arguments and buffer names.\n\tbuflist_slash_adjust();\n\talist_slash_adjust();\n# ifdef FEAT_EVAL\n\tscriptnames_slash_adjust();\n# endif\n    }\n#endif\n\n    // If 'wrap' is set, set w_leftcol to zero.\n    else if ((int *)varp == &curwin->w_p_wrap)\n    {\n\tif (curwin->w_p_wrap)\n\t    curwin->w_leftcol = 0;\n    }\n\n    else if ((int *)varp == &p_ea)\n    {\n\tif (p_ea && !old_value)\n\t    win_equal(curwin, FALSE, 0);\n    }\n\n    else if ((int *)varp == &p_wiv)\n    {\n\t/*\n\t * When 'weirdinvert' changed, set/reset 't_xs'.\n\t * Then set 'weirdinvert' according to value of 't_xs'.\n\t */\n\tif (p_wiv && !old_value)\n\t    T_XS = (char_u *)\"y\";\n\telse if (!p_wiv && old_value)\n\t    T_XS = empty_option;\n\tp_wiv = (*T_XS != NUL);\n    }\n\n#ifdef FEAT_BEVAL_GUI\n    else if ((int *)varp == &p_beval)\n    {\n\tif (!balloonEvalForTerm)\n\t{\n\t    if (p_beval && !old_value)\n\t\tgui_mch_enable_beval_area(balloonEval);\n\t    else if (!p_beval && old_value)\n\t\tgui_mch_disable_beval_area(balloonEval);\n\t}\n    }\n#endif\n#ifdef FEAT_BEVAL_TERM\n    else if ((int *)varp == &p_bevalterm)\n    {\n\tmch_bevalterm_changed();\n    }\n#endif\n\n#ifdef FEAT_AUTOCHDIR\n    else if ((int *)varp == &p_acd)\n    {\n\t// Change directories when the 'acd' option is set now.\n\tDO_AUTOCHDIR;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // 'diff'\n    else if ((int *)varp == &curwin->w_p_diff)\n    {\n\t// May add or remove the buffer from the list of diff buffers.\n\tdiff_buf_adjust(curwin);\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsDiff(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n    }\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    // 'imdisable'\n    else if ((int *)varp == &p_imdisable)\n    {\n\t// Only de-activate it here, it will be enabled when changing mode.\n\tif (p_imdisable)\n\t    im_set_active(FALSE);\n\telse if (State & INSERT)\n\t    // When the option is set from an autocommand, it may need to take\n\t    // effect right away.\n\t    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // 'spell'\n    else if ((int *)varp == &curwin->w_p_spell)\n    {\n\tif (curwin->w_p_spell)\n\t{\n\t    char\t*errmsg = did_set_spelllang(curwin);\n\n\t    if (errmsg != NULL)\n\t\temsg(_(errmsg));\n\t}\n    }\n#endif\n\n#ifdef FEAT_ARABIC\n    if ((int *)varp == &curwin->w_p_arab)\n    {\n\tif (curwin->w_p_arab)\n\t{\n\t    /*\n\t     * 'arabic' is set, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// set rightleft mode\n\t\tif (!curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = TRUE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// Enable Arabic shaping (major part of what Arabic requires)\n\t\tif (!p_arshape)\n\t\t{\n\t\t    p_arshape = TRUE;\n\t\t    redraw_later_clear();\n\t\t}\n\t    }\n\n\t    // Arabic requires a utf-8 encoding, inform the user if its not\n\t    // set.\n\t    if (STRCMP(p_enc, \"utf-8\") != 0)\n\t    {\n\t\tstatic char *w_arabic = N_(\"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n\t\tmsg_source(HL_ATTR(HLF_W));\n\t\tmsg_attr(_(w_arabic), HL_ATTR(HLF_W));\n#ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);\n#endif\n\t    }\n\n\t    // set 'delcombine'\n\t    p_deco = TRUE;\n\n# ifdef FEAT_KEYMAP\n\t    // Force-set the necessary keymap for arabic\n\t    set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n# endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * 'arabic' is reset, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// reset rightleft mode\n\t\tif (curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = FALSE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// 'arabicshape' isn't reset, it is a global option and\n\t\t// another window may still need it \"on\".\n\t    }\n\n\t    // 'delcombine' isn't reset, it is a global option and another\n\t    // window may still want it \"on\".\n\n# ifdef FEAT_KEYMAP\n\t    // Revert to the default keymap\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n# endif\n\t}\n    }\n\n#endif\n\n#if defined(FEAT_SIGNS) && defined(FEAT_GUI)\n    else if (((int *)varp == &curwin->w_p_nu\n\t\t|| (int *)varp == &curwin->w_p_rnu)\n\t    && gui.in_use\n\t    && (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u')\n\t    && curbuf->b_signlist != NULL)\n    {\n\t// If the 'number' or 'relativenumber' options are modified and\n\t// 'signcolumn' is set to 'number', then clear the screen for a full\n\t// refresh. Otherwise the sign icons are not displayed properly in the\n\t// number column.  If the 'number' option is set and only the\n\t// 'relativenumber' option is toggled, then don't refresh the screen\n\t// (optimization).\n\tif (!(curwin->w_p_nu && ((int *)varp == &curwin->w_p_rnu)))\n\t    redraw_all_later(CLEAR);\n    }\n#endif\n\n#ifdef FEAT_TERMGUICOLORS\n    // 'termguicolors'\n    else if ((int *)varp == &p_tgc)\n    {\n# ifdef FEAT_VTP\n\t// Do not turn on 'tgc' when 24-bit colors are not supported.\n\tif (\n#  ifdef VIMDLL\n\t    !gui.in_use && !gui.starting &&\n#  endif\n\t    !has_vtp_working())\n\t{\n\t    p_tgc = 0;\n\t    return N_(\"E954: 24-bit colors are not supported on this environment\");\n\t}\n\tif (is_term_win32())\n\t    swap_tcap();\n# endif\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t    highlight_gui_started();\n# ifdef FEAT_VTP\n\t// reset t_Co\n\tif (is_term_win32())\n\t{\n\t    control_console_color_rgb();\n\t    set_termname(T_NAME);\n\t    init_highlight(TRUE, FALSE);\n\t}\n# endif\n    }\n#endif\n\n    /*\n     * End of handling side effects for bool options.\n     */\n\n    // after handling side effects, call autocommand\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags,\n\t\t\t\t(long)(old_value ? TRUE : FALSE),\n\t\t\t\t(long)(old_global_value ? TRUE : FALSE),\n\t\t\t\t(long)(value ? TRUE : FALSE), NULL);\n#endif\n\n    comp_col();\t\t\t    // in case 'ruler' or 'showcmd' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_secure;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invarg;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invarg;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n#ifdef FEAT_TITLE\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n#endif\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf((char *)errbuf, errbuflen,\n\t\t\t       _(\"E593: Need at least %d lines\"), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf((char *)errbuf, errbuflen,\n\t\t\t    _(\"E594: Need at least %d columns\"), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invarg;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invarg;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\n    void\ncheck_redraw(long_u flags)\n{\n    // Careful: P_RCLR and P_RALL are a combination of other P_ flags\n    int\t\tdoclear = (flags & P_RCLR) == P_RCLR;\n    int\t\tall = ((flags & P_RALL) == P_RALL || doclear);\n\n    if ((flags & P_RSTAT) || all)\t// mark all status lines dirty\n\tstatus_redraw_all();\n\n    if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n\tchanged_window_setting();\n    if (flags & P_RBUF)\n\tredraw_curbuf_later(NOT_VALID);\n    if (flags & P_RWINONLY)\n\tredraw_later(NOT_VALID);\n    if (doclear)\n\tredraw_all_later(CLEAR);\n    else if (all)\n\tredraw_all_later(NOT_VALID);\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\n    int\nfindoption(char_u *arg)\n{\n    int\t\t    opt_idx;\n    char\t    *s, *p;\n    static short    quick_tab[27] = {0, 0};\t// quick access table\n    int\t\t    is_term_opt;\n\n    /*\n     * For first call: Initialize the quick-access table.\n     * It contains the index for the first option that starts with a certain\n     * letter.  There are 26 letters, plus the first \"t_\" option.\n     */\n    if (quick_tab[1] == 0)\n    {\n\tp = options[0].fullname;\n\tfor (opt_idx = 1; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n\t{\n\t    if (s[0] != p[0])\n\t    {\n\t\tif (s[0] == 't' && s[1] == '_')\n\t\t    quick_tab[26] = opt_idx;\n\t\telse\n\t\t    quick_tab[CharOrdLow(s[0])] = opt_idx;\n\t    }\n\t    p = s;\n\t}\n    }\n\n    /*\n     * Check for name starting with an illegal character.\n     */\n#ifdef EBCDIC\n    if (!islower(arg[0]))\n#else\n    if (arg[0] < 'a' || arg[0] > 'z')\n#endif\n\treturn -1;\n\n    is_term_opt = (arg[0] == 't' && arg[1] == '_');\n    if (is_term_opt)\n\topt_idx = quick_tab[26];\n    else\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n    for ( ; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n    {\n\tif (STRCMP(arg, s) == 0)\t\t    // match full name\n\t    break;\n    }\n    if (s == NULL && !is_term_opt)\n    {\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n\tfor ( ; options[opt_idx].fullname != NULL; opt_idx++)\n\t{\n\t    s = options[opt_idx].shortname;\n\t    if (s != NULL && STRCMP(arg, s) == 0)   // match short name\n\t\tbreak;\n\t    s = NULL;\n\t}\n    }\n    if (s == NULL)\n\topt_idx = -1;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_TCL) || defined(FEAT_MZSCHEME)\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number option: gov_number, *numval gets value.\n * Toggle option: gov_bool,   *numval gets value.\n * String option: gov_string, *stringval gets allocated string.\n * Hidden Number option: gov_hidden_number.\n * Hidden Toggle option: gov_hidden_bool.\n * Hidden String option: gov_hidden_string.\n * Unknown option: gov_unknown.\n */\n    getoption_T\nget_option_value(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only checking existence\n    int\t\topt_flags)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\t\t    // option not in the table\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t\t\t  && (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\t    char_u *p;\n\n\t    // check for a terminal option\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    p = find_termcode(key_name);\n\t    if (p != NULL)\n\t    {\n\t\tif (stringval != NULL)\n\t\t    *stringval = vim_strsave(p);\n\t\treturn gov_string;\n\t    }\n\t}\n\treturn gov_unknown;\n    }\n\n    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\n    if (options[opt_idx].flags & P_STRING)\n    {\n\tif (varp == NULL)\t\t    // hidden option\n\t    return gov_hidden_string;\n\tif (stringval != NULL)\n\t{\n#ifdef FEAT_CRYPT\n\t    // never return the value of the crypt key\n\t    if ((char_u **)varp == &curbuf->b_p_key\n\t\t\t\t\t\t&& **(char_u **)(varp) != NUL)\n\t\t*stringval = vim_strsave((char_u *)\"*****\");\n\t    else\n#endif\n\t\t*stringval = vim_strsave(*(char_u **)(varp));\n\t}\n\treturn gov_string;\n    }\n\n    if (varp == NULL)\t\t    // hidden option\n\treturn (options[opt_idx].flags & P_NUM)\n\t\t\t\t\t ? gov_hidden_number : gov_hidden_bool;\n    if (options[opt_idx].flags & P_NUM)\n\t*numval = *(long *)varp;\n    else\n    {\n\t// Special case: 'modified' is b_changed, but we also want to consider\n\t// it set when 'ff' or 'fenc' changed.\n\tif ((int *)varp == &curbuf->b_changed)\n\t    *numval = curbufIsChanged();\n\telse\n\t    *numval = (long) *(int *)varp;\n    }\n    return (options[opt_idx].flags & P_NUM) ? gov_number : gov_bool;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Returns the option attributes and its value. Unlike the above function it\n * will return either global value or local value of the option depending on\n * what was requested, but it will never return global value if it was\n * requested to return local one and vice versa. Neither it will return\n * buffer-local value if it was requested to return window-local one.\n *\n * Pretends that option is absent if it is not present in the requested scope\n * (i.e. has no global, window-local or buffer-local value depending on\n * opt_type). Uses\n *\n * Returned flags:\n *       0 hidden or unknown option, also option that does not have requested\n *\t   type (see SREQ_* in vim.h)\n *  see SOPT_* in vim.h for other flags\n *\n * Possible opt_type values: see SREQ_* in vim.h\n */\n    int\nget_option_value_strict(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only obtaining attributes\n    int\t\topt_type,\n    void\t*from)\n{\n    int\t\topt_idx;\n    char_u\t*varp = NULL;\n    struct vimoption *p;\n    int\t\tr = 0;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn 0;\n\n    p = &(options[opt_idx]);\n\n    // Hidden option\n    if (p->var == NULL)\n\treturn 0;\n\n    if (p->flags & P_BOOL)\n\tr |= SOPT_BOOL;\n    else if (p->flags & P_NUM)\n\tr |= SOPT_NUM;\n    else if (p->flags & P_STRING)\n\tr |= SOPT_STRING;\n\n    if (p->indir == PV_NONE)\n    {\n\tif (opt_type == SREQ_GLOBAL)\n\t    r |= SOPT_GLOBAL;\n\telse\n\t    return 0; // Did not request global-only option\n    }\n    else\n    {\n\tif (p->indir & PV_BOTH)\n\t    r |= SOPT_GLOBAL;\n\telse if (opt_type == SREQ_GLOBAL)\n\t    return 0; // Requested global option\n\n\tif (p->indir & PV_WIN)\n\t{\n\t    if (opt_type == SREQ_BUF)\n\t\treturn 0; // Did not request window-local option\n\t    else\n\t\tr |= SOPT_WIN;\n\t}\n\telse if (p->indir & PV_BUF)\n\t{\n\t    if (opt_type == SREQ_WIN)\n\t\treturn 0; // Did not request buffer-local option\n\t    else\n\t\tr |= SOPT_BUF;\n\t}\n    }\n\n    if (stringval == NULL)\n\treturn r;\n\n    if (opt_type == SREQ_GLOBAL)\n\tvarp = p->var;\n    else\n    {\n\tif (opt_type == SREQ_BUF)\n\t{\n\t    // Special case: 'modified' is b_changed, but we also want to\n\t    // consider it set when 'ff' or 'fenc' changed.\n\t    if (p->indir == PV_MOD)\n\t    {\n\t\t*numval = bufIsChanged((buf_T *)from);\n\t\tvarp = NULL;\n\t    }\n#ifdef FEAT_CRYPT\n\t    else if (p->indir == PV_KEY)\n\t    {\n\t\t// never return the value of the crypt key\n\t\t*stringval = NULL;\n\t\tvarp = NULL;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\t// only getting a pointer, no need to use aucmd_prepbuf()\n\t\tcurbuf = (buf_T *)from;\n\t\tcurwin->w_buffer = curbuf;\n\t\tvarp = get_varp(p);\n\t\tcurbuf = save_curbuf;\n\t\tcurwin->w_buffer = curbuf;\n\t    }\n\t}\n\telse if (opt_type == SREQ_WIN)\n\t{\n\t    win_T\t*save_curwin = curwin;\n\n\t    curwin = (win_T *)from;\n\t    curbuf = curwin->w_buffer;\n\t    varp = get_varp(p);\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tif (varp == p->var)\n\t    return (r | SOPT_UNSET);\n    }\n\n    if (varp != NULL)\n    {\n\tif (p->flags & P_STRING)\n\t    *stringval = vim_strsave(*(char_u **)(varp));\n\telse if (p->flags & P_NUM)\n\t    *numval = *(long *) varp;\n\telse\n\t    *numval = *(int *)varp;\n    }\n\n    return r;\n}\n\n/*\n * Iterate over options. First argument is a pointer to a pointer to a\n * structure inside options[] array, second is option type like in the above\n * function.\n *\n * If first argument points to NULL it is assumed that iteration just started\n * and caller needs the very first value.\n * If first argument points to the end marker function returns NULL and sets\n * first argument to NULL.\n *\n * Returns full option name for current option on each call.\n */\n    char_u *\noption_iter_next(void **option, int opt_type)\n{\n    struct vimoption\t*ret = NULL;\n    do\n    {\n\tif (*option == NULL)\n\t    *option = (void *) options;\n\telse if (((struct vimoption *) (*option))->fullname == NULL)\n\t{\n\t    *option = NULL;\n\t    return NULL;\n\t}\n\telse\n\t    *option = (void *) (((struct vimoption *) (*option)) + 1);\n\n\tret = ((struct vimoption *) (*option));\n\n\t// Hidden option\n\tif (ret->var == NULL)\n\t{\n\t    ret = NULL;\n\t    continue;\n\t}\n\n\tswitch (opt_type)\n\t{\n\t    case SREQ_GLOBAL:\n\t\tif (!(ret->indir == PV_NONE || ret->indir & PV_BOTH))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_BUF:\n\t\tif (!(ret->indir & PV_BUF))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_WIN:\n\t\tif (!(ret->indir & PV_WIN))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    default:\n\t\tinternal_error(\"option_iter_next()\");\n\t\treturn NULL;\n\t}\n    }\n    while (ret == NULL);\n\n    return (char_u *)ret->fullname;\n}\n#endif\n\n/*\n * Return the flags for the option at 'opt_idx'.\n */\n    long_u\nget_option_flags(int opt_idx)\n{\n    return options[opt_idx].flags;\n}\n\n/*\n * Set a flag for the option at 'opt_idx'.\n */\n    void\nset_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags |= flag;\n}\n\n/*\n * Clear a flag for the option at 'opt_idx'.\n */\n    void\nclear_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags &= ~flag;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option\n */\n    int\nis_global_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_NONE;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option which also has a\n * local value.\n */\n    int\nis_global_local_option(int opt_idx)\n{\n    return options[opt_idx].indir & PV_BOTH;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a window-local option\n */\n    int\nis_window_local_option(int opt_idx)\n{\n    return options[opt_idx].var == VAR_WIN;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a hidden option\n */\n    int\nis_hidden_option(int opt_idx)\n{\n    return options[opt_idx].var == NULL;\n}\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Returns TRUE if the option at 'opt_idx' is a crypt key option\n */\n    int\nis_crypt_key_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_KEY;\n}\n#endif\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    add_termcode(key_name, string, FALSE);\n\t    if (full_screen)\n\t\tttest(FALSE);\n\t    redraw_all_later(CLEAR);\n\t    return NULL;\n\t}\n\n\tsemsg(_(\"E355: Unknown option: %s\"), name);\n    }\n    else\n    {\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags);\n\telse\n\t{\n\t    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    if (varp != NULL)\t// hidden option is not changed\n\t    {\n\t\tif (number == 0 && string != NULL)\n\t\t{\n\t\t    int idx;\n\n\t\t    // Either we are given a string or we are setting option\n\t\t    // to zero.\n\t\t    for (idx = 0; string[idx] == '0'; ++idx)\n\t\t\t;\n\t\t    if (string[idx] != NUL || idx == 0)\n\t\t    {\n\t\t\t// There's another character after zeros or the string\n\t\t\t// is empty.  In both cases, we are trying to set a\n\t\t\t// num option using a string.\n\t\t\tsemsg(_(\"E521: Number required: &%s = '%s'\"),\n\t\t\t\t\t\t\t\tname, string);\n\t\t\treturn NULL;     // do nothing as we hit an error\n\n\t\t    }\n\t\t}\n\t\tif (flags & P_NUM)\n\t\t    return set_num_option(opt_idx, varp, number,\n\t\t\t\t\t\t\t  NULL, 0, opt_flags);\n\t\telse\n\t\t    return set_bool_option(opt_idx, varp, (int)number,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t    }\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the terminal code for a terminal option.\n * Returns NULL when not found.\n */\n    char_u *\nget_term_code(char_u *tname)\n{\n    int\t    opt_idx;\n    char_u  *varp;\n\n    if (tname[0] != 't' || tname[1] != '_' ||\n\t    tname[2] == NUL || tname[3] == NUL)\n\treturn NULL;\n    if ((opt_idx = findoption(tname)) >= 0)\n    {\n\tvarp = get_varp(&(options[opt_idx]));\n\tif (varp != NULL)\n\t    varp = *(char_u **)(varp);\n\treturn varp;\n    }\n    return find_termcode(tname + 2);\n}\n\n    char_u *\nget_highlight_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"hl\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n    char_u *\nget_encoding_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"enc\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n * When \"has_lt\" is true there is a '<' before \"*arg_arg\".\n * Returns 0 when the key is not recognized.\n */\n    static int\nfind_key_option(char_u *arg_arg, int has_lt)\n{\n    int\t\tkey = 0;\n    int\t\tmodifiers;\n    char_u\t*arg = arg_arg;\n\n    /*\n     * Don't use get_special_key_code() for t_xx, we don't want it to call\n     * add_termcap_entry().\n     */\n    if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\tkey = TERMCAP2KEY(arg[2], arg[3]);\n    else if (has_lt)\n    {\n\t--arg;\t\t\t    // put arg at the '<'\n\tmodifiers = 0;\n\tkey = find_special_key(&arg, &modifiers,\n\t\t\t    FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);\n\tif (modifiers)\t\t    // can't handle modifiers here\n\t    key = 0;\n    }\n    return key;\n}\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n * if 'all' == 2: show all terminal options\n */\n    static void\nshowoptions(\n    int\t\tall,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    struct vimoption\t*p;\n    int\t\t\tcol;\n    int\t\t\tisterm;\n    char_u\t\t*varp;\n    struct vimoption\t**items;\n    int\t\t\titem_count;\n    int\t\t\trun;\n    int\t\t\trow, rows;\n    int\t\t\tcols;\n    int\t\t\ti;\n    int\t\t\tlen;\n\n#define INC 20\n#define GAP 3\n\n    items = ALLOC_MULT(struct vimoption *, OPTION_COUNT);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    if (all == 2)\n\tmsg_puts_title(_(\"\\n--- Terminal codes ---\"));\n    else if (opt_flags & OPT_GLOBAL)\n\tmsg_puts_title(_(\"\\n--- Global option values ---\"));\n    else if (opt_flags & OPT_LOCAL)\n\tmsg_puts_title(_(\"\\n--- Local option values ---\"));\n    else\n\tmsg_puts_title(_(\"\\n--- Options ---\"));\n\n    /*\n     * Do the loop two times:\n     * 1. display the short items\n     * 2. display the long items (only strings and numbers)\n     * When \"opt_flags\" has OPT_ONECOLUMN do everything in run 2.\n     */\n    for (run = 1; run <= 2 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (p = &options[0]; p->fullname != NULL; p++)\n\t{\n\t    // apply :filter /pat/\n\t    if (message_filtered((char_u *)p->fullname))\n\t\tcontinue;\n\n\t    varp = NULL;\n\t    isterm = istermoption(p);\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) != 0)\n\t    {\n\t\tif (p->indir != PV_NONE && !isterm)\n\t\t    varp = get_varp_scope(p, opt_flags);\n\t    }\n\t    else\n\t\tvarp = get_varp(p);\n\t    if (varp != NULL\n\t\t    && ((all == 2 && isterm)\n\t\t\t|| (all == 1 && !isterm)\n\t\t\t|| (all == 0 && !optval_default(p, varp, p_cp))))\n\t    {\n\t\tif (opt_flags & OPT_ONECOLUMN)\n\t\t    len = Columns;\n\t\telse if (p->flags & P_BOOL)\n\t\t    len = 1;\t\t// a toggle option fits always\n\t\telse\n\t\t{\n\t\t    option_value2string(p, opt_flags);\n\t\t    len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n\t\t}\n\t\tif ((len <= INC - GAP && run == 1) ||\n\t\t\t\t\t\t(len > INC - GAP && run == 2))\n\t\t    items[item_count++] = p;\n\t    }\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run == 1)\n\t{\n\t    cols = (Columns + GAP - 3) / INC;\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 2\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshowoneopt(items[i], opt_flags);\n\t\tcol += INC;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\n    static int\noptval_default(struct vimoption *p, char_u *varp, int compatible)\n{\n    int\t\tdvi;\n\n    if (varp == NULL)\n\treturn TRUE;\t    // hidden option is always at default\n    dvi = ((p->flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (p->flags & P_NUM)\n\treturn (*(long *)varp == (long)(long_i)p->def_val[dvi]);\n    if (p->flags & P_BOOL)\n\t\t\t// the cast to long is required for Manx C, long_i is\n\t\t\t// needed for MSVC\n\treturn (*(int *)varp == (int)(long)(long_i)p->def_val[dvi]);\n    // P_STRING\n    return (STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0);\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\n    static void\nshowoneopt(\n    struct vimoption\t*p,\n    int\t\t\topt_flags)\t// OPT_LOCAL or OPT_GLOBAL\n{\n    char_u\t*varp;\n    int\t\tsave_silent = silent_mode;\n\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\n    varp = get_varp_scope(p, opt_flags);\n\n    // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n    if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n\t\t\t\t\t? !curbufIsChanged() : !*(int *)varp))\n\tmsg_puts(\"no\");\n    else if ((p->flags & P_BOOL) && *(int *)varp < 0)\n\tmsg_puts(\"--\");\n    else\n\tmsg_puts(\"  \");\n    msg_puts(p->fullname);\n    if (!(p->flags & P_BOOL))\n    {\n\tmsg_putchar('=');\n\t// put value string in NameBuff\n\toption_value2string(p, opt_flags);\n\tmsg_outtrans(NameBuff);\n    }\n\n    silent_mode = save_silent;\n    info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakeset(FILE *fd, int opt_flags, int local_only)\n{\n    struct vimoption\t*p;\n    char_u\t\t*varp;\t\t\t// currently used value\n    char_u\t\t*varp_fresh;\t\t// local value\n    char_u\t\t*varp_local = NULL;\t// fresh value\n    char\t\t*cmd;\n    int\t\t\tround;\n    int\t\t\tpri;\n\n    /*\n     * The options that don't have a default (terminal name, columns, lines)\n     * are never written.  Terminal options are also not written.\n     * Do the loop over \"options[]\" twice: once for options with the\n     * P_PRI_MKRC flag and once without.\n     */\n    for (pri = 1; pri >= 0; --pri)\n    {\n      for (p = &options[0]; !istermoption(p); p++)\n\tif (!(p->flags & P_NO_MKRC)\n\t\t&& !istermoption(p)\n\t\t&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))\n\t{\n\t    // skip global option when only doing locals\n\t    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n\t\tcontinue;\n\n\t    // Do not store options like 'bufhidden' and 'syntax' in a vimrc\n\t    // file, they are always buffer-specific.\n\t    if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n\t\tcontinue;\n\n\t    // Global values are only written when not at the default value.\n\t    varp = get_varp_scope(p, opt_flags);\n\t    if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp, p_cp))\n\t\tcontinue;\n\n\t    if ((opt_flags & OPT_SKIPRTP) && (p->var == (char_u *)&p_rtp\n\t\t\t\t\t\t || p->var == (char_u *)&p_pp))\n\t\tcontinue;\n\n\t    round = 2;\n\t    if (p->indir != PV_NONE)\n\t    {\n\t\tif (p->var == VAR_WIN)\n\t\t{\n\t\t    // skip window-local option when only doing globals\n\t\t    if (!(opt_flags & OPT_LOCAL))\n\t\t\tcontinue;\n\t\t    // When fresh value of window-local option is not at the\n\t\t    // default, need to write it too.\n\t\t    if (!(opt_flags & OPT_GLOBAL) && !local_only)\n\t\t    {\n\t\t\tvarp_fresh = get_varp_scope(p, OPT_GLOBAL);\n\t\t\tif (!optval_default(p, varp_fresh, p_cp))\n\t\t\t{\n\t\t\t    round = 1;\n\t\t\t    varp_local = varp;\n\t\t\t    varp = varp_fresh;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Round 1: fresh value for window-local options.\n\t    // Round 2: other values\n\t    for ( ; round <= 2; varp = varp_local, ++round)\n\t    {\n\t\tif (round == 1 || (opt_flags & OPT_GLOBAL))\n\t\t    cmd = \"set\";\n\t\telse\n\t\t    cmd = \"setlocal\";\n\n\t\tif (p->flags & P_BOOL)\n\t\t{\n\t\t    if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse if (p->flags & P_NUM)\n\t\t{\n\t\t    if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse    // P_STRING\n\t\t{\n\t\t    int\t\tdo_endif = FALSE;\n\n\t\t    // Don't set 'syntax' and 'filetype' again if the value is\n\t\t    // already right, avoids reloading the syntax file.\n\t\t    if (\n#if defined(FEAT_SYN_HL)\n\t\t\t    p->indir == PV_SYN ||\n#endif\n\t\t\t    p->indir == PV_FT)\n\t\t    {\n\t\t\tif (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n\t\t\t\t\t\t       *(char_u **)(varp)) < 0\n\t\t\t\t|| put_eol(fd) < 0)\n\t\t\t    return FAIL;\n\t\t\tdo_endif = TRUE;\n\t\t    }\n\t\t    if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n\t\t\t\t\t\t\t     p->flags) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (do_endif)\n\t\t    {\n\t\t\tif (put_line(fd, \"endif\") == FAIL)\n\t\t\t    return FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\n    int\nmakefoldset(FILE *fd)\n{\n    if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, 0) == FAIL\n# ifdef FEAT_EVAL\n\t    || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n# endif\n\t    || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n\t    || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n\t    )\n\treturn FAIL;\n\n    return OK;\n}\n#endif\n\n    static int\nput_setstring(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    char_u\t**valuep,\n    long_u\tflags)\n{\n    char_u\t*s;\n    char_u\t*buf = NULL;\n    char_u\t*part = NULL;\n    char_u\t*p;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (*valuep != NULL)\n    {\n\t// Output 'pastetoggle' as key names.  For other\n\t// options some characters have to be escaped with\n\t// CTRL-V or backslash\n\tif (valuep == &p_pt)\n\t{\n\t    s = *valuep;\n\t    while (*s != NUL)\n\t\tif (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n\t\t    return FAIL;\n\t}\n\t// expand the option value, replace $HOME by ~\n\telse if ((flags & P_EXPAND) != 0)\n\t{\n\t    int  size = (int)STRLEN(*valuep) + 1;\n\n\t    // replace home directory in the whole option value into \"buf\"\n\t    buf = alloc(size);\n\t    if (buf == NULL)\n\t\tgoto fail;\n\t    home_replace(NULL, *valuep, buf, size, FALSE);\n\n\t    // If the option value is longer than MAXPATHL, we need to append\n\t    // each comma separated part of the option separately, so that it\n\t    // can be expanded when read back.\n\t    if (size >= MAXPATHL && (flags & P_COMMA) != 0\n\t\t\t\t\t   && vim_strchr(*valuep, ',') != NULL)\n\t    {\n\t\tpart = alloc(size);\n\t\tif (part == NULL)\n\t\t    goto fail;\n\n\t\t// write line break to clear the option, e.g. ':set rtp='\n\t\tif (put_eol(fd) == FAIL)\n\t\t    goto fail;\n\n\t\tp = buf;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    // for each comma separated option part, append value to\n\t\t    // the option, :set rtp+=value\n\t\t    if (fprintf(fd, \"%s %s+=\", cmd, name) < 0)\n\t\t\tgoto fail;\n\t\t    (void)copy_option_part(&p, part, size,  \",\");\n\t\t    if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL)\n\t\t\tgoto fail;\n\t\t}\n\t\tvim_free(buf);\n\t\tvim_free(part);\n\t\treturn OK;\n\t    }\n\t    if (put_escstr(fd, buf, 2) == FAIL)\n\t    {\n\t\tvim_free(buf);\n\t\treturn FAIL;\n\t    }\n\t    vim_free(buf);\n\t}\n\telse if (put_escstr(fd, *valuep, 2) == FAIL)\n\t    return FAIL;\n    }\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\nfail:\n    vim_free(buf);\n    vim_free(part);\n    return FAIL;\n}\n\n    static int\nput_setnum(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    long\t*valuep)\n{\n    long\twc;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (wc_use_keyname((char_u *)valuep, &wc))\n    {\n\t// print 'wildchar' and 'wildcharm' as a key name\n\tif (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n\t    return FAIL;\n    }\n    else if (fprintf(fd, \"%ld\", *valuep) < 0)\n\treturn FAIL;\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n    static int\nput_setbool(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    int\t\tvalue)\n{\n    if (value < 0)\t// global/local option using global value\n\treturn OK;\n    if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n\t    || put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Clear all the terminal options.\n * If the option has been allocated, free the memory.\n * Terminal options are never hidden or indirect.\n */\n    void\nclear_termoptions(void)\n{\n    /*\n     * Reset a few things before clearing the old options. This may cause\n     * outputting a few things that the terminal doesn't understand, but the\n     * screen will be cleared later, so this is OK.\n     */\n    mch_setmouse(FALSE);\t    // switch mouse off\n#ifdef FEAT_TITLE\n    mch_restore_title(SAVE_RESTORE_BOTH);    // restore window titles\n#endif\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_GUI)\n    // When starting the GUI close the display opened for the clipboard.\n    // After restoring the title, because that will need the display.\n    if (gui.starting)\n\tclear_xterm_clip();\n#endif\n    stoptermcap();\t\t\t// stop termcap mode\n\n    free_termoptions();\n}\n\n    void\nfree_termoptions(void)\n{\n    struct vimoption   *p;\n\n    for (p = options; p->fullname != NULL; p++)\n\tif (istermoption(p))\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    if (p->flags & P_DEF_ALLOCED)\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->def_val[VI_DEFAULT] = empty_option;\n\t    p->flags &= ~(P_ALLOCED|P_DEF_ALLOCED);\n#ifdef FEAT_EVAL\n\t    // remember where the option was cleared\n\t    set_option_sctx_idx((int)(p - options), OPT_GLOBAL, current_sctx);\n#endif\n\t}\n    clear_termcodes();\n}\n\n/*\n * Free the string for one term option, if it was allocated.\n * Set the string to empty_option and clear allocated flag.\n * \"var\" points to the option value.\n */\n    void\nfree_one_termoption(char_u *var)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n\tif (p->var == var)\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->flags &= ~P_ALLOCED;\n\t    break;\n\t}\n}\n\n/*\n * Set the terminal option defaults to the current value.\n * Used after setting the terminal name.\n */\n    void\nset_term_defaults(void)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n    {\n\tif (istermoption(p) && p->def_val[VI_DEFAULT] != *(char_u **)(p->var))\n\t{\n\t    if (p->flags & P_DEF_ALLOCED)\n\t    {\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t\tp->flags &= ~P_DEF_ALLOCED;\n\t    }\n\t    p->def_val[VI_DEFAULT] = *(char_u **)(p->var);\n\t    if (p->flags & P_ALLOCED)\n\t    {\n\t\tp->flags |= P_DEF_ALLOCED;\n\t\tp->flags &= ~P_ALLOCED;\t // don't free the value now\n\t    }\n\t}\n    }\n}\n\n/*\n * return TRUE if 'p' starts with 't_'\n */\n    static int\nistermoption(struct vimoption *p)\n{\n    return (p->fullname[0] == 't' && p->fullname[1] == '_');\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' starts with 't_'\n */\n    int\nistermoption_idx(int opt_idx)\n{\n    return istermoption(&options[opt_idx]);\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Unset local option value, similar to \":set opt<\".\n */\n    void\nunset_global_local_option(char_u *name, void *from)\n{\n    struct vimoption *p;\n    int\t\topt_idx;\n    buf_T\t*buf = (buf_T *)from;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn;\n    p = &(options[opt_idx]);\n\n    switch ((int)p->indir)\n    {\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\n\t    clear_string_option(&buf->b_p_ep);\n\t    break;\n\tcase PV_KP:\n\t    clear_string_option(&buf->b_p_kp);\n\t    break;\n\tcase PV_PATH:\n\t    clear_string_option(&buf->b_p_path);\n\t    break;\n\tcase PV_AR:\n\t    buf->b_p_ar = -1;\n\t    break;\n\tcase PV_BKC:\n\t    clear_string_option(&buf->b_p_bkc);\n\t    buf->b_bkc_flags = 0;\n\t    break;\n\tcase PV_TAGS:\n\t    clear_string_option(&buf->b_p_tags);\n\t    break;\n\tcase PV_TC:\n\t    clear_string_option(&buf->b_p_tc);\n\t    buf->b_tc_flags = 0;\n\t    break;\n        case PV_SISO:\n            curwin->w_p_siso = -1;\n            break;\n        case PV_SO:\n            curwin->w_p_so = -1;\n            break;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\n\t    clear_string_option(&buf->b_p_def);\n\t    break;\n\tcase PV_INC:\n\t    clear_string_option(&buf->b_p_inc);\n\t    break;\n#endif\n\tcase PV_DICT:\n\t    clear_string_option(&buf->b_p_dict);\n\t    break;\n\tcase PV_TSR:\n\t    clear_string_option(&buf->b_p_tsr);\n\t    break;\n\tcase PV_FP:\n\t    clear_string_option(&buf->b_p_fp);\n\t    break;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\n\t    clear_string_option(&buf->b_p_efm);\n\t    break;\n\tcase PV_GP:\n\t    clear_string_option(&buf->b_p_gp);\n\t    break;\n\tcase PV_MP:\n\t    clear_string_option(&buf->b_p_mp);\n\t    break;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\n\t    clear_string_option(&buf->b_p_bexpr);\n\t    break;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\n\t    clear_string_option(&buf->b_p_cm);\n\t    break;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\n\t    clear_string_option(&((win_T *)from)->w_p_sbr);\n\t    break;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\n\t    clear_string_option(&((win_T *)from)->w_p_stl);\n\t    break;\n#endif\n\tcase PV_UL:\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    break;\n#ifdef FEAT_LISP\n\tcase PV_LW:\n\t    clear_string_option(&buf->b_p_lw);\n\t    break;\n#endif\n\tcase PV_MENC:\n\t    clear_string_option(&buf->b_p_menc);\n\t    break;\n\tcase PV_LCS:\n\t    clear_string_option(&((win_T *)from)->w_p_lcs);\n\t    set_chars_option((win_T *)from, &((win_T *)from)->w_p_lcs);\n\t    redraw_later(NOT_VALID);\n\t    break;\n\tcase PV_VE:\n\t    clear_string_option(&((win_T *)from)->w_p_ve);\n\t    ((win_T *)from)->w_ve_flags = 0;\n\t    break;\n    }\n}\n#endif\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n */\n    static char_u *\nget_varp_scope(struct vimoption *p, int opt_flags)\n{\n    if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE)\n    {\n\tif (p->var == VAR_WIN)\n\t    return (char_u *)GLOBAL_WO(get_varp(p));\n\treturn p->var;\n    }\n    if ((opt_flags & OPT_LOCAL) && ((int)p->indir & PV_BOTH))\n    {\n\tswitch ((int)p->indir)\n\t{\n\t    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);\n#ifdef FEAT_QUICKFIX\n\t    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n\t    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n\t    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n#endif\n\t    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n\t    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n\t    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n\t    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n\t    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n\t    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n            case PV_SISO: return (char_u *)&(curwin->w_p_siso);\n            case PV_SO:   return (char_u *)&(curwin->w_p_so);\n#ifdef FEAT_FIND_ID\n\t    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n\t    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n#endif\n\t    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n\t    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    case PV_BEXPR: return (char_u *)&(curbuf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n\t    case PV_CM:\t  return (char_u *)&(curbuf->b_p_cm);\n#endif\n#ifdef FEAT_LINEBREAK\n\t    case PV_SBR:  return (char_u *)&(curwin->w_p_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n#endif\n\t    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n#ifdef FEAT_LISP\n\t    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n#endif\n\t    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n\t    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);\n\t    case PV_LCS:  return (char_u *)&(curwin->w_p_lcs);\n\t    case PV_VE:\t  return (char_u *)&(curwin->w_p_ve);\n\n\t}\n\treturn NULL; // \"cannot happen\"\n    }\n    return get_varp(p);\n}\n\n/*\n * Get pointer to option variable at 'opt_idx', depending on local or global\n * scope.\n */\n    char_u *\nget_option_varp_scope(int opt_idx, int opt_flags)\n{\n    return get_varp_scope(&(options[opt_idx]), opt_flags);\n}\n\n/*\n * Get pointer to option variable.\n */\n    static char_u *\nget_varp(struct vimoption *p)\n{\n    // hidden option, always return NULL\n    if (p->var == NULL)\n\treturn NULL;\n\n    switch ((int)p->indir)\n    {\n\tcase PV_NONE:\treturn p->var;\n\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\treturn *curbuf->b_p_ep != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_ep : p->var;\n\tcase PV_KP:\treturn *curbuf->b_p_kp != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_kp : p->var;\n\tcase PV_PATH:\treturn *curbuf->b_p_path != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_path) : p->var;\n\tcase PV_AR:\treturn curbuf->b_p_ar >= 0\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ar) : p->var;\n\tcase PV_TAGS:\treturn *curbuf->b_p_tags != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tags) : p->var;\n\tcase PV_TC:\treturn *curbuf->b_p_tc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tc) : p->var;\n\tcase PV_BKC:\treturn *curbuf->b_p_bkc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n\tcase PV_SISO:\treturn curwin->w_p_siso >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_siso) : p->var;\n\tcase PV_SO:\treturn curwin->w_p_so >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_so) : p->var;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\treturn *curbuf->b_p_def != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_def) : p->var;\n\tcase PV_INC:\treturn *curbuf->b_p_inc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_inc) : p->var;\n#endif\n\tcase PV_DICT:\treturn *curbuf->b_p_dict != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_dict) : p->var;\n\tcase PV_TSR:\treturn *curbuf->b_p_tsr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n\tcase PV_FP:\treturn *curbuf->b_p_fp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_fp) : p->var;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\treturn *curbuf->b_p_efm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_efm) : p->var;\n\tcase PV_GP:\treturn *curbuf->b_p_gp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_gp) : p->var;\n\tcase PV_MP:\treturn *curbuf->b_p_mp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_mp) : p->var;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\treturn *curbuf->b_p_bexpr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bexpr) : p->var;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\treturn *curbuf->b_p_cm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_cm) : p->var;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\treturn *curwin->w_p_sbr != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_sbr) : p->var;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\treturn *curwin->w_p_stl != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_stl) : p->var;\n#endif\n\tcase PV_UL:\treturn curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ul) : p->var;\n#ifdef FEAT_LISP\n\tcase PV_LW:\treturn *curbuf->b_p_lw != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_lw) : p->var;\n#endif\n\tcase PV_MENC:\treturn *curbuf->b_p_menc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_menc) : p->var;\n#ifdef FEAT_ARABIC\n\tcase PV_ARAB:\treturn (char_u *)&(curwin->w_p_arab);\n#endif\n\tcase PV_LIST:\treturn (char_u *)&(curwin->w_p_list);\n\tcase PV_LCS:\treturn *curwin->w_p_lcs != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_lcs) : p->var;\n\tcase PV_VE:\treturn *curwin->w_p_ve != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_ve) : p->var;\n#ifdef FEAT_SPELL\n\tcase PV_SPELL:\treturn (char_u *)&(curwin->w_p_spell);\n#endif\n#ifdef FEAT_SYN_HL\n\tcase PV_CUC:\treturn (char_u *)&(curwin->w_p_cuc);\n\tcase PV_CUL:\treturn (char_u *)&(curwin->w_p_cul);\n\tcase PV_CULOPT:\treturn (char_u *)&(curwin->w_p_culopt);\n\tcase PV_CC:\treturn (char_u *)&(curwin->w_p_cc);\n#endif\n#ifdef FEAT_DIFF\n\tcase PV_DIFF:\treturn (char_u *)&(curwin->w_p_diff);\n#endif\n#ifdef FEAT_FOLDING\n\tcase PV_FDC:\treturn (char_u *)&(curwin->w_p_fdc);\n\tcase PV_FEN:\treturn (char_u *)&(curwin->w_p_fen);\n\tcase PV_FDI:\treturn (char_u *)&(curwin->w_p_fdi);\n\tcase PV_FDL:\treturn (char_u *)&(curwin->w_p_fdl);\n\tcase PV_FDM:\treturn (char_u *)&(curwin->w_p_fdm);\n\tcase PV_FML:\treturn (char_u *)&(curwin->w_p_fml);\n\tcase PV_FDN:\treturn (char_u *)&(curwin->w_p_fdn);\n# ifdef FEAT_EVAL\n\tcase PV_FDE:\treturn (char_u *)&(curwin->w_p_fde);\n\tcase PV_FDT:\treturn (char_u *)&(curwin->w_p_fdt);\n# endif\n\tcase PV_FMR:\treturn (char_u *)&(curwin->w_p_fmr);\n#endif\n\tcase PV_NU:\treturn (char_u *)&(curwin->w_p_nu);\n\tcase PV_RNU:\treturn (char_u *)&(curwin->w_p_rnu);\n#ifdef FEAT_LINEBREAK\n\tcase PV_NUW:\treturn (char_u *)&(curwin->w_p_nuw);\n#endif\n\tcase PV_WFH:\treturn (char_u *)&(curwin->w_p_wfh);\n\tcase PV_WFW:\treturn (char_u *)&(curwin->w_p_wfw);\n#if defined(FEAT_QUICKFIX)\n\tcase PV_PVW:\treturn (char_u *)&(curwin->w_p_pvw);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tcase PV_RL:\treturn (char_u *)&(curwin->w_p_rl);\n\tcase PV_RLC:\treturn (char_u *)&(curwin->w_p_rlc);\n#endif\n\tcase PV_SCROLL:\treturn (char_u *)&(curwin->w_p_scr);\n\tcase PV_WRAP:\treturn (char_u *)&(curwin->w_p_wrap);\n#ifdef FEAT_LINEBREAK\n\tcase PV_LBR:\treturn (char_u *)&(curwin->w_p_lbr);\n\tcase PV_BRI:\treturn (char_u *)&(curwin->w_p_bri);\n\tcase PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n#endif\n\tcase PV_WCR:\treturn (char_u *)&(curwin->w_p_wcr);\n\tcase PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n\tcase PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n#ifdef FEAT_CONCEAL\n\tcase PV_COCU:   return (char_u *)&(curwin->w_p_cocu);\n\tcase PV_COLE:   return (char_u *)&(curwin->w_p_cole);\n#endif\n#ifdef FEAT_TERMINAL\n\tcase PV_TWK:    return (char_u *)&(curwin->w_p_twk);\n\tcase PV_TWS:    return (char_u *)&(curwin->w_p_tws);\n\tcase PV_TWSL:\treturn (char_u *)&(curbuf->b_p_twsl);\n#endif\n\n\tcase PV_AI:\treturn (char_u *)&(curbuf->b_p_ai);\n\tcase PV_BIN:\treturn (char_u *)&(curbuf->b_p_bin);\n\tcase PV_BOMB:\treturn (char_u *)&(curbuf->b_p_bomb);\n\tcase PV_BH:\treturn (char_u *)&(curbuf->b_p_bh);\n\tcase PV_BT:\treturn (char_u *)&(curbuf->b_p_bt);\n\tcase PV_BL:\treturn (char_u *)&(curbuf->b_p_bl);\n\tcase PV_CI:\treturn (char_u *)&(curbuf->b_p_ci);\n#ifdef FEAT_CINDENT\n\tcase PV_CIN:\treturn (char_u *)&(curbuf->b_p_cin);\n\tcase PV_CINK:\treturn (char_u *)&(curbuf->b_p_cink);\n\tcase PV_CINO:\treturn (char_u *)&(curbuf->b_p_cino);\n#endif\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\tcase PV_CINW:\treturn (char_u *)&(curbuf->b_p_cinw);\n#endif\n\tcase PV_COM:\treturn (char_u *)&(curbuf->b_p_com);\n#ifdef FEAT_FOLDING\n\tcase PV_CMS:\treturn (char_u *)&(curbuf->b_p_cms);\n#endif\n\tcase PV_CPT:\treturn (char_u *)&(curbuf->b_p_cpt);\n#ifdef BACKSLASH_IN_FILENAME\n\tcase PV_CSL:\treturn (char_u *)&(curbuf->b_p_csl);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_CFU:\treturn (char_u *)&(curbuf->b_p_cfu);\n\tcase PV_OFU:\treturn (char_u *)&(curbuf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_TFU:\treturn (char_u *)&(curbuf->b_p_tfu);\n#endif\n\tcase PV_EOL:\treturn (char_u *)&(curbuf->b_p_eol);\n\tcase PV_FIXEOL:\treturn (char_u *)&(curbuf->b_p_fixeol);\n\tcase PV_ET:\treturn (char_u *)&(curbuf->b_p_et);\n\tcase PV_FENC:\treturn (char_u *)&(curbuf->b_p_fenc);\n\tcase PV_FF:\treturn (char_u *)&(curbuf->b_p_ff);\n\tcase PV_FT:\treturn (char_u *)&(curbuf->b_p_ft);\n\tcase PV_FO:\treturn (char_u *)&(curbuf->b_p_fo);\n\tcase PV_FLP:\treturn (char_u *)&(curbuf->b_p_flp);\n\tcase PV_IMI:\treturn (char_u *)&(curbuf->b_p_iminsert);\n\tcase PV_IMS:\treturn (char_u *)&(curbuf->b_p_imsearch);\n\tcase PV_INF:\treturn (char_u *)&(curbuf->b_p_inf);\n\tcase PV_ISK:\treturn (char_u *)&(curbuf->b_p_isk);\n#ifdef FEAT_FIND_ID\n# ifdef FEAT_EVAL\n\tcase PV_INEX:\treturn (char_u *)&(curbuf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\tcase PV_INDE:\treturn (char_u *)&(curbuf->b_p_inde);\n\tcase PV_INDK:\treturn (char_u *)&(curbuf->b_p_indk);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_FEX:\treturn (char_u *)&(curbuf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n\tcase PV_KEY:\treturn (char_u *)&(curbuf->b_p_key);\n#endif\n#ifdef FEAT_LISP\n\tcase PV_LISP:\treturn (char_u *)&(curbuf->b_p_lisp);\n#endif\n\tcase PV_ML:\treturn (char_u *)&(curbuf->b_p_ml);\n\tcase PV_MPS:\treturn (char_u *)&(curbuf->b_p_mps);\n\tcase PV_MA:\treturn (char_u *)&(curbuf->b_p_ma);\n\tcase PV_MOD:\treturn (char_u *)&(curbuf->b_changed);\n\tcase PV_NF:\treturn (char_u *)&(curbuf->b_p_nf);\n\tcase PV_PI:\treturn (char_u *)&(curbuf->b_p_pi);\n#ifdef FEAT_TEXTOBJ\n\tcase PV_QE:\treturn (char_u *)&(curbuf->b_p_qe);\n#endif\n\tcase PV_RO:\treturn (char_u *)&(curbuf->b_p_ro);\n#ifdef FEAT_SMARTINDENT\n\tcase PV_SI:\treturn (char_u *)&(curbuf->b_p_si);\n#endif\n\tcase PV_SN:\treturn (char_u *)&(curbuf->b_p_sn);\n\tcase PV_STS:\treturn (char_u *)&(curbuf->b_p_sts);\n#ifdef FEAT_SEARCHPATH\n\tcase PV_SUA:\treturn (char_u *)&(curbuf->b_p_sua);\n#endif\n\tcase PV_SWF:\treturn (char_u *)&(curbuf->b_p_swf);\n#ifdef FEAT_SYN_HL\n\tcase PV_SMC:\treturn (char_u *)&(curbuf->b_p_smc);\n\tcase PV_SYN:\treturn (char_u *)&(curbuf->b_p_syn);\n#endif\n#ifdef FEAT_SPELL\n\tcase PV_SPC:\treturn (char_u *)&(curwin->w_s->b_p_spc);\n\tcase PV_SPF:\treturn (char_u *)&(curwin->w_s->b_p_spf);\n\tcase PV_SPL:\treturn (char_u *)&(curwin->w_s->b_p_spl);\n\tcase PV_SPO:\treturn (char_u *)&(curwin->w_s->b_p_spo);\n#endif\n\tcase PV_SW:\treturn (char_u *)&(curbuf->b_p_sw);\n\tcase PV_TS:\treturn (char_u *)&(curbuf->b_p_ts);\n\tcase PV_TW:\treturn (char_u *)&(curbuf->b_p_tw);\n\tcase PV_TX:\treturn (char_u *)&(curbuf->b_p_tx);\n#ifdef FEAT_PERSISTENT_UNDO\n\tcase PV_UDF:\treturn (char_u *)&(curbuf->b_p_udf);\n#endif\n\tcase PV_WM:\treturn (char_u *)&(curbuf->b_p_wm);\n#ifdef FEAT_KEYMAP\n\tcase PV_KMAP:\treturn (char_u *)&(curbuf->b_p_keymap);\n#endif\n#ifdef FEAT_SIGNS\n\tcase PV_SCL:\treturn (char_u *)&(curwin->w_p_scl);\n#endif\n#ifdef FEAT_VARTABS\n\tcase PV_VSTS:\treturn (char_u *)&(curbuf->b_p_vsts);\n\tcase PV_VTS:\treturn (char_u *)&(curbuf->b_p_vts);\n#endif\n\tdefault:\tiemsg(_(\"E356: get_varp ERROR\"));\n    }\n    // always return a valid pointer to avoid a crash!\n    return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Return a pointer to the variable for option at 'opt_idx'\n */\n    char_u *\nget_option_var(int opt_idx)\n{\n    return options[opt_idx].var;\n}\n\n/*\n * Return the full name of the option at 'opt_idx'\n */\n    char_u *\nget_option_fullname(int opt_idx)\n{\n    return (char_u *)options[opt_idx].fullname;\n}\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\n    char_u *\nget_equalprg(void)\n{\n    if (*curbuf->b_p_ep == NUL)\n\treturn p_ep;\n    return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\n    void\nwin_copy_options(win_T *wp_from, win_T *wp_to)\n{\n    copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n    copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n    after_copy_winopt(wp_to);\n}\n\n/*\n * After copying window options: update variables depending on options.\n */\n    void\nafter_copy_winopt(win_T *wp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    briopt_check(wp);\n#endif\n#ifdef FEAT_SYN_HL\n    fill_culopt_flags(NULL, wp);\n    check_colorcolumn(wp);\n#endif\n    set_chars_option(wp, &wp->w_p_lcs);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\n    void\ncopy_winopt(winopt_T *from, winopt_T *to)\n{\n#ifdef FEAT_ARABIC\n    to->wo_arab = from->wo_arab;\n#endif\n    to->wo_list = from->wo_list;\n    to->wo_lcs = vim_strsave(from->wo_lcs);\n    to->wo_nu = from->wo_nu;\n    to->wo_rnu = from->wo_rnu;\n    to->wo_ve = vim_strsave(from->wo_ve);\n    to->wo_ve_flags = from->wo_ve_flags;\n#ifdef FEAT_LINEBREAK\n    to->wo_nuw = from->wo_nuw;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    to->wo_rl  = from->wo_rl;\n    to->wo_rlc = vim_strsave(from->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_sbr = vim_strsave(from->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    to->wo_stl = vim_strsave(from->wo_stl);\n#endif\n    to->wo_wrap = from->wo_wrap;\n#ifdef FEAT_DIFF\n    to->wo_wrap_save = from->wo_wrap_save;\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_lbr = from->wo_lbr;\n    to->wo_bri = from->wo_bri;\n    to->wo_briopt = vim_strsave(from->wo_briopt);\n#endif\n    to->wo_wcr = vim_strsave(from->wo_wcr);\n    to->wo_scb = from->wo_scb;\n    to->wo_scb_save = from->wo_scb_save;\n    to->wo_crb = from->wo_crb;\n    to->wo_crb_save = from->wo_crb_save;\n#ifdef FEAT_SPELL\n    to->wo_spell = from->wo_spell;\n#endif\n#ifdef FEAT_SYN_HL\n    to->wo_cuc = from->wo_cuc;\n    to->wo_cul = from->wo_cul;\n    to->wo_culopt = vim_strsave(from->wo_culopt);\n    to->wo_cc = vim_strsave(from->wo_cc);\n#endif\n#ifdef FEAT_DIFF\n    to->wo_diff = from->wo_diff;\n    to->wo_diff_saved = from->wo_diff_saved;\n#endif\n#ifdef FEAT_CONCEAL\n    to->wo_cocu = vim_strsave(from->wo_cocu);\n    to->wo_cole = from->wo_cole;\n#endif\n#ifdef FEAT_TERMINAL\n    to->wo_twk = vim_strsave(from->wo_twk);\n    to->wo_tws = vim_strsave(from->wo_tws);\n#endif\n#ifdef FEAT_FOLDING\n    to->wo_fdc = from->wo_fdc;\n    to->wo_fdc_save = from->wo_fdc_save;\n    to->wo_fen = from->wo_fen;\n    to->wo_fen_save = from->wo_fen_save;\n    to->wo_fdi = vim_strsave(from->wo_fdi);\n    to->wo_fml = from->wo_fml;\n    to->wo_fdl = from->wo_fdl;\n    to->wo_fdl_save = from->wo_fdl_save;\n    to->wo_fdm = vim_strsave(from->wo_fdm);\n    to->wo_fdm_save = from->wo_diff_saved\n\t\t\t      ? vim_strsave(from->wo_fdm_save) : empty_option;\n    to->wo_fdn = from->wo_fdn;\n# ifdef FEAT_EVAL\n    to->wo_fde = vim_strsave(from->wo_fde);\n    to->wo_fdt = vim_strsave(from->wo_fdt);\n# endif\n    to->wo_fmr = vim_strsave(from->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    to->wo_scl = vim_strsave(from->wo_scl);\n#endif\n\n#ifdef FEAT_EVAL\n    // Copy the script context so that we know where the value was last set.\n    mch_memmove(to->wo_script_ctx, from->wo_script_ctx,\n\t\t\t\t\t\t    sizeof(to->wo_script_ctx));\n#endif\n    check_winopt(to);\t\t// don't want NULL pointers\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\n    static void\ncheck_win_options(win_T *win)\n{\n    check_winopt(&win->w_onebuf_opt);\n    check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\n    static void\ncheck_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    check_string_option(&wop->wo_fdi);\n    check_string_option(&wop->wo_fdm);\n    check_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    check_string_option(&wop->wo_fde);\n    check_string_option(&wop->wo_fdt);\n# endif\n    check_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    check_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_RIGHTLEFT\n    check_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    check_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&wop->wo_culopt);\n    check_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    check_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    check_string_option(&wop->wo_twk);\n    check_string_option(&wop->wo_tws);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_briopt);\n#endif\n    check_string_option(&wop->wo_wcr);\n    check_string_option(&wop->wo_lcs);\n    check_string_option(&wop->wo_ve);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\n    void\nclear_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    clear_string_option(&wop->wo_fdi);\n    clear_string_option(&wop->wo_fdm);\n    clear_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    clear_string_option(&wop->wo_fde);\n    clear_string_option(&wop->wo_fdt);\n# endif\n    clear_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    clear_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_briopt);\n#endif\n    clear_string_option(&wop->wo_wcr);\n#ifdef FEAT_RIGHTLEFT\n    clear_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    clear_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    clear_string_option(&wop->wo_culopt);\n    clear_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    clear_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    clear_string_option(&wop->wo_twk);\n    clear_string_option(&wop->wo_tws);\n#endif\n    clear_string_option(&wop->wo_lcs);\n    clear_string_option(&wop->wo_ve);\n}\n\n#ifdef FEAT_EVAL\n// Index into the options table for a buffer-local option enum.\nstatic int buf_opt_idx[BV_COUNT];\n# define COPY_OPT_SCTX(buf, bv) buf->b_p_script_ctx[bv] = options[buf_opt_idx[bv]].script_ctx\n\n/*\n * Initialize buf_opt_idx[] if not done already.\n */\n    static void\ninit_buf_opt_idx(void)\n{\n    static int did_init_buf_opt_idx = FALSE;\n    int i;\n\n    if (did_init_buf_opt_idx)\n\treturn;\n    did_init_buf_opt_idx = TRUE;\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (options[i].indir & PV_BUF)\n\t    buf_opt_idx[options[i].indir & PV_MASK] = i;\n}\n#else\n# define COPY_OPT_SCTX(buf, bv)\n#endif\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buffer \"buf\".\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\n    void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_INF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\ttabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\n    void\nreset_modifiable(void)\n{\n    int\t\topt_idx;\n\n    curbuf->b_p_ma = FALSE;\n    p_ma = FALSE;\n    opt_idx = findoption((char_u *)\"ma\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\n    void\nset_iminsert_global(void)\n{\n    p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\n    void\nset_imsearch_global(void)\n{\n    p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\n    void\nset_context_in_set_cmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    int\t\tnextchar;\n    long_u\tflags = 0;\t// init for GCC\n    int\t\topt_idx = 0;\t// init for GCC\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tis_term_option = FALSE;\n    int\t\tkey;\n\n    expand_option_flags = opt_flags;\n\n    xp->xp_context = EXPAND_SETTINGS;\n    if (*arg == NUL)\n    {\n\txp->xp_pattern = arg;\n\treturn;\n    }\n    p = arg + STRLEN(arg) - 1;\n    if (*p == ' ' && *(p - 1) != '\\\\')\n    {\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    while (p > arg)\n    {\n\ts = p;\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    while (s > arg && *(s - 1) == '\\\\')\n\t\t--s;\n\t}\n\t// break at a space with an even number of backslashes\n\tif (*p == ' ' && ((p - s) & 1) == 0)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\t--p;\n    }\n    if (STRNCMP(p, \"no\", 2) == 0 && STRNCMP(p, \"novice\", 6) != 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 2;\n    }\n    if (STRNCMP(p, \"inv\", 3) == 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 3;\n    }\n    xp->xp_pattern = arg = p;\n    if (*arg == '<')\n    {\n\twhile (*p != '>')\n\t    if (*p++ == NUL)\t    // expand terminal option name\n\t\treturn;\n\tkey = get_special_key_code(arg + 1);\n\tif (key == 0)\t\t    // unknown name\n\t{\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    return;\n\t}\n\tnextchar = *++p;\n\tis_term_option = TRUE;\n\texpand_option_name[2] = KEY2TERMCAP0(key);\n\texpand_option_name[3] = KEY2TERMCAP1(key);\n    }\n    else\n    {\n\tif (p[0] == 't' && p[1] == '_')\n\t{\n\t    p += 2;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == NUL)\n\t\treturn;\t\t// expand option name\n\t    nextchar = *++p;\n\t    is_term_option = TRUE;\n\t    expand_option_name[2] = p[-2];\n\t    expand_option_name[3] = p[-1];\n\t}\n\telse\n\t{\n\t    // Allow * wildcard\n\t    while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n\t\tp++;\n\t    if (*p == NUL)\n\t\treturn;\n\t    nextchar = *p;\n\t    *p = NUL;\n\t    opt_idx = findoption(arg);\n\t    *p = nextchar;\n\t    if (opt_idx == -1 || options[opt_idx].var == NULL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t    flags = options[opt_idx].flags;\n\t    if (flags & P_BOOL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t}\n    }\n    // handle \"-=\" and \"+=\"\n    if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=')\n    {\n\t++p;\n\tnextchar = '=';\n    }\n    if ((nextchar != '=' && nextchar != ':')\n\t\t\t\t    || xp->xp_context == EXPAND_BOOL_SETTINGS)\n    {\n\txp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn;\n    }\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)\n    {\n\txp->xp_context = EXPAND_OLD_SETTING;\n\tif (is_term_option)\n\t    expand_option_idx = -1;\n\telse\n\t    expand_option_idx = opt_idx;\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    xp->xp_context = EXPAND_NOTHING;\n    if (is_term_option || (flags & P_NUM))\n\treturn;\n\n    xp->xp_pattern = p + 1;\n\n    if (flags & P_EXPAND)\n    {\n\tp = options[opt_idx].var;\n\tif (p == (char_u *)&p_bdir\n\t\t|| p == (char_u *)&p_dir\n\t\t|| p == (char_u *)&p_path\n\t\t|| p == (char_u *)&p_pp\n\t\t|| p == (char_u *)&p_rtp\n#ifdef FEAT_SEARCHPATH\n\t\t|| p == (char_u *)&p_cdpath\n#endif\n#ifdef FEAT_SESSION\n\t\t|| p == (char_u *)&p_vdir\n#endif\n\t\t)\n\t{\n\t    xp->xp_context = EXPAND_DIRECTORIES;\n\t    if (p == (char_u *)&p_path\n#ifdef FEAT_SEARCHPATH\n\t\t    || p == (char_u *)&p_cdpath\n#endif\n\t\t   )\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n\telse if (p == (char_u *)&p_ft)\n\t{\n\t    xp->xp_context = EXPAND_FILETYPE;\n\t}\n\telse\n\t{\n\t    xp->xp_context = EXPAND_FILES;\n\t    // for 'tags' need three backslashes for a space\n\t    if (p == (char_u *)&p_tags)\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n    }\n\n    // For an option that is a list of file names, find the start of the\n    // last file name.\n    for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p)\n    {\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    s = p;\n\t    while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n\t\t--s;\n\t    if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n\t\t    || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0))\n\t    {\n\t\txp->xp_pattern = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n#ifdef FEAT_SPELL\n\t// for 'spellsuggest' start at \"file:\"\n\tif (options[opt_idx].var == (char_u *)&p_sps\n\t\t\t\t\t       && STRNCMP(p, \"file:\", 5) == 0)\n\t{\n\t    xp->xp_pattern = p + 5;\n\t    break;\n\t}\n#endif\n    }\n\n    return;\n}\n\n    int\nExpandSettings(\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\tnum_normal = 0;\t    // Nr of matching non-term-code settings\n    int\t\tnum_term = 0;\t    // Nr of matching terminal code settings\n    int\t\topt_idx;\n    int\t\tmatch;\n    int\t\tcount = 0;\n    char_u\t*str;\n    int\t\tloop;\n    int\t\tis_term_opt;\n    char_u\tname_buf[MAX_KEY_NAME_LEN];\n    static char *(names[]) = {\"all\", \"termcap\"};\n    int\t\tic = regmatch->rm_ic;\t// remember the ignore-case flag\n\n    // do this loop twice:\n    // loop == 0: count the number of matching options\n    // loop == 1: copy the matching options into allocated memory\n    for (loop = 0; loop <= 1; ++loop)\n    {\n\tregmatch->rm_ic = ic;\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS)\n\t{\n\t    for (match = 0; match < (int)ARRAY_LENGTH(names); ++match)\n\t\tif (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_normal++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave((char_u *)names[match]);\n\t\t}\n\t}\n\tfor (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n\t\t\t\t\t\t\t\t    opt_idx++)\n\t{\n\t    if (options[opt_idx].var == NULL)\n\t\tcontinue;\n\t    if (xp->xp_context == EXPAND_BOOL_SETTINGS\n\t      && !(options[opt_idx].flags & P_BOOL))\n\t\tcontinue;\n\t    is_term_opt = istermoption_idx(opt_idx);\n\t    if (is_term_opt && num_normal > 0)\n\t\tcontinue;\n\t    match = FALSE;\n\t    if (vim_regexec(regmatch, str, (colnr_T)0)\n\t\t    || (options[opt_idx].shortname != NULL\n\t\t\t&& vim_regexec(regmatch,\n\t\t\t   (char_u *)options[opt_idx].shortname, (colnr_T)0)))\n\t\tmatch = TRUE;\n\t    else if (is_term_opt)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tname_buf[1] = 't';\n\t\tname_buf[2] = '_';\n\t\tname_buf[3] = str[2];\n\t\tname_buf[4] = str[3];\n\t\tname_buf[5] = '>';\n\t\tname_buf[6] = NUL;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    match = TRUE;\n\t\t    str = name_buf;\n\t\t}\n\t    }\n\t    if (match)\n\t    {\n\t\tif (loop == 0)\n\t\t{\n\t\t    if (is_term_opt)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\tnum_normal++;\n\t\t}\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(str);\n\t    }\n\t}\n\t/*\n\t * Check terminal key codes, these are not in the option table\n\t */\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS  && num_normal == 0)\n\t{\n\t    for (opt_idx = 0; (str = get_termcode(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tif (!isprint(str[0]) || !isprint(str[1]))\n\t\t    continue;\n\n\t\tname_buf[0] = 't';\n\t\tname_buf[1] = '_';\n\t\tname_buf[2] = str[0];\n\t\tname_buf[3] = str[1];\n\t\tname_buf[4] = NUL;\n\n\t\tmatch = FALSE;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t    match = TRUE;\n\t\telse\n\t\t{\n\t\t    name_buf[0] = '<';\n\t\t    name_buf[1] = 't';\n\t\t    name_buf[2] = '_';\n\t\t    name_buf[3] = str[0];\n\t\t    name_buf[4] = str[1];\n\t\t    name_buf[5] = '>';\n\t\t    name_buf[6] = NUL;\n\n\t\t    if (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match)\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check special key names.\n\t     */\n\t    regmatch->rm_ic = TRUE;\t\t// ignore case here\n\t    for (opt_idx = 0; (str = get_key_name(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tSTRCPY(name_buf + 1, str);\n\t\tSTRCAT(name_buf, \">\");\n\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\t}\n\tif (loop == 0)\n\t{\n\t    if (num_normal > 0)\n\t\t*num_file = num_normal;\n\t    else if (num_term > 0)\n\t\t*num_file = num_term;\n\t    else\n\t\treturn OK;\n\t    *file = ALLOC_MULT(char_u *, *num_file);\n\t    if (*file == NULL)\n\t    {\n\t\t*file = (char_u **)\"\";\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    return OK;\n}\n\n    int\nExpandOldSetting(int *num_file, char_u ***file)\n{\n    char_u  *var = NULL;\t// init for GCC\n    char_u  *buf;\n\n    *num_file = 0;\n    *file = ALLOC_ONE(char_u *);\n    if (*file == NULL)\n\treturn FAIL;\n\n    /*\n     * For a terminal key code expand_option_idx is < 0.\n     */\n    if (expand_option_idx < 0)\n    {\n\tvar = find_termcode(expand_option_name + 2);\n\tif (var == NULL)\n\t    expand_option_idx = findoption(expand_option_name);\n    }\n\n    if (expand_option_idx >= 0)\n    {\n\t// put string of option value in NameBuff\n\toption_value2string(&options[expand_option_idx], expand_option_flags);\n\tvar = NameBuff;\n    }\n    else if (var == NULL)\n\tvar = (char_u *)\"\";\n\n    // A backslash is required before some characters.  This is the reverse of\n    // what happens in do_set().\n    buf = vim_strsave_escaped(var, escape_chars);\n\n    if (buf == NULL)\n    {\n\tVIM_CLEAR(*file);\n\treturn FAIL;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // For MS-Windows et al. we don't double backslashes at the start and\n    // before a file name character.\n    for (var = buf; *var != NUL; MB_PTR_ADV(var))\n\tif (var[0] == '\\\\' && var[1] == '\\\\'\n\t\t&& expand_option_idx >= 0\n\t\t&& (options[expand_option_idx].flags & P_EXPAND)\n\t\t&& vim_isfilec(var[2])\n\t\t&& (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n\t    STRMOVE(var, var + 1);\n#endif\n\n    *file[0] = buf;\n    *num_file = 1;\n    return OK;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\n    static void\noption_value2string(\n    struct vimoption\t*opp,\n    int\t\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    char_u\t*varp;\n\n    varp = get_varp_scope(opp, opt_flags);\n\n    if (opp->flags & P_NUM)\n    {\n\tlong wc = 0;\n\n\tif (wc_use_keyname(varp, &wc))\n\t    STRCPY(NameBuff, get_special_key_name((int)wc, 0));\n\telse if (wc != 0)\n\t    STRCPY(NameBuff, transchar((int)wc));\n\telse\n\t    sprintf((char *)NameBuff, \"%ld\", *(long *)varp);\n    }\n    else    // P_STRING\n    {\n\tvarp = *(char_u **)(varp);\n\tif (varp == NULL)\t\t    // just in case\n\t    NameBuff[0] = NUL;\n#ifdef FEAT_CRYPT\n\t// don't show the actual value of 'key', only that it's set\n\telse if (opp->var == (char_u *)&p_key && *varp)\n\t    STRCPY(NameBuff, \"*****\");\n#endif\n\telse if (opp->flags & P_EXPAND)\n\t    home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n\t// Translate 'pastetoggle' into special key names\n\telse if ((char_u **)opp->var == &p_pt)\n\t    str2specialbuf(p_pt, NameBuff, MAXPATHL);\n\telse\n\t    vim_strncpy(NameBuff, varp, MAXPATHL - 1);\n    }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\n    static int\nwc_use_keyname(char_u *varp, long *wcp)\n{\n    if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))\n    {\n\t*wcp = *(long *)varp;\n\tif (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"x\" is present in 'shortmess' option, or\n * 'shortmess' contains 'a' and \"x\" is present in SHM_A.\n */\n    int\nshortmess(int x)\n{\n    return p_shm != NULL &&\n\t    (   vim_strchr(p_shm, x) != NULL\n\t    || (vim_strchr(p_shm, 'a') != NULL\n\t\t&& vim_strchr((char_u *)SHM_A, x) != NULL));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\n    static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\ttabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}\n\n/*\n * vimrc_found() - Called when a \".vimrc\" or \"VIMINIT\" has been found.\n *\n * Reset 'compatible' and set the values for options that didn't get set yet\n * to the Vim defaults.\n * Don't do this if the 'compatible' option has been set or reset before.\n * When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\n */\n    void\nvimrc_found(char_u *fname, char_u *envname)\n{\n    int\t\topt_idx;\n    int\t\tdofree = FALSE;\n    char_u\t*p;\n\n    if (!option_was_set((char_u *)\"cp\"))\n    {\n\tp_cp = FALSE;\n\tfor (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\t    if (!(options[opt_idx].flags & (P_WAS_SET|P_VI_DEF)))\n\t\tset_option_default(opt_idx, OPT_FREE, FALSE);\n\tdidset_options();\n\tdidset_options2();\n    }\n\n    if (fname != NULL)\n    {\n\tp = vim_getenv(envname, &dofree);\n\tif (p == NULL)\n\t{\n\t    // Set $MYVIMRC to the first vimrc file found.\n\t    p = FullName_save(fname, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv(envname, p);\n\t\tvim_free(p);\n\t    }\n\t}\n\telse if (dofree)\n\t    vim_free(p);\n    }\n}\n\n/*\n * Set 'compatible' on or off.  Called for \"-C\" and \"-N\" command line arg.\n */\n    void\nchange_compatible(int on)\n{\n    int\t    opt_idx;\n\n    if (p_cp != on)\n    {\n\tp_cp = on;\n\tcompatible_set();\n    }\n    opt_idx = findoption((char_u *)\"cp\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_WAS_SET;\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\n    int\noption_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t// unknown option\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Reset the flag indicating option \"name\" was set.\n */\n    int\nreset_option_was_set(char_u *name)\n{\n    int idx = findoption(name);\n\n    if (idx >= 0)\n    {\n\toptions[idx].flags &= ~P_WAS_SET;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * compatible_set() - Called when 'compatible' has been set or unset.\n *\n * When 'compatible' set: Set all relevant options (those that have the P_VIM)\n * flag) to a Vi compatible value.\n * When 'compatible' is unset: Set all options that have a different default\n * for Vim (without the P_VI_DEF flag) to that default.\n */\n    static void\ncompatible_set(void)\n{\n    int\t    opt_idx;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\tif (\t   ((options[opt_idx].flags & P_VIM) && p_cp)\n\t\t|| (!(options[opt_idx].flags & P_VI_DEF) && !p_cp))\n\t    set_option_default(opt_idx, OPT_FREE, p_cp);\n    didset_options();\n    didset_options2();\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\n    void\nfill_breakat_flags(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    for (i = 0; i < 256; i++)\n\tbreakat_flags[i] = FALSE;\n\n    if (p_breakat != NULL)\n\tfor (p = p_breakat; *p; p++)\n\t    breakat_flags[*p] = TRUE;\n}\n#endif\n\n/*\n * Check if backspacing over something is allowed.\n */\n    int\ncan_bs(\n    int\t\twhat)\t    // BS_INDENT, BS_EOL, BS_START or BS_NOSTOP\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (what == BS_START && bt_prompt(curbuf))\n\treturn FALSE;\n#endif\n    switch (*p_bs)\n    {\n\tcase '3':       return TRUE;\n\tcase '2':\treturn (what != BS_NOSTOP);\n\tcase '1':\treturn (what != BS_START);\n\tcase '0':\treturn FALSE;\n    }\n    return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Return the effective 'scrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_scrolloff_value(void)\n{\n    return curwin->w_p_so < 0 ? p_so : curwin->w_p_so;\n}\n\n/*\n * Return the effective 'sidescrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_sidescrolloff_value(void)\n{\n    return curwin->w_p_siso < 0 ? p_siso : curwin->w_p_siso;\n}\n\n/*\n * Get the local or global value of 'backupcopy'.\n */\n    unsigned int\nget_bkc_value(buf_T *buf)\n{\n    return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/*\n * Get the local or global value of the 'virtualedit' flags.\n */\n    unsigned int\nget_ve_flags(void)\n{\n    return (curwin->w_ve_flags ? curwin->w_ve_flags : ve_flags)\n\t    & ~(VE_NONE | VE_NONEU);\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * Get the local or global value of 'showbreak'.\n */\n    char_u *\nget_showbreak_value(win_T *win)\n{\n    if (win->w_p_sbr == NULL || *win->w_p_sbr == NUL)\n\treturn p_sbr;\n    if (STRCMP(win->w_p_sbr, \"NONE\") == 0)\n\treturn empty_option;\n    return win->w_p_sbr;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get window or buffer local options.\n */\n    dict_T *\nget_winbuf_options(int bufopt)\n{\n    dict_T\t*d;\n    int\t\topt_idx;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tstruct vimoption *opt = &options[opt_idx];\n\n\tif ((bufopt && (opt->indir & PV_BUF))\n\t\t\t\t\t || (!bufopt && (opt->indir & PV_WIN)))\n\t{\n\t    char_u *varp = get_varp(opt);\n\n\t    if (varp != NULL)\n\t    {\n\t\tif (opt->flags & P_STRING)\n\t\t    dict_add_string(d, opt->fullname, *(char_u **)varp);\n\t\telse if (opt->flags & P_NUM)\n\t\t    dict_add_number(d, opt->fullname, *(long *)varp);\n\t\telse\n\t\t    dict_add_number(d, opt->fullname, *(int *)varp);\n\t    }\n\t}\n    }\n\n    return d;\n}\n#endif\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * This is called when 'culopt' is changed\n */\n    int\nfill_culopt_flags(char_u *val, win_T *wp)\n{\n    char_u\t*p;\n    char_u\tculopt_flags_new = 0;\n\n    if (val == NULL)\n\tp = wp->w_p_culopt;\n    else\n\tp = val;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"line\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE;\n\t}\n\telse if (STRNCMP(p, \"both\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"number\", 6) == 0)\n\t{\n\t    p += 6;\n\t    culopt_flags_new |= CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"screenline\", 10) == 0)\n\t{\n\t    p += 10;\n\t    culopt_flags_new |= CULOPT_SCRLINE;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    // Can't have both \"line\" and \"screenline\".\n    if ((culopt_flags_new & CULOPT_LINE) && (culopt_flags_new & CULOPT_SCRLINE))\n\treturn FAIL;\n    wp->w_p_culopt_flags = culopt_flags_new;\n\n    return OK;\n}\n#endif\n\n/*\n * Get the value of 'magic' adjusted for Vim9 script.\n */\n    int\nmagic_isset(void)\n{\n    switch (magic_overruled)\n    {\n\tcase OPTION_MAGIC_ON:      return TRUE;\n\tcase OPTION_MAGIC_OFF:     return FALSE;\n\tcase OPTION_MAGIC_NOT_SET: break;\n    }\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn TRUE;\n#endif\n    return p_magic;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * optionstr.c: Functions related to string options\n */\n\n#include \"vim.h\"\n\nstatic char *(p_ambw_values[]) = {\"single\", \"double\", NULL};\nstatic char *(p_bg_values[]) = {\"light\", \"dark\", NULL};\nstatic char *(p_bkc_values[]) = {\"yes\", \"auto\", \"no\", \"breaksymlink\", \"breakhardlink\", NULL};\nstatic char *(p_bo_values[]) = {\"all\", \"backspace\", \"cursor\", \"complete\",\n\t\t\t\t \"copy\", \"ctrlg\", \"error\", \"esc\", \"ex\",\n\t\t\t\t \"hangul\", \"insertmode\", \"lang\", \"mess\",\n\t\t\t\t \"showmatch\", \"operator\", \"register\", \"shell\",\n\t\t\t\t \"spell\", \"wildmode\", NULL};\nstatic char *(p_nf_values[]) = {\"bin\", \"octal\", \"hex\", \"alpha\", \"unsigned\", NULL};\nstatic char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};\n#ifdef FEAT_CRYPT\nstatic char *(p_cm_values[]) = {\"zip\", \"blowfish\", \"blowfish2\",\n # ifdef FEAT_SODIUM\n    \"xchacha20\",\n # endif\n    NULL};\n#endif\nstatic char *(p_cmp_values[]) = {\"internal\", \"keepascii\", NULL};\nstatic char *(p_dy_values[]) = {\"lastline\", \"truncate\", \"uhex\", NULL};\n#ifdef FEAT_FOLDING\nstatic char *(p_fdo_values[]) = {\"all\", \"block\", \"hor\", \"mark\", \"percent\",\n\t\t\t\t \"quickfix\", \"search\", \"tag\", \"insert\",\n\t\t\t\t \"undo\", \"jump\", NULL};\n#endif\n#ifdef FEAT_SESSION\n// Also used for 'viewoptions'!  Keep in sync with SSOP_ flags.\nstatic char *(p_ssop_values[]) = {\"buffers\", \"winpos\", \"resize\", \"winsize\",\n    \"localoptions\", \"options\", \"help\", \"blank\", \"globals\", \"slash\", \"unix\",\n    \"sesdir\", \"curdir\", \"folds\", \"cursor\", \"tabpages\", \"terminal\", \"skiprtp\",\n    NULL};\n#endif\n// Keep in sync with SWB_ flags in option.h\nstatic char *(p_swb_values[]) = {\"useopen\", \"usetab\", \"split\", \"newtab\", \"vsplit\", \"uselast\", NULL};\nstatic char *(p_tc_values[]) = {\"followic\", \"ignore\", \"match\", \"followscs\", \"smart\", NULL};\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\nstatic char *(p_toolbar_values[]) = {\"text\", \"icons\", \"tooltips\", \"horiz\", NULL};\n#endif\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\nstatic char *(p_tbis_values[]) = {\"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"giant\", NULL};\n#endif\n#if defined(UNIX) || defined(VMS)\nstatic char *(p_ttym_values[]) = {\"xterm\", \"xterm2\", \"dec\", \"netterm\", \"jsbterm\", \"pterm\", \"urxvt\", \"sgr\", NULL};\n#endif\nstatic char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", \"none\", \"NONE\", NULL};\nstatic char *(p_wop_values[]) = {\"tagfile\", NULL};\n#ifdef FEAT_WAK\nstatic char *(p_wak_values[]) = {\"yes\", \"menu\", \"no\", NULL};\n#endif\nstatic char *(p_mousem_values[]) = {\"extend\", \"popup\", \"popup_setpos\", \"mac\", NULL};\nstatic char *(p_sel_values[]) = {\"inclusive\", \"exclusive\", \"old\", NULL};\nstatic char *(p_slm_values[]) = {\"mouse\", \"key\", \"cmd\", NULL};\nstatic char *(p_km_values[]) = {\"startsel\", \"stopsel\", NULL};\n#ifdef FEAT_BROWSE\nstatic char *(p_bsdir_values[]) = {\"current\", \"last\", \"buffer\", NULL};\n#endif\nstatic char *(p_scbopt_values[]) = {\"ver\", \"hor\", \"jump\", NULL};\nstatic char *(p_debug_values[]) = {\"msg\", \"throw\", \"beep\", NULL};\nstatic char *(p_ead_values[]) = {\"both\", \"ver\", \"hor\", NULL};\nstatic char *(p_buftype_values[]) = {\"nofile\", \"nowrite\", \"quickfix\", \"help\", \"terminal\", \"acwrite\", \"prompt\", \"popup\", NULL};\nstatic char *(p_bufhidden_values[]) = {\"hide\", \"unload\", \"delete\", \"wipe\", NULL};\nstatic char *(p_bs_values[]) = {\"indent\", \"eol\", \"start\", \"nostop\", NULL};\n#ifdef FEAT_FOLDING\nstatic char *(p_fdm_values[]) = {\"manual\", \"expr\", \"marker\", \"indent\", \"syntax\",\n# ifdef FEAT_DIFF\n\t\t\t\t\"diff\",\n# endif\n\t\t\t\tNULL};\nstatic char *(p_fcl_values[]) = {\"all\", NULL};\n#endif\nstatic char *(p_cot_values[]) = {\"menu\", \"menuone\", \"longest\", \"preview\", \"popup\", \"popuphidden\", \"noinsert\", \"noselect\", NULL};\n#ifdef BACKSLASH_IN_FILENAME\nstatic char *(p_csl_values[]) = {\"slash\", \"backslash\", NULL};\n#endif\n#ifdef FEAT_SIGNS\nstatic char *(p_scl_values[]) = {\"yes\", \"no\", \"auto\", \"number\", NULL};\n#endif\n#if defined(MSWIN) && defined(FEAT_TERMINAL)\nstatic char *(p_twt_values[]) = {\"winpty\", \"conpty\", \"\", NULL};\n#endif\n\nstatic int check_opt_strings(char_u *val, char **values, int list);\nstatic int opt_strings_flags(char_u *val, char **values, unsigned *flagp, int list);\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    void\ndidset_string_options(void)\n{\n    (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE);\n    (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE);\n    (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE);\n#ifdef FEAT_SESSION\n    (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE);\n    (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE);\n#endif\n#ifdef FEAT_FOLDING\n    (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE);\n#endif\n    (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE);\n    (void)opt_strings_flags(p_tc, p_tc_values, &tc_flags, FALSE);\n    (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE);\n#if defined(UNIX) || defined(VMS)\n    (void)opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE);\n#endif\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\n    (void)opt_strings_flags(p_toolbar, p_toolbar_values, &toolbar_flags, TRUE);\n#endif\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    (void)opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE);\n#endif\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Trigger the OptionSet autocommand.\n * \"opt_idx\"\tis the index of the option being set.\n * \"opt_flags\"\tcan be OPT_LOCAL etc.\n * \"oldval\"\tthe old value\n *  \"oldval_l\"  the old local value (only non-NULL if global and local value\n *\t\tare set)\n * \"oldval_g\"   the old global value (only non-NULL if global and local value\n *\t\tare set)\n * \"newval\"\tthe new value\n */\n    void\ntrigger_optionsset_string(\n\tint\topt_idx,\n\tint\topt_flags,\n\tchar_u  *oldval,\n\tchar_u  *oldval_l,\n\tchar_u  *oldval_g,\n\tchar_u  *newval)\n{\n    // Don't do this recursively.\n    if (oldval != NULL && newval != NULL\n\t\t\t\t    && *get_vim_var_str(VV_OPTION_TYPE) == NUL)\n    {\n\tchar_u buf_type[7];\n\n\tsprintf((char *)buf_type, \"%s\",\n\t    (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n\tset_vim_var_string(VV_OPTION_OLD, oldval, -1);\n\tset_vim_var_string(VV_OPTION_NEW, newval, -1);\n\tset_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);\n\t}\n\tif (opt_flags & OPT_GLOBAL)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval, -1);\n\t}\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval_l, -1);\n\t    set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval_g, -1);\n\t}\n\tif (opt_flags & OPT_MODELINE)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);\n\t}\n\tapply_autocmds(EVENT_OPTIONSET,\n\t\t       (char_u *)get_option_fullname(opt_idx), NULL, FALSE,\n\t\t       NULL);\n\treset_v_option_vars();\n    }\n}\n#endif\n\n    static char *\nillegal_char(char *errbuf, int c)\n{\n    if (errbuf == NULL)\n\treturn \"\";\n    sprintf((char *)errbuf, _(\"E539: Illegal character <%s>\"),\n\t\t\t\t\t\t\t(char *)transchar(c));\n    return errbuf;\n}\n\n/*\n * Check string options in a buffer for NULL value.\n */\n    void\ncheck_buf_options(buf_T *buf)\n{\n    check_string_option(&buf->b_p_bh);\n    check_string_option(&buf->b_p_bt);\n    check_string_option(&buf->b_p_fenc);\n    check_string_option(&buf->b_p_ff);\n#ifdef FEAT_FIND_ID\n    check_string_option(&buf->b_p_def);\n    check_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    check_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_inde);\n    check_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    check_string_option(&buf->b_p_cm);\n#endif\n    check_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n    check_string_option(&buf->b_p_key);\n#endif\n    check_string_option(&buf->b_p_kp);\n    check_string_option(&buf->b_p_mps);\n    check_string_option(&buf->b_p_fo);\n    check_string_option(&buf->b_p_flp);\n    check_string_option(&buf->b_p_isk);\n    check_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    check_string_option(&buf->b_p_cms);\n#endif\n    check_string_option(&buf->b_p_nf);\n#ifdef FEAT_TEXTOBJ\n    check_string_option(&buf->b_p_qe);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&buf->b_p_syn);\n    check_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    check_string_option(&buf->b_s.b_p_spc);\n    check_string_option(&buf->b_s.b_p_spf);\n    check_string_option(&buf->b_s.b_p_spl);\n    check_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    check_string_option(&buf->b_p_sua);\n#endif\n#ifdef FEAT_CINDENT\n    check_string_option(&buf->b_p_cink);\n    check_string_option(&buf->b_p_cino);\n    parse_cino(buf);\n#endif\n    check_string_option(&buf->b_p_ft);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n    check_string_option(&buf->b_p_cinw);\n#endif\n    check_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    check_string_option(&buf->b_p_cfu);\n    check_string_option(&buf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n    check_string_option(&buf->b_p_tfu);\n#endif\n#ifdef FEAT_KEYMAP\n    check_string_option(&buf->b_p_keymap);\n#endif\n#ifdef FEAT_QUICKFIX\n    check_string_option(&buf->b_p_gp);\n    check_string_option(&buf->b_p_mp);\n    check_string_option(&buf->b_p_efm);\n#endif\n    check_string_option(&buf->b_p_ep);\n    check_string_option(&buf->b_p_path);\n    check_string_option(&buf->b_p_tags);\n    check_string_option(&buf->b_p_tc);\n    check_string_option(&buf->b_p_dict);\n    check_string_option(&buf->b_p_tsr);\n#ifdef FEAT_LISP\n    check_string_option(&buf->b_p_lw);\n#endif\n    check_string_option(&buf->b_p_bkc);\n    check_string_option(&buf->b_p_menc);\n#ifdef FEAT_VARTABS\n    check_string_option(&buf->b_p_vsts);\n    check_string_option(&buf->b_p_vts);\n#endif\n}\n\n/*\n * Free the string allocated for an option.\n * Checks for the string being empty_option. This may happen if we're out of\n * memory, vim_strsave() returned NULL, which was replaced by empty_option by\n * check_options().\n * Does NOT check for P_ALLOCED flag!\n */\n    void\nfree_string_option(char_u *p)\n{\n    if (p != empty_option)\n\tvim_free(p);\n}\n\n    void\nclear_string_option(char_u **pp)\n{\n    if (*pp != empty_option)\n\tvim_free(*pp);\n    *pp = empty_option;\n}\n\n    void\ncheck_string_option(char_u **pp)\n{\n    if (*pp == NULL)\n\t*pp = empty_option;\n}\n\n/*\n * Set global value for string option when it's a local option.\n */\n    static void\nset_string_option_global(\n    int\t\topt_idx,\t// option index\n    char_u\t**varp)\t\t// pointer to option variable\n{\n    char_u\t**p, *s;\n\n    // the global value is always allocated\n    if (is_window_local_option(opt_idx))\n\tp = (char_u **)GLOBAL_WO(varp);\n    else\n\tp = (char_u **)get_option_var(opt_idx);\n    if (!is_global_option(opt_idx)\n\t    && p != varp\n\t    && (s = vim_strsave(*varp)) != NULL)\n    {\n\tfree_string_option(*p);\n\t*p = s;\n    }\n}\n\n/*\n * Set a string option to a new value (without checking the effect).\n * The string is copied into allocated memory.\n * if (\"opt_idx\" == -1) \"name\" is used, otherwise \"opt_idx\" is used.\n * When \"set_sid\" is zero set the scriptID to current_sctx.sc_sid.  When\n * \"set_sid\" is SID_NONE don't set the scriptID.  Otherwise set the scriptID to\n * \"set_sid\".\n */\n    void\nset_string_option_direct(\n    char_u\t*name,\n    int\t\topt_idx,\n    char_u\t*val,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tset_sid UNUSED)\n{\n    char_u\t*s;\n    char_u\t**varp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tidx = opt_idx;\n\n    if (idx == -1)\t\t// use name\n    {\n\tidx = findoption(name);\n\tif (idx < 0)\t// not found (should not happen)\n\t{\n\t    semsg(_(e_intern2), \"set_string_option_direct()\");\n\t    siemsg(_(\"For option %s\"), name);\n\t    return;\n\t}\n    }\n\n    if (is_hidden_option(idx))\t\t// can't set hidden option\n\treturn;\n\n    s = vim_strsave(val);\n    if (s != NULL)\n    {\n\tvarp = (char_u **)get_option_varp_scope(idx,\n\t\t\t\t\t       both ? OPT_LOCAL : opt_flags);\n\tif ((opt_flags & OPT_FREE) && (get_option_flags(idx) & P_ALLOCED))\n\t    free_string_option(*varp);\n\t*varp = s;\n\n\t// For buffer/window local option may also set the global value.\n\tif (both)\n\t    set_string_option_global(idx, varp);\n\n\tset_option_flag(idx, P_ALLOCED);\n\n\t// When setting both values of a global option with a local value,\n\t// make the local value empty, so that the global value is used.\n\tif (is_global_local_option(idx) && both)\n\t{\n\t    free_string_option(*varp);\n\t    *varp = empty_option;\n\t}\n# ifdef FEAT_EVAL\n\tif (set_sid != SID_NONE)\n\t{\n\t    sctx_T script_ctx;\n\n\t    if (set_sid == 0)\n\t\tscript_ctx = current_sctx;\n\t    else\n\t    {\n\t\tscript_ctx.sc_sid = set_sid;\n\t\tscript_ctx.sc_seq = 0;\n\t\tscript_ctx.sc_lnum = 0;\n\t\tscript_ctx.sc_version = 1;\n\t    }\n\t    set_option_sctx_idx(idx, opt_flags, script_ctx);\n\t}\n# endif\n    }\n}\n\n/*\n * Like set_string_option_direct(), but for a window-local option in \"wp\".\n * Blocks autocommands to avoid the old curwin becoming invalid.\n */\n    void\nset_string_option_direct_in_win(\n\twin_T\t\t*wp,\n\tchar_u\t\t*name,\n\tint\t\topt_idx,\n\tchar_u\t\t*val,\n\tint\t\topt_flags,\n\tint\t\tset_sid)\n{\n    win_T\t*save_curwin = curwin;\n\n    block_autocmds();\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    set_string_option_direct(name, opt_idx, val, opt_flags, set_sid);\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n    unblock_autocmds();\n}\n\n/*\n * Like set_string_option_direct(), but for a buffer-local option in \"buf\".\n * Blocks autocommands to avoid the old curbuf becoming invalid.\n */\n    void\nset_string_option_direct_in_buf(\n\tbuf_T\t\t*buf,\n\tchar_u\t\t*name,\n\tint\t\topt_idx,\n\tchar_u\t\t*val,\n\tint\t\topt_flags,\n\tint\t\tset_sid)\n{\n    buf_T\t*save_curbuf = curbuf;\n\n    block_autocmds();\n    curbuf = buf;\n    curwin->w_buffer = curbuf;\n    set_string_option_direct(name, opt_idx, val, opt_flags, set_sid);\n    curbuf = save_curbuf;\n    curwin->w_buffer = curbuf;\n    unblock_autocmds();\n}\n\n/*\n * Set a string option to a new value, and handle the effects.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_string_option(\n    int\t\topt_idx,\n    char_u\t*value,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    char_u\t*s;\n    char_u\t**varp;\n    char_u\t*oldval;\n#if defined(FEAT_EVAL)\n    char_u\t*oldval_l = NULL;\n    char_u\t*oldval_g = NULL;\n    char_u\t*saved_oldval = NULL;\n    char_u\t*saved_oldval_l = NULL;\n    char_u\t*saved_oldval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n    char\t*r = NULL;\n    int\t\tvalue_checked = FALSE;\n\n    if (is_hidden_option(opt_idx))\t// don't set hidden option\n\treturn NULL;\n\n    s = vim_strsave(value == NULL ? (char_u *)\"\" : value);\n    if (s != NULL)\n    {\n\tvarp = (char_u **)get_option_varp_scope(opt_idx,\n\t\t(opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t    ? (is_global_local_option(opt_idx)\n\t\t\t? OPT_GLOBAL : OPT_LOCAL)\n\t\t    : opt_flags);\n\toldval = *varp;\n#if defined(FEAT_EVAL)\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t{\n\t    oldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);\n\t    oldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n\t}\n#endif\n\t*varp = s;\n\n#if defined(FEAT_EVAL)\n\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t&& !is_crypt_key_option(opt_idx)\n# endif\n\t\t)\n\t{\n\t    if (oldval_l != NULL)\n\t\tsaved_oldval_l = vim_strsave(oldval_l);\n\t    if (oldval_g != NULL)\n\t\tsaved_oldval_g = vim_strsave(oldval_g);\n\t    saved_oldval = vim_strsave(oldval);\n\t    saved_newval = vim_strsave(s);\n\t}\n#endif\n\tif ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,\n\t\t\t\t\t   opt_flags, &value_checked)) == NULL)\n\t    did_set_option(opt_idx, opt_flags, TRUE, value_checked);\n\n#if defined(FEAT_EVAL)\n\t// call autocommand after handling side effects\n\tif (r == NULL)\n\t    trigger_optionsset_string(opt_idx, opt_flags,\n\t\t\t\t   saved_oldval, saved_oldval_l,\n\t\t\t\t   saved_oldval_g, saved_newval);\n\tvim_free(saved_oldval);\n\tvim_free(saved_oldval_l);\n\tvim_free(saved_oldval_g);\n\tvim_free(saved_newval);\n#endif\n    }\n    return r;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'filetype' name.\n * Also used for 'syntax' and 'keymap'.\n */\n    static int\nvalid_filetype(char_u *val)\n{\n    return valid_name(val, \".-_\");\n}\n\n#ifdef FEAT_STL_OPT\n/*\n * Check validity of options with the 'statusline' format.\n * Return error message or NULL.\n */\n    static char *\ncheck_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[80];\n\n    while (*s)\n    {\n\t// Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    s++;\n\tif (!*s)\n\t    break;\n\ts++;\n\tif (*s == '%' || *s == STL_TRUNCMARK || *s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (--groupdepth < 0)\n\t\tbreak;\n\t    continue;\n\t}\n\tif (*s == '-')\n\t    s++;\n\twhile (VIM_ISDIGIT(*s))\n\t    s++;\n\tif (*s == STL_USER_HL)\n\t    continue;\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    while (*s && VIM_ISDIGIT(*s))\n\t\ts++;\n\t}\n\tif (*s == '(')\n\t{\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*s == '%');\n\n\t    s++;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn N_(\"E540: Unclosed expression sequence\");\n\t}\n    }\n    if (groupdepth != 0)\n\treturn N_(\"E542: unbalanced groups\");\n    return NULL;\n}\n#endif\n\n/*\n * Handle string options that need some action to perform when changed.\n * Returns NULL for success, or an error message for an error.\n */\n    char *\ndid_set_string_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t**varp,\t\t\t// pointer to the option variable\n    int\t\tnew_value_alloced,\t// new value was allocated\n    char_u\t*oldval,\t\t// previous value of the option\n    char\t*errbuf,\t\t// buffer for errors, or NULL\n    int\t\topt_flags,\t\t// OPT_LOCAL and/or OPT_GLOBAL\n    int\t\t*value_checked)\t\t// value was checked to be save, no\n\t\t\t\t\t// need to set P_INSECURE\n{\n    char\t*errmsg = NULL;\n    char_u\t*s, *p;\n    int\t\tdid_chartab = FALSE;\n    char_u\t**gvarp;\n    long_u\tfree_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n#ifdef FEAT_GUI\n    // set when changing an option that only requires a redraw in the GUI\n    int\t\tredraw_gui_only = FALSE;\n#endif\n    int\t\tvalue_changed = FALSE;\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n    int\t\tdid_swaptcap = FALSE;\n#endif\n\n    // Get the global option to compare with, otherwise we would have to check\n    // two values for all local options.\n    gvarp = (char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (get_option_flags(opt_idx) & P_SECURE))\n\terrmsg = e_secure;\n\n    // Check for a \"normal\" directory or file name in some options.  Disallow a\n    // path separator (slash and/or backslash), wildcards and characters that\n    // are often illegal in a file name. Be more permissive if \"secure\" is off.\n    else if (((get_option_flags(opt_idx) & P_NFNAME)\n\t\t    && vim_strpbrk(*varp, (char_u *)(secure\n\t\t\t    ? \"/\\\\*?[|;&<>\\r\\n\" : \"/\\\\*?[<>\\r\\n\")) != NULL)\n\t  || ((get_option_flags(opt_idx) & P_NDNAME)\n\t\t    && vim_strpbrk(*varp, (char_u *)\"*?[|;&<>\\r\\n\") != NULL))\n\terrmsg = e_invarg;\n\n    // 'term'\n    else if (varp == &T_NAME)\n    {\n\tif (T_NAME[0] == NUL)\n\t    errmsg = N_(\"E529: Cannot set 'term' to empty string\");\n#ifdef FEAT_GUI\n\telse if (gui.in_use)\n\t    errmsg = N_(\"E530: Cannot change term in GUI\");\n\telse if (term_is_gui(T_NAME))\n\t    errmsg = N_(\"E531: Use \\\":gui\\\" to start the GUI\");\n#endif\n\telse if (set_termname(T_NAME) == FAIL)\n\t    errmsg = N_(\"E522: Not found in termcap\");\n\telse\n\t{\n\t    // Screen colors may have changed.\n\t    redraw_later_clear();\n\n\t    // Both 'term' and 'ttytype' point to T_NAME, only set the\n\t    // P_ALLOCED flag on 'term'.\n\t    opt_idx = findoption((char_u *)\"term\");\n\t    free_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n\t}\n    }\n\n    // 'backupcopy'\n    else if (gvarp == &p_bkc)\n    {\n\tchar_u\t\t*bkc = p_bkc;\n\tunsigned int\t*flags = &bkc_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    bkc = curbuf->b_p_bkc;\n\t    flags = &curbuf->b_bkc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *bkc == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(bkc, p_bkc_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    if ((((int)*flags & BKC_AUTO) != 0)\n\t\t    + (((int)*flags & BKC_YES) != 0)\n\t\t    + (((int)*flags & BKC_NO) != 0) != 1)\n\t    {\n\t\t// Must have exactly one of \"auto\", \"yes\"  and \"no\".\n\t\t(void)opt_strings_flags(oldval, p_bkc_values, flags, TRUE);\n\t\terrmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    // 'backupext' and 'patchmode'\n    else if (varp == &p_bex || varp == &p_pm)\n    {\n\tif (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n\t\t     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n\t    errmsg = N_(\"E589: 'backupext' and 'patchmode' are equal\");\n    }\n#ifdef FEAT_LINEBREAK\n    // 'breakindentopt'\n    else if (varp == &curwin->w_p_briopt)\n    {\n\tif (briopt_check(curwin) == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    else if (  varp == &p_isi\n\t    || varp == &(curbuf->b_p_isk)\n\t    || varp == &p_isp\n\t    || varp == &p_isf)\n    {\n\tif (init_chartab() == FAIL)\n\t{\n\t    did_chartab = TRUE;\t    // need to restore it below\n\t    errmsg = e_invarg;\t    // error in value\n\t}\n    }\n\n    // 'helpfile'\n    else if (varp == &p_hf)\n    {\n\t// May compute new values for $VIM and $VIMRUNTIME\n\tif (didset_vim)\n\t{\n\t    vim_setenv((char_u *)\"VIM\", (char_u *)\"\");\n\t    didset_vim = FALSE;\n\t}\n\tif (didset_vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", (char_u *)\"\");\n\t    didset_vimruntime = FALSE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    // 'cursorlineopt'\n    else if (varp == &curwin->w_p_culopt\n\t\t\t\t  || gvarp == &curwin->w_allbuf_opt.wo_culopt)\n    {\n\tif (**varp == NUL || fill_culopt_flags(*varp, curwin) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'colorcolumn'\n    else if (varp == &curwin->w_p_cc)\n\terrmsg = check_colorcolumn(curwin);\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // 'helplang'\n    else if (varp == &p_hlg)\n    {\n\t// Check for \"\", \"ab\", \"ab,cd\", etc.\n\tfor (s = p_hlg; *s != NUL; s += 3)\n\t{\n\t    if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL))\n\t    {\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (s[2] == NUL)\n\t\tbreak;\n\t}\n    }\n#endif\n\n    // 'highlight'\n    else if (varp == &p_hl)\n    {\n\tif (highlight_changed() == FAIL)\n\t    errmsg = e_invarg;\t// invalid flags\n    }\n\n    // 'nrformats'\n    else if (gvarp == &p_nf)\n    {\n\tif (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_SESSION\n    // 'sessionoptions'\n    else if (varp == &p_ssop)\n    {\n\tif (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\tif ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR))\n\t{\n\t    // Don't allow both \"sesdir\" and \"curdir\".\n\t    (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, TRUE);\n\t    errmsg = e_invarg;\n\t}\n    }\n    // 'viewoptions'\n    else if (varp == &p_vop)\n    {\n\tif (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'scrollopt'\n    else if (varp == &p_sbo)\n    {\n\tif (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'ambiwidth'\n    else if (varp == &p_ambw || varp == &p_emoji)\n    {\n\tif (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse if (set_chars_option(curwin, &p_fcs) != NULL)\n\t    errmsg = _(\"E835: Conflicts with value of 'fillchars'\");\n\telse\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (set_chars_option(wp, &wp->w_p_lcs) != NULL)\n\t\t{\n\t\t    errmsg = _(\"E834: Conflicts with value of 'listchars'\");\n\t\t    goto ambw_end;\n\t\t}\n\t    }\n\t}\nambw_end:\n\t{}\n    }\n\n    // 'background'\n    else if (varp == &p_bg)\n    {\n\tif (check_opt_strings(p_bg, p_bg_values, FALSE) == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    int dark = (*p_bg == 'd');\n#endif\n\n\t    init_highlight(FALSE, FALSE);\n\n#ifdef FEAT_EVAL\n\t    if (dark != (*p_bg == 'd')\n\t\t\t  && get_var_value((char_u *)\"g:colors_name\") != NULL)\n\t    {\n\t\t// The color scheme must have set 'background' back to another\n\t\t// value, that's not what we want here.  Disable the color\n\t\t// scheme and set the colors again.\n\t\tdo_unlet((char_u *)\"g:colors_name\", TRUE);\n\t\tfree_string_option(p_bg);\n\t\tp_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n\t\tcheck_string_option(&p_bg);\n\t\tinit_highlight(FALSE, FALSE);\n\t    }\n#endif\n#ifdef FEAT_TERMINAL\n\t    term_update_colors_all();\n#endif\n\t}\n\telse\n\t    errmsg = e_invarg;\n    }\n\n    // 'wildmode'\n    else if (varp == &p_wim)\n    {\n\tif (check_opt_wim() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n    // 'wildoptions'\n    else if (varp == &p_wop)\n    {\n\tif (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_WAK\n    // 'winaltkeys'\n    else if (varp == &p_wak)\n    {\n\tif (*p_wak == NUL\n\t\t|| check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n# ifdef FEAT_MENU\n#  ifdef FEAT_GUI_MOTIF\n\telse if (gui.in_use)\n\t    gui_motif_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#  else\n#   ifdef FEAT_GUI_GTK\n\telse if (gui.in_use)\n\t    gui_gtk_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#   endif\n#  endif\n# endif\n    }\n#endif\n\n    // 'eventignore'\n    else if (varp == &p_ei)\n    {\n\tif (check_ei() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n    // 'encoding', 'fileencoding', 'termencoding' and 'makeencoding'\n    else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc\n\t\t\t\t\t\t\t   || gvarp == &p_menc)\n    {\n\tif (gvarp == &p_fenc)\n\t{\n\t    if (!curbuf->b_p_ma && opt_flags != OPT_GLOBAL)\n\t\terrmsg = e_cannot_make_changes_modifiable_is_off;\n\t    else if (vim_strchr(*varp, ',') != NULL)\n\t\t// No comma allowed in 'fileencoding'; catches confusing it\n\t\t// with 'fileencodings'.\n\t\terrmsg = e_invarg;\n\t    else\n\t    {\n#ifdef FEAT_TITLE\n\t\t// May show a \"+\" in the title now.\n\t\tredraw_titles();\n#endif\n\t\t// Add 'fileencoding' to the swap file.\n\t\tml_setflags(curbuf);\n\t    }\n\t}\n\tif (errmsg == NULL)\n\t{\n\t    // canonize the value, so that STRCMP() can be used on it\n\t    p = enc_canonize(*varp);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(*varp);\n\t\t*varp = p;\n\t    }\n\t    if (varp == &p_enc)\n\t    {\n\t\terrmsg = mb_init();\n#ifdef FEAT_TITLE\n\t\tredraw_titles();\n#endif\n\t    }\n\t}\n\n#if defined(FEAT_GUI_GTK)\n\tif (errmsg == NULL && varp == &p_tenc && gui.in_use)\n\t{\n\t    // GTK+ 2 uses only a single encoding, and that is UTF-8.\n\t    if (STRCMP(p_tenc, \"utf-8\") != 0)\n\t\terrmsg = N_(\"E617: Cannot be changed in the GTK+ 2 GUI\");\n\t}\n#endif\n\n\tif (errmsg == NULL)\n\t{\n#ifdef FEAT_KEYMAP\n\t    // When 'keymap' is used and 'encoding' changes, reload the keymap\n\t    // (with another encoding).\n\t    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)\n\t\t(void)keymap_init();\n#endif\n\n\t    // When 'termencoding' is not empty and 'encoding' changes or when\n\t    // 'termencoding' changes, need to setup for keyboard input and\n\t    // display output conversion.\n\t    if (((varp == &p_enc && *p_tenc != NUL) || varp == &p_tenc))\n\t    {\n\t\tif (convert_setup(&input_conv, p_tenc, p_enc) == FAIL\n\t\t\t|| convert_setup(&output_conv, p_enc, p_tenc) == FAIL)\n\t\t{\n\t\t    semsg(_(\"E950: Cannot convert between %s and %s\"),\n\t\t\t    p_tenc, p_enc);\n\t\t    errmsg = e_invarg;\n\t\t}\n\t    }\n\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    if (varp == &p_enc)\n\t\tinit_homedir();\n#endif\n\t}\n    }\n\n#if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_penc)\n    {\n\t// Canonize printencoding if VIM standard one\n\tp = enc_canonize(p_penc);\n\tif (p != NULL)\n\t{\n\t    vim_free(p_penc);\n\t    p_penc = p;\n\t}\n\telse\n\t{\n\t    // Ensure lower case and '-' for '_'\n\t    for (s = p_penc; *s != NUL; s++)\n\t    {\n\t\tif (*s == '_')\n\t\t    *s = '-';\n\t\telse\n\t\t    *s = TOLOWER_ASC(*s);\n\t    }\n\t}\n    }\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    else if (varp == &p_imak)\n    {\n\tif (!im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    int\t    secure_save = secure;\n\n\t    // Reset the secure flag, since the value of 'keymap' has\n\t    // been checked to be safe.\n\t    secure = 0;\n\n\t    // load or unload key mapping tables\n\t    errmsg = keymap_init();\n\n\t    secure = secure_save;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t// Installed a new keymap, switch on using it.\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n\t    else\n\t    {\n\t\t// Cleared the keymap, may reset 'iminsert' and 'imsearch'.\n\t\tif (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t\tif (curbuf->b_p_imsearch == B_IMODE_LMAP)\n\t\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n\t    }\n\t    if ((opt_flags & OPT_LOCAL) == 0)\n\t    {\n\t\tset_iminsert_global();\n\t\tset_imsearch_global();\n\t    }\n\t    status_redraw_curbuf();\n\t}\n    }\n#endif\n\n    // 'fileformat'\n    else if (gvarp == &p_ff)\n    {\n\tif (!curbuf->b_p_ma && !(opt_flags & OPT_GLOBAL))\n\t    errmsg = e_cannot_make_changes_modifiable_is_off;\n\telse if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // may also change 'textmode'\n\t    if (get_fileformat(curbuf) == EOL_DOS)\n\t\tcurbuf->b_p_tx = TRUE;\n\t    else\n\t\tcurbuf->b_p_tx = FALSE;\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t    // update flag in swap file\n\t    ml_setflags(curbuf);\n\t    // Redraw needed when switching to/from \"mac\": a CR in the text\n\t    // will be displayed differently.\n\t    if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n\t\tredraw_curbuf_later(NOT_VALID);\n\t}\n    }\n\n    // 'fileformats'\n    else if (varp == &p_ffs)\n    {\n\tif (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // also change 'textauto'\n\t    if (*p_ffs == NUL)\n\t\tp_ta = FALSE;\n\t    else\n\t\tp_ta = TRUE;\n\t}\n    }\n\n#if defined(FEAT_CRYPT)\n    // 'cryptkey'\n    else if (gvarp == &p_key)\n    {\n\t// Make sure the \":set\" command doesn't show the new value in the\n\t// history.\n\tremove_key_from_history();\n\n\tif (STRCMP(curbuf->b_p_key, oldval) != 0)\n\t    // Need to update the swapfile.\n\t{\n\t    ml_set_crypt_key(curbuf, oldval,\n\t\t\t      *curbuf->b_p_cm == NUL ? p_cm : curbuf->b_p_cm);\n\t    changed_internal();\n\t}\n    }\n\n    else if (gvarp == &p_cm)\n    {\n\tif (opt_flags & OPT_LOCAL)\n\t    p = curbuf->b_p_cm;\n\telse\n\t    p = p_cm;\n\tif (check_opt_strings(p, p_cm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (crypt_self_test() == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // When setting the global value to empty, make it \"zip\".\n\t    if (*p_cm == NUL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_cm);\n\t\tp_cm = vim_strsave((char_u *)\"zip\");\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t    // When using \":set cm=name\" the local value is going to be empty.\n\t    // Do that here, otherwise the crypt functions will still use the\n\t    // local value.\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t    {\n\t\tfree_string_option(curbuf->b_p_cm);\n\t\tcurbuf->b_p_cm = empty_option;\n\t    }\n\n\t    // Need to update the swapfile when the effective method changed.\n\t    // Set \"s\" to the effective old value, \"p\" to the effective new\n\t    // method and compare.\n\t    if ((opt_flags & OPT_LOCAL) && *oldval == NUL)\n\t\ts = p_cm;  // was previously using the global value\n\t    else\n\t\ts = oldval;\n\t    if (*curbuf->b_p_cm == NUL)\n\t\tp = p_cm;  // is now using the global value\n\t    else\n\t\tp = curbuf->b_p_cm;\n\t    if (STRCMP(s, p) != 0)\n\t\tml_set_crypt_key(curbuf, curbuf->b_p_key, s);\n\n\t    // If the global value changes need to update the swapfile for all\n\t    // buffers using that value.\n\t    if ((opt_flags & OPT_GLOBAL) && STRCMP(p_cm, oldval) != 0)\n\t    {\n\t\tbuf_T\t*buf;\n\n\t\tFOR_ALL_BUFFERS(buf)\n\t\t    if (buf != curbuf && *buf->b_p_cm == NUL)\n\t\t\tml_set_crypt_key(buf, buf->b_p_key, oldval);\n\t    }\n\t}\n    }\n#endif\n\n    // 'matchpairs'\n    else if (gvarp == &p_mps)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (p = *varp; *p != NUL; ++p)\n\t    {\n\t\tint x2 = -1;\n\t\tint x3 = -1;\n\n\t\tif (*p != NUL)\n\t\t    p += mb_ptr2len(p);\n\t\tif (*p != NUL)\n\t\t    x2 = *p++;\n\t\tif (*p != NUL)\n\t\t{\n\t\t    x3 = mb_ptr2char(p);\n\t\t    p += mb_ptr2len(p);\n\t\t}\n\t\tif (x2 != ':' || x3 == -1 || (*p != NUL && *p != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    // Check for \"x:y,x:y\"\n\t    for (p = *varp; *p != NUL; p += 4)\n\t    {\n\t\tif (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (p[3] == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    // 'comments'\n    else if (gvarp == &p_com)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    while (*s && *s != ':')\n\t    {\n\t\tif (vim_strchr((char_u *)COM_ALL, *s) == NULL\n\t\t\t\t\t     && !VIM_ISDIGIT(*s) && *s != '-')\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    }\n\t    if (*s++ == NUL)\n\t\terrmsg = N_(\"E524: Missing colon\");\n\t    else if (*s == ',' || *s == NUL)\n\t\terrmsg = N_(\"E525: Zero length string\");\n\t    if (errmsg != NULL)\n\t\tbreak;\n\t    while (*s && *s != ',')\n\t    {\n\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t    ++s;\n\t\t++s;\n\t    }\n\t    s = skip_to_option_part(s);\n\t}\n    }\n\n    // global 'listchars'\n    else if (varp == &p_lcs)\n    {\n\terrmsg = set_chars_option(curwin, varp);\n\tif (errmsg == NULL)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t\t*wp;\n\n\t    // The current window is set to use the global 'listchars' value.\n\t    // So clear the window-local value.\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t\tclear_string_option(&curwin->w_p_lcs);\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\terrmsg = set_chars_option(wp, &wp->w_p_lcs);\n\t\tif (errmsg)\n\t\t    break;\n\t    }\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n\n    // local 'listchars'\n    else if (varp == &curwin->w_p_lcs)\n\terrmsg = set_chars_option(curwin, varp);\n\n    // 'fillchars'\n    else if (varp == &p_fcs)\n    {\n\terrmsg = set_chars_option(curwin, varp);\n    }\n\n#ifdef FEAT_CMDWIN\n    // 'cedit'\n    else if (varp == &p_cedit)\n    {\n\terrmsg = check_cedit();\n    }\n#endif\n\n    // 'verbosefile'\n    else if (varp == &p_vfile)\n    {\n\tverbose_stop();\n\tif (*p_vfile != NUL && verbose_open() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_VIMINFO\n    // 'viminfo'\n    else if (varp == &p_viminfo)\n    {\n\tfor (s = p_viminfo; *s;)\n\t{\n\t    // Check it's a valid character\n\t    if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*s == 'n')\t// name is always last one\n\t\tbreak;\n\t    else if (*s == 'r') // skip until next ','\n\t    {\n\t\twhile (*++s && *s != ',')\n\t\t    ;\n\t    }\n\t    else if (*s == '%')\n\t    {\n\t\t// optional number\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\t    }\n\t    else if (*s == '!' || *s == 'h' || *s == 'c')\n\t\t++s;\t\t// no extra chars\n\t    else\t\t// must have a number\n\t    {\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\n\t\tif (!VIM_ISDIGIT(*(s - 1)))\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf(errbuf, _(\"E526: Missing number after <%s>\"),\n\t\t\t\t\t\t    transchar_byte(*(s - 1)));\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = \"\";\n\t\t    break;\n\t\t}\n\t    }\n\t    if (*s == ',')\n\t\t++s;\n\t    else if (*s)\n\t    {\n\t\tif (errbuf != NULL)\n\t\t    errmsg = N_(\"E527: Missing comma\");\n\t\telse\n\t\t    errmsg = \"\";\n\t\tbreak;\n\t    }\n\t}\n\tif (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\\'') < 0)\n\t    errmsg = N_(\"E528: Must specify a ' value\");\n    }\n#endif // FEAT_VIMINFO\n\n    // terminal options\n    else if (istermoption_idx(opt_idx) && full_screen)\n    {\n\t// \":set t_Co=0\" and \":set t_Co=1\" do \":set t_Co=\"\n\tif (varp == &T_CCO)\n\t{\n\t    int colors = atoi((char *)T_CCO);\n\n\t    // Only reinitialize colors if t_Co value has really changed to\n\t    // avoid expensive reload of colorscheme if t_Co is set to the\n\t    // same value multiple times.\n\t    if (colors != t_colors)\n\t    {\n\t\tt_colors = colors;\n\t\tif (t_colors <= 1)\n\t\t{\n\t\t    if (new_value_alloced)\n\t\t\tvim_free(T_CCO);\n\t\t    T_CCO = empty_option;\n\t\t}\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\tif (is_term_win32())\n\t\t{\n\t\t    swap_tcap();\n\t\t    did_swaptcap = TRUE;\n\t\t}\n#endif\n\t\t// We now have a different color setup, initialize it again.\n\t\tinit_highlight(TRUE, FALSE);\n\t    }\n\t}\n\tttest(FALSE);\n\tif (varp == &T_ME)\n\t{\n\t    out_str(T_ME);\n\t    redraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n\t    // Since t_me has been set, this probably means that the user\n\t    // wants to use this as default colors.  Need to reset default\n\t    // background/foreground colors.\n# ifdef VIMDLL\n\t    if (!gui.in_use && !gui.starting)\n# endif\n\t\tmch_set_normal_colors();\n#endif\n\t}\n\tif (varp == &T_BE && termcap_active)\n\t{\n#ifdef FEAT_JOB_CHANNEL\n\t    ch_log_output = TRUE;\n#endif\n\t    if (*T_BE == NUL)\n\t\t// When clearing t_BE we assume the user no longer wants\n\t\t// bracketed paste, thus disable it by writing t_BD.\n\t\tout_str(T_BD);\n\t    else\n\t\tout_str(T_BE);\n\t}\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'showbreak'\n    else if (gvarp == &p_sbr)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    if (ptr2cells(s) != 1)\n\t\terrmsg = N_(\"E595: 'showbreak' contains unprintable or wide character\");\n\t    MB_PTR_ADV(s);\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    // 'guifont'\n    else if (varp == &p_guifont)\n    {\n\tif (gui.in_use)\n\t{\n\t    p = p_guifont;\n# if defined(FEAT_GUI_GTK)\n\t    // Put up a font dialog and let the user select a new value.\n\t    // If this is cancelled go back to the old value but don't\n\t    // give an error message.\n\t    if (STRCMP(p, \"*\") == 0)\n\t    {\n\t\tp = gui_mch_font_dialog(oldval);\n\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_guifont);\n\n\t\tp_guifont = (p != NULL) ? p : vim_strsave(oldval);\n\t\tnew_value_alloced = TRUE;\n\t    }\n# endif\n\t    if (p != NULL && gui_init_font(p_guifont, FALSE) != OK)\n\t    {\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_PHOTON)\n\t\tif (STRCMP(p_guifont, \"*\") == 0)\n\t\t{\n\t\t    // Dialog was cancelled: Keep the old value without giving\n\t\t    // an error message.\n\t\t    if (new_value_alloced)\n\t\t\tfree_string_option(p_guifont);\n\t\t    p_guifont = vim_strsave(oldval);\n\t\t    new_value_alloced = TRUE;\n\t\t}\n\t\telse\n# endif\n\t\t    errmsg = N_(\"E596: Invalid font(s)\");\n\t    }\n\t}\n\tredraw_gui_only = TRUE;\n    }\n# ifdef FEAT_XFONTSET\n    else if (varp == &p_guifontset)\n    {\n\tif (STRCMP(p_guifontset, \"*\") == 0)\n\t    errmsg = N_(\"E597: can't select fontset\");\n\telse if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)\n\t    errmsg = N_(\"E598: Invalid fontset\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n    else if (varp == &p_guifontwide)\n    {\n\tif (STRCMP(p_guifontwide, \"*\") == 0)\n\t    errmsg = N_(\"E533: can't select wide font\");\n\telse if (gui_get_wide_font() == FAIL)\n\t    errmsg = N_(\"E534: Invalid wide font\");\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    // 'guicursor'\n    else if (varp == &p_guicursor)\n\terrmsg = parse_shape_opt(SHAPE_CURSOR);\n#endif\n\n#ifdef FEAT_MOUSESHAPE\n    // 'mouseshape'\n    else if (varp == &p_mouseshape)\n    {\n\terrmsg = parse_shape_opt(SHAPE_MOUSE);\n\tupdate_mouseshape(-1);\n    }\n#endif\n\n#ifdef FEAT_PRINTER\n    else if (varp == &p_popt)\n\terrmsg = parse_printoptions();\n# if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_pmfn)\n\terrmsg = parse_printmbfont();\n# endif\n#endif\n\n#ifdef FEAT_LANGMAP\n    // 'langmap'\n    else if (varp == &p_langmap)\n\tlangmap_set();\n#endif\n\n#ifdef FEAT_LINEBREAK\n    // 'breakat'\n    else if (varp == &p_breakat)\n\tfill_breakat_flags();\n#endif\n\n#ifdef FEAT_TITLE\n    // 'titlestring' and 'iconstring'\n    else if (varp == &p_titlestring || varp == &p_iconstring)\n    {\n# ifdef FEAT_STL_OPT\n\tint\tflagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n\t// NULL => statusline syntax\n\tif (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n\t    stl_syntax |= flagval;\n\telse\n\t    stl_syntax &= ~flagval;\n# endif\n\tdid_set_title();\n    }\n#endif\n\n#ifdef FEAT_GUI\n    // 'guioptions'\n    else if (varp == &p_go)\n    {\n\tgui_init_which_components(oldval);\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_GUI_TABLINE)\n    // 'guitablabel'\n    else if (varp == &p_gtl)\n    {\n\tredraw_tabline = TRUE;\n\tredraw_gui_only = TRUE;\n    }\n    // 'guitabtooltip'\n    else if (varp == &p_gtt)\n    {\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    // 'ttymouse'\n    else if (varp == &p_ttym)\n    {\n\t// Switch the mouse off before changing the escape sequences used for\n\t// that.\n\tmch_setmouse(FALSE);\n\tif (opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    check_mouse_termcode();\n\tif (termcap_active)\n\t    setmouse();\t\t// may switch it on again\n    }\n#endif\n\n    // 'selection'\n    else if (varp == &p_sel)\n    {\n\tif (*p_sel == NUL\n\t\t|| check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'selectmode'\n    else if (varp == &p_slm)\n    {\n\tif (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_BROWSE\n    // 'browsedir'\n    else if (varp == &p_bsdir)\n    {\n\tif (check_opt_strings(p_bsdir, p_bsdir_values, FALSE) != OK\n\t\t&& !mch_isdir(p_bsdir))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'keymodel'\n    else if (varp == &p_km)\n    {\n\tif (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n\t    km_startsel = (vim_strchr(p_km, 'a') != NULL);\n\t}\n    }\n\n    // 'mousemodel'\n    else if (varp == &p_mousem)\n    {\n\tif (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU) && (XmVersion <= 1002)\n\telse if (*p_mousem != *oldval)\n\t    // Changed from \"extend\" to \"popup\" or \"popup_setpos\" or vv: need\n\t    // to create or delete the popup menus.\n\t    gui_motif_update_mousemodel(root_menu);\n#endif\n    }\n\n    // 'switchbuf'\n    else if (varp == &p_swb)\n    {\n\tif (opt_strings_flags(p_swb, p_swb_values, &swb_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'debug'\n    else if (varp == &p_debug)\n    {\n\tif (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'display'\n    else if (varp == &p_dy)\n    {\n\tif (opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    (void)init_chartab();\n\n    }\n\n    // 'eadirection'\n    else if (varp == &p_ead)\n    {\n\tif (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // 'clipboard'\n    else if (varp == &p_cb)\n\terrmsg = check_clipboard_option();\n#endif\n\n#ifdef FEAT_SPELL\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    else if (varp == &(curwin->w_s->b_p_spl)\n\t    || varp == &(curwin->w_s->b_p_spf))\n    {\n\tint\tis_spellfile = varp == &(curwin->w_s->b_p_spf);\n\n\tif ((is_spellfile && !valid_spellfile(*varp))\n\t    || (!is_spellfile && !valid_spelllang(*varp)))\n\t    errmsg = e_invarg;\n\telse\n\t    errmsg = did_set_spell_option(is_spellfile);\n    }\n    // When 'spellcapcheck' is set compile the regexp program.\n    else if (varp == &(curwin->w_s->b_p_spc))\n    {\n\terrmsg = compile_cap_prog(curwin->w_s);\n    }\n    // 'spelloptions'\n    else if (varp == &(curwin->w_s->b_p_spo))\n    {\n\tif (**varp != NUL && STRCMP(\"camel\", *varp) != 0)\n\t    errmsg = e_invarg;\n    }\n    // 'spellsuggest'\n    else if (varp == &p_sps)\n    {\n\tif (spell_check_sps() != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'mkspellmem'\n    else if (varp == &p_msm)\n    {\n\tif (spell_check_msm() != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // When 'bufhidden' is set, check for valid value.\n    else if (gvarp == &p_bh)\n    {\n\tif (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // When 'buftype' is set, check for valid value.\n    else if (gvarp == &p_bt)\n    {\n\tif (check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    if (curwin->w_status_height)\n\t    {\n\t\tcurwin->w_redr_status = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t}\n    }\n\n#ifdef FEAT_STL_OPT\n    // 'statusline' or 'rulerformat'\n    else if (gvarp == &p_stl || varp == &p_ruf)\n    {\n\tint wid;\n\n\tif (varp == &p_ruf)\t// reset ru_wid first\n\t    ru_wid = 0;\n\ts = *varp;\n\tif (varp == &p_ruf && *s == '%')\n\t{\n\t    // set ru_wid if 'ruf' starts with \"%99(\"\n\t    if (*++s == '-')\t// ignore a '-'\n\t\ts++;\n\t    wid = getdigits(&s);\n\t    if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n\t\tru_wid = wid;\n\t    else\n\t\terrmsg = check_stl_option(p_ruf);\n\t}\n\t// check 'statusline' only if it doesn't start with \"%!\"\n\telse if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n\t    errmsg = check_stl_option(s);\n\tif (varp == &p_ruf && errmsg == NULL)\n\t    comp_col();\n    }\n#endif\n\n    // check if it is a valid value for 'complete' -- Acevedo\n    else if (gvarp == &p_cpt)\n    {\n\tfor (s = *varp; *s;)\n\t{\n\t    while (*s == ',' || *s == ' ')\n\t\ts++;\n\t    if (!*s)\n\t\tbreak;\n\t    if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*++s != NUL && *s != ',' && *s != ' ')\n\t    {\n\t\tif (s[-1] == 'k' || s[-1] == 's')\n\t\t{\n\t\t    // skip optional filename after 'k' and 's'\n\t\t    while (*s && *s != ',' && *s != ' ')\n\t\t    {\n\t\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t\t    ++s;\n\t\t\t++s;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t     _(\"E535: Illegal character after <%c>\"),\n\t\t\t\t     *--s);\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = \"\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    // 'completeopt'\n    else if (varp == &p_cot)\n    {\n\tif (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    completeopt_was_set();\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // 'completeslash'\n    else if (gvarp == &p_csl)\n    {\n\tif (check_opt_strings(p_csl, p_csl_values, FALSE) != OK\n\t\t|| check_opt_strings(curbuf->b_p_csl, p_csl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SIGNS\n    // 'signcolumn'\n    else if (varp == &curwin->w_p_scl)\n    {\n\tif (check_opt_strings(*varp, p_scl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\t// When changing the 'signcolumn' to or from 'number', recompute the\n\t// width of the number column if 'number' or 'relativenumber' is set.\n\tif (((*oldval == 'n' && *(oldval + 1) == 'u')\n\t\t|| (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) =='u'))\n\t\t&& (curwin->w_p_nu || curwin->w_p_rnu))\n\t    curwin->w_nrwidth_line_count = 0;\n    }\n#endif\n\n\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\n    // 'toolbar'\n    else if (varp == &p_toolbar)\n    {\n\tif (opt_strings_flags(p_toolbar, p_toolbar_values,\n\t\t\t      &toolbar_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    // 'toolbariconsize': GTK+ 2 only\n    else if (varp == &p_tbis)\n    {\n\tif (opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n    // 'pastetoggle': translate key codes like in a mapping\n    else if (varp == &p_pt)\n    {\n\tif (*p_pt)\n\t{\n\t    (void)replace_termcodes(p_pt, &p,\n\t\t\t\t      REPTERM_FROM_PART | REPTERM_DO_LT, NULL);\n\t    if (p != NULL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_pt);\n\t\tp_pt = p;\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t}\n    }\n\n    // 'backspace'\n    else if (varp == &p_bs)\n    {\n\tif (VIM_ISDIGIT(*p_bs))\n\t{\n\t    if (*p_bs > '3' || p_bs[1] != NUL)\n\t\terrmsg = e_invarg;\n\t}\n\telse if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    else if (varp == &p_bo)\n    {\n\tif (opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'tagcase'\n    else if (gvarp == &p_tc)\n    {\n\tunsigned int\t*flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    p = curbuf->b_p_tc;\n\t    flags = &curbuf->b_tc_flags;\n\t}\n\telse\n\t{\n\t    p = p_tc;\n\t    flags = &tc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *p == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse if (*p == NUL\n\t\t|| opt_strings_flags(p, p_tc_values, flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'casemap'\n    else if (varp == &p_cmp)\n    {\n\tif (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_DIFF\n    // 'diffopt'\n    else if (varp == &p_dip)\n    {\n\tif (diffopt_changed() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldmethod'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdm)\n    {\n\tif (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n\t\t|| *curwin->w_p_fdm == NUL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    foldUpdateAll(curwin);\n\t    if (foldmethodIsDiff(curwin))\n\t\tnewFoldLevel();\n\t}\n    }\n# ifdef FEAT_EVAL\n    // 'foldexpr'\n    else if (varp == &curwin->w_p_fde)\n    {\n\tif (foldmethodIsExpr(curwin))\n\t    foldUpdateAll(curwin);\n    }\n# endif\n    // 'foldmarker'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fmr)\n    {\n\tp = vim_strchr(*varp, ',');\n\tif (p == NULL)\n\t    errmsg = N_(\"E536: comma required\");\n\telse if (p == *varp || p[1] == NUL)\n\t    errmsg = e_invarg;\n\telse if (foldmethodIsMarker(curwin))\n\t    foldUpdateAll(curwin);\n    }\n    // 'commentstring'\n    else if (gvarp == &p_cms)\n    {\n\tif (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n\t    errmsg = N_(\"E537: 'commentstring' must be empty or contain %s\");\n    }\n    // 'foldopen'\n    else if (varp == &p_fdo)\n    {\n\tif (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'foldclose'\n    else if (varp == &p_fcl)\n    {\n\tif (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'foldignore'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdi)\n    {\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n#endif\n\n    // 'virtualedit'\n    else if (gvarp == &p_ve)\n    {\n\tchar_u\t\t*ve = p_ve;\n\tunsigned int\t*flags = &ve_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    ve = curwin->w_p_ve;\n\t    flags = &curwin->w_ve_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *ve == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(ve, p_ve_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    else if (STRCMP(p_ve, oldval) != 0)\n\t    {\n\t\t// Recompute cursor position in case the new 've' setting\n\t\t// changes something.\n\t\tvalidate_virtcol();\n\t\tcoladvance(curwin->w_virtcol);\n\t    }\n\t}\n    }\n\n#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)\n    else if (varp == &p_csqf)\n    {\n\tif (p_csqf != NULL)\n\t{\n\t    p = p_csqf;\n\t    while (*p != NUL)\n\t    {\n\t\tif (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n\t\t\t|| p[1] == NUL\n\t\t\t|| vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n\t\t\t|| (p[2] != NUL && p[2] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\telse if (p[2] == NUL)\n\t\t    break;\n\t\telse\n\t\t    p += 3;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_CINDENT\n    // 'cinoptions'\n    else if (gvarp == &p_cino)\n    {\n\t// TODO: recognize errors\n\tparse_cino(curbuf);\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    // 'renderoptions'\n    else if (varp == &p_rop)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    value_changed = STRCMP(oldval, *varp) != 0;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    value_changed = STRCMP(oldval, *varp) != 0;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n    }\n#endif\n\n#ifdef FEAT_TERMINAL\n    // 'termwinkey'\n    else if (varp == &curwin->w_p_twk)\n    {\n\tif (*curwin->w_p_twk != NUL\n\t\t\t\t  && string_to_key(curwin->w_p_twk, TRUE) == 0)\n\t    errmsg = e_invarg;\n    }\n    // 'termwinsize'\n    else if (varp == &curwin->w_p_tws)\n    {\n\tif (*curwin->w_p_tws != NUL)\n\t{\n\t    p = skipdigits(curwin->w_p_tws);\n\t    if (p == curwin->w_p_tws\n\t\t    || (*p != 'x' && *p != '*')\n\t\t    || *skipdigits(p + 1) != NUL)\n\t\terrmsg = e_invarg;\n\t}\n    }\n    // 'wincolor'\n    else if (varp == &curwin->w_p_wcr)\n    {\n\tif (curwin->w_buffer->b_term != NULL)\n\t    term_update_colors(curwin->w_buffer->b_term);\n    }\n# if defined(MSWIN)\n    // 'termwintype'\n    else if (varp == &p_twt)\n    {\n\tif (check_opt_strings(*varp, p_twt_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n# endif\n#endif\n\n#ifdef FEAT_VARTABS\n    // 'varsofttabstop'\n    else if (varp == &(curbuf->b_p_vsts))\n    {\n\tchar_u *cp;\n\n\tif (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1]))\n\t{\n\t    if (curbuf->b_p_vsts_array)\n\t    {\n\t\tvim_free(curbuf->b_p_vsts_array);\n\t\tcurbuf->b_p_vsts_array = 0;\n\t    }\n\t}\n\telse\n\t{\n\t    for (cp = *varp; *cp; ++cp)\n\t    {\n\t\tif (vim_isdigit(*cp))\n\t\t    continue;\n\t\tif (*cp == ',' && cp > *varp && *(cp-1) != ',')\n\t\t    continue;\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (errmsg == NULL)\n\t    {\n\t\tint *oldarray = curbuf->b_p_vsts_array;\n\t\tif (tabstop_set(*varp, &(curbuf->b_p_vsts_array)))\n\t\t{\n\t\t    if (oldarray)\n\t\t\tvim_free(oldarray);\n\t\t}\n\t\telse\n\t\t    errmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    // 'vartabstop'\n    else if (varp == &(curbuf->b_p_vts))\n    {\n\tchar_u *cp;\n\n\tif (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1]))\n\t{\n\t    if (curbuf->b_p_vts_array)\n\t    {\n\t\tvim_free(curbuf->b_p_vts_array);\n\t\tcurbuf->b_p_vts_array = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    for (cp = *varp; *cp; ++cp)\n\t    {\n\t\tif (vim_isdigit(*cp))\n\t\t    continue;\n\t\tif (*cp == ',' && cp > *varp && *(cp-1) != ',')\n\t\t    continue;\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (errmsg == NULL)\n\t    {\n\t\tint *oldarray = curbuf->b_p_vts_array;\n\n\t\tif (tabstop_set(*varp, &(curbuf->b_p_vts_array)))\n\t\t{\n\t\t    vim_free(oldarray);\n#ifdef FEAT_FOLDING\n\t\t    if (foldmethodIsIndent(curwin))\n\t\t\tfoldUpdateAll(curwin);\n#endif\n\t\t}\n\t\telse\n\t\t    errmsg = e_invarg;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // 'previewpopup'\n    else if (varp == &p_pvp)\n    {\n\tif (parse_previewpopup(NULL) == FAIL)\n\t    errmsg = e_invarg;\n    }\n# ifdef FEAT_QUICKFIX\n    // 'completepopup'\n    else if (varp == &p_cpp)\n    {\n\tif (parse_completepopup(NULL) == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t    popup_close_info();\n    }\n# endif\n#endif\n\n#ifdef FEAT_QUICKFIX\n    else if (varp == &p_qftf)\n    {\n\tif (qf_process_qftf_option() == FALSE)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // Options that are a list of flags.\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww) // 'whichwrap'\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm) // 'shortmess'\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo)) // 'cpoptions'\n\t    p = (char_u *)CPO_ALL;\n\telse if (varp == &(curbuf->b_p_fo)) // 'formatoptions'\n\t    p = (char_u *)FO_ALL;\n#ifdef FEAT_CONCEAL\n\telse if (varp == &curwin->w_p_cocu) // 'concealcursor'\n\t    p = (char_u *)COCU_ALL;\n#endif\n\telse if (varp == &p_mouse) // 'mouse'\n\t{\n\t    p = (char_u *)MOUSE_ALL;\n\t}\n#if defined(FEAT_GUI)\n\telse if (varp == &p_go) // 'guioptions'\n\t    p = (char_u *)GO_ALL;\n#endif\n\tif (p != NULL)\n\t{\n\t    for (s = *varp; *s; ++s)\n\t\tif (vim_strchr(p, *s) == NULL)\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t}\n    }\n\n    // If error detected, restore the previous value.\n    if (errmsg != NULL)\n    {\n\tif (new_value_alloced)\n\t    free_string_option(*varp);\n\t*varp = oldval;\n\t// When resetting some values, need to act on it.\n\tif (did_chartab)\n\t    (void)init_chartab();\n\tif (varp == &p_hl)\n\t    (void)highlight_changed();\n    }\n    else\n    {\n#ifdef FEAT_EVAL\n\t// Remember where the option was set.\n\tset_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\t// Free string options that are in allocated memory.\n\t// Use \"free_oldval\", because recursiveness may change the flags under\n\t// our fingers (esp. init_highlight()).\n\tif (free_oldval)\n\t    free_string_option(oldval);\n\tif (new_value_alloced)\n\t    set_option_flag(opt_idx, P_ALLOCED);\n\telse\n\t    clear_option_flag(opt_idx, P_ALLOCED);\n\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t&& is_global_local_option(opt_idx))\n\t{\n\t    // global option with local value set to use global value; free\n\t    // the local value and make it empty\n\t    p = get_option_varp_scope(opt_idx, OPT_LOCAL);\n\t    free_string_option(*(char_u **)p);\n\t    *(char_u **)p = empty_option;\n\t}\n\n\t// May set global value for local option.\n\telse if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n\t    set_string_option_global(opt_idx, varp);\n\n\t// Trigger the autocommand only after setting the flags.\n#ifdef FEAT_SYN_HL\n\t// When 'syntax' is set, load the syntax of that name\n\tif (varp == &(curbuf->b_p_syn))\n\t{\n\t    static int syn_recursive = 0;\n\n\t    ++syn_recursive;\n\t    // Only pass TRUE for \"force\" when the value changed or not used\n\t    // recursively, to avoid endless recurrence.\n\t    apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn, curbuf->b_fname,\n\t\t    value_changed || syn_recursive == 1, curbuf);\n\t    curbuf->b_flags |= BF_SYN_SET;\n\t    --syn_recursive;\n\t}\n#endif\n\telse if (varp == &(curbuf->b_p_ft))\n\t{\n\t    // 'filetype' is set, trigger the FileType autocommand.\n\t    // Skip this when called from a modeline and the filetype was\n\t    // already set to this value.\n\t    if (!(opt_flags & OPT_MODELINE) || value_changed)\n\t    {\n\t\tstatic int  ft_recursive = 0;\n\t\tint\t    secure_save = secure;\n\n\t\t// Reset the secure flag, since the value of 'filetype' has\n\t\t// been checked to be safe.\n\t\tsecure = 0;\n\n\t\t++ft_recursive;\n\t\tdid_filetype = TRUE;\n\t\t// Only pass TRUE for \"force\" when the value changed or not\n\t\t// used recursively, to avoid endless recurrence.\n\t\tapply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n\t\t\t\t   value_changed || ft_recursive == 1, curbuf);\n\t\t--ft_recursive;\n\t\t// Just in case the old \"curbuf\" is now invalid.\n\t\tif (varp != &(curbuf->b_p_ft))\n\t\t    varp = NULL;\n\n\t\tsecure = secure_save;\n\t    }\n\t}\n#ifdef FEAT_SPELL\n\tif (varp == &(curwin->w_s->b_p_spl))\n\t{\n\t    char_u\tfname[200];\n\t    char_u\t*q = curwin->w_s->b_p_spl;\n\n\t    // Skip the first name if it is \"cjk\".\n\t    if (STRNCMP(q, \"cjk,\", 4) == 0)\n\t\tq += 4;\n\n\t    // Source the spell/LANG.vim in 'runtimepath'.\n\t    // They could set 'spellcapcheck' depending on the language.\n\t    // Use the first name in 'spelllang' up to '_region' or\n\t    // '.encoding'.\n\t    for (p = q; *p != NUL; ++p)\n\t\tif (!ASCII_ISALNUM(*p) && *p != '-')\n\t\t    break;\n\t    if (p > q)\n\t    {\n\t\tvim_snprintf((char *)fname, 200, \"spell/%.*s.vim\",\n\t\t\t\t\t\t\t      (int)(p - q), q);\n\t\tsource_runtime(fname, DIP_ALL);\n\t    }\n\t}\n#endif\n    }\n\n    if (varp == &p_mouse)\n    {\n\tif (*p_mouse == NUL)\n\t    mch_setmouse(FALSE);    // switch mouse off\n\telse\n\t    setmouse();\t\t    // in case 'mouse' changed\n    }\n\n#if defined(FEAT_LUA) || defined(PROTO)\n    if (varp == &p_rtp)\n\tupdate_package_paths_in_lua();\n#endif\n\n    if (curwin->w_curswant != MAXCOL\n\t\t   && (get_option_flags(opt_idx) & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n    {\n#ifdef FEAT_GUI\n\t// check redraw when it's not a GUI option or the GUI is active.\n\tif (!redraw_gui_only || gui.in_use)\n#endif\n\t    check_redraw(get_option_flags(opt_idx));\n    }\n\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n    if (did_swaptcap)\n    {\n\tset_termname((char_u *)\"win32\");\n\tinit_highlight(TRUE, FALSE);\n    }\n#endif\n\n    return errmsg;\n}\n\n/*\n * Check an option that can be a range of string values.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\n    static int\ncheck_opt_strings(\n    char_u\t*val,\n    char\t**values,\n    int\t\tlist)\t    // when TRUE: accept a list of values\n{\n    return opt_strings_flags(val, values, NULL, list);\n}\n\n/*\n * Handle an option that can be a range of string values.\n * Set a flag in \"*flagp\" for each string present.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\n    static int\nopt_strings_flags(\n    char_u\t*val,\t\t// new value\n    char\t**values,\t// array of valid string values\n    unsigned\t*flagp,\n    int\t\tlist)\t\t// when TRUE: accept a list of values\n{\n    int\t\ti;\n    int\t\tlen;\n    unsigned\tnew_flags = 0;\n\n    while (*val)\n    {\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (values[i] == NULL)\t// val not found in values[]\n\t\treturn FAIL;\n\n\t    len = (int)STRLEN(values[i]);\n\t    if (STRNCMP(values[i], val, len) == 0\n\t\t    && ((list && val[len] == ',') || val[len] == NUL))\n\t    {\n\t\tval += len + (val[len] == ',');\n\t\tnew_flags |= (1 << i);\n\t\tbreak;\t\t// check next item in val list\n\t    }\n\t}\n    }\n    if (flagp != NULL)\n\t*flagp = new_flags;\n\n    return OK;\n}\n\n/*\n * return OK if \"p\" is a valid fileformat name, FAIL otherwise.\n */\n    int\ncheck_ff_value(char_u *p)\n{\n    return check_opt_strings(p, p_ff_values, FALSE);\n}\n", "\" Test :retab\n\nfunc SetUp()\n  new\n  call setline(1, \"\\ta  \\t    b        c    \")\nendfunc\n\nfunc TearDown()\n  bwipe!\nendfunc\n\nfunc Retab(bang, n)\n  let l:old_tabstop = &tabstop\n  let l:old_line = getline(1)\n  exe \"retab\" . a:bang . a:n\n  let l:line = getline(1)\n  call setline(1, l:old_line)\n  if a:n > 0\n    \" :retab changes 'tabstop' to n with argument n > 0.\n    call assert_equal(a:n, &tabstop)\n    exe 'set tabstop=' . l:old_tabstop\n  else\n    \" :retab does not change 'tabstop' with empty or n <= 0.\n    call assert_equal(l:old_tabstop, &tabstop)\n  endif\n  return l:line\nendfunc\n\nfunc Test_retab()\n  set tabstop=8 noexpandtab\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  ''))\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  0))\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  8))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', ''))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', 0))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', 8))\n\n  call assert_equal(\"\\t\\ta\\t\\t\\tb        c    \",          Retab('',  4))\n  call assert_equal(\"\\t\\ta\\t\\t\\tb\\t\\t c\\t  \",             Retab('!', 4))\n\n  call assert_equal(\"        a\\t\\tb        c    \",        Retab('',  10))\n  call assert_equal(\"        a\\t\\tb        c    \",        Retab('!', 10))\n\n  set tabstop=8 expandtab\n  call assert_equal(\"        a           b        c    \", Retab('',  ''))\n  call assert_equal(\"        a           b        c    \", Retab('',  0))\n  call assert_equal(\"        a           b        c    \", Retab('',  8))\n  call assert_equal(\"        a           b        c    \", Retab('!', ''))\n  call assert_equal(\"        a           b        c    \", Retab('!', 0))\n  call assert_equal(\"        a           b        c    \", Retab('!', 8))\n\n  call assert_equal(\"        a           b        c    \", Retab(' ', 4))\n  call assert_equal(\"        a           b        c    \", Retab('!', 4))\n\n  call assert_equal(\"        a           b        c    \", Retab(' ', 10))\n  call assert_equal(\"        a           b        c    \", Retab('!', 10))\n\n  set tabstop=4 noexpandtab\n  call assert_equal(\"\\ta\\t\\tb        c    \",              Retab('',  ''))\n  call assert_equal(\"\\ta\\t\\tb\\t\\t c\\t  \",                 Retab('!', ''))\n  call assert_equal(\"\\t a\\t\\t\\tb        c    \",           Retab('',  3))\n  call assert_equal(\"\\t a\\t\\t\\tb\\t\\t\\tc\\t  \",             Retab('!', 3))\n  call assert_equal(\"    a\\t  b        c    \",            Retab('',  5))\n  call assert_equal(\"    a\\t  b\\t\\t c\\t \",                Retab('!', 5))\n\n  set tabstop=4 expandtab\n  call assert_equal(\"    a       b        c    \",         Retab('',  ''))\n  call assert_equal(\"    a       b        c    \",         Retab('!', ''))\n  call assert_equal(\"    a       b        c    \",         Retab('',  3))\n  call assert_equal(\"    a       b        c    \",         Retab('!', 3))\n  call assert_equal(\"    a       b        c    \",         Retab('',  5))\n  call assert_equal(\"    a       b        c    \",         Retab('!', 5))\nendfunc\n\nfunc Test_retab_error()\n  call assert_fails('retab -1',  'E487:')\n  call assert_fails('retab! -1', 'E487:')\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t\t  VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * indent.c: Indentation related functions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_VARTABS) || defined(PROTO)\n\n/*\n * Set the integer values corresponding to the string setting of 'vartabstop'.\n * \"array\" will be set, caller must free it if needed.\n * Return FAIL for an error.\n */\n    int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    semsg(_(e_invarg2), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invarg2), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\tif (n < 0 || n > 9999)\n\t{\n\t    semsg(_(e_invarg2), cp);\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}\n\n/*\n * Calculate the number of screen spaces a tab will occupy.\n * If \"vts\" is set then the tab widths are taken from that array,\n * otherwise the value of ts is used.\n */\n    int\ntabstop_padding(colnr_T col, int ts_arg, int *vts)\n{\n    int\t\tts = ts_arg == 0 ? 8 : ts_arg;\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\tpadding = 0;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn ts - (col % ts);\n\n    tabcount = vts[0];\n\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    padding = (int)(tabcol - col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((col - tabcol) % vts[tabcount]);\n\n    return padding;\n}\n\n/*\n * Find the size of the tab that covers a particular column.\n */\n    int\ntabstop_at(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int\t\ttab_size = 0;\n\n    if (vts == 0 || vts[0] == 0)\n\treturn ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t{\n\t    tab_size = vts[t];\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\ttab_size = vts[tabcount];\n\n    return tab_size;\n}\n\n/*\n * Find the column on which a tab starts.\n */\n    colnr_T\ntabstop_start(colnr_T col, int ts, int *vts)\n{\n    int\t\ttabcount;\n    colnr_T\ttabcol = 0;\n    int\t\tt;\n    int         excess;\n\n    if (vts == NULL || vts[0] == 0)\n\treturn (col / ts) * ts;\n\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > col)\n\t    return tabcol - vts[t];\n    }\n\n    excess = tabcol % vts[tabcount];\n    return excess + ((col - excess) / vts[tabcount]) * vts[tabcount];\n}\n\n/*\n * Find the number of tabs and spaces necessary to get from one column\n * to another.\n */\n    void\ntabstop_fromto(\n\tcolnr_T start_col,\n\tcolnr_T end_col,\n\tint\tts_arg,\n\tint\t*vts,\n\tint\t*ntabs,\n\tint\t*nspcs)\n{\n    int\t\tspaces = end_col - start_col;\n    colnr_T\ttabcol = 0;\n    int\t\tpadding = 0;\n    int\t\ttabcount;\n    int\t\tt;\n    int\t\tts = ts_arg == 0 ? curbuf->b_p_ts : ts_arg;\n\n    if (vts == NULL || vts[0] == 0)\n    {\n\tint tabs = 0;\n\tint initspc = 0;\n\n\tinitspc = ts - (start_col % ts);\n\tif (spaces >= initspc)\n\t{\n\t    spaces -= initspc;\n\t    tabs++;\n\t}\n\ttabs += spaces / ts;\n\tspaces -= (spaces / ts) * ts;\n\n\t*ntabs = tabs;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    // Find the padding needed to reach the next tabstop.\n    tabcount = vts[0];\n    for (t = 1; t <= tabcount; ++t)\n    {\n\ttabcol += vts[t];\n\tif (tabcol > start_col)\n\t{\n\t    padding = (int)(tabcol - start_col);\n\t    break;\n\t}\n    }\n    if (t > tabcount)\n\tpadding = vts[tabcount] - (int)((start_col - tabcol) % vts[tabcount]);\n\n    // If the space needed is less than the padding no tabs can be used.\n    if (spaces < padding)\n    {\n\t*ntabs = 0;\n\t*nspcs = spaces;\n\treturn;\n    }\n\n    *ntabs = 1;\n    spaces -= padding;\n\n    // At least one tab has been used. See if any more will fit.\n    while (spaces != 0 && ++t <= tabcount)\n    {\n\tpadding = vts[t];\n\tif (spaces < padding)\n\t{\n\t    *nspcs = spaces;\n\t    return;\n\t}\n\t++*ntabs;\n\tspaces -= padding;\n    }\n\n    *ntabs += spaces / vts[tabcount];\n    *nspcs =  spaces % vts[tabcount];\n}\n\n/*\n * See if two tabstop arrays contain the same values.\n */\n    static int\ntabstop_eq(int *ts1, int *ts2)\n{\n    int\t\tt;\n\n    if ((ts1 == 0 && ts2) || (ts1 && ts2 == 0))\n\treturn FALSE;\n    if (ts1 == ts2)\n\treturn TRUE;\n    if (ts1[0] != ts2[0])\n\treturn FALSE;\n\n    for (t = 1; t <= ts1[0]; ++t)\n\tif (ts1[t] != ts2[t])\n\t    return FALSE;\n\n    return TRUE;\n}\n\n# if defined(FEAT_BEVAL) || defined(PROTO)\n/*\n * Copy a tabstop array, allocating space for the new array.\n */\n    int *\ntabstop_copy(int *oldts)\n{\n    int\t\t*newts;\n    int\t\tt;\n\n    if (oldts == NULL)\n\treturn NULL;\n    newts = ALLOC_MULT(int, oldts[0] + 1);\n    if (newts != NULL)\n\tfor (t = 0; t <= oldts[0]; ++t)\n\t    newts[t] = oldts[t];\n    return newts;\n}\n# endif\n\n/*\n * Return a count of the number of tabstops.\n */\n    int\ntabstop_count(int *ts)\n{\n    return ts != NULL ? ts[0] : 0;\n}\n\n/*\n * Return the first tabstop, or 8 if there are no tabstops defined.\n */\n    int\ntabstop_first(int *ts)\n{\n    return ts != NULL ? ts[1] : 8;\n}\n\n#endif\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\n    long\nget_sw_value(buf_T *buf)\n{\n    return get_sw_value_col(buf, 0);\n}\n\n/*\n * Idem, using \"pos\".\n */\n    static long\nget_sw_value_pos(buf_T *buf, pos_T *pos)\n{\n    pos_T save_cursor = curwin->w_cursor;\n    long sw_value;\n\n    curwin->w_cursor = *pos;\n    sw_value = get_sw_value_col(buf, get_nolist_virtcol());\n    curwin->w_cursor = save_cursor;\n    return sw_value;\n}\n\n/*\n * Idem, using the first non-black in the current line.\n */\n    long\nget_sw_value_indent(buf_T *buf)\n{\n    pos_T pos = curwin->w_cursor;\n\n    pos.col = getwhitecols_curline();\n    return get_sw_value_pos(buf, &pos);\n}\n\n/*\n * Idem, using virtual column \"col\".\n */\n    long\nget_sw_value_col(buf_T *buf, colnr_T col UNUSED)\n{\n    return buf->b_p_sw ? buf->b_p_sw :\n#ifdef FEAT_VARTABS\n\ttabstop_at(col, buf->b_p_ts, buf->b_p_vts_array);\n#else\n\tbuf->b_p_ts;\n#endif\n}\n\n/*\n * Return the effective softtabstop value for the current buffer, using the\n * 'shiftwidth' value when 'softtabstop' is negative.\n */\n    long\nget_sts_value(void)\n{\n    return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n}\n\n/*\n * Count the size (in window cells) of the indent in the current line.\n */\n    int\nget_indent(void)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_curline(), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n/*\n * Count the size (in window cells) of the indent in line \"lnum\".\n */\n    int\nget_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Count the size (in window cells) of the indent in line \"lnum\" of buffer\n * \"buf\".\n */\n    int\nget_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}\n#endif\n\n/*\n * count the size (in window cells) of the indent in line \"ptr\", with\n * 'tabstop' at \"ts\"\n */\n    int\nget_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) // if TRUE, count only screen size for tabs\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\t// count a tab for what it is worth\n\t\tcount += ts - (count % ts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n\n#ifdef FEAT_VARTABS\n/*\n * Count the size (in window cells) of the indent in line \"ptr\", using\n * variable tabstops.\n * if \"list\" is TRUE, count only screen size for tabs.\n */\n    int\nget_indent_str_vtab(char_u *ptr, int ts, int *vts, int list)\n{\n    int\t\tcount = 0;\n\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)    // count a tab for what it is worth\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += tabstop_padding(count, ts, vts);\n\t    else\n\t\t// In list mode, when tab is not set, count screen char width\n\t\t// for Tab, displays: ^I\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t// count a space for one\n\telse\n\t    break;\n    }\n    return count;\n}\n#endif\n\n/*\n * Set the indent of the current line.\n * Leaves the cursor on the first non-blank in the line.\n * Caller must take care of undo.\n * \"flags\":\n *\tSIN_CHANGED:\tcall changed_bytes() if the line was changed.\n *\tSIN_INSERT:\tinsert the indent in front of the line.\n *\tSIN_UNDO:\tsave line for undo before changing it.\n * Returns TRUE if the line was changed.\n */\n    int\nset_indent(\n    int\t\tsize,\t\t    // measured in spaces\n    int\t\tflags)\n{\n    char_u\t*p;\n    char_u\t*newline;\n    char_u\t*oldline;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\t    // measured in characters\n    int\t\tline_len;\n    int\t\tdoit = FALSE;\n    int\t\tind_done = 0;\t    // measured in spaces\n#ifdef FEAT_VARTABS\n    int\t\tind_col = 0;\n#endif\n    int\t\ttab_pad;\n    int\t\tretval = FALSE;\n    int\t\torig_char_len = -1; // number of initial whitespace chars when\n\t\t\t\t    // 'et' and 'pi' are both set\n\n    // First check if there is anything to do and compute the number of\n    // characters needed for the indent.\n    todo = size;\n    ind_len = 0;\n    p = oldline = ml_get_curline();\n\n    // Calculate the buffer size for the new indent, and check to see if it\n    // isn't already set\n\n    // if 'expandtab' isn't set: use TABs; if both 'expandtab' and\n    // 'preserveindent' are set count the number of characters at the\n    // beginning of the line to be copied\n    if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    ind_done = 0;\n\n\t    // count as many characters as we can use\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ++ind_len;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_len;\n\t\t    ++ind_done;\n\t\t}\n\t\t++p;\n\t    }\n\n#ifdef FEAT_VARTABS\n\t    // These diverge from this point.\n\t    ind_col = ind_done;\n#endif\n\t    // Set initial number of whitespace chars to copy if we are\n\t    // preserving indent but expandtab is set\n\t    if (curbuf->b_p_et)\n\t\torig_char_len = ind_len;\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad && orig_char_len == -1)\n\t    {\n\t\tdoit = TRUE;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\t// ind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t}\n\n\t// count tabs required for indent\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= tab_pad;\n\t    ++ind_len;\n\t    ind_col += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    if (*p != TAB)\n\t\tdoit = TRUE;\n\t    else\n\t\t++p;\n\t    todo -= (int)curbuf->b_p_ts;\n\t    ++ind_len;\n\t    // ind_done += (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    // count spaces required for indent\n    while (todo > 0)\n    {\n\tif (*p != ' ')\n\t    doit = TRUE;\n\telse\n\t    ++p;\n\t--todo;\n\t++ind_len;\n\t// ++ind_done;\n    }\n\n    // Return if the indent is OK already.\n    if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))\n\treturn FALSE;\n\n    // Allocate memory for the new line.\n    if (flags & SIN_INSERT)\n\tp = oldline;\n    else\n\tp = skipwhite(p);\n    line_len = (int)STRLEN(p) + 1;\n\n    // If 'preserveindent' and 'expandtab' are both set keep the original\n    // characters and allocate accordingly.  We will fill the rest with spaces\n    // after the if (!curbuf->b_p_et) below.\n    if (orig_char_len != -1)\n    {\n\tnewline = alloc(orig_char_len + size - ind_done + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ttodo = size - ind_done;\n\tind_len = orig_char_len + todo;    // Set total length of indent in\n\t\t\t\t\t   // characters, which may have been\n\t\t\t\t\t   // undercounted until now\n\tp = oldline;\n\ts = newline;\n\twhile (orig_char_len > 0)\n\t{\n\t    *s++ = *p++;\n\t    orig_char_len--;\n\t}\n\n\t// Skip over any additional white space (useful when newindent is less\n\t// than old)\n\twhile (VIM_ISWHITE(*p))\n\t    ++p;\n\n    }\n    else\n    {\n\ttodo = size;\n\tnewline = alloc(ind_len + line_len);\n\tif (newline == NULL)\n\t    return FALSE;\n\ts = newline;\n    }\n\n    // Put the characters in the new line.\n    // if 'expandtab' isn't set: use TABs\n    if (!curbuf->b_p_et)\n    {\n\t// If 'preserveindent' is set then reuse as much as possible of\n\t// the existing indent structure for the new indent\n\tif (!(flags & SIN_INSERT) && curbuf->b_p_pi)\n\t{\n\t    p = oldline;\n\t    ind_done = 0;\n\n\t    while (todo > 0 && VIM_ISWHITE(*p))\n\t    {\n\t\tif (*p == TAB)\n\t\t{\n#ifdef FEAT_VARTABS\n\t\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\t    tab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t    // stop if this tab will overshoot the target\n\t\t    if (todo < tab_pad)\n\t\t\tbreak;\n\t\t    todo -= tab_pad;\n\t\t    ind_done += tab_pad;\n\t\t}\n\t\telse\n\t\t{\n\t\t    --todo;\n\t\t    ++ind_done;\n\t\t}\n\t\t*s++ = *p++;\n\t    }\n\n\t    // Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t    if (todo >= tab_pad)\n\t    {\n\t\t*s++ = TAB;\n\t\ttodo -= tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_done += tab_pad;\n#endif\n\t    }\n\n\t    p = skipwhite(p);\n\t}\n\n#ifdef FEAT_VARTABS\n\tfor (;;)\n\t{\n\t    tab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t    if (todo < tab_pad)\n\t\tbreak;\n\t    *s++ = TAB;\n\t    todo -= tab_pad;\n\t    ind_done += tab_pad;\n\t}\n#else\n\twhile (todo >= (int)curbuf->b_p_ts)\n\t{\n\t    *s++ = TAB;\n\t    todo -= (int)curbuf->b_p_ts;\n\t}\n#endif\n    }\n    while (todo > 0)\n    {\n\t*s++ = ' ';\n\t--todo;\n    }\n    mch_memmove(s, p, (size_t)line_len);\n\n    // Replace the line (unless undo fails).\n    if (!(flags & SIN_UNDO) || u_savesub(curwin->w_cursor.lnum) == OK)\n    {\n\tcolnr_T old_offset = (colnr_T)(p - oldline);\n\tcolnr_T new_offset = (colnr_T)(s - newline);\n\n\t// this may free \"newline\"\n\tml_replace(curwin->w_cursor.lnum, newline, FALSE);\n\tif (flags & SIN_CHANGED)\n\t    changed_bytes(curwin->w_cursor.lnum, 0);\n\n\t// Correct saved cursor position if it is in this line.\n\tif (saved_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    if (saved_cursor.col >= old_offset)\n\t\t// cursor was after the indent, adjust for the number of\n\t\t// bytes added/removed\n\t\tsaved_cursor.col += ind_len - old_offset;\n\t    else if (saved_cursor.col >= new_offset)\n\t\t// cursor was in the indent, and is now after it, put it back\n\t\t// at the start of the indent (replacing spaces with TAB)\n\t\tsaved_cursor.col = new_offset;\n\t}\n#ifdef FEAT_PROP_POPUP\n\t{\n\t    int added = ind_len - old_offset;\n\n\t    // When increasing indent this behaves like spaces were inserted at\n\t    // the old indent, when decreasing indent it behaves like spaces\n\t    // were deleted at the new indent.\n\t    adjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t  added > 0 ? old_offset : (colnr_T)ind_len, added, 0);\n\t}\n#endif\n\tretval = TRUE;\n    }\n    else\n\tvim_free(newline);\n\n    curwin->w_cursor.col = ind_len;\n    return retval;\n}\n\n/*\n * Return the indent of the current line after a number.  Return -1 if no\n * number was found.  Used for 'n' in 'formatoptions': numbered list.\n * Since a pattern is used it can actually handle more than numbers.\n */\n    int\nget_number_indent(linenr_T lnum)\n{\n    colnr_T\tcol;\n    pos_T\tpos;\n\n    regmatch_T\tregmatch;\n    int\t\tlead_len = 0;\t// length of comment leader\n\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn -1;\n    pos.lnum = 0;\n\n    // In format_lines() (i.e. not insert mode), fo+=q is needed too...\n    if ((State & INSERT) || has_format_option(FO_Q_COMS))\n\tlead_len = get_leader_len(ml_get(lnum), NULL, FALSE, TRUE);\n\n    regmatch.regprog = vim_regcomp(curbuf->b_p_flp, RE_MAGIC);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = FALSE;\n\n\t// vim_regexec() expects a pointer to a line.  This lets us\n\t// start matching for the flp beyond any comment leader...\n\tif (vim_regexec(&regmatch, ml_get(lnum) + lead_len, (colnr_T)0))\n\t{\n\t    pos.lnum = lnum;\n\t    pos.col = (colnr_T)(*regmatch.endp - ml_get(lnum));\n\t    pos.coladd = 0;\n\t}\n\tvim_regfree(regmatch.regprog);\n    }\n\n    if (pos.lnum == 0 || *ml_get_pos(&pos) == NUL)\n\treturn -1;\n    getvcol(curwin, &pos, &col, NULL, NULL);\n    return (int)col;\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * This is called when 'breakindentopt' is changed and when a window is\n * initialized.\n */\n    int\nbriopt_check(win_T *wp)\n{\n    char_u\t*p;\n    int\t\tbri_shift = 0;\n    long\tbri_min = 20;\n    int\t\tbri_sbr = FALSE;\n    int\t\tbri_list = 0;\n\n    p = wp->w_p_briopt;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"shift:\", 6) == 0\n\t\t && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))\n\t{\n\t    p += 6;\n\t    bri_shift = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"min:\", 4) == 0 && VIM_ISDIGIT(p[4]))\n\t{\n\t    p += 4;\n\t    bri_min = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"sbr\", 3) == 0)\n\t{\n\t    p += 3;\n\t    bri_sbr = TRUE;\n\t}\n\telse if (STRNCMP(p, \"list:\", 5) == 0)\n\t{\n\t    p += 5;\n\t    bri_list = getdigits(&p);\n\t}\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    wp->w_briopt_shift = bri_shift;\n    wp->w_briopt_min   = bri_min;\n    wp->w_briopt_sbr   = bri_sbr;\n    wp->w_briopt_list  = bri_list;\n\n    return OK;\n}\n\n/*\n * Return appropriate space number for breakindent, taking influencing\n * parameters into account. Window must be specified, since it is not\n * necessarily always the current one.\n */\n    int\nget_breakindent_win(\n    win_T\t*wp,\n    char_u\t*line) // start of the line\n{\n    static int\t    prev_indent = 0;  // cached indent value\n    static long\t    prev_ts     = 0L; // cached tabstop value\n    static char_u   *prev_line = NULL; // cached pointer to line\n    static varnumber_T prev_tick = 0;   // changedtick of cached value\n# ifdef FEAT_VARTABS\n    static int      *prev_vts = NULL;    // cached vartabs values\n# endif\n    int\t\t    bri = 0;\n    // window width minus window margin space, i.e. what rests for text\n    const int\t    eff_wwidth = wp->w_width\n\t\t\t    - ((wp->w_p_nu || wp->w_p_rnu)\n\t\t\t\t&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)\n\t\t\t\t\t\t? number_width(wp) + 1 : 0);\n\n    // used cached indent, unless pointer or 'tabstop' changed\n    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts\n\t    || prev_tick != CHANGEDTICK(wp->w_buffer)\n# ifdef FEAT_VARTABS\n\t    || prev_vts != wp->w_buffer->b_p_vts_array\n# endif\n\t)\n    {\n\tprev_line = line;\n\tprev_ts = wp->w_buffer->b_p_ts;\n\tprev_tick = CHANGEDTICK(wp->w_buffer);\n# ifdef FEAT_VARTABS\n\tprev_vts = wp->w_buffer->b_p_vts_array;\n\tprev_indent = get_indent_str_vtab(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array, wp->w_p_list);\n# else\n\tprev_indent = get_indent_str(line,\n\t\t\t\t     (int)wp->w_buffer->b_p_ts, wp->w_p_list);\n# endif\n    }\n    bri = prev_indent + wp->w_briopt_shift;\n\n    // Add offset for number column, if 'n' is in 'cpoptions'\n    bri += win_col_off2(wp);\n\n    // add additional indent for numbered lists\n    if (wp->w_briopt_list != 0)\n    {\n\tregmatch_T\t    regmatch;\n\n\tregmatch.regprog = vim_regcomp(curbuf->b_p_flp,\n\t\t\t\t   RE_MAGIC + RE_STRING + RE_AUTO + RE_STRICT);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = FALSE;\n\t    if (vim_regexec(&regmatch, line, 0))\n\t    {\n\t\tif (wp->w_briopt_list > 0)\n\t\t    bri += wp->w_briopt_list;\n\t\telse\n\t\t    bri = (*regmatch.endp - *regmatch.startp);\n\t    }\n\t    vim_regfree(regmatch.regprog);\n\t}\n    }\n\n    // indent minus the length of the showbreak string\n    if (wp->w_briopt_sbr)\n\tbri -= vim_strsize(get_showbreak_value(wp));\n\n\n    // never indent past left window margin\n    if (bri < 0)\n\tbri = 0;\n\n    // always leave at least bri_min characters on the left,\n    // if text width is sufficient\n    else if (bri > eff_wwidth - wp->w_briopt_min)\n\tbri = (eff_wwidth - wp->w_briopt_min < 0)\n\t\t\t\t\t   ? 0 : eff_wwidth - wp->w_briopt_min;\n\n    return bri;\n}\n#endif\n\n/*\n * When extra == 0: Return TRUE if the cursor is before or on the first\n *\t\t    non-blank in the line.\n * When extra == 1: Return TRUE if the cursor is before the first non-blank in\n *\t\t    the line.\n */\n    int\ninindent(int extra)\n{\n    char_u\t*ptr;\n    colnr_T\tcol;\n\n    for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)\n\t++ptr;\n    if (col >= curwin->w_cursor.col + extra)\n\treturn TRUE;\n    else\n\treturn FALSE;\n}\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * op_reindent - handle reindenting a block of lines.\n */\n    void\nop_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n\n    // Don't even try when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    for (i = oap->line_count; --i >= 0 && !got_int; )\n    {\n\t// it's a slow thing to do, so give feedback so there's no worry that\n\t// the computer's just hung.\n\n\tif (i > 1\n\t\t&& (i % 50 == 0 || i == oap->line_count - 1)\n\t\t&& oap->line_count > p_report)\n\t    smsg(_(\"%ld lines to indent... \"), i);\n\n\t// Be vi-compatible: For lisp indenting the first line is not\n\t// indented, unless there is only one line.\n# ifdef FEAT_LISP\n\tif (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t    || how != get_lisp_indent)\n# endif\n\t{\n\t    l = skipwhite(ml_get_curline());\n\t    if (*l == NUL)\t\t    // empty or blank line\n\t\tamount = 0;\n\t    else\n\t\tamount = how();\t\t    // get the indent for this line\n\n\t    if (amount >= 0 && set_indent(amount, SIN_UNDO))\n\t    {\n\t\t// did change the indent, call changed_lines() later\n\t\tif (first_changed == 0)\n\t\t    first_changed = curwin->w_cursor.lnum;\n\t\tlast_changed = curwin->w_cursor.lnum;\n\t    }\n\t}\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;  // make sure it's valid\n    }\n\n    // put cursor on first non-blank of indented line\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n\n    // Mark changed lines so that they will be redrawn.  When Visual\n    // highlighting was present, need to continue until the last line.  When\n    // there is no change still need to remove the Visual highlighting.\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set '[ and '] marks\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}\n#endif // defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\n    int\npreprocs_left(void)\n{\n    return\n# ifdef FEAT_SMARTINDENT\n#  ifdef FEAT_CINDENT\n\t(curbuf->b_p_si && !curbuf->b_p_cin) ||\n#  else\n\tcurbuf->b_p_si\n#  endif\n# endif\n# ifdef FEAT_CINDENT\n\t(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)\n\t\t\t\t\t   && curbuf->b_ind_hash_comment == 0)\n# endif\n\t;\n}\n#endif\n\n#ifdef FEAT_SMARTINDENT\n/*\n * Try to do some very smart auto-indenting.\n * Used when inserting a \"normal\" character.\n */\n    void\nins_try_si(int c)\n{\n    pos_T\t*pos, old_pos;\n    char_u\t*ptr;\n    int\t\ti;\n    int\t\ttemp;\n\n    // do some very smart indenting when entering '{' or '}'\n    if (((did_si || can_si_back) && c == '{') || (can_si && c == '}'))\n    {\n\t// for '}' set indent equal to indent of line containing matching '{'\n\tif (c == '}' && (pos = findmatch(NULL, '{')) != NULL)\n\t{\n\t    old_pos = curwin->w_cursor;\n\t    // If the matching '{' has a ')' immediately before it (ignoring\n\t    // white-space), then line up with the start of the line\n\t    // containing the matching '(' if there is one.  This handles the\n\t    // case where an \"if (..\\n..) {\" statement continues over multiple\n\t    // lines -- webb\n\t    ptr = ml_get(pos->lnum);\n\t    i = pos->col;\n\t    if (i > 0)\t\t// skip blanks before '{'\n\t\twhile (--i > 0 && VIM_ISWHITE(ptr[i]))\n\t\t    ;\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = i;\n\t    if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL)\n\t\tcurwin->w_cursor = *pos;\n\t    i = get_indent();\n\t    curwin->w_cursor = old_pos;\n\t    if (State & VREPLACE_FLAG)\n\t\tchange_indent(INDENT_SET, i, FALSE, NUL, TRUE);\n\t    else\n\t\t(void)set_indent(i, SIN_CHANGED);\n\t}\n\telse if (curwin->w_cursor.col > 0)\n\t{\n\t    // when inserting '{' after \"O\" reduce indent, but not\n\t    // more than indent of previous line\n\t    temp = TRUE;\n\t    if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1)\n\t    {\n\t\told_pos = curwin->w_cursor;\n\t\ti = get_indent();\n\t\twhile (curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    ptr = skipwhite(ml_get(--(curwin->w_cursor.lnum)));\n\n\t\t    // ignore empty lines and lines starting with '#'.\n\t\t    if (*ptr != '#' && *ptr != NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (get_indent() >= i)\n\t\t    temp = FALSE;\n\t\tcurwin->w_cursor = old_pos;\n\t    }\n\t    if (temp)\n\t\tshift_line(TRUE, FALSE, 1, TRUE);\n\t}\n    }\n\n    // set indent of '#' always to 0\n    if (curwin->w_cursor.col > 0 && can_si && c == '#')\n    {\n\t// remember current indent for next line\n\told_indent = get_indent();\n\t(void)set_indent(0, SIN_CHANGED);\n    }\n\n    // Adjust ai_col, the char at this position can be deleted.\n    if (ai_col > curwin->w_cursor.col)\n\tai_col = curwin->w_cursor.col;\n}\n#endif\n\n/*\n * Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).\n * Keep the cursor on the same character.\n * type == INDENT_INC\tincrease indent (for CTRL-T or <Tab>)\n * type == INDENT_DEC\tdecrease indent (for CTRL-D)\n * type == INDENT_SET\tset indent to \"amount\"\n * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).\n */\n    void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}\n\n/*\n * Copy the indent from ptr to the current line (and fill to size)\n * Leaves the cursor on the first non-blank in the line.\n * Returns TRUE if the line was changed.\n */\n    int\ncopy_indent(int size, char_u *src)\n{\n    char_u\t*p = NULL;\n    char_u\t*line = NULL;\n    char_u\t*s;\n    int\t\ttodo;\n    int\t\tind_len;\n    int\t\tline_len = 0;\n    int\t\ttab_pad;\n    int\t\tind_done;\n    int\t\tround;\n#ifdef FEAT_VARTABS\n    int\t\tind_col;\n#endif\n\n    // Round 1: compute the number of characters needed for the indent\n    // Round 2: copy the characters.\n    for (round = 1; round <= 2; ++round)\n    {\n\ttodo = size;\n\tind_len = 0;\n\tind_done = 0;\n#ifdef FEAT_VARTABS\n\tind_col = 0;\n#endif\n\ts = src;\n\n\t// Count/copy the usable portion of the source line\n\twhile (todo > 0 && VIM_ISWHITE(*s))\n\t{\n\t    if (*s == TAB)\n\t    {\n#ifdef FEAT_VARTABS\n\t\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\t\ttab_pad = (int)curbuf->b_p_ts\n\t\t\t\t\t   - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\t\t// Stop if this tab will overshoot the target\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\tind_done += tab_pad;\n#ifdef FEAT_VARTABS\n\t\tind_col += tab_pad;\n#endif\n\t    }\n\t    else\n\t    {\n\t\t--todo;\n\t\t++ind_done;\n#ifdef FEAT_VARTABS\n\t\t++ind_col;\n#endif\n\t    }\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = *s;\n\t    ++s;\n\t}\n\n\t// Fill to next tabstop with a tab, if possible\n#ifdef FEAT_VARTABS\n\ttab_pad = tabstop_padding(ind_done, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n#else\n\ttab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);\n#endif\n\tif (todo >= tab_pad && !curbuf->b_p_et)\n\t{\n\t    todo -= tab_pad;\n\t    ++ind_len;\n#ifdef FEAT_VARTABS\n\t    ind_col += tab_pad;\n#endif\n\t    if (p != NULL)\n\t\t*p++ = TAB;\n\t}\n\n\t// Add tabs required for indent\n\tif (!curbuf->b_p_et)\n\t{\n#ifdef FEAT_VARTABS\n\t    for (;;)\n\t    {\n\t\ttab_pad = tabstop_padding(ind_col, curbuf->b_p_ts,\n\t\t\t\t\t\t\tcurbuf->b_p_vts_array);\n\t\tif (todo < tab_pad)\n\t\t    break;\n\t\ttodo -= tab_pad;\n\t\t++ind_len;\n\t\tind_col += tab_pad;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#else\n\t    while (todo >= (int)curbuf->b_p_ts)\n\t    {\n\t\ttodo -= (int)curbuf->b_p_ts;\n\t\t++ind_len;\n\t\tif (p != NULL)\n\t\t    *p++ = TAB;\n\t    }\n#endif\n\t}\n\n\t// Count/add spaces required for indent\n\twhile (todo > 0)\n\t{\n\t    --todo;\n\t    ++ind_len;\n\t    if (p != NULL)\n\t\t*p++ = ' ';\n\t}\n\n\tif (p == NULL)\n\t{\n\t    // Allocate memory for the result: the copied indent, new indent\n\t    // and the rest of the line.\n\t    line_len = (int)STRLEN(ml_get_curline()) + 1;\n\t    line = alloc(ind_len + line_len);\n\t    if (line == NULL)\n\t\treturn FALSE;\n\t    p = line;\n\t}\n    }\n\n    // Append the original line\n    mch_memmove(p, ml_get_curline(), (size_t)line_len);\n\n    // Replace the line\n    ml_replace(curwin->w_cursor.lnum, line, FALSE);\n\n    // Put the cursor after the indent.\n    curwin->w_cursor.col = ind_len;\n    return TRUE;\n}\n\n/*\n * \":retab\".\n */\n    void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    new_ts = getdigits(&(eap->arg));\n    if (new_ts < 0)\n    {\n\temsg(_(e_positive));\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interr));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}\n\n#if (defined(FEAT_CINDENT) && defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get indent level from 'indentexpr'.\n */\n    int\nget_expr_indent(void)\n{\n    int\t\tindent = -1;\n    char_u\t*inde_copy;\n    pos_T\tsave_pos;\n    colnr_T\tsave_curswant;\n    int\t\tsave_set_curswant;\n    int\t\tsave_State;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"indentexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    // Save and restore cursor position and curswant, in case it was changed\n    // via :normal commands\n    save_pos = curwin->w_cursor;\n    save_curswant = curwin->w_curswant;\n    save_set_curswant = curwin->w_set_curswant;\n    set_vim_var_nr(VV_LNUM, curwin->w_cursor.lnum);\n    if (use_sandbox)\n\t++sandbox;\n    ++textwinlock;\n\n    // Need to make a copy, the 'indentexpr' option could be changed while\n    // evaluating it.\n    inde_copy = vim_strsave(curbuf->b_p_inde);\n    if (inde_copy != NULL)\n    {\n\tindent = (int)eval_to_number(inde_copy);\n\tvim_free(inde_copy);\n    }\n\n    if (use_sandbox)\n\t--sandbox;\n    --textwinlock;\n\n    // Restore the cursor position so that 'indentexpr' doesn't need to.\n    // Pretend to be in Insert mode, allow cursor past end of line for \"o\"\n    // command.\n    save_State = State;\n    State = INSERT;\n    curwin->w_cursor = save_pos;\n    curwin->w_curswant = save_curswant;\n    curwin->w_set_curswant = save_set_curswant;\n    check_cursor();\n    State = save_State;\n\n    // Reset did_throw, unless 'debug' has \"throw\" and inside a try/catch.\n    if (did_throw && (vim_strchr(p_debug, 't') == NULL || trylevel == 0))\n    {\n\thandle_did_throw();\n\tdid_throw = FALSE;\n    }\n\n    // If there is an error, just keep the current indent.\n    if (indent < 0)\n\tindent = get_indent();\n\n    return indent;\n}\n#endif\n\n#if defined(FEAT_LISP) || defined(PROTO)\n\n    static int\nlisp_match(char_u *p)\n{\n    char_u\tbuf[LSIZE];\n    int\t\tlen;\n    char_u\t*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;\n\n    while (*word != NUL)\n    {\n\t(void)copy_option_part(&word, buf, LSIZE, \",\");\n\tlen = (int)STRLEN(buf);\n\tif (STRNCMP(buf, p, len) == 0 && p[len] == ' ')\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * When 'p' is present in 'cpoptions, a Vi compatible method is used.\n * The incompatible newer method is quite a bit better at indenting\n * code in lisp-like languages than the traditional one; it's still\n * mostly heuristics however -- Dirk van Deun, dirk@rave.org\n *\n * TODO:\n * Findmatch() should be adapted for lisp, also to make showmatch\n * work correctly: now (v5.3) it seems all C/C++ oriented:\n * - it does not recognize the #\\( and #\\) notations as character literals\n * - it doesn't know about comments starting with a semicolon\n * - it incorrectly interprets '(' as a character literal\n * All this messes up get_lisp_indent in some rare cases.\n * Update from Sergey Khorev:\n * I tried to fix the first two issues.\n */\n    int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}\n#endif // FEAT_LISP\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(PROTO)\n/*\n * Re-indent the current line, based on the current contents of it and the\n * surrounding lines. Fixing the cursor position seems really easy -- I'm very\n * confused what all the part that handles Control-T is doing that I'm not.\n * \"get_the_indent\" should be get_c_indent, get_expr_indent or get_lisp_indent.\n */\n\n    void\nfixthisline(int (*get_the_indent)(void))\n{\n    int amount = get_the_indent();\n\n    if (amount >= 0)\n    {\n\tchange_indent(INDENT_SET, amount, FALSE, 0, TRUE);\n\tif (linewhite(curwin->w_cursor.lnum))\n\t    did_ai = TRUE;\t// delete the indent if the line stays empty\n    }\n}\n\n    void\nfix_indent(void)\n{\n    if (p_paste)\n\treturn;\n# ifdef FEAT_LISP\n    if (curbuf->b_p_lisp && curbuf->b_p_ai)\n\tfixthisline(get_lisp_indent);\n# endif\n# if defined(FEAT_LISP) && defined(FEAT_CINDENT)\n    else\n# endif\n# ifdef FEAT_CINDENT\n\tif (cindent_on())\n\t    do_c_expr_indent();\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"indent()\" function\n */\n    void\nf_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n\trettv->vval.v_number = -1;\n}\n\n/*\n * \"lispindent(lnum)\" function\n */\n    void\nf_lispindent(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_LISP\n    pos_T\tpos;\n    linenr_T\tlnum;\n\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = curwin->w_cursor;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tcurwin->w_cursor.lnum = lnum;\n\trettv->vval.v_number = get_lisp_indent();\n\tcurwin->w_cursor = pos;\n    }\n    else\n#endif\n\trettv->vval.v_number = -1;\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in structs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/quickref.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n * - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag, add a\n *   comment at the help for the 'compatible' option.\n */\n\n#define IN_OPTION_C\n#include \"vim.h\"\n#include \"optiondefs.h\"\n\nstatic void set_options_default(int opt_flags);\nstatic void set_string_default_esc(char *name, char_u *val, int escape);\nstatic char_u *find_dup_item(char_u *origval, char_u *newval, long_u flags);\nstatic char_u *option_expand(int opt_idx, char_u *val);\nstatic void didset_options(void);\nstatic void didset_options2(void);\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic long_u *insecure_flag(int opt_idx, int opt_flags);\n#else\n# define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)\n#endif\nstatic char *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);\nstatic char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen, int opt_flags);\nstatic int find_key_option(char_u *arg_arg, int has_lt);\nstatic void showoptions(int all, int opt_flags);\nstatic int optval_default(struct vimoption *, char_u *varp, int compatible);\nstatic void showoneopt(struct vimoption *, int opt_flags);\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, long_u flags);\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep);\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value);\nstatic int istermoption(struct vimoption *p);\nstatic char_u *get_varp_scope(struct vimoption *p, int opt_flags);\nstatic char_u *get_varp(struct vimoption *);\nstatic void check_win_options(win_T *win);\nstatic void option_value2string(struct vimoption *, int opt_flags);\nstatic void check_winopt(winopt_T *wop);\nstatic int wc_use_keyname(char_u *varp, long *wcp);\nstatic void paste_option_changed(void);\nstatic void compatible_set(void);\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n * If \"clean_arg\" is TRUE Vim was started with --clean.\n */\n    void\nset_init_1(int clean_arg)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n    long_u\tn;\n\n#ifdef FEAT_LANGMAP\n    langmap_init();\n#endif\n\n    // Be Vi compatible by default\n    p_cp = TRUE;\n\n    // Use POSIX compatibility when $VIM_POSIX is set.\n    if (mch_getenv((char_u *)\"VIM_POSIX\") != NULL)\n    {\n\tset_string_default(\"cpo\", (char_u *)CPO_ALL);\n\tset_string_default(\"shm\", (char_u *)SHM_POSIX);\n    }\n\n    /*\n     * Find default value for 'shell' option.\n     * Don't use it if it is empty.\n     */\n    if (((p = mch_getenv((char_u *)\"SHELL\")) != NULL && *p != NUL)\n#if defined(MSWIN)\n\t    || ((p = mch_getenv((char_u *)\"COMSPEC\")) != NULL && *p != NUL)\n\t    || ((p = (char_u *)default_shell()) != NULL && *p != NUL)\n#endif\n\t    )\n#if defined(MSWIN)\n    {\n\t// For MS-Windows put the path in quotes instead of escaping spaces.\n\tchar_u\t    *cmd;\n\tsize_t\t    len;\n\n\tif (vim_strchr(p, ' ') != NULL)\n\t{\n\t    len = STRLEN(p) + 3;  // two quotes and a trailing NUL\n\t    cmd = alloc(len);\n\t    if (cmd != NULL)\n\t    {\n\t\tvim_snprintf((char *)cmd, len, \"\\\"%s\\\"\", p);\n\t\tset_string_default(\"sh\", cmd);\n\t\tvim_free(cmd);\n\t    }\n\t}\n\telse\n\t    set_string_default(\"sh\", p);\n    }\n#else\n\tset_string_default_esc(\"sh\", p, TRUE);\n#endif\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Set the default for 'backupskip' to include environment variables for\n     * temp files.\n     */\n    {\n# ifdef UNIX\n\tstatic char\t*(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n\tstatic char\t*(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n\tint\t\tlen;\n\tgarray_T\tga;\n\tint\t\tmustfree;\n\tchar_u\t\t*item;\n\n\topt_idx = findoption((char_u *)\"backupskip\");\n\n\tga_init2(&ga, 1, 100);\n\tfor (n = 0; n < (long)ARRAY_LENGTH(names); ++n)\n\t{\n\t    mustfree = FALSE;\n# ifdef UNIX\n\t    if (*names[n] == NUL)\n#  ifdef MACOS_X\n\t\tp = (char_u *)\"/private/tmp\";\n#  else\n\t\tp = (char_u *)\"/tmp\";\n#  endif\n\t    else\n# endif\n\t\tp = vim_getenv((char_u *)names[n], &mustfree);\n\t    if (p != NULL && *p != NUL)\n\t    {\n\t\t// First time count the NUL, otherwise count the ','.\n\t\tlen = (int)STRLEN(p) + 3;\n\t\titem = alloc(len);\n\t\tSTRCPY(item, p);\n\t\tadd_pathsep(item);\n\t\tSTRCAT(item, \"*\");\n\t\tif (find_dup_item(ga.ga_data, item, options[opt_idx].flags)\n\t\t\t\t\t\t\t\t\t== NULL\n\t\t\t&& ga_grow(&ga, len) == OK)\n\t\t{\n\t\t    if (ga.ga_len > 0)\n\t\t\tSTRCAT(ga.ga_data, \",\");\n\t\t    STRCAT(ga.ga_data, item);\n\t\t    ga.ga_len += len;\n\t\t}\n\t\tvim_free(item);\n\t    }\n\t    if (mustfree)\n\t\tvim_free(p);\n\t}\n\tif (ga.ga_data != NULL)\n\t{\n\t    set_string_default(\"bsk\", ga.ga_data);\n\t    vim_free(ga.ga_data);\n\t}\n    }\n#endif\n\n    /*\n     * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n     */\n    opt_idx = findoption((char_u *)\"maxmemtot\");\n    if (opt_idx >= 0)\n    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\tif (options[opt_idx].def_val[VI_DEFAULT] == (char_u *)0L)\n#endif\n\t{\n#ifdef HAVE_AVAIL_MEM\n\t    // Use amount of memory available at this moment.\n\t    n = (mch_avail_mem(FALSE) >> 1);\n#else\n# ifdef HAVE_TOTAL_MEM\n\t    // Use amount of memory available to Vim.\n\t    n = (mch_total_mem(FALSE) >> 1);\n# else\n\t    n = (0x7fffffff >> 11);\n# endif\n#endif\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    opt_idx = findoption((char_u *)\"maxmem\");\n\t    if (opt_idx >= 0)\n\t    {\n#if !defined(HAVE_AVAIL_MEM) && !defined(HAVE_TOTAL_MEM)\n\t\tif ((long)(long_i)options[opt_idx].def_val[VI_DEFAULT] > (long)n\n\t\t  || (long)(long_i)options[opt_idx].def_val[VI_DEFAULT] == 0L)\n#endif\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n\t    }\n\t}\n    }\n\n#ifdef FEAT_SEARCHPATH\n    {\n\tchar_u\t*cdpath;\n\tchar_u\t*buf;\n\tint\ti;\n\tint\tj;\n\tint\tmustfree = FALSE;\n\n\t// Initialize the 'cdpath' option's default value.\n\tcdpath = vim_getenv((char_u *)\"CDPATH\", &mustfree);\n\tif (cdpath != NULL)\n\t{\n\t    buf = alloc((STRLEN(cdpath) << 1) + 2);\n\t    if (buf != NULL)\n\t    {\n\t\tbuf[0] = ',';\t    // start with \",\", current dir first\n\t\tj = 1;\n\t\tfor (i = 0; cdpath[i] != NUL; ++i)\n\t\t{\n\t\t    if (vim_ispathlistsep(cdpath[i]))\n\t\t\tbuf[j++] = ',';\n\t\t    else\n\t\t    {\n\t\t\tif (cdpath[i] == ' ' || cdpath[i] == ',')\n\t\t\t    buf[j++] = '\\\\';\n\t\t\tbuf[j++] = cdpath[i];\n\t\t    }\n\t\t}\n\t\tbuf[j] = NUL;\n\t\topt_idx = findoption((char_u *)\"cdpath\");\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    options[opt_idx].def_val[VI_DEFAULT] = buf;\n\t\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t}\n\t\telse\n\t\t    vim_free(buf); // cannot happen\n\t    }\n\t    if (mustfree)\n\t\tvim_free(cdpath);\n\t}\n    }\n#endif\n\n#if defined(FEAT_POSTSCRIPT) && (defined(MSWIN) || defined(VMS) || defined(EBCDIC) || defined(MAC) || defined(hpux))\n    // Set print encoding on platforms that don't default to latin1\n    set_string_default(\"penc\",\n# if defined(MSWIN)\n\t\t       (char_u *)\"cp1252\"\n# else\n#  ifdef VMS\n\t\t       (char_u *)\"dec-mcs\"\n#  else\n#   ifdef EBCDIC\n\t\t       (char_u *)\"ebcdic-uk\"\n#   else\n#    ifdef MAC\n\t\t       (char_u *)\"mac-roman\"\n#    else // HPUX\n\t\t       (char_u *)\"hp-roman8\"\n#    endif\n#   endif\n#  endif\n# endif\n\t\t       );\n#endif\n\n#ifdef FEAT_POSTSCRIPT\n    // 'printexpr' must be allocated to be able to evaluate it.\n    set_string_default(\"pexpr\",\n# if defined(MSWIN)\n\t    (char_u *)\"system('copy' . ' ' . v:fname_in . (&printdevice == '' ? ' LPT1:' : (' \\\"' . &printdevice . '\\\"'))) . delete(v:fname_in)\"\n# else\n#  ifdef VMS\n\t    (char_u *)\"system('print/delete' . (&printdevice == '' ? '' : ' /queue=' . &printdevice) . ' ' . v:fname_in)\"\n\n#  else\n\t    (char_u *)\"system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error\"\n#  endif\n# endif\n\t    );\n#endif\n\n    /*\n     * Set all the options (except the terminal options) to their default\n     * value.  Also set the global value for local options.\n     */\n    set_options_default(0);\n\n#ifdef CLEAN_RUNTIMEPATH\n    if (clean_arg)\n    {\n\topt_idx = findoption((char_u *)\"runtimepath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_rtp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n\topt_idx = findoption((char_u *)\"packpath\");\n\tif (opt_idx >= 0)\n\t{\n\t    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)CLEAN_RUNTIMEPATH;\n\t    p_pp = (char_u *)CLEAN_RUNTIMEPATH;\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    if (found_reverse_arg)\n\tset_option_value((char_u *)\"bg\", 0L, (char_u *)\"dark\", 0);\n#endif\n\n    curbuf->b_p_initialized = TRUE;\n    curbuf->b_p_ar = -1;\t// no local 'autoread' value\n    curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    check_buf_options(curbuf);\n    check_win_options(curwin);\n    check_options();\n\n    // Must be before option_expand(), because that one needs vim_isIDc()\n    didset_options();\n\n#ifdef FEAT_SPELL\n    // Use the current chartab for the generic chartab. This is not in\n    // didset_options() because it only depends on 'encoding'.\n    init_spell_chartab();\n#endif\n\n    /*\n     * Expand environment variables and things like \"~\" for the defaults.\n     * If option_expand() returns non-NULL the variable is expanded.  This can\n     * only happen for non-indirect options.\n     * Also set the default to the expanded value, so \":set\" does not list\n     * them.\n     * Don't set the P_ALLOCED flag, because we don't want to free the\n     * default.\n     */\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tif ((options[opt_idx].flags & P_GETTEXT)\n\t\t\t\t\t      && options[opt_idx].var != NULL)\n\t    p = (char_u *)_(*(char **)options[opt_idx].var);\n\telse\n\t    p = option_expand(opt_idx, NULL);\n\tif (p != NULL && (p = vim_strsave(p)) != NULL)\n\t{\n\t    *(char_u **)options[opt_idx].var = p;\n\t    // VIMEXP\n\t    // Defaults for all expanded options are currently the same for Vi\n\t    // and Vim.  When this changes, add some code here!  Also need to\n\t    // split P_DEF_ALLOCED in two.\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n\n    save_file_ff(curbuf);\t// Buffer is unchanged\n\n#if defined(FEAT_ARABIC)\n    // Detect use of mlterm.\n    // Mlterm is a terminal emulator akin to xterm that has some special\n    // abilities (bidi namely).\n    // NOTE: mlterm's author is being asked to 'set' a variable\n    //       instead of an environment variable due to inheritance.\n    if (mch_getenv((char_u *)\"MLTERM\") != NULL)\n\tset_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n#endif\n\n    didset_options2();\n\n# if defined(MSWIN) && defined(FEAT_GETTEXT)\n    /*\n     * If $LANG isn't set, try to get a good value for it.  This makes the\n     * right language be used automatically.  Don't do this for English.\n     */\n    if (mch_getenv((char_u *)\"LANG\") == NULL)\n    {\n\tchar\tbuf[20];\n\n\t// Could use LOCALE_SISO639LANGNAME, but it's not in Win95.\n\t// LOCALE_SABBREVLANGNAME gives us three letters, like \"enu\", we use\n\t// only the first two.\n\tn = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVLANGNAME,\n\t\t\t\t\t\t\t     (LPTSTR)buf, 20);\n\tif (n >= 2 && STRNICMP(buf, \"en\", 2) != 0)\n\t{\n\t    // There are a few exceptions (probably more)\n\t    if (STRNICMP(buf, \"cht\", 3) == 0 || STRNICMP(buf, \"zht\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_TW\");\n\t    else if (STRNICMP(buf, \"chs\", 3) == 0\n\t\t\t\t\t      || STRNICMP(buf, \"zhc\", 3) == 0)\n\t\tSTRCPY(buf, \"zh_CN\");\n\t    else if (STRNICMP(buf, \"jp\", 2) == 0)\n\t\tSTRCPY(buf, \"ja\");\n\t    else\n\t\tbuf[2] = NUL;\t\t// truncate to two-letter code\n\t    vim_setenv((char_u *)\"LANG\", (char_u *)buf);\n\t}\n    }\n# else\n#  ifdef MACOS_CONVERT\n    // Moved to os_mac_conv.c to avoid dependency problems.\n    mac_lang_init();\n#  endif\n# endif\n\n# ifdef MSWIN\n    // MS-Windows has builtin support for conversion to and from Unicode, using\n    // \"utf-8\" for 'encoding' should work best for most users.\n    p = vim_strsave((char_u *)ENC_DFLT);\n# else\n    // enc_locale() will try to find the encoding of the current locale.\n    // This works best for properly configured systems, old and new.\n    p = enc_locale();\n# endif\n    if (p != NULL)\n    {\n\tchar_u *save_enc;\n\n\t// Try setting 'encoding' and check if the value is valid.\n\t// If not, go back to the default encoding.\n\tsave_enc = p_enc;\n\tp_enc = p;\n\tif (STRCMP(p_enc, \"gb18030\") == 0)\n\t{\n\t    // We don't support \"gb18030\", but \"cp936\" is a good substitute\n\t    // for practical purposes, thus use that.  It's not an alias to\n\t    // still support conversion between gb18030 and utf-8.\n\t    p_enc = vim_strsave((char_u *)\"cp936\");\n\t    vim_free(p);\n\t}\n\tif (mb_init() == NULL)\n\t{\n\t    opt_idx = findoption((char_u *)\"encoding\");\n\t    if (opt_idx >= 0)\n\t    {\n\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_enc;\n\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t    }\n\n#if defined(MSWIN) || defined(MACOS_X) || defined(VMS)\n\t    if (STRCMP(p_enc, \"latin1\") == 0 || enc_utf8)\n\t    {\n\t\t// Adjust the default for 'isprint' and 'iskeyword' to match\n\t\t// latin1.  Also set the defaults for when 'nocompatible' is\n\t\t// set.\n\t\tset_string_option_direct((char_u *)\"isp\", -1,\n\t\t\t\t\t      ISP_LATIN1, OPT_FREE, SID_NONE);\n\t\tset_string_option_direct((char_u *)\"isk\", -1,\n\t\t\t\t\t      ISK_LATIN1, OPT_FREE, SID_NONE);\n\t\topt_idx = findoption((char_u *)\"isp\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISP_LATIN1;\n\t\topt_idx = findoption((char_u *)\"isk\");\n\t\tif (opt_idx >= 0)\n\t\t    options[opt_idx].def_val[VIM_DEFAULT] = ISK_LATIN1;\n\t\t(void)init_chartab();\n\t    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    // Win32 console: When GetACP() returns a different value from\n\t    // GetConsoleCP() set 'termencoding'.\n\t    if (\n# ifdef VIMDLL\n\t       (!gui.in_use && !gui.starting) &&\n# endif\n\t        GetACP() != GetConsoleCP())\n\t    {\n\t\tchar\tbuf[50];\n\n\t\t// Win32 console: In ConPTY, GetConsoleCP() returns zero.\n\t\t// Use an alternative value.\n\t\tif (GetConsoleCP() == 0)\n\t\t    sprintf(buf, \"cp%ld\", (long)GetACP());\n\t\telse\n\t\t    sprintf(buf, \"cp%ld\", (long)GetConsoleCP());\n\t\tp_tenc = vim_strsave((char_u *)buf);\n\t\tif (p_tenc != NULL)\n\t\t{\n\t\t    opt_idx = findoption((char_u *)\"termencoding\");\n\t\t    if (opt_idx >= 0)\n\t\t    {\n\t\t\toptions[opt_idx].def_val[VI_DEFAULT] = p_tenc;\n\t\t\toptions[opt_idx].flags |= P_DEF_ALLOCED;\n\t\t    }\n\t\t    convert_setup(&input_conv, p_tenc, p_enc);\n\t\t    convert_setup(&output_conv, p_enc, p_tenc);\n\t\t}\n\t\telse\n\t\t    p_tenc = empty_option;\n\t    }\n#endif\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    init_homedir();\n#endif\n\t}\n\telse\n\t{\n\t    vim_free(p_enc);\n\t    p_enc = save_enc;\n\t}\n    }\n\n#ifdef FEAT_MULTI_LANG\n    // Set the default for 'helplang'.\n    set_helplang_default(get_mess_lang());\n#endif\n}\n\nstatic char_u *fencs_utf8_default = (char_u *)\"ucs-bom,utf-8,default,latin1\";\n\n/*\n * Set the \"fileencodings\" option to the default value for when 'encoding' is\n * utf-8.\n */\n    void\nset_fencs_unicode()\n{\n    set_string_option_direct((char_u *)\"fencs\", -1, fencs_utf8_default,\n\t\t\t\t\t\t\t\t  OPT_FREE, 0);\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\n    static void\nset_option_default(\n    int\t\topt_idx,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tcompatible)\t// use Vi default value\n{\n    char_u\t*varp;\t\t// pointer to variable for current option\n    int\t\tdvi;\t\t// index in def_val[]\n    long_u\tflags;\n    long_u\t*flagsp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n    varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n    flags = options[opt_idx].flags;\n    if (varp != NULL)\t    // skip hidden option, nothing to do for it\n    {\n\tdvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n\tif (flags & P_STRING)\n\t{\n\t    // 'fencs' default value depends on 'encoding'\n\t    if (options[opt_idx].var == (char_u *)&p_fencs && enc_utf8)\n\t\tset_fencs_unicode();\n\t    // Use set_string_option_direct() for local options to handle\n\t    // freeing and allocating the value.\n\t    else if (options[opt_idx].indir != PV_NONE)\n\t\tset_string_option_direct(NULL, opt_idx,\n\t\t\t\t options[opt_idx].def_val[dvi], opt_flags, 0);\n\t    else\n\t    {\n\t\tif ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n\t\t    free_string_option(*(char_u **)(varp));\n\t\t*(char_u **)varp = options[opt_idx].def_val[dvi];\n\t\toptions[opt_idx].flags &= ~P_ALLOCED;\n\t    }\n\t}\n\telse if (flags & P_NUM)\n\t{\n\t    if (options[opt_idx].indir == PV_SCROLL)\n\t\twin_comp_scroll(curwin);\n\t    else\n\t    {\n\t\tlong def_val = (long)(long_i)options[opt_idx].def_val[dvi];\n\n\t\tif ((long *)varp == &curwin->w_p_so\n\t\t\t|| (long *)varp == &curwin->w_p_siso)\n\t\t    // 'scrolloff' and 'sidescrolloff' local values have a\n\t\t    // different default value than the global default.\n\t\t    *(long *)varp = -1;\n\t\telse\n\t\t    *(long *)varp = def_val;\n\t\t// May also set global value for local option.\n\t\tif (both)\n\t\t    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\tdef_val;\n\t    }\n\t}\n\telse\t// P_BOOL\n\t{\n\t    // the cast to long is required for Manx C, long_i is needed for\n\t    // MSVC\n\t    *(int *)varp = (int)(long)(long_i)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n\t    // 'modeline' defaults to off for root\n\t    if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n\t\t*(int *)varp = FALSE;\n#endif\n\t    // May also set global value for local option.\n\t    if (both)\n\t\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n\t\t\t\t\t\t\t\t*(int *)varp;\n\t}\n\n\t// The default value is not insecure.\n\tflagsp = insecure_flag(opt_idx, opt_flags);\n\t*flagsp = *flagsp & ~P_INSECURE;\n    }\n\n#ifdef FEAT_EVAL\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n * When \"opt_flags\" is non-zero skip 'encoding'.\n */\n    static void\nset_options_default(\n    int\t\topt_flags)\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\ti;\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (!(options[i].flags & P_NODEFAULT)\n\t\t&& (opt_flags == 0\n\t\t    || (options[i].var != (char_u *)&p_enc\n# if defined(FEAT_CRYPT)\n\t\t\t&& options[i].var != (char_u *)&p_cm\n\t\t\t&& options[i].var != (char_u *)&p_key\n# endif\n\t\t\t)))\n\t    set_option_default(i, opt_flags, p_cp);\n\n    // The 'scroll' option must be computed for all windows.\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\twin_comp_scroll(wp);\n#ifdef FEAT_CINDENT\n    parse_cino(curbuf);\n#endif\n}\n\n/*\n * Set the Vi-default value of a string option.\n * Used for 'sh', 'backupskip' and 'term'.\n * When \"escape\" is TRUE escape spaces with a backslash.\n */\n    static void\nset_string_default_esc(char *name, char_u *val, int escape)\n{\n    char_u\t*p;\n    int\t\topt_idx;\n\n    if (escape && vim_strchr(val, ' ') != NULL)\n\tp = vim_strsave_escaped(val, (char_u *)\" \");\n    else\n\tp = vim_strsave(val);\n    if (p != NULL)\t\t// we don't want a NULL\n    {\n\topt_idx = findoption((char_u *)name);\n\tif (opt_idx >= 0)\n\t{\n\t    if (options[opt_idx].flags & P_DEF_ALLOCED)\n\t\tvim_free(options[opt_idx].def_val[VI_DEFAULT]);\n\t    options[opt_idx].def_val[VI_DEFAULT] = p;\n\t    options[opt_idx].flags |= P_DEF_ALLOCED;\n\t}\n    }\n}\n\n    void\nset_string_default(char *name, char_u *val)\n{\n    set_string_default_esc(name, val, FALSE);\n}\n\n/*\n * For an option value that contains comma separated items, find \"newval\" in\n * \"origval\".  Return NULL if not found.\n */\n    static char_u *\nfind_dup_item(char_u *origval, char_u *newval, long_u flags)\n{\n    int\t    bs = 0;\n    size_t  newlen;\n    char_u  *s;\n\n    if (origval == NULL)\n\treturn NULL;\n\n    newlen = STRLEN(newval);\n    for (s = origval; *s != NUL; ++s)\n    {\n\tif ((!(flags & P_COMMA)\n\t\t    || s == origval\n\t\t    || (s[-1] == ',' && !(bs & 1)))\n\t\t&& STRNCMP(s, newval, newlen) == 0\n\t\t&& (!(flags & P_COMMA)\n\t\t    || s[newlen] == ','\n\t\t    || s[newlen] == NUL))\n\t    return s;\n\t// Count backslashes.  Only a comma with an even number of backslashes\n\t// or a single backslash preceded by a comma before it is recognized as\n\t// a separator.\n\tif ((s > origval + 1\n\t\t    && s[-1] == '\\\\'\n\t\t    && s[-2] != ',')\n\t\t|| (s == origval + 1\n\t\t    && s[-1] == '\\\\'))\n\t    ++bs;\n\telse\n\t    bs = 0;\n    }\n    return NULL;\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\n    void\nset_number_default(char *name, long val)\n{\n    int\t\topt_idx;\n\n    opt_idx = findoption((char_u *)name);\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n}\n\n/*\n * Set all window-local and buffer-local options to the Vim default.\n * local-global options will use the global value.\n * When \"do_buffer\" is FALSE don't set buffer-local options.\n */\n    void\nset_local_options_default(win_T *wp, int do_buffer)\n{\n    win_T\t*save_curwin = curwin;\n    int\t\ti;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    block_autocmds();\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tstruct vimoption    *p = &(options[i]);\n\tchar_u\t\t    *varp = get_varp_scope(p, OPT_LOCAL);\n\n\tif (p->indir != PV_NONE\n\t\t&& (do_buffer || (p->indir & PV_BUF) == 0)\n\t\t&& !(options[i].flags & P_NODEFAULT)\n\t\t&& !optval_default(p, varp, FALSE))\n\t    set_option_default(i, OPT_FREE|OPT_LOCAL, FALSE);\n    }\n\n    unblock_autocmds();\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all options.\n */\n    void\nfree_all_options(void)\n{\n    int\t\ti;\n\n    for (i = 0; !istermoption_idx(i); i++)\n    {\n\tif (options[i].indir == PV_NONE)\n\t{\n\t    // global option: free value and default value.\n\t    if ((options[i].flags & P_ALLOCED) && options[i].var != NULL)\n\t\tfree_string_option(*(char_u **)options[i].var);\n\t    if (options[i].flags & P_DEF_ALLOCED)\n\t\tfree_string_option(options[i].def_val[VI_DEFAULT]);\n\t}\n\telse if (options[i].var != VAR_WIN\n\t\t&& (options[i].flags & P_STRING))\n\t    // buffer-local option: free global value\n\t    clear_string_option((char_u **)options[i].var);\n    }\n}\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\n    void\nset_init_2(void)\n{\n    int\t\tidx;\n\n    /*\n     * 'scroll' defaults to half the window height. The stored default is zero,\n     * which results in the actual value computed from the window height.\n     */\n    idx = findoption((char_u *)\"scroll\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n\tset_option_default(idx, OPT_LOCAL, p_cp);\n    comp_col();\n\n    /*\n     * 'window' is only for backwards compatibility with Vi.\n     * Default is Rows - 1.\n     */\n    if (!option_was_set((char_u *)\"window\"))\n\tp_window = Rows - 1;\n    set_number_default(\"window\", Rows - 1);\n\n    // For DOS console the default is always black.\n#if !((defined(MSWIN)) && !defined(FEAT_GUI))\n    /*\n     * If 'background' wasn't set by the user, try guessing the value,\n     * depending on the terminal name.  Only need to check for terminals\n     * with a dark background, that can handle color.\n     */\n    idx = findoption((char_u *)\"bg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET)\n\t\t\t\t\t\t && *term_bg_default() == 'd')\n    {\n\tset_string_option_direct(NULL, idx, (char_u *)\"dark\", OPT_FREE, 0);\n\t// don't mark it as set, when starting the GUI it may be\n\t// changed again\n\toptions[idx].flags &= ~P_WAS_SET;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    parse_shape_opt(SHAPE_CURSOR); // set cursor shapes from 'guicursor'\n#endif\n#ifdef FEAT_MOUSESHAPE\n    parse_shape_opt(SHAPE_MOUSE);  // set mouse shapes from 'mouseshape'\n#endif\n#ifdef FEAT_PRINTER\n    (void)parse_printoptions();\t    // parse 'printoptions' default value\n#endif\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\n    void\nset_init_3(void)\n{\n#if defined(UNIX) || defined(MSWIN)\n/*\n * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n * This is done after other initializations, where 'shell' might have been\n * set, but only if they have not been set before.\n */\n    char_u  *p;\n    int\t    idx_srr;\n    int\t    do_srr;\n# ifdef FEAT_QUICKFIX\n    int\t    idx_sp;\n    int\t    do_sp;\n# endif\n\n    idx_srr = findoption((char_u *)\"srr\");\n    if (idx_srr < 0)\n\tdo_srr = FALSE;\n    else\n\tdo_srr = !(options[idx_srr].flags & P_WAS_SET);\n# ifdef FEAT_QUICKFIX\n    idx_sp = findoption((char_u *)\"sp\");\n    if (idx_sp < 0)\n\tdo_sp = FALSE;\n    else\n\tdo_sp = !(options[idx_sp].flags & P_WAS_SET);\n# endif\n    p = get_isolated_shell_name();\n    if (p != NULL)\n    {\n\t/*\n\t * Default for p_sp is \"| tee\", for p_srr is \">\".\n\t * For known shells it is changed here to include stderr.\n\t */\n\tif (\t   fnamecmp(p, \"csh\") == 0\n\t\t|| fnamecmp(p, \"tcsh\") == 0\n# if defined(MSWIN)\t// also check with .exe extension\n\t\t|| fnamecmp(p, \"csh.exe\") == 0\n\t\t|| fnamecmp(p, \"tcsh.exe\") == 0\n# endif\n\t   )\n\t{\n# if defined(FEAT_QUICKFIX)\n\t    if (do_sp)\n\t    {\n#  ifdef MSWIN\n\t\tp_sp = (char_u *)\">&\";\n#  else\n\t\tp_sp = (char_u *)\"|& tee\";\n#  endif\n\t\toptions[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t    }\n# endif\n\t    if (do_srr)\n\t    {\n\t\tp_srr = (char_u *)\">&\";\n\t\toptions[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t    }\n\t}\n# ifdef MSWIN\n\t// Windows PowerShell output is UTF-16 with BOM so re-encode to the\n\t// current codepage.\n\telse if (   fnamecmp(p, \"powershell\") == 0\n\t\t    || fnamecmp(p, \"powershell.exe\") == 0\n\t\t)\n\t{\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n\t\t    p_sp = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\"2>&1 | Out-File -Encoding default\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t}\n#endif\n\telse\n\t    // Always use POSIX shell style redirection if we reach this\n\t    if (       fnamecmp(p, \"sh\") == 0\n\t\t    || fnamecmp(p, \"ksh\") == 0\n\t\t    || fnamecmp(p, \"mksh\") == 0\n\t\t    || fnamecmp(p, \"pdksh\") == 0\n\t\t    || fnamecmp(p, \"zsh\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta\") == 0\n\t\t    || fnamecmp(p, \"bash\") == 0\n\t\t    || fnamecmp(p, \"fish\") == 0\n\t\t    || fnamecmp(p, \"ash\") == 0\n\t\t    || fnamecmp(p, \"dash\") == 0\n\t\t    || fnamecmp(p, \"pwsh\") == 0\n# ifdef MSWIN\n\t\t    || fnamecmp(p, \"cmd\") == 0\n\t\t    || fnamecmp(p, \"sh.exe\") == 0\n\t\t    || fnamecmp(p, \"ksh.exe\") == 0\n\t\t    || fnamecmp(p, \"mksh.exe\") == 0\n\t\t    || fnamecmp(p, \"pdksh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh.exe\") == 0\n\t\t    || fnamecmp(p, \"zsh-beta.exe\") == 0\n\t\t    || fnamecmp(p, \"bash.exe\") == 0\n\t\t    || fnamecmp(p, \"cmd.exe\") == 0\n\t\t    || fnamecmp(p, \"dash.exe\") == 0\n\t\t    || fnamecmp(p, \"pwsh.exe\") == 0\n# endif\n\t\t    )\n\t    {\n# if defined(FEAT_QUICKFIX)\n\t\tif (do_sp)\n\t\t{\n#  ifdef MSWIN\n\t\t    p_sp = (char_u *)\">%s 2>&1\";\n#  else\n\t\t    if (fnamecmp(p, \"pwsh\") == 0)\n\t\t\tp_sp = (char_u *)\">%s 2>&1\";\n\t\t    else\n\t\t\tp_sp = (char_u *)\"2>&1| tee\";\n#  endif\n\t\t    options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n\t\t}\n# endif\n\t\tif (do_srr)\n\t\t{\n\t\t    p_srr = (char_u *)\">%s 2>&1\";\n\t\t    options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n\t\t}\n\t    }\n\tvim_free(p);\n    }\n#endif\n\n#if defined(MSWIN)\n    /*\n     * Set 'shellcmdflag', 'shellxquote', and 'shellquote' depending on the\n     * 'shell' option.\n     * This is done after other initializations, where 'shell' might have been\n     * set, but only if they have not been set before.\n     * Default values depend on shell (cmd.exe is default shell):\n     *\n     *\t\t\t    p_shcf\tp_sxq\n     * cmd.exe          -   \"/c\"\t\"(\"\n     * powershell.exe   -   \"-Command\"\t\"\\\"\"\n     * pwsh.exe\t\t-   \"-c\"\t\"\\\"\"\n     * \"sh\" like shells -   \"-c\"\t\"\\\"\"\n     *\n     * For Win32 p_sxq is set instead of p_shq to include shell redirection.\n     */\n    if (strstr((char *)gettail(p_sh), \"powershell\") != NULL)\n    {\n\tint\tidx_opt;\n\n\tidx_opt = findoption((char_u *)\"shcf\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u*)\"-Command\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\tidx_opt = findoption((char_u *)\"sxq\");\n\tif (idx_opt >= 0 && !(options[idx_opt].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u*)\"\\\"\";\n\t    options[idx_opt].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"sh\") != NULL)\n    {\n\tint\tidx3;\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"-c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n\n\t// Somehow Win32 requires the quotes around the redirection too\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"\\\"\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n    }\n    else if (strstr((char *)gettail(p_sh), \"cmd.exe\") != NULL)\n    {\n\tint\tidx3;\n\n\t/*\n\t * cmd.exe on Windows will strip the first and last double quote given\n\t * on the command line, e.g. most of the time things like:\n\t *   cmd /c \"my path/to/echo\" \"my args to echo\"\n\t * become:\n\t *   my path/to/echo\" \"my args to echo\n\t * when executed.\n\t *\n\t * To avoid this, set shellxquote to surround the command in\n\t * parenthesis.  This appears to make most commands work, without\n\t * breaking commands that worked previously, such as\n\t * '\"path with spaces/cmd\" \"a&b\"'.\n\t */\n\tidx3 = findoption((char_u *)\"sxq\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_sxq = (char_u *)\"(\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_sxq;\n\t}\n\n\tidx3 = findoption((char_u *)\"shcf\");\n\tif (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))\n\t{\n\t    p_shcf = (char_u *)\"/c\";\n\t    options[idx3].def_val[VI_DEFAULT] = p_shcf;\n\t}\n    }\n#endif\n\n    if (BUFEMPTY())\n    {\n\tint idx_ffs = findoption((char_u *)\"ffs\");\n\n\t// Apply the first entry of 'fileformats' to the initial buffer.\n\tif (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET))\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n#ifdef FEAT_TITLE\n    set_title_defaults();\n#endif\n}\n\n#if defined(FEAT_MULTI_LANG) || defined(PROTO)\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\n    void\nset_helplang_default(char_u *lang)\n{\n    int\t\tidx;\n\n    if (lang == NULL || STRLEN(lang) < 2)\t// safety check\n\treturn;\n    idx = findoption((char_u *)\"hlg\");\n    if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    {\n\tif (options[idx].flags & P_ALLOCED)\n\t    free_string_option(p_hlg);\n\tp_hlg = vim_strsave(lang);\n\tif (p_hlg == NULL)\n\t    p_hlg = empty_option;\n\telse\n\t{\n\t    // zh_CN becomes \"cn\", zh_TW becomes \"tw\"\n\t    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)\n\t    {\n\t\tp_hlg[0] = TOLOWER_ASC(p_hlg[3]);\n\t\tp_hlg[1] = TOLOWER_ASC(p_hlg[4]);\n\t    }\n\t    // any C like setting, such as C.UTF-8, becomes \"en\"\n\t    else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')\n\t    {\n\t\tp_hlg[0] = 'e';\n\t\tp_hlg[1] = 'n';\n\t    }\n\t    p_hlg[2] = NUL;\n\t}\n\toptions[idx].flags |= P_ALLOCED;\n    }\n}\n#endif\n\n#ifdef FEAT_TITLE\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\n    void\nset_title_defaults(void)\n{\n    int\t    idx1;\n    long    val;\n\n    /*\n     * If GUI is (going to be) used, we can always set the window title and\n     * icon name.  Saves a bit of time, because the X11 display server does\n     * not need to be contacted.\n     */\n    idx1 = findoption((char_u *)\"title\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_title();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_title = val;\n    }\n    idx1 = findoption((char_u *)\"icon\");\n    if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))\n    {\n#ifdef FEAT_GUI\n\tif (gui.starting || gui.in_use)\n\t    val = TRUE;\n\telse\n#endif\n\t    val = mch_can_restore_icon();\n\toptions[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;\n\tp_icon = val;\n    }\n}\n#endif\n\n    void\nex_set(exarg_T *eap)\n{\n    int\t\tflags = 0;\n\n    if (eap->cmdidx == CMD_setlocal)\n\tflags = OPT_LOCAL;\n    else if (eap->cmdidx == CMD_setglobal)\n\tflags = OPT_GLOBAL;\n#if defined(FEAT_EVAL) && defined(FEAT_BROWSE)\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && flags == 0)\n\tex_options(eap);\n    else\n#endif\n    {\n\tif (eap->forceit)\n\t    flags |= OPT_ONECOLUMN;\n\t(void)do_set(eap->arg, flags);\n    }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL   for \":setglobal\"\n * OPT_LOCAL    for \":setlocal\" and a modeline\n * OPT_MODELINE for a modeline\n * OPT_WINONLY  to only set window-local options\n * OPT_NOWIN\tto skip setting window-local options\n *\n * returns FAIL if an error is detected, OK otherwise\n */\n    int\ndo_set(\n    char_u\t*arg_start,\t// option string (may be written to!)\n    int\t\topt_flags)\n{\n    char_u\t*arg = arg_start;\n    int\t\topt_idx;\n    char\t*errmsg;\n    char\terrbuf[80];\n    char_u\t*startarg;\n    int\t\tprefix;\t// 1: nothing, 0: \"no\", 2: \"inv\" in front of name\n    int\t\tnextchar;\t    // next non-white char after option name\n    int\t\tafterchar;\t    // character just after option name\n    int\t\tlen;\n    int\t\ti;\n    varnumber_T\tvalue;\n    int\t\tkey;\n    long_u\tflags;\t\t    // flags for current option\n    char_u\t*varp = NULL;\t    // pointer to variable for current option\n    int\t\tdid_show = FALSE;   // already showed one value\n    int\t\tadding;\t\t    // \"opt+=arg\"\n    int\t\tprepending;\t    // \"opt^=arg\"\n    int\t\tremoving;\t    // \"opt-=arg\"\n    int\t\tcp_val = 0;\n    char_u\tkey_name[2];\n\n    if (*arg == NUL)\n    {\n\tshowoptions(0, opt_flags);\n\tdid_show = TRUE;\n\tgoto theend;\n    }\n\n    while (*arg != NUL)\t\t// loop to process all options\n    {\n\terrmsg = NULL;\n\tstartarg = arg;\t\t// remember for error message\n\n\tif (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n\t\t\t\t\t\t&& !(opt_flags & OPT_MODELINE))\n\t{\n\t    /*\n\t     * \":set all\"  show all options.\n\t     * \":set all&\" set all options to their default value.\n\t     */\n\t    arg += 3;\n\t    if (*arg == '&')\n\t    {\n\t\t++arg;\n\t\t// Only for :set command set global value of local options.\n\t\tset_options_default(OPT_FREE | opt_flags);\n\t\tdidset_options();\n\t\tdidset_options2();\n\t\tredraw_all_later(CLEAR);\n\t    }\n\t    else\n\t    {\n\t\tshowoptions(1, opt_flags);\n\t\tdid_show = TRUE;\n\t    }\n\t}\n\telse if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))\n\t{\n\t    showoptions(2, opt_flags);\n\t    show_termcodes();\n\t    did_show = TRUE;\n\t    arg += 7;\n\t}\n\telse\n\t{\n\t    prefix = 1;\n\t    if (STRNCMP(arg, \"no\", 2) == 0 && STRNCMP(arg, \"novice\", 6) != 0)\n\t    {\n\t\tprefix = 0;\n\t\targ += 2;\n\t    }\n\t    else if (STRNCMP(arg, \"inv\", 3) == 0)\n\t    {\n\t\tprefix = 2;\n\t\targ += 3;\n\t    }\n\n\t    // find end of name\n\t    key = 0;\n\t    if (*arg == '<')\n\t    {\n\t\topt_idx = -1;\n\t\t// look out for <t_>;>\n\t\tif (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n\t\t    len = 5;\n\t\telse\n\t\t{\n\t\t    len = 1;\n\t\t    while (arg[len] != NUL && arg[len] != '>')\n\t\t\t++len;\n\t\t}\n\t\tif (arg[len] != '>')\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    goto skip;\n\t\t}\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\tif (arg[1] == 't' && arg[2] == '_') // could be term code\n\t\t    opt_idx = findoption(arg + 1);\n\t\targ[len++] = '>';\t\t    // restore '>'\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg + 1, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tlen = 0;\n\t\t/*\n\t\t * The two characters after \"t_\" may not be alphanumeric.\n\t\t */\n\t\tif (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\t\t    len = 4;\n\t\telse\n\t\t    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')\n\t\t\t++len;\n\t\tnextchar = arg[len];\n\t\targ[len] = NUL;\t\t\t    // put NUL after name\n\t\topt_idx = findoption(arg);\n\t\targ[len] = nextchar;\t\t    // restore nextchar\n\t\tif (opt_idx == -1)\n\t\t    key = find_key_option(arg, FALSE);\n\t    }\n\n\t    // remember character after option name\n\t    afterchar = arg[len];\n\n\t    if (in_vim9script())\n\t    {\n\t\tchar_u *p = skipwhite(arg + len);\n\n\t\t// disallow white space before =val, +=val, -=val, ^=val\n\t\tif (p > arg + len && (p[0] == '='\n\t\t\t|| (vim_strchr((char_u *)\"+-^\", p[0]) != NULL\n\t\t\t\t\t\t\t      && p[1] == '=')))\n\t\t{\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\t    arg = p;\n\t\t    startarg = p;\n\t\t    goto skip;\n\t\t}\n\t    }\n\t    else\n\t\t// skip white space, allow \":set ai  ?\", \":set hlsearch  !\"\n\t\twhile (VIM_ISWHITE(arg[len]))\n\t\t    ++len;\n\n\t    adding = FALSE;\n\t    prepending = FALSE;\n\t    removing = FALSE;\n\t    if (arg[len] != NUL && arg[len + 1] == '=')\n\t    {\n\t\tif (arg[len] == '+')\n\t\t{\n\t\t    adding = TRUE;\t\t// \"+=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '^')\n\t\t{\n\t\t    prepending = TRUE;\t\t// \"^=\"\n\t\t    ++len;\n\t\t}\n\t\telse if (arg[len] == '-')\n\t\t{\n\t\t    removing = TRUE;\t\t// \"-=\"\n\t\t    ++len;\n\t\t}\n\t    }\n\t    nextchar = arg[len];\n\n\t    if (opt_idx == -1 && key == 0)\t// found a mismatch: skip\n\t    {\n\t\tif (in_vim9script() && arg > arg_start\n\t\t\t\t  && vim_strchr((char_u *)\"!&<\", *arg) != NULL)\n\t\t    errmsg = e_no_white_space_allowed_between_option_and;\n\t\telse\n\t\t    errmsg = N_(\"E518: Unknown option\");\n\t\tgoto skip;\n\t    }\n\n\t    if (opt_idx >= 0)\n\t    {\n\t\tif (options[opt_idx].var == NULL)   // hidden option: skip\n\t\t{\n\t\t    // Only give an error message when requesting the value of\n\t\t    // a hidden option, ignore setting it.\n\t\t    if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n\t\t\t    && (!(options[opt_idx].flags & P_BOOL)\n\t\t\t\t|| nextchar == '?'))\n\t\t\terrmsg = N_(\"E519: Option not supported\");\n\t\t    goto skip;\n\t\t}\n\n\t\tflags = options[opt_idx].flags;\n\t\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    }\n\t    else\n\t    {\n\t\tflags = P_STRING;\n\t\tif (key < 0)\n\t\t{\n\t\t    key_name[0] = KEY2TERMCAP0(key);\n\t\t    key_name[1] = KEY2TERMCAP1(key);\n\t\t}\n\t\telse\n\t\t{\n\t\t    key_name[0] = KS_KEY;\n\t\t    key_name[1] = (key & 0xff);\n\t\t}\n\t    }\n\n\t    // Skip all options that are not window-local (used when showing\n\t    // an already loaded buffer in a window).\n\t    if ((opt_flags & OPT_WINONLY)\n\t\t\t  && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n\t\tgoto skip;\n\n\t    // Skip all options that are window-local (used for :vimgrep).\n\t    if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n\t\t\t\t\t   && options[opt_idx].var == VAR_WIN)\n\t\tgoto skip;\n\n\t    // Disallow changing some options from modelines.\n\t    if (opt_flags & OPT_MODELINE)\n\t    {\n\t\tif (flags & (P_SECURE | P_NO_ML))\n\t\t{\n\t\t    errmsg = N_(\"E520: Not allowed in a modeline\");\n\t\t    goto skip;\n\t\t}\n\t\tif ((flags & P_MLE) && !p_mle)\n\t\t{\n\t\t    errmsg = N_(\"E992: Not allowed in a modeline when 'modelineexpr' is off\");\n\t\t    goto skip;\n\t\t}\n#ifdef FEAT_DIFF\n\t\t// In diff mode some options are overruled.  This avoids that\n\t\t// 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n\t\t// \"wrap\" gets set.\n\t\tif (curwin->w_p_diff\n\t\t\t&& opt_idx >= 0  // shut up coverity warning\n\t\t\t&& (\n#ifdef FEAT_FOLDING\n\t\t\t    options[opt_idx].indir == PV_FDM ||\n#endif\n\t\t\t    options[opt_idx].indir == PV_WRAP))\n\t\t    goto skip;\n#endif\n\t    }\n\n#ifdef HAVE_SANDBOX\n\t    // Disallow changing some options in the sandbox\n\t    if (sandbox != 0 && (flags & P_SECURE))\n\t    {\n\t\terrmsg = e_not_allowed_in_sandbox;\n\t\tgoto skip;\n\t    }\n#endif\n\n\t    if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL)\n\t    {\n\t\targ += len;\n\t\tcp_val = p_cp;\n\t\tif (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')\n\t\t{\n\t\t    if (arg[3] == 'm')\t// \"opt&vim\": set to Vim default\n\t\t    {\n\t\t\tcp_val = FALSE;\n\t\t\targ += 3;\n\t\t    }\n\t\t    else\t\t// \"opt&vi\": set to Vi default\n\t\t    {\n\t\t\tcp_val = TRUE;\n\t\t\targ += 2;\n\t\t    }\n\t\t}\n\t\tif (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n\t\t\t&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))\n\t\t{\n\t\t    errmsg = e_trailing;\n\t\t    goto skip;\n\t\t}\n\t    }\n\n\t    /*\n\t     * allow '=' and ':' for historical reasons (MSDOS command.com\n\t     * allows only one '=' character per \"set\" command line. grrr. (jw)\n\t     */\n\t    if (nextchar == '?'\n\t\t    || (prefix == 1\n\t\t\t&& vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t&& !(flags & P_BOOL)))\n\t    {\n\t\t/*\n\t\t * print value\n\t\t */\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    did_show = TRUE;\t    // remember that we did a line\n\t\t}\n\t\tif (opt_idx >= 0)\n\t\t{\n\t\t    showoneopt(&options[opt_idx], opt_flags);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0)\n\t\t    {\n\t\t\t// Mention where the option was last set.\n\t\t\tif (varp == options[opt_idx].var)\n\t\t\t    last_set_msg(options[opt_idx].script_ctx);\n\t\t\telse if ((int)options[opt_idx].indir & PV_WIN)\n\t\t\t    last_set_msg(curwin->w_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t\telse if ((int)options[opt_idx].indir & PV_BUF)\n\t\t\t    last_set_msg(curbuf->b_p_script_ctx[\n\t\t\t\t      (int)options[opt_idx].indir & PV_MASK]);\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t    *p;\n\n\t\t    p = find_termcode(key_name);\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\terrmsg = N_(\"E846: Key code not set\");\n\t\t\tgoto skip;\n\t\t    }\n\t\t    else\n\t\t\t(void)show_one_termcode(key_name, p, TRUE);\n\t\t}\n\t\tif (nextchar != '?'\n\t\t\t&& nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t    errmsg = e_trailing;\n\t    }\n\t    else\n\t    {\n\t\tint value_is_replaced = !prepending && !adding && !removing;\n\t\tint value_checked = FALSE;\n\n\t\tif (flags & P_BOOL)\t\t    // boolean\n\t\t{\n\t\t    if (nextchar == '=' || nextchar == ':')\n\t\t    {\n\t\t\terrmsg = e_invarg;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    /*\n\t\t     * \":set opt!\": invert\n\t\t     * \":set opt&\": reset to default value\n\t\t     * \":set opt<\": reset to global value\n\t\t     */\n\t\t    if (nextchar == '!')\n\t\t\tvalue = *(int *)(varp) ^ 1;\n\t\t    else if (nextchar == '&')\n\t\t\tvalue = (int)(long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t    else if (nextchar == '<')\n\t\t    {\n\t\t\t// For 'autoread' -1 means to use global value.\n\t\t\tif ((int *)varp == &curbuf->b_p_ar\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t    value = -1;\n\t\t\telse\n\t\t\t    value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t  OPT_GLOBAL);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * \":set invopt\": invert\n\t\t\t * \":set opt\" or \":set noopt\": set or reset\n\t\t\t */\n\t\t\tif (nextchar != NUL && !VIM_ISWHITE(afterchar))\n\t\t\t{\n\t\t\t    errmsg = e_trailing;\n\t\t\t    goto skip;\n\t\t\t}\n\t\t\tif (prefix == 2)\t// inv\n\t\t\t    value = *(int *)(varp) ^ 1;\n\t\t\telse\n\t\t\t    value = prefix;\n\t\t    }\n\n\t\t    errmsg = set_bool_option(opt_idx, varp, (int)value,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t\t}\n\t\telse\t\t\t\t    // numeric or string\n\t\t{\n\t\t    if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t\t\t\t\t\t       || prefix != 1)\n\t\t    {\n\t\t\terrmsg = e_invarg;\n\t\t\tgoto skip;\n\t\t    }\n\n\t\t    if (flags & P_NUM)\t\t    // numeric\n\t\t    {\n\t\t\t/*\n\t\t\t * Different ways to set a number option:\n\t\t\t * &\t    set to default value\n\t\t\t * <\t    set to global value\n\t\t\t * <xx>\t    accept special key codes for 'wildchar'\n\t\t\t * c\t    accept any non-digit for 'wildchar'\n\t\t\t * [-]0-9   set number\n\t\t\t * other    error\n\t\t\t */\n\t\t\t++arg;\n\t\t\tif (nextchar == '&')\n\t\t\t    value = (long)(long_i)options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\telse if (nextchar == '<')\n\t\t\t{\n\t\t\t    // For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n\t\t\t    // use the global value.\n\t\t\t    if ((long *)varp == &curbuf->b_p_ul\n\t\t\t\t\t\t    && opt_flags == OPT_LOCAL)\n\t\t\t\tvalue = NO_LOCAL_UNDOLEVEL;\n\t\t\t    else\n\t\t\t\tvalue = *(long *)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL);\n\t\t\t}\n\t\t\telse if (((long *)varp == &p_wc\n\t\t\t\t    || (long *)varp == &p_wcm)\n\t\t\t\t&& (*arg == '<'\n\t\t\t\t    || *arg == '^'\n\t\t\t\t    || (*arg != NUL\n\t\t\t\t\t&& (!arg[1] || VIM_ISWHITE(arg[1]))\n\t\t\t\t\t&& !VIM_ISDIGIT(*arg))))\n\t\t\t{\n\t\t\t    value = string_to_key(arg, FALSE);\n\t\t\t    if (value == 0 && (long *)varp != &p_wcm)\n\t\t\t    {\n\t\t\t\terrmsg = e_invarg;\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (*arg == '-' || VIM_ISDIGIT(*arg))\n\t\t\t{\n\t\t\t    // Allow negative (for 'undolevels'), octal and\n\t\t\t    // hex numbers.\n\t\t\t    vim_str2nr(arg, NULL, &i, STR2NR_ALL,\n\t\t\t\t\t\t     &value, NULL, 0, TRUE);\n\t\t\t    if (i == 0 || (arg[i] != NUL\n\t\t\t\t\t\t      && !VIM_ISWHITE(arg[i])))\n\t\t\t    {\n\t\t\t\terrmsg = N_(\"E521: Number required after =\");\n\t\t\t\tgoto skip;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    errmsg = N_(\"E521: Number required after =\");\n\t\t\t    goto skip;\n\t\t\t}\n\n\t\t\tif (adding)\n\t\t\t    value = *(long *)varp + value;\n\t\t\tif (prepending)\n\t\t\t    value = *(long *)varp * value;\n\t\t\tif (removing)\n\t\t\t    value = *(long *)varp - value;\n\t\t\terrmsg = set_num_option(opt_idx, varp, value,\n\t\t\t\t\t   errbuf, sizeof(errbuf), opt_flags);\n\t\t    }\n\t\t    else if (opt_idx >= 0)\t\t    // string\n\t\t    {\n\t\t\tchar_u\t  *save_arg = NULL;\n\t\t\tchar_u\t  *s = NULL;\n\t\t\tchar_u\t  *oldval = NULL; // previous value if *varp\n\t\t\tchar_u\t  *newval;\n\t\t\tchar_u\t  *origval = NULL;\n\t\t\tchar_u\t  *origval_l = NULL;\n\t\t\tchar_u\t  *origval_g = NULL;\n#if defined(FEAT_EVAL)\n\t\t\tchar_u\t  *saved_origval = NULL;\n\t\t\tchar_u\t  *saved_origval_l = NULL;\n\t\t\tchar_u\t  *saved_origval_g = NULL;\n\t\t\tchar_u\t  *saved_newval = NULL;\n#endif\n\t\t\tunsigned  newlen;\n\t\t\tint\t  comma;\n\t\t\tint\t  new_value_alloced;\t// new string option\n\t\t\t\t\t\t\t// was allocated\n\n\t\t\t// When using \":set opt=val\" for a global option\n\t\t\t// with a local value the local value will be\n\t\t\t// reset, use the global value here.\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t\t\t&& ((int)options[opt_idx].indir & PV_BOTH))\n\t\t\t    varp = options[opt_idx].var;\n\n\t\t\t// The old value is kept until we are sure that the\n\t\t\t// new value is valid.\n\t\t\toldval = *(char_u **)varp;\n\n\t\t\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t\t\t{\n\t\t\t    origval_l = *(char_u **)get_varp_scope(\n\t\t\t\t\t       &(options[opt_idx]), OPT_LOCAL);\n\t\t\t    origval_g = *(char_u **)get_varp_scope(\n\t\t\t\t\t      &(options[opt_idx]), OPT_GLOBAL);\n\n\t\t\t    // A global-local string option might have an empty\n\t\t\t    // option as value to indicate that the global\n\t\t\t    // value should be used.\n\t\t\t    if (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t\t  && origval_l == empty_option)\n\t\t\t\torigval_l = origval_g;\n\t\t\t}\n\n\t\t\t// When setting the local value of a global\n\t\t\t// option, the old value may be the global value.\n\t\t\tif (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t       && (opt_flags & OPT_LOCAL))\n\t\t\t    origval = *(char_u **)get_varp(\n\t\t\t\t\t\t       &options[opt_idx]);\n\t\t\telse\n\t\t\t    origval = oldval;\n\n\t\t\tif (nextchar == '&')\t// set to default val\n\t\t\t{\n\t\t\t    newval = options[opt_idx].def_val[\n\t\t\t\t\t\t((flags & P_VI_DEF) || cp_val)\n\t\t\t\t\t\t ?  VI_DEFAULT : VIM_DEFAULT];\n\t\t\t    if ((char_u **)varp == &p_bg)\n\t\t\t    {\n\t\t\t\t// guess the value of 'background'\n#ifdef FEAT_GUI\n\t\t\t\tif (gui.in_use)\n\t\t\t\t    newval = gui_bg_default();\n\t\t\t\telse\n#endif\n\t\t\t\t    newval = term_bg_default();\n\t\t\t    }\n\t\t\t    else if ((char_u **)varp == &p_fencs && enc_utf8)\n\t\t\t\tnewval = fencs_utf8_default;\n\n\t\t\t    // expand environment variables and ~ (since the\n\t\t\t    // default value was already expanded, only\n\t\t\t    // required when an environment variable was set\n\t\t\t    // later\n\t\t\t    if (newval == NULL)\n\t\t\t\tnewval = empty_option;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = newval;\n\t\t\t\tnewval = vim_strsave(s);\n\t\t\t    }\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse if (nextchar == '<')\t// set to global val\n\t\t\t{\n\t\t\t    newval = vim_strsave(*(char_u **)get_varp_scope(\n\t\t\t\t\t     &(options[opt_idx]), OPT_GLOBAL));\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg;\t// jump to after the '=' or ':'\n\n\t\t\t    /*\n\t\t\t     * Set 'keywordprg' to \":help\" if an empty\n\t\t\t     * value was passed to :set by the user.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    if (varp == (char_u *)&p_kp\n\t\t\t\t\t      && (*arg == NUL || *arg == ' '))\n\t\t\t    {\n\t\t\t\tSTRCPY(errbuf, \":help\");\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'backspace' number to string, for\n\t\t\t     * adding, prepending and removing string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_bs\n\t\t\t\t\t && VIM_ISDIGIT(**(char_u **)varp))\n\t\t\t    {\n\t\t\t\ti = getdigits((char_u **)varp);\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\t    case 0:\n\t\t\t\t\t*(char_u **)varp = empty_option;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 1:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t      (char_u *)\"indent,eol\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 2:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,start\");\n\t\t\t\t\tbreak;\n\t\t\t\t    case 3:\n\t\t\t\t\t*(char_u **)varp = vim_strsave(\n\t\t\t\t\t\t(char_u *)\"indent,eol,nostop\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvim_free(oldval);\n\t\t\t\tif (origval == oldval)\n\t\t\t\t    origval = *(char_u **)varp;\n\t\t\t\tif (origval_l == oldval)\n\t\t\t\t    origval_l = *(char_u **)varp;\n\t\t\t\tif (origval_g == oldval)\n\t\t\t\t    origval_g = *(char_u **)varp;\n\t\t\t\toldval = *(char_u **)varp;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Convert 'whichwrap' number to string, for\n\t\t\t     * backwards compatibility with Vim 3.0.\n\t\t\t     * Misuse errbuf[] for the resulting string.\n\t\t\t     */\n\t\t\t    else if (varp == (char_u *)&p_ww\n\t\t\t\t\t\t\t && VIM_ISDIGIT(*arg))\n\t\t\t    {\n\t\t\t\t*errbuf = NUL;\n\t\t\t\ti = getdigits(&arg);\n\t\t\t\tif (i & 1)\n\t\t\t\t    STRCAT(errbuf, \"b,\");\n\t\t\t\tif (i & 2)\n\t\t\t\t    STRCAT(errbuf, \"s,\");\n\t\t\t\tif (i & 4)\n\t\t\t\t    STRCAT(errbuf, \"h,l,\");\n\t\t\t\tif (i & 8)\n\t\t\t\t    STRCAT(errbuf, \"<,>,\");\n\t\t\t\tif (i & 16)\n\t\t\t\t    STRCAT(errbuf, \"[,],\");\n\t\t\t\tif (*errbuf != NUL)\t// remove trailing ,\n\t\t\t\t    errbuf[STRLEN(errbuf) - 1] = NUL;\n\t\t\t\tsave_arg = arg;\n\t\t\t\targ = (char_u *)errbuf;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Remove '>' before 'dir' and 'bdir', for\n\t\t\t     * backwards compatibility with version 3.0\n\t\t\t     */\n\t\t\t    else if (  *arg == '>'\n\t\t\t\t    && (varp == (char_u *)&p_dir\n\t\t\t\t\t    || varp == (char_u *)&p_bdir))\n\t\t\t    {\n\t\t\t\t++arg;\n\t\t\t    }\n\n\t\t\t    /*\n\t\t\t     * Copy the new string into allocated memory.\n\t\t\t     * Can't use set_string_option_direct(), because\n\t\t\t     * we need to remove the backslashes.\n\t\t\t     */\n\t\t\t    // get a bit too much\n\t\t\t    newlen = (unsigned)STRLEN(arg) + 1;\n\t\t\t    if (adding || prepending || removing)\n\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t    newval = alloc(newlen);\n\t\t\t    if (newval == NULL)  // out of mem, don't change\n\t\t\t\tbreak;\n\t\t\t    s = newval;\n\n\t\t\t    /*\n\t\t\t     * Copy the string, skip over escaped chars.\n\t\t\t     * For MS-DOS and WIN32 backslashes before normal\n\t\t\t     * file name characters are not removed, and keep\n\t\t\t     * backslash at start, for \"\\\\machine\\path\", but\n\t\t\t     * do remove it for \"\\\\\\\\machine\\\\path\".\n\t\t\t     * The reverse is found in ExpandOldSetting().\n\t\t\t     */\n\t\t\t    while (*arg && !VIM_ISWHITE(*arg))\n\t\t\t    {\n\t\t\t\tif (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t\t&& !((flags & P_EXPAND)\n\t\t\t\t\t\t&& vim_isfilec(arg[1])\n\t\t\t\t\t\t&& !VIM_ISWHITE(arg[1])\n\t\t\t\t\t\t&& (arg[1] != '\\\\'\n\t\t\t\t\t\t    || (s == newval\n\t\t\t\t\t\t\t&& arg[2] != '\\\\')))\n#endif\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t    ++arg;\t// remove backslash\n\t\t\t\tif (has_mbyte\n\t\t\t\t\t&& (i = (*mb_ptr2len)(arg)) > 1)\n\t\t\t\t{\n\t\t\t\t    // copy multibyte char\n\t\t\t\t    mch_memmove(s, arg, (size_t)i);\n\t\t\t\t    arg += i;\n\t\t\t\t    s += i;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t    *s++ = *arg++;\n\t\t\t    }\n\t\t\t    *s = NUL;\n\n\t\t\t    /*\n\t\t\t     * Expand environment variables and ~.\n\t\t\t     * Don't do it when adding without inserting a\n\t\t\t     * comma.\n\t\t\t     */\n\t\t\t    if (!(adding || prepending || removing)\n\t\t\t\t\t\t\t || (flags & P_COMMA))\n\t\t\t    {\n\t\t\t\ts = option_expand(opt_idx, newval);\n\t\t\t\tif (s != NULL)\n\t\t\t\t{\n\t\t\t\t    vim_free(newval);\n\t\t\t\t    newlen = (unsigned)STRLEN(s) + 1;\n\t\t\t\t    if (adding || prepending || removing)\n\t\t\t\t\tnewlen += (unsigned)STRLEN(origval) + 1;\n\t\t\t\t    newval = alloc(newlen);\n\t\t\t\t    if (newval == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\t    STRCPY(newval, s);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // locate newval[] in origval[] when removing it\n\t\t\t    // and when adding to avoid duplicates\n\t\t\t    i = 0;\t// init for GCC\n\t\t\t    if (removing || (flags & P_NODUP))\n\t\t\t    {\n\t\t\t\ti = (int)STRLEN(newval);\n\t\t\t\ts = find_dup_item(origval, newval, flags);\n\n\t\t\t\t// do not add if already there\n\t\t\t\tif ((adding || prepending) && s != NULL)\n\t\t\t\t{\n\t\t\t\t    prepending = FALSE;\n\t\t\t\t    adding = FALSE;\n\t\t\t\t    STRCPY(newval, origval);\n\t\t\t\t}\n\n\t\t\t\t// if no duplicate, move pointer to end of\n\t\t\t\t// original value\n\t\t\t\tif (s == NULL)\n\t\t\t\t    s = origval + (int)STRLEN(origval);\n\t\t\t    }\n\n\t\t\t    // concatenate the two strings; add a ',' if\n\t\t\t    // needed\n\t\t\t    if (adding || prepending)\n\t\t\t    {\n\t\t\t\tcomma = ((flags & P_COMMA) && *origval != NUL\n\t\t\t\t\t\t\t   && *newval != NUL);\n\t\t\t\tif (adding)\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(origval);\n\t\t\t\t    // strip a trailing comma, would get 2\n\t\t\t\t    if (comma && i > 1\n\t\t\t\t\t  && (flags & P_ONECOMMA) == P_ONECOMMA\n\t\t\t\t\t  && origval[i - 1] == ','\n\t\t\t\t\t  && origval[i - 2] != '\\\\')\n\t\t\t\t\ti--;\n\t\t\t\t    mch_memmove(newval + i + comma, newval,\n\t\t\t\t\t\t\t  STRLEN(newval) + 1);\n\t\t\t\t    mch_memmove(newval, origval, (size_t)i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    i = (int)STRLEN(newval);\n\t\t\t\t    STRMOVE(newval + i + comma, origval);\n\t\t\t\t}\n\t\t\t\tif (comma)\n\t\t\t\t    newval[i] = ',';\n\t\t\t    }\n\n\t\t\t    // Remove newval[] from origval[]. (Note: \"i\" has\n\t\t\t    // been set above and is used here).\n\t\t\t    if (removing)\n\t\t\t    {\n\t\t\t\tSTRCPY(newval, origval);\n\t\t\t\tif (*s)\n\t\t\t\t{\n\t\t\t\t    // may need to remove a comma\n\t\t\t\t    if (flags & P_COMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (s == origval)\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma after string\n\t\t\t\t\t    if (s[i] == ',')\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    // include comma before string\n\t\t\t\t\t    --s;\n\t\t\t\t\t    ++i;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    STRMOVE(newval + (s - origval), s + i);\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (flags & P_FLAGLIST)\n\t\t\t    {\n\t\t\t\t// Remove flags that appear twice.\n\t\t\t\tfor (s = newval; *s;)\n\t\t\t\t{\n\t\t\t\t    // if options have P_FLAGLIST and\n\t\t\t\t    // P_ONECOMMA such as 'whichwrap'\n\t\t\t\t    if (flags & P_ONECOMMA)\n\t\t\t\t    {\n\t\t\t\t\tif (*s != ',' && *(s + 1) == ','\n\t\t\t\t\t      && vim_strchr(s + 2, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    // Remove the duplicated value and\n\t\t\t\t\t    // the next comma.\n\t\t\t\t\t    STRMOVE(s, s + 2);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tif ((!(flags & P_COMMA) || *s != ',')\n\t\t\t\t\t      && vim_strchr(s + 1, *s) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    STRMOVE(s, s + 1);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    ++s;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (save_arg != NULL)   // number for 'whichwrap'\n\t\t\t\targ = save_arg;\n\t\t\t    new_value_alloced = TRUE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Set the new value.\n\t\t\t */\n\t\t\t*(char_u **)(varp) = newval;\n\n#if defined(FEAT_EVAL)\n\t\t\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t\t\t&& options[opt_idx].indir != PV_KEY\n# endif\n\t\t\t\t\t  && origval != NULL && newval != NULL)\n\t\t\t{\n\t\t\t    // origval may be freed by\n\t\t\t    // did_set_string_option(), make a copy.\n\t\t\t    saved_origval = vim_strsave(origval);\n\t\t\t    // newval (and varp) may become invalid if the\n\t\t\t    // buffer is closed by autocommands.\n\t\t\t    saved_newval = vim_strsave(newval);\n\t\t\t    if (origval_l != NULL)\n\t\t\t\tsaved_origval_l = vim_strsave(origval_l);\n\t\t\t    if (origval_g != NULL)\n\t\t\t\tsaved_origval_g = vim_strsave(origval_g);\n\t\t\t}\n#endif\n\n\t\t\t{\n\t\t\t    long_u *p = insecure_flag(opt_idx, opt_flags);\n\t\t\t    int\t    secure_saved = secure;\n\n\t\t\t    // When an option is set in the sandbox, from a\n\t\t\t    // modeline or in secure mode, then deal with side\n\t\t\t    // effects in secure mode.  Also when the value was\n\t\t\t    // set with the P_INSECURE flag and is not\n\t\t\t    // completely replaced.\n\t\t\t    if ((opt_flags & OPT_MODELINE)\n#ifdef HAVE_SANDBOX\n\t\t\t\t  || sandbox != 0\n#endif\n\t\t\t\t  || (!value_is_replaced && (*p & P_INSECURE)))\n\t\t\t\tsecure = 1;\n\n\t\t\t    // Handle side effects, and set the global value\n\t\t\t    // for \":set\" on local options. Note: when setting\n\t\t\t    // 'syntax' or 'filetype' autocommands may be\n\t\t\t    // triggered that can cause havoc.\n\t\t\t    errmsg = did_set_string_option(\n\t\t\t\t    opt_idx, (char_u **)varp,\n\t\t\t\t    new_value_alloced, oldval, errbuf,\n\t\t\t\t    opt_flags, &value_checked);\n\n\t\t\t    secure = secure_saved;\n\t\t\t}\n\n#if defined(FEAT_EVAL)\n\t\t\tif (errmsg == NULL)\n\t\t\t    trigger_optionsset_string(\n\t\t\t\t    opt_idx, opt_flags, saved_origval,\n\t\t\t\t    saved_origval_l, saved_origval_g,\n\t\t\t\t    saved_newval);\n\t\t\tvim_free(saved_origval);\n\t\t\tvim_free(saved_origval_l);\n\t\t\tvim_free(saved_origval_g);\n\t\t\tvim_free(saved_newval);\n#endif\n\t\t\t// If error detected, print the error message.\n\t\t\tif (errmsg != NULL)\n\t\t\t    goto skip;\n\t\t    }\n\t\t    else\t    // key code option\n\t\t    {\n\t\t\tchar_u\t    *p;\n\n\t\t\tif (nextchar == '&')\n\t\t\t{\n\t\t\t    if (add_termcap_entry(key_name, TRUE) == FAIL)\n\t\t\t\terrmsg = N_(\"E522: Not found in termcap\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ++arg; // jump to after the '=' or ':'\n\t\t\t    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)\n\t\t\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t\t\t    ++p;\n\t\t\t    nextchar = *p;\n\t\t\t    *p = NUL;\n\t\t\t    add_termcode(key_name, arg, FALSE);\n\t\t\t    *p = nextchar;\n\t\t\t}\n\t\t\tif (full_screen)\n\t\t\t    ttest(FALSE);\n\t\t\tredraw_all_later(CLEAR);\n\t\t    }\n\t\t}\n\n\t\tif (opt_idx >= 0)\n\t\t    did_set_option(\n\t\t\t opt_idx, opt_flags, value_is_replaced, value_checked);\n\t    }\n\nskip:\n\t    /*\n\t     * Advance to next argument.\n\t     * - skip until a blank found, taking care of backslashes\n\t     * - skip blanks\n\t     * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n\t     */\n\t    for (i = 0; i < 2 ; ++i)\n\t    {\n\t\twhile (*arg != NUL && !VIM_ISWHITE(*arg))\n\t\t    if (*arg++ == '\\\\' && *arg != NUL)\n\t\t\t++arg;\n\t\targ = skipwhite(arg);\n\t\tif (*arg != '=')\n\t\t    break;\n\t    }\n\t}\n\n\tif (errmsg != NULL)\n\t{\n\t    vim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);\n\t    i = (int)STRLEN(IObuff) + 2;\n\t    if (i + (arg - startarg) < IOSIZE)\n\t    {\n\t\t// append the argument with the error\n\t\tSTRCAT(IObuff, \": \");\n\t\tmch_memmove(IObuff + i, startarg, (arg - startarg));\n\t\tIObuff[i + (arg - startarg)] = NUL;\n\t    }\n\t    // make sure all characters are printable\n\t    trans_characters(IObuff, IOSIZE);\n\n\t    ++no_wait_return;\t\t// wait_return done later\n\t    emsg((char *)IObuff);\t// show error highlighted\n\t    --no_wait_return;\n\n\t    return FAIL;\n\t}\n\n\targ = skipwhite(arg);\n    }\n\ntheend:\n    if (silent_mode && did_show)\n    {\n\t// After displaying option values in silent mode.\n\tsilent_mode = FALSE;\n\tinfo_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = TRUE;\n\tinfo_message = FALSE;\t// use mch_msg(), not mch_errmsg()\n    }\n\n    return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\n    void\ndid_set_option(\n    int\t    opt_idx,\n    int\t    opt_flags,\t    // possibly with OPT_MODELINE\n    int\t    new_value,\t    // value was replaced completely\n    int\t    value_checked)  // value was checked to be safe, no need to set the\n\t\t\t    // P_INSECURE flag.\n{\n    long_u\t*p;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n    // When an option is set in the sandbox, from a modeline or in secure mode\n    // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n    // flag.\n    p = insecure_flag(opt_idx, opt_flags);\n    if (!value_checked && (secure\n#ifdef HAVE_SANDBOX\n\t    || sandbox != 0\n#endif\n\t    || (opt_flags & OPT_MODELINE)))\n\t*p = *p | P_INSECURE;\n    else if (new_value)\n\t*p = *p & ~P_INSECURE;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n * When \"multi_byte\" is TRUE allow for multi-byte characters.\n */\n    int\nstring_to_key(char_u *arg, int multi_byte)\n{\n    if (*arg == '<')\n\treturn find_key_option(arg + 1, TRUE);\n    if (*arg == '^')\n\treturn Ctrl_chr(arg[1]);\n    if (multi_byte)\n\treturn PTR2CHAR(arg);\n    return *arg;\n}\n\n#ifdef FEAT_TITLE\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call mch_restore_title() to get\n * the old value back.\n */\n    void\ndid_set_title(void)\n{\n    if (starting != NO_SCREEN\n#ifdef FEAT_GUI\n\t    && !gui.starting\n#endif\n\t\t\t\t)\n\tmaketitle();\n}\n#endif\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\n    void\nset_options_bin(\n    int\t\toldval,\n    int\t\tnewval,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    /*\n     * The option values that are changed when 'bin' changes are\n     * copied when 'bin is set and restored when 'bin' is reset.\n     */\n    if (newval)\n    {\n\tif (!oldval)\t\t// switched on\n\t{\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t    {\n\t\tcurbuf->b_p_tw_nobin = curbuf->b_p_tw;\n\t\tcurbuf->b_p_wm_nobin = curbuf->b_p_wm;\n\t\tcurbuf->b_p_ml_nobin = curbuf->b_p_ml;\n\t\tcurbuf->b_p_et_nobin = curbuf->b_p_et;\n\t    }\n\t    if (!(opt_flags & OPT_LOCAL))\n\t    {\n\t\tp_tw_nobin = p_tw;\n\t\tp_wm_nobin = p_wm;\n\t\tp_ml_nobin = p_ml;\n\t\tp_et_nobin = p_et;\n\t    }\n\t}\n\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = 0;\t// no automatic line wrap\n\t    curbuf->b_p_wm = 0;\t// no automatic line wrap\n\t    curbuf->b_p_ml = 0;\t// no modelines\n\t    curbuf->b_p_et = 0;\t// no expandtab\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = 0;\n\t    p_wm = 0;\n\t    p_ml = FALSE;\n\t    p_et = FALSE;\n\t    p_bin = TRUE;\t// needed when called for the \"-b\" argument\n\t}\n    }\n    else if (oldval)\t\t// switched off\n    {\n\tif (!(opt_flags & OPT_GLOBAL))\n\t{\n\t    curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n\t    curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n\t    curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n\t    curbuf->b_p_et = curbuf->b_p_et_nobin;\n\t}\n\tif (!(opt_flags & OPT_LOCAL))\n\t{\n\t    p_tw = p_tw_nobin;\n\t    p_wm = p_wm_nobin;\n\t    p_ml = p_ml_nobin;\n\t    p_et = p_et_nobin;\n\t}\n    }\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\n    static char_u *\noption_expand(int opt_idx, char_u *val)\n{\n    // if option doesn't need expansion nothing to do\n    if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n\treturn NULL;\n\n    // If val is longer than MAXPATHL no meaningful expansion can be done,\n    // expand_env() would truncate the string.\n    if (val != NULL && STRLEN(val) > MAXPATHL)\n\treturn NULL;\n\n    if (val == NULL)\n\tval = *(char_u **)options[opt_idx].var;\n\n    /*\n     * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n     * Escape spaces when expanding 'tags', they are used to separate file\n     * names.\n     * For 'spellsuggest' expand after \"file:\".\n     */\n    expand_env_esc(val, NameBuff, MAXPATHL,\n\t    (char_u **)options[opt_idx].var == &p_tags, FALSE,\n#ifdef FEAT_SPELL\n\t    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n#endif\n\t\t\t\t  NULL);\n    if (STRCMP(NameBuff, val) == 0)   // they are the same\n\treturn NULL;\n\n    return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    static void\ndidset_options(void)\n{\n    // initialize the table for 'iskeyword' et.al.\n    (void)init_chartab();\n\n    didset_string_options();\n\n#ifdef FEAT_SPELL\n    (void)spell_check_msm();\n    (void)spell_check_sps();\n    (void)compile_cap_prog(curwin->w_s);\n    (void)did_set_spell_option(TRUE);\n#endif\n#ifdef FEAT_CMDWIN\n    // set cedit_key\n    (void)check_cedit();\n#endif\n#ifdef FEAT_LINEBREAK\n    // initialize the table for 'breakat'.\n    fill_breakat_flags();\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * More side effects of setting options.\n */\n    static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\n    void\ncheck_options(void)\n{\n    int\t\topt_idx;\n\n    for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n\tif ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n\t    check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Return the option index found by a pointer into term_strings[].\n * Return -1 if not found.\n */\n    int\nget_term_opt_idx(char_u **p)\n{\n    int opt_idx;\n\n    for (opt_idx = 1; options[opt_idx].fullname != NULL; opt_idx++)\n\tif (options[opt_idx].var == (char_u *)p)\n\t    return opt_idx;\n    return -1; // cannot happen: didn't find it!\n}\n\n/*\n * Mark a terminal option as allocated, found by a pointer into term_strings[].\n * Return the option index or -1 if not found.\n */\n    int\nset_term_option_alloced(char_u **p)\n{\n    int\t\topt_idx = get_term_opt_idx(p);\n\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_ALLOCED;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\n    int\nwas_set_insecurely(char_u *opt, int opt_flags)\n{\n    int\t    idx = findoption(opt);\n    long_u  *flagp;\n\n    if (idx >= 0)\n    {\n\tflagp = insecure_flag(idx, opt_flags);\n\treturn (*flagp & P_INSECURE) != 0;\n    }\n    internal_error(\"was_set_insecurely()\");\n    return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n * NOTE: Caller must make sure that \"curwin\" is set to the window from which\n * the option is used.\n */\n    static long_u *\ninsecure_flag(int opt_idx, int opt_flags)\n{\n    if (opt_flags & OPT_LOCAL)\n\tswitch ((int)options[opt_idx].indir)\n\t{\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:\treturn &curwin->w_p_stl_flags;\n#endif\n#ifdef FEAT_EVAL\n# ifdef FEAT_FOLDING\n\t    case PV_FDE:\treturn &curwin->w_p_fde_flags;\n\t    case PV_FDT:\treturn &curwin->w_p_fdt_flags;\n# endif\n# ifdef FEAT_BEVAL\n\t    case PV_BEXPR:\treturn &curbuf->b_p_bexpr_flags;\n# endif\n# if defined(FEAT_CINDENT)\n\t    case PV_INDE:\treturn &curbuf->b_p_inde_flags;\n# endif\n\t    case PV_FEX:\treturn &curbuf->b_p_fex_flags;\n# ifdef FEAT_FIND_ID\n\t    case PV_INEX:\treturn &curbuf->b_p_inex_flags;\n# endif\n#endif\n\t}\n\n    // Nothing special, return global flags field.\n    return &options[opt_idx].flags;\n}\n#endif\n\n#if defined(FEAT_TITLE) || defined(PROTO)\n/*\n * Redraw the window title and/or tab page text later.\n */\nvoid redraw_titles(void)\n{\n    need_maketitle = TRUE;\n    redraw_tabline = TRUE;\n}\n#endif\n\n/*\n * Return TRUE if \"val\" is a valid name: only consists of alphanumeric ASCII\n * characters or characters in \"allowed\".\n */\n    int\nvalid_name(char_u *val, char *allowed)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)allowed, *s) == NULL)\n\t    return FALSE;\n    return TRUE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set the script_ctx for an option, taking care of setting the buffer- or\n * window-local value.\n */\n    void\nset_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)\n{\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tindir = (int)options[opt_idx].indir;\n    sctx_T\tnew_script_ctx = script_ctx;\n\n    // Modeline already has the line number set.\n    if (!(opt_flags & OPT_MODELINE))\n\tnew_script_ctx.sc_lnum += SOURCING_LNUM;\n\n    // Remember where the option was set.  For local options need to do that\n    // in the buffer or window structure.\n    if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n\toptions[opt_idx].script_ctx = new_script_ctx;\n    if (both || (opt_flags & OPT_LOCAL))\n    {\n\tif (indir & PV_BUF)\n\t    curbuf->b_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n\telse if (indir & PV_WIN)\n\t    curwin->w_p_script_ctx[indir & PV_MASK] = new_script_ctx;\n    }\n}\n\n/*\n * Set the script_ctx for a termcap option.\n * \"name\" must be the two character code, e.g. \"RV\".\n * When \"name\" is NULL use \"opt_idx\".\n */\n    void\nset_term_option_sctx_idx(char *name, int opt_idx)\n{\n    char_u  buf[5];\n    int\t    idx;\n\n    if (name == NULL)\n\tidx = opt_idx;\n    else\n    {\n\tbuf[0] = 't';\n\tbuf[1] = '_';\n\tbuf[2] = name[0];\n\tbuf[3] = name[1];\n\tbuf[4] = 0;\n\tidx = findoption(buf);\n    }\n    if (idx >= 0)\n\tset_option_sctx_idx(idx, OPT_GLOBAL, current_sctx);\n}\n#endif\n\n#if defined(FEAT_EVAL)\n/*\n * Apply the OptionSet autocommand.\n */\n    static void\napply_optionset_autocmd(\n\tint\topt_idx,\n\tlong\topt_flags,\n\tlong\toldval,\n\tlong\toldval_g,\n\tlong\tnewval,\n\tchar\t*errmsg)\n{\n    char_u buf_old[12], buf_old_global[12], buf_new[12], buf_type[12];\n\n    // Don't do this while starting up, failure or recursively.\n    if (starting || errmsg != NULL || *get_vim_var_str(VV_OPTION_TYPE) != NUL)\n\treturn;\n\n    vim_snprintf((char *)buf_old, sizeof(buf_old), \"%ld\", oldval);\n    vim_snprintf((char *)buf_old_global, sizeof(buf_old_global), \"%ld\",\n\t\t\t\t\t\t\toldval_g);\n    vim_snprintf((char *)buf_new, sizeof(buf_new), \"%ld\", newval);\n    vim_snprintf((char *)buf_type, sizeof(buf_type), \"%s\",\n\t\t\t\t(opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    if (opt_flags & OPT_LOCAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    if (opt_flags & OPT_GLOBAL)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);\n    }\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n\tset_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);\n    }\n    if (opt_flags & OPT_MODELINE)\n    {\n\tset_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\tset_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);\n    }\n    apply_autocmds(EVENT_OPTIONSET, (char_u *)options[opt_idx].fullname,\n\t    NULL, FALSE, NULL);\n    reset_v_option_vars();\n}\n#endif\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_bool_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    int\t\tvalue,\t\t\t// new value\n    int\t\topt_flags)\t\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    int\t\told_value = *(int *)varp;\n#if defined(FEAT_EVAL)\n    int\t\told_global_value = 0;\n#endif\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_secure;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(int *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *(int *)varp = value;\t    // set the new value\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n    /*\n     * Handle side effects of changing a bool option.\n     */\n\n    // 'compatible'\n    if ((int *)varp == &p_cp)\n\tcompatible_set();\n\n#ifdef FEAT_LANGMAP\n    if ((int *)varp == &p_lrm)\n\t// 'langremap' -> !'langnoremap'\n\tp_lnr = !p_lrm;\n    else if ((int *)varp == &p_lnr)\n\t// 'langnoremap' -> !'langremap'\n\tp_lrm = !p_lnr;\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if ((int *)varp == &curwin->w_p_cul && !value && old_value)\n\treset_cursorline();\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n    // 'undofile'\n    else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf)\n    {\n\t// Only take action when the option was set. When reset we do not\n\t// delete the undo file, the option may be set again without making\n\t// any changes in between.\n\tif (curbuf->b_p_udf || p_udf)\n\t{\n\t    char_u\thash[UNDO_HASH_SIZE];\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    FOR_ALL_BUFFERS(curbuf)\n\t    {\n\t\t// When 'undofile' is set globally: for every buffer, otherwise\n\t\t// only for the current buffer: Try to read in the undofile,\n\t\t// if one exists, the buffer wasn't changed and the buffer was\n\t\t// loaded\n\t\tif ((curbuf == save_curbuf\n\t\t\t\t|| (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n\t\t\t&& !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL)\n\t\t{\n#ifdef FEAT_CRYPT\n\t\t    if (crypt_get_method_nr(curbuf) == CRYPT_M_SOD)\n\t\t\tcontinue;\n#endif\n\t\t    u_compute_hash(hash);\n\t\t    u_read_undo(NULL, hash, curbuf->b_fname);\n\t\t}\n\t    }\n\t    curbuf = save_curbuf;\n\t}\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_p_ro)\n    {\n\t// when 'readonly' is reset globally, also reset readonlymode\n\tif (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n\t    readonlymode = FALSE;\n\n\t// when 'readonly' is set may give W10 again\n\tif (curbuf->b_p_ro)\n\t    curbuf->b_did_warn = FALSE;\n\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n    }\n\n#ifdef FEAT_GUI\n    else if ((int *)varp == &p_mh)\n    {\n\tif (!p_mh)\n\t    gui_mch_mousehide(FALSE);\n    }\n#endif\n\n    // when 'modifiable' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_ma)\n    {\n# ifdef FEAT_TERMINAL\n\t// Cannot set 'modifiable' when in Terminal mode.\n\tif (curbuf->b_p_ma && (term_in_normal_mode() || (bt_terminal(curbuf)\n\t\t      && curbuf->b_term != NULL && !term_is_finished(curbuf))))\n\t{\n\t    curbuf->b_p_ma = FALSE;\n\t    return N_(\"E946: Cannot make a terminal with running job modifiable\");\n\t}\n# endif\n# ifdef FEAT_TITLE\n\tredraw_titles();\n# endif\n    }\n#ifdef FEAT_TITLE\n    // when 'endofline' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_eol)\n    {\n\tredraw_titles();\n    }\n    // when 'fixeol' is changed, redraw the window title\n    else if ((int *)varp == &curbuf->b_p_fixeol)\n    {\n\tredraw_titles();\n    }\n    // when 'bomb' is changed, redraw the window title and tab page text\n    else if ((int *)varp == &curbuf->b_p_bomb)\n    {\n\tredraw_titles();\n    }\n#endif\n\n    // when 'bin' is set also set some other options\n    else if ((int *)varp == &curbuf->b_p_bin)\n    {\n\tset_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n    }\n\n    // when 'buflisted' changes, trigger autocommands\n    else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl)\n    {\n\tapply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n\t\t\t\t\t\t    NULL, NULL, TRUE, curbuf);\n    }\n\n    // when 'swf' is set, create swapfile, when reset remove swapfile\n    else if ((int *)varp == &curbuf->b_p_swf)\n    {\n\tif (curbuf->b_p_swf && p_uc)\n\t    ml_open_file(curbuf);\t\t// create the swap file\n\telse\n\t    // no need to reset curbuf->b_may_swap, ml_open_file() will check\n\t    // buf->b_p_swf\n\t    mf_close_file(curbuf, TRUE);\t// remove the swap file\n    }\n\n    // when 'terse' is set change 'shortmess'\n    else if ((int *)varp == &p_terse)\n    {\n\tchar_u\t*p;\n\n\tp = vim_strchr(p_shm, SHM_SEARCH);\n\n\t// insert 's' in p_shm\n\tif (p_terse && p == NULL)\n\t{\n\t    STRCPY(IObuff, p_shm);\n\t    STRCAT(IObuff, \"s\");\n\t    set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n\t}\n\t// remove 's' from p_shm\n\telse if (!p_terse && p != NULL)\n\t    STRMOVE(p, p + 1);\n    }\n\n    // when 'paste' is set or reset also change other options\n    else if ((int *)varp == &p_paste)\n    {\n\tpaste_option_changed();\n    }\n\n    // when 'insertmode' is set from an autocommand need to do work here\n    else if ((int *)varp == &p_im)\n    {\n\tif (p_im)\n\t{\n\t    if ((State & INSERT) == 0)\n\t\tneed_start_insertmode = TRUE;\n\t    stop_insert_mode = FALSE;\n\t}\n\t// only reset if it was set previously\n\telse if (old_value)\n\t{\n\t    need_start_insertmode = FALSE;\n\t    stop_insert_mode = TRUE;\n\t    if (restart_edit != 0 && mode_displayed)\n\t\tclear_cmdline = TRUE;\t// remove \"(insert)\"\n\t    restart_edit = 0;\n\t}\n    }\n\n    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw\n    else if ((int *)varp == &p_ic && p_hls)\n    {\n\tredraw_all_later(SOME_VALID);\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // when 'hlsearch' is set or reset: reset no_hlsearch\n    else if ((int *)varp == &p_hls)\n    {\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    // when 'scrollbind' is set: snapshot the current position to avoid a jump\n    // at the end of normal_cmd()\n    else if ((int *)varp == &curwin->w_p_scb)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    do_check_scrollbind(FALSE);\n\t    curwin->w_scbind_pos = curwin->w_topline;\n\t}\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // There can be only one window with 'previewwindow' set.\n    else if ((int *)varp == &curwin->w_p_pvw)\n    {\n\tif (curwin->w_p_pvw)\n\t{\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t\tif (win->w_p_pvw && win != curwin)\n\t\t{\n\t\t    curwin->w_p_pvw = FALSE;\n\t\t    return N_(\"E590: A preview window already exists\");\n\t\t}\n\t}\n    }\n#endif\n\n    // when 'textmode' is set or reset also change 'fileformat'\n    else if ((int *)varp == &curbuf->b_p_tx)\n    {\n\tset_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);\n    }\n\n    // when 'textauto' is set or reset also change 'fileformats'\n    else if ((int *)varp == &p_ta)\n    {\n\tset_string_option_direct((char_u *)\"ffs\", -1,\n\t\t\t\t p_ta ? (char_u *)DFLT_FFS_VIM : (char_u *)\"\",\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n    }\n\n    /*\n     * When 'lisp' option changes include/exclude '-' in\n     * keyword characters.\n     */\n#ifdef FEAT_LISP\n    else if (varp == (char_u *)&(curbuf->b_p_lisp))\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\t    // ignore errors\n    }\n#endif\n\n#ifdef FEAT_TITLE\n    // when 'title' changed, may need to change the title; same for 'icon'\n    else if ((int *)varp == &p_title || (int *)varp == &p_icon)\n    {\n\tdid_set_title();\n    }\n#endif\n\n    else if ((int *)varp == &curbuf->b_changed)\n    {\n\tif (!value)\n\t    save_file_ff(curbuf);\t// Buffer is unchanged\n#ifdef FEAT_TITLE\n\tredraw_titles();\n#endif\n\tmodified_was_set = value;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    else if ((int *)varp == &p_ssl)\n    {\n\tif (p_ssl)\n\t{\n\t    psepc = '/';\n\t    psepcN = '\\\\';\n\t    pseps[0] = '/';\n\t}\n\telse\n\t{\n\t    psepc = '\\\\';\n\t    psepcN = '/';\n\t    pseps[0] = '\\\\';\n\t}\n\n\t// need to adjust the file name arguments and buffer names.\n\tbuflist_slash_adjust();\n\talist_slash_adjust();\n# ifdef FEAT_EVAL\n\tscriptnames_slash_adjust();\n# endif\n    }\n#endif\n\n    // If 'wrap' is set, set w_leftcol to zero.\n    else if ((int *)varp == &curwin->w_p_wrap)\n    {\n\tif (curwin->w_p_wrap)\n\t    curwin->w_leftcol = 0;\n    }\n\n    else if ((int *)varp == &p_ea)\n    {\n\tif (p_ea && !old_value)\n\t    win_equal(curwin, FALSE, 0);\n    }\n\n    else if ((int *)varp == &p_wiv)\n    {\n\t/*\n\t * When 'weirdinvert' changed, set/reset 't_xs'.\n\t * Then set 'weirdinvert' according to value of 't_xs'.\n\t */\n\tif (p_wiv && !old_value)\n\t    T_XS = (char_u *)\"y\";\n\telse if (!p_wiv && old_value)\n\t    T_XS = empty_option;\n\tp_wiv = (*T_XS != NUL);\n    }\n\n#ifdef FEAT_BEVAL_GUI\n    else if ((int *)varp == &p_beval)\n    {\n\tif (!balloonEvalForTerm)\n\t{\n\t    if (p_beval && !old_value)\n\t\tgui_mch_enable_beval_area(balloonEval);\n\t    else if (!p_beval && old_value)\n\t\tgui_mch_disable_beval_area(balloonEval);\n\t}\n    }\n#endif\n#ifdef FEAT_BEVAL_TERM\n    else if ((int *)varp == &p_bevalterm)\n    {\n\tmch_bevalterm_changed();\n    }\n#endif\n\n#ifdef FEAT_AUTOCHDIR\n    else if ((int *)varp == &p_acd)\n    {\n\t// Change directories when the 'acd' option is set now.\n\tDO_AUTOCHDIR;\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // 'diff'\n    else if ((int *)varp == &curwin->w_p_diff)\n    {\n\t// May add or remove the buffer from the list of diff buffers.\n\tdiff_buf_adjust(curwin);\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsDiff(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n    }\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    // 'imdisable'\n    else if ((int *)varp == &p_imdisable)\n    {\n\t// Only de-activate it here, it will be enabled when changing mode.\n\tif (p_imdisable)\n\t    im_set_active(FALSE);\n\telse if (State & INSERT)\n\t    // When the option is set from an autocommand, it may need to take\n\t    // effect right away.\n\t    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // 'spell'\n    else if ((int *)varp == &curwin->w_p_spell)\n    {\n\tif (curwin->w_p_spell)\n\t{\n\t    char\t*errmsg = did_set_spelllang(curwin);\n\n\t    if (errmsg != NULL)\n\t\temsg(_(errmsg));\n\t}\n    }\n#endif\n\n#ifdef FEAT_ARABIC\n    if ((int *)varp == &curwin->w_p_arab)\n    {\n\tif (curwin->w_p_arab)\n\t{\n\t    /*\n\t     * 'arabic' is set, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// set rightleft mode\n\t\tif (!curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = TRUE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// Enable Arabic shaping (major part of what Arabic requires)\n\t\tif (!p_arshape)\n\t\t{\n\t\t    p_arshape = TRUE;\n\t\t    redraw_later_clear();\n\t\t}\n\t    }\n\n\t    // Arabic requires a utf-8 encoding, inform the user if its not\n\t    // set.\n\t    if (STRCMP(p_enc, \"utf-8\") != 0)\n\t    {\n\t\tstatic char *w_arabic = N_(\"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n\t\tmsg_source(HL_ATTR(HLF_W));\n\t\tmsg_attr(_(w_arabic), HL_ATTR(HLF_W));\n#ifdef FEAT_EVAL\n\t\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);\n#endif\n\t    }\n\n\t    // set 'delcombine'\n\t    p_deco = TRUE;\n\n# ifdef FEAT_KEYMAP\n\t    // Force-set the necessary keymap for arabic\n\t    set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n# endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * 'arabic' is reset, handle various sub-settings.\n\t     */\n\t    if (!p_tbidi)\n\t    {\n\t\t// reset rightleft mode\n\t\tif (curwin->w_p_rl)\n\t\t{\n\t\t    curwin->w_p_rl = FALSE;\n\t\t    changed_window_setting();\n\t\t}\n\n\t\t// 'arabicshape' isn't reset, it is a global option and\n\t\t// another window may still need it \"on\".\n\t    }\n\n\t    // 'delcombine' isn't reset, it is a global option and another\n\t    // window may still want it \"on\".\n\n# ifdef FEAT_KEYMAP\n\t    // Revert to the default keymap\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n# endif\n\t}\n    }\n\n#endif\n\n#if defined(FEAT_SIGNS) && defined(FEAT_GUI)\n    else if (((int *)varp == &curwin->w_p_nu\n\t\t|| (int *)varp == &curwin->w_p_rnu)\n\t    && gui.in_use\n\t    && (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u')\n\t    && curbuf->b_signlist != NULL)\n    {\n\t// If the 'number' or 'relativenumber' options are modified and\n\t// 'signcolumn' is set to 'number', then clear the screen for a full\n\t// refresh. Otherwise the sign icons are not displayed properly in the\n\t// number column.  If the 'number' option is set and only the\n\t// 'relativenumber' option is toggled, then don't refresh the screen\n\t// (optimization).\n\tif (!(curwin->w_p_nu && ((int *)varp == &curwin->w_p_rnu)))\n\t    redraw_all_later(CLEAR);\n    }\n#endif\n\n#ifdef FEAT_TERMGUICOLORS\n    // 'termguicolors'\n    else if ((int *)varp == &p_tgc)\n    {\n# ifdef FEAT_VTP\n\t// Do not turn on 'tgc' when 24-bit colors are not supported.\n\tif (\n#  ifdef VIMDLL\n\t    !gui.in_use && !gui.starting &&\n#  endif\n\t    !has_vtp_working())\n\t{\n\t    p_tgc = 0;\n\t    return N_(\"E954: 24-bit colors are not supported on this environment\");\n\t}\n\tif (is_term_win32())\n\t    swap_tcap();\n# endif\n# ifdef FEAT_GUI\n\tif (!gui.in_use && !gui.starting)\n# endif\n\t    highlight_gui_started();\n# ifdef FEAT_VTP\n\t// reset t_Co\n\tif (is_term_win32())\n\t{\n\t    control_console_color_rgb();\n\t    set_termname(T_NAME);\n\t    init_highlight(TRUE, FALSE);\n\t}\n# endif\n    }\n#endif\n\n    /*\n     * End of handling side effects for bool options.\n     */\n\n    // after handling side effects, call autocommand\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags,\n\t\t\t\t(long)(old_value ? TRUE : FALSE),\n\t\t\t\t(long)(old_global_value ? TRUE : FALSE),\n\t\t\t\t(long)(value ? TRUE : FALSE), NULL);\n#endif\n\n    comp_col();\t\t\t    // in case 'ruler' or 'showcmd' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\n    static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_secure;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invarg;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invarg;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n#ifdef FEAT_TITLE\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n#endif\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invarg;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf((char *)errbuf, errbuflen,\n\t\t\t       _(\"E593: Need at least %d lines\"), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf((char *)errbuf, errbuflen,\n\t\t\t    _(\"E594: Need at least %d columns\"), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invarg;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invarg;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\n    void\ncheck_redraw(long_u flags)\n{\n    // Careful: P_RCLR and P_RALL are a combination of other P_ flags\n    int\t\tdoclear = (flags & P_RCLR) == P_RCLR;\n    int\t\tall = ((flags & P_RALL) == P_RALL || doclear);\n\n    if ((flags & P_RSTAT) || all)\t// mark all status lines dirty\n\tstatus_redraw_all();\n\n    if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n\tchanged_window_setting();\n    if (flags & P_RBUF)\n\tredraw_curbuf_later(NOT_VALID);\n    if (flags & P_RWINONLY)\n\tredraw_later(NOT_VALID);\n    if (doclear)\n\tredraw_all_later(CLEAR);\n    else if (all)\n\tredraw_all_later(NOT_VALID);\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\n    int\nfindoption(char_u *arg)\n{\n    int\t\t    opt_idx;\n    char\t    *s, *p;\n    static short    quick_tab[27] = {0, 0};\t// quick access table\n    int\t\t    is_term_opt;\n\n    /*\n     * For first call: Initialize the quick-access table.\n     * It contains the index for the first option that starts with a certain\n     * letter.  There are 26 letters, plus the first \"t_\" option.\n     */\n    if (quick_tab[1] == 0)\n    {\n\tp = options[0].fullname;\n\tfor (opt_idx = 1; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n\t{\n\t    if (s[0] != p[0])\n\t    {\n\t\tif (s[0] == 't' && s[1] == '_')\n\t\t    quick_tab[26] = opt_idx;\n\t\telse\n\t\t    quick_tab[CharOrdLow(s[0])] = opt_idx;\n\t    }\n\t    p = s;\n\t}\n    }\n\n    /*\n     * Check for name starting with an illegal character.\n     */\n#ifdef EBCDIC\n    if (!islower(arg[0]))\n#else\n    if (arg[0] < 'a' || arg[0] > 'z')\n#endif\n\treturn -1;\n\n    is_term_opt = (arg[0] == 't' && arg[1] == '_');\n    if (is_term_opt)\n\topt_idx = quick_tab[26];\n    else\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n    for ( ; (s = options[opt_idx].fullname) != NULL; opt_idx++)\n    {\n\tif (STRCMP(arg, s) == 0)\t\t    // match full name\n\t    break;\n    }\n    if (s == NULL && !is_term_opt)\n    {\n\topt_idx = quick_tab[CharOrdLow(arg[0])];\n\tfor ( ; options[opt_idx].fullname != NULL; opt_idx++)\n\t{\n\t    s = options[opt_idx].shortname;\n\t    if (s != NULL && STRCMP(arg, s) == 0)   // match short name\n\t\tbreak;\n\t    s = NULL;\n\t}\n    }\n    if (s == NULL)\n\topt_idx = -1;\n    return opt_idx;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_TCL) || defined(FEAT_MZSCHEME)\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number option: gov_number, *numval gets value.\n * Toggle option: gov_bool,   *numval gets value.\n * String option: gov_string, *stringval gets allocated string.\n * Hidden Number option: gov_hidden_number.\n * Hidden Toggle option: gov_hidden_bool.\n * Hidden String option: gov_hidden_string.\n * Unknown option: gov_unknown.\n */\n    getoption_T\nget_option_value(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only checking existence\n    int\t\topt_flags)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\t\t    // option not in the table\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t\t\t  && (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\t    char_u *p;\n\n\t    // check for a terminal option\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    p = find_termcode(key_name);\n\t    if (p != NULL)\n\t    {\n\t\tif (stringval != NULL)\n\t\t    *stringval = vim_strsave(p);\n\t\treturn gov_string;\n\t    }\n\t}\n\treturn gov_unknown;\n    }\n\n    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\n    if (options[opt_idx].flags & P_STRING)\n    {\n\tif (varp == NULL)\t\t    // hidden option\n\t    return gov_hidden_string;\n\tif (stringval != NULL)\n\t{\n#ifdef FEAT_CRYPT\n\t    // never return the value of the crypt key\n\t    if ((char_u **)varp == &curbuf->b_p_key\n\t\t\t\t\t\t&& **(char_u **)(varp) != NUL)\n\t\t*stringval = vim_strsave((char_u *)\"*****\");\n\t    else\n#endif\n\t\t*stringval = vim_strsave(*(char_u **)(varp));\n\t}\n\treturn gov_string;\n    }\n\n    if (varp == NULL)\t\t    // hidden option\n\treturn (options[opt_idx].flags & P_NUM)\n\t\t\t\t\t ? gov_hidden_number : gov_hidden_bool;\n    if (options[opt_idx].flags & P_NUM)\n\t*numval = *(long *)varp;\n    else\n    {\n\t// Special case: 'modified' is b_changed, but we also want to consider\n\t// it set when 'ff' or 'fenc' changed.\n\tif ((int *)varp == &curbuf->b_changed)\n\t    *numval = curbufIsChanged();\n\telse\n\t    *numval = (long) *(int *)varp;\n    }\n    return (options[opt_idx].flags & P_NUM) ? gov_number : gov_bool;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Returns the option attributes and its value. Unlike the above function it\n * will return either global value or local value of the option depending on\n * what was requested, but it will never return global value if it was\n * requested to return local one and vice versa. Neither it will return\n * buffer-local value if it was requested to return window-local one.\n *\n * Pretends that option is absent if it is not present in the requested scope\n * (i.e. has no global, window-local or buffer-local value depending on\n * opt_type). Uses\n *\n * Returned flags:\n *       0 hidden or unknown option, also option that does not have requested\n *\t   type (see SREQ_* in vim.h)\n *  see SOPT_* in vim.h for other flags\n *\n * Possible opt_type values: see SREQ_* in vim.h\n */\n    int\nget_option_value_strict(\n    char_u\t*name,\n    long\t*numval,\n    char_u\t**stringval,\t    // NULL when only obtaining attributes\n    int\t\topt_type,\n    void\t*from)\n{\n    int\t\topt_idx;\n    char_u\t*varp = NULL;\n    struct vimoption *p;\n    int\t\tr = 0;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn 0;\n\n    p = &(options[opt_idx]);\n\n    // Hidden option\n    if (p->var == NULL)\n\treturn 0;\n\n    if (p->flags & P_BOOL)\n\tr |= SOPT_BOOL;\n    else if (p->flags & P_NUM)\n\tr |= SOPT_NUM;\n    else if (p->flags & P_STRING)\n\tr |= SOPT_STRING;\n\n    if (p->indir == PV_NONE)\n    {\n\tif (opt_type == SREQ_GLOBAL)\n\t    r |= SOPT_GLOBAL;\n\telse\n\t    return 0; // Did not request global-only option\n    }\n    else\n    {\n\tif (p->indir & PV_BOTH)\n\t    r |= SOPT_GLOBAL;\n\telse if (opt_type == SREQ_GLOBAL)\n\t    return 0; // Requested global option\n\n\tif (p->indir & PV_WIN)\n\t{\n\t    if (opt_type == SREQ_BUF)\n\t\treturn 0; // Did not request window-local option\n\t    else\n\t\tr |= SOPT_WIN;\n\t}\n\telse if (p->indir & PV_BUF)\n\t{\n\t    if (opt_type == SREQ_WIN)\n\t\treturn 0; // Did not request buffer-local option\n\t    else\n\t\tr |= SOPT_BUF;\n\t}\n    }\n\n    if (stringval == NULL)\n\treturn r;\n\n    if (opt_type == SREQ_GLOBAL)\n\tvarp = p->var;\n    else\n    {\n\tif (opt_type == SREQ_BUF)\n\t{\n\t    // Special case: 'modified' is b_changed, but we also want to\n\t    // consider it set when 'ff' or 'fenc' changed.\n\t    if (p->indir == PV_MOD)\n\t    {\n\t\t*numval = bufIsChanged((buf_T *)from);\n\t\tvarp = NULL;\n\t    }\n#ifdef FEAT_CRYPT\n\t    else if (p->indir == PV_KEY)\n\t    {\n\t\t// never return the value of the crypt key\n\t\t*stringval = NULL;\n\t\tvarp = NULL;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\t// only getting a pointer, no need to use aucmd_prepbuf()\n\t\tcurbuf = (buf_T *)from;\n\t\tcurwin->w_buffer = curbuf;\n\t\tvarp = get_varp(p);\n\t\tcurbuf = save_curbuf;\n\t\tcurwin->w_buffer = curbuf;\n\t    }\n\t}\n\telse if (opt_type == SREQ_WIN)\n\t{\n\t    win_T\t*save_curwin = curwin;\n\n\t    curwin = (win_T *)from;\n\t    curbuf = curwin->w_buffer;\n\t    varp = get_varp(p);\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t}\n\tif (varp == p->var)\n\t    return (r | SOPT_UNSET);\n    }\n\n    if (varp != NULL)\n    {\n\tif (p->flags & P_STRING)\n\t    *stringval = vim_strsave(*(char_u **)(varp));\n\telse if (p->flags & P_NUM)\n\t    *numval = *(long *) varp;\n\telse\n\t    *numval = *(int *)varp;\n    }\n\n    return r;\n}\n\n/*\n * Iterate over options. First argument is a pointer to a pointer to a\n * structure inside options[] array, second is option type like in the above\n * function.\n *\n * If first argument points to NULL it is assumed that iteration just started\n * and caller needs the very first value.\n * If first argument points to the end marker function returns NULL and sets\n * first argument to NULL.\n *\n * Returns full option name for current option on each call.\n */\n    char_u *\noption_iter_next(void **option, int opt_type)\n{\n    struct vimoption\t*ret = NULL;\n    do\n    {\n\tif (*option == NULL)\n\t    *option = (void *) options;\n\telse if (((struct vimoption *) (*option))->fullname == NULL)\n\t{\n\t    *option = NULL;\n\t    return NULL;\n\t}\n\telse\n\t    *option = (void *) (((struct vimoption *) (*option)) + 1);\n\n\tret = ((struct vimoption *) (*option));\n\n\t// Hidden option\n\tif (ret->var == NULL)\n\t{\n\t    ret = NULL;\n\t    continue;\n\t}\n\n\tswitch (opt_type)\n\t{\n\t    case SREQ_GLOBAL:\n\t\tif (!(ret->indir == PV_NONE || ret->indir & PV_BOTH))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_BUF:\n\t\tif (!(ret->indir & PV_BUF))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    case SREQ_WIN:\n\t\tif (!(ret->indir & PV_WIN))\n\t\t    ret = NULL;\n\t\tbreak;\n\t    default:\n\t\tinternal_error(\"option_iter_next()\");\n\t\treturn NULL;\n\t}\n    }\n    while (ret == NULL);\n\n    return (char_u *)ret->fullname;\n}\n#endif\n\n/*\n * Return the flags for the option at 'opt_idx'.\n */\n    long_u\nget_option_flags(int opt_idx)\n{\n    return options[opt_idx].flags;\n}\n\n/*\n * Set a flag for the option at 'opt_idx'.\n */\n    void\nset_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags |= flag;\n}\n\n/*\n * Clear a flag for the option at 'opt_idx'.\n */\n    void\nclear_option_flag(int opt_idx, long_u flag)\n{\n    options[opt_idx].flags &= ~flag;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option\n */\n    int\nis_global_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_NONE;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a global option which also has a\n * local value.\n */\n    int\nis_global_local_option(int opt_idx)\n{\n    return options[opt_idx].indir & PV_BOTH;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a window-local option\n */\n    int\nis_window_local_option(int opt_idx)\n{\n    return options[opt_idx].var == VAR_WIN;\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' is a hidden option\n */\n    int\nis_hidden_option(int opt_idx)\n{\n    return options[opt_idx].var == NULL;\n}\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Returns TRUE if the option at 'opt_idx' is a crypt key option\n */\n    int\nis_crypt_key_option(int opt_idx)\n{\n    return options[opt_idx].indir == PV_KEY;\n}\n#endif\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    add_termcode(key_name, string, FALSE);\n\t    if (full_screen)\n\t\tttest(FALSE);\n\t    redraw_all_later(CLEAR);\n\t    return NULL;\n\t}\n\n\tsemsg(_(\"E355: Unknown option: %s\"), name);\n    }\n    else\n    {\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags);\n\telse\n\t{\n\t    varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\t    if (varp != NULL)\t// hidden option is not changed\n\t    {\n\t\tif (number == 0 && string != NULL)\n\t\t{\n\t\t    int idx;\n\n\t\t    // Either we are given a string or we are setting option\n\t\t    // to zero.\n\t\t    for (idx = 0; string[idx] == '0'; ++idx)\n\t\t\t;\n\t\t    if (string[idx] != NUL || idx == 0)\n\t\t    {\n\t\t\t// There's another character after zeros or the string\n\t\t\t// is empty.  In both cases, we are trying to set a\n\t\t\t// num option using a string.\n\t\t\tsemsg(_(\"E521: Number required: &%s = '%s'\"),\n\t\t\t\t\t\t\t\tname, string);\n\t\t\treturn NULL;     // do nothing as we hit an error\n\n\t\t    }\n\t\t}\n\t\tif (flags & P_NUM)\n\t\t    return set_num_option(opt_idx, varp, number,\n\t\t\t\t\t\t\t  NULL, 0, opt_flags);\n\t\telse\n\t\t    return set_bool_option(opt_idx, varp, (int)number,\n\t\t\t\t\t\t\t\t   opt_flags);\n\t    }\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the terminal code for a terminal option.\n * Returns NULL when not found.\n */\n    char_u *\nget_term_code(char_u *tname)\n{\n    int\t    opt_idx;\n    char_u  *varp;\n\n    if (tname[0] != 't' || tname[1] != '_' ||\n\t    tname[2] == NUL || tname[3] == NUL)\n\treturn NULL;\n    if ((opt_idx = findoption(tname)) >= 0)\n    {\n\tvarp = get_varp(&(options[opt_idx]));\n\tif (varp != NULL)\n\t    varp = *(char_u **)(varp);\n\treturn varp;\n    }\n    return find_termcode(tname + 2);\n}\n\n    char_u *\nget_highlight_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"hl\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n    char_u *\nget_encoding_default(void)\n{\n    int i;\n\n    i = findoption((char_u *)\"enc\");\n    if (i >= 0)\n\treturn options[i].def_val[VI_DEFAULT];\n    return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n * When \"has_lt\" is true there is a '<' before \"*arg_arg\".\n * Returns 0 when the key is not recognized.\n */\n    static int\nfind_key_option(char_u *arg_arg, int has_lt)\n{\n    int\t\tkey = 0;\n    int\t\tmodifiers;\n    char_u\t*arg = arg_arg;\n\n    /*\n     * Don't use get_special_key_code() for t_xx, we don't want it to call\n     * add_termcap_entry().\n     */\n    if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])\n\tkey = TERMCAP2KEY(arg[2], arg[3]);\n    else if (has_lt)\n    {\n\t--arg;\t\t\t    // put arg at the '<'\n\tmodifiers = 0;\n\tkey = find_special_key(&arg, &modifiers,\n\t\t\t    FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);\n\tif (modifiers)\t\t    // can't handle modifiers here\n\t    key = 0;\n    }\n    return key;\n}\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n * if 'all' == 2: show all terminal options\n */\n    static void\nshowoptions(\n    int\t\tall,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    struct vimoption\t*p;\n    int\t\t\tcol;\n    int\t\t\tisterm;\n    char_u\t\t*varp;\n    struct vimoption\t**items;\n    int\t\t\titem_count;\n    int\t\t\trun;\n    int\t\t\trow, rows;\n    int\t\t\tcols;\n    int\t\t\ti;\n    int\t\t\tlen;\n\n#define INC 20\n#define GAP 3\n\n    items = ALLOC_MULT(struct vimoption *, OPTION_COUNT);\n    if (items == NULL)\n\treturn;\n\n    // Highlight title\n    if (all == 2)\n\tmsg_puts_title(_(\"\\n--- Terminal codes ---\"));\n    else if (opt_flags & OPT_GLOBAL)\n\tmsg_puts_title(_(\"\\n--- Global option values ---\"));\n    else if (opt_flags & OPT_LOCAL)\n\tmsg_puts_title(_(\"\\n--- Local option values ---\"));\n    else\n\tmsg_puts_title(_(\"\\n--- Options ---\"));\n\n    /*\n     * Do the loop two times:\n     * 1. display the short items\n     * 2. display the long items (only strings and numbers)\n     * When \"opt_flags\" has OPT_ONECOLUMN do everything in run 2.\n     */\n    for (run = 1; run <= 2 && !got_int; ++run)\n    {\n\t/*\n\t * collect the items in items[]\n\t */\n\titem_count = 0;\n\tfor (p = &options[0]; p->fullname != NULL; p++)\n\t{\n\t    // apply :filter /pat/\n\t    if (message_filtered((char_u *)p->fullname))\n\t\tcontinue;\n\n\t    varp = NULL;\n\t    isterm = istermoption(p);\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) != 0)\n\t    {\n\t\tif (p->indir != PV_NONE && !isterm)\n\t\t    varp = get_varp_scope(p, opt_flags);\n\t    }\n\t    else\n\t\tvarp = get_varp(p);\n\t    if (varp != NULL\n\t\t    && ((all == 2 && isterm)\n\t\t\t|| (all == 1 && !isterm)\n\t\t\t|| (all == 0 && !optval_default(p, varp, p_cp))))\n\t    {\n\t\tif (opt_flags & OPT_ONECOLUMN)\n\t\t    len = Columns;\n\t\telse if (p->flags & P_BOOL)\n\t\t    len = 1;\t\t// a toggle option fits always\n\t\telse\n\t\t{\n\t\t    option_value2string(p, opt_flags);\n\t\t    len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n\t\t}\n\t\tif ((len <= INC - GAP && run == 1) ||\n\t\t\t\t\t\t(len > INC - GAP && run == 2))\n\t\t    items[item_count++] = p;\n\t    }\n\t}\n\n\t/*\n\t * display the items\n\t */\n\tif (run == 1)\n\t{\n\t    cols = (Columns + GAP - 3) / INC;\n\t    if (cols == 0)\n\t\tcols = 1;\n\t    rows = (item_count + cols - 1) / cols;\n\t}\n\telse\t// run == 2\n\t    rows = item_count;\n\tfor (row = 0; row < rows && !got_int; ++row)\n\t{\n\t    msg_putchar('\\n');\t\t\t// go to next line\n\t    if (got_int)\t\t\t// 'q' typed in more\n\t\tbreak;\n\t    col = 0;\n\t    for (i = row; i < item_count; i += rows)\n\t    {\n\t\tmsg_col = col;\t\t\t// make columns\n\t\tshowoneopt(items[i], opt_flags);\n\t\tcol += INC;\n\t    }\n\t    out_flush();\n\t    ui_breakcheck();\n\t}\n    }\n    vim_free(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\n    static int\noptval_default(struct vimoption *p, char_u *varp, int compatible)\n{\n    int\t\tdvi;\n\n    if (varp == NULL)\n\treturn TRUE;\t    // hidden option is always at default\n    dvi = ((p->flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (p->flags & P_NUM)\n\treturn (*(long *)varp == (long)(long_i)p->def_val[dvi]);\n    if (p->flags & P_BOOL)\n\t\t\t// the cast to long is required for Manx C, long_i is\n\t\t\t// needed for MSVC\n\treturn (*(int *)varp == (int)(long)(long_i)p->def_val[dvi]);\n    // P_STRING\n    return (STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0);\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\n    static void\nshowoneopt(\n    struct vimoption\t*p,\n    int\t\t\topt_flags)\t// OPT_LOCAL or OPT_GLOBAL\n{\n    char_u\t*varp;\n    int\t\tsave_silent = silent_mode;\n\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\n    varp = get_varp_scope(p, opt_flags);\n\n    // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n    if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n\t\t\t\t\t? !curbufIsChanged() : !*(int *)varp))\n\tmsg_puts(\"no\");\n    else if ((p->flags & P_BOOL) && *(int *)varp < 0)\n\tmsg_puts(\"--\");\n    else\n\tmsg_puts(\"  \");\n    msg_puts(p->fullname);\n    if (!(p->flags & P_BOOL))\n    {\n\tmsg_putchar('=');\n\t// put value string in NameBuff\n\toption_value2string(p, opt_flags);\n\tmsg_outtrans(NameBuff);\n    }\n\n    silent_mode = save_silent;\n    info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\n    int\nmakeset(FILE *fd, int opt_flags, int local_only)\n{\n    struct vimoption\t*p;\n    char_u\t\t*varp;\t\t\t// currently used value\n    char_u\t\t*varp_fresh;\t\t// local value\n    char_u\t\t*varp_local = NULL;\t// fresh value\n    char\t\t*cmd;\n    int\t\t\tround;\n    int\t\t\tpri;\n\n    /*\n     * The options that don't have a default (terminal name, columns, lines)\n     * are never written.  Terminal options are also not written.\n     * Do the loop over \"options[]\" twice: once for options with the\n     * P_PRI_MKRC flag and once without.\n     */\n    for (pri = 1; pri >= 0; --pri)\n    {\n      for (p = &options[0]; !istermoption(p); p++)\n\tif (!(p->flags & P_NO_MKRC)\n\t\t&& !istermoption(p)\n\t\t&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))\n\t{\n\t    // skip global option when only doing locals\n\t    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n\t\tcontinue;\n\n\t    // Do not store options like 'bufhidden' and 'syntax' in a vimrc\n\t    // file, they are always buffer-specific.\n\t    if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n\t\tcontinue;\n\n\t    // Global values are only written when not at the default value.\n\t    varp = get_varp_scope(p, opt_flags);\n\t    if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp, p_cp))\n\t\tcontinue;\n\n\t    if ((opt_flags & OPT_SKIPRTP) && (p->var == (char_u *)&p_rtp\n\t\t\t\t\t\t || p->var == (char_u *)&p_pp))\n\t\tcontinue;\n\n\t    round = 2;\n\t    if (p->indir != PV_NONE)\n\t    {\n\t\tif (p->var == VAR_WIN)\n\t\t{\n\t\t    // skip window-local option when only doing globals\n\t\t    if (!(opt_flags & OPT_LOCAL))\n\t\t\tcontinue;\n\t\t    // When fresh value of window-local option is not at the\n\t\t    // default, need to write it too.\n\t\t    if (!(opt_flags & OPT_GLOBAL) && !local_only)\n\t\t    {\n\t\t\tvarp_fresh = get_varp_scope(p, OPT_GLOBAL);\n\t\t\tif (!optval_default(p, varp_fresh, p_cp))\n\t\t\t{\n\t\t\t    round = 1;\n\t\t\t    varp_local = varp;\n\t\t\t    varp = varp_fresh;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Round 1: fresh value for window-local options.\n\t    // Round 2: other values\n\t    for ( ; round <= 2; varp = varp_local, ++round)\n\t    {\n\t\tif (round == 1 || (opt_flags & OPT_GLOBAL))\n\t\t    cmd = \"set\";\n\t\telse\n\t\t    cmd = \"setlocal\";\n\n\t\tif (p->flags & P_BOOL)\n\t\t{\n\t\t    if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse if (p->flags & P_NUM)\n\t\t{\n\t\t    if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse    // P_STRING\n\t\t{\n\t\t    int\t\tdo_endif = FALSE;\n\n\t\t    // Don't set 'syntax' and 'filetype' again if the value is\n\t\t    // already right, avoids reloading the syntax file.\n\t\t    if (\n#if defined(FEAT_SYN_HL)\n\t\t\t    p->indir == PV_SYN ||\n#endif\n\t\t\t    p->indir == PV_FT)\n\t\t    {\n\t\t\tif (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n\t\t\t\t\t\t       *(char_u **)(varp)) < 0\n\t\t\t\t|| put_eol(fd) < 0)\n\t\t\t    return FAIL;\n\t\t\tdo_endif = TRUE;\n\t\t    }\n\t\t    if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n\t\t\t\t\t\t\t     p->flags) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (do_endif)\n\t\t    {\n\t\t\tif (put_line(fd, \"endif\") == FAIL)\n\t\t\t    return FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\n    int\nmakefoldset(FILE *fd)\n{\n    if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, 0) == FAIL\n# ifdef FEAT_EVAL\n\t    || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n# endif\n\t    || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, 0)\n\t\t\t\t\t\t\t\t       == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n\t    || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n\t    || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n\t    )\n\treturn FAIL;\n\n    return OK;\n}\n#endif\n\n    static int\nput_setstring(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    char_u\t**valuep,\n    long_u\tflags)\n{\n    char_u\t*s;\n    char_u\t*buf = NULL;\n    char_u\t*part = NULL;\n    char_u\t*p;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (*valuep != NULL)\n    {\n\t// Output 'pastetoggle' as key names.  For other\n\t// options some characters have to be escaped with\n\t// CTRL-V or backslash\n\tif (valuep == &p_pt)\n\t{\n\t    s = *valuep;\n\t    while (*s != NUL)\n\t\tif (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n\t\t    return FAIL;\n\t}\n\t// expand the option value, replace $HOME by ~\n\telse if ((flags & P_EXPAND) != 0)\n\t{\n\t    int  size = (int)STRLEN(*valuep) + 1;\n\n\t    // replace home directory in the whole option value into \"buf\"\n\t    buf = alloc(size);\n\t    if (buf == NULL)\n\t\tgoto fail;\n\t    home_replace(NULL, *valuep, buf, size, FALSE);\n\n\t    // If the option value is longer than MAXPATHL, we need to append\n\t    // each comma separated part of the option separately, so that it\n\t    // can be expanded when read back.\n\t    if (size >= MAXPATHL && (flags & P_COMMA) != 0\n\t\t\t\t\t   && vim_strchr(*valuep, ',') != NULL)\n\t    {\n\t\tpart = alloc(size);\n\t\tif (part == NULL)\n\t\t    goto fail;\n\n\t\t// write line break to clear the option, e.g. ':set rtp='\n\t\tif (put_eol(fd) == FAIL)\n\t\t    goto fail;\n\n\t\tp = buf;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    // for each comma separated option part, append value to\n\t\t    // the option, :set rtp+=value\n\t\t    if (fprintf(fd, \"%s %s+=\", cmd, name) < 0)\n\t\t\tgoto fail;\n\t\t    (void)copy_option_part(&p, part, size,  \",\");\n\t\t    if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL)\n\t\t\tgoto fail;\n\t\t}\n\t\tvim_free(buf);\n\t\tvim_free(part);\n\t\treturn OK;\n\t    }\n\t    if (put_escstr(fd, buf, 2) == FAIL)\n\t    {\n\t\tvim_free(buf);\n\t\treturn FAIL;\n\t    }\n\t    vim_free(buf);\n\t}\n\telse if (put_escstr(fd, *valuep, 2) == FAIL)\n\t    return FAIL;\n    }\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\nfail:\n    vim_free(buf);\n    vim_free(part);\n    return FAIL;\n}\n\n    static int\nput_setnum(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    long\t*valuep)\n{\n    long\twc;\n\n    if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n\treturn FAIL;\n    if (wc_use_keyname((char_u *)valuep, &wc))\n    {\n\t// print 'wildchar' and 'wildcharm' as a key name\n\tif (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n\t    return FAIL;\n    }\n    else if (fprintf(fd, \"%ld\", *valuep) < 0)\n\treturn FAIL;\n    if (put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n    static int\nput_setbool(\n    FILE\t*fd,\n    char\t*cmd,\n    char\t*name,\n    int\t\tvalue)\n{\n    if (value < 0)\t// global/local option using global value\n\treturn OK;\n    if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n\t    || put_eol(fd) < 0)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Clear all the terminal options.\n * If the option has been allocated, free the memory.\n * Terminal options are never hidden or indirect.\n */\n    void\nclear_termoptions(void)\n{\n    /*\n     * Reset a few things before clearing the old options. This may cause\n     * outputting a few things that the terminal doesn't understand, but the\n     * screen will be cleared later, so this is OK.\n     */\n    mch_setmouse(FALSE);\t    // switch mouse off\n#ifdef FEAT_TITLE\n    mch_restore_title(SAVE_RESTORE_BOTH);    // restore window titles\n#endif\n#if defined(FEAT_XCLIPBOARD) && defined(FEAT_GUI)\n    // When starting the GUI close the display opened for the clipboard.\n    // After restoring the title, because that will need the display.\n    if (gui.starting)\n\tclear_xterm_clip();\n#endif\n    stoptermcap();\t\t\t// stop termcap mode\n\n    free_termoptions();\n}\n\n    void\nfree_termoptions(void)\n{\n    struct vimoption   *p;\n\n    for (p = options; p->fullname != NULL; p++)\n\tif (istermoption(p))\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    if (p->flags & P_DEF_ALLOCED)\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->def_val[VI_DEFAULT] = empty_option;\n\t    p->flags &= ~(P_ALLOCED|P_DEF_ALLOCED);\n#ifdef FEAT_EVAL\n\t    // remember where the option was cleared\n\t    set_option_sctx_idx((int)(p - options), OPT_GLOBAL, current_sctx);\n#endif\n\t}\n    clear_termcodes();\n}\n\n/*\n * Free the string for one term option, if it was allocated.\n * Set the string to empty_option and clear allocated flag.\n * \"var\" points to the option value.\n */\n    void\nfree_one_termoption(char_u *var)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n\tif (p->var == var)\n\t{\n\t    if (p->flags & P_ALLOCED)\n\t\tfree_string_option(*(char_u **)(p->var));\n\t    *(char_u **)(p->var) = empty_option;\n\t    p->flags &= ~P_ALLOCED;\n\t    break;\n\t}\n}\n\n/*\n * Set the terminal option defaults to the current value.\n * Used after setting the terminal name.\n */\n    void\nset_term_defaults(void)\n{\n    struct vimoption   *p;\n\n    for (p = &options[0]; p->fullname != NULL; p++)\n    {\n\tif (istermoption(p) && p->def_val[VI_DEFAULT] != *(char_u **)(p->var))\n\t{\n\t    if (p->flags & P_DEF_ALLOCED)\n\t    {\n\t\tfree_string_option(p->def_val[VI_DEFAULT]);\n\t\tp->flags &= ~P_DEF_ALLOCED;\n\t    }\n\t    p->def_val[VI_DEFAULT] = *(char_u **)(p->var);\n\t    if (p->flags & P_ALLOCED)\n\t    {\n\t\tp->flags |= P_DEF_ALLOCED;\n\t\tp->flags &= ~P_ALLOCED;\t // don't free the value now\n\t    }\n\t}\n    }\n}\n\n/*\n * return TRUE if 'p' starts with 't_'\n */\n    static int\nistermoption(struct vimoption *p)\n{\n    return (p->fullname[0] == 't' && p->fullname[1] == '_');\n}\n\n/*\n * Returns TRUE if the option at 'opt_idx' starts with 't_'\n */\n    int\nistermoption_idx(int opt_idx)\n{\n    return istermoption(&options[opt_idx]);\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n/*\n * Unset local option value, similar to \":set opt<\".\n */\n    void\nunset_global_local_option(char_u *name, void *from)\n{\n    struct vimoption *p;\n    int\t\topt_idx;\n    buf_T\t*buf = (buf_T *)from;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n\treturn;\n    p = &(options[opt_idx]);\n\n    switch ((int)p->indir)\n    {\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\n\t    clear_string_option(&buf->b_p_ep);\n\t    break;\n\tcase PV_KP:\n\t    clear_string_option(&buf->b_p_kp);\n\t    break;\n\tcase PV_PATH:\n\t    clear_string_option(&buf->b_p_path);\n\t    break;\n\tcase PV_AR:\n\t    buf->b_p_ar = -1;\n\t    break;\n\tcase PV_BKC:\n\t    clear_string_option(&buf->b_p_bkc);\n\t    buf->b_bkc_flags = 0;\n\t    break;\n\tcase PV_TAGS:\n\t    clear_string_option(&buf->b_p_tags);\n\t    break;\n\tcase PV_TC:\n\t    clear_string_option(&buf->b_p_tc);\n\t    buf->b_tc_flags = 0;\n\t    break;\n        case PV_SISO:\n            curwin->w_p_siso = -1;\n            break;\n        case PV_SO:\n            curwin->w_p_so = -1;\n            break;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\n\t    clear_string_option(&buf->b_p_def);\n\t    break;\n\tcase PV_INC:\n\t    clear_string_option(&buf->b_p_inc);\n\t    break;\n#endif\n\tcase PV_DICT:\n\t    clear_string_option(&buf->b_p_dict);\n\t    break;\n\tcase PV_TSR:\n\t    clear_string_option(&buf->b_p_tsr);\n\t    break;\n\tcase PV_FP:\n\t    clear_string_option(&buf->b_p_fp);\n\t    break;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\n\t    clear_string_option(&buf->b_p_efm);\n\t    break;\n\tcase PV_GP:\n\t    clear_string_option(&buf->b_p_gp);\n\t    break;\n\tcase PV_MP:\n\t    clear_string_option(&buf->b_p_mp);\n\t    break;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\n\t    clear_string_option(&buf->b_p_bexpr);\n\t    break;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\n\t    clear_string_option(&buf->b_p_cm);\n\t    break;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\n\t    clear_string_option(&((win_T *)from)->w_p_sbr);\n\t    break;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\n\t    clear_string_option(&((win_T *)from)->w_p_stl);\n\t    break;\n#endif\n\tcase PV_UL:\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    break;\n#ifdef FEAT_LISP\n\tcase PV_LW:\n\t    clear_string_option(&buf->b_p_lw);\n\t    break;\n#endif\n\tcase PV_MENC:\n\t    clear_string_option(&buf->b_p_menc);\n\t    break;\n\tcase PV_LCS:\n\t    clear_string_option(&((win_T *)from)->w_p_lcs);\n\t    set_chars_option((win_T *)from, &((win_T *)from)->w_p_lcs);\n\t    redraw_later(NOT_VALID);\n\t    break;\n\tcase PV_VE:\n\t    clear_string_option(&((win_T *)from)->w_p_ve);\n\t    ((win_T *)from)->w_ve_flags = 0;\n\t    break;\n    }\n}\n#endif\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n */\n    static char_u *\nget_varp_scope(struct vimoption *p, int opt_flags)\n{\n    if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE)\n    {\n\tif (p->var == VAR_WIN)\n\t    return (char_u *)GLOBAL_WO(get_varp(p));\n\treturn p->var;\n    }\n    if ((opt_flags & OPT_LOCAL) && ((int)p->indir & PV_BOTH))\n    {\n\tswitch ((int)p->indir)\n\t{\n\t    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);\n#ifdef FEAT_QUICKFIX\n\t    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n\t    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n\t    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n#endif\n\t    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n\t    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n\t    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n\t    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n\t    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n\t    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n            case PV_SISO: return (char_u *)&(curwin->w_p_siso);\n            case PV_SO:   return (char_u *)&(curwin->w_p_so);\n#ifdef FEAT_FIND_ID\n\t    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n\t    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n#endif\n\t    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n\t    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    case PV_BEXPR: return (char_u *)&(curbuf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n\t    case PV_CM:\t  return (char_u *)&(curbuf->b_p_cm);\n#endif\n#ifdef FEAT_LINEBREAK\n\t    case PV_SBR:  return (char_u *)&(curwin->w_p_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n\t    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n#endif\n\t    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n#ifdef FEAT_LISP\n\t    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n#endif\n\t    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n\t    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);\n\t    case PV_LCS:  return (char_u *)&(curwin->w_p_lcs);\n\t    case PV_VE:\t  return (char_u *)&(curwin->w_p_ve);\n\n\t}\n\treturn NULL; // \"cannot happen\"\n    }\n    return get_varp(p);\n}\n\n/*\n * Get pointer to option variable at 'opt_idx', depending on local or global\n * scope.\n */\n    char_u *\nget_option_varp_scope(int opt_idx, int opt_flags)\n{\n    return get_varp_scope(&(options[opt_idx]), opt_flags);\n}\n\n/*\n * Get pointer to option variable.\n */\n    static char_u *\nget_varp(struct vimoption *p)\n{\n    // hidden option, always return NULL\n    if (p->var == NULL)\n\treturn NULL;\n\n    switch ((int)p->indir)\n    {\n\tcase PV_NONE:\treturn p->var;\n\n\t// global option with local value: use local value if it's been set\n\tcase PV_EP:\treturn *curbuf->b_p_ep != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_ep : p->var;\n\tcase PV_KP:\treturn *curbuf->b_p_kp != NUL\n\t\t\t\t    ? (char_u *)&curbuf->b_p_kp : p->var;\n\tcase PV_PATH:\treturn *curbuf->b_p_path != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_path) : p->var;\n\tcase PV_AR:\treturn curbuf->b_p_ar >= 0\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ar) : p->var;\n\tcase PV_TAGS:\treturn *curbuf->b_p_tags != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tags) : p->var;\n\tcase PV_TC:\treturn *curbuf->b_p_tc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tc) : p->var;\n\tcase PV_BKC:\treturn *curbuf->b_p_bkc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n\tcase PV_SISO:\treturn curwin->w_p_siso >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_siso) : p->var;\n\tcase PV_SO:\treturn curwin->w_p_so >= 0\n\t\t\t\t    ? (char_u *)&(curwin->w_p_so) : p->var;\n#ifdef FEAT_FIND_ID\n\tcase PV_DEF:\treturn *curbuf->b_p_def != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_def) : p->var;\n\tcase PV_INC:\treturn *curbuf->b_p_inc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_inc) : p->var;\n#endif\n\tcase PV_DICT:\treturn *curbuf->b_p_dict != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_dict) : p->var;\n\tcase PV_TSR:\treturn *curbuf->b_p_tsr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n\tcase PV_FP:\treturn *curbuf->b_p_fp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_fp) : p->var;\n#ifdef FEAT_QUICKFIX\n\tcase PV_EFM:\treturn *curbuf->b_p_efm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_efm) : p->var;\n\tcase PV_GP:\treturn *curbuf->b_p_gp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_gp) : p->var;\n\tcase PV_MP:\treturn *curbuf->b_p_mp != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_mp) : p->var;\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\tcase PV_BEXPR:\treturn *curbuf->b_p_bexpr != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_bexpr) : p->var;\n#endif\n#if defined(FEAT_CRYPT)\n\tcase PV_CM:\treturn *curbuf->b_p_cm != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_cm) : p->var;\n#endif\n#ifdef FEAT_LINEBREAK\n\tcase PV_SBR:\treturn *curwin->w_p_sbr != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_sbr) : p->var;\n#endif\n#ifdef FEAT_STL_OPT\n\tcase PV_STL:\treturn *curwin->w_p_stl != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_stl) : p->var;\n#endif\n\tcase PV_UL:\treturn curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_ul) : p->var;\n#ifdef FEAT_LISP\n\tcase PV_LW:\treturn *curbuf->b_p_lw != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_lw) : p->var;\n#endif\n\tcase PV_MENC:\treturn *curbuf->b_p_menc != NUL\n\t\t\t\t    ? (char_u *)&(curbuf->b_p_menc) : p->var;\n#ifdef FEAT_ARABIC\n\tcase PV_ARAB:\treturn (char_u *)&(curwin->w_p_arab);\n#endif\n\tcase PV_LIST:\treturn (char_u *)&(curwin->w_p_list);\n\tcase PV_LCS:\treturn *curwin->w_p_lcs != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_lcs) : p->var;\n\tcase PV_VE:\treturn *curwin->w_p_ve != NUL\n\t\t\t\t    ? (char_u *)&(curwin->w_p_ve) : p->var;\n#ifdef FEAT_SPELL\n\tcase PV_SPELL:\treturn (char_u *)&(curwin->w_p_spell);\n#endif\n#ifdef FEAT_SYN_HL\n\tcase PV_CUC:\treturn (char_u *)&(curwin->w_p_cuc);\n\tcase PV_CUL:\treturn (char_u *)&(curwin->w_p_cul);\n\tcase PV_CULOPT:\treturn (char_u *)&(curwin->w_p_culopt);\n\tcase PV_CC:\treturn (char_u *)&(curwin->w_p_cc);\n#endif\n#ifdef FEAT_DIFF\n\tcase PV_DIFF:\treturn (char_u *)&(curwin->w_p_diff);\n#endif\n#ifdef FEAT_FOLDING\n\tcase PV_FDC:\treturn (char_u *)&(curwin->w_p_fdc);\n\tcase PV_FEN:\treturn (char_u *)&(curwin->w_p_fen);\n\tcase PV_FDI:\treturn (char_u *)&(curwin->w_p_fdi);\n\tcase PV_FDL:\treturn (char_u *)&(curwin->w_p_fdl);\n\tcase PV_FDM:\treturn (char_u *)&(curwin->w_p_fdm);\n\tcase PV_FML:\treturn (char_u *)&(curwin->w_p_fml);\n\tcase PV_FDN:\treturn (char_u *)&(curwin->w_p_fdn);\n# ifdef FEAT_EVAL\n\tcase PV_FDE:\treturn (char_u *)&(curwin->w_p_fde);\n\tcase PV_FDT:\treturn (char_u *)&(curwin->w_p_fdt);\n# endif\n\tcase PV_FMR:\treturn (char_u *)&(curwin->w_p_fmr);\n#endif\n\tcase PV_NU:\treturn (char_u *)&(curwin->w_p_nu);\n\tcase PV_RNU:\treturn (char_u *)&(curwin->w_p_rnu);\n#ifdef FEAT_LINEBREAK\n\tcase PV_NUW:\treturn (char_u *)&(curwin->w_p_nuw);\n#endif\n\tcase PV_WFH:\treturn (char_u *)&(curwin->w_p_wfh);\n\tcase PV_WFW:\treturn (char_u *)&(curwin->w_p_wfw);\n#if defined(FEAT_QUICKFIX)\n\tcase PV_PVW:\treturn (char_u *)&(curwin->w_p_pvw);\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tcase PV_RL:\treturn (char_u *)&(curwin->w_p_rl);\n\tcase PV_RLC:\treturn (char_u *)&(curwin->w_p_rlc);\n#endif\n\tcase PV_SCROLL:\treturn (char_u *)&(curwin->w_p_scr);\n\tcase PV_WRAP:\treturn (char_u *)&(curwin->w_p_wrap);\n#ifdef FEAT_LINEBREAK\n\tcase PV_LBR:\treturn (char_u *)&(curwin->w_p_lbr);\n\tcase PV_BRI:\treturn (char_u *)&(curwin->w_p_bri);\n\tcase PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n#endif\n\tcase PV_WCR:\treturn (char_u *)&(curwin->w_p_wcr);\n\tcase PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n\tcase PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n#ifdef FEAT_CONCEAL\n\tcase PV_COCU:   return (char_u *)&(curwin->w_p_cocu);\n\tcase PV_COLE:   return (char_u *)&(curwin->w_p_cole);\n#endif\n#ifdef FEAT_TERMINAL\n\tcase PV_TWK:    return (char_u *)&(curwin->w_p_twk);\n\tcase PV_TWS:    return (char_u *)&(curwin->w_p_tws);\n\tcase PV_TWSL:\treturn (char_u *)&(curbuf->b_p_twsl);\n#endif\n\n\tcase PV_AI:\treturn (char_u *)&(curbuf->b_p_ai);\n\tcase PV_BIN:\treturn (char_u *)&(curbuf->b_p_bin);\n\tcase PV_BOMB:\treturn (char_u *)&(curbuf->b_p_bomb);\n\tcase PV_BH:\treturn (char_u *)&(curbuf->b_p_bh);\n\tcase PV_BT:\treturn (char_u *)&(curbuf->b_p_bt);\n\tcase PV_BL:\treturn (char_u *)&(curbuf->b_p_bl);\n\tcase PV_CI:\treturn (char_u *)&(curbuf->b_p_ci);\n#ifdef FEAT_CINDENT\n\tcase PV_CIN:\treturn (char_u *)&(curbuf->b_p_cin);\n\tcase PV_CINK:\treturn (char_u *)&(curbuf->b_p_cink);\n\tcase PV_CINO:\treturn (char_u *)&(curbuf->b_p_cino);\n#endif\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\tcase PV_CINW:\treturn (char_u *)&(curbuf->b_p_cinw);\n#endif\n\tcase PV_COM:\treturn (char_u *)&(curbuf->b_p_com);\n#ifdef FEAT_FOLDING\n\tcase PV_CMS:\treturn (char_u *)&(curbuf->b_p_cms);\n#endif\n\tcase PV_CPT:\treturn (char_u *)&(curbuf->b_p_cpt);\n#ifdef BACKSLASH_IN_FILENAME\n\tcase PV_CSL:\treturn (char_u *)&(curbuf->b_p_csl);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\tcase PV_CFU:\treturn (char_u *)&(curbuf->b_p_cfu);\n\tcase PV_OFU:\treturn (char_u *)&(curbuf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_TFU:\treturn (char_u *)&(curbuf->b_p_tfu);\n#endif\n\tcase PV_EOL:\treturn (char_u *)&(curbuf->b_p_eol);\n\tcase PV_FIXEOL:\treturn (char_u *)&(curbuf->b_p_fixeol);\n\tcase PV_ET:\treturn (char_u *)&(curbuf->b_p_et);\n\tcase PV_FENC:\treturn (char_u *)&(curbuf->b_p_fenc);\n\tcase PV_FF:\treturn (char_u *)&(curbuf->b_p_ff);\n\tcase PV_FT:\treturn (char_u *)&(curbuf->b_p_ft);\n\tcase PV_FO:\treturn (char_u *)&(curbuf->b_p_fo);\n\tcase PV_FLP:\treturn (char_u *)&(curbuf->b_p_flp);\n\tcase PV_IMI:\treturn (char_u *)&(curbuf->b_p_iminsert);\n\tcase PV_IMS:\treturn (char_u *)&(curbuf->b_p_imsearch);\n\tcase PV_INF:\treturn (char_u *)&(curbuf->b_p_inf);\n\tcase PV_ISK:\treturn (char_u *)&(curbuf->b_p_isk);\n#ifdef FEAT_FIND_ID\n# ifdef FEAT_EVAL\n\tcase PV_INEX:\treturn (char_u *)&(curbuf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\tcase PV_INDE:\treturn (char_u *)&(curbuf->b_p_inde);\n\tcase PV_INDK:\treturn (char_u *)&(curbuf->b_p_indk);\n#endif\n#ifdef FEAT_EVAL\n\tcase PV_FEX:\treturn (char_u *)&(curbuf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n\tcase PV_KEY:\treturn (char_u *)&(curbuf->b_p_key);\n#endif\n#ifdef FEAT_LISP\n\tcase PV_LISP:\treturn (char_u *)&(curbuf->b_p_lisp);\n#endif\n\tcase PV_ML:\treturn (char_u *)&(curbuf->b_p_ml);\n\tcase PV_MPS:\treturn (char_u *)&(curbuf->b_p_mps);\n\tcase PV_MA:\treturn (char_u *)&(curbuf->b_p_ma);\n\tcase PV_MOD:\treturn (char_u *)&(curbuf->b_changed);\n\tcase PV_NF:\treturn (char_u *)&(curbuf->b_p_nf);\n\tcase PV_PI:\treturn (char_u *)&(curbuf->b_p_pi);\n#ifdef FEAT_TEXTOBJ\n\tcase PV_QE:\treturn (char_u *)&(curbuf->b_p_qe);\n#endif\n\tcase PV_RO:\treturn (char_u *)&(curbuf->b_p_ro);\n#ifdef FEAT_SMARTINDENT\n\tcase PV_SI:\treturn (char_u *)&(curbuf->b_p_si);\n#endif\n\tcase PV_SN:\treturn (char_u *)&(curbuf->b_p_sn);\n\tcase PV_STS:\treturn (char_u *)&(curbuf->b_p_sts);\n#ifdef FEAT_SEARCHPATH\n\tcase PV_SUA:\treturn (char_u *)&(curbuf->b_p_sua);\n#endif\n\tcase PV_SWF:\treturn (char_u *)&(curbuf->b_p_swf);\n#ifdef FEAT_SYN_HL\n\tcase PV_SMC:\treturn (char_u *)&(curbuf->b_p_smc);\n\tcase PV_SYN:\treturn (char_u *)&(curbuf->b_p_syn);\n#endif\n#ifdef FEAT_SPELL\n\tcase PV_SPC:\treturn (char_u *)&(curwin->w_s->b_p_spc);\n\tcase PV_SPF:\treturn (char_u *)&(curwin->w_s->b_p_spf);\n\tcase PV_SPL:\treturn (char_u *)&(curwin->w_s->b_p_spl);\n\tcase PV_SPO:\treturn (char_u *)&(curwin->w_s->b_p_spo);\n#endif\n\tcase PV_SW:\treturn (char_u *)&(curbuf->b_p_sw);\n\tcase PV_TS:\treturn (char_u *)&(curbuf->b_p_ts);\n\tcase PV_TW:\treturn (char_u *)&(curbuf->b_p_tw);\n\tcase PV_TX:\treturn (char_u *)&(curbuf->b_p_tx);\n#ifdef FEAT_PERSISTENT_UNDO\n\tcase PV_UDF:\treturn (char_u *)&(curbuf->b_p_udf);\n#endif\n\tcase PV_WM:\treturn (char_u *)&(curbuf->b_p_wm);\n#ifdef FEAT_KEYMAP\n\tcase PV_KMAP:\treturn (char_u *)&(curbuf->b_p_keymap);\n#endif\n#ifdef FEAT_SIGNS\n\tcase PV_SCL:\treturn (char_u *)&(curwin->w_p_scl);\n#endif\n#ifdef FEAT_VARTABS\n\tcase PV_VSTS:\treturn (char_u *)&(curbuf->b_p_vsts);\n\tcase PV_VTS:\treturn (char_u *)&(curbuf->b_p_vts);\n#endif\n\tdefault:\tiemsg(_(\"E356: get_varp ERROR\"));\n    }\n    // always return a valid pointer to avoid a crash!\n    return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Return a pointer to the variable for option at 'opt_idx'\n */\n    char_u *\nget_option_var(int opt_idx)\n{\n    return options[opt_idx].var;\n}\n\n/*\n * Return the full name of the option at 'opt_idx'\n */\n    char_u *\nget_option_fullname(int opt_idx)\n{\n    return (char_u *)options[opt_idx].fullname;\n}\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\n    char_u *\nget_equalprg(void)\n{\n    if (*curbuf->b_p_ep == NUL)\n\treturn p_ep;\n    return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\n    void\nwin_copy_options(win_T *wp_from, win_T *wp_to)\n{\n    copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n    copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n    after_copy_winopt(wp_to);\n}\n\n/*\n * After copying window options: update variables depending on options.\n */\n    void\nafter_copy_winopt(win_T *wp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    briopt_check(wp);\n#endif\n#ifdef FEAT_SYN_HL\n    fill_culopt_flags(NULL, wp);\n    check_colorcolumn(wp);\n#endif\n    set_chars_option(wp, &wp->w_p_lcs);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\n    void\ncopy_winopt(winopt_T *from, winopt_T *to)\n{\n#ifdef FEAT_ARABIC\n    to->wo_arab = from->wo_arab;\n#endif\n    to->wo_list = from->wo_list;\n    to->wo_lcs = vim_strsave(from->wo_lcs);\n    to->wo_nu = from->wo_nu;\n    to->wo_rnu = from->wo_rnu;\n    to->wo_ve = vim_strsave(from->wo_ve);\n    to->wo_ve_flags = from->wo_ve_flags;\n#ifdef FEAT_LINEBREAK\n    to->wo_nuw = from->wo_nuw;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    to->wo_rl  = from->wo_rl;\n    to->wo_rlc = vim_strsave(from->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_sbr = vim_strsave(from->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    to->wo_stl = vim_strsave(from->wo_stl);\n#endif\n    to->wo_wrap = from->wo_wrap;\n#ifdef FEAT_DIFF\n    to->wo_wrap_save = from->wo_wrap_save;\n#endif\n#ifdef FEAT_LINEBREAK\n    to->wo_lbr = from->wo_lbr;\n    to->wo_bri = from->wo_bri;\n    to->wo_briopt = vim_strsave(from->wo_briopt);\n#endif\n    to->wo_wcr = vim_strsave(from->wo_wcr);\n    to->wo_scb = from->wo_scb;\n    to->wo_scb_save = from->wo_scb_save;\n    to->wo_crb = from->wo_crb;\n    to->wo_crb_save = from->wo_crb_save;\n#ifdef FEAT_SPELL\n    to->wo_spell = from->wo_spell;\n#endif\n#ifdef FEAT_SYN_HL\n    to->wo_cuc = from->wo_cuc;\n    to->wo_cul = from->wo_cul;\n    to->wo_culopt = vim_strsave(from->wo_culopt);\n    to->wo_cc = vim_strsave(from->wo_cc);\n#endif\n#ifdef FEAT_DIFF\n    to->wo_diff = from->wo_diff;\n    to->wo_diff_saved = from->wo_diff_saved;\n#endif\n#ifdef FEAT_CONCEAL\n    to->wo_cocu = vim_strsave(from->wo_cocu);\n    to->wo_cole = from->wo_cole;\n#endif\n#ifdef FEAT_TERMINAL\n    to->wo_twk = vim_strsave(from->wo_twk);\n    to->wo_tws = vim_strsave(from->wo_tws);\n#endif\n#ifdef FEAT_FOLDING\n    to->wo_fdc = from->wo_fdc;\n    to->wo_fdc_save = from->wo_fdc_save;\n    to->wo_fen = from->wo_fen;\n    to->wo_fen_save = from->wo_fen_save;\n    to->wo_fdi = vim_strsave(from->wo_fdi);\n    to->wo_fml = from->wo_fml;\n    to->wo_fdl = from->wo_fdl;\n    to->wo_fdl_save = from->wo_fdl_save;\n    to->wo_fdm = vim_strsave(from->wo_fdm);\n    to->wo_fdm_save = from->wo_diff_saved\n\t\t\t      ? vim_strsave(from->wo_fdm_save) : empty_option;\n    to->wo_fdn = from->wo_fdn;\n# ifdef FEAT_EVAL\n    to->wo_fde = vim_strsave(from->wo_fde);\n    to->wo_fdt = vim_strsave(from->wo_fdt);\n# endif\n    to->wo_fmr = vim_strsave(from->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    to->wo_scl = vim_strsave(from->wo_scl);\n#endif\n\n#ifdef FEAT_EVAL\n    // Copy the script context so that we know where the value was last set.\n    mch_memmove(to->wo_script_ctx, from->wo_script_ctx,\n\t\t\t\t\t\t    sizeof(to->wo_script_ctx));\n#endif\n    check_winopt(to);\t\t// don't want NULL pointers\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\n    static void\ncheck_win_options(win_T *win)\n{\n    check_winopt(&win->w_onebuf_opt);\n    check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\n    static void\ncheck_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    check_string_option(&wop->wo_fdi);\n    check_string_option(&wop->wo_fdm);\n    check_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    check_string_option(&wop->wo_fde);\n    check_string_option(&wop->wo_fdt);\n# endif\n    check_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    check_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_RIGHTLEFT\n    check_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    check_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&wop->wo_culopt);\n    check_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    check_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    check_string_option(&wop->wo_twk);\n    check_string_option(&wop->wo_tws);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_briopt);\n#endif\n    check_string_option(&wop->wo_wcr);\n    check_string_option(&wop->wo_lcs);\n    check_string_option(&wop->wo_ve);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\n    void\nclear_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    clear_string_option(&wop->wo_fdi);\n    clear_string_option(&wop->wo_fdm);\n    clear_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    clear_string_option(&wop->wo_fde);\n    clear_string_option(&wop->wo_fdt);\n# endif\n    clear_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    clear_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_briopt);\n#endif\n    clear_string_option(&wop->wo_wcr);\n#ifdef FEAT_RIGHTLEFT\n    clear_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_LINEBREAK\n    clear_string_option(&wop->wo_sbr);\n#endif\n#ifdef FEAT_STL_OPT\n    clear_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    clear_string_option(&wop->wo_culopt);\n    clear_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    clear_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_TERMINAL\n    clear_string_option(&wop->wo_twk);\n    clear_string_option(&wop->wo_tws);\n#endif\n    clear_string_option(&wop->wo_lcs);\n    clear_string_option(&wop->wo_ve);\n}\n\n#ifdef FEAT_EVAL\n// Index into the options table for a buffer-local option enum.\nstatic int buf_opt_idx[BV_COUNT];\n# define COPY_OPT_SCTX(buf, bv) buf->b_p_script_ctx[bv] = options[buf_opt_idx[bv]].script_ctx\n\n/*\n * Initialize buf_opt_idx[] if not done already.\n */\n    static void\ninit_buf_opt_idx(void)\n{\n    static int did_init_buf_opt_idx = FALSE;\n    int i;\n\n    if (did_init_buf_opt_idx)\n\treturn;\n    did_init_buf_opt_idx = TRUE;\n    for (i = 0; !istermoption_idx(i); i++)\n\tif (options[i].indir & PV_BUF)\n\t    buf_opt_idx[options[i].indir & PV_MASK] = i;\n}\n#else\n# define COPY_OPT_SCTX(buf, bv)\n#endif\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buffer \"buf\".\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\n    void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_INF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\n    void\nreset_modifiable(void)\n{\n    int\t\topt_idx;\n\n    curbuf->b_p_ma = FALSE;\n    p_ma = FALSE;\n    opt_idx = findoption((char_u *)\"ma\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\n    void\nset_iminsert_global(void)\n{\n    p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\n    void\nset_imsearch_global(void)\n{\n    p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\n    void\nset_context_in_set_cmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    int\t\tnextchar;\n    long_u\tflags = 0;\t// init for GCC\n    int\t\topt_idx = 0;\t// init for GCC\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tis_term_option = FALSE;\n    int\t\tkey;\n\n    expand_option_flags = opt_flags;\n\n    xp->xp_context = EXPAND_SETTINGS;\n    if (*arg == NUL)\n    {\n\txp->xp_pattern = arg;\n\treturn;\n    }\n    p = arg + STRLEN(arg) - 1;\n    if (*p == ' ' && *(p - 1) != '\\\\')\n    {\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    while (p > arg)\n    {\n\ts = p;\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    while (s > arg && *(s - 1) == '\\\\')\n\t\t--s;\n\t}\n\t// break at a space with an even number of backslashes\n\tif (*p == ' ' && ((p - s) & 1) == 0)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\t--p;\n    }\n    if (STRNCMP(p, \"no\", 2) == 0 && STRNCMP(p, \"novice\", 6) != 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 2;\n    }\n    if (STRNCMP(p, \"inv\", 3) == 0)\n    {\n\txp->xp_context = EXPAND_BOOL_SETTINGS;\n\tp += 3;\n    }\n    xp->xp_pattern = arg = p;\n    if (*arg == '<')\n    {\n\twhile (*p != '>')\n\t    if (*p++ == NUL)\t    // expand terminal option name\n\t\treturn;\n\tkey = get_special_key_code(arg + 1);\n\tif (key == 0)\t\t    // unknown name\n\t{\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    return;\n\t}\n\tnextchar = *++p;\n\tis_term_option = TRUE;\n\texpand_option_name[2] = KEY2TERMCAP0(key);\n\texpand_option_name[3] = KEY2TERMCAP1(key);\n    }\n    else\n    {\n\tif (p[0] == 't' && p[1] == '_')\n\t{\n\t    p += 2;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == NUL)\n\t\treturn;\t\t// expand option name\n\t    nextchar = *++p;\n\t    is_term_option = TRUE;\n\t    expand_option_name[2] = p[-2];\n\t    expand_option_name[3] = p[-1];\n\t}\n\telse\n\t{\n\t    // Allow * wildcard\n\t    while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n\t\tp++;\n\t    if (*p == NUL)\n\t\treturn;\n\t    nextchar = *p;\n\t    *p = NUL;\n\t    opt_idx = findoption(arg);\n\t    *p = nextchar;\n\t    if (opt_idx == -1 || options[opt_idx].var == NULL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t    flags = options[opt_idx].flags;\n\t    if (flags & P_BOOL)\n\t    {\n\t\txp->xp_context = EXPAND_NOTHING;\n\t\treturn;\n\t    }\n\t}\n    }\n    // handle \"-=\" and \"+=\"\n    if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=')\n    {\n\t++p;\n\tnextchar = '=';\n    }\n    if ((nextchar != '=' && nextchar != ':')\n\t\t\t\t    || xp->xp_context == EXPAND_BOOL_SETTINGS)\n    {\n\txp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn;\n    }\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)\n    {\n\txp->xp_context = EXPAND_OLD_SETTING;\n\tif (is_term_option)\n\t    expand_option_idx = -1;\n\telse\n\t    expand_option_idx = opt_idx;\n\txp->xp_pattern = p + 1;\n\treturn;\n    }\n    xp->xp_context = EXPAND_NOTHING;\n    if (is_term_option || (flags & P_NUM))\n\treturn;\n\n    xp->xp_pattern = p + 1;\n\n    if (flags & P_EXPAND)\n    {\n\tp = options[opt_idx].var;\n\tif (p == (char_u *)&p_bdir\n\t\t|| p == (char_u *)&p_dir\n\t\t|| p == (char_u *)&p_path\n\t\t|| p == (char_u *)&p_pp\n\t\t|| p == (char_u *)&p_rtp\n#ifdef FEAT_SEARCHPATH\n\t\t|| p == (char_u *)&p_cdpath\n#endif\n#ifdef FEAT_SESSION\n\t\t|| p == (char_u *)&p_vdir\n#endif\n\t\t)\n\t{\n\t    xp->xp_context = EXPAND_DIRECTORIES;\n\t    if (p == (char_u *)&p_path\n#ifdef FEAT_SEARCHPATH\n\t\t    || p == (char_u *)&p_cdpath\n#endif\n\t\t   )\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n\telse if (p == (char_u *)&p_ft)\n\t{\n\t    xp->xp_context = EXPAND_FILETYPE;\n\t}\n\telse\n\t{\n\t    xp->xp_context = EXPAND_FILES;\n\t    // for 'tags' need three backslashes for a space\n\t    if (p == (char_u *)&p_tags)\n\t\txp->xp_backslash = XP_BS_THREE;\n\t    else\n\t\txp->xp_backslash = XP_BS_ONE;\n\t}\n    }\n\n    // For an option that is a list of file names, find the start of the\n    // last file name.\n    for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p)\n    {\n\t// count number of backslashes before ' ' or ','\n\tif (*p == ' ' || *p == ',')\n\t{\n\t    s = p;\n\t    while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n\t\t--s;\n\t    if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n\t\t    || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0))\n\t    {\n\t\txp->xp_pattern = p + 1;\n\t\tbreak;\n\t    }\n\t}\n\n#ifdef FEAT_SPELL\n\t// for 'spellsuggest' start at \"file:\"\n\tif (options[opt_idx].var == (char_u *)&p_sps\n\t\t\t\t\t       && STRNCMP(p, \"file:\", 5) == 0)\n\t{\n\t    xp->xp_pattern = p + 5;\n\t    break;\n\t}\n#endif\n    }\n\n    return;\n}\n\n    int\nExpandSettings(\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\tnum_normal = 0;\t    // Nr of matching non-term-code settings\n    int\t\tnum_term = 0;\t    // Nr of matching terminal code settings\n    int\t\topt_idx;\n    int\t\tmatch;\n    int\t\tcount = 0;\n    char_u\t*str;\n    int\t\tloop;\n    int\t\tis_term_opt;\n    char_u\tname_buf[MAX_KEY_NAME_LEN];\n    static char *(names[]) = {\"all\", \"termcap\"};\n    int\t\tic = regmatch->rm_ic;\t// remember the ignore-case flag\n\n    // do this loop twice:\n    // loop == 0: count the number of matching options\n    // loop == 1: copy the matching options into allocated memory\n    for (loop = 0; loop <= 1; ++loop)\n    {\n\tregmatch->rm_ic = ic;\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS)\n\t{\n\t    for (match = 0; match < (int)ARRAY_LENGTH(names); ++match)\n\t\tif (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_normal++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave((char_u *)names[match]);\n\t\t}\n\t}\n\tfor (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n\t\t\t\t\t\t\t\t    opt_idx++)\n\t{\n\t    if (options[opt_idx].var == NULL)\n\t\tcontinue;\n\t    if (xp->xp_context == EXPAND_BOOL_SETTINGS\n\t      && !(options[opt_idx].flags & P_BOOL))\n\t\tcontinue;\n\t    is_term_opt = istermoption_idx(opt_idx);\n\t    if (is_term_opt && num_normal > 0)\n\t\tcontinue;\n\t    match = FALSE;\n\t    if (vim_regexec(regmatch, str, (colnr_T)0)\n\t\t    || (options[opt_idx].shortname != NULL\n\t\t\t&& vim_regexec(regmatch,\n\t\t\t   (char_u *)options[opt_idx].shortname, (colnr_T)0)))\n\t\tmatch = TRUE;\n\t    else if (is_term_opt)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tname_buf[1] = 't';\n\t\tname_buf[2] = '_';\n\t\tname_buf[3] = str[2];\n\t\tname_buf[4] = str[3];\n\t\tname_buf[5] = '>';\n\t\tname_buf[6] = NUL;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    match = TRUE;\n\t\t    str = name_buf;\n\t\t}\n\t    }\n\t    if (match)\n\t    {\n\t\tif (loop == 0)\n\t\t{\n\t\t    if (is_term_opt)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\tnum_normal++;\n\t\t}\n\t\telse\n\t\t    (*file)[count++] = vim_strsave(str);\n\t    }\n\t}\n\t/*\n\t * Check terminal key codes, these are not in the option table\n\t */\n\tif (xp->xp_context != EXPAND_BOOL_SETTINGS  && num_normal == 0)\n\t{\n\t    for (opt_idx = 0; (str = get_termcode(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tif (!isprint(str[0]) || !isprint(str[1]))\n\t\t    continue;\n\n\t\tname_buf[0] = 't';\n\t\tname_buf[1] = '_';\n\t\tname_buf[2] = str[0];\n\t\tname_buf[3] = str[1];\n\t\tname_buf[4] = NUL;\n\n\t\tmatch = FALSE;\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t    match = TRUE;\n\t\telse\n\t\t{\n\t\t    name_buf[0] = '<';\n\t\t    name_buf[1] = 't';\n\t\t    name_buf[2] = '_';\n\t\t    name_buf[3] = str[0];\n\t\t    name_buf[4] = str[1];\n\t\t    name_buf[5] = '>';\n\t\t    name_buf[6] = NUL;\n\n\t\t    if (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t\tmatch = TRUE;\n\t\t}\n\t\tif (match)\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check special key names.\n\t     */\n\t    regmatch->rm_ic = TRUE;\t\t// ignore case here\n\t    for (opt_idx = 0; (str = get_key_name(opt_idx)) != NULL; opt_idx++)\n\t    {\n\t\tname_buf[0] = '<';\n\t\tSTRCPY(name_buf + 1, str);\n\t\tSTRCAT(name_buf, \">\");\n\n\t\tif (vim_regexec(regmatch, name_buf, (colnr_T)0))\n\t\t{\n\t\t    if (loop == 0)\n\t\t\tnum_term++;\n\t\t    else\n\t\t\t(*file)[count++] = vim_strsave(name_buf);\n\t\t}\n\t    }\n\t}\n\tif (loop == 0)\n\t{\n\t    if (num_normal > 0)\n\t\t*num_file = num_normal;\n\t    else if (num_term > 0)\n\t\t*num_file = num_term;\n\t    else\n\t\treturn OK;\n\t    *file = ALLOC_MULT(char_u *, *num_file);\n\t    if (*file == NULL)\n\t    {\n\t\t*file = (char_u **)\"\";\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n    return OK;\n}\n\n    int\nExpandOldSetting(int *num_file, char_u ***file)\n{\n    char_u  *var = NULL;\t// init for GCC\n    char_u  *buf;\n\n    *num_file = 0;\n    *file = ALLOC_ONE(char_u *);\n    if (*file == NULL)\n\treturn FAIL;\n\n    /*\n     * For a terminal key code expand_option_idx is < 0.\n     */\n    if (expand_option_idx < 0)\n    {\n\tvar = find_termcode(expand_option_name + 2);\n\tif (var == NULL)\n\t    expand_option_idx = findoption(expand_option_name);\n    }\n\n    if (expand_option_idx >= 0)\n    {\n\t// put string of option value in NameBuff\n\toption_value2string(&options[expand_option_idx], expand_option_flags);\n\tvar = NameBuff;\n    }\n    else if (var == NULL)\n\tvar = (char_u *)\"\";\n\n    // A backslash is required before some characters.  This is the reverse of\n    // what happens in do_set().\n    buf = vim_strsave_escaped(var, escape_chars);\n\n    if (buf == NULL)\n    {\n\tVIM_CLEAR(*file);\n\treturn FAIL;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // For MS-Windows et al. we don't double backslashes at the start and\n    // before a file name character.\n    for (var = buf; *var != NUL; MB_PTR_ADV(var))\n\tif (var[0] == '\\\\' && var[1] == '\\\\'\n\t\t&& expand_option_idx >= 0\n\t\t&& (options[expand_option_idx].flags & P_EXPAND)\n\t\t&& vim_isfilec(var[2])\n\t\t&& (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n\t    STRMOVE(var, var + 1);\n#endif\n\n    *file[0] = buf;\n    *num_file = 1;\n    return OK;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\n    static void\noption_value2string(\n    struct vimoption\t*opp,\n    int\t\t\topt_flags)\t// OPT_GLOBAL and/or OPT_LOCAL\n{\n    char_u\t*varp;\n\n    varp = get_varp_scope(opp, opt_flags);\n\n    if (opp->flags & P_NUM)\n    {\n\tlong wc = 0;\n\n\tif (wc_use_keyname(varp, &wc))\n\t    STRCPY(NameBuff, get_special_key_name((int)wc, 0));\n\telse if (wc != 0)\n\t    STRCPY(NameBuff, transchar((int)wc));\n\telse\n\t    sprintf((char *)NameBuff, \"%ld\", *(long *)varp);\n    }\n    else    // P_STRING\n    {\n\tvarp = *(char_u **)(varp);\n\tif (varp == NULL)\t\t    // just in case\n\t    NameBuff[0] = NUL;\n#ifdef FEAT_CRYPT\n\t// don't show the actual value of 'key', only that it's set\n\telse if (opp->var == (char_u *)&p_key && *varp)\n\t    STRCPY(NameBuff, \"*****\");\n#endif\n\telse if (opp->flags & P_EXPAND)\n\t    home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n\t// Translate 'pastetoggle' into special key names\n\telse if ((char_u **)opp->var == &p_pt)\n\t    str2specialbuf(p_pt, NameBuff, MAXPATHL);\n\telse\n\t    vim_strncpy(NameBuff, varp, MAXPATHL - 1);\n    }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\n    static int\nwc_use_keyname(char_u *varp, long *wcp)\n{\n    if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))\n    {\n\t*wcp = *(long *)varp;\n\tif (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"x\" is present in 'shortmess' option, or\n * 'shortmess' contains 'a' and \"x\" is present in SHM_A.\n */\n    int\nshortmess(int x)\n{\n    return p_shm != NULL &&\n\t    (   vim_strchr(p_shm, x) != NULL\n\t    || (vim_strchr(p_shm, 'a') != NULL\n\t\t&& vim_strchr((char_u *)SHM_A, x) != NULL));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\n    static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}\n\n/*\n * vimrc_found() - Called when a \".vimrc\" or \"VIMINIT\" has been found.\n *\n * Reset 'compatible' and set the values for options that didn't get set yet\n * to the Vim defaults.\n * Don't do this if the 'compatible' option has been set or reset before.\n * When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\n */\n    void\nvimrc_found(char_u *fname, char_u *envname)\n{\n    int\t\topt_idx;\n    int\t\tdofree = FALSE;\n    char_u\t*p;\n\n    if (!option_was_set((char_u *)\"cp\"))\n    {\n\tp_cp = FALSE;\n\tfor (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\t    if (!(options[opt_idx].flags & (P_WAS_SET|P_VI_DEF)))\n\t\tset_option_default(opt_idx, OPT_FREE, FALSE);\n\tdidset_options();\n\tdidset_options2();\n    }\n\n    if (fname != NULL)\n    {\n\tp = vim_getenv(envname, &dofree);\n\tif (p == NULL)\n\t{\n\t    // Set $MYVIMRC to the first vimrc file found.\n\t    p = FullName_save(fname, FALSE);\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv(envname, p);\n\t\tvim_free(p);\n\t    }\n\t}\n\telse if (dofree)\n\t    vim_free(p);\n    }\n}\n\n/*\n * Set 'compatible' on or off.  Called for \"-C\" and \"-N\" command line arg.\n */\n    void\nchange_compatible(int on)\n{\n    int\t    opt_idx;\n\n    if (p_cp != on)\n    {\n\tp_cp = on;\n\tcompatible_set();\n    }\n    opt_idx = findoption((char_u *)\"cp\");\n    if (opt_idx >= 0)\n\toptions[opt_idx].flags |= P_WAS_SET;\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\n    int\noption_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t// unknown option\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Reset the flag indicating option \"name\" was set.\n */\n    int\nreset_option_was_set(char_u *name)\n{\n    int idx = findoption(name);\n\n    if (idx >= 0)\n    {\n\toptions[idx].flags &= ~P_WAS_SET;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * compatible_set() - Called when 'compatible' has been set or unset.\n *\n * When 'compatible' set: Set all relevant options (those that have the P_VIM)\n * flag) to a Vi compatible value.\n * When 'compatible' is unset: Set all options that have a different default\n * for Vim (without the P_VI_DEF flag) to that default.\n */\n    static void\ncompatible_set(void)\n{\n    int\t    opt_idx;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n\tif (\t   ((options[opt_idx].flags & P_VIM) && p_cp)\n\t\t|| (!(options[opt_idx].flags & P_VI_DEF) && !p_cp))\n\t    set_option_default(opt_idx, OPT_FREE, p_cp);\n    didset_options();\n    didset_options2();\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\n    void\nfill_breakat_flags(void)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    for (i = 0; i < 256; i++)\n\tbreakat_flags[i] = FALSE;\n\n    if (p_breakat != NULL)\n\tfor (p = p_breakat; *p; p++)\n\t    breakat_flags[*p] = TRUE;\n}\n#endif\n\n/*\n * Check if backspacing over something is allowed.\n */\n    int\ncan_bs(\n    int\t\twhat)\t    // BS_INDENT, BS_EOL, BS_START or BS_NOSTOP\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (what == BS_START && bt_prompt(curbuf))\n\treturn FALSE;\n#endif\n    switch (*p_bs)\n    {\n\tcase '3':       return TRUE;\n\tcase '2':\treturn (what != BS_NOSTOP);\n\tcase '1':\treturn (what != BS_START);\n\tcase '0':\treturn FALSE;\n    }\n    return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Return the effective 'scrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_scrolloff_value(void)\n{\n    return curwin->w_p_so < 0 ? p_so : curwin->w_p_so;\n}\n\n/*\n * Return the effective 'sidescrolloff' value for the current window, using the\n * global value when appropriate.\n */\n    long\nget_sidescrolloff_value(void)\n{\n    return curwin->w_p_siso < 0 ? p_siso : curwin->w_p_siso;\n}\n\n/*\n * Get the local or global value of 'backupcopy'.\n */\n    unsigned int\nget_bkc_value(buf_T *buf)\n{\n    return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/*\n * Get the local or global value of the 'virtualedit' flags.\n */\n    unsigned int\nget_ve_flags(void)\n{\n    return (curwin->w_ve_flags ? curwin->w_ve_flags : ve_flags)\n\t    & ~(VE_NONE | VE_NONEU);\n}\n\n#if defined(FEAT_LINEBREAK) || defined(PROTO)\n/*\n * Get the local or global value of 'showbreak'.\n */\n    char_u *\nget_showbreak_value(win_T *win)\n{\n    if (win->w_p_sbr == NULL || *win->w_p_sbr == NUL)\n\treturn p_sbr;\n    if (STRCMP(win->w_p_sbr, \"NONE\") == 0)\n\treturn empty_option;\n    return win->w_p_sbr;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get window or buffer local options.\n */\n    dict_T *\nget_winbuf_options(int bufopt)\n{\n    dict_T\t*d;\n    int\t\topt_idx;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn NULL;\n\n    for (opt_idx = 0; !istermoption_idx(opt_idx); opt_idx++)\n    {\n\tstruct vimoption *opt = &options[opt_idx];\n\n\tif ((bufopt && (opt->indir & PV_BUF))\n\t\t\t\t\t || (!bufopt && (opt->indir & PV_WIN)))\n\t{\n\t    char_u *varp = get_varp(opt);\n\n\t    if (varp != NULL)\n\t    {\n\t\tif (opt->flags & P_STRING)\n\t\t    dict_add_string(d, opt->fullname, *(char_u **)varp);\n\t\telse if (opt->flags & P_NUM)\n\t\t    dict_add_number(d, opt->fullname, *(long *)varp);\n\t\telse\n\t\t    dict_add_number(d, opt->fullname, *(int *)varp);\n\t    }\n\t}\n    }\n\n    return d;\n}\n#endif\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * This is called when 'culopt' is changed\n */\n    int\nfill_culopt_flags(char_u *val, win_T *wp)\n{\n    char_u\t*p;\n    char_u\tculopt_flags_new = 0;\n\n    if (val == NULL)\n\tp = wp->w_p_culopt;\n    else\n\tp = val;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"line\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE;\n\t}\n\telse if (STRNCMP(p, \"both\", 4) == 0)\n\t{\n\t    p += 4;\n\t    culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"number\", 6) == 0)\n\t{\n\t    p += 6;\n\t    culopt_flags_new |= CULOPT_NBR;\n\t}\n\telse if (STRNCMP(p, \"screenline\", 10) == 0)\n\t{\n\t    p += 10;\n\t    culopt_flags_new |= CULOPT_SCRLINE;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    // Can't have both \"line\" and \"screenline\".\n    if ((culopt_flags_new & CULOPT_LINE) && (culopt_flags_new & CULOPT_SCRLINE))\n\treturn FAIL;\n    wp->w_p_culopt_flags = culopt_flags_new;\n\n    return OK;\n}\n#endif\n\n/*\n * Get the value of 'magic' adjusted for Vim9 script.\n */\n    int\nmagic_isset(void)\n{\n    switch (magic_overruled)\n    {\n\tcase OPTION_MAGIC_ON:      return TRUE;\n\tcase OPTION_MAGIC_OFF:     return FALSE;\n\tcase OPTION_MAGIC_NOT_SET: break;\n    }\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn TRUE;\n#endif\n    return p_magic;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * optionstr.c: Functions related to string options\n */\n\n#include \"vim.h\"\n\nstatic char *(p_ambw_values[]) = {\"single\", \"double\", NULL};\nstatic char *(p_bg_values[]) = {\"light\", \"dark\", NULL};\nstatic char *(p_bkc_values[]) = {\"yes\", \"auto\", \"no\", \"breaksymlink\", \"breakhardlink\", NULL};\nstatic char *(p_bo_values[]) = {\"all\", \"backspace\", \"cursor\", \"complete\",\n\t\t\t\t \"copy\", \"ctrlg\", \"error\", \"esc\", \"ex\",\n\t\t\t\t \"hangul\", \"insertmode\", \"lang\", \"mess\",\n\t\t\t\t \"showmatch\", \"operator\", \"register\", \"shell\",\n\t\t\t\t \"spell\", \"wildmode\", NULL};\nstatic char *(p_nf_values[]) = {\"bin\", \"octal\", \"hex\", \"alpha\", \"unsigned\", NULL};\nstatic char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};\n#ifdef FEAT_CRYPT\nstatic char *(p_cm_values[]) = {\"zip\", \"blowfish\", \"blowfish2\",\n # ifdef FEAT_SODIUM\n    \"xchacha20\",\n # endif\n    NULL};\n#endif\nstatic char *(p_cmp_values[]) = {\"internal\", \"keepascii\", NULL};\nstatic char *(p_dy_values[]) = {\"lastline\", \"truncate\", \"uhex\", NULL};\n#ifdef FEAT_FOLDING\nstatic char *(p_fdo_values[]) = {\"all\", \"block\", \"hor\", \"mark\", \"percent\",\n\t\t\t\t \"quickfix\", \"search\", \"tag\", \"insert\",\n\t\t\t\t \"undo\", \"jump\", NULL};\n#endif\n#ifdef FEAT_SESSION\n// Also used for 'viewoptions'!  Keep in sync with SSOP_ flags.\nstatic char *(p_ssop_values[]) = {\"buffers\", \"winpos\", \"resize\", \"winsize\",\n    \"localoptions\", \"options\", \"help\", \"blank\", \"globals\", \"slash\", \"unix\",\n    \"sesdir\", \"curdir\", \"folds\", \"cursor\", \"tabpages\", \"terminal\", \"skiprtp\",\n    NULL};\n#endif\n// Keep in sync with SWB_ flags in option.h\nstatic char *(p_swb_values[]) = {\"useopen\", \"usetab\", \"split\", \"newtab\", \"vsplit\", \"uselast\", NULL};\nstatic char *(p_tc_values[]) = {\"followic\", \"ignore\", \"match\", \"followscs\", \"smart\", NULL};\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\nstatic char *(p_toolbar_values[]) = {\"text\", \"icons\", \"tooltips\", \"horiz\", NULL};\n#endif\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\nstatic char *(p_tbis_values[]) = {\"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"giant\", NULL};\n#endif\n#if defined(UNIX) || defined(VMS)\nstatic char *(p_ttym_values[]) = {\"xterm\", \"xterm2\", \"dec\", \"netterm\", \"jsbterm\", \"pterm\", \"urxvt\", \"sgr\", NULL};\n#endif\nstatic char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", \"none\", \"NONE\", NULL};\nstatic char *(p_wop_values[]) = {\"tagfile\", NULL};\n#ifdef FEAT_WAK\nstatic char *(p_wak_values[]) = {\"yes\", \"menu\", \"no\", NULL};\n#endif\nstatic char *(p_mousem_values[]) = {\"extend\", \"popup\", \"popup_setpos\", \"mac\", NULL};\nstatic char *(p_sel_values[]) = {\"inclusive\", \"exclusive\", \"old\", NULL};\nstatic char *(p_slm_values[]) = {\"mouse\", \"key\", \"cmd\", NULL};\nstatic char *(p_km_values[]) = {\"startsel\", \"stopsel\", NULL};\n#ifdef FEAT_BROWSE\nstatic char *(p_bsdir_values[]) = {\"current\", \"last\", \"buffer\", NULL};\n#endif\nstatic char *(p_scbopt_values[]) = {\"ver\", \"hor\", \"jump\", NULL};\nstatic char *(p_debug_values[]) = {\"msg\", \"throw\", \"beep\", NULL};\nstatic char *(p_ead_values[]) = {\"both\", \"ver\", \"hor\", NULL};\nstatic char *(p_buftype_values[]) = {\"nofile\", \"nowrite\", \"quickfix\", \"help\", \"terminal\", \"acwrite\", \"prompt\", \"popup\", NULL};\nstatic char *(p_bufhidden_values[]) = {\"hide\", \"unload\", \"delete\", \"wipe\", NULL};\nstatic char *(p_bs_values[]) = {\"indent\", \"eol\", \"start\", \"nostop\", NULL};\n#ifdef FEAT_FOLDING\nstatic char *(p_fdm_values[]) = {\"manual\", \"expr\", \"marker\", \"indent\", \"syntax\",\n# ifdef FEAT_DIFF\n\t\t\t\t\"diff\",\n# endif\n\t\t\t\tNULL};\nstatic char *(p_fcl_values[]) = {\"all\", NULL};\n#endif\nstatic char *(p_cot_values[]) = {\"menu\", \"menuone\", \"longest\", \"preview\", \"popup\", \"popuphidden\", \"noinsert\", \"noselect\", NULL};\n#ifdef BACKSLASH_IN_FILENAME\nstatic char *(p_csl_values[]) = {\"slash\", \"backslash\", NULL};\n#endif\n#ifdef FEAT_SIGNS\nstatic char *(p_scl_values[]) = {\"yes\", \"no\", \"auto\", \"number\", NULL};\n#endif\n#if defined(MSWIN) && defined(FEAT_TERMINAL)\nstatic char *(p_twt_values[]) = {\"winpty\", \"conpty\", \"\", NULL};\n#endif\n\nstatic int check_opt_strings(char_u *val, char **values, int list);\nstatic int opt_strings_flags(char_u *val, char **values, unsigned *flagp, int list);\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\n    void\ndidset_string_options(void)\n{\n    (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE);\n    (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE);\n    (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE);\n#ifdef FEAT_SESSION\n    (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE);\n    (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE);\n#endif\n#ifdef FEAT_FOLDING\n    (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE);\n#endif\n    (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE);\n    (void)opt_strings_flags(p_tc, p_tc_values, &tc_flags, FALSE);\n    (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, TRUE);\n#if defined(UNIX) || defined(VMS)\n    (void)opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE);\n#endif\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\n    (void)opt_strings_flags(p_toolbar, p_toolbar_values, &toolbar_flags, TRUE);\n#endif\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    (void)opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE);\n#endif\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Trigger the OptionSet autocommand.\n * \"opt_idx\"\tis the index of the option being set.\n * \"opt_flags\"\tcan be OPT_LOCAL etc.\n * \"oldval\"\tthe old value\n *  \"oldval_l\"  the old local value (only non-NULL if global and local value\n *\t\tare set)\n * \"oldval_g\"   the old global value (only non-NULL if global and local value\n *\t\tare set)\n * \"newval\"\tthe new value\n */\n    void\ntrigger_optionsset_string(\n\tint\topt_idx,\n\tint\topt_flags,\n\tchar_u  *oldval,\n\tchar_u  *oldval_l,\n\tchar_u  *oldval_g,\n\tchar_u  *newval)\n{\n    // Don't do this recursively.\n    if (oldval != NULL && newval != NULL\n\t\t\t\t    && *get_vim_var_str(VV_OPTION_TYPE) == NUL)\n    {\n\tchar_u buf_type[7];\n\n\tsprintf((char *)buf_type, \"%s\",\n\t    (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n\tset_vim_var_string(VV_OPTION_OLD, oldval, -1);\n\tset_vim_var_string(VV_OPTION_NEW, newval, -1);\n\tset_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);\n\t}\n\tif (opt_flags & OPT_GLOBAL)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval, -1);\n\t}\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval_l, -1);\n\t    set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval_g, -1);\n\t}\n\tif (opt_flags & OPT_MODELINE)\n\t{\n\t    set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);\n\t    set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);\n\t}\n\tapply_autocmds(EVENT_OPTIONSET,\n\t\t       (char_u *)get_option_fullname(opt_idx), NULL, FALSE,\n\t\t       NULL);\n\treset_v_option_vars();\n    }\n}\n#endif\n\n    static char *\nillegal_char(char *errbuf, int c)\n{\n    if (errbuf == NULL)\n\treturn \"\";\n    sprintf((char *)errbuf, _(\"E539: Illegal character <%s>\"),\n\t\t\t\t\t\t\t(char *)transchar(c));\n    return errbuf;\n}\n\n/*\n * Check string options in a buffer for NULL value.\n */\n    void\ncheck_buf_options(buf_T *buf)\n{\n    check_string_option(&buf->b_p_bh);\n    check_string_option(&buf->b_p_bt);\n    check_string_option(&buf->b_p_fenc);\n    check_string_option(&buf->b_p_ff);\n#ifdef FEAT_FIND_ID\n    check_string_option(&buf->b_p_def);\n    check_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    check_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_inde);\n    check_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    check_string_option(&buf->b_p_cm);\n#endif\n    check_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    check_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n    check_string_option(&buf->b_p_key);\n#endif\n    check_string_option(&buf->b_p_kp);\n    check_string_option(&buf->b_p_mps);\n    check_string_option(&buf->b_p_fo);\n    check_string_option(&buf->b_p_flp);\n    check_string_option(&buf->b_p_isk);\n    check_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    check_string_option(&buf->b_p_cms);\n#endif\n    check_string_option(&buf->b_p_nf);\n#ifdef FEAT_TEXTOBJ\n    check_string_option(&buf->b_p_qe);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&buf->b_p_syn);\n    check_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    check_string_option(&buf->b_s.b_p_spc);\n    check_string_option(&buf->b_s.b_p_spf);\n    check_string_option(&buf->b_s.b_p_spl);\n    check_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    check_string_option(&buf->b_p_sua);\n#endif\n#ifdef FEAT_CINDENT\n    check_string_option(&buf->b_p_cink);\n    check_string_option(&buf->b_p_cino);\n    parse_cino(buf);\n#endif\n    check_string_option(&buf->b_p_ft);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n    check_string_option(&buf->b_p_cinw);\n#endif\n    check_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    check_string_option(&buf->b_p_cfu);\n    check_string_option(&buf->b_p_ofu);\n#endif\n#ifdef FEAT_EVAL\n    check_string_option(&buf->b_p_tfu);\n#endif\n#ifdef FEAT_KEYMAP\n    check_string_option(&buf->b_p_keymap);\n#endif\n#ifdef FEAT_QUICKFIX\n    check_string_option(&buf->b_p_gp);\n    check_string_option(&buf->b_p_mp);\n    check_string_option(&buf->b_p_efm);\n#endif\n    check_string_option(&buf->b_p_ep);\n    check_string_option(&buf->b_p_path);\n    check_string_option(&buf->b_p_tags);\n    check_string_option(&buf->b_p_tc);\n    check_string_option(&buf->b_p_dict);\n    check_string_option(&buf->b_p_tsr);\n#ifdef FEAT_LISP\n    check_string_option(&buf->b_p_lw);\n#endif\n    check_string_option(&buf->b_p_bkc);\n    check_string_option(&buf->b_p_menc);\n#ifdef FEAT_VARTABS\n    check_string_option(&buf->b_p_vsts);\n    check_string_option(&buf->b_p_vts);\n#endif\n}\n\n/*\n * Free the string allocated for an option.\n * Checks for the string being empty_option. This may happen if we're out of\n * memory, vim_strsave() returned NULL, which was replaced by empty_option by\n * check_options().\n * Does NOT check for P_ALLOCED flag!\n */\n    void\nfree_string_option(char_u *p)\n{\n    if (p != empty_option)\n\tvim_free(p);\n}\n\n    void\nclear_string_option(char_u **pp)\n{\n    if (*pp != empty_option)\n\tvim_free(*pp);\n    *pp = empty_option;\n}\n\n    void\ncheck_string_option(char_u **pp)\n{\n    if (*pp == NULL)\n\t*pp = empty_option;\n}\n\n/*\n * Set global value for string option when it's a local option.\n */\n    static void\nset_string_option_global(\n    int\t\topt_idx,\t// option index\n    char_u\t**varp)\t\t// pointer to option variable\n{\n    char_u\t**p, *s;\n\n    // the global value is always allocated\n    if (is_window_local_option(opt_idx))\n\tp = (char_u **)GLOBAL_WO(varp);\n    else\n\tp = (char_u **)get_option_var(opt_idx);\n    if (!is_global_option(opt_idx)\n\t    && p != varp\n\t    && (s = vim_strsave(*varp)) != NULL)\n    {\n\tfree_string_option(*p);\n\t*p = s;\n    }\n}\n\n/*\n * Set a string option to a new value (without checking the effect).\n * The string is copied into allocated memory.\n * if (\"opt_idx\" == -1) \"name\" is used, otherwise \"opt_idx\" is used.\n * When \"set_sid\" is zero set the scriptID to current_sctx.sc_sid.  When\n * \"set_sid\" is SID_NONE don't set the scriptID.  Otherwise set the scriptID to\n * \"set_sid\".\n */\n    void\nset_string_option_direct(\n    char_u\t*name,\n    int\t\topt_idx,\n    char_u\t*val,\n    int\t\topt_flags,\t// OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int\t\tset_sid UNUSED)\n{\n    char_u\t*s;\n    char_u\t**varp;\n    int\t\tboth = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n    int\t\tidx = opt_idx;\n\n    if (idx == -1)\t\t// use name\n    {\n\tidx = findoption(name);\n\tif (idx < 0)\t// not found (should not happen)\n\t{\n\t    semsg(_(e_intern2), \"set_string_option_direct()\");\n\t    siemsg(_(\"For option %s\"), name);\n\t    return;\n\t}\n    }\n\n    if (is_hidden_option(idx))\t\t// can't set hidden option\n\treturn;\n\n    s = vim_strsave(val);\n    if (s != NULL)\n    {\n\tvarp = (char_u **)get_option_varp_scope(idx,\n\t\t\t\t\t       both ? OPT_LOCAL : opt_flags);\n\tif ((opt_flags & OPT_FREE) && (get_option_flags(idx) & P_ALLOCED))\n\t    free_string_option(*varp);\n\t*varp = s;\n\n\t// For buffer/window local option may also set the global value.\n\tif (both)\n\t    set_string_option_global(idx, varp);\n\n\tset_option_flag(idx, P_ALLOCED);\n\n\t// When setting both values of a global option with a local value,\n\t// make the local value empty, so that the global value is used.\n\tif (is_global_local_option(idx) && both)\n\t{\n\t    free_string_option(*varp);\n\t    *varp = empty_option;\n\t}\n# ifdef FEAT_EVAL\n\tif (set_sid != SID_NONE)\n\t{\n\t    sctx_T script_ctx;\n\n\t    if (set_sid == 0)\n\t\tscript_ctx = current_sctx;\n\t    else\n\t    {\n\t\tscript_ctx.sc_sid = set_sid;\n\t\tscript_ctx.sc_seq = 0;\n\t\tscript_ctx.sc_lnum = 0;\n\t\tscript_ctx.sc_version = 1;\n\t    }\n\t    set_option_sctx_idx(idx, opt_flags, script_ctx);\n\t}\n# endif\n    }\n}\n\n/*\n * Like set_string_option_direct(), but for a window-local option in \"wp\".\n * Blocks autocommands to avoid the old curwin becoming invalid.\n */\n    void\nset_string_option_direct_in_win(\n\twin_T\t\t*wp,\n\tchar_u\t\t*name,\n\tint\t\topt_idx,\n\tchar_u\t\t*val,\n\tint\t\topt_flags,\n\tint\t\tset_sid)\n{\n    win_T\t*save_curwin = curwin;\n\n    block_autocmds();\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    set_string_option_direct(name, opt_idx, val, opt_flags, set_sid);\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n    unblock_autocmds();\n}\n\n/*\n * Like set_string_option_direct(), but for a buffer-local option in \"buf\".\n * Blocks autocommands to avoid the old curbuf becoming invalid.\n */\n    void\nset_string_option_direct_in_buf(\n\tbuf_T\t\t*buf,\n\tchar_u\t\t*name,\n\tint\t\topt_idx,\n\tchar_u\t\t*val,\n\tint\t\topt_flags,\n\tint\t\tset_sid)\n{\n    buf_T\t*save_curbuf = curbuf;\n\n    block_autocmds();\n    curbuf = buf;\n    curwin->w_buffer = curbuf;\n    set_string_option_direct(name, opt_idx, val, opt_flags, set_sid);\n    curbuf = save_curbuf;\n    curwin->w_buffer = curbuf;\n    unblock_autocmds();\n}\n\n/*\n * Set a string option to a new value, and handle the effects.\n *\n * Returns NULL on success or error message on error.\n */\n    char *\nset_string_option(\n    int\t\topt_idx,\n    char_u\t*value,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    char_u\t*s;\n    char_u\t**varp;\n    char_u\t*oldval;\n#if defined(FEAT_EVAL)\n    char_u\t*oldval_l = NULL;\n    char_u\t*oldval_g = NULL;\n    char_u\t*saved_oldval = NULL;\n    char_u\t*saved_oldval_l = NULL;\n    char_u\t*saved_oldval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n    char\t*r = NULL;\n    int\t\tvalue_checked = FALSE;\n\n    if (is_hidden_option(opt_idx))\t// don't set hidden option\n\treturn NULL;\n\n    s = vim_strsave(value == NULL ? (char_u *)\"\" : value);\n    if (s != NULL)\n    {\n\tvarp = (char_u **)get_option_varp_scope(opt_idx,\n\t\t(opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t    ? (is_global_local_option(opt_idx)\n\t\t\t? OPT_GLOBAL : OPT_LOCAL)\n\t\t    : opt_flags);\n\toldval = *varp;\n#if defined(FEAT_EVAL)\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t{\n\t    oldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);\n\t    oldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n\t}\n#endif\n\t*varp = s;\n\n#if defined(FEAT_EVAL)\n\tif (!starting\n# ifdef FEAT_CRYPT\n\t\t&& !is_crypt_key_option(opt_idx)\n# endif\n\t\t)\n\t{\n\t    if (oldval_l != NULL)\n\t\tsaved_oldval_l = vim_strsave(oldval_l);\n\t    if (oldval_g != NULL)\n\t\tsaved_oldval_g = vim_strsave(oldval_g);\n\t    saved_oldval = vim_strsave(oldval);\n\t    saved_newval = vim_strsave(s);\n\t}\n#endif\n\tif ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,\n\t\t\t\t\t   opt_flags, &value_checked)) == NULL)\n\t    did_set_option(opt_idx, opt_flags, TRUE, value_checked);\n\n#if defined(FEAT_EVAL)\n\t// call autocommand after handling side effects\n\tif (r == NULL)\n\t    trigger_optionsset_string(opt_idx, opt_flags,\n\t\t\t\t   saved_oldval, saved_oldval_l,\n\t\t\t\t   saved_oldval_g, saved_newval);\n\tvim_free(saved_oldval);\n\tvim_free(saved_oldval_l);\n\tvim_free(saved_oldval_g);\n\tvim_free(saved_newval);\n#endif\n    }\n    return r;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'filetype' name.\n * Also used for 'syntax' and 'keymap'.\n */\n    static int\nvalid_filetype(char_u *val)\n{\n    return valid_name(val, \".-_\");\n}\n\n#ifdef FEAT_STL_OPT\n/*\n * Check validity of options with the 'statusline' format.\n * Return error message or NULL.\n */\n    static char *\ncheck_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[80];\n\n    while (*s)\n    {\n\t// Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    s++;\n\tif (!*s)\n\t    break;\n\ts++;\n\tif (*s == '%' || *s == STL_TRUNCMARK || *s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (--groupdepth < 0)\n\t\tbreak;\n\t    continue;\n\t}\n\tif (*s == '-')\n\t    s++;\n\twhile (VIM_ISDIGIT(*s))\n\t    s++;\n\tif (*s == STL_USER_HL)\n\t    continue;\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    while (*s && VIM_ISDIGIT(*s))\n\t\ts++;\n\t}\n\tif (*s == '(')\n\t{\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*s == '%');\n\n\t    s++;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn N_(\"E540: Unclosed expression sequence\");\n\t}\n    }\n    if (groupdepth != 0)\n\treturn N_(\"E542: unbalanced groups\");\n    return NULL;\n}\n#endif\n\n/*\n * Handle string options that need some action to perform when changed.\n * Returns NULL for success, or an error message for an error.\n */\n    char *\ndid_set_string_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t**varp,\t\t\t// pointer to the option variable\n    int\t\tnew_value_alloced,\t// new value was allocated\n    char_u\t*oldval,\t\t// previous value of the option\n    char\t*errbuf,\t\t// buffer for errors, or NULL\n    int\t\topt_flags,\t\t// OPT_LOCAL and/or OPT_GLOBAL\n    int\t\t*value_checked)\t\t// value was checked to be save, no\n\t\t\t\t\t// need to set P_INSECURE\n{\n    char\t*errmsg = NULL;\n    char_u\t*s, *p;\n    int\t\tdid_chartab = FALSE;\n    char_u\t**gvarp;\n    long_u\tfree_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n#ifdef FEAT_GUI\n    // set when changing an option that only requires a redraw in the GUI\n    int\t\tredraw_gui_only = FALSE;\n#endif\n    int\t\tvalue_changed = FALSE;\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n    int\t\tdid_swaptcap = FALSE;\n#endif\n\n    // Get the global option to compare with, otherwise we would have to check\n    // two values for all local options.\n    gvarp = (char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (get_option_flags(opt_idx) & P_SECURE))\n\terrmsg = e_secure;\n\n    // Check for a \"normal\" directory or file name in some options.  Disallow a\n    // path separator (slash and/or backslash), wildcards and characters that\n    // are often illegal in a file name. Be more permissive if \"secure\" is off.\n    else if (((get_option_flags(opt_idx) & P_NFNAME)\n\t\t    && vim_strpbrk(*varp, (char_u *)(secure\n\t\t\t    ? \"/\\\\*?[|;&<>\\r\\n\" : \"/\\\\*?[<>\\r\\n\")) != NULL)\n\t  || ((get_option_flags(opt_idx) & P_NDNAME)\n\t\t    && vim_strpbrk(*varp, (char_u *)\"*?[|;&<>\\r\\n\") != NULL))\n\terrmsg = e_invarg;\n\n    // 'term'\n    else if (varp == &T_NAME)\n    {\n\tif (T_NAME[0] == NUL)\n\t    errmsg = N_(\"E529: Cannot set 'term' to empty string\");\n#ifdef FEAT_GUI\n\telse if (gui.in_use)\n\t    errmsg = N_(\"E530: Cannot change term in GUI\");\n\telse if (term_is_gui(T_NAME))\n\t    errmsg = N_(\"E531: Use \\\":gui\\\" to start the GUI\");\n#endif\n\telse if (set_termname(T_NAME) == FAIL)\n\t    errmsg = N_(\"E522: Not found in termcap\");\n\telse\n\t{\n\t    // Screen colors may have changed.\n\t    redraw_later_clear();\n\n\t    // Both 'term' and 'ttytype' point to T_NAME, only set the\n\t    // P_ALLOCED flag on 'term'.\n\t    opt_idx = findoption((char_u *)\"term\");\n\t    free_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n\t}\n    }\n\n    // 'backupcopy'\n    else if (gvarp == &p_bkc)\n    {\n\tchar_u\t\t*bkc = p_bkc;\n\tunsigned int\t*flags = &bkc_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    bkc = curbuf->b_p_bkc;\n\t    flags = &curbuf->b_bkc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *bkc == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(bkc, p_bkc_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    if ((((int)*flags & BKC_AUTO) != 0)\n\t\t    + (((int)*flags & BKC_YES) != 0)\n\t\t    + (((int)*flags & BKC_NO) != 0) != 1)\n\t    {\n\t\t// Must have exactly one of \"auto\", \"yes\"  and \"no\".\n\t\t(void)opt_strings_flags(oldval, p_bkc_values, flags, TRUE);\n\t\terrmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    // 'backupext' and 'patchmode'\n    else if (varp == &p_bex || varp == &p_pm)\n    {\n\tif (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n\t\t     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n\t    errmsg = N_(\"E589: 'backupext' and 'patchmode' are equal\");\n    }\n#ifdef FEAT_LINEBREAK\n    // 'breakindentopt'\n    else if (varp == &curwin->w_p_briopt)\n    {\n\tif (briopt_check(curwin) == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    else if (  varp == &p_isi\n\t    || varp == &(curbuf->b_p_isk)\n\t    || varp == &p_isp\n\t    || varp == &p_isf)\n    {\n\tif (init_chartab() == FAIL)\n\t{\n\t    did_chartab = TRUE;\t    // need to restore it below\n\t    errmsg = e_invarg;\t    // error in value\n\t}\n    }\n\n    // 'helpfile'\n    else if (varp == &p_hf)\n    {\n\t// May compute new values for $VIM and $VIMRUNTIME\n\tif (didset_vim)\n\t{\n\t    vim_setenv((char_u *)\"VIM\", (char_u *)\"\");\n\t    didset_vim = FALSE;\n\t}\n\tif (didset_vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", (char_u *)\"\");\n\t    didset_vimruntime = FALSE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    // 'cursorlineopt'\n    else if (varp == &curwin->w_p_culopt\n\t\t\t\t  || gvarp == &curwin->w_allbuf_opt.wo_culopt)\n    {\n\tif (**varp == NUL || fill_culopt_flags(*varp, curwin) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'colorcolumn'\n    else if (varp == &curwin->w_p_cc)\n\terrmsg = check_colorcolumn(curwin);\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // 'helplang'\n    else if (varp == &p_hlg)\n    {\n\t// Check for \"\", \"ab\", \"ab,cd\", etc.\n\tfor (s = p_hlg; *s != NUL; s += 3)\n\t{\n\t    if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL))\n\t    {\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (s[2] == NUL)\n\t\tbreak;\n\t}\n    }\n#endif\n\n    // 'highlight'\n    else if (varp == &p_hl)\n    {\n\tif (highlight_changed() == FAIL)\n\t    errmsg = e_invarg;\t// invalid flags\n    }\n\n    // 'nrformats'\n    else if (gvarp == &p_nf)\n    {\n\tif (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_SESSION\n    // 'sessionoptions'\n    else if (varp == &p_ssop)\n    {\n\tif (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\tif ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR))\n\t{\n\t    // Don't allow both \"sesdir\" and \"curdir\".\n\t    (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, TRUE);\n\t    errmsg = e_invarg;\n\t}\n    }\n    // 'viewoptions'\n    else if (varp == &p_vop)\n    {\n\tif (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'scrollopt'\n    else if (varp == &p_sbo)\n    {\n\tif (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'ambiwidth'\n    else if (varp == &p_ambw || varp == &p_emoji)\n    {\n\tif (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse if (set_chars_option(curwin, &p_fcs) != NULL)\n\t    errmsg = _(\"E835: Conflicts with value of 'fillchars'\");\n\telse\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (set_chars_option(wp, &wp->w_p_lcs) != NULL)\n\t\t{\n\t\t    errmsg = _(\"E834: Conflicts with value of 'listchars'\");\n\t\t    goto ambw_end;\n\t\t}\n\t    }\n\t}\nambw_end:\n\t{}\n    }\n\n    // 'background'\n    else if (varp == &p_bg)\n    {\n\tif (check_opt_strings(p_bg, p_bg_values, FALSE) == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    int dark = (*p_bg == 'd');\n#endif\n\n\t    init_highlight(FALSE, FALSE);\n\n#ifdef FEAT_EVAL\n\t    if (dark != (*p_bg == 'd')\n\t\t\t  && get_var_value((char_u *)\"g:colors_name\") != NULL)\n\t    {\n\t\t// The color scheme must have set 'background' back to another\n\t\t// value, that's not what we want here.  Disable the color\n\t\t// scheme and set the colors again.\n\t\tdo_unlet((char_u *)\"g:colors_name\", TRUE);\n\t\tfree_string_option(p_bg);\n\t\tp_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n\t\tcheck_string_option(&p_bg);\n\t\tinit_highlight(FALSE, FALSE);\n\t    }\n#endif\n#ifdef FEAT_TERMINAL\n\t    term_update_colors_all();\n#endif\n\t}\n\telse\n\t    errmsg = e_invarg;\n    }\n\n    // 'wildmode'\n    else if (varp == &p_wim)\n    {\n\tif (check_opt_wim() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n    // 'wildoptions'\n    else if (varp == &p_wop)\n    {\n\tif (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_WAK\n    // 'winaltkeys'\n    else if (varp == &p_wak)\n    {\n\tif (*p_wak == NUL\n\t\t|| check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n# ifdef FEAT_MENU\n#  ifdef FEAT_GUI_MOTIF\n\telse if (gui.in_use)\n\t    gui_motif_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#  else\n#   ifdef FEAT_GUI_GTK\n\telse if (gui.in_use)\n\t    gui_gtk_set_mnemonics(p_wak[0] == 'y' || p_wak[0] == 'm');\n#   endif\n#  endif\n# endif\n    }\n#endif\n\n    // 'eventignore'\n    else if (varp == &p_ei)\n    {\n\tif (check_ei() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n    // 'encoding', 'fileencoding', 'termencoding' and 'makeencoding'\n    else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc\n\t\t\t\t\t\t\t   || gvarp == &p_menc)\n    {\n\tif (gvarp == &p_fenc)\n\t{\n\t    if (!curbuf->b_p_ma && opt_flags != OPT_GLOBAL)\n\t\terrmsg = e_cannot_make_changes_modifiable_is_off;\n\t    else if (vim_strchr(*varp, ',') != NULL)\n\t\t// No comma allowed in 'fileencoding'; catches confusing it\n\t\t// with 'fileencodings'.\n\t\terrmsg = e_invarg;\n\t    else\n\t    {\n#ifdef FEAT_TITLE\n\t\t// May show a \"+\" in the title now.\n\t\tredraw_titles();\n#endif\n\t\t// Add 'fileencoding' to the swap file.\n\t\tml_setflags(curbuf);\n\t    }\n\t}\n\tif (errmsg == NULL)\n\t{\n\t    // canonize the value, so that STRCMP() can be used on it\n\t    p = enc_canonize(*varp);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(*varp);\n\t\t*varp = p;\n\t    }\n\t    if (varp == &p_enc)\n\t    {\n\t\terrmsg = mb_init();\n#ifdef FEAT_TITLE\n\t\tredraw_titles();\n#endif\n\t    }\n\t}\n\n#if defined(FEAT_GUI_GTK)\n\tif (errmsg == NULL && varp == &p_tenc && gui.in_use)\n\t{\n\t    // GTK+ 2 uses only a single encoding, and that is UTF-8.\n\t    if (STRCMP(p_tenc, \"utf-8\") != 0)\n\t\terrmsg = N_(\"E617: Cannot be changed in the GTK+ 2 GUI\");\n\t}\n#endif\n\n\tif (errmsg == NULL)\n\t{\n#ifdef FEAT_KEYMAP\n\t    // When 'keymap' is used and 'encoding' changes, reload the keymap\n\t    // (with another encoding).\n\t    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)\n\t\t(void)keymap_init();\n#endif\n\n\t    // When 'termencoding' is not empty and 'encoding' changes or when\n\t    // 'termencoding' changes, need to setup for keyboard input and\n\t    // display output conversion.\n\t    if (((varp == &p_enc && *p_tenc != NUL) || varp == &p_tenc))\n\t    {\n\t\tif (convert_setup(&input_conv, p_tenc, p_enc) == FAIL\n\t\t\t|| convert_setup(&output_conv, p_enc, p_tenc) == FAIL)\n\t\t{\n\t\t    semsg(_(\"E950: Cannot convert between %s and %s\"),\n\t\t\t    p_tenc, p_enc);\n\t\t    errmsg = e_invarg;\n\t\t}\n\t    }\n\n#if defined(MSWIN)\n\t    // $HOME may have characters in active code page.\n\t    if (varp == &p_enc)\n\t\tinit_homedir();\n#endif\n\t}\n    }\n\n#if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_penc)\n    {\n\t// Canonize printencoding if VIM standard one\n\tp = enc_canonize(p_penc);\n\tif (p != NULL)\n\t{\n\t    vim_free(p_penc);\n\t    p_penc = p;\n\t}\n\telse\n\t{\n\t    // Ensure lower case and '-' for '_'\n\t    for (s = p_penc; *s != NUL; s++)\n\t    {\n\t\tif (*s == '_')\n\t\t    *s = '-';\n\t\telse\n\t\t    *s = TOLOWER_ASC(*s);\n\t    }\n\t}\n    }\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    else if (varp == &p_imak)\n    {\n\tif (!im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    int\t    secure_save = secure;\n\n\t    // Reset the secure flag, since the value of 'keymap' has\n\t    // been checked to be safe.\n\t    secure = 0;\n\n\t    // load or unload key mapping tables\n\t    errmsg = keymap_init();\n\n\t    secure = secure_save;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t// Installed a new keymap, switch on using it.\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n\t    else\n\t    {\n\t\t// Cleared the keymap, may reset 'iminsert' and 'imsearch'.\n\t\tif (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t\tif (curbuf->b_p_imsearch == B_IMODE_LMAP)\n\t\t    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n\t    }\n\t    if ((opt_flags & OPT_LOCAL) == 0)\n\t    {\n\t\tset_iminsert_global();\n\t\tset_imsearch_global();\n\t    }\n\t    status_redraw_curbuf();\n\t}\n    }\n#endif\n\n    // 'fileformat'\n    else if (gvarp == &p_ff)\n    {\n\tif (!curbuf->b_p_ma && !(opt_flags & OPT_GLOBAL))\n\t    errmsg = e_cannot_make_changes_modifiable_is_off;\n\telse if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // may also change 'textmode'\n\t    if (get_fileformat(curbuf) == EOL_DOS)\n\t\tcurbuf->b_p_tx = TRUE;\n\t    else\n\t\tcurbuf->b_p_tx = FALSE;\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t    // update flag in swap file\n\t    ml_setflags(curbuf);\n\t    // Redraw needed when switching to/from \"mac\": a CR in the text\n\t    // will be displayed differently.\n\t    if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n\t\tredraw_curbuf_later(NOT_VALID);\n\t}\n    }\n\n    // 'fileformats'\n    else if (varp == &p_ffs)\n    {\n\tif (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // also change 'textauto'\n\t    if (*p_ffs == NUL)\n\t\tp_ta = FALSE;\n\t    else\n\t\tp_ta = TRUE;\n\t}\n    }\n\n#if defined(FEAT_CRYPT)\n    // 'cryptkey'\n    else if (gvarp == &p_key)\n    {\n\t// Make sure the \":set\" command doesn't show the new value in the\n\t// history.\n\tremove_key_from_history();\n\n\tif (STRCMP(curbuf->b_p_key, oldval) != 0)\n\t    // Need to update the swapfile.\n\t{\n\t    ml_set_crypt_key(curbuf, oldval,\n\t\t\t      *curbuf->b_p_cm == NUL ? p_cm : curbuf->b_p_cm);\n\t    changed_internal();\n\t}\n    }\n\n    else if (gvarp == &p_cm)\n    {\n\tif (opt_flags & OPT_LOCAL)\n\t    p = curbuf->b_p_cm;\n\telse\n\t    p = p_cm;\n\tif (check_opt_strings(p, p_cm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse if (crypt_self_test() == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    // When setting the global value to empty, make it \"zip\".\n\t    if (*p_cm == NUL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_cm);\n\t\tp_cm = vim_strsave((char_u *)\"zip\");\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t    // When using \":set cm=name\" the local value is going to be empty.\n\t    // Do that here, otherwise the crypt functions will still use the\n\t    // local value.\n\t    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t    {\n\t\tfree_string_option(curbuf->b_p_cm);\n\t\tcurbuf->b_p_cm = empty_option;\n\t    }\n\n\t    // Need to update the swapfile when the effective method changed.\n\t    // Set \"s\" to the effective old value, \"p\" to the effective new\n\t    // method and compare.\n\t    if ((opt_flags & OPT_LOCAL) && *oldval == NUL)\n\t\ts = p_cm;  // was previously using the global value\n\t    else\n\t\ts = oldval;\n\t    if (*curbuf->b_p_cm == NUL)\n\t\tp = p_cm;  // is now using the global value\n\t    else\n\t\tp = curbuf->b_p_cm;\n\t    if (STRCMP(s, p) != 0)\n\t\tml_set_crypt_key(curbuf, curbuf->b_p_key, s);\n\n\t    // If the global value changes need to update the swapfile for all\n\t    // buffers using that value.\n\t    if ((opt_flags & OPT_GLOBAL) && STRCMP(p_cm, oldval) != 0)\n\t    {\n\t\tbuf_T\t*buf;\n\n\t\tFOR_ALL_BUFFERS(buf)\n\t\t    if (buf != curbuf && *buf->b_p_cm == NUL)\n\t\t\tml_set_crypt_key(buf, buf->b_p_key, oldval);\n\t    }\n\t}\n    }\n#endif\n\n    // 'matchpairs'\n    else if (gvarp == &p_mps)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (p = *varp; *p != NUL; ++p)\n\t    {\n\t\tint x2 = -1;\n\t\tint x3 = -1;\n\n\t\tif (*p != NUL)\n\t\t    p += mb_ptr2len(p);\n\t\tif (*p != NUL)\n\t\t    x2 = *p++;\n\t\tif (*p != NUL)\n\t\t{\n\t\t    x3 = mb_ptr2char(p);\n\t\t    p += mb_ptr2len(p);\n\t\t}\n\t\tif (x2 != ':' || x3 == -1 || (*p != NUL && *p != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (*p == NUL)\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    // Check for \"x:y,x:y\"\n\t    for (p = *varp; *p != NUL; p += 4)\n\t    {\n\t\tif (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\tif (p[3] == NUL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    // 'comments'\n    else if (gvarp == &p_com)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    while (*s && *s != ':')\n\t    {\n\t\tif (vim_strchr((char_u *)COM_ALL, *s) == NULL\n\t\t\t\t\t     && !VIM_ISDIGIT(*s) && *s != '-')\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    }\n\t    if (*s++ == NUL)\n\t\terrmsg = N_(\"E524: Missing colon\");\n\t    else if (*s == ',' || *s == NUL)\n\t\terrmsg = N_(\"E525: Zero length string\");\n\t    if (errmsg != NULL)\n\t\tbreak;\n\t    while (*s && *s != ',')\n\t    {\n\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t    ++s;\n\t\t++s;\n\t    }\n\t    s = skip_to_option_part(s);\n\t}\n    }\n\n    // global 'listchars'\n    else if (varp == &p_lcs)\n    {\n\terrmsg = set_chars_option(curwin, varp);\n\tif (errmsg == NULL)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t\t*wp;\n\n\t    // The current window is set to use the global 'listchars' value.\n\t    // So clear the window-local value.\n\t    if (!(opt_flags & OPT_GLOBAL))\n\t\tclear_string_option(&curwin->w_p_lcs);\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\terrmsg = set_chars_option(wp, &wp->w_p_lcs);\n\t\tif (errmsg)\n\t\t    break;\n\t    }\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n\n    // local 'listchars'\n    else if (varp == &curwin->w_p_lcs)\n\terrmsg = set_chars_option(curwin, varp);\n\n    // 'fillchars'\n    else if (varp == &p_fcs)\n    {\n\terrmsg = set_chars_option(curwin, varp);\n    }\n\n#ifdef FEAT_CMDWIN\n    // 'cedit'\n    else if (varp == &p_cedit)\n    {\n\terrmsg = check_cedit();\n    }\n#endif\n\n    // 'verbosefile'\n    else if (varp == &p_vfile)\n    {\n\tverbose_stop();\n\tif (*p_vfile != NUL && verbose_open() == FAIL)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_VIMINFO\n    // 'viminfo'\n    else if (varp == &p_viminfo)\n    {\n\tfor (s = p_viminfo; *s;)\n\t{\n\t    // Check it's a valid character\n\t    if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*s == 'n')\t// name is always last one\n\t\tbreak;\n\t    else if (*s == 'r') // skip until next ','\n\t    {\n\t\twhile (*++s && *s != ',')\n\t\t    ;\n\t    }\n\t    else if (*s == '%')\n\t    {\n\t\t// optional number\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\t    }\n\t    else if (*s == '!' || *s == 'h' || *s == 'c')\n\t\t++s;\t\t// no extra chars\n\t    else\t\t// must have a number\n\t    {\n\t\twhile (vim_isdigit(*++s))\n\t\t    ;\n\n\t\tif (!VIM_ISDIGIT(*(s - 1)))\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf(errbuf, _(\"E526: Missing number after <%s>\"),\n\t\t\t\t\t\t    transchar_byte(*(s - 1)));\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = \"\";\n\t\t    break;\n\t\t}\n\t    }\n\t    if (*s == ',')\n\t\t++s;\n\t    else if (*s)\n\t    {\n\t\tif (errbuf != NULL)\n\t\t    errmsg = N_(\"E527: Missing comma\");\n\t\telse\n\t\t    errmsg = \"\";\n\t\tbreak;\n\t    }\n\t}\n\tif (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\\'') < 0)\n\t    errmsg = N_(\"E528: Must specify a ' value\");\n    }\n#endif // FEAT_VIMINFO\n\n    // terminal options\n    else if (istermoption_idx(opt_idx) && full_screen)\n    {\n\t// \":set t_Co=0\" and \":set t_Co=1\" do \":set t_Co=\"\n\tif (varp == &T_CCO)\n\t{\n\t    int colors = atoi((char *)T_CCO);\n\n\t    // Only reinitialize colors if t_Co value has really changed to\n\t    // avoid expensive reload of colorscheme if t_Co is set to the\n\t    // same value multiple times.\n\t    if (colors != t_colors)\n\t    {\n\t\tt_colors = colors;\n\t\tif (t_colors <= 1)\n\t\t{\n\t\t    if (new_value_alloced)\n\t\t\tvim_free(T_CCO);\n\t\t    T_CCO = empty_option;\n\t\t}\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n\t\tif (is_term_win32())\n\t\t{\n\t\t    swap_tcap();\n\t\t    did_swaptcap = TRUE;\n\t\t}\n#endif\n\t\t// We now have a different color setup, initialize it again.\n\t\tinit_highlight(TRUE, FALSE);\n\t    }\n\t}\n\tttest(FALSE);\n\tif (varp == &T_ME)\n\t{\n\t    out_str(T_ME);\n\t    redraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n\t    // Since t_me has been set, this probably means that the user\n\t    // wants to use this as default colors.  Need to reset default\n\t    // background/foreground colors.\n# ifdef VIMDLL\n\t    if (!gui.in_use && !gui.starting)\n# endif\n\t\tmch_set_normal_colors();\n#endif\n\t}\n\tif (varp == &T_BE && termcap_active)\n\t{\n#ifdef FEAT_JOB_CHANNEL\n\t    ch_log_output = TRUE;\n#endif\n\t    if (*T_BE == NUL)\n\t\t// When clearing t_BE we assume the user no longer wants\n\t\t// bracketed paste, thus disable it by writing t_BD.\n\t\tout_str(T_BD);\n\t    else\n\t\tout_str(T_BE);\n\t}\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'showbreak'\n    else if (gvarp == &p_sbr)\n    {\n\tfor (s = *varp; *s; )\n\t{\n\t    if (ptr2cells(s) != 1)\n\t\terrmsg = N_(\"E595: 'showbreak' contains unprintable or wide character\");\n\t    MB_PTR_ADV(s);\n\t}\n    }\n#endif\n\n#ifdef FEAT_GUI\n    // 'guifont'\n    else if (varp == &p_guifont)\n    {\n\tif (gui.in_use)\n\t{\n\t    p = p_guifont;\n# if defined(FEAT_GUI_GTK)\n\t    // Put up a font dialog and let the user select a new value.\n\t    // If this is cancelled go back to the old value but don't\n\t    // give an error message.\n\t    if (STRCMP(p, \"*\") == 0)\n\t    {\n\t\tp = gui_mch_font_dialog(oldval);\n\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_guifont);\n\n\t\tp_guifont = (p != NULL) ? p : vim_strsave(oldval);\n\t\tnew_value_alloced = TRUE;\n\t    }\n# endif\n\t    if (p != NULL && gui_init_font(p_guifont, FALSE) != OK)\n\t    {\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_PHOTON)\n\t\tif (STRCMP(p_guifont, \"*\") == 0)\n\t\t{\n\t\t    // Dialog was cancelled: Keep the old value without giving\n\t\t    // an error message.\n\t\t    if (new_value_alloced)\n\t\t\tfree_string_option(p_guifont);\n\t\t    p_guifont = vim_strsave(oldval);\n\t\t    new_value_alloced = TRUE;\n\t\t}\n\t\telse\n# endif\n\t\t    errmsg = N_(\"E596: Invalid font(s)\");\n\t    }\n\t}\n\tredraw_gui_only = TRUE;\n    }\n# ifdef FEAT_XFONTSET\n    else if (varp == &p_guifontset)\n    {\n\tif (STRCMP(p_guifontset, \"*\") == 0)\n\t    errmsg = N_(\"E597: can't select fontset\");\n\telse if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)\n\t    errmsg = N_(\"E598: Invalid fontset\");\n\tredraw_gui_only = TRUE;\n    }\n# endif\n    else if (varp == &p_guifontwide)\n    {\n\tif (STRCMP(p_guifontwide, \"*\") == 0)\n\t    errmsg = N_(\"E533: can't select wide font\");\n\telse if (gui_get_wide_font() == FAIL)\n\t    errmsg = N_(\"E534: Invalid wide font\");\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#ifdef CURSOR_SHAPE\n    // 'guicursor'\n    else if (varp == &p_guicursor)\n\terrmsg = parse_shape_opt(SHAPE_CURSOR);\n#endif\n\n#ifdef FEAT_MOUSESHAPE\n    // 'mouseshape'\n    else if (varp == &p_mouseshape)\n    {\n\terrmsg = parse_shape_opt(SHAPE_MOUSE);\n\tupdate_mouseshape(-1);\n    }\n#endif\n\n#ifdef FEAT_PRINTER\n    else if (varp == &p_popt)\n\terrmsg = parse_printoptions();\n# if defined(FEAT_POSTSCRIPT)\n    else if (varp == &p_pmfn)\n\terrmsg = parse_printmbfont();\n# endif\n#endif\n\n#ifdef FEAT_LANGMAP\n    // 'langmap'\n    else if (varp == &p_langmap)\n\tlangmap_set();\n#endif\n\n#ifdef FEAT_LINEBREAK\n    // 'breakat'\n    else if (varp == &p_breakat)\n\tfill_breakat_flags();\n#endif\n\n#ifdef FEAT_TITLE\n    // 'titlestring' and 'iconstring'\n    else if (varp == &p_titlestring || varp == &p_iconstring)\n    {\n# ifdef FEAT_STL_OPT\n\tint\tflagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n\t// NULL => statusline syntax\n\tif (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n\t    stl_syntax |= flagval;\n\telse\n\t    stl_syntax &= ~flagval;\n# endif\n\tdid_set_title();\n    }\n#endif\n\n#ifdef FEAT_GUI\n    // 'guioptions'\n    else if (varp == &p_go)\n    {\n\tgui_init_which_components(oldval);\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(FEAT_GUI_TABLINE)\n    // 'guitablabel'\n    else if (varp == &p_gtl)\n    {\n\tredraw_tabline = TRUE;\n\tredraw_gui_only = TRUE;\n    }\n    // 'guitabtooltip'\n    else if (varp == &p_gtt)\n    {\n\tredraw_gui_only = TRUE;\n    }\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    // 'ttymouse'\n    else if (varp == &p_ttym)\n    {\n\t// Switch the mouse off before changing the escape sequences used for\n\t// that.\n\tmch_setmouse(FALSE);\n\tif (opt_strings_flags(p_ttym, p_ttym_values, &ttym_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    check_mouse_termcode();\n\tif (termcap_active)\n\t    setmouse();\t\t// may switch it on again\n    }\n#endif\n\n    // 'selection'\n    else if (varp == &p_sel)\n    {\n\tif (*p_sel == NUL\n\t\t|| check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'selectmode'\n    else if (varp == &p_slm)\n    {\n\tif (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_BROWSE\n    // 'browsedir'\n    else if (varp == &p_bsdir)\n    {\n\tif (check_opt_strings(p_bsdir, p_bsdir_values, FALSE) != OK\n\t\t&& !mch_isdir(p_bsdir))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // 'keymodel'\n    else if (varp == &p_km)\n    {\n\tif (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n\t    km_startsel = (vim_strchr(p_km, 'a') != NULL);\n\t}\n    }\n\n    // 'mousemodel'\n    else if (varp == &p_mousem)\n    {\n\tif (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU) && (XmVersion <= 1002)\n\telse if (*p_mousem != *oldval)\n\t    // Changed from \"extend\" to \"popup\" or \"popup_setpos\" or vv: need\n\t    // to create or delete the popup menus.\n\t    gui_motif_update_mousemodel(root_menu);\n#endif\n    }\n\n    // 'switchbuf'\n    else if (varp == &p_swb)\n    {\n\tif (opt_strings_flags(p_swb, p_swb_values, &swb_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'debug'\n    else if (varp == &p_debug)\n    {\n\tif (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'display'\n    else if (varp == &p_dy)\n    {\n\tif (opt_strings_flags(p_dy, p_dy_values, &dy_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    (void)init_chartab();\n\n    }\n\n    // 'eadirection'\n    else if (varp == &p_ead)\n    {\n\tif (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // 'clipboard'\n    else if (varp == &p_cb)\n\terrmsg = check_clipboard_option();\n#endif\n\n#ifdef FEAT_SPELL\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    else if (varp == &(curwin->w_s->b_p_spl)\n\t    || varp == &(curwin->w_s->b_p_spf))\n    {\n\tint\tis_spellfile = varp == &(curwin->w_s->b_p_spf);\n\n\tif ((is_spellfile && !valid_spellfile(*varp))\n\t    || (!is_spellfile && !valid_spelllang(*varp)))\n\t    errmsg = e_invarg;\n\telse\n\t    errmsg = did_set_spell_option(is_spellfile);\n    }\n    // When 'spellcapcheck' is set compile the regexp program.\n    else if (varp == &(curwin->w_s->b_p_spc))\n    {\n\terrmsg = compile_cap_prog(curwin->w_s);\n    }\n    // 'spelloptions'\n    else if (varp == &(curwin->w_s->b_p_spo))\n    {\n\tif (**varp != NUL && STRCMP(\"camel\", *varp) != 0)\n\t    errmsg = e_invarg;\n    }\n    // 'spellsuggest'\n    else if (varp == &p_sps)\n    {\n\tif (spell_check_sps() != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'mkspellmem'\n    else if (varp == &p_msm)\n    {\n\tif (spell_check_msm() != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // When 'bufhidden' is set, check for valid value.\n    else if (gvarp == &p_bh)\n    {\n\tif (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // When 'buftype' is set, check for valid value.\n    else if (gvarp == &p_bt)\n    {\n\tif (check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    if (curwin->w_status_height)\n\t    {\n\t\tcurwin->w_redr_status = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n#ifdef FEAT_TITLE\n\t    redraw_titles();\n#endif\n\t}\n    }\n\n#ifdef FEAT_STL_OPT\n    // 'statusline' or 'rulerformat'\n    else if (gvarp == &p_stl || varp == &p_ruf)\n    {\n\tint wid;\n\n\tif (varp == &p_ruf)\t// reset ru_wid first\n\t    ru_wid = 0;\n\ts = *varp;\n\tif (varp == &p_ruf && *s == '%')\n\t{\n\t    // set ru_wid if 'ruf' starts with \"%99(\"\n\t    if (*++s == '-')\t// ignore a '-'\n\t\ts++;\n\t    wid = getdigits(&s);\n\t    if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n\t\tru_wid = wid;\n\t    else\n\t\terrmsg = check_stl_option(p_ruf);\n\t}\n\t// check 'statusline' only if it doesn't start with \"%!\"\n\telse if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n\t    errmsg = check_stl_option(s);\n\tif (varp == &p_ruf && errmsg == NULL)\n\t    comp_col();\n    }\n#endif\n\n    // check if it is a valid value for 'complete' -- Acevedo\n    else if (gvarp == &p_cpt)\n    {\n\tfor (s = *varp; *s;)\n\t{\n\t    while (*s == ',' || *s == ' ')\n\t\ts++;\n\t    if (!*s)\n\t\tbreak;\n\t    if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    {\n\t\terrmsg = illegal_char(errbuf, *s);\n\t\tbreak;\n\t    }\n\t    if (*++s != NUL && *s != ',' && *s != ' ')\n\t    {\n\t\tif (s[-1] == 'k' || s[-1] == 's')\n\t\t{\n\t\t    // skip optional filename after 'k' and 's'\n\t\t    while (*s && *s != ',' && *s != ' ')\n\t\t    {\n\t\t\tif (*s == '\\\\' && s[1] != NUL)\n\t\t\t    ++s;\n\t\t\t++s;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (errbuf != NULL)\n\t\t    {\n\t\t\tsprintf((char *)errbuf,\n\t\t\t\t     _(\"E535: Illegal character after <%c>\"),\n\t\t\t\t     *--s);\n\t\t\terrmsg = errbuf;\n\t\t    }\n\t\t    else\n\t\t\terrmsg = \"\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    // 'completeopt'\n    else if (varp == &p_cot)\n    {\n\tif (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t    completeopt_was_set();\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    // 'completeslash'\n    else if (gvarp == &p_csl)\n    {\n\tif (check_opt_strings(p_csl, p_csl_values, FALSE) != OK\n\t\t|| check_opt_strings(curbuf->b_p_csl, p_csl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SIGNS\n    // 'signcolumn'\n    else if (varp == &curwin->w_p_scl)\n    {\n\tif (check_opt_strings(*varp, p_scl_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n\t// When changing the 'signcolumn' to or from 'number', recompute the\n\t// width of the number column if 'number' or 'relativenumber' is set.\n\tif (((*oldval == 'n' && *(oldval + 1) == 'u')\n\t\t|| (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) =='u'))\n\t\t&& (curwin->w_p_nu || curwin->w_p_rnu))\n\t    curwin->w_nrwidth_line_count = 0;\n    }\n#endif\n\n\n#if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_MSWIN)\n    // 'toolbar'\n    else if (varp == &p_toolbar)\n    {\n\tif (opt_strings_flags(p_toolbar, p_toolbar_values,\n\t\t\t      &toolbar_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n#if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)\n    // 'toolbariconsize': GTK+ 2 only\n    else if (varp == &p_tbis)\n    {\n\tif (opt_strings_flags(p_tbis, p_tbis_values, &tbis_flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    out_flush();\n\t    gui_mch_show_toolbar((toolbar_flags &\n\t\t\t\t  (TOOLBAR_TEXT | TOOLBAR_ICONS)) != 0);\n\t}\n    }\n#endif\n\n    // 'pastetoggle': translate key codes like in a mapping\n    else if (varp == &p_pt)\n    {\n\tif (*p_pt)\n\t{\n\t    (void)replace_termcodes(p_pt, &p,\n\t\t\t\t      REPTERM_FROM_PART | REPTERM_DO_LT, NULL);\n\t    if (p != NULL)\n\t    {\n\t\tif (new_value_alloced)\n\t\t    free_string_option(p_pt);\n\t\tp_pt = p;\n\t\tnew_value_alloced = TRUE;\n\t    }\n\t}\n    }\n\n    // 'backspace'\n    else if (varp == &p_bs)\n    {\n\tif (VIM_ISDIGIT(*p_bs))\n\t{\n\t    if (*p_bs > '3' || p_bs[1] != NUL)\n\t\terrmsg = e_invarg;\n\t}\n\telse if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    else if (varp == &p_bo)\n    {\n\tif (opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'tagcase'\n    else if (gvarp == &p_tc)\n    {\n\tunsigned int\t*flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    p = curbuf->b_p_tc;\n\t    flags = &curbuf->b_tc_flags;\n\t}\n\telse\n\t{\n\t    p = p_tc;\n\t    flags = &tc_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *p == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse if (*p == NUL\n\t\t|| opt_strings_flags(p, p_tc_values, flags, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n    // 'casemap'\n    else if (varp == &p_cmp)\n    {\n\tif (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n\n#ifdef FEAT_DIFF\n    // 'diffopt'\n    else if (varp == &p_dip)\n    {\n\tif (diffopt_changed() == FAIL)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldmethod'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdm)\n    {\n\tif (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n\t\t|| *curwin->w_p_fdm == NUL)\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    foldUpdateAll(curwin);\n\t    if (foldmethodIsDiff(curwin))\n\t\tnewFoldLevel();\n\t}\n    }\n# ifdef FEAT_EVAL\n    // 'foldexpr'\n    else if (varp == &curwin->w_p_fde)\n    {\n\tif (foldmethodIsExpr(curwin))\n\t    foldUpdateAll(curwin);\n    }\n# endif\n    // 'foldmarker'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fmr)\n    {\n\tp = vim_strchr(*varp, ',');\n\tif (p == NULL)\n\t    errmsg = N_(\"E536: comma required\");\n\telse if (p == *varp || p[1] == NUL)\n\t    errmsg = e_invarg;\n\telse if (foldmethodIsMarker(curwin))\n\t    foldUpdateAll(curwin);\n    }\n    // 'commentstring'\n    else if (gvarp == &p_cms)\n    {\n\tif (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n\t    errmsg = N_(\"E537: 'commentstring' must be empty or contain %s\");\n    }\n    // 'foldopen'\n    else if (varp == &p_fdo)\n    {\n\tif (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'foldclose'\n    else if (varp == &p_fcl)\n    {\n\tif (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n\t    errmsg = e_invarg;\n    }\n    // 'foldignore'\n    else if (gvarp == &curwin->w_allbuf_opt.wo_fdi)\n    {\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n#endif\n\n    // 'virtualedit'\n    else if (gvarp == &p_ve)\n    {\n\tchar_u\t\t*ve = p_ve;\n\tunsigned int\t*flags = &ve_flags;\n\n\tif (opt_flags & OPT_LOCAL)\n\t{\n\t    ve = curwin->w_p_ve;\n\t    flags = &curwin->w_ve_flags;\n\t}\n\n\tif ((opt_flags & OPT_LOCAL) && *ve == NUL)\n\t    // make the local value empty: use the global value\n\t    *flags = 0;\n\telse\n\t{\n\t    if (opt_strings_flags(ve, p_ve_values, flags, TRUE) != OK)\n\t\terrmsg = e_invarg;\n\t    else if (STRCMP(p_ve, oldval) != 0)\n\t    {\n\t\t// Recompute cursor position in case the new 've' setting\n\t\t// changes something.\n\t\tvalidate_virtcol();\n\t\tcoladvance(curwin->w_virtcol);\n\t    }\n\t}\n    }\n\n#if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)\n    else if (varp == &p_csqf)\n    {\n\tif (p_csqf != NULL)\n\t{\n\t    p = p_csqf;\n\t    while (*p != NUL)\n\t    {\n\t\tif (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n\t\t\t|| p[1] == NUL\n\t\t\t|| vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n\t\t\t|| (p[2] != NUL && p[2] != ','))\n\t\t{\n\t\t    errmsg = e_invarg;\n\t\t    break;\n\t\t}\n\t\telse if (p[2] == NUL)\n\t\t    break;\n\t\telse\n\t\t    p += 3;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_CINDENT\n    // 'cinoptions'\n    else if (gvarp == &p_cino)\n    {\n\t// TODO: recognize errors\n\tparse_cino(curbuf);\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    // 'renderoptions'\n    else if (varp == &p_rop)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    value_changed = STRCMP(oldval, *varp) != 0;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n    }\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t{\n\t    value_changed = STRCMP(oldval, *varp) != 0;\n\n\t    // Since we check the value, there is no need to set P_INSECURE,\n\t    // even when the value comes from a modeline.\n\t    *value_checked = TRUE;\n\t}\n    }\n#endif\n\n#ifdef FEAT_TERMINAL\n    // 'termwinkey'\n    else if (varp == &curwin->w_p_twk)\n    {\n\tif (*curwin->w_p_twk != NUL\n\t\t\t\t  && string_to_key(curwin->w_p_twk, TRUE) == 0)\n\t    errmsg = e_invarg;\n    }\n    // 'termwinsize'\n    else if (varp == &curwin->w_p_tws)\n    {\n\tif (*curwin->w_p_tws != NUL)\n\t{\n\t    p = skipdigits(curwin->w_p_tws);\n\t    if (p == curwin->w_p_tws\n\t\t    || (*p != 'x' && *p != '*')\n\t\t    || *skipdigits(p + 1) != NUL)\n\t\terrmsg = e_invarg;\n\t}\n    }\n    // 'wincolor'\n    else if (varp == &curwin->w_p_wcr)\n    {\n\tif (curwin->w_buffer->b_term != NULL)\n\t    term_update_colors(curwin->w_buffer->b_term);\n    }\n# if defined(MSWIN)\n    // 'termwintype'\n    else if (varp == &p_twt)\n    {\n\tif (check_opt_strings(*varp, p_twt_values, FALSE) != OK)\n\t    errmsg = e_invarg;\n    }\n# endif\n#endif\n\n#ifdef FEAT_VARTABS\n    // 'varsofttabstop'\n    else if (varp == &(curbuf->b_p_vsts))\n    {\n\tchar_u *cp;\n\n\tif (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1]))\n\t{\n\t    if (curbuf->b_p_vsts_array)\n\t    {\n\t\tvim_free(curbuf->b_p_vsts_array);\n\t\tcurbuf->b_p_vsts_array = 0;\n\t    }\n\t}\n\telse\n\t{\n\t    for (cp = *varp; *cp; ++cp)\n\t    {\n\t\tif (vim_isdigit(*cp))\n\t\t    continue;\n\t\tif (*cp == ',' && cp > *varp && *(cp-1) != ',')\n\t\t    continue;\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (errmsg == NULL)\n\t    {\n\t\tint *oldarray = curbuf->b_p_vsts_array;\n\t\tif (tabstop_set(*varp, &(curbuf->b_p_vsts_array)) == OK)\n\t\t{\n\t\t    if (oldarray)\n\t\t\tvim_free(oldarray);\n\t\t}\n\t\telse\n\t\t    errmsg = e_invarg;\n\t    }\n\t}\n    }\n\n    // 'vartabstop'\n    else if (varp == &(curbuf->b_p_vts))\n    {\n\tchar_u *cp;\n\n\tif (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1]))\n\t{\n\t    if (curbuf->b_p_vts_array)\n\t    {\n\t\tvim_free(curbuf->b_p_vts_array);\n\t\tcurbuf->b_p_vts_array = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    for (cp = *varp; *cp; ++cp)\n\t    {\n\t\tif (vim_isdigit(*cp))\n\t\t    continue;\n\t\tif (*cp == ',' && cp > *varp && *(cp-1) != ',')\n\t\t    continue;\n\t\terrmsg = e_invarg;\n\t\tbreak;\n\t    }\n\t    if (errmsg == NULL)\n\t    {\n\t\tint *oldarray = curbuf->b_p_vts_array;\n\n\t\tif (tabstop_set(*varp, &(curbuf->b_p_vts_array)) == OK)\n\t\t{\n\t\t    vim_free(oldarray);\n#ifdef FEAT_FOLDING\n\t\t    if (foldmethodIsIndent(curwin))\n\t\t\tfoldUpdateAll(curwin);\n#endif\n\t\t}\n\t\telse\n\t\t    errmsg = e_invarg;\n\t    }\n\t}\n    }\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // 'previewpopup'\n    else if (varp == &p_pvp)\n    {\n\tif (parse_previewpopup(NULL) == FAIL)\n\t    errmsg = e_invarg;\n    }\n# ifdef FEAT_QUICKFIX\n    // 'completepopup'\n    else if (varp == &p_cpp)\n    {\n\tif (parse_completepopup(NULL) == FAIL)\n\t    errmsg = e_invarg;\n\telse\n\t    popup_close_info();\n    }\n# endif\n#endif\n\n#ifdef FEAT_QUICKFIX\n    else if (varp == &p_qftf)\n    {\n\tif (qf_process_qftf_option() == FALSE)\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    // Options that are a list of flags.\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww) // 'whichwrap'\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm) // 'shortmess'\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo)) // 'cpoptions'\n\t    p = (char_u *)CPO_ALL;\n\telse if (varp == &(curbuf->b_p_fo)) // 'formatoptions'\n\t    p = (char_u *)FO_ALL;\n#ifdef FEAT_CONCEAL\n\telse if (varp == &curwin->w_p_cocu) // 'concealcursor'\n\t    p = (char_u *)COCU_ALL;\n#endif\n\telse if (varp == &p_mouse) // 'mouse'\n\t{\n\t    p = (char_u *)MOUSE_ALL;\n\t}\n#if defined(FEAT_GUI)\n\telse if (varp == &p_go) // 'guioptions'\n\t    p = (char_u *)GO_ALL;\n#endif\n\tif (p != NULL)\n\t{\n\t    for (s = *varp; *s; ++s)\n\t\tif (vim_strchr(p, *s) == NULL)\n\t\t{\n\t\t    errmsg = illegal_char(errbuf, *s);\n\t\t    break;\n\t\t}\n\t}\n    }\n\n    // If error detected, restore the previous value.\n    if (errmsg != NULL)\n    {\n\tif (new_value_alloced)\n\t    free_string_option(*varp);\n\t*varp = oldval;\n\t// When resetting some values, need to act on it.\n\tif (did_chartab)\n\t    (void)init_chartab();\n\tif (varp == &p_hl)\n\t    (void)highlight_changed();\n    }\n    else\n    {\n#ifdef FEAT_EVAL\n\t// Remember where the option was set.\n\tset_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\t// Free string options that are in allocated memory.\n\t// Use \"free_oldval\", because recursiveness may change the flags under\n\t// our fingers (esp. init_highlight()).\n\tif (free_oldval)\n\t    free_string_option(oldval);\n\tif (new_value_alloced)\n\t    set_option_flag(opt_idx, P_ALLOCED);\n\telse\n\t    clear_option_flag(opt_idx, P_ALLOCED);\n\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t&& is_global_local_option(opt_idx))\n\t{\n\t    // global option with local value set to use global value; free\n\t    // the local value and make it empty\n\t    p = get_option_varp_scope(opt_idx, OPT_LOCAL);\n\t    free_string_option(*(char_u **)p);\n\t    *(char_u **)p = empty_option;\n\t}\n\n\t// May set global value for local option.\n\telse if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n\t    set_string_option_global(opt_idx, varp);\n\n\t// Trigger the autocommand only after setting the flags.\n#ifdef FEAT_SYN_HL\n\t// When 'syntax' is set, load the syntax of that name\n\tif (varp == &(curbuf->b_p_syn))\n\t{\n\t    static int syn_recursive = 0;\n\n\t    ++syn_recursive;\n\t    // Only pass TRUE for \"force\" when the value changed or not used\n\t    // recursively, to avoid endless recurrence.\n\t    apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn, curbuf->b_fname,\n\t\t    value_changed || syn_recursive == 1, curbuf);\n\t    curbuf->b_flags |= BF_SYN_SET;\n\t    --syn_recursive;\n\t}\n#endif\n\telse if (varp == &(curbuf->b_p_ft))\n\t{\n\t    // 'filetype' is set, trigger the FileType autocommand.\n\t    // Skip this when called from a modeline and the filetype was\n\t    // already set to this value.\n\t    if (!(opt_flags & OPT_MODELINE) || value_changed)\n\t    {\n\t\tstatic int  ft_recursive = 0;\n\t\tint\t    secure_save = secure;\n\n\t\t// Reset the secure flag, since the value of 'filetype' has\n\t\t// been checked to be safe.\n\t\tsecure = 0;\n\n\t\t++ft_recursive;\n\t\tdid_filetype = TRUE;\n\t\t// Only pass TRUE for \"force\" when the value changed or not\n\t\t// used recursively, to avoid endless recurrence.\n\t\tapply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n\t\t\t\t   value_changed || ft_recursive == 1, curbuf);\n\t\t--ft_recursive;\n\t\t// Just in case the old \"curbuf\" is now invalid.\n\t\tif (varp != &(curbuf->b_p_ft))\n\t\t    varp = NULL;\n\n\t\tsecure = secure_save;\n\t    }\n\t}\n#ifdef FEAT_SPELL\n\tif (varp == &(curwin->w_s->b_p_spl))\n\t{\n\t    char_u\tfname[200];\n\t    char_u\t*q = curwin->w_s->b_p_spl;\n\n\t    // Skip the first name if it is \"cjk\".\n\t    if (STRNCMP(q, \"cjk,\", 4) == 0)\n\t\tq += 4;\n\n\t    // Source the spell/LANG.vim in 'runtimepath'.\n\t    // They could set 'spellcapcheck' depending on the language.\n\t    // Use the first name in 'spelllang' up to '_region' or\n\t    // '.encoding'.\n\t    for (p = q; *p != NUL; ++p)\n\t\tif (!ASCII_ISALNUM(*p) && *p != '-')\n\t\t    break;\n\t    if (p > q)\n\t    {\n\t\tvim_snprintf((char *)fname, 200, \"spell/%.*s.vim\",\n\t\t\t\t\t\t\t      (int)(p - q), q);\n\t\tsource_runtime(fname, DIP_ALL);\n\t    }\n\t}\n#endif\n    }\n\n    if (varp == &p_mouse)\n    {\n\tif (*p_mouse == NUL)\n\t    mch_setmouse(FALSE);    // switch mouse off\n\telse\n\t    setmouse();\t\t    // in case 'mouse' changed\n    }\n\n#if defined(FEAT_LUA) || defined(PROTO)\n    if (varp == &p_rtp)\n\tupdate_package_paths_in_lua();\n#endif\n\n    if (curwin->w_curswant != MAXCOL\n\t\t   && (get_option_flags(opt_idx) & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n    {\n#ifdef FEAT_GUI\n\t// check redraw when it's not a GUI option or the GUI is active.\n\tif (!redraw_gui_only || gui.in_use)\n#endif\n\t    check_redraw(get_option_flags(opt_idx));\n    }\n\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n    if (did_swaptcap)\n    {\n\tset_termname((char_u *)\"win32\");\n\tinit_highlight(TRUE, FALSE);\n    }\n#endif\n\n    return errmsg;\n}\n\n/*\n * Check an option that can be a range of string values.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\n    static int\ncheck_opt_strings(\n    char_u\t*val,\n    char\t**values,\n    int\t\tlist)\t    // when TRUE: accept a list of values\n{\n    return opt_strings_flags(val, values, NULL, list);\n}\n\n/*\n * Handle an option that can be a range of string values.\n * Set a flag in \"*flagp\" for each string present.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\n    static int\nopt_strings_flags(\n    char_u\t*val,\t\t// new value\n    char\t**values,\t// array of valid string values\n    unsigned\t*flagp,\n    int\t\tlist)\t\t// when TRUE: accept a list of values\n{\n    int\t\ti;\n    int\t\tlen;\n    unsigned\tnew_flags = 0;\n\n    while (*val)\n    {\n\tfor (i = 0; ; ++i)\n\t{\n\t    if (values[i] == NULL)\t// val not found in values[]\n\t\treturn FAIL;\n\n\t    len = (int)STRLEN(values[i]);\n\t    if (STRNCMP(values[i], val, len) == 0\n\t\t    && ((list && val[len] == ',') || val[len] == NUL))\n\t    {\n\t\tval += len + (val[len] == ',');\n\t\tnew_flags |= (1 << i);\n\t\tbreak;\t\t// check next item in val list\n\t    }\n\t}\n    }\n    if (flagp != NULL)\n\t*flagp = new_flags;\n\n    return OK;\n}\n\n/*\n * return OK if \"p\" is a valid fileformat name, FAIL otherwise.\n */\n    int\ncheck_ff_value(char_u *p)\n{\n    return check_opt_strings(p, p_ff_values, FALSE);\n}\n", "\" Test :retab\n\nfunc SetUp()\n  new\n  call setline(1, \"\\ta  \\t    b        c    \")\nendfunc\n\nfunc TearDown()\n  bwipe!\nendfunc\n\nfunc Retab(bang, n)\n  let l:old_tabstop = &tabstop\n  let l:old_line = getline(1)\n  exe \"retab\" . a:bang . a:n\n  let l:line = getline(1)\n  call setline(1, l:old_line)\n  if a:n > 0\n    \" :retab changes 'tabstop' to n with argument n > 0.\n    call assert_equal(a:n, &tabstop)\n    exe 'set tabstop=' . l:old_tabstop\n  else\n    \" :retab does not change 'tabstop' with empty or n <= 0.\n    call assert_equal(l:old_tabstop, &tabstop)\n  endif\n  return l:line\nendfunc\n\nfunc Test_retab()\n  set tabstop=8 noexpandtab\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  ''))\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  0))\n  call assert_equal(\"\\ta\\t    b        c    \",            Retab('',  8))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', ''))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', 0))\n  call assert_equal(\"\\ta\\t    b\\t     c\\t  \",             Retab('!', 8))\n\n  call assert_equal(\"\\t\\ta\\t\\t\\tb        c    \",          Retab('',  4))\n  call assert_equal(\"\\t\\ta\\t\\t\\tb\\t\\t c\\t  \",             Retab('!', 4))\n\n  call assert_equal(\"        a\\t\\tb        c    \",        Retab('',  10))\n  call assert_equal(\"        a\\t\\tb        c    \",        Retab('!', 10))\n\n  set tabstop=8 expandtab\n  call assert_equal(\"        a           b        c    \", Retab('',  ''))\n  call assert_equal(\"        a           b        c    \", Retab('',  0))\n  call assert_equal(\"        a           b        c    \", Retab('',  8))\n  call assert_equal(\"        a           b        c    \", Retab('!', ''))\n  call assert_equal(\"        a           b        c    \", Retab('!', 0))\n  call assert_equal(\"        a           b        c    \", Retab('!', 8))\n\n  call assert_equal(\"        a           b        c    \", Retab(' ', 4))\n  call assert_equal(\"        a           b        c    \", Retab('!', 4))\n\n  call assert_equal(\"        a           b        c    \", Retab(' ', 10))\n  call assert_equal(\"        a           b        c    \", Retab('!', 10))\n\n  set tabstop=4 noexpandtab\n  call assert_equal(\"\\ta\\t\\tb        c    \",              Retab('',  ''))\n  call assert_equal(\"\\ta\\t\\tb\\t\\t c\\t  \",                 Retab('!', ''))\n  call assert_equal(\"\\t a\\t\\t\\tb        c    \",           Retab('',  3))\n  call assert_equal(\"\\t a\\t\\t\\tb\\t\\t\\tc\\t  \",             Retab('!', 3))\n  call assert_equal(\"    a\\t  b        c    \",            Retab('',  5))\n  call assert_equal(\"    a\\t  b\\t\\t c\\t \",                Retab('!', 5))\n\n  set tabstop=4 expandtab\n  call assert_equal(\"    a       b        c    \",         Retab('',  ''))\n  call assert_equal(\"    a       b        c    \",         Retab('!', ''))\n  call assert_equal(\"    a       b        c    \",         Retab('',  3))\n  call assert_equal(\"    a       b        c    \",         Retab('!', 3))\n  call assert_equal(\"    a       b        c    \",         Retab('',  5))\n  call assert_equal(\"    a       b        c    \",         Retab('!', 5))\nendfunc\n\nfunc Test_retab_error()\n  call assert_fails('retab -1',  'E487:')\n  call assert_fails('retab! -1', 'E487:')\n  call assert_fails('ret -1000', 'E487:')\n  call assert_fails('ret 10000', 'E475:')\n  call assert_fails('ret 80000000000000000000', 'E475:')\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t\t  VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/indent.c", "src/option.c", "src/optionstr.c", "src/testdir/test_retab.vim", "src/version.c"], "buggy_code_start_loc": [20, 2452, 2243, 77, 757], "buggy_code_end_loc": [1595, 6822, 2283, 77, 757], "fixing_code_start_loc": [21, 2452, 2243, 78, 758], "fixing_code_end_loc": [1603, 6822, 2283, 81, 760], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3770", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-06T12:15:08.383", "lastModified": "2022-12-07T21:30:12.110", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable a un Desbordamiento del B\u00fafer en la regi\u00f3n Heap de la memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3408", "matchCriteriaId": "D703C26C-A2C5-46CE-B1FF-8552AB2E1066"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/10/01/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/016ad2f2-07c1-4d14-a8ce-6eed10729365", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/J2CJLY3CF55I2ULG2X4ENXLSXAXYW5J4/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X4FFQARG3LGREPDZRI4C7ERQL3RJKEWQ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZFNTMVZCN4TRTTCAXRLVQ7H2P7FYAIZQ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221124-0003/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9"}}