{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport com.facebook.thrift.TException;\nimport com.facebook.thrift.transport.TTransport;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/** Binary protocol implementation for thrift. */\npublic class TBinaryProtocol extends TProtocol {\n  private static final TStruct ANONYMOUS_STRUCT = new TStruct();\n\n  public static final int VERSION_MASK = 0xffff0000;\n  public static final int VERSION_1 = 0x80010000;\n\n  protected final boolean strictRead_;\n  protected final boolean strictWrite_;\n\n  protected int readLength_;\n  protected boolean checkReadLength_;\n\n  private final byte[] buffer = new byte[8];\n\n  /** Factory */\n  @SuppressWarnings(\"serial\")\n  public static class Factory implements TProtocolFactory {\n    protected final boolean strictRead_;\n    protected final boolean strictWrite_;\n    protected int readLength_;\n\n    public Factory() {\n      this(false, true);\n    }\n\n    public Factory(boolean strictRead, boolean strictWrite) {\n      this(strictRead, strictWrite, 0);\n    }\n\n    public Factory(boolean strictRead, boolean strictWrite, int readLength) {\n      strictRead_ = strictRead;\n      strictWrite_ = strictWrite;\n      readLength_ = readLength;\n    }\n\n    public TProtocol getProtocol(TTransport trans) {\n      TBinaryProtocol proto = new TBinaryProtocol(trans, strictRead_, strictWrite_);\n      if (readLength_ != 0) {\n        proto.setReadLength(readLength_);\n      }\n      return proto;\n    }\n  }\n\n  /** Constructor */\n  public TBinaryProtocol(TTransport trans) {\n    this(trans, false, true);\n  }\n\n  public TBinaryProtocol(TTransport trans, boolean strictRead, boolean strictWrite) {\n    super(trans);\n    strictRead_ = strictRead;\n    strictWrite_ = strictWrite;\n    checkReadLength_ = false;\n  }\n\n  public void writeMessageBegin(TMessage message) throws TException {\n    if (message == null) {\n      throw new TException(\"Can't write 'null' message\");\n    }\n\n    if (strictWrite_) {\n      int version = VERSION_1 | message.type;\n      writeI32(version);\n      writeString(message.name);\n      writeI32(message.seqid);\n    } else {\n      writeString(message.name);\n      writeByte(message.type);\n      writeI32(message.seqid);\n    }\n  }\n\n  public void writeMessageEnd() {}\n\n  public void writeStructBegin(TStruct struct) {}\n\n  public void writeStructEnd() {}\n\n  public void writeFieldBegin(TField field) throws TException {\n    writeByte(field.type);\n    writeI16(field.id);\n  }\n\n  public void writeFieldEnd() {}\n\n  public void writeFieldStop() throws TException {\n    writeByte(TType.STOP);\n  }\n\n  public void writeMapBegin(TMap map) throws TException {\n    writeByte(map.keyType);\n    writeByte(map.valueType);\n    writeI32(map.size);\n  }\n\n  public void writeMapEnd() {}\n\n  public void writeListBegin(TList list) throws TException {\n    writeByte(list.elemType);\n    writeI32(list.size);\n  }\n\n  public void writeListEnd() {}\n\n  public void writeSetBegin(TSet set) throws TException {\n    writeByte(set.elemType);\n    writeI32(set.size);\n  }\n\n  public void writeSetEnd() {}\n\n  public void writeBool(boolean b) throws TException {\n    writeByte(b ? (byte) 1 : (byte) 0);\n  }\n\n  public void writeByte(byte b) throws TException {\n    buffer[0] = b;\n    trans_.write(buffer, 0, 1);\n  }\n\n  public void writeI16(short i16) throws TException {\n    buffer[0] = (byte) (0xff & (i16 >> 8));\n    buffer[1] = (byte) (0xff & (i16));\n    trans_.write(buffer, 0, 2);\n  }\n\n  public void writeI32(int i32) throws TException {\n    buffer[0] = (byte) (0xff & (i32 >> 24));\n    buffer[1] = (byte) (0xff & (i32 >> 16));\n    buffer[2] = (byte) (0xff & (i32 >> 8));\n    buffer[3] = (byte) (0xff & (i32));\n    trans_.write(buffer, 0, 4);\n  }\n\n  public void writeI64(long i64) throws TException {\n    buffer[0] = (byte) (0xff & (i64 >> 56));\n    buffer[1] = (byte) (0xff & (i64 >> 48));\n    buffer[2] = (byte) (0xff & (i64 >> 40));\n    buffer[3] = (byte) (0xff & (i64 >> 32));\n    buffer[4] = (byte) (0xff & (i64 >> 24));\n    buffer[5] = (byte) (0xff & (i64 >> 16));\n    buffer[6] = (byte) (0xff & (i64 >> 8));\n    buffer[7] = (byte) (0xff & (i64));\n    trans_.write(buffer, 0, 8);\n  }\n\n  public void writeDouble(double dub) throws TException {\n    writeI64(Double.doubleToLongBits(dub));\n  }\n\n  public void writeFloat(float flt) throws TException {\n    writeI32(Float.floatToIntBits(flt));\n  }\n\n  public void writeString(String str) throws TException {\n    byte[] dat = str.getBytes(StandardCharsets.UTF_8);\n    writeI32(dat.length);\n    trans_.write(dat, 0, dat.length);\n  }\n\n  public void writeBinary(byte[] bin) throws TException {\n    writeI32(bin.length);\n    trans_.write(bin, 0, bin.length);\n  }\n\n  /** Reading methods. */\n  public TMessage readMessageBegin() throws TException {\n    int size = readI32();\n    if (size < 0) {\n      int version = size & VERSION_MASK;\n      if (version != VERSION_1) {\n        throw new TProtocolException(\n            TProtocolException.BAD_VERSION, \"Bad version in readMessageBegin\");\n      }\n      return new TMessage(readString(), (byte) (size & 0x000000ff), readI32());\n    } else {\n      if (strictRead_) {\n        throw new TProtocolException(\n            TProtocolException.BAD_VERSION, \"Missing version in readMessageBegin, old client?\");\n      }\n      return new TMessage(readStringBody(size), readByte(), readI32());\n    }\n  }\n\n  public void readMessageEnd() {}\n\n  public TStruct readStructBegin(\n      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) {\n    return ANONYMOUS_STRUCT;\n  }\n\n  public void readStructEnd() {}\n\n  public TField readFieldBegin() throws TException {\n    byte type = readByte();\n    short id = type == TType.STOP ? 0 : readI16();\n    return new TField(\"\", type, id);\n  }\n\n  public void readFieldEnd() {}\n\n  public TMap readMapBegin() throws TException {\n    byte keyType = readByte();\n    byte valueType = readByte();\n    int size = readI32();\n    ensureMapHasEnough(size, keyType, valueType);\n    return new TMap(keyType, valueType, size);\n  }\n\n  public void readMapEnd() {}\n\n  public TList readListBegin() throws TException {\n    byte type = readByte();\n    int size = readI32();\n    ensureContainerHasEnough(size, type);\n    return new TList(type, size);\n  }\n\n  public void readListEnd() {}\n\n  public TSet readSetBegin() throws TException {\n    byte type = readByte();\n    int size = readI32();\n    ensureContainerHasEnough(size, type);\n    return new TSet(type, size);\n  }\n\n  public void readSetEnd() {}\n\n  public boolean readBool() throws TException {\n    return (readByte() == 1);\n  }\n\n  public byte readByte() throws TException {\n    if (trans_.getBytesRemainingInBuffer() >= 1) {\n      byte b = trans_.getBuffer()[trans_.getBufferPosition()];\n      trans_.consumeBuffer(1);\n      return b;\n    }\n    readAll(buffer, 0, 1);\n    return buffer[0];\n  }\n\n  public short readI16() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 2) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(2);\n    } else {\n      readAll(buffer, 0, 2);\n    }\n\n    return (short) (((buf[off] & 0xff) << 8) | ((buf[off + 1] & 0xff)));\n  }\n\n  public int readI32() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 4) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(4);\n    } else {\n      readAll(buffer, 0, 4);\n    }\n    return ((buf[off] & 0xff) << 24)\n        | ((buf[off + 1] & 0xff) << 16)\n        | ((buf[off + 2] & 0xff) << 8)\n        | ((buf[off + 3] & 0xff));\n  }\n\n  public long readI64() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 8) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(8);\n    } else {\n      readAll(buffer, 0, 8);\n    }\n\n    return ((long) (buf[off] & 0xff) << 56)\n        | ((long) (buf[off + 1] & 0xff) << 48)\n        | ((long) (buf[off + 2] & 0xff) << 40)\n        | ((long) (buf[off + 3] & 0xff) << 32)\n        | ((long) (buf[off + 4] & 0xff) << 24)\n        | ((long) (buf[off + 5] & 0xff) << 16)\n        | ((long) (buf[off + 6] & 0xff) << 8)\n        | ((long) (buf[off + 7] & 0xff));\n  }\n\n  public double readDouble() throws TException {\n    return Double.longBitsToDouble(readI64());\n  }\n\n  public float readFloat() throws TException {\n    return Float.intBitsToFloat(readI32());\n  }\n\n  public String readString() throws TException {\n    int size = readI32();\n    checkReadLength(size);\n\n    if (trans_.getBytesRemainingInBuffer() >= size) {\n      String s =\n          new String(trans_.getBuffer(), trans_.getBufferPosition(), size, StandardCharsets.UTF_8);\n      trans_.consumeBuffer(size);\n      return s;\n    }\n\n    return readStringBody(size);\n  }\n\n  public String readStringBody(int size) throws TException {\n    checkReadLength(size);\n    byte[] buf = new byte[size];\n    trans_.readAll(buf, 0, size);\n    return new String(buf, StandardCharsets.UTF_8);\n  }\n\n  public byte[] readBinary() throws TException {\n    int size = readI32();\n    checkReadLength(size);\n    byte[] buf = new byte[size];\n    trans_.readAll(buf, 0, size);\n    return buf;\n  }\n\n  private int readAll(byte[] buf, int off, int len) throws TException {\n    checkReadLength(len);\n    return trans_.readAll(buf, off, len);\n  }\n\n  public void setReadLength(int readLength) {\n    readLength_ = readLength;\n    checkReadLength_ = true;\n  }\n\n  protected void checkReadLength(int length) throws TException {\n    if (length < 0) {\n      throw new TException(\"Negative length: \" + length);\n    }\n    if (checkReadLength_) {\n      readLength_ -= length;\n      if (readLength_ < 0) {\n        throw new TException(\"Message length exceeded: \" + length);\n      }\n    }\n  }\n\n  @Override\n  protected int typeMinimumSize(byte type) {\n    switch (type & 0x0f) {\n      case TType.BOOL:\n      case TType.BYTE:\n        return 1;\n      case TType.I16:\n        return 2;\n      case TType.I32:\n      case TType.FLOAT:\n        return 4;\n      case TType.DOUBLE:\n      case TType.I64:\n        return 8;\n      case TType.STRING:\n        return 4;\n      case TType.LIST:\n      case TType.SET:\n        // type (1 byte) + size (4 bytes)\n        return 1 + 4;\n      case TType.MAP:\n        // key type (1 byte) + value type (1 byte) + size (4 bytes)\n        return 1 + 1 + 4;\n      case TType.STRUCT:\n        return 1;\n      default:\n        throw new TProtocolException(\n            TProtocolException.INVALID_DATA, \"Unexpected data type \" + (byte) (type & 0x0f));\n    }\n  }\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport com.facebook.thrift.ShortStack;\nimport com.facebook.thrift.TException;\nimport com.facebook.thrift.transport.TTransport;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * TCompactProtocol2 is the Java implementation of the compact protocol specified in THRIFT-110. The\n * fundamental approach to reducing the overhead of structures is a) use variable-length integers\n * all over the place and b) make use of unused bits wherever possible. Your savings will obviously\n * vary based on the specific makeup of your structs, but in general, the more fields, nested\n * structures, short strings and collections, and low-value i32 and i64 fields you have, the more\n * benefit you'll see.\n */\npublic class TCompactProtocol extends TProtocol {\n\n  private static final TStruct ANONYMOUS_STRUCT = new TStruct(\"\");\n  private static final TField TSTOP = new TField(\"\", TType.STOP, (short) 0);\n\n  private static final byte[] ttypeToCompactType = new byte[20];\n\n  static {\n    ttypeToCompactType[TType.STOP] = TType.STOP;\n    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;\n    ttypeToCompactType[TType.BYTE] = Types.BYTE;\n    ttypeToCompactType[TType.I16] = Types.I16;\n    ttypeToCompactType[TType.I32] = Types.I32;\n    ttypeToCompactType[TType.I64] = Types.I64;\n    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;\n    ttypeToCompactType[TType.STRING] = Types.BINARY;\n    ttypeToCompactType[TType.LIST] = Types.LIST;\n    ttypeToCompactType[TType.SET] = Types.SET;\n    ttypeToCompactType[TType.MAP] = Types.MAP;\n    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;\n    ttypeToCompactType[TType.FLOAT] = Types.FLOAT;\n  }\n\n  /** TProtocolFactory that produces TCompactProtocols. */\n  @SuppressWarnings(\"serial\")\n  public static class Factory implements TProtocolFactory {\n    private final long maxNetworkBytes_;\n\n    public Factory() {\n      maxNetworkBytes_ = -1;\n    }\n\n    public Factory(int maxNetworkBytes) {\n      maxNetworkBytes_ = maxNetworkBytes;\n    }\n\n    public TProtocol getProtocol(TTransport trans) {\n      return new TCompactProtocol(trans, maxNetworkBytes_);\n    }\n  }\n\n  public static final byte PROTOCOL_ID = (byte) 0x82;\n  public static final byte VERSION = 2;\n  public static final byte VERSION_LOW = 1;\n  public static final byte VERSION_DOUBLE_BE = 2;\n  public static final byte VERSION_MASK = 0x1f; // 0001 1111\n  public static final byte TYPE_MASK = (byte) 0xE0; // 1110 0000\n  public static final int TYPE_SHIFT_AMOUNT = 5;\n\n  /** All of the on-wire type codes. */\n  private static class Types {\n    public static final byte BOOLEAN_TRUE = 0x01;\n    public static final byte BOOLEAN_FALSE = 0x02;\n    public static final byte BYTE = 0x03;\n    public static final byte I16 = 0x04;\n    public static final byte I32 = 0x05;\n    public static final byte I64 = 0x06;\n    public static final byte DOUBLE = 0x07;\n    public static final byte BINARY = 0x08;\n    public static final byte LIST = 0x09;\n    public static final byte SET = 0x0A;\n    public static final byte MAP = 0x0B;\n    public static final byte STRUCT = 0x0C;\n    public static final byte FLOAT = 0x0D;\n  }\n\n  /**\n   * Used to keep track of the last field for the current and previous structs, so we can do the\n   * delta stuff.\n   */\n  private ShortStack lastField_ = new ShortStack(15);\n\n  private short lastFieldId_ = 0;\n\n  private byte version_ = VERSION;\n\n  /**\n   * If we encounter a boolean field begin, save the TField here so it can have the value\n   * incorporated.\n   */\n  private TField booleanField_ = null;\n\n  /**\n   * If we read a field header, and it's a boolean field, save the boolean value here so that\n   * readBool can use it.\n   */\n  private Boolean boolValue_ = null;\n\n  /**\n   * The maximum number of bytes to read from the network for variable-length fields (such as\n   * strings or binary) or -1 for unlimited.\n   */\n  private final long maxNetworkBytes_;\n\n  /** Temporary buffer to avoid allocations */\n  private final byte[] buffer = new byte[10];\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   * @param maxNetworkBytes the maximum number of bytes to read for variable-length fields.\n   */\n  public TCompactProtocol(TTransport transport, long maxNetworkBytes) {\n    super(transport);\n    maxNetworkBytes_ = maxNetworkBytes;\n  }\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   */\n  public TCompactProtocol(TTransport transport) {\n    this(transport, -1);\n  }\n\n  public void reset() {\n    lastField_.clear();\n    lastFieldId_ = 0;\n  }\n\n  //\n  // Public Writing methods.\n  //\n\n  /**\n   * Write a message header to the wire. Compact Protocol messages contain the protocol version so\n   * we can migrate forwards in the future if need be.\n   */\n  public void writeMessageBegin(TMessage message) throws TException {\n    writeByteDirect(PROTOCOL_ID);\n    writeByteDirect((VERSION & VERSION_MASK) | ((message.type << TYPE_SHIFT_AMOUNT) & TYPE_MASK));\n    writeVarint32(message.seqid);\n    writeString(message.name);\n  }\n\n  /**\n   * Write a struct begin. This doesn't actually put anything on the wire. We use it as an\n   * opportunity to put special placeholder markers on the field stack so we can get the field id\n   * deltas correct.\n   */\n  public void writeStructBegin(TStruct struct) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n  }\n\n  /**\n   * Write a struct end. This doesn't actually put anything on the wire. We use this as an\n   * opportunity to pop the last field from the current struct off of the field stack.\n   */\n  public void writeStructEnd() throws TException {\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /**\n   * Write a field header containing the field id and field type. If the difference between the\n   * current field id and the last one is small (< 15), then the field id will be encoded in the 4\n   * MSB as a delta. Otherwise, the field id will follow the type header as a zigzag varint.\n   */\n  public void writeFieldBegin(TField field) throws TException {\n    if (field.type == TType.BOOL) {\n      // we want to possibly include the value, so we'll wait.\n      booleanField_ = field;\n    } else {\n      writeFieldBeginInternal(field, (byte) -1);\n    }\n  }\n\n  /**\n   * The workhorse of writeFieldBegin. It has the option of doing a 'type override' of the type\n   * header. This is used specifically in the boolean field case.\n   */\n  private void writeFieldBeginInternal(TField field, byte typeOverride) throws TException {\n    // short lastField = lastField_.pop();\n\n    // if there's a type override, use that.\n    byte typeToWrite = typeOverride == -1 ? getCompactType(field.type) : typeOverride;\n\n    // check if we can use delta encoding for the field id\n    if (field.id > lastFieldId_ && field.id - lastFieldId_ <= 15) {\n      // write them together\n      writeByteDirect((field.id - lastFieldId_) << 4 | typeToWrite);\n    } else {\n      // write them separate\n      writeByteDirect(typeToWrite);\n      writeI16(field.id);\n    }\n\n    lastFieldId_ = field.id;\n    // lastField_.push(field.id);\n  }\n\n  /** Write the STOP symbol so we know there are no more fields in this struct. */\n  public void writeFieldStop() throws TException {\n    writeByteDirect(TType.STOP);\n  }\n\n  /**\n   * Write a map header. If the map is empty, omit the key and value type headers, as we don't need\n   * any additional information to skip it.\n   */\n  public void writeMapBegin(TMap map) throws TException {\n    if (map.size == 0) {\n      writeByteDirect(0);\n    } else {\n      writeVarint32(map.size);\n      writeByteDirect(getCompactType(map.keyType) << 4 | getCompactType(map.valueType));\n    }\n  }\n\n  /** Write a list header. */\n  public void writeListBegin(TList list) throws TException {\n    writeCollectionBegin(list.elemType, list.size);\n  }\n\n  /** Write a set header. */\n  public void writeSetBegin(TSet set) throws TException {\n    writeCollectionBegin(set.elemType, set.size);\n  }\n\n  /**\n   * Write a boolean value. Potentially, this could be a boolean field, in which case the field\n   * header info isn't written yet. If so, decide what the right type header is for the value and\n   * then write the field header. Otherwise, write a single byte.\n   */\n  public void writeBool(boolean b) throws TException {\n    if (booleanField_ != null) {\n      // we haven't written the field header yet\n      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n      booleanField_ = null;\n    } else {\n      // we're not part of a field, so just write the value.\n      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n    }\n  }\n\n  /** Write a byte. Nothing to see here! */\n  public void writeByte(byte b) throws TException {\n    writeByteDirect(b);\n  }\n\n  /** Write an I16 as a zigzag varint. */\n  public void writeI16(short i16) throws TException {\n    writeVarint32(intToZigZag(i16));\n  }\n\n  /** Write an i32 as a zigzag varint. */\n  public void writeI32(int i32) throws TException {\n    writeVarint32(intToZigZag(i32));\n  }\n\n  /** Write an i64 as a zigzag varint. */\n  public void writeI64(long i64) throws TException {\n    writeVarint64(longToZigzag(i64));\n  }\n\n  /** Write a double to the wire as 8 bytes. */\n  public void writeDouble(double dub) throws TException {\n    fixedLongToBytes(Double.doubleToLongBits(dub), buffer, 0);\n    trans_.write(buffer, 0, 8);\n  }\n\n  /** Write a float to the wire as 4 bytes. */\n  public void writeFloat(float flt) throws TException {\n    fixedIntToBytes(Float.floatToIntBits(flt), buffer, 0);\n    trans_.write(buffer, 0, 4);\n  }\n\n  /** Write a string to the wire with a varint size preceding. */\n  public void writeString(String str) throws TException {\n    byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    writeBinary(bytes, 0, bytes.length);\n  }\n\n  /** Write a byte array, using a varint for the size. */\n  public void writeBinary(byte[] buf) throws TException {\n    writeBinary(buf, 0, buf.length);\n  }\n\n  private void writeBinary(byte[] buf, int offset, int length) throws TException {\n    writeVarint32(length);\n    trans_.write(buf, offset, length);\n  }\n\n  //\n  // These methods are called by structs, but don't actually have any wire\n  // output or purpose.\n  //\n\n  public void writeMessageEnd() throws TException {}\n\n  public void writeMapEnd() throws TException {}\n\n  public void writeListEnd() throws TException {}\n\n  public void writeSetEnd() throws TException {}\n\n  public void writeFieldEnd() throws TException {}\n\n  //\n  // Internal writing methods\n  //\n\n  /**\n   * Abstract method for writing the start of lists and sets. List and sets on the wire differ only\n   * by the type indicator.\n   */\n  protected void writeCollectionBegin(byte elemType, int size) throws TException {\n    if (size <= 14) {\n      writeByteDirect(size << 4 | getCompactType(elemType));\n    } else {\n      writeByteDirect(0xf0 | getCompactType(elemType));\n      writeVarint32(size);\n    }\n  }\n\n  /** Write an i32 as a varint. Results in 1-5 bytes on the wire. */\n  private void writeVarint32(int n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7F) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = (byte) ((n & 0x7F) | 0x80);\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /** Write an i64 as a varint. Results in 1-10 bytes on the wire. */\n  private void writeVarint64(long n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7FL) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = ((byte) ((n & 0x7F) | 0x80));\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /**\n   * Convert l into a zigzag long. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private long longToZigzag(long l) {\n    return (l << 1) ^ (l >> 63);\n  }\n\n  /**\n   * Convert n into a zigzag int. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private int intToZigZag(int n) {\n    return (n << 1) ^ (n >> 31);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedLongToBytes(long n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 56) & 0xff);\n    buf[off + 1] = (byte) ((n >> 48) & 0xff);\n    buf[off + 2] = (byte) ((n >> 40) & 0xff);\n    buf[off + 3] = (byte) ((n >> 32) & 0xff);\n    buf[off + 4] = (byte) ((n >> 24) & 0xff);\n    buf[off + 5] = (byte) ((n >> 16) & 0xff);\n    buf[off + 6] = (byte) ((n >> 8) & 0xff);\n    buf[off + 7] = (byte) (n & 0xff);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedIntToBytes(int n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 24) & 0xff);\n    buf[off + 1] = (byte) ((n >> 16) & 0xff);\n    buf[off + 2] = (byte) ((n >> 8) & 0xff);\n    buf[off + 3] = (byte) (n & 0xff);\n  }\n\n  /**\n   * Writes a byte without any possiblity of all that field header nonsense. Used internally by\n   * other writing methods that know they need to write a byte.\n   */\n  private void writeByteDirect(byte b) throws TException {\n    buffer[0] = b;\n    trans_.write(buffer, 0, 1);\n  }\n\n  /** Writes a byte without any possiblity of all that field header nonsense. */\n  private void writeByteDirect(int n) throws TException {\n    writeByteDirect((byte) n);\n  }\n\n  //\n  // Reading methods.\n  //\n\n  /** Read a message header. */\n  public TMessage readMessageBegin() throws TException {\n    byte protocolId = readByte();\n    if (protocolId != PROTOCOL_ID) {\n      throw new TProtocolException(\n          \"Expected protocol id \"\n              + Integer.toHexString(PROTOCOL_ID)\n              + \" but got \"\n              + Integer.toHexString(protocolId));\n    }\n    byte versionAndType = readByte();\n    version_ = (byte) (versionAndType & VERSION_MASK);\n    if (!(version_ <= VERSION && version_ >= VERSION_LOW)) {\n      throw new TProtocolException(\"Expected version \" + VERSION + \" but got \" + version_);\n    }\n    byte type = (byte) ((versionAndType >> TYPE_SHIFT_AMOUNT) & 0x03);\n    int seqid = readVarint32();\n    String messageName = readString();\n    return new TMessage(messageName, type, seqid);\n  }\n\n  /**\n   * Read a struct begin. There's nothing on the wire for this, but it is our opportunity to push a\n   * new struct begin marker onto the field stack.\n   */\n  public TStruct readStructBegin(\n      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n    return ANONYMOUS_STRUCT;\n  }\n\n  /**\n   * Doesn't actually consume any wire data, just removes the last field for this struct from the\n   * field stack.\n   */\n  public void readStructEnd() throws TException {\n    // consume the last field we read off the wire.\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /** Read a field header off the wire. */\n  public TField readFieldBegin() throws TException {\n    byte type = readByte();\n\n    // if it's a stop, then we can return immediately, as the struct is over.\n    if (type == TType.STOP) {\n      return TSTOP;\n    }\n\n    short fieldId;\n\n    // mask off the 4 MSB of the type header. it could contain a field id delta.\n    short modifier = (short) ((type & 0xf0) >> 4);\n    if (modifier == 0) {\n      // not a delta. look ahead for the zigzag varint field id.\n      fieldId = readI16();\n    } else {\n      // has a delta. add the delta to the last read field id.\n      fieldId = (short) (lastFieldId_ + modifier);\n    }\n\n    TField field = new TField(\"\", getTType((byte) (type & 0x0f)), fieldId);\n\n    // if this happens to be a boolean field, the value is encoded in the type\n    if (isBoolType(type)) {\n      // save the boolean value in a special instance variable.\n      boolValue_ = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    // push the new field onto the field stack so we can keep the deltas going.\n    lastFieldId_ = field.id;\n    return field;\n  }\n\n  /**\n   * Read a map header off the wire. If the size is zero, skip reading the key and value type. This\n   * means that 0-length maps will yield TMaps without the \"correct\" types.\n   */\n  public TMap readMapBegin() throws TException {\n    int size = readVarint32();\n    byte keyAndValueType = size == 0 ? 0 : readByte();\n    byte keyType = getTType((byte) (keyAndValueType >> 4));\n    byte valueType = getTType((byte) (keyAndValueType & 0xf));\n    if (size > 0) {\n      ensureMapHasEnough(size, keyType, valueType);\n    }\n    return new TMap(keyType, valueType, size);\n  }\n\n  /**\n   * Read a list header off the wire. If the list size is 0-14, the size will be packed into the\n   * element type header. If it's a longer list, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TList readListBegin() throws TException {\n    byte size_and_type = readByte();\n    int size = (size_and_type >> 4) & 0x0f;\n    if (size == 15) {\n      size = readVarint32();\n    }\n    byte type = getTType(size_and_type);\n    ensureContainerHasEnough(size, type);\n    return new TList(type, size);\n  }\n\n  /**\n   * Read a set header off the wire. If the set size is 0-14, the size will be packed into the\n   * element type header. If it's a longer set, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TSet readSetBegin() throws TException {\n    return new TSet(readListBegin());\n  }\n\n  /**\n   * Read a boolean off the wire. If this is a boolean field, the value should already have been\n   * read during readFieldBegin, so we'll just consume the pre-stored value. Otherwise, read a byte.\n   */\n  public boolean readBool() throws TException {\n    if (boolValue_ != null) {\n      boolean result = boolValue_.booleanValue();\n      boolValue_ = null;\n      return result;\n    }\n    return readByte() == Types.BOOLEAN_TRUE;\n  }\n\n  /** Read a single byte off the wire. Nothing interesting here. */\n  public byte readByte() throws TException {\n    byte b;\n    if (trans_.getBytesRemainingInBuffer() > 0) {\n      b = trans_.getBuffer()[trans_.getBufferPosition()];\n      trans_.consumeBuffer(1);\n    } else {\n      trans_.readAll(buffer, 0, 1);\n      b = buffer[0];\n    }\n    return b;\n  }\n\n  /** Read an i16 from the wire as a zigzag varint. */\n  public short readI16() throws TException {\n    return (short) zigzagToInt(readVarint32());\n  }\n\n  /** Read an i32 from the wire as a zigzag varint. */\n  public int readI32() throws TException {\n    return zigzagToInt(readVarint32());\n  }\n\n  /** Read an i64 from the wire as a zigzag varint. */\n  public long readI64() throws TException {\n    return zigzagToLong(readVarint64());\n  }\n\n  /** No magic here - just read a double off the wire. */\n  public double readDouble() throws TException {\n    trans_.readAll(buffer, 0, 8);\n    long value;\n    if (version_ >= VERSION_DOUBLE_BE) {\n      value = bytesToLong(buffer);\n    } else {\n      value = bytesToLongLE(buffer);\n    }\n    return Double.longBitsToDouble(value);\n  }\n\n  /** No magic here - just read a float off the wire. */\n  public float readFloat() throws TException {\n    trans_.readAll(buffer, 0, 4);\n    int value = bytesToInt(buffer);\n    return Float.intBitsToFloat(value);\n  }\n\n  /** Reads a byte[] (via readBinary), and then UTF-8 decodes it. */\n  public String readString() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n\n    if (length == 0) {\n      return \"\";\n    }\n\n    if (trans_.getBytesRemainingInBuffer() >= length) {\n      String str =\n          new String(\n              trans_.getBuffer(), trans_.getBufferPosition(), length, StandardCharsets.UTF_8);\n      trans_.consumeBuffer(length);\n      return str;\n    } else {\n      return new String(readBinary(length), StandardCharsets.UTF_8);\n    }\n  }\n\n  /** Read a byte[] from the wire. */\n  public byte[] readBinary() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n    return readBinary(length);\n  }\n\n  private byte[] readBinary(int length) throws TException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    byte[] buf = new byte[length];\n    trans_.readAll(buf, 0, length);\n    return buf;\n  }\n\n  private void checkReadLength(int length) throws TProtocolException {\n    if (length < 0) {\n      throw new TProtocolException(\"Negative length: \" + length);\n    }\n    if (maxNetworkBytes_ != -1 && length > maxNetworkBytes_) {\n      throw new TProtocolException(\"Length exceeded max allowed: \" + length);\n    }\n  }\n\n  //\n  // These methods are here for the struct to call, but don't have any wire\n  // encoding.\n  //\n  public void readMessageEnd() throws TException {}\n\n  public void readFieldEnd() throws TException {}\n\n  public void readMapEnd() throws TException {}\n\n  public void readListEnd() throws TException {}\n\n  public void readSetEnd() throws TException {}\n\n  //\n  // Internal reading methods\n  //\n\n  /**\n   * Read an i32 from the wire as a varint. The MSB of each byte is set if there is another byte to\n   * follow. This can read up to 5 bytes.\n   */\n  private int readVarint32() throws TException {\n    int result = 0;\n    int shift = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 5) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Read an i64 from the wire as a proper varint. The MSB of each byte is set if there is another\n   * byte to follow. This can read up to 10 bytes.\n   */\n  private long readVarint64() throws TException {\n    int shift = 0;\n    long result = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 10) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  //\n  // encoding helpers\n  //\n\n  /** Convert from zigzag int to int. */\n  private int zigzagToInt(int n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /** Convert from zigzag long to long. */\n  private long zigzagToLong(long n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /**\n   * Note that it's important that the mask bytes are long literals, otherwise they'll default to\n   * ints, and when you shift an int left 56 bits, you just get a messed up int.\n   */\n  private long bytesToLong(byte[] bytes) {\n    return ((bytes[0] & 0xffL) << 56)\n        | ((bytes[1] & 0xffL) << 48)\n        | ((bytes[2] & 0xffL) << 40)\n        | ((bytes[3] & 0xffL) << 32)\n        | ((bytes[4] & 0xffL) << 24)\n        | ((bytes[5] & 0xffL) << 16)\n        | ((bytes[6] & 0xffL) << 8)\n        | ((bytes[7] & 0xffL));\n  }\n\n  /* Little endian version of the above */\n  private long bytesToLongLE(byte[] bytes) {\n    return ((bytes[7] & 0xffL) << 56)\n        | ((bytes[6] & 0xffL) << 48)\n        | ((bytes[5] & 0xffL) << 40)\n        | ((bytes[4] & 0xffL) << 32)\n        | ((bytes[3] & 0xffL) << 24)\n        | ((bytes[2] & 0xffL) << 16)\n        | ((bytes[1] & 0xffL) << 8)\n        | ((bytes[0] & 0xffL));\n  }\n\n  private int bytesToInt(byte[] bytes) {\n    return ((bytes[0] & 0xff) << 24)\n        | ((bytes[1] & 0xff) << 16)\n        | ((bytes[2] & 0xff) << 8)\n        | ((bytes[3] & 0xff));\n  }\n\n  //\n  // type testing and converting\n  //\n\n  private boolean isBoolType(byte b) {\n    int lowerNibble = b & 0x0f;\n    return lowerNibble == Types.BOOLEAN_TRUE || lowerNibble == Types.BOOLEAN_FALSE;\n  }\n\n  /** Given a TCompactProtocol.Types constant, convert it to its corresponding TType value. */\n  private byte getTType(byte type) throws TProtocolException {\n    switch ((byte) (type & 0x0f)) {\n      case TType.STOP:\n        return TType.STOP;\n      case Types.BOOLEAN_FALSE:\n      case Types.BOOLEAN_TRUE:\n        return TType.BOOL;\n      case Types.BYTE:\n        return TType.BYTE;\n      case Types.I16:\n        return TType.I16;\n      case Types.I32:\n        return TType.I32;\n      case Types.I64:\n        return TType.I64;\n      case Types.DOUBLE:\n        return TType.DOUBLE;\n      case Types.FLOAT:\n        return TType.FLOAT;\n      case Types.BINARY:\n        return TType.STRING;\n      case Types.LIST:\n        return TType.LIST;\n      case Types.SET:\n        return TType.SET;\n      case Types.MAP:\n        return TType.MAP;\n      case Types.STRUCT:\n        return TType.STRUCT;\n      default:\n        throw new TProtocolException(\"don't know what type: \" + (byte) (type & 0x0f));\n    }\n  }\n\n  /** Given a TType value, find the appropriate TCompactProtocol.Types constant. */\n  private byte getCompactType(byte ttype) {\n    return ttypeToCompactType[ttype];\n  }\n\n  @Override\n  protected int typeMinimumSize(byte type) {\n    switch (type & 0x0f) {\n      case TType.BOOL:\n      case TType.BYTE:\n      case TType.I16: // because of variable length encoding\n      case TType.I32: // because of variable length encoding\n      case TType.I64: // because of variable length encoding\n        return 1;\n      case TType.FLOAT:\n        return 4;\n      case TType.DOUBLE:\n        return 8;\n      case TType.STRING:\n      case TType.STRUCT:\n      case TType.MAP:\n      case TType.SET:\n      case TType.LIST:\n      case TType.ENUM:\n        return 1;\n      default:\n        throw new TProtocolException(\n            TProtocolException.INVALID_DATA, \"Unexpected data type \" + (byte) (type & 0x0f));\n    }\n  }\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace java com.facebook.thrift.java.test\nnamespace java.swift com.facebook.thrift.javaswift.test\n\nstruct MySimpleStruct {\n  1: i64 id,\n  2: string name,\n}\n\nenum SmallEnum {\n  RED = 1,\n  BLUE = 2,\n  GREEN = 3,\n}\n\nenum BigEnum {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  FIVE = 5,\n  SIX = 6,\n  SEVEN = 7,\n  EIGHT = 8,\n  NINE = 9,\n  TEN = 10,\n  ELEVEN = 11,\n  TWELVE = 12,\n  THIRTEEN = 13,\n  FOURTEEN = 14,\n  FIFTEEN = 15,\n  SIXTEEN = 16,\n  SEVENTEEN = 17,\n  EIGHTEEN = 18,\n  NINETEEN = 19,\n  TWENTY = 20,\n}\n\nstruct MyListStruct {\n  1: list<i64> ids\n}\n\nstruct MySetStruct {\n  1: set<i64> ids\n}\n\nstruct MyMapStruct {\n  1: map<i64, string> mapping\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift;\n\nimport com.facebook.thrift.java.test.MyListStruct;\nimport com.facebook.thrift.java.test.MyMapStruct;\nimport com.facebook.thrift.java.test.MySetStruct;\nimport com.facebook.thrift.protocol.TBinaryProtocol;\nimport com.facebook.thrift.protocol.TCompactProtocol;\nimport com.facebook.thrift.protocol.TProtocol;\nimport com.facebook.thrift.protocol.TProtocolException;\nimport com.facebook.thrift.protocol.TType;\nimport com.facebook.thrift.transport.TMemoryInputTransport;\nimport org.junit.Test;\n\npublic class TruncatedFrameTest extends junit.framework.TestCase {\n  private static final byte[] kBinaryListEncoding = {\n    TType.LIST, // Field Type = List\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // List type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // List length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11100110, // list size (0111) and 7>3 + list type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding2 = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11110110, // list size magic marker (1111) + list type (0110) = i64\n    (byte) 0x64, // list actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  public static void testTruncated(TBase struct, TProtocol iprot) throws Exception {\n    try {\n      struct.read(iprot);\n      assertTrue(\"Not reachable\", false);\n    } catch (TProtocolException ex) {\n      assertEquals(\n          \"Not enough bytes to read the entire message, the data appears to be truncated\",\n          ex.getMessage());\n    }\n  }\n\n  @Test\n  public static void testListBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryListEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  private static final byte[] kBinarySetEncoding = {\n    TType.SET, // Field Type = Set\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // Set type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // Set length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b01110110, // set size (0111) and 7>3 + set type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding2 = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b11110110, // set size magic marker (1111) + set type (0110) = i64\n    (byte) 0x64, // set actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testSetBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinarySetEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  private static final byte[] kBinaryMapEncoding = {\n    TType.MAP, // field type = Map\n    (byte) 0x00,\n    (byte) 0x01, // field id = 1\n    TType.I64, // key type = i64\n    TType.STRING, // value type = string\n    (byte) 0x00,\n    (byte) 0xFF,\n    (byte) 0xFF,\n    (byte) 0xFF, // size = 0x00FFFFFF\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00, // key = 0\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x30, // string value = \"0\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // key = 1\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x31, // string value = \"1\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // key = 2\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x32, // string value = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactMapEncoding = {\n    (byte) 0b00011011, // field id delta (0001) + type (1011) = Map\n    (byte) 0x64, // map size (varint = 100)\n    (byte) 0b01101000, // key type (0110) i64, value type (1000) string\n    (byte) 0x00, // key value = 0\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x30, // string content = \"0\"\n    (byte) 0x02, // key value = 1 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x31, // string content = \"1\"\n    (byte) 0x04, // key value = 2 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x32, // string content = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testMapBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryMapEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  @Test\n  public static void testMapCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactMapEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  private static final char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n  private static String bytesToHex(byte[] bytes, int length) {\n    String out = \"\";\n    for (int j = 0; j < length; j++) {\n      int v = bytes[j] & 0xFF;\n      out += hexArray[v >>> 4];\n      out += hexArray[v & 0x0F];\n      out += \" \";\n    }\n    return out;\n  }\n}\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport com.facebook.thrift.TException;\nimport com.facebook.thrift.transport.TTransport;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/** Binary protocol implementation for thrift. */\npublic class TBinaryProtocol extends TProtocol {\n  private static final TStruct ANONYMOUS_STRUCT = new TStruct();\n\n  public static final int VERSION_MASK = 0xffff0000;\n  public static final int VERSION_1 = 0x80010000;\n\n  protected final boolean strictRead_;\n  protected final boolean strictWrite_;\n\n  protected int readLength_;\n  protected boolean checkReadLength_;\n\n  private final byte[] buffer = new byte[8];\n\n  /** Factory */\n  @SuppressWarnings(\"serial\")\n  public static class Factory implements TProtocolFactory {\n    protected final boolean strictRead_;\n    protected final boolean strictWrite_;\n    protected int readLength_;\n\n    public Factory() {\n      this(false, true);\n    }\n\n    public Factory(boolean strictRead, boolean strictWrite) {\n      this(strictRead, strictWrite, 0);\n    }\n\n    public Factory(boolean strictRead, boolean strictWrite, int readLength) {\n      strictRead_ = strictRead;\n      strictWrite_ = strictWrite;\n      readLength_ = readLength;\n    }\n\n    public TProtocol getProtocol(TTransport trans) {\n      TBinaryProtocol proto = new TBinaryProtocol(trans, strictRead_, strictWrite_);\n      if (readLength_ != 0) {\n        proto.setReadLength(readLength_);\n      }\n      return proto;\n    }\n  }\n\n  /** Constructor */\n  public TBinaryProtocol(TTransport trans) {\n    this(trans, false, true);\n  }\n\n  public TBinaryProtocol(TTransport trans, boolean strictRead, boolean strictWrite) {\n    super(trans);\n    strictRead_ = strictRead;\n    strictWrite_ = strictWrite;\n    checkReadLength_ = false;\n  }\n\n  public void writeMessageBegin(TMessage message) throws TException {\n    if (message == null) {\n      throw new TException(\"Can't write 'null' message\");\n    }\n\n    if (strictWrite_) {\n      int version = VERSION_1 | message.type;\n      writeI32(version);\n      writeString(message.name);\n      writeI32(message.seqid);\n    } else {\n      writeString(message.name);\n      writeByte(message.type);\n      writeI32(message.seqid);\n    }\n  }\n\n  public void writeMessageEnd() {}\n\n  public void writeStructBegin(TStruct struct) {}\n\n  public void writeStructEnd() {}\n\n  public void writeFieldBegin(TField field) throws TException {\n    writeByte(field.type);\n    writeI16(field.id);\n  }\n\n  public void writeFieldEnd() {}\n\n  public void writeFieldStop() throws TException {\n    writeByte(TType.STOP);\n  }\n\n  public void writeMapBegin(TMap map) throws TException {\n    writeByte(map.keyType);\n    writeByte(map.valueType);\n    writeI32(map.size);\n  }\n\n  public void writeMapEnd() {}\n\n  public void writeListBegin(TList list) throws TException {\n    writeByte(list.elemType);\n    writeI32(list.size);\n  }\n\n  public void writeListEnd() {}\n\n  public void writeSetBegin(TSet set) throws TException {\n    writeByte(set.elemType);\n    writeI32(set.size);\n  }\n\n  public void writeSetEnd() {}\n\n  public void writeBool(boolean b) throws TException {\n    writeByte(b ? (byte) 1 : (byte) 0);\n  }\n\n  public void writeByte(byte b) throws TException {\n    buffer[0] = b;\n    trans_.write(buffer, 0, 1);\n  }\n\n  public void writeI16(short i16) throws TException {\n    buffer[0] = (byte) (0xff & (i16 >> 8));\n    buffer[1] = (byte) (0xff & (i16));\n    trans_.write(buffer, 0, 2);\n  }\n\n  public void writeI32(int i32) throws TException {\n    buffer[0] = (byte) (0xff & (i32 >> 24));\n    buffer[1] = (byte) (0xff & (i32 >> 16));\n    buffer[2] = (byte) (0xff & (i32 >> 8));\n    buffer[3] = (byte) (0xff & (i32));\n    trans_.write(buffer, 0, 4);\n  }\n\n  public void writeI64(long i64) throws TException {\n    buffer[0] = (byte) (0xff & (i64 >> 56));\n    buffer[1] = (byte) (0xff & (i64 >> 48));\n    buffer[2] = (byte) (0xff & (i64 >> 40));\n    buffer[3] = (byte) (0xff & (i64 >> 32));\n    buffer[4] = (byte) (0xff & (i64 >> 24));\n    buffer[5] = (byte) (0xff & (i64 >> 16));\n    buffer[6] = (byte) (0xff & (i64 >> 8));\n    buffer[7] = (byte) (0xff & (i64));\n    trans_.write(buffer, 0, 8);\n  }\n\n  public void writeDouble(double dub) throws TException {\n    writeI64(Double.doubleToLongBits(dub));\n  }\n\n  public void writeFloat(float flt) throws TException {\n    writeI32(Float.floatToIntBits(flt));\n  }\n\n  public void writeString(String str) throws TException {\n    byte[] dat = str.getBytes(StandardCharsets.UTF_8);\n    writeI32(dat.length);\n    trans_.write(dat, 0, dat.length);\n  }\n\n  public void writeBinary(byte[] bin) throws TException {\n    writeI32(bin.length);\n    trans_.write(bin, 0, bin.length);\n  }\n\n  /** Reading methods. */\n  public TMessage readMessageBegin() throws TException {\n    int size = readI32();\n    if (size < 0) {\n      int version = size & VERSION_MASK;\n      if (version != VERSION_1) {\n        throw new TProtocolException(\n            TProtocolException.BAD_VERSION, \"Bad version in readMessageBegin\");\n      }\n      return new TMessage(readString(), (byte) (size & 0x000000ff), readI32());\n    } else {\n      if (strictRead_) {\n        throw new TProtocolException(\n            TProtocolException.BAD_VERSION, \"Missing version in readMessageBegin, old client?\");\n      }\n      return new TMessage(readStringBody(size), readByte(), readI32());\n    }\n  }\n\n  public void readMessageEnd() {}\n\n  public TStruct readStructBegin(\n      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) {\n    return ANONYMOUS_STRUCT;\n  }\n\n  public void readStructEnd() {}\n\n  public TField readFieldBegin() throws TException {\n    byte type = readByte();\n    short id = type == TType.STOP ? 0 : readI16();\n    return new TField(\"\", type, id);\n  }\n\n  public void readFieldEnd() {}\n\n  public TMap readMapBegin() throws TException {\n    byte keyType = readByte();\n    byte valueType = readByte();\n    int size = readI32();\n    ensureMapHasEnough(size, keyType, valueType);\n    return new TMap(keyType, valueType, size);\n  }\n\n  public void readMapEnd() {}\n\n  public TList readListBegin() throws TException {\n    byte type = readByte();\n    int size = readI32();\n    ensureContainerHasEnough(size, type);\n    return new TList(type, size);\n  }\n\n  public void readListEnd() {}\n\n  public TSet readSetBegin() throws TException {\n    byte type = readByte();\n    int size = readI32();\n    ensureContainerHasEnough(size, type);\n    return new TSet(type, size);\n  }\n\n  public void readSetEnd() {}\n\n  public boolean readBool() throws TException {\n    return (readByte() == 1);\n  }\n\n  public byte readByte() throws TException {\n    if (trans_.getBytesRemainingInBuffer() >= 1) {\n      byte b = trans_.getBuffer()[trans_.getBufferPosition()];\n      trans_.consumeBuffer(1);\n      return b;\n    }\n    readAll(buffer, 0, 1);\n    return buffer[0];\n  }\n\n  public short readI16() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 2) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(2);\n    } else {\n      readAll(buffer, 0, 2);\n    }\n\n    return (short) (((buf[off] & 0xff) << 8) | ((buf[off + 1] & 0xff)));\n  }\n\n  public int readI32() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 4) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(4);\n    } else {\n      readAll(buffer, 0, 4);\n    }\n    return ((buf[off] & 0xff) << 24)\n        | ((buf[off + 1] & 0xff) << 16)\n        | ((buf[off + 2] & 0xff) << 8)\n        | ((buf[off + 3] & 0xff));\n  }\n\n  public long readI64() throws TException {\n    byte[] buf = buffer;\n    int off = 0;\n\n    if (trans_.getBytesRemainingInBuffer() >= 8) {\n      buf = trans_.getBuffer();\n      off = trans_.getBufferPosition();\n      trans_.consumeBuffer(8);\n    } else {\n      readAll(buffer, 0, 8);\n    }\n\n    return ((long) (buf[off] & 0xff) << 56)\n        | ((long) (buf[off + 1] & 0xff) << 48)\n        | ((long) (buf[off + 2] & 0xff) << 40)\n        | ((long) (buf[off + 3] & 0xff) << 32)\n        | ((long) (buf[off + 4] & 0xff) << 24)\n        | ((long) (buf[off + 5] & 0xff) << 16)\n        | ((long) (buf[off + 6] & 0xff) << 8)\n        | ((long) (buf[off + 7] & 0xff));\n  }\n\n  public double readDouble() throws TException {\n    return Double.longBitsToDouble(readI64());\n  }\n\n  public float readFloat() throws TException {\n    return Float.intBitsToFloat(readI32());\n  }\n\n  public String readString() throws TException {\n    int size = readI32();\n    checkReadLength(size);\n\n    if (trans_.getBytesRemainingInBuffer() >= size) {\n      String s =\n          new String(trans_.getBuffer(), trans_.getBufferPosition(), size, StandardCharsets.UTF_8);\n      trans_.consumeBuffer(size);\n      return s;\n    }\n\n    return readStringBody(size);\n  }\n\n  public String readStringBody(int size) throws TException {\n    ensureContainerHasEnough(size, TType.BYTE);\n    checkReadLength(size);\n    byte[] buf = new byte[size];\n    trans_.readAll(buf, 0, size);\n    return new String(buf, StandardCharsets.UTF_8);\n  }\n\n  public byte[] readBinary() throws TException {\n    int size = readI32();\n    ensureContainerHasEnough(size, TType.BYTE);\n    checkReadLength(size);\n    byte[] buf = new byte[size];\n    trans_.readAll(buf, 0, size);\n    return buf;\n  }\n\n  private int readAll(byte[] buf, int off, int len) throws TException {\n    checkReadLength(len);\n    return trans_.readAll(buf, off, len);\n  }\n\n  public void setReadLength(int readLength) {\n    readLength_ = readLength;\n    checkReadLength_ = true;\n  }\n\n  protected void checkReadLength(int length) throws TException {\n    if (length < 0) {\n      throw new TException(\"Negative length: \" + length);\n    }\n    if (checkReadLength_) {\n      readLength_ -= length;\n      if (readLength_ < 0) {\n        throw new TException(\"Message length exceeded: \" + length);\n      }\n    }\n  }\n\n  @Override\n  protected int typeMinimumSize(byte type) {\n    switch (type & 0x0f) {\n      case TType.BOOL:\n      case TType.BYTE:\n        return 1;\n      case TType.I16:\n        return 2;\n      case TType.I32:\n      case TType.FLOAT:\n        return 4;\n      case TType.DOUBLE:\n      case TType.I64:\n        return 8;\n      case TType.STRING:\n        return 4;\n      case TType.LIST:\n      case TType.SET:\n        // type (1 byte) + size (4 bytes)\n        return 1 + 4;\n      case TType.MAP:\n        // key type (1 byte) + value type (1 byte) + size (4 bytes)\n        return 1 + 1 + 4;\n      case TType.STRUCT:\n        return 1;\n      default:\n        throw new TProtocolException(\n            TProtocolException.INVALID_DATA, \"Unexpected data type \" + (byte) (type & 0x0f));\n    }\n  }\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport com.facebook.thrift.ShortStack;\nimport com.facebook.thrift.TException;\nimport com.facebook.thrift.transport.TTransport;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * TCompactProtocol2 is the Java implementation of the compact protocol specified in THRIFT-110. The\n * fundamental approach to reducing the overhead of structures is a) use variable-length integers\n * all over the place and b) make use of unused bits wherever possible. Your savings will obviously\n * vary based on the specific makeup of your structs, but in general, the more fields, nested\n * structures, short strings and collections, and low-value i32 and i64 fields you have, the more\n * benefit you'll see.\n */\npublic class TCompactProtocol extends TProtocol {\n\n  private static final TStruct ANONYMOUS_STRUCT = new TStruct(\"\");\n  private static final TField TSTOP = new TField(\"\", TType.STOP, (short) 0);\n\n  private static final byte[] ttypeToCompactType = new byte[20];\n\n  static {\n    ttypeToCompactType[TType.STOP] = TType.STOP;\n    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;\n    ttypeToCompactType[TType.BYTE] = Types.BYTE;\n    ttypeToCompactType[TType.I16] = Types.I16;\n    ttypeToCompactType[TType.I32] = Types.I32;\n    ttypeToCompactType[TType.I64] = Types.I64;\n    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;\n    ttypeToCompactType[TType.STRING] = Types.BINARY;\n    ttypeToCompactType[TType.LIST] = Types.LIST;\n    ttypeToCompactType[TType.SET] = Types.SET;\n    ttypeToCompactType[TType.MAP] = Types.MAP;\n    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;\n    ttypeToCompactType[TType.FLOAT] = Types.FLOAT;\n  }\n\n  /** TProtocolFactory that produces TCompactProtocols. */\n  @SuppressWarnings(\"serial\")\n  public static class Factory implements TProtocolFactory {\n    private final long maxNetworkBytes_;\n\n    public Factory() {\n      maxNetworkBytes_ = -1;\n    }\n\n    public Factory(int maxNetworkBytes) {\n      maxNetworkBytes_ = maxNetworkBytes;\n    }\n\n    public TProtocol getProtocol(TTransport trans) {\n      return new TCompactProtocol(trans, maxNetworkBytes_);\n    }\n  }\n\n  public static final byte PROTOCOL_ID = (byte) 0x82;\n  public static final byte VERSION = 2;\n  public static final byte VERSION_LOW = 1;\n  public static final byte VERSION_DOUBLE_BE = 2;\n  public static final byte VERSION_MASK = 0x1f; // 0001 1111\n  public static final byte TYPE_MASK = (byte) 0xE0; // 1110 0000\n  public static final int TYPE_SHIFT_AMOUNT = 5;\n\n  /** All of the on-wire type codes. */\n  private static class Types {\n    public static final byte BOOLEAN_TRUE = 0x01;\n    public static final byte BOOLEAN_FALSE = 0x02;\n    public static final byte BYTE = 0x03;\n    public static final byte I16 = 0x04;\n    public static final byte I32 = 0x05;\n    public static final byte I64 = 0x06;\n    public static final byte DOUBLE = 0x07;\n    public static final byte BINARY = 0x08;\n    public static final byte LIST = 0x09;\n    public static final byte SET = 0x0A;\n    public static final byte MAP = 0x0B;\n    public static final byte STRUCT = 0x0C;\n    public static final byte FLOAT = 0x0D;\n  }\n\n  /**\n   * Used to keep track of the last field for the current and previous structs, so we can do the\n   * delta stuff.\n   */\n  private ShortStack lastField_ = new ShortStack(15);\n\n  private short lastFieldId_ = 0;\n\n  private byte version_ = VERSION;\n\n  /**\n   * If we encounter a boolean field begin, save the TField here so it can have the value\n   * incorporated.\n   */\n  private TField booleanField_ = null;\n\n  /**\n   * If we read a field header, and it's a boolean field, save the boolean value here so that\n   * readBool can use it.\n   */\n  private Boolean boolValue_ = null;\n\n  /**\n   * The maximum number of bytes to read from the network for variable-length fields (such as\n   * strings or binary) or -1 for unlimited.\n   */\n  private final long maxNetworkBytes_;\n\n  /** Temporary buffer to avoid allocations */\n  private final byte[] buffer = new byte[10];\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   * @param maxNetworkBytes the maximum number of bytes to read for variable-length fields.\n   */\n  public TCompactProtocol(TTransport transport, long maxNetworkBytes) {\n    super(transport);\n    maxNetworkBytes_ = maxNetworkBytes;\n  }\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   */\n  public TCompactProtocol(TTransport transport) {\n    this(transport, -1);\n  }\n\n  public void reset() {\n    lastField_.clear();\n    lastFieldId_ = 0;\n  }\n\n  //\n  // Public Writing methods.\n  //\n\n  /**\n   * Write a message header to the wire. Compact Protocol messages contain the protocol version so\n   * we can migrate forwards in the future if need be.\n   */\n  public void writeMessageBegin(TMessage message) throws TException {\n    writeByteDirect(PROTOCOL_ID);\n    writeByteDirect((VERSION & VERSION_MASK) | ((message.type << TYPE_SHIFT_AMOUNT) & TYPE_MASK));\n    writeVarint32(message.seqid);\n    writeString(message.name);\n  }\n\n  /**\n   * Write a struct begin. This doesn't actually put anything on the wire. We use it as an\n   * opportunity to put special placeholder markers on the field stack so we can get the field id\n   * deltas correct.\n   */\n  public void writeStructBegin(TStruct struct) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n  }\n\n  /**\n   * Write a struct end. This doesn't actually put anything on the wire. We use this as an\n   * opportunity to pop the last field from the current struct off of the field stack.\n   */\n  public void writeStructEnd() throws TException {\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /**\n   * Write a field header containing the field id and field type. If the difference between the\n   * current field id and the last one is small (< 15), then the field id will be encoded in the 4\n   * MSB as a delta. Otherwise, the field id will follow the type header as a zigzag varint.\n   */\n  public void writeFieldBegin(TField field) throws TException {\n    if (field.type == TType.BOOL) {\n      // we want to possibly include the value, so we'll wait.\n      booleanField_ = field;\n    } else {\n      writeFieldBeginInternal(field, (byte) -1);\n    }\n  }\n\n  /**\n   * The workhorse of writeFieldBegin. It has the option of doing a 'type override' of the type\n   * header. This is used specifically in the boolean field case.\n   */\n  private void writeFieldBeginInternal(TField field, byte typeOverride) throws TException {\n    // short lastField = lastField_.pop();\n\n    // if there's a type override, use that.\n    byte typeToWrite = typeOverride == -1 ? getCompactType(field.type) : typeOverride;\n\n    // check if we can use delta encoding for the field id\n    if (field.id > lastFieldId_ && field.id - lastFieldId_ <= 15) {\n      // write them together\n      writeByteDirect((field.id - lastFieldId_) << 4 | typeToWrite);\n    } else {\n      // write them separate\n      writeByteDirect(typeToWrite);\n      writeI16(field.id);\n    }\n\n    lastFieldId_ = field.id;\n    // lastField_.push(field.id);\n  }\n\n  /** Write the STOP symbol so we know there are no more fields in this struct. */\n  public void writeFieldStop() throws TException {\n    writeByteDirect(TType.STOP);\n  }\n\n  /**\n   * Write a map header. If the map is empty, omit the key and value type headers, as we don't need\n   * any additional information to skip it.\n   */\n  public void writeMapBegin(TMap map) throws TException {\n    if (map.size == 0) {\n      writeByteDirect(0);\n    } else {\n      writeVarint32(map.size);\n      writeByteDirect(getCompactType(map.keyType) << 4 | getCompactType(map.valueType));\n    }\n  }\n\n  /** Write a list header. */\n  public void writeListBegin(TList list) throws TException {\n    writeCollectionBegin(list.elemType, list.size);\n  }\n\n  /** Write a set header. */\n  public void writeSetBegin(TSet set) throws TException {\n    writeCollectionBegin(set.elemType, set.size);\n  }\n\n  /**\n   * Write a boolean value. Potentially, this could be a boolean field, in which case the field\n   * header info isn't written yet. If so, decide what the right type header is for the value and\n   * then write the field header. Otherwise, write a single byte.\n   */\n  public void writeBool(boolean b) throws TException {\n    if (booleanField_ != null) {\n      // we haven't written the field header yet\n      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n      booleanField_ = null;\n    } else {\n      // we're not part of a field, so just write the value.\n      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n    }\n  }\n\n  /** Write a byte. Nothing to see here! */\n  public void writeByte(byte b) throws TException {\n    writeByteDirect(b);\n  }\n\n  /** Write an I16 as a zigzag varint. */\n  public void writeI16(short i16) throws TException {\n    writeVarint32(intToZigZag(i16));\n  }\n\n  /** Write an i32 as a zigzag varint. */\n  public void writeI32(int i32) throws TException {\n    writeVarint32(intToZigZag(i32));\n  }\n\n  /** Write an i64 as a zigzag varint. */\n  public void writeI64(long i64) throws TException {\n    writeVarint64(longToZigzag(i64));\n  }\n\n  /** Write a double to the wire as 8 bytes. */\n  public void writeDouble(double dub) throws TException {\n    fixedLongToBytes(Double.doubleToLongBits(dub), buffer, 0);\n    trans_.write(buffer, 0, 8);\n  }\n\n  /** Write a float to the wire as 4 bytes. */\n  public void writeFloat(float flt) throws TException {\n    fixedIntToBytes(Float.floatToIntBits(flt), buffer, 0);\n    trans_.write(buffer, 0, 4);\n  }\n\n  /** Write a string to the wire with a varint size preceding. */\n  public void writeString(String str) throws TException {\n    byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    writeBinary(bytes, 0, bytes.length);\n  }\n\n  /** Write a byte array, using a varint for the size. */\n  public void writeBinary(byte[] buf) throws TException {\n    writeBinary(buf, 0, buf.length);\n  }\n\n  private void writeBinary(byte[] buf, int offset, int length) throws TException {\n    writeVarint32(length);\n    trans_.write(buf, offset, length);\n  }\n\n  //\n  // These methods are called by structs, but don't actually have any wire\n  // output or purpose.\n  //\n\n  public void writeMessageEnd() throws TException {}\n\n  public void writeMapEnd() throws TException {}\n\n  public void writeListEnd() throws TException {}\n\n  public void writeSetEnd() throws TException {}\n\n  public void writeFieldEnd() throws TException {}\n\n  //\n  // Internal writing methods\n  //\n\n  /**\n   * Abstract method for writing the start of lists and sets. List and sets on the wire differ only\n   * by the type indicator.\n   */\n  protected void writeCollectionBegin(byte elemType, int size) throws TException {\n    if (size <= 14) {\n      writeByteDirect(size << 4 | getCompactType(elemType));\n    } else {\n      writeByteDirect(0xf0 | getCompactType(elemType));\n      writeVarint32(size);\n    }\n  }\n\n  /** Write an i32 as a varint. Results in 1-5 bytes on the wire. */\n  private void writeVarint32(int n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7F) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = (byte) ((n & 0x7F) | 0x80);\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /** Write an i64 as a varint. Results in 1-10 bytes on the wire. */\n  private void writeVarint64(long n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7FL) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = ((byte) ((n & 0x7F) | 0x80));\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /**\n   * Convert l into a zigzag long. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private long longToZigzag(long l) {\n    return (l << 1) ^ (l >> 63);\n  }\n\n  /**\n   * Convert n into a zigzag int. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private int intToZigZag(int n) {\n    return (n << 1) ^ (n >> 31);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedLongToBytes(long n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 56) & 0xff);\n    buf[off + 1] = (byte) ((n >> 48) & 0xff);\n    buf[off + 2] = (byte) ((n >> 40) & 0xff);\n    buf[off + 3] = (byte) ((n >> 32) & 0xff);\n    buf[off + 4] = (byte) ((n >> 24) & 0xff);\n    buf[off + 5] = (byte) ((n >> 16) & 0xff);\n    buf[off + 6] = (byte) ((n >> 8) & 0xff);\n    buf[off + 7] = (byte) (n & 0xff);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedIntToBytes(int n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 24) & 0xff);\n    buf[off + 1] = (byte) ((n >> 16) & 0xff);\n    buf[off + 2] = (byte) ((n >> 8) & 0xff);\n    buf[off + 3] = (byte) (n & 0xff);\n  }\n\n  /**\n   * Writes a byte without any possiblity of all that field header nonsense. Used internally by\n   * other writing methods that know they need to write a byte.\n   */\n  private void writeByteDirect(byte b) throws TException {\n    buffer[0] = b;\n    trans_.write(buffer, 0, 1);\n  }\n\n  /** Writes a byte without any possiblity of all that field header nonsense. */\n  private void writeByteDirect(int n) throws TException {\n    writeByteDirect((byte) n);\n  }\n\n  //\n  // Reading methods.\n  //\n\n  /** Read a message header. */\n  public TMessage readMessageBegin() throws TException {\n    byte protocolId = readByte();\n    if (protocolId != PROTOCOL_ID) {\n      throw new TProtocolException(\n          \"Expected protocol id \"\n              + Integer.toHexString(PROTOCOL_ID)\n              + \" but got \"\n              + Integer.toHexString(protocolId));\n    }\n    byte versionAndType = readByte();\n    version_ = (byte) (versionAndType & VERSION_MASK);\n    if (!(version_ <= VERSION && version_ >= VERSION_LOW)) {\n      throw new TProtocolException(\"Expected version \" + VERSION + \" but got \" + version_);\n    }\n    byte type = (byte) ((versionAndType >> TYPE_SHIFT_AMOUNT) & 0x03);\n    int seqid = readVarint32();\n    String messageName = readString();\n    return new TMessage(messageName, type, seqid);\n  }\n\n  /**\n   * Read a struct begin. There's nothing on the wire for this, but it is our opportunity to push a\n   * new struct begin marker onto the field stack.\n   */\n  public TStruct readStructBegin(\n      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n    return ANONYMOUS_STRUCT;\n  }\n\n  /**\n   * Doesn't actually consume any wire data, just removes the last field for this struct from the\n   * field stack.\n   */\n  public void readStructEnd() throws TException {\n    // consume the last field we read off the wire.\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /** Read a field header off the wire. */\n  public TField readFieldBegin() throws TException {\n    byte type = readByte();\n\n    // if it's a stop, then we can return immediately, as the struct is over.\n    if (type == TType.STOP) {\n      return TSTOP;\n    }\n\n    short fieldId;\n\n    // mask off the 4 MSB of the type header. it could contain a field id delta.\n    short modifier = (short) ((type & 0xf0) >> 4);\n    if (modifier == 0) {\n      // not a delta. look ahead for the zigzag varint field id.\n      fieldId = readI16();\n    } else {\n      // has a delta. add the delta to the last read field id.\n      fieldId = (short) (lastFieldId_ + modifier);\n    }\n\n    TField field = new TField(\"\", getTType((byte) (type & 0x0f)), fieldId);\n\n    // if this happens to be a boolean field, the value is encoded in the type\n    if (isBoolType(type)) {\n      // save the boolean value in a special instance variable.\n      boolValue_ = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    // push the new field onto the field stack so we can keep the deltas going.\n    lastFieldId_ = field.id;\n    return field;\n  }\n\n  /**\n   * Read a map header off the wire. If the size is zero, skip reading the key and value type. This\n   * means that 0-length maps will yield TMaps without the \"correct\" types.\n   */\n  public TMap readMapBegin() throws TException {\n    int size = readVarint32();\n    byte keyAndValueType = size == 0 ? 0 : readByte();\n    byte keyType = getTType((byte) (keyAndValueType >> 4));\n    byte valueType = getTType((byte) (keyAndValueType & 0xf));\n    if (size > 0) {\n      ensureMapHasEnough(size, keyType, valueType);\n    }\n    return new TMap(keyType, valueType, size);\n  }\n\n  /**\n   * Read a list header off the wire. If the list size is 0-14, the size will be packed into the\n   * element type header. If it's a longer list, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TList readListBegin() throws TException {\n    byte size_and_type = readByte();\n    int size = (size_and_type >> 4) & 0x0f;\n    if (size == 15) {\n      size = readVarint32();\n    }\n    byte type = getTType(size_and_type);\n    ensureContainerHasEnough(size, type);\n    return new TList(type, size);\n  }\n\n  /**\n   * Read a set header off the wire. If the set size is 0-14, the size will be packed into the\n   * element type header. If it's a longer set, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TSet readSetBegin() throws TException {\n    return new TSet(readListBegin());\n  }\n\n  /**\n   * Read a boolean off the wire. If this is a boolean field, the value should already have been\n   * read during readFieldBegin, so we'll just consume the pre-stored value. Otherwise, read a byte.\n   */\n  public boolean readBool() throws TException {\n    if (boolValue_ != null) {\n      boolean result = boolValue_.booleanValue();\n      boolValue_ = null;\n      return result;\n    }\n    return readByte() == Types.BOOLEAN_TRUE;\n  }\n\n  /** Read a single byte off the wire. Nothing interesting here. */\n  public byte readByte() throws TException {\n    byte b;\n    if (trans_.getBytesRemainingInBuffer() > 0) {\n      b = trans_.getBuffer()[trans_.getBufferPosition()];\n      trans_.consumeBuffer(1);\n    } else {\n      trans_.readAll(buffer, 0, 1);\n      b = buffer[0];\n    }\n    return b;\n  }\n\n  /** Read an i16 from the wire as a zigzag varint. */\n  public short readI16() throws TException {\n    return (short) zigzagToInt(readVarint32());\n  }\n\n  /** Read an i32 from the wire as a zigzag varint. */\n  public int readI32() throws TException {\n    return zigzagToInt(readVarint32());\n  }\n\n  /** Read an i64 from the wire as a zigzag varint. */\n  public long readI64() throws TException {\n    return zigzagToLong(readVarint64());\n  }\n\n  /** No magic here - just read a double off the wire. */\n  public double readDouble() throws TException {\n    trans_.readAll(buffer, 0, 8);\n    long value;\n    if (version_ >= VERSION_DOUBLE_BE) {\n      value = bytesToLong(buffer);\n    } else {\n      value = bytesToLongLE(buffer);\n    }\n    return Double.longBitsToDouble(value);\n  }\n\n  /** No magic here - just read a float off the wire. */\n  public float readFloat() throws TException {\n    trans_.readAll(buffer, 0, 4);\n    int value = bytesToInt(buffer);\n    return Float.intBitsToFloat(value);\n  }\n\n  /** Reads a byte[] (via readBinary), and then UTF-8 decodes it. */\n  public String readString() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n\n    if (length == 0) {\n      return \"\";\n    }\n\n    if (trans_.getBytesRemainingInBuffer() >= length) {\n      String str =\n          new String(\n              trans_.getBuffer(), trans_.getBufferPosition(), length, StandardCharsets.UTF_8);\n      trans_.consumeBuffer(length);\n      return str;\n    } else {\n      return new String(readBinary(length), StandardCharsets.UTF_8);\n    }\n  }\n\n  /** Read a byte[] from the wire. */\n  public byte[] readBinary() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n    return readBinary(length);\n  }\n\n  private byte[] readBinary(int length) throws TException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    ensureContainerHasEnough(length, TType.BYTE);\n    byte[] buf = new byte[length];\n    trans_.readAll(buf, 0, length);\n    return buf;\n  }\n\n  private void checkReadLength(int length) throws TProtocolException {\n    if (length < 0) {\n      throw new TProtocolException(\"Negative length: \" + length);\n    }\n    if (maxNetworkBytes_ != -1 && length > maxNetworkBytes_) {\n      throw new TProtocolException(\"Length exceeded max allowed: \" + length);\n    }\n  }\n\n  //\n  // These methods are here for the struct to call, but don't have any wire\n  // encoding.\n  //\n  public void readMessageEnd() throws TException {}\n\n  public void readFieldEnd() throws TException {}\n\n  public void readMapEnd() throws TException {}\n\n  public void readListEnd() throws TException {}\n\n  public void readSetEnd() throws TException {}\n\n  //\n  // Internal reading methods\n  //\n\n  /**\n   * Read an i32 from the wire as a varint. The MSB of each byte is set if there is another byte to\n   * follow. This can read up to 5 bytes.\n   */\n  private int readVarint32() throws TException {\n    int result = 0;\n    int shift = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 5) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Read an i64 from the wire as a proper varint. The MSB of each byte is set if there is another\n   * byte to follow. This can read up to 10 bytes.\n   */\n  private long readVarint64() throws TException {\n    int shift = 0;\n    long result = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 10) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  //\n  // encoding helpers\n  //\n\n  /** Convert from zigzag int to int. */\n  private int zigzagToInt(int n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /** Convert from zigzag long to long. */\n  private long zigzagToLong(long n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /**\n   * Note that it's important that the mask bytes are long literals, otherwise they'll default to\n   * ints, and when you shift an int left 56 bits, you just get a messed up int.\n   */\n  private long bytesToLong(byte[] bytes) {\n    return ((bytes[0] & 0xffL) << 56)\n        | ((bytes[1] & 0xffL) << 48)\n        | ((bytes[2] & 0xffL) << 40)\n        | ((bytes[3] & 0xffL) << 32)\n        | ((bytes[4] & 0xffL) << 24)\n        | ((bytes[5] & 0xffL) << 16)\n        | ((bytes[6] & 0xffL) << 8)\n        | ((bytes[7] & 0xffL));\n  }\n\n  /* Little endian version of the above */\n  private long bytesToLongLE(byte[] bytes) {\n    return ((bytes[7] & 0xffL) << 56)\n        | ((bytes[6] & 0xffL) << 48)\n        | ((bytes[5] & 0xffL) << 40)\n        | ((bytes[4] & 0xffL) << 32)\n        | ((bytes[3] & 0xffL) << 24)\n        | ((bytes[2] & 0xffL) << 16)\n        | ((bytes[1] & 0xffL) << 8)\n        | ((bytes[0] & 0xffL));\n  }\n\n  private int bytesToInt(byte[] bytes) {\n    return ((bytes[0] & 0xff) << 24)\n        | ((bytes[1] & 0xff) << 16)\n        | ((bytes[2] & 0xff) << 8)\n        | ((bytes[3] & 0xff));\n  }\n\n  //\n  // type testing and converting\n  //\n\n  private boolean isBoolType(byte b) {\n    int lowerNibble = b & 0x0f;\n    return lowerNibble == Types.BOOLEAN_TRUE || lowerNibble == Types.BOOLEAN_FALSE;\n  }\n\n  /** Given a TCompactProtocol.Types constant, convert it to its corresponding TType value. */\n  private byte getTType(byte type) throws TProtocolException {\n    switch ((byte) (type & 0x0f)) {\n      case TType.STOP:\n        return TType.STOP;\n      case Types.BOOLEAN_FALSE:\n      case Types.BOOLEAN_TRUE:\n        return TType.BOOL;\n      case Types.BYTE:\n        return TType.BYTE;\n      case Types.I16:\n        return TType.I16;\n      case Types.I32:\n        return TType.I32;\n      case Types.I64:\n        return TType.I64;\n      case Types.DOUBLE:\n        return TType.DOUBLE;\n      case Types.FLOAT:\n        return TType.FLOAT;\n      case Types.BINARY:\n        return TType.STRING;\n      case Types.LIST:\n        return TType.LIST;\n      case Types.SET:\n        return TType.SET;\n      case Types.MAP:\n        return TType.MAP;\n      case Types.STRUCT:\n        return TType.STRUCT;\n      default:\n        throw new TProtocolException(\"don't know what type: \" + (byte) (type & 0x0f));\n    }\n  }\n\n  /** Given a TType value, find the appropriate TCompactProtocol.Types constant. */\n  private byte getCompactType(byte ttype) {\n    return ttypeToCompactType[ttype];\n  }\n\n  @Override\n  protected int typeMinimumSize(byte type) {\n    switch (type & 0x0f) {\n      case TType.BOOL:\n      case TType.BYTE:\n      case TType.I16: // because of variable length encoding\n      case TType.I32: // because of variable length encoding\n      case TType.I64: // because of variable length encoding\n        return 1;\n      case TType.FLOAT:\n        return 4;\n      case TType.DOUBLE:\n        return 8;\n      case TType.STRING:\n      case TType.STRUCT:\n      case TType.MAP:\n      case TType.SET:\n      case TType.LIST:\n      case TType.ENUM:\n        return 1;\n      default:\n        throw new TProtocolException(\n            TProtocolException.INVALID_DATA, \"Unexpected data type \" + (byte) (type & 0x0f));\n    }\n  }\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace java com.facebook.thrift.java.test\nnamespace java.swift com.facebook.thrift.javaswift.test\n\nstruct MySimpleStruct {\n  1: i64 id,\n  2: string name,\n}\n\nenum SmallEnum {\n  RED = 1,\n  BLUE = 2,\n  GREEN = 3,\n}\n\nenum BigEnum {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  FIVE = 5,\n  SIX = 6,\n  SEVEN = 7,\n  EIGHT = 8,\n  NINE = 9,\n  TEN = 10,\n  ELEVEN = 11,\n  TWELVE = 12,\n  THIRTEEN = 13,\n  FOURTEEN = 14,\n  FIFTEEN = 15,\n  SIXTEEN = 16,\n  SEVENTEEN = 17,\n  EIGHTEEN = 18,\n  NINETEEN = 19,\n  TWENTY = 20,\n}\n\nstruct MyListStruct {\n  1: list<i64> ids\n}\n\nstruct MySetStruct {\n  1: set<i64> ids\n}\n\nstruct MyMapStruct {\n  1: map<i64, string> mapping\n}\n\nstruct MyStringStruct {\n  1: string aLongString\n}\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift;\n\nimport com.facebook.thrift.java.test.MyListStruct;\nimport com.facebook.thrift.java.test.MyMapStruct;\nimport com.facebook.thrift.java.test.MySetStruct;\nimport com.facebook.thrift.java.test.MyStringStruct;\nimport com.facebook.thrift.protocol.TBinaryProtocol;\nimport com.facebook.thrift.protocol.TCompactProtocol;\nimport com.facebook.thrift.protocol.TProtocol;\nimport com.facebook.thrift.protocol.TProtocolException;\nimport com.facebook.thrift.protocol.TType;\nimport com.facebook.thrift.transport.TMemoryInputTransport;\nimport org.junit.Test;\n\npublic class TruncatedFrameTest extends junit.framework.TestCase {\n  private static final byte[] kBinaryListEncoding = {\n    TType.LIST, // Field Type = List\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // List type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // List length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x03, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11100110, // list size (0111) and 7>3 + list type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding2 = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11110110, // list size magic marker (1111) + list type (0110) = i64\n    (byte) 0x64, // list actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  public static void testTruncated(TBase struct, TProtocol iprot) throws Exception {\n    try {\n      struct.read(iprot);\n      assertTrue(\"Not reachable\", false);\n    } catch (TProtocolException ex) {\n      assertEquals(\n          \"Not enough bytes to read the entire message, the data appears to be truncated\",\n          ex.getMessage());\n    }\n  }\n\n  @Test\n  public static void testListBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryListEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  private static final byte[] kBinarySetEncoding = {\n    TType.SET, // Field Type = Set\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // Set type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // Set length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x03, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b01110110, // set size (0111) and 7>3 + set type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding2 = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b11110110, // set size magic marker (1111) + set type (0110) = i64\n    (byte) 0x64, // set actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testSetBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinarySetEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  private static final byte[] kBinaryMapEncoding = {\n    TType.MAP, // field type = Map\n    (byte) 0x00,\n    (byte) 0x01, // field id = 1\n    TType.I64, // key type = i64\n    TType.STRING, // value type = string\n    (byte) 0x00,\n    (byte) 0xFF,\n    (byte) 0xFF,\n    (byte) 0xFF, // size = 0x00FFFFFF\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00, // key = 0\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x30, // string value = \"0\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // key = 1\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x31, // string value = \"1\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // key = 2\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x32, // string value = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactMapEncoding = {\n    (byte) 0b00011011, // field id delta (0001) + type (1011) = Map\n    (byte) 0x64, // map size (varint = 100)\n    (byte) 0b01101000, // key type (0110) i64, value type (1000) string\n    (byte) 0x00, // key value = 0\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x30, // string content = \"0\"\n    (byte) 0x02, // key value = 1 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x31, // string content = \"1\"\n    (byte) 0x04, // key value = 2 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x32, // string content = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testMapBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryMapEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  @Test\n  public static void testMapCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactMapEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  private static final byte[] kBinaryStringEncoding = {\n    TType.STRING, // Field Type = string\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // string length (255!)\n    (byte) 0x48,\n    (byte) 0x65,\n    (byte) 0x6C,\n    (byte) 0x6C,\n    (byte) 0x6F,\n    (byte) 0x2C,\n    (byte) 0x20,\n    (byte) 0x57,\n    (byte) 0x6F,\n    (byte) 0x72,\n    (byte) 0x6C,\n    (byte) 0x64,\n    (byte) 0x21, // string chars: \"Hello, World!\"\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactStringEncoding = {\n    (byte) 0b00011000, // field id delta (0001) + type (1000) = Binary\n    (byte) 0xFF,\n    (byte) 0x0F, // string size (varint) = 0x0FFF (4095)\n    (byte) 0x48,\n    (byte) 0x65,\n    (byte) 0x6C,\n    (byte) 0x6C,\n    (byte) 0x6F,\n    (byte) 0x2C,\n    (byte) 0x20,\n    (byte) 0x57,\n    (byte) 0x6F,\n    (byte) 0x72,\n    (byte) 0x6C,\n    (byte) 0x64,\n    (byte) 0x21, // string chars: \"Hello, World!\"\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public void testStringBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryStringEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyStringStruct(), iprot);\n  }\n\n  @Test\n  public void testStringCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactStringEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyStringStruct(), iprot);\n  }\n}\n"], "filenames": ["thrift/lib/java/src/main/java/com/facebook/thrift/protocol/TBinaryProtocol.java", "thrift/lib/java/src/main/java/com/facebook/thrift/protocol/TCompactProtocol.java", "thrift/lib/java/src/resources/testing_data_structures.thrift", "thrift/lib/java/src/test/java/com/facebook/thrift/TruncatedFrameTest.java"], "buggy_code_start_loc": [345, 640, 64, 21], "buggy_code_end_loc": [353, 640, 64, 287], "fixing_code_start_loc": [346, 641, 65, 22], "fixing_code_end_loc": [356, 642, 69, 333], "type": "CWE-770", "message": "Java Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.12.09.00.", "other": {"cve": {"id": "CVE-2019-11938", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-03-10T21:15:11.653", "lastModified": "2020-03-11T16:21:00.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Java Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.12.09.00."}, {"lang": "es", "value": "Los servidores de Java Facebook Thrift no se equivocar\u00edan tras recibir mensajes que declaran contenedores de tama\u00f1os m\u00e1s grandes que la carga \u00fatil. Como resultado, los clientes maliciosos podr\u00edan enviar mensajes cortos que resultar\u00edan en una asignaci\u00f3n de memoria considerable, conllevando potencialmente a una denegaci\u00f3n de servicio. Este problema afecta a Facebook Thrift versiones anteriores a v2019.12.09.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.12.09.00", "matchCriteriaId": "19706D04-00B1-4ADF-81FF-09F5C7F2875B"}]}]}], "references": [{"url": "https://github.com/facebook/fbthrift/commit/08c2d412adb214c40bb03be7587057b25d053030", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebook/fbthrift/commit/71c97ffdcb61cccf1f8267774e873e21ebd3ebd3", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11938", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/08c2d412adb214c40bb03be7587057b25d053030"}}