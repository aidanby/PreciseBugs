{"buggy_code": ["# API\n\n> **Note:** You may also refer to the [TypeScript definitions](/src/index.d.ts).\n\n## Methods\n\n\n### tempura.esc(value)\nReturns: `string` or `typeof value`\n\n#### value\nType: `string` or `unknown`\n\nThe value to be HTML-escaped. The following special characters are escaped: `\"`, `&`, and `<`.\n\n> **Note:** Any non-`string` values are returned as is.\n\n\n### tempura.compile(input, options?)\nReturns: `Compiler`\n\nConvert a template into a `function` that can be executed.\n\nWhen called with the appropriate, template-specific arguments, the `Compiler` function will return a `string` or a `Promise<string>`, resulting in the desired template output.\n\n```js\nlet render = tempura.compile(`\n  {{#expect age}}\n  {{#if age < 100}}\n    You're not 100+ yet\n  {{#else}}\n    What's the secret?\n  {{/if}}\n`);\n\nconsole.log(typeof render);\n//=> \"function\"\n\nrender({ age: 31 });\n//=> \"You're not 100+ yet\"\n\nrender({ age: 102 });\n//=> \"What's the secret?\"\n```\n\n\n#### input\nType: `string`\n\nThe template to be converted.\n\n#### options\n\nAll common [Options](#options-2) are supported, in addition to:\n\n#### options.escape\nType: `(value: any) => string`\nDefault: `typeof tempura.esc`\n\nThe escape function to use for `{{{ raw }}}` values.\n\nWhen unspecified, [`tempura.esc`](#tempuraescvalue) is used by default;\n\n\n### tempura.transform(input, options?)\nReturns: `string`\n\nTransforms the `input` source template into a string-representation of the equivalent JavaScript function.\n\nUnlike [`tempura.compile`](#tempuracompileinput-options), this generates a `string` instead of a `function`, which makes this method suitable for bundler transformations and/or replacing code at build-time.\n\n```js\nlet template = `\n  {{#expect age}}\n  {{#if age < 100}}\n    You're not 100+ yet\n  {{#else}}\n    What's the secret?\n  {{/if}}\n`;\n\n// produces ESM format by default\nlet esm = tempura.transform(template);\nconsole.log(typeof esm); //=> \"string\"\nconsole.log(esm);\n//=> 'import{esc as $$1}from\"tempura\";export default function($$3,$$2){var{age}=$$3,x=``;x+=``;if(age < 100){x+=`You\\'re not 100+ yet\"`;}else{x+=`What\\'s the secret?`;}return x}'\n```\n\n#### input\nType: `string`\n\nThe template to be converted.\n\n#### options\n\nAll common [Options](#options-2) are supported, in addition to:\n\n#### options.format\nType: `\"esm\"` or `\"cjs\"`<br>\nDefault: `\"esm\"`\n\nModify the generated output to be compliant with the CommonJS or ES Module format.\n\n> **Note:** Most bundlers and/or upstream consumers can understand (and prefer) the ESM format.\n\n\n## Options\n\n### options.async\nType: `boolean`<br>\nDefault: `false`\n\nWhen true, `tempura.compile` produces an `AsyncFunction` and `tempura.compile` generates an `async` function. Also will include the `await` keyword when a [Custom Block](/docs/blocks.md) is invoked.\n\n\n### options.props\nType: `string[]`\n\nThe _names_ of variables that will be provided to a view.\n\nDeclaring `props` names means that they don't have to appear within any `{{#expect ...}}` declarations \u2013 and vice versa. In other words, `options.props` is a programmatic way to define (or skip) `{{#expect}}` blocks.\n\nIt is recommended that you include global and/or shared variables within `options.props`, which saves you the trouble of writing the same `{{#expect foo, bar}}` statements over and over. This way, each template can `{{#expect}}` any variables that are unique to it.\n\n> **Note:** Variable names are deduped. For example, defining `{{#expect foo}}` _and_ `options.props: ['foo']` will not have any adverse/duplicative effects.\n\n\n### options.loose\nType: `boolean`<br>\nDefault: `false`\n\nBy default, any template variables must be known ahead of time \u2013 either through [`options.props`](/docs/api.md#optionsprops) or through [`#expect`](/docs/syntax.md#expect) declarations. However, when enabled, `options.loose` relaxes this constraint.\n\n> **Note:** Enabling `options.loose` makes for a more Handlebars-like experience.\n\nWith this option activated, removing the `#expect` declaration from the example below will produce the same output:\n\n```diff\n--{{#expect name}}\n<p>Hello, {{ name }}!</p>\n```\n\n\n### options.blocks\nType: `Record<string, Compiler>`\n\nAny [custom directives](/docs/blocks.md) that should be made available within the template.\n\n> **Important:** An error will be thrown while parsing if a custom directive was found but not defined.\n\nAll key names are converted into the directive names. Keys must start with a `A-Z`, `a-z`, or `_` and may include any number of `A-Z`, `a-z`, `_`, or `0-9` characters.\n\nFor example, in order to define and use the `{{#foo}}` and `{{#hello123}}` directives within a template, an `options.blocks` object with `foo` and `hello123` keys must be defined:\n\n```js\n/**\n * @type {tempura.Options}\n */\nlet options = {\n  async: true,\n  blocks: {\n    foo(args) {\n      return `<span>foo got ~${args.value}~</span>`;\n    },\n    async hello123(args) {\n      return `<h1>hello123 got ~${args.name}~</h1>`;\n    }\n  }\n};\n\nlet template = `\n  {{#foo value=123 }}\n  {{#hello123 name=\"world\" }}\n`;\n\n// NOTE: Works with `transform` too\nawait tempura.compile(template, options)();\n//=> \"<span>foo got ~123~</span><h1>hello123 got ~world~</h1>\"\n```\n", "const ESCAPE = /[&\"<]/g, CHARS = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt',\n};\n\nimport { gen } from './$utils';\n\nexport function esc(value) {\n\tif (typeof value !== 'string') return value;\n\tlet last=ESCAPE.lastIndex=0, tmp=0, out='';\n\twhile (ESCAPE.test(value)) {\n\t\ttmp = ESCAPE.lastIndex - 1;\n\t\tout += value.substring(last, tmp) + CHARS[value[tmp]];\n\t\tlast = tmp + 1;\n\t}\n\treturn out + value.substring(last);\n}\n\nexport function compile(input, options={}) {\n\treturn new (options.async ? (async()=>{}).constructor : Function)(\n\t\t'$$1', '$$2', '$$3', gen(input, options)\n\t).bind(0, options.escape || esc, options.blocks);\n}\n\nexport function transform(input, options={}) {\n\treturn (\n\t\toptions.format === 'cjs'\n\t\t? 'var $$1=require(\"tempura\").esc;module.exports='\n\t\t: 'import{esc as $$1}from\"tempura\";export default '\n\t) + (\n\t\toptions.async ? 'async ' : ''\n\t) + 'function($$3,$$2){'+gen(input, options)+'}';\n}\n", "export type Args = Record<string, any>;\nexport type Blocks = Record<string, Compiler<any>>;\n\nexport type Compiler<T extends Args = Args> =\n\t| ((data: T, blocks?: Blocks) => Promise<string>|string)\n\t| ((data?: T) => Promise<string>|string)\n\nexport interface Options {\n\tloose?: boolean;\n\tprops?: string[];\n\tblocks?: Blocks;\n\tasync?: boolean;\n}\n\nexport function esc<T=unknown>(value: T): T|string;\nexport function transform(input: string, options?: Options & { format?: 'esm' | 'cjs' }): string;\n\ntype CompileOptions = Options & { escape?: typeof esc };\nexport function compile(input: string, options?: CompileOptions & { async: true }): <T extends Args> (data?: T, blocks?: Blocks) => Promise<string>;\nexport function compile(input: string, options?: CompileOptions & { async?: false }): <T extends Args> (data?: T, blocks?: Blocks) => string;\nexport function compile(input: string, options?: CompileOptions): Compiler;\n", "import { suite } from 'uvu';\nimport * as assert from 'uvu/assert';\nimport * as tempura from '../src/$index';\n\n// ---\n\nconst transform = suite('transform');\n\ntransform('should be a function', () => {\n\tassert.type(tempura.transform, 'function');\n});\n\ntransform('should return a string', () => {\n\tlet output = tempura.transform('');\n\tassert.type(output, 'string');\n});\n\ntransform('should include \"esc\" import via \"tempura\" module', () => {\n\tlet output = tempura.transform('');\n\tassert.match(output, /\\{esc(\\:| as )/);\n\tassert.match(output, '\"tempura\"');\n});\n\ntransform('format :: ESM (default)', () => {\n\tlet output = tempura.transform('');\n\tassert.match(output, 'import{esc as $$1}from\"tempura\";');\n\tassert.match(output, ';export default function($$3,$$2){');\n\tassert.ok(output.endsWith('}'), 'close function');\n});\n\ntransform('format :: ESM :: async', () => {\n\tlet output = tempura.transform('', { async: true });\n\tassert.match(output, ';export default async function($$3,$$2){');\n});\n\ntransform('format :: CommonJS', () => {\n\tlet output = tempura.transform('', { format: 'cjs' });\n\tassert.match(output, 'var $$1=require(\"tempura\").esc;');\n\tassert.match(output, ';module.exports=function($$3,$$2){');\n\tassert.ok(output.endsWith('}'), 'close function');\n});\n\ntransform('format :: CommonJS :: async', () => {\n\tlet output = tempura.transform('', { format: 'cjs', async: true });\n\tassert.match(output, ';module.exports=async function($$3,$$2){');\n});\n\ntransform('should bubble parsing errors', () => {\n\ttry {\n\t\ttempura.transform('{{#if foo}}stop');\n\t\tassert.unreachable('should have thrown');\n\t} catch (err) {\n\t\tassert.instance(err, Error);\n\t\tassert.is(err.message, 'Unterminated \"if\" block');\n\t}\n});\n\ntransform.run();\n\n// ---\n\nconst compile = suite('compile');\n\ncompile('should be a function', () => {\n\tassert.type(tempura.compile, 'function');\n});\n\ncompile('should return a function', () => {\n\tlet output = tempura.compile('');\n\tassert.type(output, 'function');\n});\n\ncompile('should produce valid output :: raw', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\t{{#if value.length > 10}}\n\t\t\t\"{{{ value }}}\" is more than 10 characters\n\t\t{{#else}}\n\t\t\t\"{{{ value }}}\" is too short\n\t\t{{/if}}\n\t`);\n\n\tassert.is(\n\t\toutput({ value: '<b>howdy</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"<b>howdy</b>\" is more than 10 characters'\n\t);\n\n\tassert.is(\n\t\toutput({ value: '<b>aaa</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"<b>aaa</b>\" is too short'\n\t);\n});\n\ncompile('should produce valid output :: escape', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\t{{#if value.length > 10}}\n\t\t\t\"{{ value }}\" is more than 10 characters\n\t\t{{#else}}\n\t\t\t\"{{ value }}\" is too short\n\t\t{{/if}}\n\t`);\n\n\tassert.is(\n\t\toutput({ value: '<b>howdy</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"&ltb>howdy&lt/b>\" is more than 10 characters'\n\t);\n\n\tassert.is(\n\t\toutput({ value: '<b>aaa</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"&ltb>aaa&lt/b>\" is too short'\n\t);\n});\n\ncompile('should allow custom `escape` option :: {{value}}', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\tvalue is \"{{ value }}\"\n\t`, {\n\t\tescape(val) {\n\t\t\treturn val.replace('foo', 'bar');\n\t\t}\n\t});\n\n\tassert.is(\n\t\toutput({ value: 'foobar' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'value is \"barbar\"'\n\t);\n});\n\ncompile('should allow custom `escape` option :: {{{ value }}}', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\tvalue is \"{{{ value }}}\"\n\t`, {\n\t\tescape(val) {\n\t\t\treturn val.replace('foo', 'bar');\n\t\t}\n\t});\n\n\tassert.is(\n\t\toutput({ value: 'foobar' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'value is \"foobar\"'\n\t);\n});\n\ncompile('should bubble parsing errors', () => {\n\ttry {\n\t\ttempura.compile('{{#if foo}}stop');\n\t\tassert.unreachable('should have thrown');\n\t} catch (err) {\n\t\tassert.instance(err, Error);\n\t\tassert.is(err.message, 'Unterminated \"if\" block');\n\t}\n});\n\ncompile('should create `async` function', async () => {\n\tlet delta;\n\tlet sleep = ms => new Promise(r => setTimeout(r, ms));\n\tlet normalize = x => x.replace(/[\\r\\n\\t]+/g, '');\n\n\tasync function delay({ wait }) {\n\t\tlet x = Date.now();\n\n\t\tawait sleep(wait);\n\t\tdelta = Date.now() - x;\n\t\treturn `~> waited ${wait}ms!`;\n\t}\n\n\tlet render = tempura.compile(`\n\t\t{{#expect ms}}\n\t\t{{#delay wait=ms }}\n\t`, {\n\t\tasync: true,\n\t\tblocks: { delay }\n\t});\n\n\tassert.instance(render, Function);\n\tassert.instance(render, delay.constructor);\n\n\tassert.is(\n\t\tObject.prototype.toString.call(render),\n\t\t'[object AsyncFunction]'\n\t);\n\n\tlet foo = await render({ ms: 100 });\n\tassert.is(normalize(foo), '~> waited 100ms!');\n\tassert.ok(delta > 99 && delta < 110);\n\n\tlet bar = await render({ ms: 30 });\n\tassert.is(normalize(bar), '~> waited 30ms!');\n\tassert.ok(delta > 29 && delta < 35);\n});\n\ncompile('should allow `blocks` to call other blocks', () => {\n\tlet blocks = {\n\t\thello(args, blocks) {\n\t\t\tlet output = `<h>\"${args.name}\"</h>`;\n\t\t\t// Always invoke the `foo` block\n\t\t\toutput += blocks.foo({ value: 123  });\n\t\t\t// Calls itself; recursive block\n\t\t\tif (args.other) output += blocks.hello({ name: args.other }, blocks);\n\t\t\treturn output;\n\t\t},\n\t\tfoo(args) {\n\t\t\treturn `<foo>${args.value}</foo>`;\n\t\t}\n\t};\n\n\tlet render = tempura.compile('{{#hello name=\"world\" other=\"there\"}}', { blocks });\n\n\tassert.is(\n\t\trender(),\n\t\t`<h>\"world\"</h><foo>123</foo><h>\"there\"</h><foo>123</foo>`\n\t);\n});\n\ncompile('should allow `Compiler` output as blocks', () => {\n\tlet blocks = {\n\t\t// initialize foo\n\t\t// ~> does NOT use custom blocks\n\t\tfoo: tempura.compile(`\n\t\t\t{{#expect age}}\n\t\t\t{{#if age > 100}}\n\t\t\t\t<p>centurion</p>\n\t\t\t{{#else}}\n\t\t\t\t<p>youngin</p>\n\t\t\t{{/if}}\n\t\t`),\n\n\t\t// initial hello\n\t\t// ~> placeholder; because self-references\n\t\thello: null,\n\t};\n\n\tblocks.hello = tempura.compile(`\n\t\t{{#expect name, other}}\n\n\t\t<h>\"{{ name }}\"</h>\n\t\t{{#foo age=123}}\n\n\t\t{{#if other}}\n\t\t\t{{#hello name=other}}\n\t\t{{/if}}\n\t`,  { blocks });\n\n\tlet normalize = x => x.replace(/[\\r\\n\\t]+/g, '');\n\tlet render = tempura.compile('{{#hello name=\"world\" other=\"there\"}}', { blocks });\n\n\tassert.is(\n\t\tnormalize(render()),\n\t\t`<h>\"world\"</h><p>centurion</p><h>\"there\"</h><p>centurion</p>`\n\t);\n});\n\ncompile.run();\n\n// ---\n\nconst esc = suite('esc');\n\nesc('should be a function', () => {\n\tassert.type(tempura.esc, 'function');\n});\n\nesc('should echo non-string inputs', () => {\n\t// @ts-ignore\n\tassert.is(tempura.esc(), undefined);\n\tassert.is(tempura.esc(null), null);\n\tassert.is(tempura.esc(false), false);\n\tassert.is(tempura.esc(123), 123);\n\tassert.is(tempura.esc(0), 0);\n\n\tassert.equal(tempura.esc([1, 2, 3]), [1, 2, 3]);\n\tassert.equal(tempura.esc({ foo: 1 }), { foo: 1 });\n});\n\nesc('should return string from string input', () => {\n\tassert.type(tempura.esc(''), 'string');\n\tassert.type(tempura.esc('foobar'), 'string');\n});\n\nesc('should escape `<` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: <'),\n\t\t'here: &lt'\n\t);\n});\n\nesc('should escape `\"` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: \"'),\n\t\t'here: &quot;'\n\t);\n});\n\nesc('should escape `&` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: &'),\n\t\t'here: &amp;'\n\t);\n});\n\nesc('should escape all target characters in a string', () => {\n\tassert.is(\n\t\ttempura.esc('&&& <<< \"\"\"'),\n\t\t'&amp;&amp;&amp; &lt&lt&lt &quot;&quot;&quot;'\n\t);\n});\n\nesc('should reset state on same input string', () => {\n\tlet input = '<foo>\"hello\"</foo>';\n\n\tassert.is(\n\t\ttempura.esc(input),\n\t\t'&ltfoo>&quot;hello&quot;&lt/foo>'\n\t);\n\n\tassert.is(\n\t\ttempura.esc(input),\n\t\t'&ltfoo>&quot;hello&quot;&lt/foo>',\n\t\t'~> repeat'\n\t);\n});\n\nesc.run();\n"], "fixing_code": ["# API\n\n> **Note:** You may also refer to the [TypeScript definitions](/src/index.d.ts).\n\n## Methods\n\n\n### tempura.esc(value)\nReturns: `string`\n\n#### value\nType: `string` or `unknown`\n\nThe value to be HTML-escaped. The following special characters are escaped: `\"`, `&`, and `<`.\n\n> **Note:** Any non-`string` values are coerced to a strings!\n>  * `null` and `undefined` become `\"\"`\n>  * `{ foo: 123 }` becomes `\"[object Object]\"`\n>  * `[1, 2, 3]` becomes `\"1,2,3\"`\n>  * `123` becomes `\"123\"`\n\n\n### tempura.compile(input, options?)\nReturns: `Compiler`\n\nConvert a template into a `function` that can be executed.\n\nWhen called with the appropriate, template-specific arguments, the `Compiler` function will return a `string` or a `Promise<string>`, resulting in the desired template output.\n\n```js\nlet render = tempura.compile(`\n  {{#expect age}}\n  {{#if age < 100}}\n    You're not 100+ yet\n  {{#else}}\n    What's the secret?\n  {{/if}}\n`);\n\nconsole.log(typeof render);\n//=> \"function\"\n\nrender({ age: 31 });\n//=> \"You're not 100+ yet\"\n\nrender({ age: 102 });\n//=> \"What's the secret?\"\n```\n\n\n#### input\nType: `string`\n\nThe template to be converted.\n\n#### options\n\nAll common [Options](#options-2) are supported, in addition to:\n\n#### options.escape\nType: `(value: any) => string`\nDefault: `typeof tempura.esc`\n\nThe escape function to use for `{{{ raw }}}` values.\n\nWhen unspecified, [`tempura.esc`](#tempuraescvalue) is used by default;\n\n\n### tempura.transform(input, options?)\nReturns: `string`\n\nTransforms the `input` source template into a string-representation of the equivalent JavaScript function.\n\nUnlike [`tempura.compile`](#tempuracompileinput-options), this generates a `string` instead of a `function`, which makes this method suitable for bundler transformations and/or replacing code at build-time.\n\n```js\nlet template = `\n  {{#expect age}}\n  {{#if age < 100}}\n    You're not 100+ yet\n  {{#else}}\n    What's the secret?\n  {{/if}}\n`;\n\n// produces ESM format by default\nlet esm = tempura.transform(template);\nconsole.log(typeof esm); //=> \"string\"\nconsole.log(esm);\n//=> 'import{esc as $$1}from\"tempura\";export default function($$3,$$2){var{age}=$$3,x=``;x+=``;if(age < 100){x+=`You\\'re not 100+ yet\"`;}else{x+=`What\\'s the secret?`;}return x}'\n```\n\n#### input\nType: `string`\n\nThe template to be converted.\n\n#### options\n\nAll common [Options](#options-2) are supported, in addition to:\n\n#### options.format\nType: `\"esm\"` or `\"cjs\"`<br>\nDefault: `\"esm\"`\n\nModify the generated output to be compliant with the CommonJS or ES Module format.\n\n> **Note:** Most bundlers and/or upstream consumers can understand (and prefer) the ESM format.\n\n\n## Options\n\n### options.async\nType: `boolean`<br>\nDefault: `false`\n\nWhen true, `tempura.compile` produces an `AsyncFunction` and `tempura.compile` generates an `async` function. Also will include the `await` keyword when a [Custom Block](/docs/blocks.md) is invoked.\n\n\n### options.props\nType: `string[]`\n\nThe _names_ of variables that will be provided to a view.\n\nDeclaring `props` names means that they don't have to appear within any `{{#expect ...}}` declarations \u2013 and vice versa. In other words, `options.props` is a programmatic way to define (or skip) `{{#expect}}` blocks.\n\nIt is recommended that you include global and/or shared variables within `options.props`, which saves you the trouble of writing the same `{{#expect foo, bar}}` statements over and over. This way, each template can `{{#expect}}` any variables that are unique to it.\n\n> **Note:** Variable names are deduped. For example, defining `{{#expect foo}}` _and_ `options.props: ['foo']` will not have any adverse/duplicative effects.\n\n\n### options.loose\nType: `boolean`<br>\nDefault: `false`\n\nBy default, any template variables must be known ahead of time \u2013 either through [`options.props`](/docs/api.md#optionsprops) or through [`#expect`](/docs/syntax.md#expect) declarations. However, when enabled, `options.loose` relaxes this constraint.\n\n> **Note:** Enabling `options.loose` makes for a more Handlebars-like experience.\n\nWith this option activated, removing the `#expect` declaration from the example below will produce the same output:\n\n```diff\n--{{#expect name}}\n<p>Hello, {{ name }}!</p>\n```\n\n\n### options.blocks\nType: `Record<string, Compiler>`\n\nAny [custom directives](/docs/blocks.md) that should be made available within the template.\n\n> **Important:** An error will be thrown while parsing if a custom directive was found but not defined.\n\nAll key names are converted into the directive names. Keys must start with a `A-Z`, `a-z`, or `_` and may include any number of `A-Z`, `a-z`, `_`, or `0-9` characters.\n\nFor example, in order to define and use the `{{#foo}}` and `{{#hello123}}` directives within a template, an `options.blocks` object with `foo` and `hello123` keys must be defined:\n\n```js\n/**\n * @type {tempura.Options}\n */\nlet options = {\n  async: true,\n  blocks: {\n    foo(args) {\n      return `<span>foo got ~${args.value}~</span>`;\n    },\n    async hello123(args) {\n      return `<h1>hello123 got ~${args.name}~</h1>`;\n    }\n  }\n};\n\nlet template = `\n  {{#foo value=123 }}\n  {{#hello123 name=\"world\" }}\n`;\n\n// NOTE: Works with `transform` too\nawait tempura.compile(template, options)();\n//=> \"<span>foo got ~123~</span><h1>hello123 got ~world~</h1>\"\n```\n", "const ESCAPE = /[&\"<]/g, CHARS = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt',\n};\n\nimport { gen } from './$utils';\n\nexport function esc(value) {\n\tvalue = (value == null) ? '' : '' + value;\n\tlet last=ESCAPE.lastIndex=0, tmp=0, out='';\n\twhile (ESCAPE.test(value)) {\n\t\ttmp = ESCAPE.lastIndex - 1;\n\t\tout += value.substring(last, tmp) + CHARS[value[tmp]];\n\t\tlast = tmp + 1;\n\t}\n\treturn out + value.substring(last);\n}\n\nexport function compile(input, options={}) {\n\treturn new (options.async ? (async()=>{}).constructor : Function)(\n\t\t'$$1', '$$2', '$$3', gen(input, options)\n\t).bind(0, options.escape || esc, options.blocks);\n}\n\nexport function transform(input, options={}) {\n\treturn (\n\t\toptions.format === 'cjs'\n\t\t? 'var $$1=require(\"tempura\").esc;module.exports='\n\t\t: 'import{esc as $$1}from\"tempura\";export default '\n\t) + (\n\t\toptions.async ? 'async ' : ''\n\t) + 'function($$3,$$2){'+gen(input, options)+'}';\n}\n", "export type Args = Record<string, any>;\nexport type Blocks = Record<string, Compiler<any>>;\n\nexport type Compiler<T extends Args = Args> =\n\t| ((data: T, blocks?: Blocks) => Promise<string>|string)\n\t| ((data?: T) => Promise<string>|string)\n\nexport interface Options {\n\tloose?: boolean;\n\tprops?: string[];\n\tblocks?: Blocks;\n\tasync?: boolean;\n}\n\nexport function esc(value: string|unknown): string;\nexport function transform(input: string, options?: Options & { format?: 'esm' | 'cjs' }): string;\n\ntype CompileOptions = Options & { escape?: typeof esc };\nexport function compile(input: string, options?: CompileOptions & { async: true }): <T extends Args> (data?: T, blocks?: Blocks) => Promise<string>;\nexport function compile(input: string, options?: CompileOptions & { async?: false }): <T extends Args> (data?: T, blocks?: Blocks) => string;\nexport function compile(input: string, options?: CompileOptions): Compiler;\n", "import { suite } from 'uvu';\nimport * as assert from 'uvu/assert';\nimport * as tempura from '../src/$index';\n\n// ---\n\nconst transform = suite('transform');\n\ntransform('should be a function', () => {\n\tassert.type(tempura.transform, 'function');\n});\n\ntransform('should return a string', () => {\n\tlet output = tempura.transform('');\n\tassert.type(output, 'string');\n});\n\ntransform('should include \"esc\" import via \"tempura\" module', () => {\n\tlet output = tempura.transform('');\n\tassert.match(output, /\\{esc(\\:| as )/);\n\tassert.match(output, '\"tempura\"');\n});\n\ntransform('format :: ESM (default)', () => {\n\tlet output = tempura.transform('');\n\tassert.match(output, 'import{esc as $$1}from\"tempura\";');\n\tassert.match(output, ';export default function($$3,$$2){');\n\tassert.ok(output.endsWith('}'), 'close function');\n});\n\ntransform('format :: ESM :: async', () => {\n\tlet output = tempura.transform('', { async: true });\n\tassert.match(output, ';export default async function($$3,$$2){');\n});\n\ntransform('format :: CommonJS', () => {\n\tlet output = tempura.transform('', { format: 'cjs' });\n\tassert.match(output, 'var $$1=require(\"tempura\").esc;');\n\tassert.match(output, ';module.exports=function($$3,$$2){');\n\tassert.ok(output.endsWith('}'), 'close function');\n});\n\ntransform('format :: CommonJS :: async', () => {\n\tlet output = tempura.transform('', { format: 'cjs', async: true });\n\tassert.match(output, ';module.exports=async function($$3,$$2){');\n});\n\ntransform('should bubble parsing errors', () => {\n\ttry {\n\t\ttempura.transform('{{#if foo}}stop');\n\t\tassert.unreachable('should have thrown');\n\t} catch (err) {\n\t\tassert.instance(err, Error);\n\t\tassert.is(err.message, 'Unterminated \"if\" block');\n\t}\n});\n\ntransform.run();\n\n// ---\n\nconst compile = suite('compile');\n\ncompile('should be a function', () => {\n\tassert.type(tempura.compile, 'function');\n});\n\ncompile('should return a function', () => {\n\tlet output = tempura.compile('');\n\tassert.type(output, 'function');\n});\n\ncompile('should produce valid output :: raw', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\t{{#if value.length > 10}}\n\t\t\t\"{{{ value }}}\" is more than 10 characters\n\t\t{{#else}}\n\t\t\t\"{{{ value }}}\" is too short\n\t\t{{/if}}\n\t`);\n\n\tassert.is(\n\t\toutput({ value: '<b>howdy</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"<b>howdy</b>\" is more than 10 characters'\n\t);\n\n\tassert.is(\n\t\toutput({ value: '<b>aaa</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"<b>aaa</b>\" is too short'\n\t);\n});\n\ncompile('should produce valid output :: escape', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\t{{#if value.length > 10}}\n\t\t\t\"{{ value }}\" is more than 10 characters\n\t\t{{#else}}\n\t\t\t\"{{ value }}\" is too short\n\t\t{{/if}}\n\t`);\n\n\tassert.is(\n\t\toutput({ value: '<b>howdy</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"&ltb>howdy&lt/b>\" is more than 10 characters'\n\t);\n\n\tassert.is(\n\t\toutput({ value: '<b>aaa</b>' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'\"&ltb>aaa&lt/b>\" is too short'\n\t);\n});\n\ncompile('should allow custom `escape` option :: {{value}}', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\tvalue is \"{{ value }}\"\n\t`, {\n\t\tescape(val) {\n\t\t\treturn val.replace('foo', 'bar');\n\t\t}\n\t});\n\n\tassert.is(\n\t\toutput({ value: 'foobar' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'value is \"barbar\"'\n\t);\n});\n\ncompile('should allow custom `escape` option :: {{{ value }}}', () => {\n\tlet output = tempura.compile(`\n\t\t{{#expect value}}\n\t\tvalue is \"{{{ value }}}\"\n\t`, {\n\t\tescape(val) {\n\t\t\treturn val.replace('foo', 'bar');\n\t\t}\n\t});\n\n\tassert.is(\n\t\toutput({ value: 'foobar' }).replace(/[\\r\\n\\t]+/g, ''),\n\t\t'value is \"foobar\"'\n\t);\n});\n\ncompile('should bubble parsing errors', () => {\n\ttry {\n\t\ttempura.compile('{{#if foo}}stop');\n\t\tassert.unreachable('should have thrown');\n\t} catch (err) {\n\t\tassert.instance(err, Error);\n\t\tassert.is(err.message, 'Unterminated \"if\" block');\n\t}\n});\n\ncompile('should create `async` function', async () => {\n\tlet delta;\n\tlet sleep = ms => new Promise(r => setTimeout(r, ms));\n\tlet normalize = x => x.replace(/[\\r\\n\\t]+/g, '');\n\n\tasync function delay({ wait }) {\n\t\tlet x = Date.now();\n\n\t\tawait sleep(wait);\n\t\tdelta = Date.now() - x;\n\t\treturn `~> waited ${wait}ms!`;\n\t}\n\n\tlet render = tempura.compile(`\n\t\t{{#expect ms}}\n\t\t{{#delay wait=ms }}\n\t`, {\n\t\tasync: true,\n\t\tblocks: { delay }\n\t});\n\n\tassert.instance(render, Function);\n\tassert.instance(render, delay.constructor);\n\n\tassert.is(\n\t\tObject.prototype.toString.call(render),\n\t\t'[object AsyncFunction]'\n\t);\n\n\tlet foo = await render({ ms: 100 });\n\tassert.is(normalize(foo), '~> waited 100ms!');\n\tassert.ok(delta > 99 && delta < 110);\n\n\tlet bar = await render({ ms: 30 });\n\tassert.is(normalize(bar), '~> waited 30ms!');\n\tassert.ok(delta > 29 && delta < 35);\n});\n\ncompile('should allow `blocks` to call other blocks', () => {\n\tlet blocks = {\n\t\thello(args, blocks) {\n\t\t\tlet output = `<h>\"${args.name}\"</h>`;\n\t\t\t// Always invoke the `foo` block\n\t\t\toutput += blocks.foo({ value: 123  });\n\t\t\t// Calls itself; recursive block\n\t\t\tif (args.other) output += blocks.hello({ name: args.other }, blocks);\n\t\t\treturn output;\n\t\t},\n\t\tfoo(args) {\n\t\t\treturn `<foo>${args.value}</foo>`;\n\t\t}\n\t};\n\n\tlet render = tempura.compile('{{#hello name=\"world\" other=\"there\"}}', { blocks });\n\n\tassert.is(\n\t\trender(),\n\t\t`<h>\"world\"</h><foo>123</foo><h>\"there\"</h><foo>123</foo>`\n\t);\n});\n\ncompile('should allow `Compiler` output as blocks', () => {\n\tlet blocks = {\n\t\t// initialize foo\n\t\t// ~> does NOT use custom blocks\n\t\tfoo: tempura.compile(`\n\t\t\t{{#expect age}}\n\t\t\t{{#if age > 100}}\n\t\t\t\t<p>centurion</p>\n\t\t\t{{#else}}\n\t\t\t\t<p>youngin</p>\n\t\t\t{{/if}}\n\t\t`),\n\n\t\t// initial hello\n\t\t// ~> placeholder; because self-references\n\t\thello: null,\n\t};\n\n\tblocks.hello = tempura.compile(`\n\t\t{{#expect name, other}}\n\n\t\t<h>\"{{ name }}\"</h>\n\t\t{{#foo age=123}}\n\n\t\t{{#if other}}\n\t\t\t{{#hello name=other}}\n\t\t{{/if}}\n\t`,  { blocks });\n\n\tlet normalize = x => x.replace(/[\\r\\n\\t]+/g, '');\n\tlet render = tempura.compile('{{#hello name=\"world\" other=\"there\"}}', { blocks });\n\n\tassert.is(\n\t\tnormalize(render()),\n\t\t`<h>\"world\"</h><p>centurion</p><h>\"there\"</h><p>centurion</p>`\n\t);\n});\n\ncompile.run();\n\n// ---\n\nconst esc = suite('esc');\n\nesc('should be a function', () => {\n\tassert.type(tempura.esc, 'function');\n});\n\nesc('should convert non-string inputs to string', () => {\n\tassert.is(tempura.esc(), '');\n\tassert.is(tempura.esc(null), '');\n\n\tassert.is(tempura.esc(false), 'false');\n\tassert.is(tempura.esc(123), '123');\n\tassert.is(tempura.esc(0), '0');\n\n\tassert.equal(tempura.esc([1, 2, 3]), '1,2,3');\n\tassert.equal(tempura.esc({ foo: 1 }), '[object Object]');\n});\n\nesc('should prevent xss scripting in array', () => {\n\tlet output = tempura.esc(['<img src=x onerror=\"alert(1)\" />']);\n\tassert.is(output, '&ltimg src=x onerror=&quot;alert(1)&quot; />');\n});\n\nesc('should return string from string input', () => {\n\tassert.type(tempura.esc(''), 'string');\n\tassert.type(tempura.esc('foobar'), 'string');\n});\n\nesc('should escape `<` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: <'),\n\t\t'here: &lt'\n\t);\n});\n\nesc('should escape `\"` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: \"'),\n\t\t'here: &quot;'\n\t);\n});\n\nesc('should escape `&` character', () => {\n\tassert.is(\n\t\ttempura.esc('here: &'),\n\t\t'here: &amp;'\n\t);\n});\n\nesc('should escape all target characters in a string', () => {\n\tassert.is(\n\t\ttempura.esc('&&& <<< \"\"\"'),\n\t\t'&amp;&amp;&amp; &lt&lt&lt &quot;&quot;&quot;'\n\t);\n});\n\nesc('should reset state on same input string', () => {\n\tlet input = '<foo>\"hello\"</foo>';\n\n\tassert.is(\n\t\ttempura.esc(input),\n\t\t'&ltfoo>&quot;hello&quot;&lt/foo>'\n\t);\n\n\tassert.is(\n\t\ttempura.esc(input),\n\t\t'&ltfoo>&quot;hello&quot;&lt/foo>',\n\t\t'~> repeat'\n\t);\n});\n\nesc.run();\n"], "filenames": ["docs/api.md", "src/$index.js", "src/index.d.ts", "test/$index.js"], "buggy_code_start_loc": [9, 10, 15, 266], "buggy_code_end_loc": [17, 11, 16, 276], "fixing_code_start_loc": [9, 10, 15, 266], "fixing_code_end_loc": [21, 11, 16, 281], "type": "CWE-79", "message": "This affects the package tempura before 0.4.0. If the input to the esc function is of type object (i.e an array) it is returned without being escaped/sanitized, leading to a potential Cross-Site Scripting vulnerability.", "other": {"cve": {"id": "CVE-2021-23784", "sourceIdentifier": "report@snyk.io", "published": "2021-11-03T18:15:08.180", "lastModified": "2021-11-05T18:11:35.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package tempura before 0.4.0. If the input to the esc function is of type object (i.e an array) it is returned without being escaped/sanitized, leading to a potential Cross-Site Scripting vulnerability."}, {"lang": "es", "value": "Esto afecta al paquete tempura versiones anteriores a 0.4.0. Si la entrada a la funci\u00f3n esc es de tipo objeto (es decir, una matriz) se devuelve sin ser escapada/saneada, conllevando una potencial vulnerabilidad de tipo Cross-Site Scripting"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tempura_project:tempura:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.0", "matchCriteriaId": "ACE9E824-B3FD-4D3C-B5B7-817110F088C2"}]}]}], "references": [{"url": "https://github.com/lukeed/tempura/commit/58a5c3671e2f36b26810e77ead9e0dd471902f9b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lukeed/tempura/releases/tag/v0.4.0", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-TEMPURA-1569633", "source": "report@snyk.io", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/lukeed/tempura/commit/58a5c3671e2f36b26810e77ead9e0dd471902f9b"}}