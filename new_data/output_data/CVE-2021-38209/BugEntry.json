{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/netdevice.h>\n#include <linux/security.h>\n#include <net/net_namespace.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_timestamp.h>\n#include <linux/rculist_nulls.h>\n\nstatic bool enable_hooks __read_mostly;\nMODULE_PARM_DESC(enable_hooks, \"Always enable conntrack hooks\");\nmodule_param(enable_hooks, bool, 0000);\n\nunsigned int nf_conntrack_net_id __read_mostly;\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\nvoid\nprint_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,\n            const struct nf_conntrack_l4proto *l4proto)\n{\n\tswitch (tuple->src.l3num) {\n\tcase NFPROTO_IPV4:\n\t\tseq_printf(s, \"src=%pI4 dst=%pI4 \",\n\t\t\t   &tuple->src.u3.ip, &tuple->dst.u3.ip);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tseq_printf(s, \"src=%pI6 dst=%pI6 \",\n\t\t\t   tuple->src.u3.ip6, tuple->dst.u3.ip6);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4proto->l4proto) {\n\tcase IPPROTO_ICMP:\n\t\tseq_printf(s, \"type=%u code=%u id=%u \",\n\t\t\t   tuple->dst.u.icmp.type,\n\t\t\t   tuple->dst.u.icmp.code,\n\t\t\t   ntohs(tuple->src.u.icmp.id));\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.tcp.port),\n\t\t\t   ntohs(tuple->dst.u.tcp.port));\n\t\tbreak;\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_UDP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.udp.port),\n\t\t\t   ntohs(tuple->dst.u.udp.port));\n\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.dccp.port),\n\t\t\t   ntohs(tuple->dst.u.dccp.port));\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.sctp.port),\n\t\t\t   ntohs(tuple->dst.u.sctp.port));\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tseq_printf(s, \"type=%u code=%u id=%u \",\n\t\t\t   tuple->dst.u.icmp.type,\n\t\t\t   tuple->dst.u.icmp.code,\n\t\t\t   ntohs(tuple->src.u.icmp.id));\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tseq_printf(s, \"srckey=0x%x dstkey=0x%x \",\n\t\t\t   ntohs(tuple->src.u.gre.key),\n\t\t\t   ntohs(tuple->dst.u.gre.key));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(print_tuple);\n\nstruct ct_iter_state {\n\tstruct seq_net_private p;\n\tstruct hlist_nulls_head *hash;\n\tunsigned int htable_size;\n\tunsigned int bucket;\n\tu_int64_t time_now;\n};\n\nstatic struct hlist_nulls_node *ct_get_first(struct seq_file *seq)\n{\n\tstruct ct_iter_state *st = seq->private;\n\tstruct hlist_nulls_node *n;\n\n\tfor (st->bucket = 0;\n\t     st->bucket < st->htable_size;\n\t     st->bucket++) {\n\t\tn = rcu_dereference(\n\t\t\thlist_nulls_first_rcu(&st->hash[st->bucket]));\n\t\tif (!is_a_nulls(n))\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}\n\nstatic struct hlist_nulls_node *ct_get_next(struct seq_file *seq,\n\t\t\t\t      struct hlist_nulls_node *head)\n{\n\tstruct ct_iter_state *st = seq->private;\n\n\thead = rcu_dereference(hlist_nulls_next_rcu(head));\n\twhile (is_a_nulls(head)) {\n\t\tif (likely(get_nulls_value(head) == st->bucket)) {\n\t\t\tif (++st->bucket >= st->htable_size)\n\t\t\t\treturn NULL;\n\t\t}\n\t\thead = rcu_dereference(\n\t\t\thlist_nulls_first_rcu(&st->hash[st->bucket]));\n\t}\n\treturn head;\n}\n\nstatic struct hlist_nulls_node *ct_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct hlist_nulls_node *head = ct_get_first(seq);\n\n\tif (head)\n\t\twhile (pos && (head = ct_get_next(seq, head)))\n\t\t\tpos--;\n\treturn pos ? NULL : head;\n}\n\nstatic void *ct_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct ct_iter_state *st = seq->private;\n\n\tst->time_now = ktime_get_real_ns();\n\trcu_read_lock();\n\n\tnf_conntrack_get_ht(&st->hash, &st->htable_size);\n\treturn ct_get_idx(seq, *pos);\n}\n\nstatic void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn ct_get_next(s, v);\n}\n\nstatic void ct_seq_stop(struct seq_file *s, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\nstatic void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\n{\n\tint ret;\n\tu32 len;\n\tchar *secctx;\n\n\tret = security_secid_to_secctx(ct->secmark, &secctx, &len);\n\tif (ret)\n\t\treturn;\n\n\tseq_printf(s, \"secctx=%s \", secctx);\n\n\tsecurity_release_secctx(secctx, len);\n}\n#else\nstatic inline void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\n{\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic void ct_show_zone(struct seq_file *s, const struct nf_conn *ct,\n\t\t\t int dir)\n{\n\tconst struct nf_conntrack_zone *zone = nf_ct_zone(ct);\n\n\tif (zone->dir != dir)\n\t\treturn;\n\tswitch (zone->dir) {\n\tcase NF_CT_DEFAULT_ZONE_DIR:\n\t\tseq_printf(s, \"zone=%u \", zone->id);\n\t\tbreak;\n\tcase NF_CT_ZONE_DIR_ORIG:\n\t\tseq_printf(s, \"zone-orig=%u \", zone->id);\n\t\tbreak;\n\tcase NF_CT_ZONE_DIR_REPL:\n\t\tseq_printf(s, \"zone-reply=%u \", zone->id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n#else\nstatic inline void ct_show_zone(struct seq_file *s, const struct nf_conn *ct,\n\t\t\t\tint dir)\n{\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\nstatic void ct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\n{\n\tstruct ct_iter_state *st = s->private;\n\tstruct nf_conn_tstamp *tstamp;\n\ts64 delta_time;\n\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (tstamp) {\n\t\tdelta_time = st->time_now - tstamp->start;\n\t\tif (delta_time > 0)\n\t\t\tdelta_time = div_s64(delta_time, NSEC_PER_SEC);\n\t\telse\n\t\t\tdelta_time = 0;\n\n\t\tseq_printf(s, \"delta-time=%llu \",\n\t\t\t   (unsigned long long)delta_time);\n\t}\n\treturn;\n}\n#else\nstatic inline void\nct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\n{\n}\n#endif\n\nstatic const char* l3proto_name(u16 proto)\n{\n\tswitch (proto) {\n\tcase AF_INET: return \"ipv4\";\n\tcase AF_INET6: return \"ipv6\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic const char* l4proto_name(u16 proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_ICMP: return \"icmp\";\n\tcase IPPROTO_TCP: return \"tcp\";\n\tcase IPPROTO_UDP: return \"udp\";\n\tcase IPPROTO_DCCP: return \"dccp\";\n\tcase IPPROTO_GRE: return \"gre\";\n\tcase IPPROTO_SCTP: return \"sctp\";\n\tcase IPPROTO_UDPLITE: return \"udplite\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic unsigned int\nseq_print_acct(struct seq_file *s, const struct nf_conn *ct, int dir)\n{\n\tstruct nf_conn_acct *acct;\n\tstruct nf_conn_counter *counter;\n\n\tacct = nf_conn_acct_find(ct);\n\tif (!acct)\n\t\treturn 0;\n\n\tcounter = acct->counter;\n\tseq_printf(s, \"packets=%llu bytes=%llu \",\n\t\t   (unsigned long long)atomic64_read(&counter[dir].packets),\n\t\t   (unsigned long long)atomic64_read(&counter[dir].bytes));\n\n\treturn 0;\n}\n\n/* return 0 on success, 1 in case of error */\nstatic int ct_seq_show(struct seq_file *s, void *v)\n{\n\tstruct nf_conntrack_tuple_hash *hash = v;\n\tstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct net *net = seq_file_net(s);\n\tint ret = 0;\n\n\tWARN_ON(!ct);\n\tif (unlikely(!atomic_inc_not_zero(&ct->ct_general.use)))\n\t\treturn 0;\n\n\tif (nf_ct_should_gc(ct)) {\n\t\tnf_ct_kill(ct);\n\t\tgoto release;\n\t}\n\n\t/* we only want to print DIR_ORIGINAL */\n\tif (NF_CT_DIRECTION(hash))\n\t\tgoto release;\n\n\tif (!net_eq(nf_ct_net(ct), net))\n\t\tgoto release;\n\n\tl4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));\n\n\tret = -ENOSPC;\n\tseq_printf(s, \"%-8s %u %-8s %u \",\n\t\t   l3proto_name(nf_ct_l3num(ct)), nf_ct_l3num(ct),\n\t\t   l4proto_name(l4proto->l4proto), nf_ct_protonum(ct));\n\n\tif (!test_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\tseq_printf(s, \"%ld \", nf_ct_expires(ct)  / HZ);\n\n\tif (l4proto->print_conntrack)\n\t\tl4proto->print_conntrack(s, ct);\n\n\tprint_tuple(s, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\n\t\t    l4proto);\n\n\tct_show_zone(s, ct, NF_CT_ZONE_DIR_ORIG);\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n\tif (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))\n\t\tgoto release;\n\n\tif (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))\n\t\tseq_puts(s, \"[UNREPLIED] \");\n\n\tprint_tuple(s, &ct->tuplehash[IP_CT_DIR_REPLY].tuple, l4proto);\n\n\tct_show_zone(s, ct, NF_CT_ZONE_DIR_REPL);\n\n\tif (seq_print_acct(s, ct, IP_CT_DIR_REPLY))\n\t\tgoto release;\n\n\tif (test_bit(IPS_HW_OFFLOAD_BIT, &ct->status))\n\t\tseq_puts(s, \"[HW_OFFLOAD] \");\n\telse if (test_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\tseq_puts(s, \"[OFFLOAD] \");\n\telse if (test_bit(IPS_ASSURED_BIT, &ct->status))\n\t\tseq_puts(s, \"[ASSURED] \");\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tseq_printf(s, \"mark=%u \", ct->mark);\n#endif\n\n\tct_show_secctx(s, ct);\n\tct_show_zone(s, ct, NF_CT_DEFAULT_ZONE_DIR);\n\tct_show_delta_time(s, ct);\n\n\tseq_printf(s, \"use=%u\\n\", atomic_read(&ct->ct_general.use));\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n\tret = 0;\nrelease:\n\tnf_ct_put(ct);\n\treturn ret;\n}\n\nstatic const struct seq_operations ct_seq_ops = {\n\t.start = ct_seq_start,\n\t.next  = ct_seq_next,\n\t.stop  = ct_seq_stop,\n\t.show  = ct_seq_show\n};\n\nstatic void *ct_cpu_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tint cpu;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(net->ct.stat, cpu);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ct_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tint cpu;\n\n\tfor (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(net->ct.stat, cpu);\n\t}\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void ct_cpu_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int ct_cpu_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq_file_net(seq);\n\tunsigned int nr_conntracks = atomic_read(&net->ct.count);\n\tconst struct ip_conntrack_stat *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"entries  clashres found new invalid ignore delete delete_list insert insert_failed drop early_drop icmp_error  expect_new expect_create expect_delete search_restart\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(seq, \"%08x  %08x %08x %08x %08x %08x %08x %08x \"\n\t\t\t\"%08x %08x %08x %08x %08x  %08x %08x %08x %08x\\n\",\n\t\t   nr_conntracks,\n\t\t   st->clash_resolve,\n\t\t   st->found,\n\t\t   0,\n\t\t   st->invalid,\n\t\t   0,\n\t\t   0,\n\t\t   0,\n\t\t   st->insert,\n\t\t   st->insert_failed,\n\t\t   st->drop,\n\t\t   st->early_drop,\n\t\t   st->error,\n\n\t\t   st->expect_new,\n\t\t   st->expect_create,\n\t\t   st->expect_delete,\n\t\t   st->search_restart\n\t\t);\n\treturn 0;\n}\n\nstatic const struct seq_operations ct_cpu_seq_ops = {\n\t.start\t= ct_cpu_seq_start,\n\t.next\t= ct_cpu_seq_next,\n\t.stop\t= ct_cpu_seq_stop,\n\t.show\t= ct_cpu_seq_show,\n};\n\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\tpde = proc_create_net(\"nf_conntrack\", 0440, net->proc_net, &ct_seq_ops,\n\t\t\tsizeof(struct ct_iter_state));\n\tif (!pde)\n\t\tgoto out_nf_conntrack;\n\n\troot_uid = make_kuid(net->user_ns, 0);\n\troot_gid = make_kgid(net->user_ns, 0);\n\tif (uid_valid(root_uid) && gid_valid(root_gid))\n\t\tproc_set_user(pde, root_uid, root_gid);\n\n\tpde = proc_create_net(\"nf_conntrack\", 0444, net->proc_net_stat,\n\t\t\t&ct_cpu_seq_ops, sizeof(struct seq_net_private));\n\tif (!pde)\n\t\tgoto out_stat_nf_conntrack;\n\treturn 0;\n\nout_stat_nf_conntrack:\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net);\nout_nf_conntrack:\n\treturn -ENOMEM;\n}\n\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\n{\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net_stat);\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net);\n}\n#else\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\n{\n}\n#endif /* CONFIG_NF_CONNTRACK_PROCFS */\n\n/* Sysctl support */\n\n#ifdef CONFIG_SYSCTL\n/* Log invalid packets of a given protocol */\nstatic int log_invalid_proto_min __read_mostly;\nstatic int log_invalid_proto_max __read_mostly = 255;\n\n/* size the user *wants to set */\nstatic unsigned int nf_conntrack_htable_size_user __read_mostly;\n\nstatic int\nnf_conntrack_hash_sysctl(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\t/* module_param hashsize could have changed value */\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret < 0 || !write)\n\t\treturn ret;\n\n\t/* update ret, we might not be able to satisfy request */\n\tret = nf_conntrack_hash_resize(nf_conntrack_htable_size_user);\n\n\t/* update it to the actual value used by conntrack */\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n\treturn ret;\n}\n\nstatic struct ctl_table_header *nf_ct_netfilter_header;\n\nenum nf_ct_sysctl_index {\n\tNF_SYSCTL_CT_MAX,\n\tNF_SYSCTL_CT_COUNT,\n\tNF_SYSCTL_CT_BUCKETS,\n\tNF_SYSCTL_CT_CHECKSUM,\n\tNF_SYSCTL_CT_LOG_INVALID,\n\tNF_SYSCTL_CT_EXPECT_MAX,\n\tNF_SYSCTL_CT_ACCT,\n\tNF_SYSCTL_CT_HELPER,\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tNF_SYSCTL_CT_EVENTS,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\tNF_SYSCTL_CT_TIMESTAMP,\n#endif\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK,\n\tNF_SYSCTL_CT_PROTO_TCP_LOOSE,\n\tNF_SYSCTL_CT_PROTO_TCP_LIBERAL,\n\tNF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_UDP,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_ICMP,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6,\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED,\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT,\n\tNF_SYSCTL_CT_PROTO_DCCP_LOOSE,\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GRE,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM,\n#endif\n\n\t__NF_SYSCTL_CT_LAST_SYSCTL,\n};\n\n#define NF_SYSCTL_CT_LAST_SYSCTL (__NF_SYSCTL_CT_LAST_SYSCTL + 1)\n\nstatic struct ctl_table nf_ct_sysctl_table[] = {\n\t[NF_SYSCTL_CT_MAX] = {\n\t\t.procname\t= \"nf_conntrack_max\",\n\t\t.data\t\t= &nf_conntrack_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_COUNT] = {\n\t\t.procname\t= \"nf_conntrack_count\",\n\t\t.data\t\t= &init_net.ct.count,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_BUCKETS] = {\n\t\t.procname       = \"nf_conntrack_buckets\",\n\t\t.data           = &nf_conntrack_htable_size_user,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = nf_conntrack_hash_sysctl,\n\t},\n\t[NF_SYSCTL_CT_CHECKSUM] = {\n\t\t.procname\t= \"nf_conntrack_checksum\",\n\t\t.data\t\t= &init_net.ct.sysctl_checksum,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_LOG_INVALID] = {\n\t\t.procname\t= \"nf_conntrack_log_invalid\",\n\t\t.data\t\t= &init_net.ct.sysctl_log_invalid,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &log_invalid_proto_min,\n\t\t.extra2\t\t= &log_invalid_proto_max,\n\t},\n\t[NF_SYSCTL_CT_EXPECT_MAX] = {\n\t\t.procname\t= \"nf_conntrack_expect_max\",\n\t\t.data\t\t= &nf_ct_expect_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_ACCT] = {\n\t\t.procname\t= \"nf_conntrack_acct\",\n\t\t.data\t\t= &init_net.ct.sysctl_acct,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_HELPER] = {\n\t\t.procname\t= \"nf_conntrack_helper\",\n\t\t.data\t\t= &init_net.ct.sysctl_auto_assign_helper,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\t[NF_SYSCTL_CT_EVENTS] = {\n\t\t.procname\t= \"nf_conntrack_events\",\n\t\t.data\t\t= &init_net.ct.sysctl_events,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\t[NF_SYSCTL_CT_TIMESTAMP] = {\n\t\t.procname\t= \"nf_conntrack_timestamp\",\n\t\t.data\t\t= &init_net.ct.sysctl_tstamp,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC] = {\n\t\t.procname\t= \"nf_conntrack_generic_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_syn_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_syn_recv\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_established\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_fin_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_close_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_last_ack\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_time_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_close\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_max_retrans\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_unacknowledged\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_LOOSE] = {\n\t\t.procname\t= \"nf_conntrack_tcp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_LIBERAL] = {\n\t\t.procname       = \"nf_conntrack_tcp_be_liberal\",\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS] = {\n\t\t.procname\t= \"nf_conntrack_tcp_max_retrans\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP] = {\n\t\t.procname\t= \"nf_conntrack_udp_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM] = {\n\t\t.procname\t= \"nf_conntrack_udp_timeout_stream\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP] = {\n\t\t.procname\t= \"nf_conntrack_icmp_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6] = {\n\t\t.procname\t= \"nf_conntrack_icmpv6_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_closed\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_cookie_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_cookie_echoed\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_established\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_recd\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_ack_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_heartbeat_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED] = {\n\t\t.procname       = \"nf_conntrack_sctp_timeout_heartbeat_acked\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_request\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_respond\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_partopen\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_open\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closereq\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closing\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_timewait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_DCCP_LOOSE] = {\n\t\t.procname\t= \"nf_conntrack_dccp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE] = {\n\t\t.procname       = \"nf_conntrack_gre_timeout\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM] = {\n\t\t.procname       = \"nf_conntrack_gre_timeout_stream\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n#endif\n\t{}\n};\n\nstatic struct ctl_table nf_ct_netfilter_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_max\",\n\t\t.data\t\t= &nf_conntrack_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic void nf_conntrack_standalone_init_tcp_sysctl(struct net *net,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n\tstruct nf_tcp_net *tn = nf_tcp_pernet(net);\n\n#define XASSIGN(XNAME, tn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ ## XNAME].data = \\\n\t\t\t&(tn)->timeouts[TCP_CONNTRACK_ ## XNAME]\n\n\tXASSIGN(SYN_SENT, tn);\n\tXASSIGN(SYN_RECV, tn);\n\tXASSIGN(ESTABLISHED, tn);\n\tXASSIGN(FIN_WAIT, tn);\n\tXASSIGN(CLOSE_WAIT, tn);\n\tXASSIGN(LAST_ACK, tn);\n\tXASSIGN(TIME_WAIT, tn);\n\tXASSIGN(CLOSE, tn);\n\tXASSIGN(RETRANS, tn);\n\tXASSIGN(UNACK, tn);\n#undef XASSIGN\n#define XASSIGN(XNAME, rval) \\\n\ttable[NF_SYSCTL_CT_PROTO_TCP_ ## XNAME].data = (rval)\n\n\tXASSIGN(LOOSE, &tn->tcp_loose);\n\tXASSIGN(LIBERAL, &tn->tcp_be_liberal);\n\tXASSIGN(MAX_RETRANS, &tn->tcp_max_retrans);\n#undef XASSIGN\n}\n\nstatic void nf_conntrack_standalone_init_sctp_sysctl(struct net *net,\n\t\t\t\t\t\t     struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tstruct nf_sctp_net *sn = nf_sctp_pernet(net);\n\n#define XASSIGN(XNAME, sn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ ## XNAME].data = \\\n\t\t\t&(sn)->timeouts[SCTP_CONNTRACK_ ## XNAME]\n\n\tXASSIGN(CLOSED, sn);\n\tXASSIGN(COOKIE_WAIT, sn);\n\tXASSIGN(COOKIE_ECHOED, sn);\n\tXASSIGN(ESTABLISHED, sn);\n\tXASSIGN(SHUTDOWN_SENT, sn);\n\tXASSIGN(SHUTDOWN_RECD, sn);\n\tXASSIGN(SHUTDOWN_ACK_SENT, sn);\n\tXASSIGN(HEARTBEAT_SENT, sn);\n\tXASSIGN(HEARTBEAT_ACKED, sn);\n#undef XASSIGN\n#endif\n}\n\nstatic void nf_conntrack_standalone_init_dccp_sysctl(struct net *net,\n\t\t\t\t\t\t     struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tstruct nf_dccp_net *dn = nf_dccp_pernet(net);\n\n#define XASSIGN(XNAME, dn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_ ## XNAME].data = \\\n\t\t\t&(dn)->dccp_timeout[CT_DCCP_ ## XNAME]\n\n\tXASSIGN(REQUEST, dn);\n\tXASSIGN(RESPOND, dn);\n\tXASSIGN(PARTOPEN, dn);\n\tXASSIGN(OPEN, dn);\n\tXASSIGN(CLOSEREQ, dn);\n\tXASSIGN(CLOSING, dn);\n\tXASSIGN(TIMEWAIT, dn);\n#undef XASSIGN\n\n\ttable[NF_SYSCTL_CT_PROTO_DCCP_LOOSE].data = &dn->dccp_loose;\n#endif\n}\n\nstatic void nf_conntrack_standalone_init_gre_sysctl(struct net *net,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tstruct nf_gre_net *gn = nf_gre_pernet(net);\n\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE].data = &gn->timeouts[GRE_CT_UNREPLIED];\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM].data = &gn->timeouts[GRE_CT_REPLIED];\n#endif\n}\n\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\n{\n\tstruct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);\n\tstruct nf_udp_net *un = nf_udp_pernet(net);\n\tstruct ctl_table *table;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);\n\n\ttable = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable[NF_SYSCTL_CT_COUNT].data = &net->ct.count;\n\ttable[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;\n\ttable[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;\n\ttable[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;\n\ttable[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\ttable[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\ttable[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;\n#endif\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];\n\n\tnf_conntrack_standalone_init_tcp_sysctl(net, table);\n\tnf_conntrack_standalone_init_sctp_sysctl(net, table);\n\tnf_conntrack_standalone_init_dccp_sysctl(net, table);\n\tnf_conntrack_standalone_init_gre_sysctl(net, table);\n\n\t/* Don't allow unprivileged users to alter certain sysctls */\n\tif (net->user_ns != &init_user_ns) {\n\t\ttable[NF_SYSCTL_CT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_HELPER].mode = 0444;\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\t\ttable[NF_SYSCTL_CT_EVENTS].mode = 0444;\n#endif\n\t\ttable[NF_SYSCTL_CT_BUCKETS].mode = 0444;\n\t} else if (!net_eq(&init_net, net)) {\n\t\ttable[NF_SYSCTL_CT_BUCKETS].mode = 0444;\n\t}\n\n\tcnet->sysctl_header = register_net_sysctl(net, \"net/netfilter\", table);\n\tif (!cnet->sysctl_header)\n\t\tgoto out_unregister_netfilter;\n\n\treturn 0;\n\nout_unregister_netfilter:\n\tkfree(table);\n\treturn -ENOMEM;\n}\n\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\n{\n\tstruct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);\n\tstruct ctl_table *table;\n\n\ttable = cnet->sysctl_header->ctl_table_arg;\n\tunregister_net_sysctl_table(cnet->sysctl_header);\n\tkfree(table);\n}\n#else\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\n{\n}\n#endif /* CONFIG_SYSCTL */\n\nstatic void nf_conntrack_fini_net(struct net *net)\n{\n\tif (enable_hooks)\n\t\tnf_ct_netns_put(net, NFPROTO_INET);\n\n\tnf_conntrack_standalone_fini_proc(net);\n\tnf_conntrack_standalone_fini_sysctl(net);\n}\n\nstatic int nf_conntrack_pernet_init(struct net *net)\n{\n\tint ret;\n\n\tnet->ct.sysctl_checksum = 1;\n\n\tret = nf_conntrack_standalone_init_sysctl(net);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nf_conntrack_standalone_init_proc(net);\n\tif (ret < 0)\n\t\tgoto out_proc;\n\n\tret = nf_conntrack_init_net(net);\n\tif (ret < 0)\n\t\tgoto out_init_net;\n\n\tif (enable_hooks) {\n\t\tret = nf_ct_netns_get(net, NFPROTO_INET);\n\t\tif (ret < 0)\n\t\t\tgoto out_hooks;\n\t}\n\n\treturn 0;\n\nout_hooks:\n\tnf_conntrack_cleanup_net(net);\nout_init_net:\n\tnf_conntrack_standalone_fini_proc(net);\nout_proc:\n\tnf_conntrack_standalone_fini_sysctl(net);\n\treturn ret;\n}\n\nstatic void nf_conntrack_pernet_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnf_conntrack_fini_net(net);\n\n\tnf_conntrack_cleanup_net_list(net_exit_list);\n}\n\nstatic struct pernet_operations nf_conntrack_net_ops = {\n\t.init\t\t= nf_conntrack_pernet_init,\n\t.exit_batch\t= nf_conntrack_pernet_exit,\n\t.id\t\t= &nf_conntrack_net_id,\n\t.size = sizeof(struct nf_conntrack_net),\n};\n\nstatic int __init nf_conntrack_standalone_init(void)\n{\n\tint ret = nf_conntrack_init_start();\n\tif (ret < 0)\n\t\tgoto out_start;\n\n\tBUILD_BUG_ON(NFCT_INFOMASK <= IP_CT_NUMBER);\n\n#ifdef CONFIG_SYSCTL\n\tnf_ct_netfilter_header =\n\t\tregister_net_sysctl(&init_net, \"net\", nf_ct_netfilter_table);\n\tif (!nf_ct_netfilter_header) {\n\t\tpr_err(\"nf_conntrack: can't register to sysctl.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_sysctl;\n\t}\n\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n#endif\n\n\tret = register_pernet_subsys(&nf_conntrack_net_ops);\n\tif (ret < 0)\n\t\tgoto out_pernet;\n\n\tnf_conntrack_init_end();\n\treturn 0;\n\nout_pernet:\n#ifdef CONFIG_SYSCTL\n\tunregister_net_sysctl_table(nf_ct_netfilter_header);\nout_sysctl:\n#endif\n\tnf_conntrack_cleanup_end();\nout_start:\n\treturn ret;\n}\n\nstatic void __exit nf_conntrack_standalone_fini(void)\n{\n\tnf_conntrack_cleanup_start();\n\tunregister_pernet_subsys(&nf_conntrack_net_ops);\n#ifdef CONFIG_SYSCTL\n\tunregister_net_sysctl_table(nf_ct_netfilter_header);\n#endif\n\tnf_conntrack_cleanup_end();\n}\n\nmodule_init(nf_conntrack_standalone_init);\nmodule_exit(nf_conntrack_standalone_fini);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/percpu.h>\n#include <linux/netdevice.h>\n#include <linux/security.h>\n#include <net/net_namespace.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_acct.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/nf_conntrack_timestamp.h>\n#include <linux/rculist_nulls.h>\n\nstatic bool enable_hooks __read_mostly;\nMODULE_PARM_DESC(enable_hooks, \"Always enable conntrack hooks\");\nmodule_param(enable_hooks, bool, 0000);\n\nunsigned int nf_conntrack_net_id __read_mostly;\n\n#ifdef CONFIG_NF_CONNTRACK_PROCFS\nvoid\nprint_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,\n            const struct nf_conntrack_l4proto *l4proto)\n{\n\tswitch (tuple->src.l3num) {\n\tcase NFPROTO_IPV4:\n\t\tseq_printf(s, \"src=%pI4 dst=%pI4 \",\n\t\t\t   &tuple->src.u3.ip, &tuple->dst.u3.ip);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tseq_printf(s, \"src=%pI6 dst=%pI6 \",\n\t\t\t   tuple->src.u3.ip6, tuple->dst.u3.ip6);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4proto->l4proto) {\n\tcase IPPROTO_ICMP:\n\t\tseq_printf(s, \"type=%u code=%u id=%u \",\n\t\t\t   tuple->dst.u.icmp.type,\n\t\t\t   tuple->dst.u.icmp.code,\n\t\t\t   ntohs(tuple->src.u.icmp.id));\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.tcp.port),\n\t\t\t   ntohs(tuple->dst.u.tcp.port));\n\t\tbreak;\n\tcase IPPROTO_UDPLITE:\n\tcase IPPROTO_UDP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.udp.port),\n\t\t\t   ntohs(tuple->dst.u.udp.port));\n\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.dccp.port),\n\t\t\t   ntohs(tuple->dst.u.dccp.port));\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tseq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t   ntohs(tuple->src.u.sctp.port),\n\t\t\t   ntohs(tuple->dst.u.sctp.port));\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tseq_printf(s, \"type=%u code=%u id=%u \",\n\t\t\t   tuple->dst.u.icmp.type,\n\t\t\t   tuple->dst.u.icmp.code,\n\t\t\t   ntohs(tuple->src.u.icmp.id));\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tseq_printf(s, \"srckey=0x%x dstkey=0x%x \",\n\t\t\t   ntohs(tuple->src.u.gre.key),\n\t\t\t   ntohs(tuple->dst.u.gre.key));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(print_tuple);\n\nstruct ct_iter_state {\n\tstruct seq_net_private p;\n\tstruct hlist_nulls_head *hash;\n\tunsigned int htable_size;\n\tunsigned int bucket;\n\tu_int64_t time_now;\n};\n\nstatic struct hlist_nulls_node *ct_get_first(struct seq_file *seq)\n{\n\tstruct ct_iter_state *st = seq->private;\n\tstruct hlist_nulls_node *n;\n\n\tfor (st->bucket = 0;\n\t     st->bucket < st->htable_size;\n\t     st->bucket++) {\n\t\tn = rcu_dereference(\n\t\t\thlist_nulls_first_rcu(&st->hash[st->bucket]));\n\t\tif (!is_a_nulls(n))\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}\n\nstatic struct hlist_nulls_node *ct_get_next(struct seq_file *seq,\n\t\t\t\t      struct hlist_nulls_node *head)\n{\n\tstruct ct_iter_state *st = seq->private;\n\n\thead = rcu_dereference(hlist_nulls_next_rcu(head));\n\twhile (is_a_nulls(head)) {\n\t\tif (likely(get_nulls_value(head) == st->bucket)) {\n\t\t\tif (++st->bucket >= st->htable_size)\n\t\t\t\treturn NULL;\n\t\t}\n\t\thead = rcu_dereference(\n\t\t\thlist_nulls_first_rcu(&st->hash[st->bucket]));\n\t}\n\treturn head;\n}\n\nstatic struct hlist_nulls_node *ct_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct hlist_nulls_node *head = ct_get_first(seq);\n\n\tif (head)\n\t\twhile (pos && (head = ct_get_next(seq, head)))\n\t\t\tpos--;\n\treturn pos ? NULL : head;\n}\n\nstatic void *ct_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct ct_iter_state *st = seq->private;\n\n\tst->time_now = ktime_get_real_ns();\n\trcu_read_lock();\n\n\tnf_conntrack_get_ht(&st->hash, &st->htable_size);\n\treturn ct_get_idx(seq, *pos);\n}\n\nstatic void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn ct_get_next(s, v);\n}\n\nstatic void ct_seq_stop(struct seq_file *s, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\nstatic void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\n{\n\tint ret;\n\tu32 len;\n\tchar *secctx;\n\n\tret = security_secid_to_secctx(ct->secmark, &secctx, &len);\n\tif (ret)\n\t\treturn;\n\n\tseq_printf(s, \"secctx=%s \", secctx);\n\n\tsecurity_release_secctx(secctx, len);\n}\n#else\nstatic inline void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\n{\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_ZONES\nstatic void ct_show_zone(struct seq_file *s, const struct nf_conn *ct,\n\t\t\t int dir)\n{\n\tconst struct nf_conntrack_zone *zone = nf_ct_zone(ct);\n\n\tif (zone->dir != dir)\n\t\treturn;\n\tswitch (zone->dir) {\n\tcase NF_CT_DEFAULT_ZONE_DIR:\n\t\tseq_printf(s, \"zone=%u \", zone->id);\n\t\tbreak;\n\tcase NF_CT_ZONE_DIR_ORIG:\n\t\tseq_printf(s, \"zone-orig=%u \", zone->id);\n\t\tbreak;\n\tcase NF_CT_ZONE_DIR_REPL:\n\t\tseq_printf(s, \"zone-reply=%u \", zone->id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n#else\nstatic inline void ct_show_zone(struct seq_file *s, const struct nf_conn *ct,\n\t\t\t\tint dir)\n{\n}\n#endif\n\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\nstatic void ct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\n{\n\tstruct ct_iter_state *st = s->private;\n\tstruct nf_conn_tstamp *tstamp;\n\ts64 delta_time;\n\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (tstamp) {\n\t\tdelta_time = st->time_now - tstamp->start;\n\t\tif (delta_time > 0)\n\t\t\tdelta_time = div_s64(delta_time, NSEC_PER_SEC);\n\t\telse\n\t\t\tdelta_time = 0;\n\n\t\tseq_printf(s, \"delta-time=%llu \",\n\t\t\t   (unsigned long long)delta_time);\n\t}\n\treturn;\n}\n#else\nstatic inline void\nct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\n{\n}\n#endif\n\nstatic const char* l3proto_name(u16 proto)\n{\n\tswitch (proto) {\n\tcase AF_INET: return \"ipv4\";\n\tcase AF_INET6: return \"ipv6\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic const char* l4proto_name(u16 proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_ICMP: return \"icmp\";\n\tcase IPPROTO_TCP: return \"tcp\";\n\tcase IPPROTO_UDP: return \"udp\";\n\tcase IPPROTO_DCCP: return \"dccp\";\n\tcase IPPROTO_GRE: return \"gre\";\n\tcase IPPROTO_SCTP: return \"sctp\";\n\tcase IPPROTO_UDPLITE: return \"udplite\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic unsigned int\nseq_print_acct(struct seq_file *s, const struct nf_conn *ct, int dir)\n{\n\tstruct nf_conn_acct *acct;\n\tstruct nf_conn_counter *counter;\n\n\tacct = nf_conn_acct_find(ct);\n\tif (!acct)\n\t\treturn 0;\n\n\tcounter = acct->counter;\n\tseq_printf(s, \"packets=%llu bytes=%llu \",\n\t\t   (unsigned long long)atomic64_read(&counter[dir].packets),\n\t\t   (unsigned long long)atomic64_read(&counter[dir].bytes));\n\n\treturn 0;\n}\n\n/* return 0 on success, 1 in case of error */\nstatic int ct_seq_show(struct seq_file *s, void *v)\n{\n\tstruct nf_conntrack_tuple_hash *hash = v;\n\tstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);\n\tconst struct nf_conntrack_l4proto *l4proto;\n\tstruct net *net = seq_file_net(s);\n\tint ret = 0;\n\n\tWARN_ON(!ct);\n\tif (unlikely(!atomic_inc_not_zero(&ct->ct_general.use)))\n\t\treturn 0;\n\n\tif (nf_ct_should_gc(ct)) {\n\t\tnf_ct_kill(ct);\n\t\tgoto release;\n\t}\n\n\t/* we only want to print DIR_ORIGINAL */\n\tif (NF_CT_DIRECTION(hash))\n\t\tgoto release;\n\n\tif (!net_eq(nf_ct_net(ct), net))\n\t\tgoto release;\n\n\tl4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));\n\n\tret = -ENOSPC;\n\tseq_printf(s, \"%-8s %u %-8s %u \",\n\t\t   l3proto_name(nf_ct_l3num(ct)), nf_ct_l3num(ct),\n\t\t   l4proto_name(l4proto->l4proto), nf_ct_protonum(ct));\n\n\tif (!test_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\tseq_printf(s, \"%ld \", nf_ct_expires(ct)  / HZ);\n\n\tif (l4proto->print_conntrack)\n\t\tl4proto->print_conntrack(s, ct);\n\n\tprint_tuple(s, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\n\t\t    l4proto);\n\n\tct_show_zone(s, ct, NF_CT_ZONE_DIR_ORIG);\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n\tif (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))\n\t\tgoto release;\n\n\tif (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))\n\t\tseq_puts(s, \"[UNREPLIED] \");\n\n\tprint_tuple(s, &ct->tuplehash[IP_CT_DIR_REPLY].tuple, l4proto);\n\n\tct_show_zone(s, ct, NF_CT_ZONE_DIR_REPL);\n\n\tif (seq_print_acct(s, ct, IP_CT_DIR_REPLY))\n\t\tgoto release;\n\n\tif (test_bit(IPS_HW_OFFLOAD_BIT, &ct->status))\n\t\tseq_puts(s, \"[HW_OFFLOAD] \");\n\telse if (test_bit(IPS_OFFLOAD_BIT, &ct->status))\n\t\tseq_puts(s, \"[OFFLOAD] \");\n\telse if (test_bit(IPS_ASSURED_BIT, &ct->status))\n\t\tseq_puts(s, \"[ASSURED] \");\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tseq_printf(s, \"mark=%u \", ct->mark);\n#endif\n\n\tct_show_secctx(s, ct);\n\tct_show_zone(s, ct, NF_CT_DEFAULT_ZONE_DIR);\n\tct_show_delta_time(s, ct);\n\n\tseq_printf(s, \"use=%u\\n\", atomic_read(&ct->ct_general.use));\n\n\tif (seq_has_overflowed(s))\n\t\tgoto release;\n\n\tret = 0;\nrelease:\n\tnf_ct_put(ct);\n\treturn ret;\n}\n\nstatic const struct seq_operations ct_seq_ops = {\n\t.start = ct_seq_start,\n\t.next  = ct_seq_next,\n\t.stop  = ct_seq_stop,\n\t.show  = ct_seq_show\n};\n\nstatic void *ct_cpu_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tint cpu;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(net->ct.stat, cpu);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ct_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tint cpu;\n\n\tfor (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*pos = cpu + 1;\n\t\treturn per_cpu_ptr(net->ct.stat, cpu);\n\t}\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void ct_cpu_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int ct_cpu_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq_file_net(seq);\n\tunsigned int nr_conntracks = atomic_read(&net->ct.count);\n\tconst struct ip_conntrack_stat *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"entries  clashres found new invalid ignore delete delete_list insert insert_failed drop early_drop icmp_error  expect_new expect_create expect_delete search_restart\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(seq, \"%08x  %08x %08x %08x %08x %08x %08x %08x \"\n\t\t\t\"%08x %08x %08x %08x %08x  %08x %08x %08x %08x\\n\",\n\t\t   nr_conntracks,\n\t\t   st->clash_resolve,\n\t\t   st->found,\n\t\t   0,\n\t\t   st->invalid,\n\t\t   0,\n\t\t   0,\n\t\t   0,\n\t\t   st->insert,\n\t\t   st->insert_failed,\n\t\t   st->drop,\n\t\t   st->early_drop,\n\t\t   st->error,\n\n\t\t   st->expect_new,\n\t\t   st->expect_create,\n\t\t   st->expect_delete,\n\t\t   st->search_restart\n\t\t);\n\treturn 0;\n}\n\nstatic const struct seq_operations ct_cpu_seq_ops = {\n\t.start\t= ct_cpu_seq_start,\n\t.next\t= ct_cpu_seq_next,\n\t.stop\t= ct_cpu_seq_stop,\n\t.show\t= ct_cpu_seq_show,\n};\n\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\n\tpde = proc_create_net(\"nf_conntrack\", 0440, net->proc_net, &ct_seq_ops,\n\t\t\tsizeof(struct ct_iter_state));\n\tif (!pde)\n\t\tgoto out_nf_conntrack;\n\n\troot_uid = make_kuid(net->user_ns, 0);\n\troot_gid = make_kgid(net->user_ns, 0);\n\tif (uid_valid(root_uid) && gid_valid(root_gid))\n\t\tproc_set_user(pde, root_uid, root_gid);\n\n\tpde = proc_create_net(\"nf_conntrack\", 0444, net->proc_net_stat,\n\t\t\t&ct_cpu_seq_ops, sizeof(struct seq_net_private));\n\tif (!pde)\n\t\tgoto out_stat_nf_conntrack;\n\treturn 0;\n\nout_stat_nf_conntrack:\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net);\nout_nf_conntrack:\n\treturn -ENOMEM;\n}\n\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\n{\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net_stat);\n\tremove_proc_entry(\"nf_conntrack\", net->proc_net);\n}\n#else\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\n{\n}\n#endif /* CONFIG_NF_CONNTRACK_PROCFS */\n\n/* Sysctl support */\n\n#ifdef CONFIG_SYSCTL\n/* Log invalid packets of a given protocol */\nstatic int log_invalid_proto_min __read_mostly;\nstatic int log_invalid_proto_max __read_mostly = 255;\n\n/* size the user *wants to set */\nstatic unsigned int nf_conntrack_htable_size_user __read_mostly;\n\nstatic int\nnf_conntrack_hash_sysctl(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\t/* module_param hashsize could have changed value */\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret < 0 || !write)\n\t\treturn ret;\n\n\t/* update ret, we might not be able to satisfy request */\n\tret = nf_conntrack_hash_resize(nf_conntrack_htable_size_user);\n\n\t/* update it to the actual value used by conntrack */\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n\treturn ret;\n}\n\nstatic struct ctl_table_header *nf_ct_netfilter_header;\n\nenum nf_ct_sysctl_index {\n\tNF_SYSCTL_CT_MAX,\n\tNF_SYSCTL_CT_COUNT,\n\tNF_SYSCTL_CT_BUCKETS,\n\tNF_SYSCTL_CT_CHECKSUM,\n\tNF_SYSCTL_CT_LOG_INVALID,\n\tNF_SYSCTL_CT_EXPECT_MAX,\n\tNF_SYSCTL_CT_ACCT,\n\tNF_SYSCTL_CT_HELPER,\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\tNF_SYSCTL_CT_EVENTS,\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\tNF_SYSCTL_CT_TIMESTAMP,\n#endif\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK,\n\tNF_SYSCTL_CT_PROTO_TCP_LOOSE,\n\tNF_SYSCTL_CT_PROTO_TCP_LIBERAL,\n\tNF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_UDP,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_ICMP,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6,\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED,\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT,\n\tNF_SYSCTL_CT_PROTO_DCCP_LOOSE,\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GRE,\n\tNF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM,\n#endif\n\n\t__NF_SYSCTL_CT_LAST_SYSCTL,\n};\n\n#define NF_SYSCTL_CT_LAST_SYSCTL (__NF_SYSCTL_CT_LAST_SYSCTL + 1)\n\nstatic struct ctl_table nf_ct_sysctl_table[] = {\n\t[NF_SYSCTL_CT_MAX] = {\n\t\t.procname\t= \"nf_conntrack_max\",\n\t\t.data\t\t= &nf_conntrack_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_COUNT] = {\n\t\t.procname\t= \"nf_conntrack_count\",\n\t\t.data\t\t= &init_net.ct.count,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_BUCKETS] = {\n\t\t.procname       = \"nf_conntrack_buckets\",\n\t\t.data           = &nf_conntrack_htable_size_user,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = nf_conntrack_hash_sysctl,\n\t},\n\t[NF_SYSCTL_CT_CHECKSUM] = {\n\t\t.procname\t= \"nf_conntrack_checksum\",\n\t\t.data\t\t= &init_net.ct.sysctl_checksum,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_LOG_INVALID] = {\n\t\t.procname\t= \"nf_conntrack_log_invalid\",\n\t\t.data\t\t= &init_net.ct.sysctl_log_invalid,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &log_invalid_proto_min,\n\t\t.extra2\t\t= &log_invalid_proto_max,\n\t},\n\t[NF_SYSCTL_CT_EXPECT_MAX] = {\n\t\t.procname\t= \"nf_conntrack_expect_max\",\n\t\t.data\t\t= &nf_ct_expect_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_ACCT] = {\n\t\t.procname\t= \"nf_conntrack_acct\",\n\t\t.data\t\t= &init_net.ct.sysctl_acct,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_HELPER] = {\n\t\t.procname\t= \"nf_conntrack_helper\",\n\t\t.data\t\t= &init_net.ct.sysctl_auto_assign_helper,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\t[NF_SYSCTL_CT_EVENTS] = {\n\t\t.procname\t= \"nf_conntrack_events\",\n\t\t.data\t\t= &init_net.ct.sysctl_events,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\t[NF_SYSCTL_CT_TIMESTAMP] = {\n\t\t.procname\t= \"nf_conntrack_timestamp\",\n\t\t.data\t\t= &init_net.ct.sysctl_tstamp,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC] = {\n\t\t.procname\t= \"nf_conntrack_generic_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_syn_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_syn_recv\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_established\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_fin_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_close_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_last_ack\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_time_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_close\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_max_retrans\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK] = {\n\t\t.procname\t= \"nf_conntrack_tcp_timeout_unacknowledged\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_LOOSE] = {\n\t\t.procname\t= \"nf_conntrack_tcp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_LIBERAL] = {\n\t\t.procname       = \"nf_conntrack_tcp_be_liberal\",\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS] = {\n\t\t.procname\t= \"nf_conntrack_tcp_max_retrans\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP] = {\n\t\t.procname\t= \"nf_conntrack_udp_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM] = {\n\t\t.procname\t= \"nf_conntrack_udp_timeout_stream\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP] = {\n\t\t.procname\t= \"nf_conntrack_icmp_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6] = {\n\t\t.procname\t= \"nf_conntrack_icmpv6_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_closed\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_cookie_wait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_cookie_echoed\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_established\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_recd\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_shutdown_ack_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT] = {\n\t\t.procname\t= \"nf_conntrack_sctp_timeout_heartbeat_sent\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED] = {\n\t\t.procname       = \"nf_conntrack_sctp_timeout_heartbeat_acked\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_request\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_respond\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_partopen\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_open\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closereq\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closing\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT] = {\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_timewait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_DCCP_LOOSE] = {\n\t\t.procname\t= \"nf_conntrack_dccp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1 \t= SYSCTL_ZERO,\n\t\t.extra2 \t= SYSCTL_ONE,\n\t},\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE] = {\n\t\t.procname       = \"nf_conntrack_gre_timeout\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n\t[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM] = {\n\t\t.procname       = \"nf_conntrack_gre_timeout_stream\",\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_jiffies,\n\t},\n#endif\n\t{}\n};\n\nstatic struct ctl_table nf_ct_netfilter_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_max\",\n\t\t.data\t\t= &nf_conntrack_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic void nf_conntrack_standalone_init_tcp_sysctl(struct net *net,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n\tstruct nf_tcp_net *tn = nf_tcp_pernet(net);\n\n#define XASSIGN(XNAME, tn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ ## XNAME].data = \\\n\t\t\t&(tn)->timeouts[TCP_CONNTRACK_ ## XNAME]\n\n\tXASSIGN(SYN_SENT, tn);\n\tXASSIGN(SYN_RECV, tn);\n\tXASSIGN(ESTABLISHED, tn);\n\tXASSIGN(FIN_WAIT, tn);\n\tXASSIGN(CLOSE_WAIT, tn);\n\tXASSIGN(LAST_ACK, tn);\n\tXASSIGN(TIME_WAIT, tn);\n\tXASSIGN(CLOSE, tn);\n\tXASSIGN(RETRANS, tn);\n\tXASSIGN(UNACK, tn);\n#undef XASSIGN\n#define XASSIGN(XNAME, rval) \\\n\ttable[NF_SYSCTL_CT_PROTO_TCP_ ## XNAME].data = (rval)\n\n\tXASSIGN(LOOSE, &tn->tcp_loose);\n\tXASSIGN(LIBERAL, &tn->tcp_be_liberal);\n\tXASSIGN(MAX_RETRANS, &tn->tcp_max_retrans);\n#undef XASSIGN\n}\n\nstatic void nf_conntrack_standalone_init_sctp_sysctl(struct net *net,\n\t\t\t\t\t\t     struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_SCTP\n\tstruct nf_sctp_net *sn = nf_sctp_pernet(net);\n\n#define XASSIGN(XNAME, sn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ ## XNAME].data = \\\n\t\t\t&(sn)->timeouts[SCTP_CONNTRACK_ ## XNAME]\n\n\tXASSIGN(CLOSED, sn);\n\tXASSIGN(COOKIE_WAIT, sn);\n\tXASSIGN(COOKIE_ECHOED, sn);\n\tXASSIGN(ESTABLISHED, sn);\n\tXASSIGN(SHUTDOWN_SENT, sn);\n\tXASSIGN(SHUTDOWN_RECD, sn);\n\tXASSIGN(SHUTDOWN_ACK_SENT, sn);\n\tXASSIGN(HEARTBEAT_SENT, sn);\n\tXASSIGN(HEARTBEAT_ACKED, sn);\n#undef XASSIGN\n#endif\n}\n\nstatic void nf_conntrack_standalone_init_dccp_sysctl(struct net *net,\n\t\t\t\t\t\t     struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_DCCP\n\tstruct nf_dccp_net *dn = nf_dccp_pernet(net);\n\n#define XASSIGN(XNAME, dn) \\\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_ ## XNAME].data = \\\n\t\t\t&(dn)->dccp_timeout[CT_DCCP_ ## XNAME]\n\n\tXASSIGN(REQUEST, dn);\n\tXASSIGN(RESPOND, dn);\n\tXASSIGN(PARTOPEN, dn);\n\tXASSIGN(OPEN, dn);\n\tXASSIGN(CLOSEREQ, dn);\n\tXASSIGN(CLOSING, dn);\n\tXASSIGN(TIMEWAIT, dn);\n#undef XASSIGN\n\n\ttable[NF_SYSCTL_CT_PROTO_DCCP_LOOSE].data = &dn->dccp_loose;\n#endif\n}\n\nstatic void nf_conntrack_standalone_init_gre_sysctl(struct net *net,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n#ifdef CONFIG_NF_CT_PROTO_GRE\n\tstruct nf_gre_net *gn = nf_gre_pernet(net);\n\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE].data = &gn->timeouts[GRE_CT_UNREPLIED];\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM].data = &gn->timeouts[GRE_CT_REPLIED];\n#endif\n}\n\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\n{\n\tstruct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);\n\tstruct nf_udp_net *un = nf_udp_pernet(net);\n\tstruct ctl_table *table;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);\n\n\ttable = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable[NF_SYSCTL_CT_COUNT].data = &net->ct.count;\n\ttable[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;\n\ttable[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;\n\ttable[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;\n\ttable[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\ttable[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\ttable[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;\n#endif\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];\n\n\tnf_conntrack_standalone_init_tcp_sysctl(net, table);\n\tnf_conntrack_standalone_init_sctp_sysctl(net, table);\n\tnf_conntrack_standalone_init_dccp_sysctl(net, table);\n\tnf_conntrack_standalone_init_gre_sysctl(net, table);\n\n\t/* Don't allow non-init_net ns to alter global sysctls */\n\tif (!net_eq(&init_net, net)) {\n\t\ttable[NF_SYSCTL_CT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_BUCKETS].mode = 0444;\n\t}\n\n\tcnet->sysctl_header = register_net_sysctl(net, \"net/netfilter\", table);\n\tif (!cnet->sysctl_header)\n\t\tgoto out_unregister_netfilter;\n\n\treturn 0;\n\nout_unregister_netfilter:\n\tkfree(table);\n\treturn -ENOMEM;\n}\n\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\n{\n\tstruct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);\n\tstruct ctl_table *table;\n\n\ttable = cnet->sysctl_header->ctl_table_arg;\n\tunregister_net_sysctl_table(cnet->sysctl_header);\n\tkfree(table);\n}\n#else\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\n{\n}\n#endif /* CONFIG_SYSCTL */\n\nstatic void nf_conntrack_fini_net(struct net *net)\n{\n\tif (enable_hooks)\n\t\tnf_ct_netns_put(net, NFPROTO_INET);\n\n\tnf_conntrack_standalone_fini_proc(net);\n\tnf_conntrack_standalone_fini_sysctl(net);\n}\n\nstatic int nf_conntrack_pernet_init(struct net *net)\n{\n\tint ret;\n\n\tnet->ct.sysctl_checksum = 1;\n\n\tret = nf_conntrack_standalone_init_sysctl(net);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nf_conntrack_standalone_init_proc(net);\n\tif (ret < 0)\n\t\tgoto out_proc;\n\n\tret = nf_conntrack_init_net(net);\n\tif (ret < 0)\n\t\tgoto out_init_net;\n\n\tif (enable_hooks) {\n\t\tret = nf_ct_netns_get(net, NFPROTO_INET);\n\t\tif (ret < 0)\n\t\t\tgoto out_hooks;\n\t}\n\n\treturn 0;\n\nout_hooks:\n\tnf_conntrack_cleanup_net(net);\nout_init_net:\n\tnf_conntrack_standalone_fini_proc(net);\nout_proc:\n\tnf_conntrack_standalone_fini_sysctl(net);\n\treturn ret;\n}\n\nstatic void nf_conntrack_pernet_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnf_conntrack_fini_net(net);\n\n\tnf_conntrack_cleanup_net_list(net_exit_list);\n}\n\nstatic struct pernet_operations nf_conntrack_net_ops = {\n\t.init\t\t= nf_conntrack_pernet_init,\n\t.exit_batch\t= nf_conntrack_pernet_exit,\n\t.id\t\t= &nf_conntrack_net_id,\n\t.size = sizeof(struct nf_conntrack_net),\n};\n\nstatic int __init nf_conntrack_standalone_init(void)\n{\n\tint ret = nf_conntrack_init_start();\n\tif (ret < 0)\n\t\tgoto out_start;\n\n\tBUILD_BUG_ON(NFCT_INFOMASK <= IP_CT_NUMBER);\n\n#ifdef CONFIG_SYSCTL\n\tnf_ct_netfilter_header =\n\t\tregister_net_sysctl(&init_net, \"net\", nf_ct_netfilter_table);\n\tif (!nf_ct_netfilter_header) {\n\t\tpr_err(\"nf_conntrack: can't register to sysctl.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_sysctl;\n\t}\n\n\tnf_conntrack_htable_size_user = nf_conntrack_htable_size;\n#endif\n\n\tret = register_pernet_subsys(&nf_conntrack_net_ops);\n\tif (ret < 0)\n\t\tgoto out_pernet;\n\n\tnf_conntrack_init_end();\n\treturn 0;\n\nout_pernet:\n#ifdef CONFIG_SYSCTL\n\tunregister_net_sysctl_table(nf_ct_netfilter_header);\nout_sysctl:\n#endif\n\tnf_conntrack_cleanup_end();\nout_start:\n\treturn ret;\n}\n\nstatic void __exit nf_conntrack_standalone_fini(void)\n{\n\tnf_conntrack_cleanup_start();\n\tunregister_pernet_subsys(&nf_conntrack_net_ops);\n#ifdef CONFIG_SYSCTL\n\tunregister_net_sysctl_table(nf_ct_netfilter_header);\n#endif\n\tnf_conntrack_cleanup_end();\n}\n\nmodule_init(nf_conntrack_standalone_init);\nmodule_exit(nf_conntrack_standalone_fini);\n"], "filenames": ["net/netfilter/nf_conntrack_standalone.c"], "buggy_code_start_loc": [1063], "buggy_code_end_loc": [1073], "fixing_code_start_loc": [1063], "fixing_code_end_loc": [1066], "type": "CWE-203", "message": "net/netfilter/nf_conntrack_standalone.c in the Linux kernel before 5.12.2 allows observation of changes in any net namespace because these changes are leaked into all other net namespaces. This is related to the NF_SYSCTL_CT_MAX, NF_SYSCTL_CT_EXPECT_MAX, and NF_SYSCTL_CT_BUCKETS sysctls.", "other": {"cve": {"id": "CVE-2021-38209", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.423", "lastModified": "2021-08-12T22:49:10.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/netfilter/nf_conntrack_standalone.c in the Linux kernel before 5.12.2 allows observation of changes in any net namespace because these changes are leaked into all other net namespaces. This is related to the NF_SYSCTL_CT_MAX, NF_SYSCTL_CT_EXPECT_MAX, and NF_SYSCTL_CT_BUCKETS sysctls."}, {"lang": "es", "value": "El archivo net/netfilter/nf_conntrack_standalone.c en el kernel de Linux versiones anteriores a 5.12.2, permite la observaci\u00f3n de cambios en cualquier espacio de nombres de red porque estos cambios son filtrados a todos los dem\u00e1s espacios de nombres de red.&#xa0;Esto est\u00e1 relacionado con los sysctls NF_SYSCTL_CT_MAX, NF_SYSCTL_CT_EXPECT_MAX y NF_SYSCTL_CT_BUCKETS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.2", "matchCriteriaId": "280A377E-707F-4C8E-B457-5FD215570D0D"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.12.2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2671fa4dc0109d3fb581bc3078fdf17b5d9080f6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2671fa4dc0109d3fb581bc3078fdf17b5d9080f6"}}