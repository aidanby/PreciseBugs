{"buggy_code": ["require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"rubygems/package\"\nrequire \"statistics\"\nrequire \"yaml\"\nrequire \"utilities\"\n\nclass AssessmentsController < ApplicationController\n  include ActiveSupport::Callbacks\n  include AssessmentAutogradeCore\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/handin.rb\")\n  include AssessmentHandin\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/handout.rb\")\n  include AssessmentHandout\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/grading.rb\")\n  include AssessmentGrading\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/autograde.rb\")\n  include AssessmentAutograde\n\n  # this is inherited from ApplicationController\n  before_action :set_assessment, except: %i[index new create install_assessment\n                                            importAsmtFromTar importAssessment\n                                            log_submit local_submit autograde_done]\n  before_action :set_submission, only: [:viewFeedback]\n\n  # We have to do this here, because the modules don't inherit ApplicationController.\n\n  # Grading\n  action_auth_level :bulkGrade, :course_assistant\n  action_auth_level :quickSetScore, :course_assistant\n  action_auth_level :quickSetScoreDetails, :course_assistant\n  action_auth_level :submission_popover, :course_assistant\n  action_auth_level :score_grader_info, :course_assistant\n  action_auth_level :viewGradesheet, :course_assistant\n  action_auth_level :viewGradesheet2, :course_assistant\n  action_auth_level :quickGetTotal, :course_assistant\n  action_auth_level :statistics, :instructor\n\n  # Handin\n  action_auth_level :handin, :student\n\n  # Handout\n  action_auth_level :handout, :student\n\n  # Autograde\n  action_no_auth :autograde_done\n  action_auth_level :regrade, :instructor\n  action_auth_level :regradeAll, :instructor\n  action_no_auth :log_submit\n  action_no_auth :local_submit\n\n  # SVN\n  autolab_require Rails.root.join(\"app/controllers/assessment/svn.rb\")\n  include AssessmentSVN\n  action_auth_level :admin_svn, :instructor\n  action_auth_level :set_repo, :instructor\n  action_auth_level :import_svn, :instructor\n\n  def index\n    @is_instructor = @cud.has_auth_level? :instructor\n    announcements_tmp = Announcement.where(\"start_date < :now AND end_date > :now\",\n                                           now: Time.current)\n                                    .where(persistent: false)\n    @announcements = announcements_tmp.where(course_id: @course.id)\n                                      .or(announcements_tmp.where(system: true)).order(:start_date)\n    @attachments = if @cud.instructor?\n                     @course.attachments\n                   else\n                     # Attachments that are released, and whose related assessment is also released\n                     course_attachments = @course.attachments\n                                                 .where(released: true)\n                                                 .left_outer_joins(:assessment)\n\n                     # Either assessment_id is nil (i.e. course attachment)\n                     # Or the assessment has started\n                     course_attachments.where(assessment_id: nil)\n                                       .or(course_attachments.where(\"assessments.start_at < ?\",\n                                                                    Time.current))\n                   end\n  end\n\n  # GET /assessments/new\n  # Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :new, :instructor\n\n  def new\n    @assessment = @course.assessments.new\n    return if GithubIntegration.connected\n\n    @assessment.github_submission_enabled = false\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory on file system, or from an uploaded\n  # tar file with the assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    ass_dir = Rails.root.join(\"courses\", @course.name)\n    @unused_config_files = []\n    Dir.foreach(ass_dir) do |filename|\n      # skip if not directory in folder\n      next if !File.directory?(File.join(ass_dir,\n                                         filename)) || (filename == \"..\") || (filename == \".\")\n\n      # assessment names must be only lowercase letters and digits\n      if filename =~ /[^a-z0-9]/\n        # add line break if adding to existing error message\n        flash.now[:error] = flash.now[:error] ? \"#{flash.now[:error]} <br>\" : \"\"\n        flash.now[:error] += \"An error occurred while trying to display an existing assessment \" \\\n            \"on file directory #{filename}: assessment file names must only contain lowercase \" \\\n            \"letters and digits with no spaces\"\n        flash.now[:html_safe] = true\n        next\n      end\n\n      # each assessment must have an associated yaml file\n      unless File.exist?(File.join(ass_dir, filename, \"#{filename}.yml\"))\n        flash.now[:error] = flash.now[:error] ? \"#{flash.now[:error]} <br>\" : \"\"\n        flash.now[:error] += \"An error occurred while trying to display an existing assessment \" \\\n          \"on file directory #{filename}: #{filename}.yml does not exist\"\n        flash.now[:html_safe] = true\n        next\n      end\n\n      # Only list assessments that aren't installed yet\n      assessment_exists = @course.assessments.exists?(name: filename)\n      @unused_config_files << filename unless assessment_exists\n    end\n    @unused_config_files.sort!\n  end\n\n  action_auth_level :importAsmtFromTar, :instructor\n\n  def importAsmtFromTar\n    tarFile = params[\"tarFile\"]\n    if tarFile.nil?\n      flash[:error] = \"Please select an assessment tarball for uploading.\"\n      redirect_to(action: \"install_assessment\")\n      return\n    end\n\n    begin\n      tarFile = File.new(tarFile.open, \"rb\")\n      tar_extract = Gem::Package::TarReader.new(tarFile)\n      tar_extract.rewind\n      is_valid_tar, asmt_name = valid_asmt_tar(tar_extract)\n      tar_extract.close\n      unless is_valid_tar\n        flash[:error] +=\n          \"<br>Invalid tarball. A valid assessment tar has a single root \"\\\n          \"directory that's named after the assessment, containing an \"\\\n          \"assessment yaml file and an assessment ruby file.\"\n        flash[:html_safe] = true\n        redirect_to(action: \"install_assessment\") && return\n      end\n    rescue SyntaxError => e\n      flash[:error] = \"Error parsing assessment configuration file:\"\n      # escape so that <compiled> doesn't get treated as a html tag\n      flash[:error] += \"<br><pre>#{CGI.escapeHTML e.to_s}</pre>\"\n      flash[:html_safe] = true\n      redirect_to(action: \"install_assessment\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error while reading the tarball -- #{e.message}.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    # Check if the assessment already exists.\n    unless @course.assessments.find_by(name: asmt_name).nil?\n      flash[:error] =\n        \"An assessment with the same name already exists for the course. \"\\\n        \"Please use a different name.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    # If all requirements are satisfied, extract assessment files.\n    begin\n      course_root = Rails.root.join(\"courses\", @course.name)\n      tar_extract.rewind\n      tar_extract.each do |entry|\n        relative_pathname = entry.full_name\n        if entry.directory?\n          FileUtils.mkdir_p(File.join(course_root, relative_pathname),\n                            mode: entry.header.mode, verbose: false)\n        elsif entry.file?\n          FileUtils.mkdir_p(File.join(course_root, File.dirname(relative_pathname)),\n                            mode: entry.header.mode, verbose: false)\n          File.open(File.join(course_root, relative_pathname), \"wb\") do |f|\n            f.write entry.read\n          end\n          FileUtils.chmod entry.header.mode, File.join(course_root, relative_pathname),\n                          verbose: false\n        elsif entry.header.typeflag == \"2\"\n          File.symlink entry.header.linkname, File.join(course_root, relative_pathname)\n        end\n      end\n      tar_extract.close\n    rescue StandardError => e\n      flash[:error] = \"Error while extracting tarball to server -- #{e.message}.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    params[:assessment_name] = asmt_name\n    importAssessment && return\n  end\n\n  # importAssessment - Imports an existing assessment from local file.\n  # The main task of this function is to decide what category a newly\n  # installed assessment should be assigned to.\n  action_auth_level :importAssessment, :instructor\n\n  def importAssessment\n    @assessment = @course.assessments.new(name: params[:assessment_name])\n    assessment_path = Rails.root.join(\"courses/#{@course.name}/#{@assessment.name}\")\n    # not sure if this check is 100% necessary anymore, but is a last resort\n    # against creating an invalid assessment\n    if params[:assessment_name] != @assessment.name\n      flash[:error] = \"Error creating assessment: Config module is named #{@assessment.name}\n                       but assessment file name is #{params[:assessment_name]}\"\n      # destroy model\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n\n    begin\n      @assessment.load_yaml # this will save the assessment\n    rescue StandardError => e\n      flash[:error] = \"Error loading yaml: #{e}\"\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n    @assessment.load_embedded_quiz # this will check and load embedded quiz\n    @assessment.construct_folder # make sure there's a handin folder, just in case\n    begin\n      @assessment.load_config_file # only call this on saved assessments\n    rescue StandardError => e\n      flash[:error] = \"Error loading config module: #{e}\"\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n    flash[:success] = \"Successfully imported #{@assessment.name}\"\n    redirect_to([@course, @assessment])\n  end\n\n  # create - Creates an assessment from an assessment directory\n  # residing in the course directory.\n  action_auth_level :create, :instructor\n\n  def create\n    @assessment = @course.assessments.new(new_assessment_params)\n\n    if @assessment.name.blank?\n      # Validate the name\n      ass_name = @assessment.display_name.downcase.gsub(/[^a-z0-9]/, \"\")\n\n      if ass_name.blank?\n        flash[:error] =\n          \"Assessment name is blank or contains characters that are not lowercase letters or digits\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n\n      # Update name in object\n      @assessment.name = ass_name\n    end\n\n    # fill in other fields\n    @assessment.course = @course\n    @assessment.handin_directory = \"handin\"\n\n    @assessment.handin_filename = if @assessment.github_submission_enabled\n                                    \"handin.tgz\"\n                                  else\n                                    \"handin.c\"\n                                  end\n\n    @assessment.visible_at = Time.current + 1.day\n    @assessment.start_at = Time.current + 1.day\n    @assessment.due_at = Time.current + 1.day\n    @assessment.end_at = Time.current + 1.day\n    @assessment.grading_deadline = Time.current + 1.day\n    @assessment.quiz = false\n    @assessment.quizData = \"\"\n    @assessment.max_submissions = params.include?(:max_submissions) ? params[:max_submissions] : -1\n\n    if @assessment.embedded_quiz\n      begin\n        @assessment.embedded_quiz_form_data = params[:assessment][:embedded_quiz_form].read\n      rescue StandardError\n        flash[:error] = \"Embedded quiz form cannot be empty!\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n    end\n\n    begin\n      @assessment.construct_folder\n    rescue StandardError => e\n      # Something bad happened. Undo everything\n      flash[:error] = e.to_s\n      begin\n        FileUtils.remove_dir(@assessment.folder_path)\n      rescue StandardError => e2\n        flash[:error] += \"An error occurred (#{e2}} \" \\\n          \" while recovering from a previous error (#{flash[:error]})\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n    end\n\n    # From here on, if something weird happens, we rollback\n    begin\n      @assessment.save!\n    rescue StandardError => e\n      flash[:error] = \"Error saving #{@assessment.name}: #{e}\"\n      redirect_to(action: :install_assessment)\n      return\n    end\n\n    # reload the assessment's config file\n    @assessment.load_config_file # only call this on saved assessments\n\n    flash[:success] = \"Successfully installed #{@assessment.name}.\"\n    # reload the course config file\n    @course.reload_course_config\n\n    redirect_to([@course, @assessment]) && return\n  end\n\n  def assessmentInitialize(assignName)\n    @assessment = @course.assessments.find_by(name: assignName)\n    raise \"Assessment #{assignName} does not exist!\" unless @assessment\n\n    if @assessment.nil?\n      flash[:error] = \"Error: Invalid assessment\"\n      redirect_to([@course, :assessments]) && return\n    end\n\n    @name = @assessment.name\n    @description = @assessment.description\n    @start_at = @assessment.start_at\n    @due_at = @assessment.due_at\n    @end_at = @assessment.end_at\n    @visible_at = @assessment.visible_at\n    @id = @assessment.id\n  end\n\n  # installProblems - If there are no problems defined yet for this\n  # assessment, then create them using the list defined by the #\n  # assessmentInitialize() function in the user's assessment.rb\n  # file.\n  #\n  # Note: this is only here for backward compatibility. In the\n  # current system, problems definitions are imported from the\n  # assessment properties yaml file.\n  def installProblems\n    redirect_to(action: \"index\") && return unless @cud.instructor?\n\n    return unless @assessment.problems.count == 0\n\n    @problems.each do |problem|\n      @assessment.problems.create do |p|\n        p.name = problem[\"name\"]\n        p.description = problem[\"description\"]\n        p.max_score = problem[\"max_score\"]\n        p.optional = problem[\"optional\"]\n      end\n    end\n  end\n\n  # raw_score\n  # @param map of problem names to problem scores\n  # @return score on this assignment not including any tweak or late penalty.\n  # We generically cast all values to floating point numbers because we don't\n  # trust the upstream developer to do that for us.\n  def raw_score(scores)\n    if @assessment.has_autograder? &&\n       @assessment.overwrites_method?(:raw_score)\n      sum = @assessment.config_module.raw_score(scores)\n    else\n      sum = 0.0\n      scores.each_value { |value| sum += value.to_f }\n    end\n\n    sum\n  end\n\n  def grade\n    @problem = @assessment.problems.find(params[:problem])\n    @submission = @assessment.submissions.find(params[:submission])\n    # Shows a form which has the submission on top, and feedback on bottom\n    begin\n      subFile = Rails.root.join(\"courses\", @course.name, @assessment.name,\n                                @assessment.handin_directory,\n                                @submission.filename)\n      @submissionData = File.read(subFile)\n    rescue StandardError\n      flash[:error] = \"Could not read #{subFile}\"\n    end\n    @score = @submission.scores.where(problem_id: @problem.id).first\n  end\n\n  def getAssessmentVariable(key)\n    @assessmentVariables&.key(key)\n  end\n\n  # export - export an assessment by saving its persistent\n  # properties in a yaml properties file.\n  action_auth_level :export, :instructor\n\n  def export\n    base_path = Rails.root.join(\"courses\", @course.name).to_s\n    asmt_dir = @assessment.name\n    begin\n      # Update the assessment config YAML file.\n      @assessment.dump_yaml\n      # Save embedded_quiz\n      @assessment.dump_embedded_quiz\n      # Pack assessment directory into a tarball.\n      tarStream = StringIO.new(\"\")\n      Gem::Package::TarWriter.new(tarStream) do |tar|\n        tar.mkdir asmt_dir, File.stat(File.join(base_path, asmt_dir)).mode\n        Dir[File.join(base_path, asmt_dir, \"**\")].each do |file|\n          mode = File.stat(file).mode\n          relative_path = file.sub(%r{^#{Regexp.escape base_path}/?}, \"\")\n\n          if File.directory?(file)\n            tar.mkdir relative_path, mode\n          elsif !relative_path.starts_with? File.join(@assessment.name,\n                                                      @assessment.handin_directory)\n            tar.add_file relative_path, mode do |tarFile|\n              File.open(file, \"rb\") { |f| tarFile.write f.read }\n            end\n          end\n        end\n      end\n      tarStream.rewind\n      tarStream.close\n      send_data tarStream.string.force_encoding(\"binary\"),\n                filename: \"#{@assessment.name}_#{Time.current.strftime('%Y%m%d')}.tar\",\n                content_type: \"application/x-tar\"\n    rescue SystemCallError => e\n      flash[:error] = \"Unable to update the config YAML file: #{e}\"\n      redirect_to action: \"index\"\n    rescue StandardError => e\n      flash[:error] = \"Unable to generate tarball -- #{e.message}\"\n      redirect_to action: \"index\"\n    end\n  end\n\n  action_auth_level :destroy, :instructor\n\n  def destroy\n    @assessment.submissions.each(&:destroy)\n\n    @assessment.attachments.each(&:destroy)\n\n    # Delete config file copy in assessmentConfig\n    if File.exist? @assessment.config_file_path\n      File.delete @assessment.config_file_path\n    end\n    if File.exist? @assessment.config_backup_file_path\n      File.delete @assessment.config_backup_file_path\n    end\n\n    name = @assessment.display_name\n    @assessment.destroy # awwww!!!!\n    flash[:success] = \"The assessment #{name} has been deleted.\"\n    redirect_to(course_path(@course)) && return\n  end\n\n  action_auth_level :show, :student\n\n  def show\n    set_handin\n    extend_config_module(@assessment, @submission, @cud)\n\n    @aud = @assessment.aud_for @cud.id\n\n    @list = {}\n    @list_title = {}\n\n    if @assessment.overwrites_method?(:listOptions)\n      list = @list\n      @list = @assessment.config_module.listOptions(list)\n    end\n\n    # Remember the student ID in case the user wants visit the gradesheet\n    session[\"gradeUser#{@assessment.id}\"] = params[:cud_id] if params[:cud_id]\n\n    @startTime = Time.current\n    @effectiveCud = if @cud.instructor? && params[:cud_id]\n                      @course.course_user_data.find(params[:cud_id])\n                    else\n                      @cud\n                    end\n    @attachments = if @cud.instructor?\n                     @assessment.attachments\n                   else\n                     @assessment.attachments.where(released: true)\n                   end\n    @submissions = @assessment.submissions.where(course_user_datum_id: @effectiveCud.id)\n                              .order(\"version DESC\")\n    @extension = @assessment.extensions.find_by(course_user_datum_id: @effectiveCud.id)\n    @problems = @assessment.problems\n\n    results = @submissions.select(\"submissions.id AS submission_id\",\n                                  \"problems.id AS problem_id\",\n                                  \"scores.id AS score_id\",\n                                  \"scores.*\")\n                          .joins(\"LEFT JOIN problems ON\n        submissions.assessment_id = problems.assessment_id\")\n                          .joins(\"LEFT JOIN scores ON\n        (submissions.id = scores.submission_id\n        AND problems.id = scores.problem_id)\")\n\n    # Process them to get into a format we want.\n    @scores = {}\n    results.each do |result|\n      subId = result[\"submission_id\"].to_i\n      @scores[subId] = {} unless @scores.key?(subId)\n\n      @scores[subId][result[\"problem_id\"].to_i] = {\n        score: result[\"score\"].to_f,\n        feedback: result[\"feedback\"],\n        score_id: result[\"score_id\"].to_i,\n        released: Utilities.is_truthy?(result[\"released\"]) ? 1 : 0\n      }\n    end\n\n    # Check if we should include regrade as a function\n    @autograded = @assessment.has_autograder?\n\n    @repos = GithubIntegration.find_by(user_id: @cud.user.id)&.repositories\n  end\n\n  action_auth_level :history, :student\n\n  def history\n    # Remember the student ID in case the user wants visit the gradesheet\n    session[\"gradeUser#{@assessment.id}\"] = params[:cud_id] if params[:cud_id]\n\n    @startTime = Time.current\n    @effectiveCud = if @cud.instructor? && params[:cud_id]\n                      @course.course_user_data.find(params[:cud_id])\n                    else\n                      @cud\n                    end\n    @submissions = @assessment.submissions.where(course_user_datum_id: @effectiveCud.id)\n                              .order(\"version DESC\")\n    @extension = @assessment.extensions.find_by(course_user_datum_id: @effectiveCud.id)\n    @problems = @assessment.problems\n\n    results = @submissions.select(\"submissions.id AS submission_id\",\n                                  \"problems.id AS problem_id\",\n                                  \"scores.id AS score_id\",\n                                  \"scores.*\")\n                          .joins(\"LEFT JOIN problems ON\n        submissions.assessment_id = problems.assessment_id\")\n                          .joins(\"LEFT JOIN scores ON\n        (submissions.id = scores.submission_id\n        AND problems.id = scores.problem_id)\")\n\n    # Process them to get into a format we want.\n    @scores = {}\n    results.each do |result|\n      subId = result[\"submission_id\"].to_i\n      @scores[subId] = {} unless @scores.key?(subId)\n\n      @scores[subId][result[\"problem_id\"].to_i] = {\n        score: result[\"score\"].to_f,\n        feedback: result[\"feedback\"],\n        score_id: result[\"score_id\"].to_i,\n        released: Utilities.is_truthy?(result[\"released\"]) ? 1 : 0, # converts 't' to 1, \"f\" to 0\n      }\n    end\n\n    # Check if we should include regrade as a function\n    @autograded = @assessment.has_autograder?\n\n    return unless params[:partial]\n\n    @partial = true\n    render(\"history\", layout: false) && return\n  end\n\n  action_auth_level :viewFeedback, :student\n\n  def viewFeedback\n    # User requested to view feedback on a score\n    @score = @submission.scores.find_by(problem_id: params[:feedback])\n    # Checks whether at least one problem has finished being auto-graded\n    @finishedAutograding = @submission.scores.where.not(feedback: nil).where(grader_id: 0)\n    @job_id = @submission[\"jobid\"]\n    @submission_id = params[:submission_id]\n\n    # Autograding is not in-progress and no score is available\n    if @score.nil?\n      if !@finishedAutograding.empty?\n        redirect_to(action: \"viewFeedback\",\n                    feedback: @finishedAutograding.first.problem_id,\n                    submission_id: params[:submission_id]) && return\n      end\n\n      if @job_id.nil?\n        flash[:error] = \"No feedback for requested score\"\n        redirect_to(action: \"index\") && return\n      end\n    end\n\n    # Autograding is in-progress\n    return if @score.nil?\n\n    @jsonFeedback = parseFeedback(@score.feedback)\n    @scoreHash = parseScore(@score.feedback)\n    if Archive.archive? @submission.handin_file_path\n      @files = Archive.get_files @submission.handin_file_path\n    end\n    @problemReleased = @submission.scores.pluck(:released).all? &&\n                       !@assessment.before_grading_deadline?\n    # get_correct_filename is protected, so we wrap around controller-specific call\n    @get_correct_filename = ->(annotation) {\n      get_correct_filename(annotation, @files, @submission)\n    }\n  end\n\n  action_auth_level :getPartialFeedback, :student\n\n  def getPartialFeedback\n    job_id = params[\"job_id\"].to_i\n\n    # User requested to view feedback on a score\n    if job_id.nil?\n      flash[:error] = \"Invalid job id\"\n      redirect_to(action: \"index\") && return\n    end\n\n    begin\n      resp = get_job_status(job_id)\n\n      if resp[\"is_assigned\"]\n        resp['partial_feedback'] = tango_get_partial_feedback(job_id)\n      end\n    rescue AutogradeError => e\n      render json: { error: \"Get partial feedback request failed: #{e}\" },\n             status: :internal_server_error\n    else\n      render json: resp.to_json\n    end\n  end\n\n  def parseScore(feedback)\n    return if feedback.nil?\n\n    lines = feedback.lines\n    feedback = lines[lines.length - 1].chomp\n\n    return unless valid_json?(feedback)\n\n    score_hash = JSON.parse(feedback)\n    score_hash = score_hash[\"scores\"]\n    if @jsonFeedback&.key?(\"_scores_order\") == false\n      @jsonFeedback[\"_scores_order\"] = score_hash.keys\n    end\n    @total = 0\n    score_hash.keys.each do |k|\n      @total += score_hash[k]\n    end\n    score_hash[\"_total\"] = @total\n    score_hash\n  end\n\n  def parse_stages(jsonFeedbackHash)\n    @result = true\n    if jsonFeedbackHash.key?(\"stages\")\n      jsonFeedbackHash[\"stages\"].each do |stage|\n        if jsonFeedbackHash[stage].key?(\"_order\") == false\n          jsonFeedbackHash[stage][\"_order\"] = jsonFeedbackHash[stage].keys\n        end\n      end\n    end\n    @result\n  end\n\n  def parseFeedback(feedback)\n    return if feedback.nil?\n\n    lines = feedback.lines\n    feedback = lines[lines.length - 2]&.chomp\n\n    return unless valid_json?(feedback)\n\n    jsonFeedbackHash = JSON.parse(feedback)\n    if jsonFeedbackHash.key?(\"_presentation\") == false\n      nil\n    elsif jsonFeedbackHash[\"_presentation\"] == \"semantic\" && !parse_stages(jsonFeedbackHash).nil?\n      jsonFeedbackHash\n    end\n  end\n\n  def valid_json?(json)\n    JSON.parse(json)\n  rescue JSON::ParserError, TypeError\n    false\n  end\n\n  action_auth_level :reload, :instructor\n\n  def reload\n    @assessment.load_config_file\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Assessment config file reloaded!\"\n    redirect_to(action: :show) && return\n  end\n\n  action_auth_level :edit, :instructor\n\n  def edit\n    # default to the basic tab\n    params[:active_tab] ||= \"basic\"\n\n    # make sure the 'active_tab' is a real tab\n    unless %w[basic handin penalties problems advanced].include? params[:active_tab]\n      params[:active_tab] = \"basic\"\n    end\n\n    # make sure the penalties are set up\n    @assessment.late_penalty ||= Penalty.new(kind: \"points\")\n    @assessment.version_penalty ||= Penalty.new(kind: \"points\")\n\n    @has_annotations = @assessment.submissions.any? { |s| !s.annotations.empty? }\n\n    @is_positive_grading = @assessment.is_positive_grading\n  end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_embedded_quiz_form = params[:assessment][:embedded_quiz_form]\n    uploaded_config_file = params[:assessment][:config_file]\n    unless uploaded_embedded_quiz_form.nil?\n      @assessment.embedded_quiz_form_data = uploaded_embedded_quiz_form.read\n      @assessment.save!\n    end\n\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      assessment_config_file_path = @assessment.source_config_file_path\n      File.open(assessment_config_file_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @assessment.load_config_file\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    begin\n      @assessment.update!(edit_assessment_params)\n      flash[:success] = \"Assessment configuration updated!\"\n\n      redirect_to(tab_index) && return\n    rescue ActiveRecord::RecordInvalid => e\n      flash[:error] = e.message.sub!(\"Validation failed: \", \"\")\n\n      redirect_to(tab_index) && return\n    end\n  end\n\n  action_auth_level :releaseAllGrades, :instructor\n\n  def releaseAllGrades\n    # release all grades\n    num_released = releaseMatchingGrades { |_| true }\n\n    if num_released > 0\n      flash[:success] =\n        format(\"%<num_released>d %<plurality>s released.\",\n               num_released: num_released,\n               plurality: (num_released > 1 ? \"grades were\" : \"grade was\"))\n    else\n      flash[:error] = \"No grades were released. They might have all already been released.\"\n    end\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :releaseSectionGrades, :course_assistant\n\n  def releaseSectionGrades\n    unless @cud.section? && !@cud.section.empty? && @cud.lecture && !@cud.lecture.empty?\n      flash[:error] =\n        \"You haven't been assigned to a lecture and/or section. Please contact your instructor.\"\n      redirect_to action: \"index\"\n      return\n    end\n\n    num_released = releaseMatchingGrades do |submission, _|\n      @cud.CA_of? submission.course_user_datum\n    end\n\n    if num_released > 0\n      flash[:success] =\n        format(\"%<num_released>d %<plurality>s released.\",\n               num_released: num_released,\n               plurality: (num_released > 1 ? \"grades were\" : \"grade was\"))\n    else\n      flash[:error] = \"No grades were released. \" \\\n                      \"Either they were all already released or you \"\\\n                      \"might be assigned to a lecture \" \\\n                      \"and/or section that doesn't exist. Please contact an instructor.\"\n    end\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :withdrawAllGrades, :instructor\n\n  def withdrawAllGrades\n    @assessment.submissions.each do |submission|\n      scores = submission.scores.where(released: true)\n      scores.each do |score|\n        score.released = false\n\n        begin\n          updateScore(@assessment.course.course_user_data, score)\n        rescue ActiveRecord::RecordInvalid => e\n          flash[:error] = flash[:error] || \"\"\n          flash[:error] += \"Unable to withdraw score for \"\\\n                           \"#{@assessment.course.course_user_data.user.email}: #{e.message}\"\n        end\n      end\n    end\n\n    flash[:success] = \"Grades have been withdrawn.\"\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :writeup, :student\n\n  def writeup\n    # If the logic here changes, do update assessment#has_writeup?\n    if @assessment.writeup_is_url?\n      redirect_to @assessment.writeup\n      return\n    end\n\n    if @assessment.writeup_is_file?\n      filename = @assessment.writeup_path\n      send_file(filename,\n                type: mime_type_from_ext(File.extname(filename)),\n                disposition: \"inline\",\n                file: File.basename(filename))\n      return\n    end\n\n    flash.now[:error] = \"There is no writeup for this assessment.\"\n  end\n\n  # uninstall - uninstalls an assessment\n  def uninstall(name)\n    if name.blank?\n      flash[:error] = \"Name cannot be blank\"\n      return\n    end\n    @assessment.destroy\n    f = Rails.root.join(\"assessmentConfig\", \"#{@course.name}-#{name}.rb\")\n    File.delete(f)\n  end\n\nprotected\n\n  # We only do this so that it can be overwritten by modules\n  def updateScore(_user, score)\n    score.save!\n    true\n  end\n\n  # This does nothing on purpose\n  def loadHandinPage; end\n\n  def releaseMatchingGrades\n    num_released = 0\n\n    @assessment.problems.each do |problem|\n      @assessment.submissions.find_each do |sub|\n        next unless yield(sub, problem)\n\n        score = problem.scores.where(submission_id: sub.id).first\n\n        # if score already exists and isn't released, release it\n        if score\n          unless score.released\n            score.released = true\n            num_released += 1\n          end\n\n          # if score doesn't exist yet, create it and release it\n        else\n          score = problem.scores.new(submission: sub,\n                                     released: true,\n                                     grader: @cud)\n          num_released += 1\n        end\n\n        updateScore(sub.course_user_datum_id, score)\n      end\n    end\n\n    num_released\n  end\n\nprivate\n\n  def new_assessment_params\n    ass = params.require(:assessment)\n    ass[:category_name] = params[:new_category] if params[:new_category].present?\n    ass.permit(:name, :display_name, :category_name, :has_svn, :has_lang, :group_size,\n               :embedded_quiz, :embedded_quiz_form_data, :github_submission_enabled)\n  end\n\n  def edit_assessment_params\n    ass = params.require(:assessment)\n    ass[:category_name] = params[:new_category] if params[:new_category].present?\n\n    if ass[:late_penalty_attributes] && ass[:late_penalty_attributes][:value].blank?\n      ass.delete(:late_penalty_attributes)\n      @assessment.late_penalty&.destroy\n    end\n\n    if ass[:version_penalty_attributes] && ass[:version_penalty_attributes][:value].blank?\n      ass.delete(:version_penalty_attributes)\n      @assessment.version_penalty&.destroy\n    end\n\n    ass.delete(:name)\n    ass.delete(:config_file)\n\n    ass.permit!\n  end\n\n  ##\n  # a valid assessment tar has a single root directory that's named after the\n  # assessment, containing an assessment yaml file and an assessment ruby file\n  #\n  def valid_asmt_tar(tar_extract)\n    asmt_name = nil\n    asmt_rb_exists = false\n    asmt_yml_exists = false\n    asmt_name_is_valid = true\n    tar_extract.each do |entry|\n      pathname = entry.full_name\n      next if pathname.start_with? \".\"\n\n      # Removes file created by Mac when tar'ed\n      next if pathname.start_with? \"PaxHeader\"\n\n      pathname.chomp!(\"/\") if entry.directory?\n      # nested directories are okay\n      if entry.directory? && pathname.count(\"/\") == 0\n        return false if asmt_name\n\n        asmt_name = pathname\n      else\n        return false unless asmt_name\n\n        if pathname == \"#{asmt_name}/#{asmt_name}.rb\"\n          # We only ever read once, so no need to rewind after\n          config_source = entry.read\n\n          # validate syntax of config\n          RubyVM::InstructionSequence.compile(config_source)\n\n          asmt_rb_exists = true\n        end\n        asmt_yml_exists = true if pathname == \"#{asmt_name}/#{asmt_name}.yml\"\n      end\n    end\n    # it is possible that the assessment path does not match the\n    # the expected assessment path when the Ruby config file\n    # has a different name then the pathname\n    if !asmt_name.nil? && asmt_name =~ /[^a-z0-9]/\n      flash[:error] = \"Errors found in tarball: Assessment name #{asmt_name} is invalid.\n                       Assessment file names must only contain lowercase\n                       letters and digits with no spaces.\"\n      asmt_name_is_valid = false\n    end\n    if !(asmt_rb_exists && asmt_yml_exists && !asmt_name.nil?)\n      flash[:error] = \"Errors found in tarball:\"\n      if !asmt_yml_exists && !asmt_name.nil?\n        flash[:error] += \"<br>Assessment yml file #{asmt_name}/#{asmt_name}.yml was not found\"\n      end\n      if !asmt_rb_exists && !asmt_name.nil?\n        flash[:error] += \"<br>Assessment rb file #{asmt_name}/#{asmt_name}.rb was not found\"\n      end\n    end\n    [asmt_rb_exists && asmt_yml_exists && !asmt_name.nil? && asmt_name_is_valid, asmt_name]\n  end\n\n  def tab_index\n    # Get the current tab's redirect path by checking the submit tag\n    # which tells us which submit button in the edit form was clicked\n    tab_name = \"basic\"\n    if params[:handin]\n      tab_name = \"handin\"\n    elsif params[:penalties]\n      tab_name = \"penalties\"\n    elsif params[:problems]\n      tab_name = \"problems\"\n    elsif params[:advanced]\n      tab_name = \"advanced\"\n    end\n\n    \"#{edit_course_assessment_path(@course, @assessment)}/#tab_#{tab_name}\"\n  end\n\n  def destroy_no_redirect\n    @assessment.submissions.each(&:destroy)\n\n    @assessment.attachments.each(&:destroy)\n\n    # Delete config file copy in assessmentConfig\n    if File.exist? @assessment.config_file_path\n      File.delete @assessment.config_file_path\n    end\n    if File.exist? @assessment.config_backup_file_path\n      File.delete @assessment.config_backup_file_path\n    end\n\n    @assessment.destroy # awwww!!!!\n  end\nend\n", "require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"pathname\"\nrequire \"statistics\"\n\nclass CoursesController < ApplicationController\n  skip_before_action :set_course, only: %i[courses_redirect index new create]\n  # you need to be able to pick a course to be authorized for it\n  skip_before_action :authorize_user_for_course, only: %i[courses_redirect index new create]\n  # if there's no course, there are no persistent announcements for that course\n  skip_before_action :update_persistent_announcements, only: %i[courses_redirect index new create]\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  def index\n    courses_for_user = User.courses_for_user current_user\n\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n  end\n\n  def courses_redirect\n    courses_for_user = User.courses_for_user current_user\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n    # if only enrolled in one course (currently), go to that course\n    # only happens when first loading the site, not when user goes back to courses\n    if @listing[:current].one?\n      course_name = @listing[:current][0].name\n      redirect_to course_assessments_url(course_name)\n    else\n      redirect_to(action: :index)\n    end\n  end\n\n  action_auth_level :show, :student\n  def show\n    redirect_to course_assessments_url(@course)\n  end\n\n  ROSTER_COLUMNS_S15 = 29\n  ROSTER_COLUMNS_F16 = 32\n  ROSTER_COLUMNS_F20 = 34\n\n  action_auth_level :manage, :instructor\n  def manage\n    matrix = GradeMatrix.new @course, @cud\n    cols = {}\n    # extract assessment final scores\n    @course.assessments.each do |asmt|\n      next unless matrix.has_assessment? asmt.id\n\n      cells = matrix.cells_for_assessment asmt.id\n      final_scores = cells.map { |c| c[\"final_score\"] }\n      cols[asmt.name] = [\"asmt\", asmt, final_scores]\n    end\n\n    # category averages\n    @course.assessment_categories.each do |cat|\n      next unless matrix.has_category? cat\n\n      cols[\"#{cat} Average\"] = [\"avg\", nil, matrix.averages_for_category(cat)]\n    end\n\n    # course averages\n    cols[\"Course Average\"] = [\"avg\", nil, matrix.course_averages]\n\n    # calculate statistics\n    # send course_stats back in the form of\n    # name of average / assesment -> [type, asmt, statistics]\n    # where type = \"asmt\" or \"avg\" (assessment or average)\n    # asmt = assessment object or nil if an average of category / class\n    # statistics (statistics pertaining to asmt/avg (mean, median, std dev, etc))\n    @course_stats = {}\n    stat = Statistics.new\n    cols.each do |key, values|\n      @course_stats[key] = [values[0], values[1], stat.stats(values[2])]\n    end\n  end\n\n  def new\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n    @newCourse = Course.new\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.version_penalty = Penalty.new\n  end\n\n  def create\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n\n    @newCourse = Course.new(new_course_params)\n\n    @newCourse.display_name = @newCourse.name\n\n    # fill temporary values in other fields\n    @newCourse.late_slack = 0\n    @newCourse.grace_days = 0\n    @newCourse.start_date = Time.zone.now\n    @newCourse.end_date = Time.zone.now\n\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.late_penalty.kind = \"points\"\n    @newCourse.late_penalty.value = \"0\"\n\n    @newCourse.version_penalty = Penalty.new\n    @newCourse.version_penalty.kind = \"points\"\n    @newCourse.version_penalty.value = \"0\"\n\n    if @newCourse.save\n      instructor = User.where(email: params[:instructor_email]).first\n\n      # create a new user as instructor if he didn't exist\n      if instructor.nil?\n        begin\n          instructor = User.instructor_create(params[:instructor_email],\n                                              @newCourse.name)\n        rescue StandardError => e\n          # roll back course creation\n          @newCourse.destroy\n          flash[:error] = \"Can't create instructor for the course: #{e}\"\n          render(action: \"new\") && return\n        end\n\n      end\n\n      new_cud = @newCourse.course_user_data.new\n      new_cud.user = instructor\n      new_cud.instructor = true\n\n      if new_cud.save\n        begin\n          @newCourse.reload_course_config\n        rescue StandardError, SyntaxError\n          # roll back course creation and instruction creation\n          new_cud.destroy\n          @newCourse.destroy\n          flash[:error] = \"Can't load course config for #{@newCourse.name}.\"\n          render(action: \"new\") && return\n        else\n          flash[:success] = \"New Course #{@newCourse.name} successfully created!\"\n          redirect_to(edit_course_path(@newCourse)) && return\n        end\n      else\n        # roll back course creation\n        @newCourse.destroy\n        flash[:error] = \"Can't create instructor for the course.\"\n        render(action: \"new\") && return\n      end\n\n    else\n      flash[:error] = \"Course creation failed. Check all fields\"\n      render(action: \"new\") && return\n    end\n  end\n\n  action_auth_level :edit, :instructor\n  def edit; end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_config_file = params[:editCourse][:config_file]\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      course_config_source_path = @course.source_config_file_path\n      File.open(course_config_source_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @course.reload_course_config\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    if @course.update(edit_course_params)\n      flash[:success] = \"Course configuration updated!\"\n    else\n      flash[:error] = \"Error: There were errors editing the course.\"\n      @course.errors.full_messages.each do |msg|\n        flash[:error] += \"<br>#{msg}\"\n      end\n      flash[:html_safe] = true\n    end\n    redirect_to edit_course_path(@course)\n  end\n\n  # DELETE courses/:id/\n  action_auth_level :destroy, :administrator\n  def destroy\n    # Delete config file copy in courseConfig\n    if File.exist? @course.config_file_path\n      File.delete @course.config_file_path\n    end\n    if File.exist? @course.config_backup_file_path\n      File.delete @course.config_backup_file_path\n    end\n\n    if @course.destroy\n      flash[:success] = \"Course destroyed.\"\n    else\n      flash[:error] = \"Error: Course wasn't destroyed!\"\n    end\n    redirect_to(courses_path) && return\n  end\n\n  # Non-RESTful Routes Below\n\n  def report_bug\n    return unless request.post?\n\n    CourseMailer.bug_report(\n      params[:title],\n      params[:summary],\n      current_user,\n      @course\n    ).deliver\n  end\n\n  # Only instructor (and above) can use this feature\n  # to look up user accounts and fill in cud fields\n  action_auth_level :user_lookup, :instructor\n  def user_lookup\n    if params[:email].empty?\n      flash[:error] = \"No email supplied for LDAP Lookup\"\n      render(action: :new, layout: false) && return\n    end\n\n    # make sure that user already exists in the database\n    user = User.where(email: params[:email]).first\n\n    render(json: nil) && return if user.nil?\n\n    @user_data = { first_name: user.first_name,\n                   last_name: user.last_name,\n                   email: user.email }\n\n    render json: @user_data\n  end\n\n  action_auth_level :users, :instructor\n  def users\n    @cuds = if params[:search]\n              # left over from when AJAX was used to find users on the admin users list\n              @course.course_user_data.joins(:user)\n                     .order(\"users.email ASC\")\n                     .where(CourseUserDatum\n                                .conditions_by_like(params[:search]))\n            else\n              @course.course_user_data.joins(:user).order(\"users.email ASC\")\n            end\n  end\n\n  action_auth_level :add_users_from_emails, :instructor\n  def add_users_from_emails\n    # check if user_emails and role exist in params\n    unless params.key?(:user_emails) && params.key?(:role)\n      flash[:error] = \"No user emails or role supplied\"\n      redirect_to(users_course_path(@course)) && return\n    end\n\n    user_emails = params[:user_emails].split(/\\n/).map(&:strip)\n\n    user_emails = user_emails.map do |email|\n      if email.nil?\n        nil\n        # when it's first name <email>\n      elsif email =~ /(.*)\\s+(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), middle_name: Regexp.last_match(2),\n          last_name: Regexp.last_match(3), email: Regexp.last_match(4) }\n        # when it's email\n      elsif email =~ /(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), last_name: Regexp.last_match(2),\n          email: Regexp.last_match(3) }\n        # when it's first name middle name last name <email>\n      elsif email =~ /(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), email: Regexp.last_match(2) }\n        # when it's first name last name <email>\n      else\n        { email: email }\n      end\n    end\n\n    # filter out nil emails\n    user_emails = user_emails.reject(&:nil?)\n\n    # check if email matches regex\n    email_regex = /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n    # raise error if any email is invalid and return which emails are invalid\n    invalid_emails = user_emails.reject { |user| user[:email] =~ email_regex }\n    if invalid_emails.any?\n      flash[:error] = \"Invalid email(s): #{invalid_emails.map { |user| user[:email] }.join(', ')}\"\n      redirect_to([:users, @course]) && return\n    end\n\n    role = params[:role]\n\n    @cuds = []\n    user_emails.each do |email|\n      user = User.find_by(email: email[:email])\n\n      # create users if they don't exist\n      if user.nil?\n        begin\n          user = if email[:first_name].nil? && email[:last_name].nil?\n                   User.roster_create(email[:email], email[:email], \"\", \"\", \"\", \"\")\n                 else\n                   User.roster_create(email[:email], email[:first_name] || \"\",\n                                      email[:last_name] || \"\", \"\", \"\", \"\")\n                 end\n        rescue StandardError => e\n          flash[:error] = \"Error: #{e.message}\"\n          redirect_to([:users, @course]) && return\n        end\n\n        if user.nil?\n          flash[:error] = \"Error: User #{email} could not be created.\"\n          redirect_to([:users, @course]) && return\n        end\n      end\n\n      # if user already exists in the course, retrieve the cud\n      cud = @course.course_user_data.find_by(user_id: user.id)\n\n      # if user doesn't exist in the course, create a new cud\n      if cud.nil?\n        cud = @course.course_user_data.new\n        cud.user = user\n      end\n\n      # set the role of the user\n      case role\n      when \"instructor\"\n        cud.instructor = true\n        cud.course_assistant = false\n      when \"ca\"\n        cud.instructor = false\n        cud.course_assistant = true\n      when \"student\"\n        cud.instructor = false\n        cud.course_assistant = false\n      # if role is not valid, return error\n      else\n        flash[:error] = \"Error: Invalid role #{role}.\"\n        redirect_to([:users, @course]) && return\n      end\n\n      # add the cud to the list of cuds to be saved\n      @cuds << cud\n    end\n\n    # save all the cuds\n    if @cuds.all?(&:save)\n      flash[:success] = \"Success: Users added to course.\"\n    else\n      flash[:error] = \"Error: Users could not be added to course.\"\n    end\n    redirect_to([:users, @course]) && return\n  end\n\n  action_auth_level :unlink_course, :instructor\n  def unlink_course\n    lcd = LtiCourseDatum.find_by(course_id: @course.id)\n\n    if lcd.nil?\n      flash[:error] = \"Unable to unlink course\"\n      redirect_to(action: :users) && return\n    end\n\n    lcd.destroy\n    flash[:success] = \"Course unlinked\"\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :update_lti_settings, :instructor\n  def update_lti_settings\n    lcd = @course.lti_course_datum\n    lcd.drop_missing_students = params[:lcd][:drop_missing_students] == \"1\"\n    lcd.save\n\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :reload, :instructor\n  def reload\n    @course.reload_course_config\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Course config file reloaded!\"\n    redirect_to([@course]) && return\n  end\n\n  # Upload a CSV roster and import the users into the course\n  # Colors are associated to each row of CUD after roster is processed:\n  #   green - User doesn't exist in the course, and is going to be added\n  #   red - User is going to be dropped from the course\n  #   black - User exists in the course\n  action_auth_level :upload_roster, :instructor\n  def upload_roster\n    return unless request.post?\n\n    # Check if any file is attached\n    if params[\"upload\"] && params[\"upload\"][\"file\"].nil?\n      flash[:error] = \"Please attach a roster!\"\n      redirect_to(action: :upload_roster) && return\n    end\n\n    if params[:doIt]\n      begin\n        save_uploaded_roster\n        flash[:success] = \"Successfully updated roster!\"\n        redirect_to(action: \"users\") && return\n      rescue StandardError => e\n        if e != \"Roster validation error\"\n          flash[:error] = e\n        end\n        redirect_to(action: \"upload_roster\") && return\n      end\n    else\n      parse_roster_csv\n    end\n  end\n\n  action_auth_level :download_roster, :instructor\n  def download_roster\n    @cuds = @course.course_user_data.where(instructor: false,\n                                           course_assistant: false,\n                                           dropped: false)\n    output = \"\"\n    @cuds.each do |cud|\n      user = cud.user\n      # to_csv avoids issues with commas\n      output += [@course.semester, cud.user.email, user.last_name, user.first_name,\n                 cud.school, cud.major, cud.year, cud.grade_policy,\n                 @course.name, cud.lecture, cud.section].to_csv\n    end\n    send_data output, filename: \"roster.csv\", type: \"text/csv\", disposition: \"inline\"\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    @assignDir = Rails.root.join(\"courses\", @course.name)\n    @availableAssessments = []\n    begin\n      Dir.foreach(@assignDir) do |filename|\n        if File.exist?(File.join(@assignDir, filename, \"#{filename}.rb\"))\n          # names must be only lowercase letters and digits\n          next if filename =~ /[^a-z0-9]/\n\n          # Only list assessments that aren't installed yet\n          assessment = @course.assessments.where(name: filename).first\n          @availableAssessments << filename unless assessment\n        end\n      end\n      @availableAssessments = @availableAssessments.sort\n    rescue StandardError => e\n      render(text: \"<h3>#{e}</h3>\", layout: true) && return\n    end\n  end\n\n  # email - The email action allows instructors to email the entire course, or\n  # a single section at a time.  Sections are passed via params[:section].\n  action_auth_level :email, :instructor\n  def email\n    return unless request.post?\n\n    section = (params[:section] if !params[:section].empty?)\n\n    # don't email kids who dropped!\n    @cuds = if section\n              @course.course_user_data.where(dropped: false, section: section)\n            else\n              @course.course_user_data.where(dropped: false)\n            end\n\n    bccString = make_dlist(@cuds)\n\n    @email = CourseMailer.course_announcement(\n      params[:from],\n      bccString,\n      params[:subject],\n      params[:body],\n      @cud,\n      @course\n    )\n    @email.deliver\n  end\n\n  action_auth_level :moss, :instructor\n  def moss; end\n\n  LANGUAGE_WHITELIST = %w[c cc java ml pascal ada lisp scheme haskell fortran ascii vhdl perl\n                          matlab python mips prolog spice vb csharp modula2 a8086 javascript plsql\n                          verilog].freeze\n\n  action_auth_level :run_moss, :instructor\n  def run_moss\n    # Return if we have no files to process.\n    unless params[:assessments] || params[:external_tar]\n      flash[:error] = \"No input files provided for MOSS.\"\n      redirect_to(action: :moss) && return\n    end\n    assessmentIDs = params[:assessments]\n    assessments = []\n\n    # First, validate access on each of the requested assessments\n    assessmentIDs&.keys&.each do |aid|\n      assessment = Assessment.find(aid)\n      unless assessment\n        flash[:error] = \"Invalid Assessment ID: #{aid}\"\n        redirect_to(action: :moss) && return\n      end\n      assessmentCUD = assessment.course.course_user_data.joins(:user).find_by(\n        users: { email: current_user.email }, instructor: true\n      )\n      if !assessmentCUD && !@cud.user.administrator?\n        flash[:error] = \"Invalid User\"\n        redirect_to(action: :moss) && return\n      end\n      assessments << assessment\n    end\n\n    # Create a temporary directory\n    @failures = []\n    tmp_dir = Dir.mktmpdir(\"#{@cud.user.email}Moss\", Rails.root.join(\"tmp\"))\n\n    files = params[:files]\n    base_file = params[:box_basefile]\n    max_lines = params[:box_max]\n    language = params[:box_language]\n\n    moss_params = \"\"\n    files&.each do |_, v|\n      # Space-separated patterns\n      patternList = v.split(\" \")\n      # Each pattern consists of one or more segments, where each segment consists of\n      # - a leading period (optional)\n      # - a word character (A..Z, a..z, 0..9, _), or hyphen (-), or asterisk (*)\n      # Each pattern optionally ends with a period\n      # OKAY: foo.c *.c * .c README foo_c foo-c .* **\n      # NOT OKAY: . ..\n      patternList.each do |pattern|\n        unless pattern =~ /\\A(\\.?[\\w*-])+\\.?\\z/\n          flash[:error] = \"Invalid file pattern\"\n          redirect_to(action: :moss) && return\n        end\n      end\n    end\n    unless base_file.nil?\n      extract_tar_for_moss(tmp_dir, params[:base_tar], false)\n      moss_params = [moss_params, \"-b\", @basefiles].join(\" \")\n    end\n    unless max_lines.nil?\n      params[:max_lines] = 10 if params[:max_lines] == \"\"\n      # Only accept positive integers (> 0)\n      unless params[:max_lines] =~ /\\A[1-9]([0-9]*)?\\z/\n        flash[:error] = \"Invalid max lines\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-m\", params[:max_lines]].join(\" \")\n    end\n    unless language.nil?\n      unless LANGUAGE_WHITELIST.include? params[:language_selection]\n        flash[:error] = \"Invalid language\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-l\", params[:language_selection]].join(\" \")\n    end\n\n    # Get moss flags from text field\n    moss_flags = [\"mossnet#{moss_params} -d\"].join(\" \")\n    @mossCmd = [Rails.root.join(\"vendor\", moss_flags)]\n\n    extract_asmt_for_moss(tmp_dir, assessments)\n    extract_tar_for_moss(tmp_dir, params[:external_tar], true)\n\n    # Ensure that all files in Moss tmp dir are readable\n    system(\"chmod -R a+r #{tmp_dir}\")\n    ActiveRecord::Base.clear_active_connections!\n    # Remove non text files when making a moss run\n    `~/Autolab/script/cleanMoss #{tmp_dir}`\n    # Now run the Moss command\n    @mossCmdString = @mossCmd.join(\" \")\n    @mossOutput = `#{@mossCmdString} 2>&1`\n    @mossExit = $?.exitstatus\n\n    # Clean up after ourselves (droh: leave for debugging)\n    `rm -rf #{tmp_dir}`\n  end\n\nprivate\n\n  def new_course_params\n    params.require(:newCourse).permit(:name, :semester)\n  end\n\n  def edit_course_params\n    params.require(:editCourse).permit(:semester, :website, :late_slack,\n                                       :grace_days, :display_name, :start_date, :end_date,\n                                       :disabled, :exam_in_progress, :version_threshold,\n                                       :gb_message, late_penalty_attributes: %i[kind value],\n                                                    version_penalty_attributes: %i[kind value])\n  end\n\n  def categorize_courses_for_listing(courses)\n    listing = {}\n\n    # temporal\n    listing[:current] = []\n    listing[:completed] = []\n    listing[:upcoming] = []\n\n    listing[:disabled] = []\n    # categorize\n    courses.each do |course|\n      if course.disabled?\n        listing[:disabled] << course\n      else\n        listing[course.temporal_status] << course\n      end\n    end\n\n    listing\n  end\n\n  def write_cuds(cuds)\n    rowNum = 0\n    rosterErrors = {}\n    rowCUDs = []\n    duplicates = Set.new\n\n    cuds.each do |new_cud|\n      cloneCUD = new_cud.clone\n      cloneCUD[:row_num] = rowNum + 2\n      rowCUDs.push(cloneCUD)\n\n      case new_cud[:color]\n      when \"green\"\n        # Add this user to the course\n        # Look for this user\n        email = new_cud[:email]\n        first_name = new_cud[:first_name]\n        last_name = new_cud[:last_name]\n        school = new_cud[:school]\n        major = new_cud[:major]\n        year = new_cud[:year]\n\n        if (user = User.where(email: email).first).nil?\n          begin\n            # Create a new user\n            user = User.roster_create(email, first_name, last_name, school,\n                                      major, year)\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        else\n          # Override current user\n          user.first_name = first_name\n          user.last_name = last_name\n          user.school = school\n          user.major = major\n          user.year = year\n          begin\n            user.save!\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        end\n\n        existing = @course.course_user_data.where(user: user).first\n        # Make sure this user doesn't have a cud in the course\n        if existing\n          duplicates.add(new_cud[:email])\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # Build cud\n        if !user.nil?\n          cud = @course.course_user_data.new\n          cud.user = user\n          params = ActionController::Parameters.new(\n            course_number: new_cud[:course_number],\n            lecture: new_cud[:lecture],\n            section: new_cud[:section],\n            grade_policy: new_cud[:grade_policy]\n          )\n          cud.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n\n          # Save without validations\n          cud.save(validate: false)\n        end\n\n      when \"red\"\n        # Drop this user from the course\n        existing = @course.course_user_data.includes(:user)\n                          .where(users: { email: new_cud[:email] }).first\n\n        fail \"Red CUD doesn't exist in the database.\" if existing.nil?\n\n        existing.dropped = true\n        existing.save(validate: false)\n      else\n        # Update this user's attributes.\n        existing = @course.course_user_data.includes(:user)\n                          .where(\"lower(users.email) = ?\", new_cud[:email].downcase)\n                          .references(:users).first\n        # existing = @course.course_user_data.includes(:user).\n        # where(users[:email].matches(\"%#{new_cud[:email]}%\")).first\n\n        fail \"Black CUD doesn't exist in the database.\" if existing.nil?\n\n        user = existing.user\n        if user.nil?\n          fail \"User associated to black CUD doesn't exist in the database.\"\n        end\n\n        # Update user data\n        user.first_name = new_cud[:first_name]\n        user.last_name = new_cud[:last_name]\n        user.school = new_cud[:school]\n        user.major = new_cud[:major]\n        user.year = new_cud[:year]\n\n        begin\n          user.save!\n        rescue StandardError => e\n          msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n          if !rosterErrors.key?(msg)\n            rosterErrors[msg] = []\n          end\n          rosterErrors[msg].push(cloneCUD)\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # assign attributes\n        params = ActionController::Parameters.new(\n          course_number: new_cud[:course_number],\n          lecture: new_cud[:lecture],\n          section: new_cud[:section],\n          grade_policy: new_cud[:grade_policy]\n        )\n        existing.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n        existing.dropped = false\n        existing.save(validate: false) # Save without validations.\n      end\n      rowNum += 1\n    end\n\n    rowCUDs.each do |cud|\n      next unless duplicates.include?(cud[:email])\n\n      msg = \"Validation failed: Duplicate email #{cud[:email]}\"\n      if !rosterErrors.key?(msg)\n        rosterErrors[msg] = []\n      end\n      rosterErrors[msg].push(cud)\n    end\n\n    return if rosterErrors.empty?\n\n    flash[:roster_error] = rosterErrors\n    fail \"Roster validation error\"\n  end\n\n  def save_uploaded_roster\n    cuds = []\n\n    rowNum = 0\n    until params[\"cuds\"][rowNum.to_s].nil?\n      cuds.push(params[\"cuds\"][rowNum.to_s])\n      rowNum += 1\n    end\n\n    CourseUserDatum.transaction do\n      write_cuds(cuds)\n    end\n  end\n\n  def change_view(is_sorted)\n    @cud_view = if is_sorted\n                  @sorted_cuds\n                else\n                  @cuds\n                end\n  end\n\n  def parse_roster_csv\n    # generate doIt form from the upload\n    @cuds = []\n    @currentCUDs = @course.course_user_data.all.to_a\n    @new_cuds = []\n\n    begin\n      csv = detect_and_convert_roster(params[\"upload\"][\"file\"].read)\n      csv.each do |row|\n        new_cud = { # Ignore Semester (row[0])\n          email: row[1].to_s,\n          last_name: row[2].to_s.chomp(\" \"),\n          first_name: row[3].to_s.chomp(\" \"),\n          school: row[4].to_s.chomp(\" \"),\n          major: row[5].to_s.chomp(\" \"),\n          year: row[6].to_s.chomp(\" \"),\n          grade_policy: row[7].to_s.chomp(\" \"),\n          course_number: row[8].to_s.chomp(\" \"),\n          lecture: row[9].to_s.chomp(\" \"),\n          section: row[10].to_s.chomp(\" \")\n        }\n        cud = @currentCUDs.find do |current|\n          current.user && current.user.email.downcase == new_cud[:email].downcase\n        end\n\n        if !cud\n          new_cud[:color] = \"green\"\n        else\n          @currentCUDs.delete(cud)\n        end\n        @cuds << new_cud\n      end\n    rescue CSV::MalformedCSVError => e\n      flash[:error] = \"Error parsing CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error uploading the CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n      raise e\n    end\n\n    # drop the rest if indicated\n    if params[:upload][:dropMissing] == \"1\"\n      # We never drop instructors, remove them first\n      @currentCUDs.delete_if do |cud|\n        cud.instructor? || cud.user.administrator? || cud.course_assistant?\n      end\n      @currentCUDs.each do |cud| # These are the drops\n        new_cud = {\n          email: cud.user.email,\n          last_name: cud.user.last_name,\n          first_name: cud.user.first_name,\n          school: cud.school,\n          major: cud.major,\n          year: cud.year,\n          grade_policy: cud.grade_policy,\n          course_number: cud.course_number,\n          lecture: cud.lecture,\n          section: cud.section,\n          color: \"red\"\n        }\n        @cuds << new_cud\n      end\n    end\n\n    # do dry run for error checking\n    CourseUserDatum.transaction do\n      cloned_cuds = Marshal.load(Marshal.dump(@cuds))\n      begin\n        write_cuds(cloned_cuds)\n      rescue StandardError => e\n        redirect_to(action: \"upload_roster\")\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    @sorted_cuds = @cuds.sort_by { |cud| cud[:color] || \"z\" }\n    @cud_view = @sorted_cuds\n  end\n\n  # detect_and_convert_roster - Detect the type of a roster based on roster\n  # column matching and convert to default roster\n\n  # map fields:\n  # map[0]: semester (unused)\n  # map[1]: email\n  # map[2]: last_name\n  # map[3]: first_name\n  # map[4]: school\n  # map[5]: major\n  # map[6]: year\n  # map[7]: grade_policy\n  # map[8]: course\n  # map[9]: lecture\n  # map[10]: section\n  # rubocop:disable Lint/UselessAssignment\n  def detect_and_convert_roster(roster)\n    raise \"Roster is empty\" if roster.empty?\n\n    parsedRoster = CSV.parse(roster, skip_blanks: true)\n    raise \"Roster cannot be recognized\" if parsedRoster[0][0].nil?\n\n    case parsedRoster[0].length\n    when ROSTER_COLUMNS_F20 # 34 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11 - skip), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Time Zone Code(22), Time Zone Description(23), Added By(24),\n      # Added On(25), Confirmed(26), Waitlist Position(27), Units Carried/Max Units(28),\n      # Waitlisted By(29), Waitlisted On(30), Dropped By(31), Dropped On(32), Roster As Of Date(33)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F20\n    when ROSTER_COLUMNS_F16 # 32 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Added By(22), Added On(23), Confirmed(24), Waitlist Position(25),\n      # Units Carried/Max Units(26), Waitlisted By(27), Waitlisted On(28), Dropped By(29),\n      # Dropped On(30), Roster As Of Date(31)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F16\n    when ROSTER_COLUMNS_S15 # 29 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Lecture(1), Section(2), (skip)(3), (skip)(4), Last Name(5),\n      # First Name(6), (skip)(7), Andrew ID(8), (skip)(9), School(10),\n      # Major(11), Year(12), (skip)(13), Grade Policy(14), ... [elided]\n      map = [-1, 8, 5, 6, 10, 11, 12, 14, -1, 1, 2]\n      select_columns = ROSTER_COLUMNS_S15\n    else\n      # No header row. Columns are:\n      # Semester(0 - skip), Email(1), Last Name(2), First Name(3), School(4),\n      # Major(5), Year(6), Grade Policy(7), Course(8), Lecture(9),\n      # Section(10)\n      return parsedRoster\n    end\n    # rubocop:enable Lint/UselessAssignment\n\n    # Detect if there is a header row\n    offset = if parsedRoster[0][0] == \"Semester\"\n               1\n             else\n               0\n             end\n    numRows = parsedRoster.length - offset\n    convertedRoster = Array.new(numRows) { Array.new(11) }\n\n    domain = if Rails.env.production?\n               \"andrew.cmu.edu\"\n             else\n               \"foo.bar\"\n             end\n    (0..(numRows - 1)).each do |i|\n      11.times do |j|\n        next unless map[j] >= 0\n\n        convertedRoster[i][j] = if j == 1\n                                  \"#{parsedRoster[i + offset][map[j]]}@#{domain}\"\n                                else\n                                  parsedRoster[i + offset][map[j]]\n                                end\n      end\n    end\n    convertedRoster\n  end\n\n  def extract_asmt_for_moss(tmp_dir, assessments)\n    # for each assessment\n    assessments.each do |ass|\n      # Create a directory for ths assessment\n      assDir = File.join(tmp_dir, \"#{ass.name}-#{ass.course.name}\")\n      Dir.mkdir(assDir)\n\n      # params[:isArchive] might be nil if no archive assessments are submitted\n      isArchive = params[:isArchive] && params[:isArchive][ass.id.to_s]\n\n      visitedGroups = Set.new\n\n      # For each student who submitted\n      ass.submissions.latest.each do |sub|\n        subFile = sub.handin_file_path\n        next unless subFile && File.exist?(subFile)\n\n        if ass.has_groups?\n          group_id = sub.aud.group_id\n          next if visitedGroups.include?(group_id)\n\n          visitedGroups.add(group_id)\n        end\n\n        # Create a directory for this student\n        stuDir = File.join(assDir, sub.course_user_datum.email)\n        Dir.mkdir(stuDir)\n\n        # Copy their submission over\n        FileUtils.cp(subFile, stuDir)\n\n        # Read archive files\n        next unless isArchive\n\n        # If we need to unarchive this file, then create archive reader\n        archive_path = File.join(stuDir, sub.filename)\n        begin\n          archive_extract = Archive.get_archive(archive_path)\n\n          archive_extract.each do |entry|\n            pathname = Archive.get_entry_name(entry)\n            next if Archive.looks_like_directory?(pathname)\n\n            pathname.gsub!(%r{/}, \"-\")\n            destination = File.join(stuDir, pathname)\n            # make sure all subdirectories are there\n            FileUtils.mkdir_p(File.dirname(destination))\n            File.open(destination, \"wb\") do |out|\n              out.write Archive.read_entry_file(entry)\n              begin\n                out.fsync\n              rescue StandardError\n                nil\n              end\n            end\n          end\n        rescue StandardError\n          @failures << sub.filename\n        end\n      end\n\n      # add this assessment to the moss command\n      patternList = params[\"files\"][ass.id.to_s].split(\" \")\n      patternList.each do |pattern|\n        @mossCmd << File.join(assDir, [\"*\", pattern])\n      end\n    end\n  end\n\n  def extract_tar_for_moss(tmp_dir, external_tar, archive)\n    return unless external_tar\n\n    # Directory to hold tar ball and all individual files.\n    extTarDir = File.join(tmp_dir, \"external_input\")\n    baseFilesDir = File.join(tmp_dir, \"basefiles\")\n    begin\n      Dir.mkdir(extTarDir)\n      Dir.mkdir(baseFilesDir) # To hold all basefiles\n    rescue StandardError\n      nil\n    end\n\n    # Read in the tarfile from the given source.\n    extTarPath = File.join(extTarDir, \"input_file\")\n    external_tar.rewind\n    File.open(extTarPath, \"wb\") { |f| f.write(external_tar.read) } # Write tar file.\n\n    # Directory to hold all external individual submission.\n    extFilesDir = File.join(extTarDir, \"submissions\")\n\n    begin\n      Dir.mkdir(extFilesDir) # To hold all submissions\n    rescue StandardError\n      nil\n    end\n\n    # Untar the given Tar file.\n    begin\n      archive_extract = Archive.get_archive(extTarPath)\n\n      # write each file, renaming nested files\n      archive_extract.each do |entry|\n        pathname = Archive.get_entry_name(entry)\n        next if Archive.looks_like_directory?(pathname)\n\n        output_dir = if archive\n                       extFilesDir\n                      else\n                        baseFilesDir\n                      end\n        output_file = File.join(output_dir, pathname)\n\n        # skip if the file lies outside the archive\n        next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir))\n\n        # make sure all subdirectories are there\n        File.open(output_file, \"wb\") do |out|\n          out.write Archive.read_entry_file(entry)\n          begin\n            out.fsync\n          rescue StandardError\n            nil\n          end\n        end\n      end\n    rescue StandardError\n      @failures << \"External Tar\"\n    end\n\n    # Feed the uploaded files to MOSS.\n    if archive\n      @mossCmd << File.join(extFilesDir, \"*\")\n    else\n      @basefiles = File.join(baseFilesDir, \"*\")\n    end\n  end\nend\n"], "fixing_code": ["require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"rubygems/package\"\nrequire \"statistics\"\nrequire \"yaml\"\nrequire \"utilities\"\n\nclass AssessmentsController < ApplicationController\n  include ActiveSupport::Callbacks\n  include AssessmentAutogradeCore\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/handin.rb\")\n  include AssessmentHandin\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/handout.rb\")\n  include AssessmentHandout\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/grading.rb\")\n  include AssessmentGrading\n\n  autolab_require Rails.root.join(\"app/controllers/assessment/autograde.rb\")\n  include AssessmentAutograde\n\n  # this is inherited from ApplicationController\n  before_action :set_assessment, except: %i[index new create install_assessment\n                                            importAsmtFromTar importAssessment\n                                            log_submit local_submit autograde_done]\n  before_action :set_submission, only: [:viewFeedback]\n\n  # We have to do this here, because the modules don't inherit ApplicationController.\n\n  # Grading\n  action_auth_level :bulkGrade, :course_assistant\n  action_auth_level :quickSetScore, :course_assistant\n  action_auth_level :quickSetScoreDetails, :course_assistant\n  action_auth_level :submission_popover, :course_assistant\n  action_auth_level :score_grader_info, :course_assistant\n  action_auth_level :viewGradesheet, :course_assistant\n  action_auth_level :viewGradesheet2, :course_assistant\n  action_auth_level :quickGetTotal, :course_assistant\n  action_auth_level :statistics, :instructor\n\n  # Handin\n  action_auth_level :handin, :student\n\n  # Handout\n  action_auth_level :handout, :student\n\n  # Autograde\n  action_no_auth :autograde_done\n  action_auth_level :regrade, :instructor\n  action_auth_level :regradeAll, :instructor\n  action_no_auth :log_submit\n  action_no_auth :local_submit\n\n  # SVN\n  autolab_require Rails.root.join(\"app/controllers/assessment/svn.rb\")\n  include AssessmentSVN\n  action_auth_level :admin_svn, :instructor\n  action_auth_level :set_repo, :instructor\n  action_auth_level :import_svn, :instructor\n\n  def index\n    @is_instructor = @cud.has_auth_level? :instructor\n    announcements_tmp = Announcement.where(\"start_date < :now AND end_date > :now\",\n                                           now: Time.current)\n                                    .where(persistent: false)\n    @announcements = announcements_tmp.where(course_id: @course.id)\n                                      .or(announcements_tmp.where(system: true)).order(:start_date)\n    @attachments = if @cud.instructor?\n                     @course.attachments\n                   else\n                     # Attachments that are released, and whose related assessment is also released\n                     course_attachments = @course.attachments\n                                                 .where(released: true)\n                                                 .left_outer_joins(:assessment)\n\n                     # Either assessment_id is nil (i.e. course attachment)\n                     # Or the assessment has started\n                     course_attachments.where(assessment_id: nil)\n                                       .or(course_attachments.where(\"assessments.start_at < ?\",\n                                                                    Time.current))\n                   end\n  end\n\n  # GET /assessments/new\n  # Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :new, :instructor\n\n  def new\n    @assessment = @course.assessments.new\n    return if GithubIntegration.connected\n\n    @assessment.github_submission_enabled = false\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory on file system, or from an uploaded\n  # tar file with the assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    ass_dir = Rails.root.join(\"courses\", @course.name)\n    @unused_config_files = []\n    Dir.foreach(ass_dir) do |filename|\n      # skip if not directory in folder\n      next if !File.directory?(File.join(ass_dir,\n                                         filename)) || (filename == \"..\") || (filename == \".\")\n\n      # assessment names must be only lowercase letters and digits\n      if filename =~ /[^a-z0-9]/\n        # add line break if adding to existing error message\n        flash.now[:error] = flash.now[:error] ? \"#{flash.now[:error]} <br>\" : \"\"\n        flash.now[:error] += \"An error occurred while trying to display an existing assessment \" \\\n            \"on file directory #{filename}: assessment file names must only contain lowercase \" \\\n            \"letters and digits with no spaces\"\n        flash.now[:html_safe] = true\n        next\n      end\n\n      # each assessment must have an associated yaml file\n      unless File.exist?(File.join(ass_dir, filename, \"#{filename}.yml\"))\n        flash.now[:error] = flash.now[:error] ? \"#{flash.now[:error]} <br>\" : \"\"\n        flash.now[:error] += \"An error occurred while trying to display an existing assessment \" \\\n          \"on file directory #{filename}: #{filename}.yml does not exist\"\n        flash.now[:html_safe] = true\n        next\n      end\n\n      # Only list assessments that aren't installed yet\n      assessment_exists = @course.assessments.exists?(name: filename)\n      @unused_config_files << filename unless assessment_exists\n    end\n    @unused_config_files.sort!\n  end\n\n  action_auth_level :importAsmtFromTar, :instructor\n\n  def importAsmtFromTar\n    tarFile = params[\"tarFile\"]\n    if tarFile.nil?\n      flash[:error] = \"Please select an assessment tarball for uploading.\"\n      redirect_to(action: \"install_assessment\")\n      return\n    end\n\n    begin\n      tarFile = File.new(tarFile.open, \"rb\")\n      tar_extract = Gem::Package::TarReader.new(tarFile)\n      tar_extract.rewind\n      is_valid_tar, asmt_name = valid_asmt_tar(tar_extract)\n      tar_extract.close\n      unless is_valid_tar\n        flash[:error] +=\n          \"<br>Invalid tarball. A valid assessment tar has a single root \"\\\n          \"directory that's named after the assessment, containing an \"\\\n          \"assessment yaml file and an assessment ruby file.\"\n        flash[:html_safe] = true\n        redirect_to(action: \"install_assessment\") && return\n      end\n    rescue SyntaxError => e\n      flash[:error] = \"Error parsing assessment configuration file:\"\n      # escape so that <compiled> doesn't get treated as a html tag\n      flash[:error] += \"<br><pre>#{CGI.escapeHTML e.to_s}</pre>\"\n      flash[:html_safe] = true\n      redirect_to(action: \"install_assessment\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error while reading the tarball -- #{e.message}.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    # Check if the assessment already exists.\n    unless @course.assessments.find_by(name: asmt_name).nil?\n      flash[:error] =\n        \"An assessment with the same name already exists for the course. \"\\\n        \"Please use a different name.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    # If all requirements are satisfied, extract assessment files.\n    begin\n      course_root = Rails.root.join(\"courses\", @course.name)\n      assessment_path = Rails.root.join(\"courses\", @course.name, asmt_name)\n      tar_extract.rewind\n      tar_extract.each do |entry|\n        relative_pathname = entry.full_name\n        entry_file = File.join(course_root, relative_pathname)\n        # Ensure file will lie within course, otherwise skip\n        next unless Archive.in_dir?(Pathname(entry_file), Pathname(assessment_path))\n\n        if entry.directory?\n          FileUtils.mkdir_p(entry_file,\n                            mode: entry.header.mode, verbose: false)\n        elsif entry.file?\n          FileUtils.mkdir_p(File.join(course_root, File.dirname(relative_pathname)),\n                            mode: entry.header.mode, verbose: false)\n          File.open(entry_file, \"wb\") do |f|\n            f.write entry.read\n          end\n          FileUtils.chmod entry.header.mode, entry_file,\n                          verbose: false\n        elsif entry.header.typeflag == \"2\"\n          File.symlink entry.header.linkname, entry_file\n        end\n      end\n      tar_extract.close\n    rescue StandardError => e\n      flash[:error] = \"Error while extracting tarball to server -- #{e.message}.\"\n      redirect_to(action: \"install_assessment\") && return\n    end\n\n    params[:assessment_name] = asmt_name\n    importAssessment && return\n  end\n\n  # importAssessment - Imports an existing assessment from local file.\n  # The main task of this function is to decide what category a newly\n  # installed assessment should be assigned to.\n  action_auth_level :importAssessment, :instructor\n\n  def importAssessment\n    @assessment = @course.assessments.new(name: params[:assessment_name])\n    assessment_path = Rails.root.join(\"courses/#{@course.name}/#{@assessment.name}\")\n    # not sure if this check is 100% necessary anymore, but is a last resort\n    # against creating an invalid assessment\n    if params[:assessment_name] != @assessment.name\n      flash[:error] = \"Error creating assessment: Config module is named #{@assessment.name}\n                       but assessment file name is #{params[:assessment_name]}\"\n      # destroy model\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n\n    begin\n      @assessment.load_yaml # this will save the assessment\n    rescue StandardError => e\n      flash[:error] = \"Error loading yaml: #{e}\"\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n    @assessment.load_embedded_quiz # this will check and load embedded quiz\n    @assessment.construct_folder # make sure there's a handin folder, just in case\n    begin\n      @assessment.load_config_file # only call this on saved assessments\n    rescue StandardError => e\n      flash[:error] = \"Error loading config module: #{e}\"\n      destroy_no_redirect\n      # need to delete explicitly b/c the paths don't match\n      FileUtils.rm_rf(assessment_path)\n      redirect_to(install_assessment_course_assessments_path(@course)) && return\n    end\n    flash[:success] = \"Successfully imported #{@assessment.name}\"\n    redirect_to([@course, @assessment])\n  end\n\n  # create - Creates an assessment from an assessment directory\n  # residing in the course directory.\n  action_auth_level :create, :instructor\n\n  def create\n    @assessment = @course.assessments.new(new_assessment_params)\n\n    if @assessment.name.blank?\n      # Validate the name\n      ass_name = @assessment.display_name.downcase.gsub(/[^a-z0-9]/, \"\")\n\n      if ass_name.blank?\n        flash[:error] =\n          \"Assessment name is blank or contains characters that are not lowercase letters or digits\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n\n      # Update name in object\n      @assessment.name = ass_name\n    end\n\n    # fill in other fields\n    @assessment.course = @course\n    @assessment.handin_directory = \"handin\"\n\n    @assessment.handin_filename = if @assessment.github_submission_enabled\n                                    \"handin.tgz\"\n                                  else\n                                    \"handin.c\"\n                                  end\n\n    @assessment.visible_at = Time.current + 1.day\n    @assessment.start_at = Time.current + 1.day\n    @assessment.due_at = Time.current + 1.day\n    @assessment.end_at = Time.current + 1.day\n    @assessment.grading_deadline = Time.current + 1.day\n    @assessment.quiz = false\n    @assessment.quizData = \"\"\n    @assessment.max_submissions = params.include?(:max_submissions) ? params[:max_submissions] : -1\n\n    if @assessment.embedded_quiz\n      begin\n        @assessment.embedded_quiz_form_data = params[:assessment][:embedded_quiz_form].read\n      rescue StandardError\n        flash[:error] = \"Embedded quiz form cannot be empty!\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n    end\n\n    begin\n      @assessment.construct_folder\n    rescue StandardError => e\n      # Something bad happened. Undo everything\n      flash[:error] = e.to_s\n      begin\n        FileUtils.remove_dir(@assessment.folder_path)\n      rescue StandardError => e2\n        flash[:error] += \"An error occurred (#{e2}} \" \\\n          \" while recovering from a previous error (#{flash[:error]})\"\n        redirect_to(action: :install_assessment)\n        return\n      end\n    end\n\n    # From here on, if something weird happens, we rollback\n    begin\n      @assessment.save!\n    rescue StandardError => e\n      flash[:error] = \"Error saving #{@assessment.name}: #{e}\"\n      redirect_to(action: :install_assessment)\n      return\n    end\n\n    # reload the assessment's config file\n    @assessment.load_config_file # only call this on saved assessments\n\n    flash[:success] = \"Successfully installed #{@assessment.name}.\"\n    # reload the course config file\n    @course.reload_course_config\n\n    redirect_to([@course, @assessment]) && return\n  end\n\n  def assessmentInitialize(assignName)\n    @assessment = @course.assessments.find_by(name: assignName)\n    raise \"Assessment #{assignName} does not exist!\" unless @assessment\n\n    if @assessment.nil?\n      flash[:error] = \"Error: Invalid assessment\"\n      redirect_to([@course, :assessments]) && return\n    end\n\n    @name = @assessment.name\n    @description = @assessment.description\n    @start_at = @assessment.start_at\n    @due_at = @assessment.due_at\n    @end_at = @assessment.end_at\n    @visible_at = @assessment.visible_at\n    @id = @assessment.id\n  end\n\n  # installProblems - If there are no problems defined yet for this\n  # assessment, then create them using the list defined by the #\n  # assessmentInitialize() function in the user's assessment.rb\n  # file.\n  #\n  # Note: this is only here for backward compatibility. In the\n  # current system, problems definitions are imported from the\n  # assessment properties yaml file.\n  def installProblems\n    redirect_to(action: \"index\") && return unless @cud.instructor?\n\n    return unless @assessment.problems.count == 0\n\n    @problems.each do |problem|\n      @assessment.problems.create do |p|\n        p.name = problem[\"name\"]\n        p.description = problem[\"description\"]\n        p.max_score = problem[\"max_score\"]\n        p.optional = problem[\"optional\"]\n      end\n    end\n  end\n\n  # raw_score\n  # @param map of problem names to problem scores\n  # @return score on this assignment not including any tweak or late penalty.\n  # We generically cast all values to floating point numbers because we don't\n  # trust the upstream developer to do that for us.\n  def raw_score(scores)\n    if @assessment.has_autograder? &&\n       @assessment.overwrites_method?(:raw_score)\n      sum = @assessment.config_module.raw_score(scores)\n    else\n      sum = 0.0\n      scores.each_value { |value| sum += value.to_f }\n    end\n\n    sum\n  end\n\n  def grade\n    @problem = @assessment.problems.find(params[:problem])\n    @submission = @assessment.submissions.find(params[:submission])\n    # Shows a form which has the submission on top, and feedback on bottom\n    begin\n      subFile = Rails.root.join(\"courses\", @course.name, @assessment.name,\n                                @assessment.handin_directory,\n                                @submission.filename)\n      @submissionData = File.read(subFile)\n    rescue StandardError\n      flash[:error] = \"Could not read #{subFile}\"\n    end\n    @score = @submission.scores.where(problem_id: @problem.id).first\n  end\n\n  def getAssessmentVariable(key)\n    @assessmentVariables&.key(key)\n  end\n\n  # export - export an assessment by saving its persistent\n  # properties in a yaml properties file.\n  action_auth_level :export, :instructor\n\n  def export\n    base_path = Rails.root.join(\"courses\", @course.name).to_s\n    asmt_dir = @assessment.name\n    begin\n      # Update the assessment config YAML file.\n      @assessment.dump_yaml\n      # Save embedded_quiz\n      @assessment.dump_embedded_quiz\n      # Pack assessment directory into a tarball.\n      tarStream = StringIO.new(\"\")\n      Gem::Package::TarWriter.new(tarStream) do |tar|\n        tar.mkdir asmt_dir, File.stat(File.join(base_path, asmt_dir)).mode\n        Dir[File.join(base_path, asmt_dir, \"**\")].each do |file|\n          mode = File.stat(file).mode\n          relative_path = file.sub(%r{^#{Regexp.escape base_path}/?}, \"\")\n\n          if File.directory?(file)\n            tar.mkdir relative_path, mode\n          elsif !relative_path.starts_with? File.join(@assessment.name,\n                                                      @assessment.handin_directory)\n            tar.add_file relative_path, mode do |tarFile|\n              File.open(file, \"rb\") { |f| tarFile.write f.read }\n            end\n          end\n        end\n      end\n      tarStream.rewind\n      tarStream.close\n      send_data tarStream.string.force_encoding(\"binary\"),\n                filename: \"#{@assessment.name}_#{Time.current.strftime('%Y%m%d')}.tar\",\n                content_type: \"application/x-tar\"\n    rescue SystemCallError => e\n      flash[:error] = \"Unable to update the config YAML file: #{e}\"\n      redirect_to action: \"index\"\n    rescue StandardError => e\n      flash[:error] = \"Unable to generate tarball -- #{e.message}\"\n      redirect_to action: \"index\"\n    end\n  end\n\n  action_auth_level :destroy, :instructor\n\n  def destroy\n    @assessment.submissions.each(&:destroy)\n\n    @assessment.attachments.each(&:destroy)\n\n    # Delete config file copy in assessmentConfig\n    if File.exist? @assessment.config_file_path\n      File.delete @assessment.config_file_path\n    end\n    if File.exist? @assessment.config_backup_file_path\n      File.delete @assessment.config_backup_file_path\n    end\n\n    name = @assessment.display_name\n    @assessment.destroy # awwww!!!!\n    flash[:success] = \"The assessment #{name} has been deleted.\"\n    redirect_to(course_path(@course)) && return\n  end\n\n  action_auth_level :show, :student\n\n  def show\n    set_handin\n    extend_config_module(@assessment, @submission, @cud)\n\n    @aud = @assessment.aud_for @cud.id\n\n    @list = {}\n    @list_title = {}\n\n    if @assessment.overwrites_method?(:listOptions)\n      list = @list\n      @list = @assessment.config_module.listOptions(list)\n    end\n\n    # Remember the student ID in case the user wants visit the gradesheet\n    session[\"gradeUser#{@assessment.id}\"] = params[:cud_id] if params[:cud_id]\n\n    @startTime = Time.current\n    @effectiveCud = if @cud.instructor? && params[:cud_id]\n                      @course.course_user_data.find(params[:cud_id])\n                    else\n                      @cud\n                    end\n    @attachments = if @cud.instructor?\n                     @assessment.attachments\n                   else\n                     @assessment.attachments.where(released: true)\n                   end\n    @submissions = @assessment.submissions.where(course_user_datum_id: @effectiveCud.id)\n                              .order(\"version DESC\")\n    @extension = @assessment.extensions.find_by(course_user_datum_id: @effectiveCud.id)\n    @problems = @assessment.problems\n\n    results = @submissions.select(\"submissions.id AS submission_id\",\n                                  \"problems.id AS problem_id\",\n                                  \"scores.id AS score_id\",\n                                  \"scores.*\")\n                          .joins(\"LEFT JOIN problems ON\n        submissions.assessment_id = problems.assessment_id\")\n                          .joins(\"LEFT JOIN scores ON\n        (submissions.id = scores.submission_id\n        AND problems.id = scores.problem_id)\")\n\n    # Process them to get into a format we want.\n    @scores = {}\n    results.each do |result|\n      subId = result[\"submission_id\"].to_i\n      @scores[subId] = {} unless @scores.key?(subId)\n\n      @scores[subId][result[\"problem_id\"].to_i] = {\n        score: result[\"score\"].to_f,\n        feedback: result[\"feedback\"],\n        score_id: result[\"score_id\"].to_i,\n        released: Utilities.is_truthy?(result[\"released\"]) ? 1 : 0\n      }\n    end\n\n    # Check if we should include regrade as a function\n    @autograded = @assessment.has_autograder?\n\n    @repos = GithubIntegration.find_by(user_id: @cud.user.id)&.repositories\n  end\n\n  action_auth_level :history, :student\n\n  def history\n    # Remember the student ID in case the user wants visit the gradesheet\n    session[\"gradeUser#{@assessment.id}\"] = params[:cud_id] if params[:cud_id]\n\n    @startTime = Time.current\n    @effectiveCud = if @cud.instructor? && params[:cud_id]\n                      @course.course_user_data.find(params[:cud_id])\n                    else\n                      @cud\n                    end\n    @submissions = @assessment.submissions.where(course_user_datum_id: @effectiveCud.id)\n                              .order(\"version DESC\")\n    @extension = @assessment.extensions.find_by(course_user_datum_id: @effectiveCud.id)\n    @problems = @assessment.problems\n\n    results = @submissions.select(\"submissions.id AS submission_id\",\n                                  \"problems.id AS problem_id\",\n                                  \"scores.id AS score_id\",\n                                  \"scores.*\")\n                          .joins(\"LEFT JOIN problems ON\n        submissions.assessment_id = problems.assessment_id\")\n                          .joins(\"LEFT JOIN scores ON\n        (submissions.id = scores.submission_id\n        AND problems.id = scores.problem_id)\")\n\n    # Process them to get into a format we want.\n    @scores = {}\n    results.each do |result|\n      subId = result[\"submission_id\"].to_i\n      @scores[subId] = {} unless @scores.key?(subId)\n\n      @scores[subId][result[\"problem_id\"].to_i] = {\n        score: result[\"score\"].to_f,\n        feedback: result[\"feedback\"],\n        score_id: result[\"score_id\"].to_i,\n        released: Utilities.is_truthy?(result[\"released\"]) ? 1 : 0, # converts 't' to 1, \"f\" to 0\n      }\n    end\n\n    # Check if we should include regrade as a function\n    @autograded = @assessment.has_autograder?\n\n    return unless params[:partial]\n\n    @partial = true\n    render(\"history\", layout: false) && return\n  end\n\n  action_auth_level :viewFeedback, :student\n\n  def viewFeedback\n    # User requested to view feedback on a score\n    @score = @submission.scores.find_by(problem_id: params[:feedback])\n    # Checks whether at least one problem has finished being auto-graded\n    @finishedAutograding = @submission.scores.where.not(feedback: nil).where(grader_id: 0)\n    @job_id = @submission[\"jobid\"]\n    @submission_id = params[:submission_id]\n\n    # Autograding is not in-progress and no score is available\n    if @score.nil?\n      if !@finishedAutograding.empty?\n        redirect_to(action: \"viewFeedback\",\n                    feedback: @finishedAutograding.first.problem_id,\n                    submission_id: params[:submission_id]) && return\n      end\n\n      if @job_id.nil?\n        flash[:error] = \"No feedback for requested score\"\n        redirect_to(action: \"index\") && return\n      end\n    end\n\n    # Autograding is in-progress\n    return if @score.nil?\n\n    @jsonFeedback = parseFeedback(@score.feedback)\n    @scoreHash = parseScore(@score.feedback)\n    if Archive.archive? @submission.handin_file_path\n      @files = Archive.get_files @submission.handin_file_path\n    end\n    @problemReleased = @submission.scores.pluck(:released).all? &&\n                       !@assessment.before_grading_deadline?\n    # get_correct_filename is protected, so we wrap around controller-specific call\n    @get_correct_filename = ->(annotation) {\n      get_correct_filename(annotation, @files, @submission)\n    }\n  end\n\n  action_auth_level :getPartialFeedback, :student\n\n  def getPartialFeedback\n    job_id = params[\"job_id\"].to_i\n\n    # User requested to view feedback on a score\n    if job_id.nil?\n      flash[:error] = \"Invalid job id\"\n      redirect_to(action: \"index\") && return\n    end\n\n    begin\n      resp = get_job_status(job_id)\n\n      if resp[\"is_assigned\"]\n        resp['partial_feedback'] = tango_get_partial_feedback(job_id)\n      end\n    rescue AutogradeError => e\n      render json: { error: \"Get partial feedback request failed: #{e}\" },\n             status: :internal_server_error\n    else\n      render json: resp.to_json\n    end\n  end\n\n  def parseScore(feedback)\n    return if feedback.nil?\n\n    lines = feedback.lines\n    feedback = lines[lines.length - 1].chomp\n\n    return unless valid_json?(feedback)\n\n    score_hash = JSON.parse(feedback)\n    score_hash = score_hash[\"scores\"]\n    if @jsonFeedback&.key?(\"_scores_order\") == false\n      @jsonFeedback[\"_scores_order\"] = score_hash.keys\n    end\n    @total = 0\n    score_hash.keys.each do |k|\n      @total += score_hash[k]\n    end\n    score_hash[\"_total\"] = @total\n    score_hash\n  end\n\n  def parse_stages(jsonFeedbackHash)\n    @result = true\n    if jsonFeedbackHash.key?(\"stages\")\n      jsonFeedbackHash[\"stages\"].each do |stage|\n        if jsonFeedbackHash[stage].key?(\"_order\") == false\n          jsonFeedbackHash[stage][\"_order\"] = jsonFeedbackHash[stage].keys\n        end\n      end\n    end\n    @result\n  end\n\n  def parseFeedback(feedback)\n    return if feedback.nil?\n\n    lines = feedback.lines\n    feedback = lines[lines.length - 2]&.chomp\n\n    return unless valid_json?(feedback)\n\n    jsonFeedbackHash = JSON.parse(feedback)\n    if jsonFeedbackHash.key?(\"_presentation\") == false\n      nil\n    elsif jsonFeedbackHash[\"_presentation\"] == \"semantic\" && !parse_stages(jsonFeedbackHash).nil?\n      jsonFeedbackHash\n    end\n  end\n\n  def valid_json?(json)\n    JSON.parse(json)\n  rescue JSON::ParserError, TypeError\n    false\n  end\n\n  action_auth_level :reload, :instructor\n\n  def reload\n    @assessment.load_config_file\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Assessment config file reloaded!\"\n    redirect_to(action: :show) && return\n  end\n\n  action_auth_level :edit, :instructor\n\n  def edit\n    # default to the basic tab\n    params[:active_tab] ||= \"basic\"\n\n    # make sure the 'active_tab' is a real tab\n    unless %w[basic handin penalties problems advanced].include? params[:active_tab]\n      params[:active_tab] = \"basic\"\n    end\n\n    # make sure the penalties are set up\n    @assessment.late_penalty ||= Penalty.new(kind: \"points\")\n    @assessment.version_penalty ||= Penalty.new(kind: \"points\")\n\n    @has_annotations = @assessment.submissions.any? { |s| !s.annotations.empty? }\n\n    @is_positive_grading = @assessment.is_positive_grading\n  end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_embedded_quiz_form = params[:assessment][:embedded_quiz_form]\n    uploaded_config_file = params[:assessment][:config_file]\n    unless uploaded_embedded_quiz_form.nil?\n      @assessment.embedded_quiz_form_data = uploaded_embedded_quiz_form.read\n      @assessment.save!\n    end\n\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      assessment_config_file_path = @assessment.source_config_file_path\n      File.open(assessment_config_file_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @assessment.load_config_file\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    begin\n      @assessment.update!(edit_assessment_params)\n      flash[:success] = \"Assessment configuration updated!\"\n\n      redirect_to(tab_index) && return\n    rescue ActiveRecord::RecordInvalid => e\n      flash[:error] = e.message.sub!(\"Validation failed: \", \"\")\n\n      redirect_to(tab_index) && return\n    end\n  end\n\n  action_auth_level :releaseAllGrades, :instructor\n\n  def releaseAllGrades\n    # release all grades\n    num_released = releaseMatchingGrades { |_| true }\n\n    if num_released > 0\n      flash[:success] =\n        format(\"%<num_released>d %<plurality>s released.\",\n               num_released: num_released,\n               plurality: (num_released > 1 ? \"grades were\" : \"grade was\"))\n    else\n      flash[:error] = \"No grades were released. They might have all already been released.\"\n    end\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :releaseSectionGrades, :course_assistant\n\n  def releaseSectionGrades\n    unless @cud.section? && !@cud.section.empty? && @cud.lecture && !@cud.lecture.empty?\n      flash[:error] =\n        \"You haven't been assigned to a lecture and/or section. Please contact your instructor.\"\n      redirect_to action: \"index\"\n      return\n    end\n\n    num_released = releaseMatchingGrades do |submission, _|\n      @cud.CA_of? submission.course_user_datum\n    end\n\n    if num_released > 0\n      flash[:success] =\n        format(\"%<num_released>d %<plurality>s released.\",\n               num_released: num_released,\n               plurality: (num_released > 1 ? \"grades were\" : \"grade was\"))\n    else\n      flash[:error] = \"No grades were released. \" \\\n                      \"Either they were all already released or you \"\\\n                      \"might be assigned to a lecture \" \\\n                      \"and/or section that doesn't exist. Please contact an instructor.\"\n    end\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :withdrawAllGrades, :instructor\n\n  def withdrawAllGrades\n    @assessment.submissions.each do |submission|\n      scores = submission.scores.where(released: true)\n      scores.each do |score|\n        score.released = false\n\n        begin\n          updateScore(@assessment.course.course_user_data, score)\n        rescue ActiveRecord::RecordInvalid => e\n          flash[:error] = flash[:error] || \"\"\n          flash[:error] += \"Unable to withdraw score for \"\\\n                           \"#{@assessment.course.course_user_data.user.email}: #{e.message}\"\n        end\n      end\n    end\n\n    flash[:success] = \"Grades have been withdrawn.\"\n    redirect_to action: \"viewGradesheet\"\n  end\n\n  action_auth_level :writeup, :student\n\n  def writeup\n    # If the logic here changes, do update assessment#has_writeup?\n    if @assessment.writeup_is_url?\n      redirect_to @assessment.writeup\n      return\n    end\n\n    if @assessment.writeup_is_file?\n      filename = @assessment.writeup_path\n      send_file(filename,\n                type: mime_type_from_ext(File.extname(filename)),\n                disposition: \"inline\",\n                file: File.basename(filename))\n      return\n    end\n\n    flash.now[:error] = \"There is no writeup for this assessment.\"\n  end\n\n  # uninstall - uninstalls an assessment\n  def uninstall(name)\n    if name.blank?\n      flash[:error] = \"Name cannot be blank\"\n      return\n    end\n    @assessment.destroy\n    f = Rails.root.join(\"assessmentConfig\", \"#{@course.name}-#{name}.rb\")\n    File.delete(f)\n  end\n\nprotected\n\n  # We only do this so that it can be overwritten by modules\n  def updateScore(_user, score)\n    score.save!\n    true\n  end\n\n  # This does nothing on purpose\n  def loadHandinPage; end\n\n  def releaseMatchingGrades\n    num_released = 0\n\n    @assessment.problems.each do |problem|\n      @assessment.submissions.find_each do |sub|\n        next unless yield(sub, problem)\n\n        score = problem.scores.where(submission_id: sub.id).first\n\n        # if score already exists and isn't released, release it\n        if score\n          unless score.released\n            score.released = true\n            num_released += 1\n          end\n\n          # if score doesn't exist yet, create it and release it\n        else\n          score = problem.scores.new(submission: sub,\n                                     released: true,\n                                     grader: @cud)\n          num_released += 1\n        end\n\n        updateScore(sub.course_user_datum_id, score)\n      end\n    end\n\n    num_released\n  end\n\nprivate\n\n  def new_assessment_params\n    ass = params.require(:assessment)\n    ass[:category_name] = params[:new_category] if params[:new_category].present?\n    ass.permit(:name, :display_name, :category_name, :has_svn, :has_lang, :group_size,\n               :embedded_quiz, :embedded_quiz_form_data, :github_submission_enabled)\n  end\n\n  def edit_assessment_params\n    ass = params.require(:assessment)\n    ass[:category_name] = params[:new_category] if params[:new_category].present?\n\n    if ass[:late_penalty_attributes] && ass[:late_penalty_attributes][:value].blank?\n      ass.delete(:late_penalty_attributes)\n      @assessment.late_penalty&.destroy\n    end\n\n    if ass[:version_penalty_attributes] && ass[:version_penalty_attributes][:value].blank?\n      ass.delete(:version_penalty_attributes)\n      @assessment.version_penalty&.destroy\n    end\n\n    ass.delete(:name)\n    ass.delete(:config_file)\n\n    ass.permit!\n  end\n\n  ##\n  # a valid assessment tar has a single root directory that's named after the\n  # assessment, containing an assessment yaml file and an assessment ruby file\n  #\n  def valid_asmt_tar(tar_extract)\n    asmt_name = nil\n    asmt_rb_exists = false\n    asmt_yml_exists = false\n    asmt_name_is_valid = true\n    tar_extract.each do |entry|\n      pathname = entry.full_name\n      next if pathname.start_with? \".\"\n\n      # Removes file created by Mac when tar'ed\n      next if pathname.start_with? \"PaxHeader\"\n\n      pathname.chomp!(\"/\") if entry.directory?\n      # nested directories are okay\n      if entry.directory? && pathname.count(\"/\") == 0\n        return false if asmt_name\n\n        asmt_name = pathname\n      else\n        return false unless asmt_name\n\n        if pathname == \"#{asmt_name}/#{asmt_name}.rb\"\n          # We only ever read once, so no need to rewind after\n          config_source = entry.read\n\n          # validate syntax of config\n          RubyVM::InstructionSequence.compile(config_source)\n\n          asmt_rb_exists = true\n        end\n        asmt_yml_exists = true if pathname == \"#{asmt_name}/#{asmt_name}.yml\"\n      end\n    end\n    # it is possible that the assessment path does not match the\n    # the expected assessment path when the Ruby config file\n    # has a different name then the pathname\n    if !asmt_name.nil? && asmt_name =~ /[^a-z0-9]/\n      flash[:error] = \"Errors found in tarball: Assessment name #{asmt_name} is invalid.\n                       Assessment file names must only contain lowercase\n                       letters and digits with no spaces.\"\n      asmt_name_is_valid = false\n    end\n    if !(asmt_rb_exists && asmt_yml_exists && !asmt_name.nil?)\n      flash[:error] = \"Errors found in tarball:\"\n      if !asmt_yml_exists && !asmt_name.nil?\n        flash[:error] += \"<br>Assessment yml file #{asmt_name}/#{asmt_name}.yml was not found\"\n      end\n      if !asmt_rb_exists && !asmt_name.nil?\n        flash[:error] += \"<br>Assessment rb file #{asmt_name}/#{asmt_name}.rb was not found\"\n      end\n    end\n    [asmt_rb_exists && asmt_yml_exists && !asmt_name.nil? && asmt_name_is_valid, asmt_name]\n  end\n\n  def tab_index\n    # Get the current tab's redirect path by checking the submit tag\n    # which tells us which submit button in the edit form was clicked\n    tab_name = \"basic\"\n    if params[:handin]\n      tab_name = \"handin\"\n    elsif params[:penalties]\n      tab_name = \"penalties\"\n    elsif params[:problems]\n      tab_name = \"problems\"\n    elsif params[:advanced]\n      tab_name = \"advanced\"\n    end\n\n    \"#{edit_course_assessment_path(@course, @assessment)}/#tab_#{tab_name}\"\n  end\n\n  def destroy_no_redirect\n    @assessment.submissions.each(&:destroy)\n\n    @assessment.attachments.each(&:destroy)\n\n    # Delete config file copy in assessmentConfig\n    if File.exist? @assessment.config_file_path\n      File.delete @assessment.config_file_path\n    end\n    if File.exist? @assessment.config_backup_file_path\n      File.delete @assessment.config_backup_file_path\n    end\n\n    @assessment.destroy # awwww!!!!\n  end\nend\n", "require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"pathname\"\nrequire \"statistics\"\n\nclass CoursesController < ApplicationController\n  skip_before_action :set_course, only: %i[courses_redirect index new create]\n  # you need to be able to pick a course to be authorized for it\n  skip_before_action :authorize_user_for_course, only: %i[courses_redirect index new create]\n  # if there's no course, there are no persistent announcements for that course\n  skip_before_action :update_persistent_announcements, only: %i[courses_redirect index new create]\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  def index\n    courses_for_user = User.courses_for_user current_user\n\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n  end\n\n  def courses_redirect\n    courses_for_user = User.courses_for_user current_user\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n    # if only enrolled in one course (currently), go to that course\n    # only happens when first loading the site, not when user goes back to courses\n    if @listing[:current].one?\n      course_name = @listing[:current][0].name\n      redirect_to course_assessments_url(course_name)\n    else\n      redirect_to(action: :index)\n    end\n  end\n\n  action_auth_level :show, :student\n  def show\n    redirect_to course_assessments_url(@course)\n  end\n\n  ROSTER_COLUMNS_S15 = 29\n  ROSTER_COLUMNS_F16 = 32\n  ROSTER_COLUMNS_F20 = 34\n\n  action_auth_level :manage, :instructor\n  def manage\n    matrix = GradeMatrix.new @course, @cud\n    cols = {}\n    # extract assessment final scores\n    @course.assessments.each do |asmt|\n      next unless matrix.has_assessment? asmt.id\n\n      cells = matrix.cells_for_assessment asmt.id\n      final_scores = cells.map { |c| c[\"final_score\"] }\n      cols[asmt.name] = [\"asmt\", asmt, final_scores]\n    end\n\n    # category averages\n    @course.assessment_categories.each do |cat|\n      next unless matrix.has_category? cat\n\n      cols[\"#{cat} Average\"] = [\"avg\", nil, matrix.averages_for_category(cat)]\n    end\n\n    # course averages\n    cols[\"Course Average\"] = [\"avg\", nil, matrix.course_averages]\n\n    # calculate statistics\n    # send course_stats back in the form of\n    # name of average / assesment -> [type, asmt, statistics]\n    # where type = \"asmt\" or \"avg\" (assessment or average)\n    # asmt = assessment object or nil if an average of category / class\n    # statistics (statistics pertaining to asmt/avg (mean, median, std dev, etc))\n    @course_stats = {}\n    stat = Statistics.new\n    cols.each do |key, values|\n      @course_stats[key] = [values[0], values[1], stat.stats(values[2])]\n    end\n  end\n\n  def new\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n    @newCourse = Course.new\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.version_penalty = Penalty.new\n  end\n\n  def create\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n\n    @newCourse = Course.new(new_course_params)\n\n    @newCourse.display_name = @newCourse.name\n\n    # fill temporary values in other fields\n    @newCourse.late_slack = 0\n    @newCourse.grace_days = 0\n    @newCourse.start_date = Time.zone.now\n    @newCourse.end_date = Time.zone.now\n\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.late_penalty.kind = \"points\"\n    @newCourse.late_penalty.value = \"0\"\n\n    @newCourse.version_penalty = Penalty.new\n    @newCourse.version_penalty.kind = \"points\"\n    @newCourse.version_penalty.value = \"0\"\n\n    if @newCourse.save\n      instructor = User.where(email: params[:instructor_email]).first\n\n      # create a new user as instructor if he didn't exist\n      if instructor.nil?\n        begin\n          instructor = User.instructor_create(params[:instructor_email],\n                                              @newCourse.name)\n        rescue StandardError => e\n          # roll back course creation\n          @newCourse.destroy\n          flash[:error] = \"Can't create instructor for the course: #{e}\"\n          render(action: \"new\") && return\n        end\n\n      end\n\n      new_cud = @newCourse.course_user_data.new\n      new_cud.user = instructor\n      new_cud.instructor = true\n\n      if new_cud.save\n        begin\n          @newCourse.reload_course_config\n        rescue StandardError, SyntaxError\n          # roll back course creation and instruction creation\n          new_cud.destroy\n          @newCourse.destroy\n          flash[:error] = \"Can't load course config for #{@newCourse.name}.\"\n          render(action: \"new\") && return\n        else\n          flash[:success] = \"New Course #{@newCourse.name} successfully created!\"\n          redirect_to(edit_course_path(@newCourse)) && return\n        end\n      else\n        # roll back course creation\n        @newCourse.destroy\n        flash[:error] = \"Can't create instructor for the course.\"\n        render(action: \"new\") && return\n      end\n\n    else\n      flash[:error] = \"Course creation failed. Check all fields\"\n      render(action: \"new\") && return\n    end\n  end\n\n  action_auth_level :edit, :instructor\n  def edit; end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_config_file = params[:editCourse][:config_file]\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      course_config_source_path = @course.source_config_file_path\n      File.open(course_config_source_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @course.reload_course_config\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    if @course.update(edit_course_params)\n      flash[:success] = \"Course configuration updated!\"\n    else\n      flash[:error] = \"Error: There were errors editing the course.\"\n      @course.errors.full_messages.each do |msg|\n        flash[:error] += \"<br>#{msg}\"\n      end\n      flash[:html_safe] = true\n    end\n    redirect_to edit_course_path(@course)\n  end\n\n  # DELETE courses/:id/\n  action_auth_level :destroy, :administrator\n  def destroy\n    # Delete config file copy in courseConfig\n    if File.exist? @course.config_file_path\n      File.delete @course.config_file_path\n    end\n    if File.exist? @course.config_backup_file_path\n      File.delete @course.config_backup_file_path\n    end\n\n    if @course.destroy\n      flash[:success] = \"Course destroyed.\"\n    else\n      flash[:error] = \"Error: Course wasn't destroyed!\"\n    end\n    redirect_to(courses_path) && return\n  end\n\n  # Non-RESTful Routes Below\n\n  def report_bug\n    return unless request.post?\n\n    CourseMailer.bug_report(\n      params[:title],\n      params[:summary],\n      current_user,\n      @course\n    ).deliver\n  end\n\n  # Only instructor (and above) can use this feature\n  # to look up user accounts and fill in cud fields\n  action_auth_level :user_lookup, :instructor\n  def user_lookup\n    if params[:email].empty?\n      flash[:error] = \"No email supplied for LDAP Lookup\"\n      render(action: :new, layout: false) && return\n    end\n\n    # make sure that user already exists in the database\n    user = User.where(email: params[:email]).first\n\n    render(json: nil) && return if user.nil?\n\n    @user_data = { first_name: user.first_name,\n                   last_name: user.last_name,\n                   email: user.email }\n\n    render json: @user_data\n  end\n\n  action_auth_level :users, :instructor\n  def users\n    @cuds = if params[:search]\n              # left over from when AJAX was used to find users on the admin users list\n              @course.course_user_data.joins(:user)\n                     .order(\"users.email ASC\")\n                     .where(CourseUserDatum\n                                .conditions_by_like(params[:search]))\n            else\n              @course.course_user_data.joins(:user).order(\"users.email ASC\")\n            end\n  end\n\n  action_auth_level :add_users_from_emails, :instructor\n  def add_users_from_emails\n    # check if user_emails and role exist in params\n    unless params.key?(:user_emails) && params.key?(:role)\n      flash[:error] = \"No user emails or role supplied\"\n      redirect_to(users_course_path(@course)) && return\n    end\n\n    user_emails = params[:user_emails].split(/\\n/).map(&:strip)\n\n    user_emails = user_emails.map do |email|\n      if email.nil?\n        nil\n        # when it's first name <email>\n      elsif email =~ /(.*)\\s+(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), middle_name: Regexp.last_match(2),\n          last_name: Regexp.last_match(3), email: Regexp.last_match(4) }\n        # when it's email\n      elsif email =~ /(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), last_name: Regexp.last_match(2),\n          email: Regexp.last_match(3) }\n        # when it's first name middle name last name <email>\n      elsif email =~ /(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), email: Regexp.last_match(2) }\n        # when it's first name last name <email>\n      else\n        { email: email }\n      end\n    end\n\n    # filter out nil emails\n    user_emails = user_emails.reject(&:nil?)\n\n    # check if email matches regex\n    email_regex = /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n    # raise error if any email is invalid and return which emails are invalid\n    invalid_emails = user_emails.reject { |user| user[:email] =~ email_regex }\n    if invalid_emails.any?\n      flash[:error] = \"Invalid email(s): #{invalid_emails.map { |user| user[:email] }.join(', ')}\"\n      redirect_to([:users, @course]) && return\n    end\n\n    role = params[:role]\n\n    @cuds = []\n    user_emails.each do |email|\n      user = User.find_by(email: email[:email])\n\n      # create users if they don't exist\n      if user.nil?\n        begin\n          user = if email[:first_name].nil? && email[:last_name].nil?\n                   User.roster_create(email[:email], email[:email], \"\", \"\", \"\", \"\")\n                 else\n                   User.roster_create(email[:email], email[:first_name] || \"\",\n                                      email[:last_name] || \"\", \"\", \"\", \"\")\n                 end\n        rescue StandardError => e\n          flash[:error] = \"Error: #{e.message}\"\n          redirect_to([:users, @course]) && return\n        end\n\n        if user.nil?\n          flash[:error] = \"Error: User #{email} could not be created.\"\n          redirect_to([:users, @course]) && return\n        end\n      end\n\n      # if user already exists in the course, retrieve the cud\n      cud = @course.course_user_data.find_by(user_id: user.id)\n\n      # if user doesn't exist in the course, create a new cud\n      if cud.nil?\n        cud = @course.course_user_data.new\n        cud.user = user\n      end\n\n      # set the role of the user\n      case role\n      when \"instructor\"\n        cud.instructor = true\n        cud.course_assistant = false\n      when \"ca\"\n        cud.instructor = false\n        cud.course_assistant = true\n      when \"student\"\n        cud.instructor = false\n        cud.course_assistant = false\n      # if role is not valid, return error\n      else\n        flash[:error] = \"Error: Invalid role #{role}.\"\n        redirect_to([:users, @course]) && return\n      end\n\n      # add the cud to the list of cuds to be saved\n      @cuds << cud\n    end\n\n    # save all the cuds\n    if @cuds.all?(&:save)\n      flash[:success] = \"Success: Users added to course.\"\n    else\n      flash[:error] = \"Error: Users could not be added to course.\"\n    end\n    redirect_to([:users, @course]) && return\n  end\n\n  action_auth_level :unlink_course, :instructor\n  def unlink_course\n    lcd = LtiCourseDatum.find_by(course_id: @course.id)\n\n    if lcd.nil?\n      flash[:error] = \"Unable to unlink course\"\n      redirect_to(action: :users) && return\n    end\n\n    lcd.destroy\n    flash[:success] = \"Course unlinked\"\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :update_lti_settings, :instructor\n  def update_lti_settings\n    lcd = @course.lti_course_datum\n    lcd.drop_missing_students = params[:lcd][:drop_missing_students] == \"1\"\n    lcd.save\n\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :reload, :instructor\n  def reload\n    @course.reload_course_config\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Course config file reloaded!\"\n    redirect_to([@course]) && return\n  end\n\n  # Upload a CSV roster and import the users into the course\n  # Colors are associated to each row of CUD after roster is processed:\n  #   green - User doesn't exist in the course, and is going to be added\n  #   red - User is going to be dropped from the course\n  #   black - User exists in the course\n  action_auth_level :upload_roster, :instructor\n  def upload_roster\n    return unless request.post?\n\n    # Check if any file is attached\n    if params[\"upload\"] && params[\"upload\"][\"file\"].nil?\n      flash[:error] = \"Please attach a roster!\"\n      redirect_to(action: :upload_roster) && return\n    end\n\n    if params[:doIt]\n      begin\n        save_uploaded_roster\n        flash[:success] = \"Successfully updated roster!\"\n        redirect_to(action: \"users\") && return\n      rescue StandardError => e\n        if e != \"Roster validation error\"\n          flash[:error] = e\n        end\n        redirect_to(action: \"upload_roster\") && return\n      end\n    else\n      parse_roster_csv\n    end\n  end\n\n  action_auth_level :download_roster, :instructor\n  def download_roster\n    @cuds = @course.course_user_data.where(instructor: false,\n                                           course_assistant: false,\n                                           dropped: false)\n    output = \"\"\n    @cuds.each do |cud|\n      user = cud.user\n      # to_csv avoids issues with commas\n      output += [@course.semester, cud.user.email, user.last_name, user.first_name,\n                 cud.school, cud.major, cud.year, cud.grade_policy,\n                 @course.name, cud.lecture, cud.section].to_csv\n    end\n    send_data output, filename: \"roster.csv\", type: \"text/csv\", disposition: \"inline\"\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    @assignDir = Rails.root.join(\"courses\", @course.name)\n    @availableAssessments = []\n    begin\n      Dir.foreach(@assignDir) do |filename|\n        if File.exist?(File.join(@assignDir, filename, \"#{filename}.rb\"))\n          # names must be only lowercase letters and digits\n          next if filename =~ /[^a-z0-9]/\n\n          # Only list assessments that aren't installed yet\n          assessment = @course.assessments.where(name: filename).first\n          @availableAssessments << filename unless assessment\n        end\n      end\n      @availableAssessments = @availableAssessments.sort\n    rescue StandardError => e\n      render(text: \"<h3>#{e}</h3>\", layout: true) && return\n    end\n  end\n\n  # email - The email action allows instructors to email the entire course, or\n  # a single section at a time.  Sections are passed via params[:section].\n  action_auth_level :email, :instructor\n  def email\n    return unless request.post?\n\n    section = (params[:section] if !params[:section].empty?)\n\n    # don't email kids who dropped!\n    @cuds = if section\n              @course.course_user_data.where(dropped: false, section: section)\n            else\n              @course.course_user_data.where(dropped: false)\n            end\n\n    bccString = make_dlist(@cuds)\n\n    @email = CourseMailer.course_announcement(\n      params[:from],\n      bccString,\n      params[:subject],\n      params[:body],\n      @cud,\n      @course\n    )\n    @email.deliver\n  end\n\n  action_auth_level :moss, :instructor\n  def moss; end\n\n  LANGUAGE_WHITELIST = %w[c cc java ml pascal ada lisp scheme haskell fortran ascii vhdl perl\n                          matlab python mips prolog spice vb csharp modula2 a8086 javascript plsql\n                          verilog].freeze\n\n  action_auth_level :run_moss, :instructor\n  def run_moss\n    # Return if we have no files to process.\n    unless params[:assessments] || params[:external_tar]\n      flash[:error] = \"No input files provided for MOSS.\"\n      redirect_to(action: :moss) && return\n    end\n    assessmentIDs = params[:assessments]\n    assessments = []\n\n    # First, validate access on each of the requested assessments\n    assessmentIDs&.keys&.each do |aid|\n      assessment = Assessment.find(aid)\n      unless assessment\n        flash[:error] = \"Invalid Assessment ID: #{aid}\"\n        redirect_to(action: :moss) && return\n      end\n      assessmentCUD = assessment.course.course_user_data.joins(:user).find_by(\n        users: { email: current_user.email }, instructor: true\n      )\n      if !assessmentCUD && !@cud.user.administrator?\n        flash[:error] = \"Invalid User\"\n        redirect_to(action: :moss) && return\n      end\n      assessments << assessment\n    end\n\n    # Create a temporary directory\n    @failures = []\n    tmp_dir = Dir.mktmpdir(\"#{@cud.user.email}Moss\", Rails.root.join(\"tmp\"))\n\n    files = params[:files]\n    base_file = params[:box_basefile]\n    max_lines = params[:box_max]\n    language = params[:box_language]\n\n    moss_params = \"\"\n    files&.each do |_, v|\n      # Space-separated patterns\n      patternList = v.split(\" \")\n      # Each pattern consists of one or more segments, where each segment consists of\n      # - a leading period (optional)\n      # - a word character (A..Z, a..z, 0..9, _), or hyphen (-), or asterisk (*)\n      # Each pattern optionally ends with a period\n      # OKAY: foo.c *.c * .c README foo_c foo-c .* **\n      # NOT OKAY: . ..\n      patternList.each do |pattern|\n        unless pattern =~ /\\A(\\.?[\\w*-])+\\.?\\z/\n          flash[:error] = \"Invalid file pattern\"\n          redirect_to(action: :moss) && return\n        end\n      end\n    end\n    unless base_file.nil?\n      extract_tar_for_moss(tmp_dir, params[:base_tar], false)\n      moss_params = [moss_params, \"-b\", @basefiles].join(\" \")\n    end\n    unless max_lines.nil?\n      params[:max_lines] = 10 if params[:max_lines] == \"\"\n      # Only accept positive integers (> 0)\n      unless params[:max_lines] =~ /\\A[1-9]([0-9]*)?\\z/\n        flash[:error] = \"Invalid max lines\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-m\", params[:max_lines]].join(\" \")\n    end\n    unless language.nil?\n      unless LANGUAGE_WHITELIST.include? params[:language_selection]\n        flash[:error] = \"Invalid language\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-l\", params[:language_selection]].join(\" \")\n    end\n\n    # Get moss flags from text field\n    moss_flags = [\"mossnet#{moss_params} -d\"].join(\" \")\n    @mossCmd = [Rails.root.join(\"vendor\", moss_flags)]\n\n    extract_asmt_for_moss(tmp_dir, assessments)\n    extract_tar_for_moss(tmp_dir, params[:external_tar], true)\n\n    # Ensure that all files in Moss tmp dir are readable\n    system(\"chmod -R a+r #{tmp_dir}\")\n    ActiveRecord::Base.clear_active_connections!\n    # Remove non text files when making a moss run\n    `~/Autolab/script/cleanMoss #{tmp_dir}`\n    # Now run the Moss command\n    @mossCmdString = @mossCmd.join(\" \")\n    @mossOutput = `#{@mossCmdString} 2>&1`\n    @mossExit = $?.exitstatus\n\n    # Clean up after ourselves (droh: leave for debugging)\n    `rm -rf #{tmp_dir}`\n  end\n\nprivate\n\n  def new_course_params\n    params.require(:newCourse).permit(:name, :semester)\n  end\n\n  def edit_course_params\n    params.require(:editCourse).permit(:semester, :website, :late_slack,\n                                       :grace_days, :display_name, :start_date, :end_date,\n                                       :disabled, :exam_in_progress, :version_threshold,\n                                       :gb_message, late_penalty_attributes: %i[kind value],\n                                                    version_penalty_attributes: %i[kind value])\n  end\n\n  def categorize_courses_for_listing(courses)\n    listing = {}\n\n    # temporal\n    listing[:current] = []\n    listing[:completed] = []\n    listing[:upcoming] = []\n\n    listing[:disabled] = []\n    # categorize\n    courses.each do |course|\n      if course.disabled?\n        listing[:disabled] << course\n      else\n        listing[course.temporal_status] << course\n      end\n    end\n\n    listing\n  end\n\n  def write_cuds(cuds)\n    rowNum = 0\n    rosterErrors = {}\n    rowCUDs = []\n    duplicates = Set.new\n\n    cuds.each do |new_cud|\n      cloneCUD = new_cud.clone\n      cloneCUD[:row_num] = rowNum + 2\n      rowCUDs.push(cloneCUD)\n\n      case new_cud[:color]\n      when \"green\"\n        # Add this user to the course\n        # Look for this user\n        email = new_cud[:email]\n        first_name = new_cud[:first_name]\n        last_name = new_cud[:last_name]\n        school = new_cud[:school]\n        major = new_cud[:major]\n        year = new_cud[:year]\n\n        if (user = User.where(email: email).first).nil?\n          begin\n            # Create a new user\n            user = User.roster_create(email, first_name, last_name, school,\n                                      major, year)\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        else\n          # Override current user\n          user.first_name = first_name\n          user.last_name = last_name\n          user.school = school\n          user.major = major\n          user.year = year\n          begin\n            user.save!\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        end\n\n        existing = @course.course_user_data.where(user: user).first\n        # Make sure this user doesn't have a cud in the course\n        if existing\n          duplicates.add(new_cud[:email])\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # Build cud\n        if !user.nil?\n          cud = @course.course_user_data.new\n          cud.user = user\n          params = ActionController::Parameters.new(\n            course_number: new_cud[:course_number],\n            lecture: new_cud[:lecture],\n            section: new_cud[:section],\n            grade_policy: new_cud[:grade_policy]\n          )\n          cud.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n\n          # Save without validations\n          cud.save(validate: false)\n        end\n\n      when \"red\"\n        # Drop this user from the course\n        existing = @course.course_user_data.includes(:user)\n                          .where(users: { email: new_cud[:email] }).first\n\n        fail \"Red CUD doesn't exist in the database.\" if existing.nil?\n\n        existing.dropped = true\n        existing.save(validate: false)\n      else\n        # Update this user's attributes.\n        existing = @course.course_user_data.includes(:user)\n                          .where(\"lower(users.email) = ?\", new_cud[:email].downcase)\n                          .references(:users).first\n        # existing = @course.course_user_data.includes(:user).\n        # where(users[:email].matches(\"%#{new_cud[:email]}%\")).first\n\n        fail \"Black CUD doesn't exist in the database.\" if existing.nil?\n\n        user = existing.user\n        if user.nil?\n          fail \"User associated to black CUD doesn't exist in the database.\"\n        end\n\n        # Update user data\n        user.first_name = new_cud[:first_name]\n        user.last_name = new_cud[:last_name]\n        user.school = new_cud[:school]\n        user.major = new_cud[:major]\n        user.year = new_cud[:year]\n\n        begin\n          user.save!\n        rescue StandardError => e\n          msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n          if !rosterErrors.key?(msg)\n            rosterErrors[msg] = []\n          end\n          rosterErrors[msg].push(cloneCUD)\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # assign attributes\n        params = ActionController::Parameters.new(\n          course_number: new_cud[:course_number],\n          lecture: new_cud[:lecture],\n          section: new_cud[:section],\n          grade_policy: new_cud[:grade_policy]\n        )\n        existing.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n        existing.dropped = false\n        existing.save(validate: false) # Save without validations.\n      end\n      rowNum += 1\n    end\n\n    rowCUDs.each do |cud|\n      next unless duplicates.include?(cud[:email])\n\n      msg = \"Validation failed: Duplicate email #{cud[:email]}\"\n      if !rosterErrors.key?(msg)\n        rosterErrors[msg] = []\n      end\n      rosterErrors[msg].push(cud)\n    end\n\n    return if rosterErrors.empty?\n\n    flash[:roster_error] = rosterErrors\n    fail \"Roster validation error\"\n  end\n\n  def save_uploaded_roster\n    cuds = []\n\n    rowNum = 0\n    until params[\"cuds\"][rowNum.to_s].nil?\n      cuds.push(params[\"cuds\"][rowNum.to_s])\n      rowNum += 1\n    end\n\n    CourseUserDatum.transaction do\n      write_cuds(cuds)\n    end\n  end\n\n  def change_view(is_sorted)\n    @cud_view = if is_sorted\n                  @sorted_cuds\n                else\n                  @cuds\n                end\n  end\n\n  def parse_roster_csv\n    # generate doIt form from the upload\n    @cuds = []\n    @currentCUDs = @course.course_user_data.all.to_a\n    @new_cuds = []\n\n    begin\n      csv = detect_and_convert_roster(params[\"upload\"][\"file\"].read)\n      csv.each do |row|\n        new_cud = { # Ignore Semester (row[0])\n          email: row[1].to_s,\n          last_name: row[2].to_s.chomp(\" \"),\n          first_name: row[3].to_s.chomp(\" \"),\n          school: row[4].to_s.chomp(\" \"),\n          major: row[5].to_s.chomp(\" \"),\n          year: row[6].to_s.chomp(\" \"),\n          grade_policy: row[7].to_s.chomp(\" \"),\n          course_number: row[8].to_s.chomp(\" \"),\n          lecture: row[9].to_s.chomp(\" \"),\n          section: row[10].to_s.chomp(\" \")\n        }\n        cud = @currentCUDs.find do |current|\n          current.user && current.user.email.downcase == new_cud[:email].downcase\n        end\n\n        if !cud\n          new_cud[:color] = \"green\"\n        else\n          @currentCUDs.delete(cud)\n        end\n        @cuds << new_cud\n      end\n    rescue CSV::MalformedCSVError => e\n      flash[:error] = \"Error parsing CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error uploading the CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n      raise e\n    end\n\n    # drop the rest if indicated\n    if params[:upload][:dropMissing] == \"1\"\n      # We never drop instructors, remove them first\n      @currentCUDs.delete_if do |cud|\n        cud.instructor? || cud.user.administrator? || cud.course_assistant?\n      end\n      @currentCUDs.each do |cud| # These are the drops\n        new_cud = {\n          email: cud.user.email,\n          last_name: cud.user.last_name,\n          first_name: cud.user.first_name,\n          school: cud.school,\n          major: cud.major,\n          year: cud.year,\n          grade_policy: cud.grade_policy,\n          course_number: cud.course_number,\n          lecture: cud.lecture,\n          section: cud.section,\n          color: \"red\"\n        }\n        @cuds << new_cud\n      end\n    end\n\n    # do dry run for error checking\n    CourseUserDatum.transaction do\n      cloned_cuds = Marshal.load(Marshal.dump(@cuds))\n      begin\n        write_cuds(cloned_cuds)\n      rescue StandardError => e\n        redirect_to(action: \"upload_roster\")\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    @sorted_cuds = @cuds.sort_by { |cud| cud[:color] || \"z\" }\n    @cud_view = @sorted_cuds\n  end\n\n  # detect_and_convert_roster - Detect the type of a roster based on roster\n  # column matching and convert to default roster\n\n  # map fields:\n  # map[0]: semester (unused)\n  # map[1]: email\n  # map[2]: last_name\n  # map[3]: first_name\n  # map[4]: school\n  # map[5]: major\n  # map[6]: year\n  # map[7]: grade_policy\n  # map[8]: course\n  # map[9]: lecture\n  # map[10]: section\n  # rubocop:disable Lint/UselessAssignment\n  def detect_and_convert_roster(roster)\n    raise \"Roster is empty\" if roster.empty?\n\n    parsedRoster = CSV.parse(roster, skip_blanks: true)\n    raise \"Roster cannot be recognized\" if parsedRoster[0][0].nil?\n\n    case parsedRoster[0].length\n    when ROSTER_COLUMNS_F20 # 34 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11 - skip), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Time Zone Code(22), Time Zone Description(23), Added By(24),\n      # Added On(25), Confirmed(26), Waitlist Position(27), Units Carried/Max Units(28),\n      # Waitlisted By(29), Waitlisted On(30), Dropped By(31), Dropped On(32), Roster As Of Date(33)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F20\n    when ROSTER_COLUMNS_F16 # 32 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Added By(22), Added On(23), Confirmed(24), Waitlist Position(25),\n      # Units Carried/Max Units(26), Waitlisted By(27), Waitlisted On(28), Dropped By(29),\n      # Dropped On(30), Roster As Of Date(31)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F16\n    when ROSTER_COLUMNS_S15 # 29 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Lecture(1), Section(2), (skip)(3), (skip)(4), Last Name(5),\n      # First Name(6), (skip)(7), Andrew ID(8), (skip)(9), School(10),\n      # Major(11), Year(12), (skip)(13), Grade Policy(14), ... [elided]\n      map = [-1, 8, 5, 6, 10, 11, 12, 14, -1, 1, 2]\n      select_columns = ROSTER_COLUMNS_S15\n    else\n      # No header row. Columns are:\n      # Semester(0 - skip), Email(1), Last Name(2), First Name(3), School(4),\n      # Major(5), Year(6), Grade Policy(7), Course(8), Lecture(9),\n      # Section(10)\n      return parsedRoster\n    end\n    # rubocop:enable Lint/UselessAssignment\n\n    # Detect if there is a header row\n    offset = if parsedRoster[0][0] == \"Semester\"\n               1\n             else\n               0\n             end\n    numRows = parsedRoster.length - offset\n    convertedRoster = Array.new(numRows) { Array.new(11) }\n\n    domain = if Rails.env.production?\n               \"andrew.cmu.edu\"\n             else\n               \"foo.bar\"\n             end\n    (0..(numRows - 1)).each do |i|\n      11.times do |j|\n        next unless map[j] >= 0\n\n        convertedRoster[i][j] = if j == 1\n                                  \"#{parsedRoster[i + offset][map[j]]}@#{domain}\"\n                                else\n                                  parsedRoster[i + offset][map[j]]\n                                end\n      end\n    end\n    convertedRoster\n  end\n\n  def extract_asmt_for_moss(tmp_dir, assessments)\n    # for each assessment\n    assessments.each do |ass|\n      # Create a directory for ths assessment\n      assDir = File.join(tmp_dir, \"#{ass.name}-#{ass.course.name}\")\n      Dir.mkdir(assDir)\n\n      # params[:isArchive] might be nil if no archive assessments are submitted\n      isArchive = params[:isArchive] && params[:isArchive][ass.id.to_s]\n\n      visitedGroups = Set.new\n\n      # For each student who submitted\n      ass.submissions.latest.each do |sub|\n        subFile = sub.handin_file_path\n        next unless subFile && File.exist?(subFile)\n\n        if ass.has_groups?\n          group_id = sub.aud.group_id\n          next if visitedGroups.include?(group_id)\n\n          visitedGroups.add(group_id)\n        end\n\n        # Create a directory for this student\n        stuDir = File.join(assDir, sub.course_user_datum.email)\n        Dir.mkdir(stuDir)\n\n        # Copy their submission over\n        FileUtils.cp(subFile, stuDir)\n\n        # Read archive files\n        next unless isArchive\n\n        # If we need to unarchive this file, then create archive reader\n        archive_path = File.join(stuDir, sub.filename)\n        begin\n          archive_extract = Archive.get_archive(archive_path)\n\n          archive_extract.each do |entry|\n            pathname = Archive.get_entry_name(entry)\n            next if Archive.looks_like_directory?(pathname)\n\n            pathname.gsub!(%r{/}, \"-\")\n            destination = File.join(stuDir, pathname)\n            # make sure all subdirectories are there\n            FileUtils.mkdir_p(File.dirname(destination))\n            File.open(destination, \"wb\") do |out|\n              out.write Archive.read_entry_file(entry)\n              begin\n                out.fsync\n              rescue StandardError\n                nil\n              end\n            end\n          end\n        rescue StandardError\n          @failures << sub.filename\n        end\n      end\n\n      # add this assessment to the moss command\n      patternList = params[\"files\"][ass.id.to_s].split(\" \")\n      patternList.each do |pattern|\n        @mossCmd << File.join(assDir, [\"*\", pattern])\n      end\n    end\n  end\n\n  def extract_tar_for_moss(tmp_dir, external_tar, archive)\n    return unless external_tar\n\n    # Directory to hold tar ball and all individual files.\n    extTarDir = File.join(tmp_dir, \"external_input\")\n    baseFilesDir = File.join(tmp_dir, \"basefiles\")\n    begin\n      Dir.mkdir(extTarDir)\n      Dir.mkdir(baseFilesDir) # To hold all basefiles\n    rescue StandardError\n      nil\n    end\n\n    # Read in the tarfile from the given source.\n    extTarPath = File.join(extTarDir, \"input_file\")\n    external_tar.rewind\n    File.open(extTarPath, \"wb\") { |f| f.write(external_tar.read) } # Write tar file.\n\n    # Directory to hold all external individual submission.\n    extFilesDir = File.join(extTarDir, \"submissions\")\n\n    begin\n      Dir.mkdir(extFilesDir) # To hold all submissions\n    rescue StandardError\n      nil\n    end\n\n    # Untar the given Tar file.\n    begin\n      archive_extract = Archive.get_archive(extTarPath)\n\n      # write each file, renaming nested files\n      archive_extract.each do |entry|\n        pathname = Archive.get_entry_name(entry)\n        next if Archive.looks_like_directory?(pathname)\n\n        output_dir = if archive\n                       extFilesDir\n                     else\n                       baseFilesDir\n                     end\n        output_file = File.join(output_dir, pathname)\n\n        # skip if the file lies outside the archive\n        next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir))\n\n        # make sure all subdirectories are there\n        File.open(output_file, \"wb\") do |out|\n          out.write Archive.read_entry_file(entry)\n          begin\n            out.fsync\n          rescue StandardError\n            nil\n          end\n        end\n      end\n    rescue StandardError\n      @failures << \"External Tar\"\n    end\n\n    # Feed the uploaded files to MOSS.\n    if archive\n      @mossCmd << File.join(extFilesDir, \"*\")\n    else\n      @basefiles = File.join(baseFilesDir, \"*\")\n    end\n  end\nend\n"], "filenames": ["app/controllers/assessments_controller.rb", "app/controllers/courses_controller.rb"], "buggy_code_start_loc": [189, 1113], "buggy_code_end_loc": [206, 1116], "fixing_code_start_loc": [190, 1113], "fixing_code_end_loc": [211, 1116], "type": "CWE-22", "message": "Autolab is a course management service that enables auto-graded programming assignments. A Tar slip vulnerability was found in the Install assessment functionality of Autolab. To exploit this vulnerability an authenticated attacker with instructor permissions needs to upload a specially crafted Tar file. Using the install assessment functionality an attacker can feed a Tar file that contain files with paths pointing outside of the target directory (e.g.,  `../../../../tmp/tarslipped1.sh`). When the Install assessment form is submitted the files inside of the archives are expanded to the attacker-chosen locations. This issue has been addressed in version 2.11.0. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-32676", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-26T23:15:18.647", "lastModified": "2023-06-05T15:30:07.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Autolab is a course management service that enables auto-graded programming assignments. A Tar slip vulnerability was found in the Install assessment functionality of Autolab. To exploit this vulnerability an authenticated attacker with instructor permissions needs to upload a specially crafted Tar file. Using the install assessment functionality an attacker can feed a Tar file that contain files with paths pointing outside of the target directory (e.g.,  `../../../../tmp/tarslipped1.sh`). When the Install assessment form is submitted the files inside of the archives are expanded to the attacker-chosen locations. This issue has been addressed in version 2.11.0. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:autolabproject:autolab:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.0", "matchCriteriaId": "F025235E-3D41-4053-8167-1D8D94A645FF"}]}]}], "references": [{"url": "https://github.com/autolab/Autolab/commit/14f508484a8323eceb0cf3a128573b43eabbc80d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/autolab/Autolab/security/advisories/GHSA-x9hj-r9q4-832c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/autolab/Autolab/commit/14f508484a8323eceb0cf3a128573b43eabbc80d"}}