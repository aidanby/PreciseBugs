{"buggy_code": ["<?php\n\nnamespace App\\Http\\Controllers\\Auth;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\SendsPasswordResetEmails;\nuse Illuminate\\Http\\Request;\n\nclass ForgotPasswordController extends Controller\n{\n    /*\n    |--------------------------------------------------------------------------\n    | Password Reset Controller\n    |--------------------------------------------------------------------------\n    |\n    | This controller is responsible for handling password reset emails and\n    | includes a trait which assists in sending these notifications from\n    | your application to your users. Feel free to explore this trait.\n    |\n    */\n\n    use SendsPasswordResetEmails;\n\n    /**\n     * Create a new controller instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->middleware('guest');\n        $this->middleware('throttle:5,1', ['except' => 'showLinkRequestForm']);\n    }\n\n    /**\n     * Get the e-mail subject line to be used for the reset link email.\n     * Overriding method \"getEmailSubject()\" from trait \"use ResetsPasswords\"\n     * @return string\n     */\n    public function getEmailSubject()\n    {\n        return property_exists($this, 'subject') ? $this->subject : \\Lang::get('mail.reset_link');\n    }\n\n\n\n    /**\n     * Send a reset link to the given user.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function sendResetLinkEmail(Request $request)\n    {\n\n        /**\n         * Let's set a max character count here to prevent potential\n         * buffer overflow issues with attackers sending very large\n         * payloads through.\n         */\n\n        $request->validate([\n            'username' => ['required', 'max:255'],\n        ]);\n\n\n\n        /**\n         * If we find a matching email with an activated user, we will\n         * send the password reset link to the user.\n         *\n         * Once we have attempted to send the link, we will examine the response\n         * then see the message we need to show to the user. Finally, we'll send out a proper response.\n         */\n        \n        $response = null;\n\n        try {\n            $response = $this->broker()->sendResetLink(\n                array_merge(\n                    $request->only('username'),\n                    ['activated' => '1'],\n                    ['ldap_import' => '0']\n                )\n            );\n        } catch(\\Exception $e) {\n            \\Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );\n        }\n\n\n        if ($response === \\Password::RESET_LINK_SENT) {\n            \\Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');\n        } else {\n            \\Log::info('Password reset attempt: User matching username '.$request->input('username').' NOT FOUND or user is inactive');\n        }\n\n\n        /**\n         * If an error was returned by the password broker, we will get this message\n         * translated so we can notify a user of the problem. We'll redirect back\n         * to where the users came from so they can attempt this process again.\n         *\n         * HOWEVER, we do not want to translate the message if the user isn't found\n         * or isn't active, since that would allow an attacker to walk through\n         * a dictionary attack and figure out registered user email addresses.\n         *\n         * Instead we tell the user we've sent an email even though we haven't.\n         * It's bad UX, but better security. The compromises we sometimes have to make.\n        */\n\n        // Regardless of response, we do not want to disclose the status of a user account,\n        // so we give them a generic \"If this exists, we're TOTALLY gonna email you\" response\n        return redirect()->route('login')->with('success',trans('passwords.sent'));\n        }\n\n\n}\n"], "fixing_code": ["<?php\n\nnamespace App\\Http\\Controllers\\Auth;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Foundation\\Auth\\SendsPasswordResetEmails;\nuse Illuminate\\Http\\Request;\n\nclass ForgotPasswordController extends Controller\n{\n    /*\n    |--------------------------------------------------------------------------\n    | Password Reset Controller\n    |--------------------------------------------------------------------------\n    |\n    | This controller is responsible for handling password reset emails and\n    | includes a trait which assists in sending these notifications from\n    | your application to your users. Feel free to explore this trait.\n    |\n    */\n\n    use SendsPasswordResetEmails;\n\n    /**\n     * Create a new controller instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->middleware('guest');\n        $this->middleware('throttle:5,1', ['except' => 'showLinkRequestForm']);\n    }\n\n    /**\n     * Get the e-mail subject line to be used for the reset link email.\n     * Overriding method \"getEmailSubject()\" from trait \"use ResetsPasswords\"\n     * @return string\n     */\n    public function getEmailSubject()\n    {\n        return property_exists($this, 'subject') ? $this->subject : \\Lang::get('mail.reset_link');\n    }\n\n\n\n    /**\n     * Send a reset link to the given user.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function sendResetLinkEmail(Request $request)\n    {\n\n        /**\n         * Let's set a max character count here to prevent potential\n         * buffer overflow issues with attackers sending very large\n         * payloads through.\n         */\n\n        $request->validate([\n            'username' => ['required', 'max:255'],\n        ]);\n\n\n\n        /**\n         * If we find a matching email with an activated user, we will\n         * send the password reset link to the user.\n         *\n         * Once we have attempted to send the link, we will examine the response\n         * then see the message we need to show to the user. Finally, we'll send out a proper response.\n         */\n        \n        $response = null;\n\n        try {\n            $response = $this->broker()->sendResetLink(\n                array_merge(\n                    $request->only('username'),\n                    ['activated' => '1'],\n                    ['ldap_import' => '0']\n                )\n            );\n        } catch(\\Exception $e) {\n            \\Log::info('Password reset attempt: User '.$request->input('username').'failed with exception: '.$e );\n        }\n\n        // Prevent timing attack to enumerate users.\n        usleep(500000 + random_int(0, 1500000));\n\n        if ($response === \\Password::RESET_LINK_SENT) {\n            \\Log::info('Password reset attempt: User '.$request->input('username').' WAS found, password reset sent');\n        } else {\n            \\Log::info('Password reset attempt: User matching username '.$request->input('username').' NOT FOUND or user is inactive');\n        }\n\n\n        /**\n         * If an error was returned by the password broker, we will get this message\n         * translated so we can notify a user of the problem. We'll redirect back\n         * to where the users came from so they can attempt this process again.\n         *\n         * HOWEVER, we do not want to translate the message if the user isn't found\n         * or isn't active, since that would allow an attacker to walk through\n         * a dictionary attack and figure out registered user email addresses.\n         *\n         * Instead we tell the user we've sent an email even though we haven't.\n         * It's bad UX, but better security. The compromises we sometimes have to make.\n        */\n\n        // Regardless of response, we do not want to disclose the status of a user account,\n        // so we give them a generic \"If this exists, we're TOTALLY gonna email you\" response\n        return redirect()->route('login')->with('success',trans('passwords.sent'));\n        }\n\n\n}\n"], "filenames": ["app/Http/Controllers/Auth/ForgotPasswordController.php"], "buggy_code_start_loc": [89], "buggy_code_end_loc": [89], "fixing_code_start_loc": [90], "fixing_code_end_loc": [92], "type": "CWE-209", "message": "Generation of Error Message Containing Sensitive Information in Packagist snipe/snipe-it prior to 5.3.11.", "other": {"cve": {"id": "CVE-2022-0622", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-17T02:15:09.267", "lastModified": "2022-02-25T02:07:28.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Generation of Error Message Containing Sensitive Information in Packagist snipe/snipe-it prior to 5.3.11."}, {"lang": "es", "value": "Una Generaci\u00f3n de un Mensaje de Error que Contiene Informaci\u00f3n Confidencial en Packagist snipe/snipe-it versiones anteriores a 5.3.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.10", "matchCriteriaId": "CD6623B0-0B21-426D-8757-9811DAF9D3AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:6.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "E3171FF1-3D9C-4F9F-B2AA-6848580FB8E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:6.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "444AB799-DA17-4B22-A24D-249283176A95"}]}]}], "references": [{"url": "https://github.com/snipe/snipe-it/commit/178e44095141ab805c282f563fb088df1a10b2e2", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4ed99dab-5319-4b6b-919a-84a9acd0061a", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snipe/snipe-it/commit/178e44095141ab805c282f563fb088df1a10b2e2"}}