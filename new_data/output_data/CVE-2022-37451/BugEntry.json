{"buggy_code": ["/*************************************************\n*     Exim - an Internet mail transport agent    *\n*************************************************/\n\n/* Copyright (c) University of Cambridge 1995 - 2018 */\n/* Copyright (c) The Exim Maintainers 2020 */\n/* See the file NOTICE for conditions of use and distribution. */\n\n#include \"../exim.h\"\n\n/* This module contains functions that call the PAM authentication mechanism\ndefined by Sun for Solaris and also available for Linux and other OS.\n\nWe can't just compile this code and allow the library mechanism to omit the\nfunctions if they are not wanted, because we need to have the PAM headers\navailable for compiling. Therefore, compile these functions only if SUPPORT_PAM\nis defined. However, some compilers don't like compiling empty modules, so keep\nthem happy with a dummy when skipping the rest. Make it reference itself to\nstop picky compilers complaining that it is unused, and put in a dummy argument\nto stop even pickier compilers complaining about infinite loops.\nThen use a mutually-recursive pair as gcc is just getting stupid. */\n\n#ifndef SUPPORT_PAM\nstatic void dummy(int x);\nstatic void dummy2(int x) { dummy(x-1); }\nstatic void dummy(int x) { dummy2(x-1); }\n#else  /* SUPPORT_PAM */\n\n#ifdef PAM_H_IN_PAM\n#include <pam/pam_appl.h>\n#else\n#include <security/pam_appl.h>\n#endif\n\n/* According to the specification, it should be possible to have an application\ndata pointer passed to the conversation function. However, I was unable to get\nthis to work on Solaris 2.6, so static variables are used instead. */\n\nstatic int pam_conv_had_error;\nstatic const uschar *pam_args;\nstatic BOOL pam_arg_ended;\n\n\n\n/*************************************************\n*           PAM conversation function            *\n*************************************************/\n\n/* This function is passed to the PAM authentication function, and it calls it\nback when it wants data from the client. The string list is in pam_args. When\nwe reach the end, we pass back an empty string once. If this function is called\nagain, it will give an error response. This is protection against something\ncrazy happening.\n\nArguments:\n  num_msg        number of messages associated with the call\n  msg            points to an array of length num_msg of pam_message structures\n  resp           set to point to the response block, which has to be got by\n                   this function\n  appdata_ptr    the application data pointer - not used because in Solaris\n                   2.6 it always arrived in pam_converse() as NULL\n\nReturns:         a PAM return code\n*/\n\nstatic int\npam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n/* It seems that PAM frees reply[] */\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); /* PAM frees resp */\n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    /* Just acknowledge messages */\n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  /* Must be an error of some sort... */\n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}\n\n\n\n/*************************************************\n*              Perform PAM authentication        *\n*************************************************/\n\n/* This function calls the PAM authentication mechanism, passing over one or\nmore data strings.\n\nArguments:\n  s        a colon-separated list of strings\n  errptr   where to point an error message\n\nReturns:   OK if authentication succeeded\n           FAIL if authentication failed\n           ERROR some other error condition\n*/\n\nint\nauth_call_pam(const uschar *s, uschar **errptr)\n{\npam_handle_t *pamh = NULL;\nstruct pam_conv pamc;\nint pam_error;\nint sep = 0;\nuschar *user;\n\n/* Set up the input data structure: the address of the conversation function,\nand a pointer to application data, which we don't use because I couldn't get it\nto work under Solaris 2.6 - it always arrived in pam_converse() as NULL. */\n\npamc.conv = pam_converse;\npamc.appdata_ptr = NULL;\n\n/* Initialize the static data - the current input data, the error flag, and the\nflag for data end. */\n\npam_args = s;\npam_conv_had_error = FALSE;\npam_arg_ended = FALSE;\n\n/* The first string in the list is the user. If this is an empty string, we\nfail. PAM doesn't support authentication with an empty user (it prompts for it,\ncausing a potential mis-interpretation). */\n\nuser = string_nextinlist(&pam_args, &sep, NULL, 0);\nif (user == NULL || user[0] == 0) return FAIL;\n\n/* Start off PAM interaction */\n\nDEBUG(D_auth)\n  debug_printf(\"Running PAM authentication for user \\\"%s\\\"\\n\", user);\n\npam_error = pam_start (\"exim\", CS user, &pamc, &pamh);\n\n/* Do the authentication - the pam_authenticate() will call pam_converse() to\nget the data it wants. After successful authentication we call pam_acct_mgmt()\nto apply any other restrictions (e.g. only some times of day). */\n\nif (pam_error == PAM_SUCCESS)\n  {\n  pam_error = pam_authenticate (pamh, PAM_SILENT);\n  if (pam_error == PAM_SUCCESS && !pam_conv_had_error)\n    pam_error = pam_acct_mgmt (pamh, PAM_SILENT);\n  }\n\n/* Finish the PAM interaction - this causes it to clean up store etc. Unclear\nwhat should be passed as the second argument. */\n\npam_end(pamh, PAM_SUCCESS);\n\n/* Sort out the return code. If not success, set the error message. */\n\nif (pam_error == PAM_SUCCESS)\n  {\n  DEBUG(D_auth) debug_printf(\"PAM success\\n\");\n  return OK;\n  }\n\n*errptr = US pam_strerror(pamh, pam_error);\nDEBUG(D_auth) debug_printf(\"PAM error: %s\\n\", *errptr);\n\nif (pam_error == PAM_USER_UNKNOWN ||\n    pam_error == PAM_AUTH_ERR ||\n    pam_error == PAM_ACCT_EXPIRED)\n  return FAIL;\n\nreturn ERROR;\n}\n\n#endif  /* SUPPORT_PAM */\n\n/* End of call_pam.c */\n"], "fixing_code": ["/*************************************************\n*     Exim - an Internet mail transport agent    *\n*************************************************/\n\n/* Copyright (c) University of Cambridge 1995 - 2018 */\n/* Copyright (c) The Exim Maintainers 2020 */\n/* See the file NOTICE for conditions of use and distribution. */\n\n#include \"../exim.h\"\n\n/* This module contains functions that call the PAM authentication mechanism\ndefined by Sun for Solaris and also available for Linux and other OS.\n\nWe can't just compile this code and allow the library mechanism to omit the\nfunctions if they are not wanted, because we need to have the PAM headers\navailable for compiling. Therefore, compile these functions only if SUPPORT_PAM\nis defined. However, some compilers don't like compiling empty modules, so keep\nthem happy with a dummy when skipping the rest. Make it reference itself to\nstop picky compilers complaining that it is unused, and put in a dummy argument\nto stop even pickier compilers complaining about infinite loops.\nThen use a mutually-recursive pair as gcc is just getting stupid. */\n\n#ifndef SUPPORT_PAM\nstatic void dummy(int x);\nstatic void dummy2(int x) { dummy(x-1); }\nstatic void dummy(int x) { dummy2(x-1); }\n#else  /* SUPPORT_PAM */\n\n#ifdef PAM_H_IN_PAM\n#include <pam/pam_appl.h>\n#else\n#include <security/pam_appl.h>\n#endif\n\n/* According to the specification, it should be possible to have an application\ndata pointer passed to the conversation function. However, I was unable to get\nthis to work on Solaris 2.6, so static variables are used instead. */\n\nstatic int pam_conv_had_error;\nstatic const uschar *pam_args;\nstatic BOOL pam_arg_ended;\n\n\n\n/*************************************************\n*           PAM conversation function            *\n*************************************************/\n\n/* This function is passed to the PAM authentication function, and it calls it\nback when it wants data from the client. The string list is in pam_args. When\nwe reach the end, we pass back an empty string once. If this function is called\nagain, it will give an error response. This is protection against something\ncrazy happening.\n\nArguments:\n  num_msg        number of messages associated with the call\n  msg            points to an array of length num_msg of pam_message structures\n  resp           set to point to the response block, which has to be got by\n                   this function\n  appdata_ptr    the application data pointer - not used because in Solaris\n                   2.6 it always arrived in pam_converse() as NULL\n\nReturns:         a PAM return code\n*/\n\nstatic int\npam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n/* It seems that PAM frees reply[] */\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = strdup(CCS arg); /* Use libc malloc, PAM frees resp directly*/\n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    /* Just acknowledge messages */\n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  /* Must be an error of some sort... */\n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}\n\n\n\n/*************************************************\n*              Perform PAM authentication        *\n*************************************************/\n\n/* This function calls the PAM authentication mechanism, passing over one or\nmore data strings.\n\nArguments:\n  s        a colon-separated list of strings\n  errptr   where to point an error message\n\nReturns:   OK if authentication succeeded\n           FAIL if authentication failed\n           ERROR some other error condition\n*/\n\nint\nauth_call_pam(const uschar *s, uschar **errptr)\n{\npam_handle_t *pamh = NULL;\nstruct pam_conv pamc;\nint pam_error;\nint sep = 0;\nuschar *user;\n\n/* Set up the input data structure: the address of the conversation function,\nand a pointer to application data, which we don't use because I couldn't get it\nto work under Solaris 2.6 - it always arrived in pam_converse() as NULL. */\n\npamc.conv = pam_converse;\npamc.appdata_ptr = NULL;\n\n/* Initialize the static data - the current input data, the error flag, and the\nflag for data end. */\n\npam_args = s;\npam_conv_had_error = FALSE;\npam_arg_ended = FALSE;\n\n/* The first string in the list is the user. If this is an empty string, we\nfail. PAM doesn't support authentication with an empty user (it prompts for it,\ncausing a potential mis-interpretation). */\n\nuser = string_nextinlist(&pam_args, &sep, NULL, 0);\nif (user == NULL || user[0] == 0) return FAIL;\n\n/* Start off PAM interaction */\n\nDEBUG(D_auth)\n  debug_printf(\"Running PAM authentication for user \\\"%s\\\"\\n\", user);\n\npam_error = pam_start (\"exim\", CS user, &pamc, &pamh);\n\n/* Do the authentication - the pam_authenticate() will call pam_converse() to\nget the data it wants. After successful authentication we call pam_acct_mgmt()\nto apply any other restrictions (e.g. only some times of day). */\n\nif (pam_error == PAM_SUCCESS)\n  {\n  pam_error = pam_authenticate (pamh, PAM_SILENT);\n  if (pam_error == PAM_SUCCESS && !pam_conv_had_error)\n    pam_error = pam_acct_mgmt (pamh, PAM_SILENT);\n  }\n\n/* Finish the PAM interaction - this causes it to clean up store etc. Unclear\nwhat should be passed as the second argument. */\n\npam_end(pamh, PAM_SUCCESS);\n\n/* Sort out the return code. If not success, set the error message. */\n\nif (pam_error == PAM_SUCCESS)\n  {\n  DEBUG(D_auth) debug_printf(\"PAM success\\n\");\n  return OK;\n  }\n\n*errptr = US pam_strerror(pamh, pam_error);\nDEBUG(D_auth) debug_printf(\"PAM error: %s\\n\", *errptr);\n\nif (pam_error == PAM_USER_UNKNOWN ||\n    pam_error == PAM_AUTH_ERR ||\n    pam_error == PAM_ACCT_EXPIRED)\n  return FAIL;\n\nreturn ERROR;\n}\n\n#endif  /* SUPPORT_PAM */\n\n/* End of call_pam.c */\n"], "filenames": ["src/src/auths/call_pam.c"], "buggy_code_start_loc": [91], "buggy_code_end_loc": [92], "fixing_code_start_loc": [91], "fixing_code_end_loc": [92], "type": "CWE-763", "message": "Exim before 4.96 has an invalid free in pam_converse in auths/call_pam.c because store_free is not used after store_malloc.", "other": {"cve": {"id": "CVE-2022-37451", "sourceIdentifier": "cve@mitre.org", "published": "2022-08-06T18:15:08.967", "lastModified": "2022-09-29T15:41:29.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exim before 4.96 has an invalid free in pam_converse in auths/call_pam.c because store_free is not used after store_malloc."}, {"lang": "es", "value": "Exim versiones anteriores a 4.96, presenta una liberaci\u00f3n no v\u00e1lida en el archivo pam_converse en auths/call_pam.c porque store_free no es usada despu\u00e9s de store_malloc"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exim:exim:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.96", "matchCriteriaId": "17916062-EE08-476D-8DF0-8EEC3F974AAF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://cwe.mitre.org/data/definitions/762.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Exim/exim/commit/51be321b27825c01829dffd90f11bfff256f7e42", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Exim/exim/compare/exim-4.95...exim-4.96", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Exim/exim/wiki/EximSecurity", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ivd38/exim_invalid_free", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.exim.org/lurker/message/20220625.141825.d6de6074.en.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LETR5CVDPFOFQHXCJP6NFLG52JZHQYDY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XSWDF4QEXD4TDWQLYQOWCHBJKTDQR4Z7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.exim.org/static/doc/security/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/08/06/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Exim/exim/commit/51be321b27825c01829dffd90f11bfff256f7e42"}}