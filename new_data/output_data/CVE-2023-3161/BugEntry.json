{"buggy_code": ["/*\n *  linux/drivers/video/fbcon.c -- Low level frame buffer based console driver\n *\n *\tCopyright (C) 1995 Geert Uytterhoeven\n *\n *\n *  This file is based on the original Amiga console driver (amicon.c):\n *\n *\tCopyright (C) 1993 Hamish Macdonald\n *\t\t\t   Greg Harp\n *\tCopyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]\n *\n *\t      with work by William Rucklidge (wjr@cs.cornell.edu)\n *\t\t\t   Geert Uytterhoeven\n *\t\t\t   Jes Sorensen (jds@kom.auc.dk)\n *\t\t\t   Martin Apel\n *\n *  and on the original Atari console driver (atacon.c):\n *\n *\tCopyright (C) 1993 Bjoern Brauel\n *\t\t\t   Roman Hodek\n *\n *\t      with work by Guenther Kelleter\n *\t\t\t   Martin Schaller\n *\t\t\t   Andreas Schwab\n *\n *  Hardware cursor support added by Emmanuel Marty (core@ggi-project.org)\n *  Smart redraw scrolling, arbitrary font width support, 512char font support\n *  and software scrollback added by \n *                         Jakub Jelinek (jj@ultra.linux.cz)\n *\n *  Random hacking by Martin Mares <mj@ucw.cz>\n *\n *\t2001 - Documented with DocBook\n *\t- Brad Douglas <brad@neruo.com>\n *\n *  The low level operations for the various display memory organizations are\n *  now in separate source files.\n *\n *  Currently the following organizations are supported:\n *\n *    o afb\t\t\tAmiga bitplanes\n *    o cfb{2,4,8,16,24,32}\tPacked pixels\n *    o ilbm\t\t\tAmiga interleaved bitplanes\n *    o iplan2p[248]\t\tAtari interleaved bitplanes\n *    o mfb\t\t\tMonochrome\n *    o vga\t\t\tVGA characters/attributes\n *\n *  To do:\n *\n *    - Implement 16 plane mode (iplan2p16)\n *\n *\n *  This file is subject to the terms and conditions of the GNU General Public\n *  License.  See the file COPYING in the main directory of this archive for\n *  more details.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\t/* MSch: for IRQ probe */\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/fbcon.h>\n#include <linux/vt_kern.h>\n#include <linux/selection.h>\n#include <linux/font.h>\n#include <linux/smp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/crc32.h> /* For counting font checksums */\n#include <linux/uaccess.h>\n#include <asm/fb.h>\n#include <asm/irq.h>\n\n#include \"fbcon.h\"\n\n/*\n * FIXME: Locking\n *\n * - fbcon state itself is protected by the console_lock, and the code does a\n *   pretty good job at making sure that lock is held everywhere it's needed.\n *\n * - fbcon doesn't bother with fb_lock/unlock at all. This is buggy, since it\n *   means concurrent access to the same fbdev from both fbcon and userspace\n *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out\n *   of fb_lock/unlock protected sections, since otherwise we'll recurse and\n *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in\n *   fbmem.c cannot use locking asserts, and there's lots of callers which get\n *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.\n */\n\nenum {\n\tFBCON_LOGO_CANSHOW\t= -1,\t/* the logo can be shown */\n\tFBCON_LOGO_DRAW\t\t= -2,\t/* draw the logo to a console */\n\tFBCON_LOGO_DONTSHOW\t= -3\t/* do not show the logo */\n};\n\nstatic struct fbcon_display fb_display[MAX_NR_CONSOLES];\n\nstruct fb_info *fbcon_registered_fb[FB_MAX];\nint fbcon_num_registered_fb;\n\n#define fbcon_for_each_registered_fb(i)\t\t\\\n\tfor (i = 0; WARN_CONSOLE_UNLOCKED(), i < FB_MAX; i++)\t\t\\\n\t\tif (!fbcon_registered_fb[i]) {} else\n\nstatic signed char con2fb_map[MAX_NR_CONSOLES];\nstatic signed char con2fb_map_boot[MAX_NR_CONSOLES];\n\nstatic struct fb_info *fbcon_info_from_console(int console)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn fbcon_registered_fb[con2fb_map[console]];\n}\n\nstatic int logo_lines;\n/* logo_shown is an index to vc_cons when >= 0; otherwise follows FBCON_LOGO\n   enums.  */\nstatic int logo_shown = FBCON_LOGO_CANSHOW;\n/* console mappings */\nstatic unsigned int first_fb_vc;\nstatic unsigned int last_fb_vc = MAX_NR_CONSOLES - 1;\nstatic int fbcon_is_default = 1; \nstatic int primary_device = -1;\nstatic int fbcon_has_console_bind;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\nstatic int map_override;\n\nstatic inline void fbcon_map_override(void)\n{\n\tmap_override = 1;\n}\n#else\nstatic inline void fbcon_map_override(void)\n{\n}\n#endif /* CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY */\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\nstatic bool deferred_takeover = true;\n#else\n#define deferred_takeover false\n#endif\n\n/* font data */\nstatic char fontname[40];\n\n/* current fb_info */\nstatic int info_idx = -1;\n\n/* console rotation */\nstatic int initial_rotation = -1;\nstatic int fbcon_has_sysfs;\nstatic int margin_color;\n\nstatic const struct consw fb_con;\n\n#define advance_row(p, delta) (unsigned short *)((unsigned long)(p) + (delta) * vc->vc_size_row)\n\nstatic int fbcon_cursor_noblink;\n\n#define divides(a, b)\t((!(a) || (b)%(a)) ? 0 : 1)\n\n/*\n *  Interface used by the world\n */\n\nstatic void fbcon_clear_margins(struct vc_data *vc, int bottom_only);\nstatic void fbcon_set_palette(struct vc_data *vc, const unsigned char *table);\n\n/*\n *  Internal routines\n */\nstatic void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit);\nstatic void fbcon_redraw_move(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t      int line, int count, int dy);\nstatic void fbcon_modechanged(struct fb_info *info);\nstatic void fbcon_set_all_vcs(struct fb_info *info);\n\nstatic struct device *fbcon_device;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_ROTATION\nstatic inline void fbcon_set_rotation(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!(info->flags & FBINFO_MISC_TILEBLITTING) &&\n\t    ops->p->con_rotate < 4)\n\t\tops->rotate = ops->p->con_rotate;\n\telse\n\t\tops->rotate = 0;\n}\n\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\n{\n\tstruct fbcon_ops *ops= info->fbcon_par;\n\tstruct fb_info *fb_info;\n\n\tif (!ops || ops->currcon == -1)\n\t\treturn;\n\n\tfb_info = fbcon_info_from_console(ops->currcon);\n\n\tif (info == fb_info) {\n\t\tstruct fbcon_display *p = &fb_display[ops->currcon];\n\n\t\tif (rotate < 4)\n\t\t\tp->con_rotate = rotate;\n\t\telse\n\t\t\tp->con_rotate = 0;\n\n\t\tfbcon_modechanged(info);\n\t}\n}\n\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint i;\n\n\tif (!ops || ops->currcon < 0 || rotate > 3)\n\t\treturn;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t    fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tp = &fb_display[vc->vc_num];\n\t\tp->con_rotate = rotate;\n\t}\n\n\tfbcon_set_all_vcs(info);\n}\n#else\nstatic inline void fbcon_set_rotation(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->rotate = FB_ROTATE_UR;\n}\n\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\n{\n\treturn;\n}\n\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\n{\n\treturn;\n}\n#endif /* CONFIG_FRAMEBUFFER_CONSOLE_ROTATION */\n\nstatic int fbcon_get_rotate(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\treturn (ops) ? ops->rotate : 0;\n}\n\nstatic inline int fbcon_is_inactive(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\treturn (info->state != FBINFO_STATE_RUNNING ||\n\t\tvc->vc_mode != KD_TEXT || ops->graphics);\n}\n\nstatic int get_color(struct vc_data *vc, struct fb_info *info,\n\t      u16 c, int is_fg)\n{\n\tint depth = fb_get_color_depth(&info->var, &info->fix);\n\tint color = 0;\n\n\tif (console_blanked) {\n\t\tunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\n\t\tc = vc->vc_video_erase_char & charmask;\n\t}\n\n\tif (depth != 1)\n\t\tcolor = (is_fg) ? attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8, c)\n\t\t\t: attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12, c);\n\n\tswitch (depth) {\n\tcase 1:\n\t{\n\t\tint col = mono_col(info);\n\t\t/* 0 or 1 */\n\t\tint fg = (info->fix.visual != FB_VISUAL_MONO01) ? col : 0;\n\t\tint bg = (info->fix.visual != FB_VISUAL_MONO01) ? 0 : col;\n\n\t\tif (console_blanked)\n\t\t\tfg = bg;\n\n\t\tcolor = (is_fg) ? fg : bg;\n\t\tbreak;\n\t}\n\tcase 2:\n\t\t/*\n\t\t * Scale down 16-colors to 4 colors. Default 4-color palette\n\t\t * is grayscale. However, simply dividing the values by 4\n\t\t * will not work, as colors 1, 2 and 3 will be scaled-down\n\t\t * to zero rendering them invisible.  So empirically convert\n\t\t * colors to a sane 4-level grayscale.\n\t\t */\n\t\tswitch (color) {\n\t\tcase 0:\n\t\t\tcolor = 0; /* black */\n\t\t\tbreak;\n\t\tcase 1 ... 6:\n\t\t\tcolor = 2; /* white */\n\t\t\tbreak;\n\t\tcase 7 ... 8:\n\t\t\tcolor = 1; /* gray */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor = 3; /* intense white */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\t/*\n\t\t * Last 8 entries of default 16-color palette is a more intense\n\t\t * version of the first 8 (i.e., same chrominance, different\n\t\t * luminance).\n\t\t */\n\t\tcolor &= 7;\n\t\tbreak;\n\t}\n\n\n\treturn color;\n}\n\nstatic void fb_flashcursor(struct work_struct *work)\n{\n\tstruct fbcon_ops *ops = container_of(work, struct fbcon_ops, cursor_work.work);\n\tstruct fb_info *info;\n\tstruct vc_data *vc = NULL;\n\tint c;\n\tint mode;\n\tint ret;\n\n\t/* FIXME: we should sort out the unbind locking instead */\n\t/* instead we just fail to flash the cursor if we can't get\n\t * the lock instead of blocking fbcon deinit */\n\tret = console_trylock();\n\tif (ret == 0)\n\t\treturn;\n\n\t/* protected by console_lock */\n\tinfo = ops->info;\n\n\tif (ops->currcon != -1)\n\t\tvc = vc_cons[ops->currcon].d;\n\n\tif (!vc || !con_is_visible(vc) ||\n\t    fbcon_info_from_console(vc->vc_num) != info ||\n\t    vc->vc_deccm != 1) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tc = scr_readw((u16 *) vc->vc_pos);\n\tmode = (!ops->cursor_flash || ops->cursor_state.enable) ?\n\t\tCM_ERASE : CM_DRAW;\n\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),\n\t\t    get_color(vc, info, c, 0));\n\tconsole_unlock();\n\n\tqueue_delayed_work(system_power_efficient_wq, &ops->cursor_work,\n\t\t\t   ops->cur_blink_jiffies);\n}\n\nstatic void fbcon_add_cursor_work(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_cursor_noblink)\n\t\tqueue_delayed_work(system_power_efficient_wq, &ops->cursor_work,\n\t\t\t\t   ops->cur_blink_jiffies);\n}\n\nstatic void fbcon_del_cursor_work(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tcancel_delayed_work_sync(&ops->cursor_work);\n}\n\n#ifndef MODULE\nstatic int __init fb_console_setup(char *this_opt)\n{\n\tchar *options;\n\tint i, j;\n\n\tif (!this_opt || !*this_opt)\n\t\treturn 1;\n\n\twhile ((options = strsep(&this_opt, \",\")) != NULL) {\n\t\tif (!strncmp(options, \"font:\", 5)) {\n\t\t\tstrscpy(fontname, options + 5, sizeof(fontname));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!strncmp(options, \"scrollback:\", 11)) {\n\t\t\tpr_warn(\"Ignoring scrollback size option\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!strncmp(options, \"map:\", 4)) {\n\t\t\toptions += 4;\n\t\t\tif (*options) {\n\t\t\t\tfor (i = 0, j = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\t\t\tif (!options[j])\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tcon2fb_map_boot[i] =\n\t\t\t\t\t\t(options[j++]-'0') % FB_MAX;\n\t\t\t\t}\n\n\t\t\t\tfbcon_map_override();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"vc:\", 3)) {\n\t\t\toptions += 3;\n\t\t\tif (*options)\n\t\t\t\tfirst_fb_vc = simple_strtoul(options, &options, 10) - 1;\n\t\t\tif (first_fb_vc >= MAX_NR_CONSOLES)\n\t\t\t\tfirst_fb_vc = 0;\n\t\t\tif (*options++ == '-')\n\t\t\t\tlast_fb_vc = simple_strtoul(options, &options, 10) - 1;\n\t\t\tif (last_fb_vc < first_fb_vc || last_fb_vc >= MAX_NR_CONSOLES)\n\t\t\t\tlast_fb_vc = MAX_NR_CONSOLES - 1;\n\t\t\tfbcon_is_default = 0; \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"rotate:\", 7)) {\n\t\t\toptions += 7;\n\t\t\tif (*options)\n\t\t\t\tinitial_rotation = simple_strtoul(options, &options, 0);\n\t\t\tif (initial_rotation > 3)\n\t\t\t\tinitial_rotation = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"margin:\", 7)) {\n\t\t\toptions += 7;\n\t\t\tif (*options)\n\t\t\t\tmargin_color = simple_strtoul(options, &options, 0);\n\t\t\tcontinue;\n\t\t}\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\t\tif (!strcmp(options, \"nodefer\")) {\n\t\t\tdeferred_takeover = false;\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif (!strncmp(options, \"logo-pos:\", 9)) {\n\t\t\toptions += 9;\n\t\t\tif (!strcmp(options, \"center\"))\n\t\t\t\tfb_center_logo = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"logo-count:\", 11)) {\n\t\t\toptions += 11;\n\t\t\tif (*options)\n\t\t\t\tfb_logo_count = simple_strtol(options, &options, 0);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"fbcon=\", fb_console_setup);\n#endif\n\nstatic int search_fb_in_map(int idx)\n{\n\tint i, retval = 0;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] == idx)\n\t\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int search_for_mapped_con(void)\n{\n\tint i, retval = 0;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] != -1)\n\t\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int do_fbcon_takeover(int show_logo)\n{\n\tint err, i;\n\n\tif (!fbcon_num_registered_fb)\n\t\treturn -ENODEV;\n\n\tif (!show_logo)\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\tcon2fb_map[i] = info_idx;\n\n\terr = do_take_over_console(&fb_con, first_fb_vc, last_fb_vc,\n\t\t\t\tfbcon_is_default);\n\n\tif (err) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map[i] = -1;\n\t\tinfo_idx = -1;\n\t} else {\n\t\tfbcon_has_console_bind = 1;\n\t}\n\n\treturn err;\n}\n\n#ifdef MODULE\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\n\t\t\t       int cols, int rows, int new_cols, int new_rows)\n{\n\tlogo_shown = FBCON_LOGO_DONTSHOW;\n}\n#else\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\n\t\t\t       int cols, int rows, int new_cols, int new_rows)\n{\n\t/* Need to make room for the logo */\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint cnt, erase = vc->vc_video_erase_char, step;\n\tunsigned short *save = NULL, *r, *q;\n\tint logo_height;\n\n\tif (info->fbops->owner) {\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\t\treturn;\n\t}\n\n\t/*\n\t * remove underline attribute from erase character\n\t * if black and white framebuffer.\n\t */\n\tif (fb_get_color_depth(&info->var, &info->fix) == 1)\n\t\terase &= ~0x400;\n\tlogo_height = fb_prepare_logo(info, ops->rotate);\n\tlogo_lines = DIV_ROUND_UP(logo_height, vc->vc_font.height);\n\tq = (unsigned short *) (vc->vc_origin +\n\t\t\t\tvc->vc_size_row * rows);\n\tstep = logo_lines * cols;\n\tfor (r = q - logo_lines * cols; r < q; r++)\n\t\tif (scr_readw(r) != vc->vc_video_erase_char)\n\t\t\tbreak;\n\tif (r != q && new_rows >= rows + logo_lines) {\n\t\tsave = kzalloc(array3_size(logo_lines, new_cols, 2),\n\t\t\t       GFP_KERNEL);\n\t\tif (save) {\n\t\t\tint i = min(cols, new_cols);\n\t\t\tscr_memsetw(save, erase, array3_size(logo_lines, new_cols, 2));\n\t\t\tr = q - step;\n\t\t\tfor (cnt = 0; cnt < logo_lines; cnt++, r += i)\n\t\t\t\tscr_memcpyw(save + cnt * new_cols, r, 2 * i);\n\t\t\tr = q;\n\t\t}\n\t}\n\tif (r == q) {\n\t\t/* We can scroll screen down */\n\t\tr = q - step - cols;\n\t\tfor (cnt = rows - logo_lines; cnt > 0; cnt--) {\n\t\t\tscr_memcpyw(r + step, r, vc->vc_size_row);\n\t\t\tr -= cols;\n\t\t}\n\t\tif (!save) {\n\t\t\tint lines;\n\t\t\tif (vc->state.y + logo_lines >= rows)\n\t\t\t\tlines = rows - vc->state.y - 1;\n\t\t\telse\n\t\t\t\tlines = logo_lines;\n\t\t\tvc->state.y += lines;\n\t\t\tvc->vc_pos += lines * vc->vc_size_row;\n\t\t}\n\t}\n\tscr_memsetw((unsigned short *) vc->vc_origin,\n\t\t    erase,\n\t\t    vc->vc_size_row * logo_lines);\n\n\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (save) {\n\t\tq = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\trows);\n\t\tscr_memcpyw(q, save, array3_size(logo_lines, new_cols, 2));\n\t\tvc->state.y += logo_lines;\n\t\tvc->vc_pos += logo_lines * vc->vc_size_row;\n\t\tkfree(save);\n\t}\n\n\tif (logo_shown == FBCON_LOGO_DONTSHOW)\n\t\treturn;\n\n\tif (logo_lines > vc->vc_bottom) {\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\t\tprintk(KERN_INFO\n\t\t       \"fbcon_init: disable boot-logo (boot-logo bigger than screen).\\n\");\n\t} else {\n\t\tlogo_shown = FBCON_LOGO_DRAW;\n\t\tvc->vc_top = logo_lines;\n\t}\n}\n#endif /* MODULE */\n\n#ifdef CONFIG_FB_TILEBLITTING\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->p = &fb_display[vc->vc_num];\n\n\tif ((info->flags & FBINFO_MISC_TILEBLITTING))\n\t\tfbcon_set_tileops(vc, info);\n\telse {\n\t\tfbcon_set_rotation(info);\n\t\tfbcon_set_bitops(ops);\n\t}\n}\n\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\n{\n\tint err = 0;\n\n\tif (info->flags & FBINFO_MISC_TILEBLITTING &&\n\t    info->tileops->fb_get_tilemax(info) < charcount)\n\t\terr = 1;\n\n\treturn err;\n}\n#else\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tinfo->flags &= ~FBINFO_MISC_TILEBLITTING;\n\tops->p = &fb_display[vc->vc_num];\n\tfbcon_set_rotation(info);\n\tfbcon_set_bitops(ops);\n}\n\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MISC_TILEBLITTING */\n\nstatic void fbcon_release(struct fb_info *info)\n{\n\tlock_fb_info(info);\n\tif (info->fbops->fb_release)\n\t\tinfo->fbops->fb_release(info, 0);\n\tunlock_fb_info(info);\n\n\tmodule_put(info->fbops->owner);\n\n\tif (info->fbcon_par) {\n\t\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\t\tfbcon_del_cursor_work(info);\n\t\tkfree(ops->cursor_state.mask);\n\t\tkfree(ops->cursor_data);\n\t\tkfree(ops->cursor_src);\n\t\tkfree(ops->fontbuffer);\n\t\tkfree(info->fbcon_par);\n\t\tinfo->fbcon_par = NULL;\n\t}\n}\n\nstatic int fbcon_open(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops;\n\n\tif (!try_module_get(info->fbops->owner))\n\t\treturn -ENODEV;\n\n\tlock_fb_info(info);\n\tif (info->fbops->fb_open &&\n\t    info->fbops->fb_open(info, 0)) {\n\t\tunlock_fb_info(info);\n\t\tmodule_put(info->fbops->owner);\n\t\treturn -ENODEV;\n\t}\n\tunlock_fb_info(info);\n\n\tops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);\n\tif (!ops) {\n\t\tfbcon_release(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&ops->cursor_work, fb_flashcursor);\n\tops->info = info;\n\tinfo->fbcon_par = ops;\n\tops->cur_blink_jiffies = HZ / 5;\n\n\treturn 0;\n}\n\nstatic int con2fb_acquire_newinfo(struct vc_data *vc, struct fb_info *info,\n\t\t\t\t  int unit)\n{\n\tint err;\n\n\terr = fbcon_open(info);\n\tif (err)\n\t\treturn err;\n\n\tif (vc)\n\t\tset_blitting_type(vc, info);\n\n\treturn err;\n}\n\nstatic void con2fb_release_oldinfo(struct vc_data *vc, struct fb_info *oldinfo,\n\t\t\t\t   struct fb_info *newinfo)\n{\n\tint ret;\n\n\tfbcon_release(oldinfo);\n\n\t/*\n\t  If oldinfo and newinfo are driving the same hardware,\n\t  the fb_release() method of oldinfo may attempt to\n\t  restore the hardware state.  This will leave the\n\t  newinfo in an undefined state. Thus, a call to\n\t  fb_set_par() may be needed for the newinfo.\n\t*/\n\tif (newinfo && newinfo->fbops->fb_set_par) {\n\t\tret = newinfo->fbops->fb_set_par(newinfo);\n\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"con2fb_release_oldinfo: \"\n\t\t\t\t\"detected unhandled fb_set_par error, \"\n\t\t\t\t\"error code %d\\n\", ret);\n\t}\n}\n\nstatic void con2fb_init_display(struct vc_data *vc, struct fb_info *info,\n\t\t\t\tint unit, int show_logo)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint ret;\n\n\tops->currcon = fg_console;\n\n\tif (info->fbops->fb_set_par && !ops->initialized) {\n\t\tret = info->fbops->fb_set_par(info);\n\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"con2fb_init_display: detected \"\n\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\"error code %d\\n\", ret);\n\t}\n\n\tops->initialized = true;\n\tops->graphics = 0;\n\tfbcon_set_disp(info, &info->var, unit);\n\n\tif (show_logo) {\n\t\tstruct vc_data *fg_vc = vc_cons[fg_console].d;\n\t\tstruct fb_info *fg_info =\n\t\t\tfbcon_info_from_console(fg_console);\n\n\t\tfbcon_prepare_logo(fg_vc, fg_info, fg_vc->vc_cols,\n\t\t\t\t   fg_vc->vc_rows, fg_vc->vc_cols,\n\t\t\t\t   fg_vc->vc_rows);\n\t}\n\n\tupdate_screen(vc_cons[fg_console].d);\n}\n\n/**\n *\tset_con2fb_map - map console to frame buffer device\n *\t@unit: virtual console number to map\n *\t@newidx: frame buffer index to map virtual console to\n *      @user: user request\n *\n *\tMaps a virtual console @unit to a frame buffer device\n *\t@newidx.\n *\n *\tThis should be called with the console lock held.\n */\nstatic int set_con2fb_map(int unit, int newidx, int user)\n{\n\tstruct vc_data *vc = vc_cons[unit].d;\n\tint oldidx = con2fb_map[unit];\n\tstruct fb_info *info = fbcon_registered_fb[newidx];\n\tstruct fb_info *oldinfo = NULL;\n\tint found, err = 0, show_logo;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (oldidx == newidx)\n\t\treturn 0;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tif (!search_for_mapped_con() || !con_is_bound(&fb_con)) {\n\t\tinfo_idx = newidx;\n\t\treturn do_fbcon_takeover(0);\n\t}\n\n\tif (oldidx != -1)\n\t\toldinfo = fbcon_registered_fb[oldidx];\n\n\tfound = search_fb_in_map(newidx);\n\n\tif (!err && !found) {\n\t\terr = con2fb_acquire_newinfo(vc, info, unit);\n\t\tif (!err)\n\t\t\tcon2fb_map[unit] = newidx;\n\t}\n\n\t/*\n\t * If old fb is not mapped to any of the consoles,\n\t * fbcon should release it.\n\t */\n\tif (!err && oldinfo && !search_fb_in_map(oldidx))\n\t\tcon2fb_release_oldinfo(vc, oldinfo, info);\n\n\tshow_logo = (fg_console == 0 && !user &&\n\t\t\t logo_shown != FBCON_LOGO_DONTSHOW);\n\n\tif (!found)\n\t\tfbcon_add_cursor_work(info);\n\tcon2fb_map_boot[unit] = newidx;\n\tcon2fb_init_display(vc, info, unit, show_logo);\n\n\tif (!search_fb_in_map(info_idx))\n\t\tinfo_idx = newidx;\n\n\treturn err;\n}\n\n/*\n *  Low Level Operations\n */\n/* NOTE: fbcon cannot be __init: it may be called from do_take_over_console later */\nstatic int var_to_display(struct fbcon_display *disp,\n\t\t\t  struct fb_var_screeninfo *var,\n\t\t\t  struct fb_info *info)\n{\n\tdisp->xres_virtual = var->xres_virtual;\n\tdisp->yres_virtual = var->yres_virtual;\n\tdisp->bits_per_pixel = var->bits_per_pixel;\n\tdisp->grayscale = var->grayscale;\n\tdisp->nonstd = var->nonstd;\n\tdisp->accel_flags = var->accel_flags;\n\tdisp->height = var->height;\n\tdisp->width = var->width;\n\tdisp->red = var->red;\n\tdisp->green = var->green;\n\tdisp->blue = var->blue;\n\tdisp->transp = var->transp;\n\tdisp->rotate = var->rotate;\n\tdisp->mode = fb_match_mode(var, &info->modelist);\n\tif (disp->mode == NULL)\n\t\t/* This should not happen */\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void display_to_var(struct fb_var_screeninfo *var,\n\t\t\t   struct fbcon_display *disp)\n{\n\tfb_videomode_to_var(var, disp->mode);\n\tvar->xres_virtual = disp->xres_virtual;\n\tvar->yres_virtual = disp->yres_virtual;\n\tvar->bits_per_pixel = disp->bits_per_pixel;\n\tvar->grayscale = disp->grayscale;\n\tvar->nonstd = disp->nonstd;\n\tvar->accel_flags = disp->accel_flags;\n\tvar->height = disp->height;\n\tvar->width = disp->width;\n\tvar->red = disp->red;\n\tvar->green = disp->green;\n\tvar->blue = disp->blue;\n\tvar->transp = disp->transp;\n\tvar->rotate = disp->rotate;\n}\n\nstatic const char *fbcon_startup(void)\n{\n\tconst char *display_desc = \"frame buffer device\";\n\tstruct fbcon_display *p = &fb_display[fg_console];\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tconst struct font_desc *font = NULL;\n\tstruct fb_info *info = NULL;\n\tstruct fbcon_ops *ops;\n\tint rows, cols;\n\n\t/*\n\t *  If num_registered_fb is zero, this is a call for the dummy part.\n\t *  The frame buffer devices weren't initialized yet.\n\t */\n\tif (!fbcon_num_registered_fb || info_idx == -1)\n\t\treturn display_desc;\n\t/*\n\t * Instead of blindly using registered_fb[0], we use info_idx, set by\n\t * fbcon_fb_registered();\n\t */\n\tinfo = fbcon_registered_fb[info_idx];\n\tif (!info)\n\t\treturn NULL;\n\t\n\tif (fbcon_open(info))\n\t\treturn NULL;\n\n\tops = info->fbcon_par;\n\tops->currcon = -1;\n\tops->graphics = 1;\n\tops->cur_rotate = -1;\n\n\tp->con_rotate = initial_rotation;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = info->fbcon_rotate_hint;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = FB_ROTATE_UR;\n\n\tset_blitting_type(vc, info);\n\n\t/* Setup default font */\n\tif (!p->fontdata && !vc->vc_font.data) {\n\t\tif (!fontname[0] || !(font = find_font(fontname)))\n\t\t\tfont = get_default_font(info->var.xres,\n\t\t\t\t\t\tinfo->var.yres,\n\t\t\t\t\t\tinfo->pixmap.blit_x,\n\t\t\t\t\t\tinfo->pixmap.blit_y);\n\t\tvc->vc_font.width = font->width;\n\t\tvc->vc_font.height = font->height;\n\t\tvc->vc_font.data = (void *)(p->fontdata = font->data);\n\t\tvc->vc_font.charcount = font->charcount;\n\t} else {\n\t\tp->fontdata = vc->vc_font.data;\n\t}\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tpr_debug(\"mode:   %s\\n\", info->fix.id);\n\tpr_debug(\"visual: %d\\n\", info->fix.visual);\n\tpr_debug(\"res:    %dx%d-%d\\n\", info->var.xres,\n\t\t info->var.yres,\n\t\t info->var.bits_per_pixel);\n\n\tfbcon_add_cursor_work(info);\n\treturn display_desc;\n}\n\nstatic void fbcon_init(struct vc_data *vc, int init)\n{\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tstruct vc_data **default_mode = vc->vc_display_fg;\n\tstruct vc_data *svc = *default_mode;\n\tstruct fbcon_display *t, *p = &fb_display[vc->vc_num];\n\tint logo = 1, new_rows, new_cols, rows, cols;\n\tint ret;\n\n\tif (WARN_ON(info_idx == -1))\n\t    return;\n\n\tif (con2fb_map[vc->vc_num] == -1)\n\t\tcon2fb_map[vc->vc_num] = info_idx;\n\n\tinfo = fbcon_info_from_console(vc->vc_num);\n\n\tif (logo_shown < 0 && console_loglevel <= CONSOLE_LOGLEVEL_QUIET)\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tif (vc != svc || logo_shown == FBCON_LOGO_DONTSHOW ||\n\t    (info->fix.type == FB_TYPE_TEXT))\n\t\tlogo = 0;\n\n\tif (var_to_display(p, &info->var, info))\n\t\treturn;\n\n\tif (!info->fbcon_par)\n\t\tcon2fb_acquire_newinfo(vc, info, vc->vc_num);\n\n\t/* If we are not the first console on this\n\t   fb, copy the font from that console */\n\tt = &fb_display[fg_console];\n\tif (!p->fontdata) {\n\t\tif (t->fontdata) {\n\t\t\tstruct vc_data *fvc = vc_cons[fg_console].d;\n\n\t\t\tvc->vc_font.data = (void *)(p->fontdata =\n\t\t\t\t\t\t    fvc->vc_font.data);\n\t\t\tvc->vc_font.width = fvc->vc_font.width;\n\t\t\tvc->vc_font.height = fvc->vc_font.height;\n\t\t\tvc->vc_font.charcount = fvc->vc_font.charcount;\n\t\t\tp->userfont = t->userfont;\n\n\t\t\tif (p->userfont)\n\t\t\t\tREFCOUNT(p->fontdata)++;\n\t\t} else {\n\t\t\tconst struct font_desc *font = NULL;\n\n\t\t\tif (!fontname[0] || !(font = find_font(fontname)))\n\t\t\t\tfont = get_default_font(info->var.xres,\n\t\t\t\t\t\t\tinfo->var.yres,\n\t\t\t\t\t\t\tinfo->pixmap.blit_x,\n\t\t\t\t\t\t\tinfo->pixmap.blit_y);\n\t\t\tvc->vc_font.width = font->width;\n\t\t\tvc->vc_font.height = font->height;\n\t\t\tvc->vc_font.data = (void *)(p->fontdata = font->data);\n\t\t\tvc->vc_font.charcount = font->charcount;\n\t\t}\n\t}\n\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (vc->vc_font.charcount == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->uni_pagedict_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->uni_pagedict_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tops = info->fbcon_par;\n\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);\n\n\tp->con_rotate = initial_rotation;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = info->fbcon_rotate_hint;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = FB_ROTATE_UR;\n\n\tset_blitting_type(vc, info);\n\n\tcols = vc->vc_cols;\n\trows = vc->vc_rows;\n\tnew_cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\tnew_rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tnew_cols /= vc->vc_font.width;\n\tnew_rows /= vc->vc_font.height;\n\n\t/*\n\t * We must always set the mode. The mode of the previous console\n\t * driver could be in the same resolution but we are using different\n\t * hardware so we have to initialize the hardware.\n\t *\n\t * We need to do it in fbcon_init() to prevent screen corruption.\n\t */\n\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\tif (info->fbops->fb_set_par && !ops->initialized) {\n\t\t\tret = info->fbops->fb_set_par(info);\n\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR \"fbcon_init: detected \"\n\t\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\t\"error code %d\\n\", ret);\n\t\t}\n\n\t\tops->initialized = true;\n\t}\n\n\tops->graphics = 0;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION\n\tif ((info->flags & FBINFO_HWACCEL_COPYAREA) &&\n\t    !(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\tp->scrollmode = SCROLL_MOVE;\n\telse /* default to something safe */\n\t\tp->scrollmode = SCROLL_REDRAW;\n#endif\n\n\t/*\n\t *  ++guenther: console.c:vc_allocate() relies on initializing\n\t *  vc_{cols,rows}, but we must not set those if we are only\n\t *  resizing the console.\n\t */\n\tif (init) {\n\t\tvc->vc_cols = new_cols;\n\t\tvc->vc_rows = new_rows;\n\t} else\n\t\tvc_resize(vc, new_cols, new_rows);\n\n\tif (logo)\n\t\tfbcon_prepare_logo(vc, info, cols, rows, new_cols, new_rows);\n\n\tif (ops->rotate_font && ops->rotate_font(info, vc)) {\n\t\tops->rotate = FB_ROTATE_UR;\n\t\tset_blitting_type(vc, info);\n\t}\n\n\tops->p = &fb_display[fg_console];\n}\n\nstatic void fbcon_free_font(struct fbcon_display *p, bool freefont)\n{\n\tif (freefont && p->userfont && p->fontdata && (--REFCOUNT(p->fontdata) == 0))\n\t\tkfree(p->fontdata - FONT_EXTRA_WORDS * sizeof(int));\n\tp->fontdata = NULL;\n\tp->userfont = 0;\n}\n\nstatic void set_vc_hi_font(struct vc_data *vc, bool set);\n\nstatic void fbcon_release_all(void)\n{\n\tstruct fb_info *info;\n\tint i, j, mapped;\n\n\tfbcon_for_each_registered_fb(i) {\n\t\tmapped = 0;\n\t\tinfo = fbcon_registered_fb[i];\n\n\t\tfor (j = first_fb_vc; j <= last_fb_vc; j++) {\n\t\t\tif (con2fb_map[j] == i) {\n\t\t\t\tmapped = 1;\n\t\t\t\tcon2fb_map[j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (mapped)\n\t\t\tfbcon_release(info);\n\t}\n}\n\nstatic void fbcon_deinit(struct vc_data *vc)\n{\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tint idx;\n\tbool free_font = true;\n\n\tidx = con2fb_map[vc->vc_num];\n\n\tif (idx == -1)\n\t\tgoto finished;\n\n\tinfo = fbcon_registered_fb[idx];\n\n\tif (!info)\n\t\tgoto finished;\n\n\tif (info->flags & FBINFO_MISC_FIRMWARE)\n\t\tfree_font = false;\n\tops = info->fbcon_par;\n\n\tif (!ops)\n\t\tgoto finished;\n\n\tif (con_is_visible(vc))\n\t\tfbcon_del_cursor_work(info);\n\n\tops->initialized = false;\nfinished:\n\n\tfbcon_free_font(p, free_font);\n\tif (free_font)\n\t\tvc->vc_font.data = NULL;\n\n\tif (vc->vc_hi_font_mask && vc->vc_screenbuf)\n\t\tset_vc_hi_font(vc, false);\n\n\tif (!con_is_bound(&fb_con))\n\t\tfbcon_release_all();\n\n\tif (vc->vc_num == logo_shown)\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\n\treturn;\n}\n\n/* ====================================================================== */\n\n/*  fbcon_XXX routines - interface used by the world\n *\n *  This system is now divided into two levels because of complications\n *  caused by hardware scrolling. Top level functions:\n *\n *\tfbcon_bmove(), fbcon_clear(), fbcon_putc(), fbcon_clear_margins()\n *\n *  handles y values in range [0, scr_height-1] that correspond to real\n *  screen positions. y_wrap shift means that first line of bitmap may be\n *  anywhere on this display. These functions convert lineoffsets to\n *  bitmap offsets and deal with the wrap-around case by splitting blits.\n *\n *\tfbcon_bmove_physical_8()    -- These functions fast implementations\n *\tfbcon_clear_physical_8()    -- of original fbcon_XXX fns.\n *\tfbcon_putc_physical_8()\t    -- (font width != 8) may be added later\n *\n *  WARNING:\n *\n *  At the moment fbcon_putc() cannot blit across vertical wrap boundary\n *  Implies should only really hardware scroll in rows. Only reason for\n *  restriction is simplicity & efficiency at the moment.\n */\n\nstatic void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\tint width)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tu_int y_break;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!height || !width)\n\t\treturn;\n\n\tif (sy < vc->vc_top && vc->vc_top == logo_lines) {\n\t\tvc->vc_top = 0;\n\t\t/*\n\t\t * If the font dimensions are not an integral of the display\n\t\t * dimensions then the ops->clear below won't end up clearing\n\t\t * the margins.  Call clear_margins here in case the logo\n\t\t * bitmap stretched into the margin area.\n\t\t */\n\t\tfbcon_clear_margins(vc, 0);\n\t}\n\n\t/* Split blits that cross physical y_wrap boundary */\n\n\ty_break = p->vrows - p->yscroll;\n\tif (sy < y_break && sy + height - 1 >= y_break) {\n\t\tu_int b = y_break - sy;\n\t\tops->clear(vc, info, real_y(p, sy), sx, b, width);\n\t\tops->clear(vc, info, real_y(p, sy + b), sx, height - b,\n\t\t\t\t width);\n\t} else\n\t\tops->clear(vc, info, real_y(p, sy), sx, height, width);\n}\n\nstatic void fbcon_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\tint count, int ypos, int xpos)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_is_inactive(vc, info))\n\t\tops->putcs(vc, info, s, count, real_y(p, ypos), xpos,\n\t\t\t   get_color(vc, info, scr_readw(s), 1),\n\t\t\t   get_color(vc, info, scr_readw(s), 0));\n}\n\nstatic void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)\n{\n\tunsigned short chr;\n\n\tscr_writew(c, &chr);\n\tfbcon_putcs(vc, &chr, 1, ypos, xpos);\n}\n\nstatic void fbcon_clear_margins(struct vc_data *vc, int bottom_only)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_is_inactive(vc, info))\n\t\tops->clear_margins(vc, info, margin_color, bottom_only);\n}\n\nstatic void fbcon_cursor(struct vc_data *vc, int mode)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n \tint c = scr_readw((u16 *) vc->vc_pos);\n\n\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);\n\n\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)\n\t\treturn;\n\n\tif (vc->vc_cursor_type & CUR_SW)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;\n\n\tif (!ops->cursor)\n\t\treturn;\n\n\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),\n\t\t    get_color(vc, info, c, 0));\n}\n\nstatic int scrollback_phys_max = 0;\nstatic int scrollback_max = 0;\nstatic int scrollback_current = 0;\n\nstatic void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit)\n{\n\tstruct fbcon_display *p, *t;\n\tstruct vc_data **default_mode, *vc;\n\tstruct vc_data *svc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint rows, cols;\n\n\tp = &fb_display[unit];\n\n\tif (var_to_display(p, var, info))\n\t\treturn;\n\n\tvc = vc_cons[unit].d;\n\n\tif (!vc)\n\t\treturn;\n\n\tdefault_mode = vc->vc_display_fg;\n\tsvc = *default_mode;\n\tt = &fb_display[svc->vc_num];\n\n\tif (!vc->vc_font.data) {\n\t\tvc->vc_font.data = (void *)(p->fontdata = t->fontdata);\n\t\tvc->vc_font.width = (*default_mode)->vc_font.width;\n\t\tvc->vc_font.height = (*default_mode)->vc_font.height;\n\t\tvc->vc_font.charcount = (*default_mode)->vc_font.charcount;\n\t\tp->userfont = t->userfont;\n\t\tif (p->userfont)\n\t\t\tREFCOUNT(p->fontdata)++;\n\t}\n\n\tvar->activate = FB_ACTIVATE_NOW;\n\tinfo->var.activate = var->activate;\n\tvar->yoffset = info->var.yoffset;\n\tvar->xoffset = info->var.xoffset;\n\tfb_set_var(info, var);\n\tops->var = info->var;\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (vc->vc_font.charcount == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->uni_pagedict_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->uni_pagedict_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tif (con_is_visible(vc)) {\n\t\tupdate_screen(vc);\n\t}\n}\n\nstatic __inline__ void ywrap_up(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll += count;\n\tif (p->yscroll >= p->vrows)\t/* Deal with wrap */\n\t\tp->yscroll -= p->vrows;\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode |= FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ywrap_down(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll -= count;\n\tif (p->yscroll < 0)\t/* Deal with wrap */\n\t\tp->yscroll += p->vrows;\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode |= FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_up(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tp->yscroll += count;\n\tif (p->yscroll > p->vrows - vc->vc_rows) {\n\t\tops->bmove(vc, info, p->vrows - vc->vc_rows,\n\t\t\t    0, 0, 0, vc->vc_rows, vc->vc_cols);\n\t\tp->yscroll -= p->vrows - vc->vc_rows;\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_up_redraw(struct vc_data *vc, int t, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll += count;\n\n\tif (p->yscroll > p->vrows - vc->vc_rows) {\n\t\tp->yscroll -= p->vrows - vc->vc_rows;\n\t\tfbcon_redraw_move(vc, p, t + count, vc->vc_rows - count, t);\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_down(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tp->yscroll -= count;\n\tif (p->yscroll < 0) {\n\t\tops->bmove(vc, info, 0, 0, p->vrows - vc->vc_rows,\n\t\t\t    0, vc->vc_rows, vc->vc_cols);\n\t\tp->yscroll += p->vrows - vc->vc_rows;\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_down_redraw(struct vc_data *vc, int t, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll -= count;\n\n\tif (p->yscroll < 0) {\n\t\tp->yscroll += p->vrows - vc->vc_rows;\n\t\tfbcon_redraw_move(vc, p, t, vc->vc_rows - count, t + count);\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic void fbcon_redraw_move(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t      int line, int count, int dy)\n{\n\tunsigned short *s = (unsigned short *)\n\t\t(vc->vc_origin + vc->vc_size_row * line);\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\t\tunsigned short attr = 1;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\t\t\tif (attr != (c & 0xff00)) {\n\t\t\t\tattr = c & 0xff00;\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t    dy, x);\n\t\t\t\t\tx += s - start;\n\t\t\t\t\tstart = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tfbcon_putcs(vc, start, s - start, dy, x);\n\t\tconsole_conditional_schedule();\n\t\tdy++;\n\t}\n}\n\nstatic void fbcon_redraw_blit(struct vc_data *vc, struct fb_info *info,\n\t\t\tstruct fbcon_display *p, int line, int count, int ycount)\n{\n\tint offset = ycount * vc->vc_cols;\n\tunsigned short *d = (unsigned short *)\n\t    (vc->vc_origin + vc->vc_size_row * line);\n\tunsigned short *s = d + offset;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\n\t\t\tif (c == scr_readw(d)) {\n\t\t\t\tif (s > start) {\n\t\t\t\t\tops->bmove(vc, info, line + ycount, x,\n\t\t\t\t\t\t   line, x, 1, s-start);\n\t\t\t\t\tx += s - start + 1;\n\t\t\t\t\tstart = s + 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscr_writew(c, d);\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t\td++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tops->bmove(vc, info, line + ycount, x, line, x, 1,\n\t\t\t\t   s-start);\n\t\tconsole_conditional_schedule();\n\t\tif (ycount > 0)\n\t\t\tline++;\n\t\telse {\n\t\t\tline--;\n\t\t\t/* NOTE: We subtract two lines from these pointers */\n\t\t\ts -= vc->vc_size_row;\n\t\t\td -= vc->vc_size_row;\n\t\t}\n\t}\n}\n\nstatic void fbcon_redraw(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t int line, int count, int offset)\n{\n\tunsigned short *d = (unsigned short *)\n\t    (vc->vc_origin + vc->vc_size_row * line);\n\tunsigned short *s = d + offset;\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\t\tunsigned short attr = 1;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\t\t\tif (attr != (c & 0xff00)) {\n\t\t\t\tattr = c & 0xff00;\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t    line, x);\n\t\t\t\t\tx += s - start;\n\t\t\t\t\tstart = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == scr_readw(d)) {\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t     line, x);\n\t\t\t\t\tx += s - start + 1;\n\t\t\t\t\tstart = s + 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscr_writew(c, d);\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t\td++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tfbcon_putcs(vc, start, s - start, line, x);\n\t\tconsole_conditional_schedule();\n\t\tif (offset > 0)\n\t\t\tline++;\n\t\telse {\n\t\t\tline--;\n\t\t\t/* NOTE: We subtract two lines from these pointers */\n\t\t\ts -= vc->vc_size_row;\n\t\t\td -= vc->vc_size_row;\n\t\t}\n\t}\n}\n\nstatic void fbcon_bmove_rec(struct vc_data *vc, struct fbcon_display *p, int sy, int sx,\n\t\t\t    int dy, int dx, int height, int width, u_int y_break)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tu_int b;\n\n\tif (sy < y_break && sy + height > y_break) {\n\t\tb = y_break - sy;\n\t\tif (dy < sy) {\t/* Avoid trashing self */\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t} else {\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (dy < y_break && dy + height > y_break) {\n\t\tb = y_break - dy;\n\t\tif (dy < sy) {\t/* Avoid trashing self */\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t} else {\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t}\n\t\treturn;\n\t}\n\tops->bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,\n\t\t   height, width);\n}\n\nstatic void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,\n\t\t\tint height, int width)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!width || !height)\n\t\treturn;\n\n\t/*  Split blits that cross physical y_wrap case.\n\t *  Pathological case involves 4 blits, better to use recursive\n\t *  code rather than unrolled case\n\t *\n\t *  Recursive invocations don't need to erase the cursor over and\n\t *  over again, so we use fbcon_bmove_rec()\n\t */\n\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, height, width,\n\t\t\tp->vrows - p->yscroll);\n}\n\nstatic bool fbcon_scroll(struct vc_data *vc, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint scroll_partial = info->flags & FBINFO_PARTIAL_PAN_OK;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn true;\n\n\tfbcon_cursor(vc, CM_ERASE);\n\n\t/*\n\t * ++Geert: Only use ywrap/ypan if the console is in text mode\n\t * ++Andrew: Only use ypan on hardware text mode when scrolling the\n\t *           whole screen (prevents flicker).\n\t */\n\n\tswitch (dir) {\n\tcase SM_UP:\n\t\tif (count > vc->vc_rows)\t/* Maximum realistic size */\n\t\t\tcount = vc->vc_rows;\n\t\tswitch (fb_scrollmode(p)) {\n\t\tcase SCROLL_MOVE:\n\t\t\tfbcon_redraw_blit(vc, info, p, t, b - t - count,\n\t\t\t\t     count);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\t(b - count)),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\n\t\tcase SCROLL_WRAP_MOVE:\n\t\t\tif (b - t - count > 3 * vc->vc_rows >> 2) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, 0, 0, count, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\tywrap_up(vc, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b - count, 0, b, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t + count, 0, t, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_up;\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_REDRAW:\n\t\t\tif ((p->yscroll + count <=\n\t\t\t     2 * (p->vrows - vc->vc_rows))\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, 0, t, count);\n\t\t\t\typan_up_redraw(vc, t, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, b,\n\t\t\t\t\t\t\t  vc->vc_rows - b, b);\n\t\t\t} else\n\t\t\t\tfbcon_redraw_move(vc, p, t + count, b - t - count, t);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_MOVE:\n\t\t\tif ((p->yscroll + count <=\n\t\t\t     2 * (p->vrows - vc->vc_rows))\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, 0, 0, count, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\typan_up(vc, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b - count, 0, b, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t + count, 0, t, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_up;\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_REDRAW:\n\t\t      redraw_up:\n\t\t\tfbcon_redraw(vc, p, t, b - t - count,\n\t\t\t\t     count * vc->vc_cols);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\t(b - count)),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase SM_DOWN:\n\t\tif (count > vc->vc_rows)\t/* Maximum realistic size */\n\t\t\tcount = vc->vc_rows;\n\t\tswitch (fb_scrollmode(p)) {\n\t\tcase SCROLL_MOVE:\n\t\t\tfbcon_redraw_blit(vc, info, p, b - 1, b - t - count,\n\t\t\t\t     -count);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\tt),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\n\t\tcase SCROLL_WRAP_MOVE:\n\t\t\tif (b - t - count > 3 * vc->vc_rows >> 2) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b, 0, b - count, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\tywrap_down(vc, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, count, 0, 0, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t, 0, t + count, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_down;\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_MOVE:\n\t\t\tif ((count - p->yscroll <= p->vrows - vc->vc_rows)\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b, 0, b - count, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\typan_down(vc, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, count, 0, 0, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t, 0, t + count, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_down;\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_REDRAW:\n\t\t\tif ((count - p->yscroll <= p->vrows - vc->vc_rows)\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, b, vc->vc_rows - b,\n\t\t\t\t\t\t\t  b - count);\n\t\t\t\typan_down_redraw(vc, t, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, count, t, 0);\n\t\t\t} else\n\t\t\t\tfbcon_redraw_move(vc, p, t, b - t - count, t + count);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_REDRAW:\n\t\t      redraw_down:\n\t\t\tfbcon_redraw(vc, p, b - 1, b - t - count,\n\t\t\t\t     -count * vc->vc_cols);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\tt),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nstatic void updatescrollmode_accel(struct fbcon_display *p,\n\t\t\t\t\tstruct fb_info *info,\n\t\t\t\t\tstruct vc_data *vc)\n{\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint cap = info->flags;\n\tu16 t = 0;\n\tint ypan = FBCON_SWAP(ops->rotate, info->fix.ypanstep,\n\t\t\t\t  info->fix.xpanstep);\n\tint ywrap = FBCON_SWAP(ops->rotate, info->fix.ywrapstep, t);\n\tint yres = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tint vyres = FBCON_SWAP(ops->rotate, info->var.yres_virtual,\n\t\t\t\t   info->var.xres_virtual);\n\tint good_pan = (cap & FBINFO_HWACCEL_YPAN) &&\n\t\tdivides(ypan, vc->vc_font.height) && vyres > yres;\n\tint good_wrap = (cap & FBINFO_HWACCEL_YWRAP) &&\n\t\tdivides(ywrap, vc->vc_font.height) &&\n\t\tdivides(vc->vc_font.height, vyres) &&\n\t\tdivides(vc->vc_font.height, yres);\n\tint reading_fast = cap & FBINFO_READS_FAST;\n\tint fast_copyarea = (cap & FBINFO_HWACCEL_COPYAREA) &&\n\t\t!(cap & FBINFO_HWACCEL_DISABLED);\n\tint fast_imageblit = (cap & FBINFO_HWACCEL_IMAGEBLIT) &&\n\t\t!(cap & FBINFO_HWACCEL_DISABLED);\n\n\tif (good_wrap || good_pan) {\n\t\tif (reading_fast || fast_copyarea)\n\t\t\tp->scrollmode = good_wrap ?\n\t\t\t\tSCROLL_WRAP_MOVE : SCROLL_PAN_MOVE;\n\t\telse\n\t\t\tp->scrollmode = good_wrap ? SCROLL_REDRAW :\n\t\t\t\tSCROLL_PAN_REDRAW;\n\t} else {\n\t\tif (reading_fast || (fast_copyarea && !fast_imageblit))\n\t\t\tp->scrollmode = SCROLL_MOVE;\n\t\telse\n\t\t\tp->scrollmode = SCROLL_REDRAW;\n\t}\n#endif\n}\n\nstatic void updatescrollmode(struct fbcon_display *p,\n\t\t\t\t\tstruct fb_info *info,\n\t\t\t\t\tstruct vc_data *vc)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint fh = vc->vc_font.height;\n\tint yres = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tint vyres = FBCON_SWAP(ops->rotate, info->var.yres_virtual,\n\t\t\t\t   info->var.xres_virtual);\n\n\tp->vrows = vyres/fh;\n\tif (yres > (fh * (vc->vc_rows + 1)))\n\t\tp->vrows -= (yres - (fh * vc->vc_rows)) / fh;\n\tif ((yres % fh) && (vyres % fh < yres % fh))\n\t\tp->vrows--;\n\n\t/* update scrollmode in case hardware acceleration is used */\n\tupdatescrollmode_accel(p, info, vc);\n}\n\n#define PITCH(w) (((w) + 7) >> 3)\n#define CALC_FONTSZ(h, p, c) ((h) * (p) * (c)) /* size = height * pitch * charcount */\n\nstatic int fbcon_resize(struct vc_data *vc, unsigned int width, \n\t\t\tunsigned int height, unsigned int user)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_var_screeninfo var = info->var;\n\tint x_diff, y_diff, virt_w, virt_h, virt_fw, virt_fh;\n\n\tif (p->userfont && FNTSIZE(vc->vc_font.data)) {\n\t\tint size;\n\t\tint pitch = PITCH(vc->vc_font.width);\n\n\t\t/*\n\t\t * If user font, ensure that a possible change to user font\n\t\t * height or width will not allow a font data out-of-bounds access.\n\t\t * NOTE: must use original charcount in calculation as font\n\t\t * charcount can change and cannot be used to determine the\n\t\t * font data allocated size.\n\t\t */\n\t\tif (pitch <= 0)\n\t\t\treturn -EINVAL;\n\t\tsize = CALC_FONTSZ(vc->vc_font.height, pitch, vc->vc_font.charcount);\n\t\tif (size > FNTSIZE(vc->vc_font.data))\n\t\t\treturn -EINVAL;\n\t}\n\n\tvirt_w = FBCON_SWAP(ops->rotate, width, height);\n\tvirt_h = FBCON_SWAP(ops->rotate, height, width);\n\tvirt_fw = FBCON_SWAP(ops->rotate, vc->vc_font.width,\n\t\t\t\t vc->vc_font.height);\n\tvirt_fh = FBCON_SWAP(ops->rotate, vc->vc_font.height,\n\t\t\t\t vc->vc_font.width);\n\tvar.xres = virt_w * virt_fw;\n\tvar.yres = virt_h * virt_fh;\n\tx_diff = info->var.xres - var.xres;\n\ty_diff = info->var.yres - var.yres;\n\tif (x_diff < 0 || x_diff > virt_fw ||\n\t    y_diff < 0 || y_diff > virt_fh) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tpr_debug(\"attempting resize %ix%i\\n\", var.xres, var.yres);\n\t\tmode = fb_find_best_mode(&var, &info->modelist);\n\t\tif (mode == NULL)\n\t\t\treturn -EINVAL;\n\t\tdisplay_to_var(&var, p);\n\t\tfb_videomode_to_var(&var, mode);\n\n\t\tif (virt_w > var.xres/virt_fw || virt_h > var.yres/virt_fh)\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"resize now %ix%i\\n\", var.xres, var.yres);\n\t\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\t\tvar.activate = FB_ACTIVATE_NOW |\n\t\t\t\tFB_ACTIVATE_FORCE;\n\t\t\tfb_set_var(info, &var);\n\t\t}\n\t\tvar_to_display(p, &info->var, info);\n\t\tops->var = info->var;\n\t}\n\tupdatescrollmode(p, info, vc);\n\treturn 0;\n}\n\nstatic int fbcon_switch(struct vc_data *vc)\n{\n\tstruct fb_info *info, *old_info = NULL;\n\tstruct fbcon_ops *ops;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_var_screeninfo var;\n\tint i, ret, prev_console;\n\n\tinfo = fbcon_info_from_console(vc->vc_num);\n\tops = info->fbcon_par;\n\n\tif (logo_shown >= 0) {\n\t\tstruct vc_data *conp2 = vc_cons[logo_shown].d;\n\n\t\tif (conp2->vc_top == logo_lines\n\t\t    && conp2->vc_bottom == conp2->vc_rows)\n\t\t\tconp2->vc_top = 0;\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\t}\n\n\tprev_console = ops->currcon;\n\tif (prev_console != -1)\n\t\told_info = fbcon_info_from_console(prev_console);\n\t/*\n\t * FIXME: If we have multiple fbdev's loaded, we need to\n\t * update all info->currcon.  Perhaps, we can place this\n\t * in a centralized structure, but this might break some\n\t * drivers.\n\t *\n\t * info->currcon = vc->vc_num;\n\t */\n\tfbcon_for_each_registered_fb(i) {\n\t\tif (fbcon_registered_fb[i]->fbcon_par) {\n\t\t\tstruct fbcon_ops *o = fbcon_registered_fb[i]->fbcon_par;\n\n\t\t\to->currcon = vc->vc_num;\n\t\t}\n\t}\n\tmemset(&var, 0, sizeof(struct fb_var_screeninfo));\n\tdisplay_to_var(&var, p);\n\tvar.activate = FB_ACTIVATE_NOW;\n\n\t/*\n\t * make sure we don't unnecessarily trip the memcmp()\n\t * in fb_set_var()\n\t */\n\tinfo->var.activate = var.activate;\n\tvar.vmode |= info->var.vmode & ~FB_VMODE_MASK;\n\tfb_set_var(info, &var);\n\tops->var = info->var;\n\n\tif (old_info != NULL && (old_info != info ||\n\t\t\t\t info->flags & FBINFO_MISC_ALWAYS_SETPAR)) {\n\t\tif (info->fbops->fb_set_par) {\n\t\t\tret = info->fbops->fb_set_par(info);\n\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR \"fbcon_switch: detected \"\n\t\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\t\"error code %d\\n\", ret);\n\t\t}\n\n\t\tif (old_info != info)\n\t\t\tfbcon_del_cursor_work(old_info);\n\t}\n\n\tif (fbcon_is_inactive(vc, info) ||\n\t    ops->blank_state != FB_BLANK_UNBLANK)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\tset_blitting_type(vc, info);\n\tops->cursor_reset = 1;\n\n\tif (ops->rotate_font && ops->rotate_font(info, vc)) {\n\t\tops->rotate = FB_ROTATE_UR;\n\t\tset_blitting_type(vc, info);\n\t}\n\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\n\tif (vc->vc_font.charcount > 256)\n\t\tvc->vc_complement_mask <<= 1;\n\n\tupdatescrollmode(p, info, vc);\n\n\tswitch (fb_scrollmode(p)) {\n\tcase SCROLL_WRAP_MOVE:\n\t\tscrollback_phys_max = p->vrows - vc->vc_rows;\n\t\tbreak;\n\tcase SCROLL_PAN_MOVE:\n\tcase SCROLL_PAN_REDRAW:\n\t\tscrollback_phys_max = p->vrows - 2 * vc->vc_rows;\n\t\tif (scrollback_phys_max < 0)\n\t\t\tscrollback_phys_max = 0;\n\t\tbreak;\n\tdefault:\n\t\tscrollback_phys_max = 0;\n\t\tbreak;\n\t}\n\n\tscrollback_max = 0;\n\tscrollback_current = 0;\n\n\tif (!fbcon_is_inactive(vc, info)) {\n\t    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\n\t    ops->update_start(info);\n\t}\n\n\tfbcon_set_palette(vc, color_table); \t\n\tfbcon_clear_margins(vc, 0);\n\n\tif (logo_shown == FBCON_LOGO_DRAW) {\n\n\t\tlogo_shown = fg_console;\n\t\tfb_show_logo(info, ops->rotate);\n\t\tupdate_region(vc,\n\t\t\t      vc->vc_origin + vc->vc_size_row * vc->vc_top,\n\t\t\t      vc->vc_size_row * (vc->vc_bottom -\n\t\t\t\t\t\t vc->vc_top) / 2);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void fbcon_generic_blank(struct vc_data *vc, struct fb_info *info,\n\t\t\t\tint blank)\n{\n\tif (blank) {\n\t\tunsigned short charmask = vc->vc_hi_font_mask ?\n\t\t\t0x1ff : 0xff;\n\t\tunsigned short oldc;\n\n\t\toldc = vc->vc_video_erase_char;\n\t\tvc->vc_video_erase_char &= charmask;\n\t\tfbcon_clear(vc, 0, 0, vc->vc_rows, vc->vc_cols);\n\t\tvc->vc_video_erase_char = oldc;\n\t}\n}\n\nstatic int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (mode_switch) {\n\t\tstruct fb_var_screeninfo var = info->var;\n\n\t\tops->graphics = 1;\n\n\t\tif (!blank) {\n\t\t\tvar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE |\n\t\t\t\tFB_ACTIVATE_KD_TEXT;\n\t\t\tfb_set_var(info, &var);\n\t\t\tops->graphics = 0;\n\t\t\tops->var = info->var;\n\t\t}\n\t}\n\n \tif (!fbcon_is_inactive(vc, info)) {\n\t\tif (ops->blank_state != blank) {\n\t\t\tops->blank_state = blank;\n\t\t\tfbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);\n\t\t\tops->cursor_flash = (!blank);\n\n\t\t\tif (fb_blank(info, blank))\n\t\t\t\tfbcon_generic_blank(vc, info, blank);\n\t\t}\n\n\t\tif (!blank)\n\t\t\tupdate_screen(vc);\n\t}\n\n\tif (mode_switch || fbcon_is_inactive(vc, info) ||\n\t    ops->blank_state != FB_BLANK_UNBLANK)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\treturn 0;\n}\n\nstatic int fbcon_debug_enter(struct vc_data *vc)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->save_graphics = ops->graphics;\n\tops->graphics = 0;\n\tif (info->fbops->fb_debug_enter)\n\t\tinfo->fbops->fb_debug_enter(info);\n\tfbcon_set_palette(vc, color_table);\n\treturn 0;\n}\n\nstatic int fbcon_debug_leave(struct vc_data *vc)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->graphics = ops->save_graphics;\n\tif (info->fbops->fb_debug_leave)\n\t\tinfo->fbops->fb_debug_leave(info);\n\treturn 0;\n}\n\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* set/clear vc_hi_font_mask and update vc attrs accordingly */\nstatic void set_vc_hi_font(struct vc_data *vc, bool set)\n{\n\tif (!set) {\n\t\tvc->vc_hi_font_mask = 0;\n\t\tif (vc->vc_can_do_color) {\n\t\t\tvc->vc_complement_mask >>= 1;\n\t\t\tvc->vc_s_complement_mask >>= 1;\n\t\t}\n\t\t\t\n\t\t/* ++Edmund: reorder the attribute bits */\n\t\tif (vc->vc_can_do_color) {\n\t\t\tunsigned short *cp =\n\t\t\t    (unsigned short *) vc->vc_origin;\n\t\t\tint count = vc->vc_screenbuf_size / 2;\n\t\t\tunsigned short c;\n\t\t\tfor (; count > 0; count--, cp++) {\n\t\t\t\tc = scr_readw(cp);\n\t\t\t\tscr_writew(((c & 0xfe00) >> 1) |\n\t\t\t\t\t   (c & 0xff), cp);\n\t\t\t}\n\t\t\tc = vc->vc_video_erase_char;\n\t\t\tvc->vc_video_erase_char =\n\t\t\t    ((c & 0xfe00) >> 1) | (c & 0xff);\n\t\t\tvc->vc_attr >>= 1;\n\t\t}\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color) {\n\t\t\tvc->vc_complement_mask <<= 1;\n\t\t\tvc->vc_s_complement_mask <<= 1;\n\t\t}\n\t\t\t\n\t\t/* ++Edmund: reorder the attribute bits */\n\t\t{\n\t\t\tunsigned short *cp =\n\t\t\t    (unsigned short *) vc->vc_origin;\n\t\t\tint count = vc->vc_screenbuf_size / 2;\n\t\t\tunsigned short c;\n\t\t\tfor (; count > 0; count--, cp++) {\n\t\t\t\tunsigned short newc;\n\t\t\t\tc = scr_readw(cp);\n\t\t\t\tif (vc->vc_can_do_color)\n\t\t\t\t\tnewc =\n\t\t\t\t\t    ((c & 0xff00) << 1) | (c &\n\t\t\t\t\t\t\t\t   0xff);\n\t\t\t\telse\n\t\t\t\t\tnewc = c & ~0x100;\n\t\t\t\tscr_writew(newc, cp);\n\t\t\t}\n\t\t\tc = vc->vc_video_erase_char;\n\t\t\tif (vc->vc_can_do_color) {\n\t\t\t\tvc->vc_video_erase_char =\n\t\t\t\t    ((c & 0xff00) << 1) | (c & 0xff);\n\t\t\t\tvc->vc_attr <<= 1;\n\t\t\t} else\n\t\t\t\tvc->vc_video_erase_char = c & ~0x100;\n\t\t}\n\t}\n}\n\nstatic int fbcon_do_set_font(struct vc_data *vc, int w, int h, int charcount,\n\t\t\t     const u8 * data, int userfont)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint resize, ret, old_userfont, old_width, old_height, old_charcount;\n\tchar *old_data = NULL;\n\n\tresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\n\tif (p->userfont)\n\t\told_data = vc->vc_font.data;\n\tvc->vc_font.data = (void *)(p->fontdata = data);\n\told_userfont = p->userfont;\n\tif ((p->userfont = userfont))\n\t\tREFCOUNT(data)++;\n\n\told_width = vc->vc_font.width;\n\told_height = vc->vc_font.height;\n\told_charcount = vc->vc_font.charcount;\n\n\tvc->vc_font.width = w;\n\tvc->vc_font.height = h;\n\tvc->vc_font.charcount = charcount;\n\tif (vc->vc_hi_font_mask && charcount == 256)\n\t\tset_vc_hi_font(vc, false);\n\telse if (!vc->vc_hi_font_mask && charcount == 512)\n\t\tset_vc_hi_font(vc, true);\n\n\tif (resize) {\n\t\tint cols, rows;\n\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= w;\n\t\trows /= h;\n\t\tret = vc_resize(vc, cols, rows);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t} else if (con_is_visible(vc)\n\t\t   && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (old_data && (--REFCOUNT(old_data) == 0))\n\t\tkfree(old_data - FONT_EXTRA_WORDS * sizeof(int));\n\treturn 0;\n\nerr_out:\n\tp->fontdata = old_data;\n\tvc->vc_font.data = (void *)old_data;\n\n\tif (userfont) {\n\t\tp->userfont = old_userfont;\n\t\tif (--REFCOUNT(data) == 0)\n\t\t\tkfree(data - FONT_EXTRA_WORDS * sizeof(int));\n\t}\n\n\tvc->vc_font.width = old_width;\n\tvc->vc_font.height = old_height;\n\tvc->vc_font.charcount = old_charcount;\n\n\treturn ret;\n}\n\n/*\n *  User asked to set font; we are guaranteed that\n *\ta) width and height are in range 1..32\n *\tb) charcount does not exceed 512\n *  but lets not assume that, since someone might someday want to use larger\n *  fonts. And charcount of 512 is small for unicode support.\n *\n *  However, user space gives the font in 32 rows , regardless of\n *  actual font height. So a new API is needed if support for larger fonts\n *  is ever implemented.\n */\n\nstatic int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}\n\nstatic int fbcon_set_def_font(struct vc_data *vc, struct console_font *font, char *name)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tconst struct font_desc *f;\n\n\tif (!name)\n\t\tf = get_default_font(info->var.xres, info->var.yres,\n\t\t\t\t     info->pixmap.blit_x, info->pixmap.blit_y);\n\telse if (!(f = find_font(name)))\n\t\treturn -ENOENT;\n\n\tfont->width = f->width;\n\tfont->height = f->height;\n\treturn fbcon_do_set_font(vc, f->width, f->height, f->charcount, f->data, 0);\n}\n\nstatic u16 palette_red[16];\nstatic u16 palette_green[16];\nstatic u16 palette_blue[16];\n\nstatic struct fb_cmap palette_cmap = {\n\t0, 16, palette_red, palette_green, palette_blue, NULL\n};\n\nstatic void fbcon_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tint i, j, k, depth;\n\tu8 val;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!con_is_visible(vc))\n\t\treturn;\n\n\tdepth = fb_get_color_depth(&info->var, &info->fix);\n\tif (depth > 3) {\n\t\tfor (i = j = 0; i < 16; i++) {\n\t\t\tk = table[i];\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_red[k] = (val << 8) | val;\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_green[k] = (val << 8) | val;\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_blue[k] = (val << 8) | val;\n\t\t}\n\t\tpalette_cmap.len = 16;\n\t\tpalette_cmap.start = 0;\n\t/*\n\t * If framebuffer is capable of less than 16 colors,\n\t * use default palette of fbcon.\n\t */\n\t} else\n\t\tfb_copy_cmap(fb_default_cmap(1 << depth), &palette_cmap);\n\n\tfb_set_cmap(&palette_cmap, info);\n}\n\nstatic u16 *fbcon_screen_pos(const struct vc_data *vc, int offset)\n{\n\treturn (u16 *) (vc->vc_origin + offset);\n}\n\nstatic unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,\n\t\t\t\t int *px, int *py)\n{\n\tunsigned long ret;\n\tint x, y;\n\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\tunsigned long offset = (pos - vc->vc_origin) / 2;\n\n\t\tx = offset % vc->vc_cols;\n\t\ty = offset / vc->vc_cols;\n\t\tret = pos + (vc->vc_cols - x) * 2;\n\t} else {\n\t\t/* Should not happen */\n\t\tx = y = 0;\n\t\tret = vc->vc_origin;\n\t}\n\tif (px)\n\t\t*px = x;\n\tif (py)\n\t\t*py = y;\n\treturn ret;\n}\n\n/* As we might be inside of softback, we may work with non-contiguous buffer,\n   that's why we have to use a separate routine. */\nstatic void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)\n{\n\twhile (cnt--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (!vc->vc_can_do_color)\n\t\t\ta ^= 0x0800;\n\t\telse if (vc->vc_hi_font_mask == 0x100)\n\t\t\ta = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |\n\t\t\t    (((a) & 0x0e00) << 4);\n\t\telse\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\tscr_writew(a, p++);\n\t}\n}\n\nvoid fbcon_suspended(struct fb_info *info)\n{\n\tstruct vc_data *vc = NULL;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\n\t/* Clear cursor, restore saved data */\n\tfbcon_cursor(vc, CM_ERASE);\n}\n\nvoid fbcon_resumed(struct fb_info *info)\n{\n\tstruct vc_data *vc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\n\tupdate_screen(vc);\n}\n\nstatic void fbcon_modechanged(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint rows, cols;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\tif (vc->vc_mode != KD_TEXT ||\n\t    fbcon_info_from_console(ops->currcon) != info)\n\t\treturn;\n\n\tp = &fb_display[vc->vc_num];\n\tset_blitting_type(vc, info);\n\n\tif (con_is_visible(vc)) {\n\t\tvar_to_display(p, &info->var, info);\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= vc->vc_font.width;\n\t\trows /= vc->vc_font.height;\n\t\tvc_resize(vc, cols, rows);\n\t\tupdatescrollmode(p, info, vc);\n\t\tscrollback_max = 0;\n\t\tscrollback_current = 0;\n\n\t\tif (!fbcon_is_inactive(vc, info)) {\n\t\t    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\n\t\t    ops->update_start(info);\n\t\t}\n\n\t\tfbcon_set_palette(vc, color_table);\n\t\tupdate_screen(vc);\n\t}\n}\n\nstatic void fbcon_set_all_vcs(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint i, rows, cols, fg = -1;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t    fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tif (con_is_visible(vc)) {\n\t\t\tfg = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = &fb_display[vc->vc_num];\n\t\tset_blitting_type(vc, info);\n\t\tvar_to_display(p, &info->var, info);\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= vc->vc_font.width;\n\t\trows /= vc->vc_font.height;\n\t\tvc_resize(vc, cols, rows);\n\t}\n\n\tif (fg != -1)\n\t\tfbcon_modechanged(info);\n}\n\n\nvoid fbcon_update_vcs(struct fb_info *info, bool all)\n{\n\tif (all)\n\t\tfbcon_set_all_vcs(info);\n\telse\n\t\tfbcon_modechanged(info);\n}\nEXPORT_SYMBOL(fbcon_update_vcs);\n\n/* let fbcon check if it supports a new screen resolution */\nint fbcon_modechange_possible(struct fb_info *info, struct fb_var_screeninfo *var)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tunsigned int i;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!ops)\n\t\treturn 0;\n\n\t/* prevent setting a screen size which is smaller than font size */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t\t   fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tif (vc->vc_font.width  > FBCON_SWAP(var->rotate, var->xres, var->yres) ||\n\t\t    vc->vc_font.height > FBCON_SWAP(var->rotate, var->yres, var->xres))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fbcon_modechange_possible);\n\nint fbcon_mode_deleted(struct fb_info *info,\n\t\t       struct fb_videomode *mode)\n{\n\tstruct fb_info *fb_info;\n\tstruct fbcon_display *p;\n\tint i, j, found = 0;\n\n\t/* before deletion, ensure that mode is not in use */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tj = con2fb_map[i];\n\t\tif (j == -1)\n\t\t\tcontinue;\n\t\tfb_info = fbcon_registered_fb[j];\n\t\tif (fb_info != info)\n\t\t\tcontinue;\n\t\tp = &fb_display[i];\n\t\tif (!p || !p->mode)\n\t\t\tcontinue;\n\t\tif (fb_mode_is_equal(p->mode, mode)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\n#ifdef CONFIG_VT_HW_CONSOLE_BINDING\nstatic void fbcon_unbind(void)\n{\n\tint ret;\n\n\tret = do_unbind_con_driver(&fb_con, first_fb_vc, last_fb_vc,\n\t\t\t\tfbcon_is_default);\n\n\tif (!ret)\n\t\tfbcon_has_console_bind = 0;\n}\n#else\nstatic inline void fbcon_unbind(void) {}\n#endif /* CONFIG_VT_HW_CONSOLE_BINDING */\n\nvoid fbcon_fb_unbind(struct fb_info *info)\n{\n\tint i, new_idx = -1;\n\tint idx = info->node;\n\n\tconsole_lock();\n\n\tif (!fbcon_has_console_bind) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] != idx &&\n\t\t    con2fb_map[i] != -1) {\n\t\t\tnew_idx = con2fb_map[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_idx != -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == idx)\n\t\t\t\tset_con2fb_map(i, new_idx, 0);\n\t\t}\n\t} else {\n\t\tstruct fb_info *info = fbcon_registered_fb[idx];\n\n\t\t/* This is sort of like set_con2fb_map, except it maps\n\t\t * the consoles to no device and then releases the\n\t\t * oldinfo to free memory and cancel the cursor blink\n\t\t * timer. I can imagine this just becoming part of\n\t\t * set_con2fb_map where new_idx is -1\n\t\t */\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == idx) {\n\t\t\t\tcon2fb_map[i] = -1;\n\t\t\t\tif (!search_fb_in_map(idx)) {\n\t\t\t\t\tcon2fb_release_oldinfo(vc_cons[i].d,\n\t\t\t\t\t\t\t       info, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfbcon_unbind();\n\t}\n\n\tconsole_unlock();\n}\n\nvoid fbcon_fb_unregistered(struct fb_info *info)\n{\n\tint i, idx;\n\n\tconsole_lock();\n\n\tfbcon_registered_fb[info->node] = NULL;\n\tfbcon_num_registered_fb--;\n\n\tif (deferred_takeover) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tidx = info->node;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] == idx)\n\t\t\tcon2fb_map[i] = -1;\n\t}\n\n\tif (idx == info_idx) {\n\t\tinfo_idx = -1;\n\n\t\tfbcon_for_each_registered_fb(i) {\n\t\t\tinfo_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info_idx != -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == -1)\n\t\t\t\tcon2fb_map[i] = info_idx;\n\t\t}\n\t}\n\n\tif (primary_device == idx)\n\t\tprimary_device = -1;\n\n\tif (!fbcon_num_registered_fb)\n\t\tdo_unregister_con_driver(&fb_con);\n\tconsole_unlock();\n}\n\nvoid fbcon_remap_all(struct fb_info *info)\n{\n\tint i, idx = info->node;\n\n\tconsole_lock();\n\tif (deferred_takeover) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map_boot[i] = idx;\n\t\tfbcon_map_override();\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\tset_con2fb_map(i, idx, 0);\n\n\tif (con_is_bound(&fb_con)) {\n\t\tprintk(KERN_INFO \"fbcon: Remapping primary device, \"\n\t\t       \"fb%i, to tty %i-%i\\n\", idx,\n\t\t       first_fb_vc + 1, last_fb_vc + 1);\n\t\tinfo_idx = idx;\n\t}\n\tconsole_unlock();\n}\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\nstatic void fbcon_select_primary(struct fb_info *info)\n{\n\tif (!map_override && primary_device == -1 &&\n\t    fb_is_primary_device(info)) {\n\t\tint i;\n\n\t\tprintk(KERN_INFO \"fbcon: %s (fb%i) is primary device\\n\",\n\t\t       info->fix.id, info->node);\n\t\tprimary_device = info->node;\n\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map_boot[i] = primary_device;\n\n\t\tif (con_is_bound(&fb_con)) {\n\t\t\tprintk(KERN_INFO \"fbcon: Remapping primary device, \"\n\t\t\t       \"fb%i, to tty %i-%i\\n\", info->node,\n\t\t\t       first_fb_vc + 1, last_fb_vc + 1);\n\t\t\tinfo_idx = primary_device;\n\t\t}\n\t}\n\n}\n#else\nstatic inline void fbcon_select_primary(struct fb_info *info)\n{\n\treturn;\n}\n#endif /* CONFIG_FRAMEBUFFER_DETECT_PRIMARY */\n\nstatic bool lockless_register_fb;\nmodule_param_named_unsafe(lockless_register_fb, lockless_register_fb, bool, 0400);\nMODULE_PARM_DESC(lockless_register_fb,\n\t\"Lockless framebuffer registration for debugging [default=off]\");\n\n/* called with console_lock held */\nstatic int do_fb_registered(struct fb_info *info)\n{\n\tint ret = 0, i, idx;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tfbcon_registered_fb[info->node] = info;\n\tfbcon_num_registered_fb++;\n\n\tidx = info->node;\n\tfbcon_select_primary(info);\n\n\tif (deferred_takeover) {\n\t\tpr_info(\"fbcon: Deferring console take-over\\n\");\n\t\treturn 0;\n\t}\n\n\tif (info_idx == -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map_boot[i] == idx) {\n\t\t\t\tinfo_idx = idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info_idx != -1)\n\t\t\tret = do_fbcon_takeover(1);\n\t} else {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map_boot[i] == idx)\n\t\t\t\tset_con2fb_map(i, idx, 0);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint fbcon_fb_registered(struct fb_info *info)\n{\n\tint ret;\n\n\tif (!lockless_register_fb)\n\t\tconsole_lock();\n\telse\n\t\tatomic_inc(&ignore_console_lock_warning);\n\n\tret = do_fb_registered(info);\n\n\tif (!lockless_register_fb)\n\t\tconsole_unlock();\n\telse\n\t\tatomic_dec(&ignore_console_lock_warning);\n\n\treturn ret;\n}\n\nvoid fbcon_fb_blanked(struct fb_info *info, int blank)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\n\tvc = vc_cons[ops->currcon].d;\n\tif (vc->vc_mode != KD_TEXT ||\n\t\t\tfbcon_info_from_console(ops->currcon) != info)\n\t\treturn;\n\n\tif (con_is_visible(vc)) {\n\t\tif (blank)\n\t\t\tdo_blank_screen(0);\n\t\telse\n\t\t\tdo_unblank_screen(0);\n\t}\n\tops->blank_state = blank;\n}\n\nvoid fbcon_new_modelist(struct fb_info *info)\n{\n\tint i;\n\tstruct vc_data *vc;\n\tstruct fb_var_screeninfo var;\n\tconst struct fb_videomode *mode;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\t\tif (!fb_display[i].mode)\n\t\t\tcontinue;\n\t\tvc = vc_cons[i].d;\n\t\tdisplay_to_var(&var, &fb_display[i]);\n\t\tmode = fb_find_nearest_mode(fb_display[i].mode,\n\t\t\t\t\t    &info->modelist);\n\t\tfb_videomode_to_var(&var, mode);\n\t\tfbcon_set_disp(info, &var, vc->vc_num);\n\t}\n}\n\nvoid fbcon_get_requirement(struct fb_info *info,\n\t\t\t   struct fb_blit_caps *caps)\n{\n\tstruct vc_data *vc;\n\n\tif (caps->flags) {\n\t\tint i, charcnt;\n\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tvc = vc_cons[i].d;\n\t\t\tif (vc && vc->vc_mode == KD_TEXT &&\n\t\t\t    info->node == con2fb_map[i]) {\n\t\t\t\tcaps->x |= 1 << (vc->vc_font.width - 1);\n\t\t\t\tcaps->y |= 1 << (vc->vc_font.height - 1);\n\t\t\t\tcharcnt = vc->vc_font.charcount;\n\t\t\t\tif (caps->len < charcnt)\n\t\t\t\t\tcaps->len = charcnt;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvc = vc_cons[fg_console].d;\n\n\t\tif (vc && vc->vc_mode == KD_TEXT &&\n\t\t    info->node == con2fb_map[fg_console]) {\n\t\t\tcaps->x = 1 << (vc->vc_font.width - 1);\n\t\t\tcaps->y = 1 << (vc->vc_font.height - 1);\n\t\t\tcaps->len = vc->vc_font.charcount;\n\t\t}\n\t}\n}\n\nint fbcon_set_con2fb_map_ioctl(void __user *argp)\n{\n\tstruct fb_con2fbmap con2fb;\n\tint ret;\n\n\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\n\t\treturn -EFAULT;\n\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\n\t\treturn -EINVAL;\n\tif (con2fb.framebuffer >= FB_MAX)\n\t\treturn -EINVAL;\n\tif (!fbcon_registered_fb[con2fb.framebuffer])\n\t\trequest_module(\"fb%d\", con2fb.framebuffer);\n\tif (!fbcon_registered_fb[con2fb.framebuffer]) {\n\t\treturn -EINVAL;\n\t}\n\n\tconsole_lock();\n\tret = set_con2fb_map(con2fb.console - 1,\n\t\t\t     con2fb.framebuffer, 1);\n\tconsole_unlock();\n\n\treturn ret;\n}\n\nint fbcon_get_con2fb_map_ioctl(void __user *argp)\n{\n\tstruct fb_con2fbmap con2fb;\n\n\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\n\t\treturn -EFAULT;\n\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\n\t\treturn -EINVAL;\n\n\tconsole_lock();\n\tcon2fb.framebuffer = con2fb_map[con2fb.console - 1];\n\tconsole_unlock();\n\n\treturn copy_to_user(argp, &con2fb, sizeof(con2fb)) ? -EFAULT : 0;\n}\n\n/*\n *  The console `switch' structure for the frame buffer based console\n */\n\nstatic const struct consw fb_con = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.con_startup \t\t= fbcon_startup,\n\t.con_init \t\t= fbcon_init,\n\t.con_deinit \t\t= fbcon_deinit,\n\t.con_clear \t\t= fbcon_clear,\n\t.con_putc \t\t= fbcon_putc,\n\t.con_putcs \t\t= fbcon_putcs,\n\t.con_cursor \t\t= fbcon_cursor,\n\t.con_scroll \t\t= fbcon_scroll,\n\t.con_switch \t\t= fbcon_switch,\n\t.con_blank \t\t= fbcon_blank,\n\t.con_font_set \t\t= fbcon_set_font,\n\t.con_font_get \t\t= fbcon_get_font,\n\t.con_font_default\t= fbcon_set_def_font,\n\t.con_set_palette \t= fbcon_set_palette,\n\t.con_invert_region \t= fbcon_invert_region,\n\t.con_screen_pos \t= fbcon_screen_pos,\n\t.con_getxy \t\t= fbcon_getxy,\n\t.con_resize             = fbcon_resize,\n\t.con_debug_enter\t= fbcon_debug_enter,\n\t.con_debug_leave\t= fbcon_debug_leave,\n};\n\nstatic ssize_t store_rotate(struct device *device,\n\t\t\t    struct device_attribute *attr, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct fb_info *info;\n\tint rotate, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = simple_strtoul(buf, last, 0);\n\tfbcon_rotate(info, rotate);\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic ssize_t store_rotate_all(struct device *device,\n\t\t\t\tstruct device_attribute *attr,const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct fb_info *info;\n\tint rotate, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = simple_strtoul(buf, last, 0);\n\tfbcon_rotate_all(info, rotate);\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic ssize_t show_rotate(struct device *device,\n\t\t\t   struct device_attribute *attr,char *buf)\n{\n\tstruct fb_info *info;\n\tint rotate = 0, idx;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = fbcon_get_rotate(info);\nerr:\n\tconsole_unlock();\n\treturn sysfs_emit(buf, \"%d\\n\", rotate);\n}\n\nstatic ssize_t show_cursor_blink(struct device *device,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tint idx, blink = -1;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\tops = info->fbcon_par;\n\n\tif (!ops)\n\t\tgoto err;\n\n\tblink = delayed_work_pending(&ops->cursor_work);\nerr:\n\tconsole_unlock();\n\treturn sysfs_emit(buf, \"%d\\n\", blink);\n}\n\nstatic ssize_t store_cursor_blink(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fb_info *info;\n\tint blink, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\n\tif (!info->fbcon_par)\n\t\tgoto err;\n\n\tblink = simple_strtoul(buf, last, 0);\n\n\tif (blink) {\n\t\tfbcon_cursor_noblink = 0;\n\t\tfbcon_add_cursor_work(info);\n\t} else {\n\t\tfbcon_cursor_noblink = 1;\n\t\tfbcon_del_cursor_work(info);\n\t}\n\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic struct device_attribute device_attrs[] = {\n\t__ATTR(rotate, S_IRUGO|S_IWUSR, show_rotate, store_rotate),\n\t__ATTR(rotate_all, S_IWUSR, NULL, store_rotate_all),\n\t__ATTR(cursor_blink, S_IRUGO|S_IWUSR, show_cursor_blink,\n\t       store_cursor_blink),\n};\n\nstatic int fbcon_init_device(void)\n{\n\tint i, error = 0;\n\n\tfbcon_has_sysfs = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(device_attrs); i++) {\n\t\terror = device_create_file(fbcon_device, &device_attrs[i]);\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tdevice_remove_file(fbcon_device, &device_attrs[i]);\n\n\t\tfbcon_has_sysfs = 0;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\nstatic void fbcon_register_existing_fbs(struct work_struct *work)\n{\n\tint i;\n\n\tconsole_lock();\n\n\tdeferred_takeover = false;\n\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tfbcon_for_each_registered_fb(i)\n\t\tdo_fb_registered(fbcon_registered_fb[i]);\n\n\tconsole_unlock();\n}\n\nstatic struct notifier_block fbcon_output_nb;\nstatic DECLARE_WORK(fbcon_deferred_takeover_work, fbcon_register_existing_fbs);\n\nstatic int fbcon_output_notifier(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tpr_info(\"fbcon: Taking over console\\n\");\n\n\tdummycon_unregister_output_notifier(&fbcon_output_nb);\n\n\t/* We may get called in atomic context */\n\tschedule_work(&fbcon_deferred_takeover_work);\n\n\treturn NOTIFY_OK;\n}\n#endif\n\nstatic void fbcon_start(void)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tif (conswitchp != &dummy_con)\n\t\tdeferred_takeover = false;\n\n\tif (deferred_takeover) {\n\t\tfbcon_output_nb.notifier_call = fbcon_output_notifier;\n\t\tdummycon_register_output_notifier(&fbcon_output_nb);\n\t\treturn;\n\t}\n#endif\n}\n\nvoid __init fb_console_init(void)\n{\n\tint i;\n\n\tconsole_lock();\n\tfbcon_device = device_create(fb_class, NULL, MKDEV(0, 0), NULL,\n\t\t\t\t     \"fbcon\");\n\n\tif (IS_ERR(fbcon_device)) {\n\t\tprintk(KERN_WARNING \"Unable to create device \"\n\t\t       \"for fbcon; errno = %ld\\n\",\n\t\t       PTR_ERR(fbcon_device));\n\t\tfbcon_device = NULL;\n\t} else\n\t\tfbcon_init_device();\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tcon2fb_map[i] = -1;\n\n\tfbcon_start();\n\tconsole_unlock();\n}\n\n#ifdef MODULE\n\nstatic void __exit fbcon_deinit_device(void)\n{\n\tint i;\n\n\tif (fbcon_has_sysfs) {\n\t\tfor (i = 0; i < ARRAY_SIZE(device_attrs); i++)\n\t\t\tdevice_remove_file(fbcon_device, &device_attrs[i]);\n\n\t\tfbcon_has_sysfs = 0;\n\t}\n}\n\nvoid __exit fb_console_exit(void)\n{\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tconsole_lock();\n\tif (deferred_takeover)\n\t\tdummycon_unregister_output_notifier(&fbcon_output_nb);\n\tconsole_unlock();\n\n\tcancel_work_sync(&fbcon_deferred_takeover_work);\n#endif\n\n\tconsole_lock();\n\tfbcon_deinit_device();\n\tdevice_destroy(fb_class, MKDEV(0, 0));\n\n\tdo_unregister_con_driver(&fb_con);\n\tconsole_unlock();\n}\t\n#endif\n"], "fixing_code": ["/*\n *  linux/drivers/video/fbcon.c -- Low level frame buffer based console driver\n *\n *\tCopyright (C) 1995 Geert Uytterhoeven\n *\n *\n *  This file is based on the original Amiga console driver (amicon.c):\n *\n *\tCopyright (C) 1993 Hamish Macdonald\n *\t\t\t   Greg Harp\n *\tCopyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]\n *\n *\t      with work by William Rucklidge (wjr@cs.cornell.edu)\n *\t\t\t   Geert Uytterhoeven\n *\t\t\t   Jes Sorensen (jds@kom.auc.dk)\n *\t\t\t   Martin Apel\n *\n *  and on the original Atari console driver (atacon.c):\n *\n *\tCopyright (C) 1993 Bjoern Brauel\n *\t\t\t   Roman Hodek\n *\n *\t      with work by Guenther Kelleter\n *\t\t\t   Martin Schaller\n *\t\t\t   Andreas Schwab\n *\n *  Hardware cursor support added by Emmanuel Marty (core@ggi-project.org)\n *  Smart redraw scrolling, arbitrary font width support, 512char font support\n *  and software scrollback added by \n *                         Jakub Jelinek (jj@ultra.linux.cz)\n *\n *  Random hacking by Martin Mares <mj@ucw.cz>\n *\n *\t2001 - Documented with DocBook\n *\t- Brad Douglas <brad@neruo.com>\n *\n *  The low level operations for the various display memory organizations are\n *  now in separate source files.\n *\n *  Currently the following organizations are supported:\n *\n *    o afb\t\t\tAmiga bitplanes\n *    o cfb{2,4,8,16,24,32}\tPacked pixels\n *    o ilbm\t\t\tAmiga interleaved bitplanes\n *    o iplan2p[248]\t\tAtari interleaved bitplanes\n *    o mfb\t\t\tMonochrome\n *    o vga\t\t\tVGA characters/attributes\n *\n *  To do:\n *\n *    - Implement 16 plane mode (iplan2p16)\n *\n *\n *  This file is subject to the terms and conditions of the GNU General Public\n *  License.  See the file COPYING in the main directory of this archive for\n *  more details.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\t/* MSch: for IRQ probe */\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/fb.h>\n#include <linux/fbcon.h>\n#include <linux/vt_kern.h>\n#include <linux/selection.h>\n#include <linux/font.h>\n#include <linux/smp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/crc32.h> /* For counting font checksums */\n#include <linux/uaccess.h>\n#include <asm/fb.h>\n#include <asm/irq.h>\n\n#include \"fbcon.h\"\n\n/*\n * FIXME: Locking\n *\n * - fbcon state itself is protected by the console_lock, and the code does a\n *   pretty good job at making sure that lock is held everywhere it's needed.\n *\n * - fbcon doesn't bother with fb_lock/unlock at all. This is buggy, since it\n *   means concurrent access to the same fbdev from both fbcon and userspace\n *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out\n *   of fb_lock/unlock protected sections, since otherwise we'll recurse and\n *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in\n *   fbmem.c cannot use locking asserts, and there's lots of callers which get\n *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.\n */\n\nenum {\n\tFBCON_LOGO_CANSHOW\t= -1,\t/* the logo can be shown */\n\tFBCON_LOGO_DRAW\t\t= -2,\t/* draw the logo to a console */\n\tFBCON_LOGO_DONTSHOW\t= -3\t/* do not show the logo */\n};\n\nstatic struct fbcon_display fb_display[MAX_NR_CONSOLES];\n\nstruct fb_info *fbcon_registered_fb[FB_MAX];\nint fbcon_num_registered_fb;\n\n#define fbcon_for_each_registered_fb(i)\t\t\\\n\tfor (i = 0; WARN_CONSOLE_UNLOCKED(), i < FB_MAX; i++)\t\t\\\n\t\tif (!fbcon_registered_fb[i]) {} else\n\nstatic signed char con2fb_map[MAX_NR_CONSOLES];\nstatic signed char con2fb_map_boot[MAX_NR_CONSOLES];\n\nstatic struct fb_info *fbcon_info_from_console(int console)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn fbcon_registered_fb[con2fb_map[console]];\n}\n\nstatic int logo_lines;\n/* logo_shown is an index to vc_cons when >= 0; otherwise follows FBCON_LOGO\n   enums.  */\nstatic int logo_shown = FBCON_LOGO_CANSHOW;\n/* console mappings */\nstatic unsigned int first_fb_vc;\nstatic unsigned int last_fb_vc = MAX_NR_CONSOLES - 1;\nstatic int fbcon_is_default = 1; \nstatic int primary_device = -1;\nstatic int fbcon_has_console_bind;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\nstatic int map_override;\n\nstatic inline void fbcon_map_override(void)\n{\n\tmap_override = 1;\n}\n#else\nstatic inline void fbcon_map_override(void)\n{\n}\n#endif /* CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY */\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\nstatic bool deferred_takeover = true;\n#else\n#define deferred_takeover false\n#endif\n\n/* font data */\nstatic char fontname[40];\n\n/* current fb_info */\nstatic int info_idx = -1;\n\n/* console rotation */\nstatic int initial_rotation = -1;\nstatic int fbcon_has_sysfs;\nstatic int margin_color;\n\nstatic const struct consw fb_con;\n\n#define advance_row(p, delta) (unsigned short *)((unsigned long)(p) + (delta) * vc->vc_size_row)\n\nstatic int fbcon_cursor_noblink;\n\n#define divides(a, b)\t((!(a) || (b)%(a)) ? 0 : 1)\n\n/*\n *  Interface used by the world\n */\n\nstatic void fbcon_clear_margins(struct vc_data *vc, int bottom_only);\nstatic void fbcon_set_palette(struct vc_data *vc, const unsigned char *table);\n\n/*\n *  Internal routines\n */\nstatic void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit);\nstatic void fbcon_redraw_move(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t      int line, int count, int dy);\nstatic void fbcon_modechanged(struct fb_info *info);\nstatic void fbcon_set_all_vcs(struct fb_info *info);\n\nstatic struct device *fbcon_device;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_ROTATION\nstatic inline void fbcon_set_rotation(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!(info->flags & FBINFO_MISC_TILEBLITTING) &&\n\t    ops->p->con_rotate < 4)\n\t\tops->rotate = ops->p->con_rotate;\n\telse\n\t\tops->rotate = 0;\n}\n\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\n{\n\tstruct fbcon_ops *ops= info->fbcon_par;\n\tstruct fb_info *fb_info;\n\n\tif (!ops || ops->currcon == -1)\n\t\treturn;\n\n\tfb_info = fbcon_info_from_console(ops->currcon);\n\n\tif (info == fb_info) {\n\t\tstruct fbcon_display *p = &fb_display[ops->currcon];\n\n\t\tif (rotate < 4)\n\t\t\tp->con_rotate = rotate;\n\t\telse\n\t\t\tp->con_rotate = 0;\n\n\t\tfbcon_modechanged(info);\n\t}\n}\n\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint i;\n\n\tif (!ops || ops->currcon < 0 || rotate > 3)\n\t\treturn;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t    fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tp = &fb_display[vc->vc_num];\n\t\tp->con_rotate = rotate;\n\t}\n\n\tfbcon_set_all_vcs(info);\n}\n#else\nstatic inline void fbcon_set_rotation(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->rotate = FB_ROTATE_UR;\n}\n\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\n{\n\treturn;\n}\n\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\n{\n\treturn;\n}\n#endif /* CONFIG_FRAMEBUFFER_CONSOLE_ROTATION */\n\nstatic int fbcon_get_rotate(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\treturn (ops) ? ops->rotate : 0;\n}\n\nstatic inline int fbcon_is_inactive(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\treturn (info->state != FBINFO_STATE_RUNNING ||\n\t\tvc->vc_mode != KD_TEXT || ops->graphics);\n}\n\nstatic int get_color(struct vc_data *vc, struct fb_info *info,\n\t      u16 c, int is_fg)\n{\n\tint depth = fb_get_color_depth(&info->var, &info->fix);\n\tint color = 0;\n\n\tif (console_blanked) {\n\t\tunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\n\n\t\tc = vc->vc_video_erase_char & charmask;\n\t}\n\n\tif (depth != 1)\n\t\tcolor = (is_fg) ? attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8, c)\n\t\t\t: attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12, c);\n\n\tswitch (depth) {\n\tcase 1:\n\t{\n\t\tint col = mono_col(info);\n\t\t/* 0 or 1 */\n\t\tint fg = (info->fix.visual != FB_VISUAL_MONO01) ? col : 0;\n\t\tint bg = (info->fix.visual != FB_VISUAL_MONO01) ? 0 : col;\n\n\t\tif (console_blanked)\n\t\t\tfg = bg;\n\n\t\tcolor = (is_fg) ? fg : bg;\n\t\tbreak;\n\t}\n\tcase 2:\n\t\t/*\n\t\t * Scale down 16-colors to 4 colors. Default 4-color palette\n\t\t * is grayscale. However, simply dividing the values by 4\n\t\t * will not work, as colors 1, 2 and 3 will be scaled-down\n\t\t * to zero rendering them invisible.  So empirically convert\n\t\t * colors to a sane 4-level grayscale.\n\t\t */\n\t\tswitch (color) {\n\t\tcase 0:\n\t\t\tcolor = 0; /* black */\n\t\t\tbreak;\n\t\tcase 1 ... 6:\n\t\t\tcolor = 2; /* white */\n\t\t\tbreak;\n\t\tcase 7 ... 8:\n\t\t\tcolor = 1; /* gray */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor = 3; /* intense white */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\t/*\n\t\t * Last 8 entries of default 16-color palette is a more intense\n\t\t * version of the first 8 (i.e., same chrominance, different\n\t\t * luminance).\n\t\t */\n\t\tcolor &= 7;\n\t\tbreak;\n\t}\n\n\n\treturn color;\n}\n\nstatic void fb_flashcursor(struct work_struct *work)\n{\n\tstruct fbcon_ops *ops = container_of(work, struct fbcon_ops, cursor_work.work);\n\tstruct fb_info *info;\n\tstruct vc_data *vc = NULL;\n\tint c;\n\tint mode;\n\tint ret;\n\n\t/* FIXME: we should sort out the unbind locking instead */\n\t/* instead we just fail to flash the cursor if we can't get\n\t * the lock instead of blocking fbcon deinit */\n\tret = console_trylock();\n\tif (ret == 0)\n\t\treturn;\n\n\t/* protected by console_lock */\n\tinfo = ops->info;\n\n\tif (ops->currcon != -1)\n\t\tvc = vc_cons[ops->currcon].d;\n\n\tif (!vc || !con_is_visible(vc) ||\n\t    fbcon_info_from_console(vc->vc_num) != info ||\n\t    vc->vc_deccm != 1) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tc = scr_readw((u16 *) vc->vc_pos);\n\tmode = (!ops->cursor_flash || ops->cursor_state.enable) ?\n\t\tCM_ERASE : CM_DRAW;\n\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),\n\t\t    get_color(vc, info, c, 0));\n\tconsole_unlock();\n\n\tqueue_delayed_work(system_power_efficient_wq, &ops->cursor_work,\n\t\t\t   ops->cur_blink_jiffies);\n}\n\nstatic void fbcon_add_cursor_work(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_cursor_noblink)\n\t\tqueue_delayed_work(system_power_efficient_wq, &ops->cursor_work,\n\t\t\t\t   ops->cur_blink_jiffies);\n}\n\nstatic void fbcon_del_cursor_work(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tcancel_delayed_work_sync(&ops->cursor_work);\n}\n\n#ifndef MODULE\nstatic int __init fb_console_setup(char *this_opt)\n{\n\tchar *options;\n\tint i, j;\n\n\tif (!this_opt || !*this_opt)\n\t\treturn 1;\n\n\twhile ((options = strsep(&this_opt, \",\")) != NULL) {\n\t\tif (!strncmp(options, \"font:\", 5)) {\n\t\t\tstrscpy(fontname, options + 5, sizeof(fontname));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!strncmp(options, \"scrollback:\", 11)) {\n\t\t\tpr_warn(\"Ignoring scrollback size option\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!strncmp(options, \"map:\", 4)) {\n\t\t\toptions += 4;\n\t\t\tif (*options) {\n\t\t\t\tfor (i = 0, j = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\t\t\tif (!options[j])\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tcon2fb_map_boot[i] =\n\t\t\t\t\t\t(options[j++]-'0') % FB_MAX;\n\t\t\t\t}\n\n\t\t\t\tfbcon_map_override();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"vc:\", 3)) {\n\t\t\toptions += 3;\n\t\t\tif (*options)\n\t\t\t\tfirst_fb_vc = simple_strtoul(options, &options, 10) - 1;\n\t\t\tif (first_fb_vc >= MAX_NR_CONSOLES)\n\t\t\t\tfirst_fb_vc = 0;\n\t\t\tif (*options++ == '-')\n\t\t\t\tlast_fb_vc = simple_strtoul(options, &options, 10) - 1;\n\t\t\tif (last_fb_vc < first_fb_vc || last_fb_vc >= MAX_NR_CONSOLES)\n\t\t\t\tlast_fb_vc = MAX_NR_CONSOLES - 1;\n\t\t\tfbcon_is_default = 0; \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"rotate:\", 7)) {\n\t\t\toptions += 7;\n\t\t\tif (*options)\n\t\t\t\tinitial_rotation = simple_strtoul(options, &options, 0);\n\t\t\tif (initial_rotation > 3)\n\t\t\t\tinitial_rotation = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"margin:\", 7)) {\n\t\t\toptions += 7;\n\t\t\tif (*options)\n\t\t\t\tmargin_color = simple_strtoul(options, &options, 0);\n\t\t\tcontinue;\n\t\t}\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\t\tif (!strcmp(options, \"nodefer\")) {\n\t\t\tdeferred_takeover = false;\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif (!strncmp(options, \"logo-pos:\", 9)) {\n\t\t\toptions += 9;\n\t\t\tif (!strcmp(options, \"center\"))\n\t\t\t\tfb_center_logo = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(options, \"logo-count:\", 11)) {\n\t\t\toptions += 11;\n\t\t\tif (*options)\n\t\t\t\tfb_logo_count = simple_strtol(options, &options, 0);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"fbcon=\", fb_console_setup);\n#endif\n\nstatic int search_fb_in_map(int idx)\n{\n\tint i, retval = 0;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] == idx)\n\t\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int search_for_mapped_con(void)\n{\n\tint i, retval = 0;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] != -1)\n\t\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int do_fbcon_takeover(int show_logo)\n{\n\tint err, i;\n\n\tif (!fbcon_num_registered_fb)\n\t\treturn -ENODEV;\n\n\tif (!show_logo)\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\tcon2fb_map[i] = info_idx;\n\n\terr = do_take_over_console(&fb_con, first_fb_vc, last_fb_vc,\n\t\t\t\tfbcon_is_default);\n\n\tif (err) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map[i] = -1;\n\t\tinfo_idx = -1;\n\t} else {\n\t\tfbcon_has_console_bind = 1;\n\t}\n\n\treturn err;\n}\n\n#ifdef MODULE\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\n\t\t\t       int cols, int rows, int new_cols, int new_rows)\n{\n\tlogo_shown = FBCON_LOGO_DONTSHOW;\n}\n#else\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\n\t\t\t       int cols, int rows, int new_cols, int new_rows)\n{\n\t/* Need to make room for the logo */\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint cnt, erase = vc->vc_video_erase_char, step;\n\tunsigned short *save = NULL, *r, *q;\n\tint logo_height;\n\n\tif (info->fbops->owner) {\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\t\treturn;\n\t}\n\n\t/*\n\t * remove underline attribute from erase character\n\t * if black and white framebuffer.\n\t */\n\tif (fb_get_color_depth(&info->var, &info->fix) == 1)\n\t\terase &= ~0x400;\n\tlogo_height = fb_prepare_logo(info, ops->rotate);\n\tlogo_lines = DIV_ROUND_UP(logo_height, vc->vc_font.height);\n\tq = (unsigned short *) (vc->vc_origin +\n\t\t\t\tvc->vc_size_row * rows);\n\tstep = logo_lines * cols;\n\tfor (r = q - logo_lines * cols; r < q; r++)\n\t\tif (scr_readw(r) != vc->vc_video_erase_char)\n\t\t\tbreak;\n\tif (r != q && new_rows >= rows + logo_lines) {\n\t\tsave = kzalloc(array3_size(logo_lines, new_cols, 2),\n\t\t\t       GFP_KERNEL);\n\t\tif (save) {\n\t\t\tint i = min(cols, new_cols);\n\t\t\tscr_memsetw(save, erase, array3_size(logo_lines, new_cols, 2));\n\t\t\tr = q - step;\n\t\t\tfor (cnt = 0; cnt < logo_lines; cnt++, r += i)\n\t\t\t\tscr_memcpyw(save + cnt * new_cols, r, 2 * i);\n\t\t\tr = q;\n\t\t}\n\t}\n\tif (r == q) {\n\t\t/* We can scroll screen down */\n\t\tr = q - step - cols;\n\t\tfor (cnt = rows - logo_lines; cnt > 0; cnt--) {\n\t\t\tscr_memcpyw(r + step, r, vc->vc_size_row);\n\t\t\tr -= cols;\n\t\t}\n\t\tif (!save) {\n\t\t\tint lines;\n\t\t\tif (vc->state.y + logo_lines >= rows)\n\t\t\t\tlines = rows - vc->state.y - 1;\n\t\t\telse\n\t\t\t\tlines = logo_lines;\n\t\t\tvc->state.y += lines;\n\t\t\tvc->vc_pos += lines * vc->vc_size_row;\n\t\t}\n\t}\n\tscr_memsetw((unsigned short *) vc->vc_origin,\n\t\t    erase,\n\t\t    vc->vc_size_row * logo_lines);\n\n\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (save) {\n\t\tq = (unsigned short *) (vc->vc_origin +\n\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\trows);\n\t\tscr_memcpyw(q, save, array3_size(logo_lines, new_cols, 2));\n\t\tvc->state.y += logo_lines;\n\t\tvc->vc_pos += logo_lines * vc->vc_size_row;\n\t\tkfree(save);\n\t}\n\n\tif (logo_shown == FBCON_LOGO_DONTSHOW)\n\t\treturn;\n\n\tif (logo_lines > vc->vc_bottom) {\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\t\tprintk(KERN_INFO\n\t\t       \"fbcon_init: disable boot-logo (boot-logo bigger than screen).\\n\");\n\t} else {\n\t\tlogo_shown = FBCON_LOGO_DRAW;\n\t\tvc->vc_top = logo_lines;\n\t}\n}\n#endif /* MODULE */\n\n#ifdef CONFIG_FB_TILEBLITTING\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->p = &fb_display[vc->vc_num];\n\n\tif ((info->flags & FBINFO_MISC_TILEBLITTING))\n\t\tfbcon_set_tileops(vc, info);\n\telse {\n\t\tfbcon_set_rotation(info);\n\t\tfbcon_set_bitops(ops);\n\t}\n}\n\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\n{\n\tint err = 0;\n\n\tif (info->flags & FBINFO_MISC_TILEBLITTING &&\n\t    info->tileops->fb_get_tilemax(info) < charcount)\n\t\terr = 1;\n\n\treturn err;\n}\n#else\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tinfo->flags &= ~FBINFO_MISC_TILEBLITTING;\n\tops->p = &fb_display[vc->vc_num];\n\tfbcon_set_rotation(info);\n\tfbcon_set_bitops(ops);\n}\n\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MISC_TILEBLITTING */\n\nstatic void fbcon_release(struct fb_info *info)\n{\n\tlock_fb_info(info);\n\tif (info->fbops->fb_release)\n\t\tinfo->fbops->fb_release(info, 0);\n\tunlock_fb_info(info);\n\n\tmodule_put(info->fbops->owner);\n\n\tif (info->fbcon_par) {\n\t\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\t\tfbcon_del_cursor_work(info);\n\t\tkfree(ops->cursor_state.mask);\n\t\tkfree(ops->cursor_data);\n\t\tkfree(ops->cursor_src);\n\t\tkfree(ops->fontbuffer);\n\t\tkfree(info->fbcon_par);\n\t\tinfo->fbcon_par = NULL;\n\t}\n}\n\nstatic int fbcon_open(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops;\n\n\tif (!try_module_get(info->fbops->owner))\n\t\treturn -ENODEV;\n\n\tlock_fb_info(info);\n\tif (info->fbops->fb_open &&\n\t    info->fbops->fb_open(info, 0)) {\n\t\tunlock_fb_info(info);\n\t\tmodule_put(info->fbops->owner);\n\t\treturn -ENODEV;\n\t}\n\tunlock_fb_info(info);\n\n\tops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);\n\tif (!ops) {\n\t\tfbcon_release(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&ops->cursor_work, fb_flashcursor);\n\tops->info = info;\n\tinfo->fbcon_par = ops;\n\tops->cur_blink_jiffies = HZ / 5;\n\n\treturn 0;\n}\n\nstatic int con2fb_acquire_newinfo(struct vc_data *vc, struct fb_info *info,\n\t\t\t\t  int unit)\n{\n\tint err;\n\n\terr = fbcon_open(info);\n\tif (err)\n\t\treturn err;\n\n\tif (vc)\n\t\tset_blitting_type(vc, info);\n\n\treturn err;\n}\n\nstatic void con2fb_release_oldinfo(struct vc_data *vc, struct fb_info *oldinfo,\n\t\t\t\t   struct fb_info *newinfo)\n{\n\tint ret;\n\n\tfbcon_release(oldinfo);\n\n\t/*\n\t  If oldinfo and newinfo are driving the same hardware,\n\t  the fb_release() method of oldinfo may attempt to\n\t  restore the hardware state.  This will leave the\n\t  newinfo in an undefined state. Thus, a call to\n\t  fb_set_par() may be needed for the newinfo.\n\t*/\n\tif (newinfo && newinfo->fbops->fb_set_par) {\n\t\tret = newinfo->fbops->fb_set_par(newinfo);\n\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"con2fb_release_oldinfo: \"\n\t\t\t\t\"detected unhandled fb_set_par error, \"\n\t\t\t\t\"error code %d\\n\", ret);\n\t}\n}\n\nstatic void con2fb_init_display(struct vc_data *vc, struct fb_info *info,\n\t\t\t\tint unit, int show_logo)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint ret;\n\n\tops->currcon = fg_console;\n\n\tif (info->fbops->fb_set_par && !ops->initialized) {\n\t\tret = info->fbops->fb_set_par(info);\n\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"con2fb_init_display: detected \"\n\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\"error code %d\\n\", ret);\n\t}\n\n\tops->initialized = true;\n\tops->graphics = 0;\n\tfbcon_set_disp(info, &info->var, unit);\n\n\tif (show_logo) {\n\t\tstruct vc_data *fg_vc = vc_cons[fg_console].d;\n\t\tstruct fb_info *fg_info =\n\t\t\tfbcon_info_from_console(fg_console);\n\n\t\tfbcon_prepare_logo(fg_vc, fg_info, fg_vc->vc_cols,\n\t\t\t\t   fg_vc->vc_rows, fg_vc->vc_cols,\n\t\t\t\t   fg_vc->vc_rows);\n\t}\n\n\tupdate_screen(vc_cons[fg_console].d);\n}\n\n/**\n *\tset_con2fb_map - map console to frame buffer device\n *\t@unit: virtual console number to map\n *\t@newidx: frame buffer index to map virtual console to\n *      @user: user request\n *\n *\tMaps a virtual console @unit to a frame buffer device\n *\t@newidx.\n *\n *\tThis should be called with the console lock held.\n */\nstatic int set_con2fb_map(int unit, int newidx, int user)\n{\n\tstruct vc_data *vc = vc_cons[unit].d;\n\tint oldidx = con2fb_map[unit];\n\tstruct fb_info *info = fbcon_registered_fb[newidx];\n\tstruct fb_info *oldinfo = NULL;\n\tint found, err = 0, show_logo;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (oldidx == newidx)\n\t\treturn 0;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tif (!search_for_mapped_con() || !con_is_bound(&fb_con)) {\n\t\tinfo_idx = newidx;\n\t\treturn do_fbcon_takeover(0);\n\t}\n\n\tif (oldidx != -1)\n\t\toldinfo = fbcon_registered_fb[oldidx];\n\n\tfound = search_fb_in_map(newidx);\n\n\tif (!err && !found) {\n\t\terr = con2fb_acquire_newinfo(vc, info, unit);\n\t\tif (!err)\n\t\t\tcon2fb_map[unit] = newidx;\n\t}\n\n\t/*\n\t * If old fb is not mapped to any of the consoles,\n\t * fbcon should release it.\n\t */\n\tif (!err && oldinfo && !search_fb_in_map(oldidx))\n\t\tcon2fb_release_oldinfo(vc, oldinfo, info);\n\n\tshow_logo = (fg_console == 0 && !user &&\n\t\t\t logo_shown != FBCON_LOGO_DONTSHOW);\n\n\tif (!found)\n\t\tfbcon_add_cursor_work(info);\n\tcon2fb_map_boot[unit] = newidx;\n\tcon2fb_init_display(vc, info, unit, show_logo);\n\n\tif (!search_fb_in_map(info_idx))\n\t\tinfo_idx = newidx;\n\n\treturn err;\n}\n\n/*\n *  Low Level Operations\n */\n/* NOTE: fbcon cannot be __init: it may be called from do_take_over_console later */\nstatic int var_to_display(struct fbcon_display *disp,\n\t\t\t  struct fb_var_screeninfo *var,\n\t\t\t  struct fb_info *info)\n{\n\tdisp->xres_virtual = var->xres_virtual;\n\tdisp->yres_virtual = var->yres_virtual;\n\tdisp->bits_per_pixel = var->bits_per_pixel;\n\tdisp->grayscale = var->grayscale;\n\tdisp->nonstd = var->nonstd;\n\tdisp->accel_flags = var->accel_flags;\n\tdisp->height = var->height;\n\tdisp->width = var->width;\n\tdisp->red = var->red;\n\tdisp->green = var->green;\n\tdisp->blue = var->blue;\n\tdisp->transp = var->transp;\n\tdisp->rotate = var->rotate;\n\tdisp->mode = fb_match_mode(var, &info->modelist);\n\tif (disp->mode == NULL)\n\t\t/* This should not happen */\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void display_to_var(struct fb_var_screeninfo *var,\n\t\t\t   struct fbcon_display *disp)\n{\n\tfb_videomode_to_var(var, disp->mode);\n\tvar->xres_virtual = disp->xres_virtual;\n\tvar->yres_virtual = disp->yres_virtual;\n\tvar->bits_per_pixel = disp->bits_per_pixel;\n\tvar->grayscale = disp->grayscale;\n\tvar->nonstd = disp->nonstd;\n\tvar->accel_flags = disp->accel_flags;\n\tvar->height = disp->height;\n\tvar->width = disp->width;\n\tvar->red = disp->red;\n\tvar->green = disp->green;\n\tvar->blue = disp->blue;\n\tvar->transp = disp->transp;\n\tvar->rotate = disp->rotate;\n}\n\nstatic const char *fbcon_startup(void)\n{\n\tconst char *display_desc = \"frame buffer device\";\n\tstruct fbcon_display *p = &fb_display[fg_console];\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tconst struct font_desc *font = NULL;\n\tstruct fb_info *info = NULL;\n\tstruct fbcon_ops *ops;\n\tint rows, cols;\n\n\t/*\n\t *  If num_registered_fb is zero, this is a call for the dummy part.\n\t *  The frame buffer devices weren't initialized yet.\n\t */\n\tif (!fbcon_num_registered_fb || info_idx == -1)\n\t\treturn display_desc;\n\t/*\n\t * Instead of blindly using registered_fb[0], we use info_idx, set by\n\t * fbcon_fb_registered();\n\t */\n\tinfo = fbcon_registered_fb[info_idx];\n\tif (!info)\n\t\treturn NULL;\n\t\n\tif (fbcon_open(info))\n\t\treturn NULL;\n\n\tops = info->fbcon_par;\n\tops->currcon = -1;\n\tops->graphics = 1;\n\tops->cur_rotate = -1;\n\n\tp->con_rotate = initial_rotation;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = info->fbcon_rotate_hint;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = FB_ROTATE_UR;\n\n\tset_blitting_type(vc, info);\n\n\t/* Setup default font */\n\tif (!p->fontdata && !vc->vc_font.data) {\n\t\tif (!fontname[0] || !(font = find_font(fontname)))\n\t\t\tfont = get_default_font(info->var.xres,\n\t\t\t\t\t\tinfo->var.yres,\n\t\t\t\t\t\tinfo->pixmap.blit_x,\n\t\t\t\t\t\tinfo->pixmap.blit_y);\n\t\tvc->vc_font.width = font->width;\n\t\tvc->vc_font.height = font->height;\n\t\tvc->vc_font.data = (void *)(p->fontdata = font->data);\n\t\tvc->vc_font.charcount = font->charcount;\n\t} else {\n\t\tp->fontdata = vc->vc_font.data;\n\t}\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tpr_debug(\"mode:   %s\\n\", info->fix.id);\n\tpr_debug(\"visual: %d\\n\", info->fix.visual);\n\tpr_debug(\"res:    %dx%d-%d\\n\", info->var.xres,\n\t\t info->var.yres,\n\t\t info->var.bits_per_pixel);\n\n\tfbcon_add_cursor_work(info);\n\treturn display_desc;\n}\n\nstatic void fbcon_init(struct vc_data *vc, int init)\n{\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tstruct vc_data **default_mode = vc->vc_display_fg;\n\tstruct vc_data *svc = *default_mode;\n\tstruct fbcon_display *t, *p = &fb_display[vc->vc_num];\n\tint logo = 1, new_rows, new_cols, rows, cols;\n\tint ret;\n\n\tif (WARN_ON(info_idx == -1))\n\t    return;\n\n\tif (con2fb_map[vc->vc_num] == -1)\n\t\tcon2fb_map[vc->vc_num] = info_idx;\n\n\tinfo = fbcon_info_from_console(vc->vc_num);\n\n\tif (logo_shown < 0 && console_loglevel <= CONSOLE_LOGLEVEL_QUIET)\n\t\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tif (vc != svc || logo_shown == FBCON_LOGO_DONTSHOW ||\n\t    (info->fix.type == FB_TYPE_TEXT))\n\t\tlogo = 0;\n\n\tif (var_to_display(p, &info->var, info))\n\t\treturn;\n\n\tif (!info->fbcon_par)\n\t\tcon2fb_acquire_newinfo(vc, info, vc->vc_num);\n\n\t/* If we are not the first console on this\n\t   fb, copy the font from that console */\n\tt = &fb_display[fg_console];\n\tif (!p->fontdata) {\n\t\tif (t->fontdata) {\n\t\t\tstruct vc_data *fvc = vc_cons[fg_console].d;\n\n\t\t\tvc->vc_font.data = (void *)(p->fontdata =\n\t\t\t\t\t\t    fvc->vc_font.data);\n\t\t\tvc->vc_font.width = fvc->vc_font.width;\n\t\t\tvc->vc_font.height = fvc->vc_font.height;\n\t\t\tvc->vc_font.charcount = fvc->vc_font.charcount;\n\t\t\tp->userfont = t->userfont;\n\n\t\t\tif (p->userfont)\n\t\t\t\tREFCOUNT(p->fontdata)++;\n\t\t} else {\n\t\t\tconst struct font_desc *font = NULL;\n\n\t\t\tif (!fontname[0] || !(font = find_font(fontname)))\n\t\t\t\tfont = get_default_font(info->var.xres,\n\t\t\t\t\t\t\tinfo->var.yres,\n\t\t\t\t\t\t\tinfo->pixmap.blit_x,\n\t\t\t\t\t\t\tinfo->pixmap.blit_y);\n\t\t\tvc->vc_font.width = font->width;\n\t\t\tvc->vc_font.height = font->height;\n\t\t\tvc->vc_font.data = (void *)(p->fontdata = font->data);\n\t\t\tvc->vc_font.charcount = font->charcount;\n\t\t}\n\t}\n\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (vc->vc_font.charcount == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->uni_pagedict_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->uni_pagedict_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tops = info->fbcon_par;\n\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);\n\n\tp->con_rotate = initial_rotation;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = info->fbcon_rotate_hint;\n\tif (p->con_rotate == -1)\n\t\tp->con_rotate = FB_ROTATE_UR;\n\n\tset_blitting_type(vc, info);\n\n\tcols = vc->vc_cols;\n\trows = vc->vc_rows;\n\tnew_cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\tnew_rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tnew_cols /= vc->vc_font.width;\n\tnew_rows /= vc->vc_font.height;\n\n\t/*\n\t * We must always set the mode. The mode of the previous console\n\t * driver could be in the same resolution but we are using different\n\t * hardware so we have to initialize the hardware.\n\t *\n\t * We need to do it in fbcon_init() to prevent screen corruption.\n\t */\n\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\tif (info->fbops->fb_set_par && !ops->initialized) {\n\t\t\tret = info->fbops->fb_set_par(info);\n\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR \"fbcon_init: detected \"\n\t\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\t\"error code %d\\n\", ret);\n\t\t}\n\n\t\tops->initialized = true;\n\t}\n\n\tops->graphics = 0;\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION\n\tif ((info->flags & FBINFO_HWACCEL_COPYAREA) &&\n\t    !(info->flags & FBINFO_HWACCEL_DISABLED))\n\t\tp->scrollmode = SCROLL_MOVE;\n\telse /* default to something safe */\n\t\tp->scrollmode = SCROLL_REDRAW;\n#endif\n\n\t/*\n\t *  ++guenther: console.c:vc_allocate() relies on initializing\n\t *  vc_{cols,rows}, but we must not set those if we are only\n\t *  resizing the console.\n\t */\n\tif (init) {\n\t\tvc->vc_cols = new_cols;\n\t\tvc->vc_rows = new_rows;\n\t} else\n\t\tvc_resize(vc, new_cols, new_rows);\n\n\tif (logo)\n\t\tfbcon_prepare_logo(vc, info, cols, rows, new_cols, new_rows);\n\n\tif (ops->rotate_font && ops->rotate_font(info, vc)) {\n\t\tops->rotate = FB_ROTATE_UR;\n\t\tset_blitting_type(vc, info);\n\t}\n\n\tops->p = &fb_display[fg_console];\n}\n\nstatic void fbcon_free_font(struct fbcon_display *p, bool freefont)\n{\n\tif (freefont && p->userfont && p->fontdata && (--REFCOUNT(p->fontdata) == 0))\n\t\tkfree(p->fontdata - FONT_EXTRA_WORDS * sizeof(int));\n\tp->fontdata = NULL;\n\tp->userfont = 0;\n}\n\nstatic void set_vc_hi_font(struct vc_data *vc, bool set);\n\nstatic void fbcon_release_all(void)\n{\n\tstruct fb_info *info;\n\tint i, j, mapped;\n\n\tfbcon_for_each_registered_fb(i) {\n\t\tmapped = 0;\n\t\tinfo = fbcon_registered_fb[i];\n\n\t\tfor (j = first_fb_vc; j <= last_fb_vc; j++) {\n\t\t\tif (con2fb_map[j] == i) {\n\t\t\t\tmapped = 1;\n\t\t\t\tcon2fb_map[j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (mapped)\n\t\t\tfbcon_release(info);\n\t}\n}\n\nstatic void fbcon_deinit(struct vc_data *vc)\n{\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tint idx;\n\tbool free_font = true;\n\n\tidx = con2fb_map[vc->vc_num];\n\n\tif (idx == -1)\n\t\tgoto finished;\n\n\tinfo = fbcon_registered_fb[idx];\n\n\tif (!info)\n\t\tgoto finished;\n\n\tif (info->flags & FBINFO_MISC_FIRMWARE)\n\t\tfree_font = false;\n\tops = info->fbcon_par;\n\n\tif (!ops)\n\t\tgoto finished;\n\n\tif (con_is_visible(vc))\n\t\tfbcon_del_cursor_work(info);\n\n\tops->initialized = false;\nfinished:\n\n\tfbcon_free_font(p, free_font);\n\tif (free_font)\n\t\tvc->vc_font.data = NULL;\n\n\tif (vc->vc_hi_font_mask && vc->vc_screenbuf)\n\t\tset_vc_hi_font(vc, false);\n\n\tif (!con_is_bound(&fb_con))\n\t\tfbcon_release_all();\n\n\tif (vc->vc_num == logo_shown)\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\n\treturn;\n}\n\n/* ====================================================================== */\n\n/*  fbcon_XXX routines - interface used by the world\n *\n *  This system is now divided into two levels because of complications\n *  caused by hardware scrolling. Top level functions:\n *\n *\tfbcon_bmove(), fbcon_clear(), fbcon_putc(), fbcon_clear_margins()\n *\n *  handles y values in range [0, scr_height-1] that correspond to real\n *  screen positions. y_wrap shift means that first line of bitmap may be\n *  anywhere on this display. These functions convert lineoffsets to\n *  bitmap offsets and deal with the wrap-around case by splitting blits.\n *\n *\tfbcon_bmove_physical_8()    -- These functions fast implementations\n *\tfbcon_clear_physical_8()    -- of original fbcon_XXX fns.\n *\tfbcon_putc_physical_8()\t    -- (font width != 8) may be added later\n *\n *  WARNING:\n *\n *  At the moment fbcon_putc() cannot blit across vertical wrap boundary\n *  Implies should only really hardware scroll in rows. Only reason for\n *  restriction is simplicity & efficiency at the moment.\n */\n\nstatic void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\tint width)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tu_int y_break;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!height || !width)\n\t\treturn;\n\n\tif (sy < vc->vc_top && vc->vc_top == logo_lines) {\n\t\tvc->vc_top = 0;\n\t\t/*\n\t\t * If the font dimensions are not an integral of the display\n\t\t * dimensions then the ops->clear below won't end up clearing\n\t\t * the margins.  Call clear_margins here in case the logo\n\t\t * bitmap stretched into the margin area.\n\t\t */\n\t\tfbcon_clear_margins(vc, 0);\n\t}\n\n\t/* Split blits that cross physical y_wrap boundary */\n\n\ty_break = p->vrows - p->yscroll;\n\tif (sy < y_break && sy + height - 1 >= y_break) {\n\t\tu_int b = y_break - sy;\n\t\tops->clear(vc, info, real_y(p, sy), sx, b, width);\n\t\tops->clear(vc, info, real_y(p, sy + b), sx, height - b,\n\t\t\t\t width);\n\t} else\n\t\tops->clear(vc, info, real_y(p, sy), sx, height, width);\n}\n\nstatic void fbcon_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\tint count, int ypos, int xpos)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_is_inactive(vc, info))\n\t\tops->putcs(vc, info, s, count, real_y(p, ypos), xpos,\n\t\t\t   get_color(vc, info, scr_readw(s), 1),\n\t\t\t   get_color(vc, info, scr_readw(s), 0));\n}\n\nstatic void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)\n{\n\tunsigned short chr;\n\n\tscr_writew(c, &chr);\n\tfbcon_putcs(vc, &chr, 1, ypos, xpos);\n}\n\nstatic void fbcon_clear_margins(struct vc_data *vc, int bottom_only)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!fbcon_is_inactive(vc, info))\n\t\tops->clear_margins(vc, info, margin_color, bottom_only);\n}\n\nstatic void fbcon_cursor(struct vc_data *vc, int mode)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n \tint c = scr_readw((u16 *) vc->vc_pos);\n\n\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);\n\n\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)\n\t\treturn;\n\n\tif (vc->vc_cursor_type & CUR_SW)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;\n\n\tif (!ops->cursor)\n\t\treturn;\n\n\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),\n\t\t    get_color(vc, info, c, 0));\n}\n\nstatic int scrollback_phys_max = 0;\nstatic int scrollback_max = 0;\nstatic int scrollback_current = 0;\n\nstatic void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\n\t\t\t   int unit)\n{\n\tstruct fbcon_display *p, *t;\n\tstruct vc_data **default_mode, *vc;\n\tstruct vc_data *svc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint rows, cols;\n\n\tp = &fb_display[unit];\n\n\tif (var_to_display(p, var, info))\n\t\treturn;\n\n\tvc = vc_cons[unit].d;\n\n\tif (!vc)\n\t\treturn;\n\n\tdefault_mode = vc->vc_display_fg;\n\tsvc = *default_mode;\n\tt = &fb_display[svc->vc_num];\n\n\tif (!vc->vc_font.data) {\n\t\tvc->vc_font.data = (void *)(p->fontdata = t->fontdata);\n\t\tvc->vc_font.width = (*default_mode)->vc_font.width;\n\t\tvc->vc_font.height = (*default_mode)->vc_font.height;\n\t\tvc->vc_font.charcount = (*default_mode)->vc_font.charcount;\n\t\tp->userfont = t->userfont;\n\t\tif (p->userfont)\n\t\t\tREFCOUNT(p->fontdata)++;\n\t}\n\n\tvar->activate = FB_ACTIVATE_NOW;\n\tinfo->var.activate = var->activate;\n\tvar->yoffset = info->var.yoffset;\n\tvar->xoffset = info->var.xoffset;\n\tfb_set_var(info, var);\n\tops->var = info->var;\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\tif (vc->vc_font.charcount == 256) {\n\t\tvc->vc_hi_font_mask = 0;\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color)\n\t\t\tvc->vc_complement_mask <<= 1;\n\t}\n\n\tif (!*svc->uni_pagedict_loc)\n\t\tcon_set_default_unimap(svc);\n\tif (!*vc->uni_pagedict_loc)\n\t\tcon_copy_unimap(vc, svc);\n\n\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tcols /= vc->vc_font.width;\n\trows /= vc->vc_font.height;\n\tvc_resize(vc, cols, rows);\n\n\tif (con_is_visible(vc)) {\n\t\tupdate_screen(vc);\n\t}\n}\n\nstatic __inline__ void ywrap_up(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll += count;\n\tif (p->yscroll >= p->vrows)\t/* Deal with wrap */\n\t\tp->yscroll -= p->vrows;\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode |= FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ywrap_down(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll -= count;\n\tif (p->yscroll < 0)\t/* Deal with wrap */\n\t\tp->yscroll += p->vrows;\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode |= FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_up(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tp->yscroll += count;\n\tif (p->yscroll > p->vrows - vc->vc_rows) {\n\t\tops->bmove(vc, info, p->vrows - vc->vc_rows,\n\t\t\t    0, 0, 0, vc->vc_rows, vc->vc_cols);\n\t\tp->yscroll -= p->vrows - vc->vc_rows;\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_up_redraw(struct vc_data *vc, int t, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll += count;\n\n\tif (p->yscroll > p->vrows - vc->vc_rows) {\n\t\tp->yscroll -= p->vrows - vc->vc_rows;\n\t\tfbcon_redraw_move(vc, p, t + count, vc->vc_rows - count, t);\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max += count;\n\tif (scrollback_max > scrollback_phys_max)\n\t\tscrollback_max = scrollback_phys_max;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_down(struct vc_data *vc, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tp->yscroll -= count;\n\tif (p->yscroll < 0) {\n\t\tops->bmove(vc, info, 0, 0, p->vrows - vc->vc_rows,\n\t\t\t    0, vc->vc_rows, vc->vc_cols);\n\t\tp->yscroll += p->vrows - vc->vc_rows;\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic __inline__ void ypan_down_redraw(struct vc_data *vc, int t, int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tp->yscroll -= count;\n\n\tif (p->yscroll < 0) {\n\t\tp->yscroll += p->vrows - vc->vc_rows;\n\t\tfbcon_redraw_move(vc, p, t, vc->vc_rows - count, t + count);\n\t}\n\n\tops->var.xoffset = 0;\n\tops->var.yoffset = p->yscroll * vc->vc_font.height;\n\tops->var.vmode &= ~FB_VMODE_YWRAP;\n\tops->update_start(info);\n\tfbcon_clear_margins(vc, 1);\n\tscrollback_max -= count;\n\tif (scrollback_max < 0)\n\t\tscrollback_max = 0;\n\tscrollback_current = 0;\n}\n\nstatic void fbcon_redraw_move(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t      int line, int count, int dy)\n{\n\tunsigned short *s = (unsigned short *)\n\t\t(vc->vc_origin + vc->vc_size_row * line);\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\t\tunsigned short attr = 1;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\t\t\tif (attr != (c & 0xff00)) {\n\t\t\t\tattr = c & 0xff00;\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t    dy, x);\n\t\t\t\t\tx += s - start;\n\t\t\t\t\tstart = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tfbcon_putcs(vc, start, s - start, dy, x);\n\t\tconsole_conditional_schedule();\n\t\tdy++;\n\t}\n}\n\nstatic void fbcon_redraw_blit(struct vc_data *vc, struct fb_info *info,\n\t\t\tstruct fbcon_display *p, int line, int count, int ycount)\n{\n\tint offset = ycount * vc->vc_cols;\n\tunsigned short *d = (unsigned short *)\n\t    (vc->vc_origin + vc->vc_size_row * line);\n\tunsigned short *s = d + offset;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\n\t\t\tif (c == scr_readw(d)) {\n\t\t\t\tif (s > start) {\n\t\t\t\t\tops->bmove(vc, info, line + ycount, x,\n\t\t\t\t\t\t   line, x, 1, s-start);\n\t\t\t\t\tx += s - start + 1;\n\t\t\t\t\tstart = s + 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscr_writew(c, d);\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t\td++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tops->bmove(vc, info, line + ycount, x, line, x, 1,\n\t\t\t\t   s-start);\n\t\tconsole_conditional_schedule();\n\t\tif (ycount > 0)\n\t\t\tline++;\n\t\telse {\n\t\t\tline--;\n\t\t\t/* NOTE: We subtract two lines from these pointers */\n\t\t\ts -= vc->vc_size_row;\n\t\t\td -= vc->vc_size_row;\n\t\t}\n\t}\n}\n\nstatic void fbcon_redraw(struct vc_data *vc, struct fbcon_display *p,\n\t\t\t int line, int count, int offset)\n{\n\tunsigned short *d = (unsigned short *)\n\t    (vc->vc_origin + vc->vc_size_row * line);\n\tunsigned short *s = d + offset;\n\n\twhile (count--) {\n\t\tunsigned short *start = s;\n\t\tunsigned short *le = advance_row(s, 1);\n\t\tunsigned short c;\n\t\tint x = 0;\n\t\tunsigned short attr = 1;\n\n\t\tdo {\n\t\t\tc = scr_readw(s);\n\t\t\tif (attr != (c & 0xff00)) {\n\t\t\t\tattr = c & 0xff00;\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t    line, x);\n\t\t\t\t\tx += s - start;\n\t\t\t\t\tstart = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == scr_readw(d)) {\n\t\t\t\tif (s > start) {\n\t\t\t\t\tfbcon_putcs(vc, start, s - start,\n\t\t\t\t\t\t     line, x);\n\t\t\t\t\tx += s - start + 1;\n\t\t\t\t\tstart = s + 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscr_writew(c, d);\n\t\t\tconsole_conditional_schedule();\n\t\t\ts++;\n\t\t\td++;\n\t\t} while (s < le);\n\t\tif (s > start)\n\t\t\tfbcon_putcs(vc, start, s - start, line, x);\n\t\tconsole_conditional_schedule();\n\t\tif (offset > 0)\n\t\t\tline++;\n\t\telse {\n\t\t\tline--;\n\t\t\t/* NOTE: We subtract two lines from these pointers */\n\t\t\ts -= vc->vc_size_row;\n\t\t\td -= vc->vc_size_row;\n\t\t}\n\t}\n}\n\nstatic void fbcon_bmove_rec(struct vc_data *vc, struct fbcon_display *p, int sy, int sx,\n\t\t\t    int dy, int dx, int height, int width, u_int y_break)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tu_int b;\n\n\tif (sy < y_break && sy + height > y_break) {\n\t\tb = y_break - sy;\n\t\tif (dy < sy) {\t/* Avoid trashing self */\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t} else {\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (dy < y_break && dy + height > y_break) {\n\t\tb = y_break - dy;\n\t\tif (dy < sy) {\t/* Avoid trashing self */\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t} else {\n\t\t\tfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\n\t\t\t\t\theight - b, width, y_break);\n\t\t\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\n\t\t\t\t\ty_break);\n\t\t}\n\t\treturn;\n\t}\n\tops->bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,\n\t\t   height, width);\n}\n\nstatic void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,\n\t\t\tint height, int width)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!width || !height)\n\t\treturn;\n\n\t/*  Split blits that cross physical y_wrap case.\n\t *  Pathological case involves 4 blits, better to use recursive\n\t *  code rather than unrolled case\n\t *\n\t *  Recursive invocations don't need to erase the cursor over and\n\t *  over again, so we use fbcon_bmove_rec()\n\t */\n\tfbcon_bmove_rec(vc, p, sy, sx, dy, dx, height, width,\n\t\t\tp->vrows - p->yscroll);\n}\n\nstatic bool fbcon_scroll(struct vc_data *vc, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int count)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint scroll_partial = info->flags & FBINFO_PARTIAL_PAN_OK;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn true;\n\n\tfbcon_cursor(vc, CM_ERASE);\n\n\t/*\n\t * ++Geert: Only use ywrap/ypan if the console is in text mode\n\t * ++Andrew: Only use ypan on hardware text mode when scrolling the\n\t *           whole screen (prevents flicker).\n\t */\n\n\tswitch (dir) {\n\tcase SM_UP:\n\t\tif (count > vc->vc_rows)\t/* Maximum realistic size */\n\t\t\tcount = vc->vc_rows;\n\t\tswitch (fb_scrollmode(p)) {\n\t\tcase SCROLL_MOVE:\n\t\t\tfbcon_redraw_blit(vc, info, p, t, b - t - count,\n\t\t\t\t     count);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\t(b - count)),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\n\t\tcase SCROLL_WRAP_MOVE:\n\t\t\tif (b - t - count > 3 * vc->vc_rows >> 2) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, 0, 0, count, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\tywrap_up(vc, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b - count, 0, b, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t + count, 0, t, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_up;\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_REDRAW:\n\t\t\tif ((p->yscroll + count <=\n\t\t\t     2 * (p->vrows - vc->vc_rows))\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, 0, t, count);\n\t\t\t\typan_up_redraw(vc, t, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, b,\n\t\t\t\t\t\t\t  vc->vc_rows - b, b);\n\t\t\t} else\n\t\t\t\tfbcon_redraw_move(vc, p, t + count, b - t - count, t);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_MOVE:\n\t\t\tif ((p->yscroll + count <=\n\t\t\t     2 * (p->vrows - vc->vc_rows))\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, 0, 0, count, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\typan_up(vc, count);\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b - count, 0, b, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t + count, 0, t, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_up;\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_REDRAW:\n\t\t      redraw_up:\n\t\t\tfbcon_redraw(vc, p, t, b - t - count,\n\t\t\t\t     count * vc->vc_cols);\n\t\t\tfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\t(b - count)),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase SM_DOWN:\n\t\tif (count > vc->vc_rows)\t/* Maximum realistic size */\n\t\t\tcount = vc->vc_rows;\n\t\tswitch (fb_scrollmode(p)) {\n\t\tcase SCROLL_MOVE:\n\t\t\tfbcon_redraw_blit(vc, info, p, b - 1, b - t - count,\n\t\t\t\t     -count);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\tt),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\n\t\tcase SCROLL_WRAP_MOVE:\n\t\t\tif (b - t - count > 3 * vc->vc_rows >> 2) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b, 0, b - count, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\tywrap_down(vc, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, count, 0, 0, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t, 0, t + count, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_down;\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_MOVE:\n\t\t\tif ((count - p->yscroll <= p->vrows - vc->vc_rows)\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_bmove(vc, b, 0, b - count, 0,\n\t\t\t\t\t\t    vc->vc_rows - b,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t\typan_down(vc, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_bmove(vc, count, 0, 0, 0, t,\n\t\t\t\t\t\t    vc->vc_cols);\n\t\t\t} else if (info->flags & FBINFO_READS_FAST)\n\t\t\t\tfbcon_bmove(vc, t, 0, t + count, 0,\n\t\t\t\t\t    b - t - count, vc->vc_cols);\n\t\t\telse\n\t\t\t\tgoto redraw_down;\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_PAN_REDRAW:\n\t\t\tif ((count - p->yscroll <= p->vrows - vc->vc_rows)\n\t\t\t    && ((!scroll_partial && (b - t == vc->vc_rows))\n\t\t\t\t|| (scroll_partial\n\t\t\t\t    && (b - t - count >\n\t\t\t\t\t3 * vc->vc_rows >> 2)))) {\n\t\t\t\tif (vc->vc_rows - b > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, b, vc->vc_rows - b,\n\t\t\t\t\t\t\t  b - count);\n\t\t\t\typan_down_redraw(vc, t, count);\n\t\t\t\tif (t > 0)\n\t\t\t\t\tfbcon_redraw_move(vc, p, count, t, 0);\n\t\t\t} else\n\t\t\t\tfbcon_redraw_move(vc, p, t, b - t - count, t + count);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tbreak;\n\n\t\tcase SCROLL_REDRAW:\n\t\t      redraw_down:\n\t\t\tfbcon_redraw(vc, p, b - 1, b - t - count,\n\t\t\t\t     -count * vc->vc_cols);\n\t\t\tfbcon_clear(vc, t, 0, count, vc->vc_cols);\n\t\t\tscr_memsetw((unsigned short *) (vc->vc_origin +\n\t\t\t\t\t\t\tvc->vc_size_row *\n\t\t\t\t\t\t\tt),\n\t\t\t\t    vc->vc_video_erase_char,\n\t\t\t\t    vc->vc_size_row * count);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nstatic void updatescrollmode_accel(struct fbcon_display *p,\n\t\t\t\t\tstruct fb_info *info,\n\t\t\t\t\tstruct vc_data *vc)\n{\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint cap = info->flags;\n\tu16 t = 0;\n\tint ypan = FBCON_SWAP(ops->rotate, info->fix.ypanstep,\n\t\t\t\t  info->fix.xpanstep);\n\tint ywrap = FBCON_SWAP(ops->rotate, info->fix.ywrapstep, t);\n\tint yres = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tint vyres = FBCON_SWAP(ops->rotate, info->var.yres_virtual,\n\t\t\t\t   info->var.xres_virtual);\n\tint good_pan = (cap & FBINFO_HWACCEL_YPAN) &&\n\t\tdivides(ypan, vc->vc_font.height) && vyres > yres;\n\tint good_wrap = (cap & FBINFO_HWACCEL_YWRAP) &&\n\t\tdivides(ywrap, vc->vc_font.height) &&\n\t\tdivides(vc->vc_font.height, vyres) &&\n\t\tdivides(vc->vc_font.height, yres);\n\tint reading_fast = cap & FBINFO_READS_FAST;\n\tint fast_copyarea = (cap & FBINFO_HWACCEL_COPYAREA) &&\n\t\t!(cap & FBINFO_HWACCEL_DISABLED);\n\tint fast_imageblit = (cap & FBINFO_HWACCEL_IMAGEBLIT) &&\n\t\t!(cap & FBINFO_HWACCEL_DISABLED);\n\n\tif (good_wrap || good_pan) {\n\t\tif (reading_fast || fast_copyarea)\n\t\t\tp->scrollmode = good_wrap ?\n\t\t\t\tSCROLL_WRAP_MOVE : SCROLL_PAN_MOVE;\n\t\telse\n\t\t\tp->scrollmode = good_wrap ? SCROLL_REDRAW :\n\t\t\t\tSCROLL_PAN_REDRAW;\n\t} else {\n\t\tif (reading_fast || (fast_copyarea && !fast_imageblit))\n\t\t\tp->scrollmode = SCROLL_MOVE;\n\t\telse\n\t\t\tp->scrollmode = SCROLL_REDRAW;\n\t}\n#endif\n}\n\nstatic void updatescrollmode(struct fbcon_display *p,\n\t\t\t\t\tstruct fb_info *info,\n\t\t\t\t\tstruct vc_data *vc)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tint fh = vc->vc_font.height;\n\tint yres = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\tint vyres = FBCON_SWAP(ops->rotate, info->var.yres_virtual,\n\t\t\t\t   info->var.xres_virtual);\n\n\tp->vrows = vyres/fh;\n\tif (yres > (fh * (vc->vc_rows + 1)))\n\t\tp->vrows -= (yres - (fh * vc->vc_rows)) / fh;\n\tif ((yres % fh) && (vyres % fh < yres % fh))\n\t\tp->vrows--;\n\n\t/* update scrollmode in case hardware acceleration is used */\n\tupdatescrollmode_accel(p, info, vc);\n}\n\n#define PITCH(w) (((w) + 7) >> 3)\n#define CALC_FONTSZ(h, p, c) ((h) * (p) * (c)) /* size = height * pitch * charcount */\n\nstatic int fbcon_resize(struct vc_data *vc, unsigned int width, \n\t\t\tunsigned int height, unsigned int user)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_var_screeninfo var = info->var;\n\tint x_diff, y_diff, virt_w, virt_h, virt_fw, virt_fh;\n\n\tif (p->userfont && FNTSIZE(vc->vc_font.data)) {\n\t\tint size;\n\t\tint pitch = PITCH(vc->vc_font.width);\n\n\t\t/*\n\t\t * If user font, ensure that a possible change to user font\n\t\t * height or width will not allow a font data out-of-bounds access.\n\t\t * NOTE: must use original charcount in calculation as font\n\t\t * charcount can change and cannot be used to determine the\n\t\t * font data allocated size.\n\t\t */\n\t\tif (pitch <= 0)\n\t\t\treturn -EINVAL;\n\t\tsize = CALC_FONTSZ(vc->vc_font.height, pitch, vc->vc_font.charcount);\n\t\tif (size > FNTSIZE(vc->vc_font.data))\n\t\t\treturn -EINVAL;\n\t}\n\n\tvirt_w = FBCON_SWAP(ops->rotate, width, height);\n\tvirt_h = FBCON_SWAP(ops->rotate, height, width);\n\tvirt_fw = FBCON_SWAP(ops->rotate, vc->vc_font.width,\n\t\t\t\t vc->vc_font.height);\n\tvirt_fh = FBCON_SWAP(ops->rotate, vc->vc_font.height,\n\t\t\t\t vc->vc_font.width);\n\tvar.xres = virt_w * virt_fw;\n\tvar.yres = virt_h * virt_fh;\n\tx_diff = info->var.xres - var.xres;\n\ty_diff = info->var.yres - var.yres;\n\tif (x_diff < 0 || x_diff > virt_fw ||\n\t    y_diff < 0 || y_diff > virt_fh) {\n\t\tconst struct fb_videomode *mode;\n\n\t\tpr_debug(\"attempting resize %ix%i\\n\", var.xres, var.yres);\n\t\tmode = fb_find_best_mode(&var, &info->modelist);\n\t\tif (mode == NULL)\n\t\t\treturn -EINVAL;\n\t\tdisplay_to_var(&var, p);\n\t\tfb_videomode_to_var(&var, mode);\n\n\t\tif (virt_w > var.xres/virt_fw || virt_h > var.yres/virt_fh)\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"resize now %ix%i\\n\", var.xres, var.yres);\n\t\tif (con_is_visible(vc) && vc->vc_mode == KD_TEXT) {\n\t\t\tvar.activate = FB_ACTIVATE_NOW |\n\t\t\t\tFB_ACTIVATE_FORCE;\n\t\t\tfb_set_var(info, &var);\n\t\t}\n\t\tvar_to_display(p, &info->var, info);\n\t\tops->var = info->var;\n\t}\n\tupdatescrollmode(p, info, vc);\n\treturn 0;\n}\n\nstatic int fbcon_switch(struct vc_data *vc)\n{\n\tstruct fb_info *info, *old_info = NULL;\n\tstruct fbcon_ops *ops;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tstruct fb_var_screeninfo var;\n\tint i, ret, prev_console;\n\n\tinfo = fbcon_info_from_console(vc->vc_num);\n\tops = info->fbcon_par;\n\n\tif (logo_shown >= 0) {\n\t\tstruct vc_data *conp2 = vc_cons[logo_shown].d;\n\n\t\tif (conp2->vc_top == logo_lines\n\t\t    && conp2->vc_bottom == conp2->vc_rows)\n\t\t\tconp2->vc_top = 0;\n\t\tlogo_shown = FBCON_LOGO_CANSHOW;\n\t}\n\n\tprev_console = ops->currcon;\n\tif (prev_console != -1)\n\t\told_info = fbcon_info_from_console(prev_console);\n\t/*\n\t * FIXME: If we have multiple fbdev's loaded, we need to\n\t * update all info->currcon.  Perhaps, we can place this\n\t * in a centralized structure, but this might break some\n\t * drivers.\n\t *\n\t * info->currcon = vc->vc_num;\n\t */\n\tfbcon_for_each_registered_fb(i) {\n\t\tif (fbcon_registered_fb[i]->fbcon_par) {\n\t\t\tstruct fbcon_ops *o = fbcon_registered_fb[i]->fbcon_par;\n\n\t\t\to->currcon = vc->vc_num;\n\t\t}\n\t}\n\tmemset(&var, 0, sizeof(struct fb_var_screeninfo));\n\tdisplay_to_var(&var, p);\n\tvar.activate = FB_ACTIVATE_NOW;\n\n\t/*\n\t * make sure we don't unnecessarily trip the memcmp()\n\t * in fb_set_var()\n\t */\n\tinfo->var.activate = var.activate;\n\tvar.vmode |= info->var.vmode & ~FB_VMODE_MASK;\n\tfb_set_var(info, &var);\n\tops->var = info->var;\n\n\tif (old_info != NULL && (old_info != info ||\n\t\t\t\t info->flags & FBINFO_MISC_ALWAYS_SETPAR)) {\n\t\tif (info->fbops->fb_set_par) {\n\t\t\tret = info->fbops->fb_set_par(info);\n\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR \"fbcon_switch: detected \"\n\t\t\t\t\t\"unhandled fb_set_par error, \"\n\t\t\t\t\t\"error code %d\\n\", ret);\n\t\t}\n\n\t\tif (old_info != info)\n\t\t\tfbcon_del_cursor_work(old_info);\n\t}\n\n\tif (fbcon_is_inactive(vc, info) ||\n\t    ops->blank_state != FB_BLANK_UNBLANK)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\tset_blitting_type(vc, info);\n\tops->cursor_reset = 1;\n\n\tif (ops->rotate_font && ops->rotate_font(info, vc)) {\n\t\tops->rotate = FB_ROTATE_UR;\n\t\tset_blitting_type(vc, info);\n\t}\n\n\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\n\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\n\n\tif (vc->vc_font.charcount > 256)\n\t\tvc->vc_complement_mask <<= 1;\n\n\tupdatescrollmode(p, info, vc);\n\n\tswitch (fb_scrollmode(p)) {\n\tcase SCROLL_WRAP_MOVE:\n\t\tscrollback_phys_max = p->vrows - vc->vc_rows;\n\t\tbreak;\n\tcase SCROLL_PAN_MOVE:\n\tcase SCROLL_PAN_REDRAW:\n\t\tscrollback_phys_max = p->vrows - 2 * vc->vc_rows;\n\t\tif (scrollback_phys_max < 0)\n\t\t\tscrollback_phys_max = 0;\n\t\tbreak;\n\tdefault:\n\t\tscrollback_phys_max = 0;\n\t\tbreak;\n\t}\n\n\tscrollback_max = 0;\n\tscrollback_current = 0;\n\n\tif (!fbcon_is_inactive(vc, info)) {\n\t    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\n\t    ops->update_start(info);\n\t}\n\n\tfbcon_set_palette(vc, color_table); \t\n\tfbcon_clear_margins(vc, 0);\n\n\tif (logo_shown == FBCON_LOGO_DRAW) {\n\n\t\tlogo_shown = fg_console;\n\t\tfb_show_logo(info, ops->rotate);\n\t\tupdate_region(vc,\n\t\t\t      vc->vc_origin + vc->vc_size_row * vc->vc_top,\n\t\t\t      vc->vc_size_row * (vc->vc_bottom -\n\t\t\t\t\t\t vc->vc_top) / 2);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void fbcon_generic_blank(struct vc_data *vc, struct fb_info *info,\n\t\t\t\tint blank)\n{\n\tif (blank) {\n\t\tunsigned short charmask = vc->vc_hi_font_mask ?\n\t\t\t0x1ff : 0xff;\n\t\tunsigned short oldc;\n\n\t\toldc = vc->vc_video_erase_char;\n\t\tvc->vc_video_erase_char &= charmask;\n\t\tfbcon_clear(vc, 0, 0, vc->vc_rows, vc->vc_cols);\n\t\tvc->vc_video_erase_char = oldc;\n\t}\n}\n\nstatic int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (mode_switch) {\n\t\tstruct fb_var_screeninfo var = info->var;\n\n\t\tops->graphics = 1;\n\n\t\tif (!blank) {\n\t\t\tvar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE |\n\t\t\t\tFB_ACTIVATE_KD_TEXT;\n\t\t\tfb_set_var(info, &var);\n\t\t\tops->graphics = 0;\n\t\t\tops->var = info->var;\n\t\t}\n\t}\n\n \tif (!fbcon_is_inactive(vc, info)) {\n\t\tif (ops->blank_state != blank) {\n\t\t\tops->blank_state = blank;\n\t\t\tfbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);\n\t\t\tops->cursor_flash = (!blank);\n\n\t\t\tif (fb_blank(info, blank))\n\t\t\t\tfbcon_generic_blank(vc, info, blank);\n\t\t}\n\n\t\tif (!blank)\n\t\t\tupdate_screen(vc);\n\t}\n\n\tif (mode_switch || fbcon_is_inactive(vc, info) ||\n\t    ops->blank_state != FB_BLANK_UNBLANK)\n\t\tfbcon_del_cursor_work(info);\n\telse\n\t\tfbcon_add_cursor_work(info);\n\n\treturn 0;\n}\n\nstatic int fbcon_debug_enter(struct vc_data *vc)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->save_graphics = ops->graphics;\n\tops->graphics = 0;\n\tif (info->fbops->fb_debug_enter)\n\t\tinfo->fbops->fb_debug_enter(info);\n\tfbcon_set_palette(vc, color_table);\n\treturn 0;\n}\n\nstatic int fbcon_debug_leave(struct vc_data *vc)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tops->graphics = ops->save_graphics;\n\tif (info->fbops->fb_debug_leave)\n\t\tinfo->fbops->fb_debug_leave(info);\n\treturn 0;\n}\n\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* set/clear vc_hi_font_mask and update vc attrs accordingly */\nstatic void set_vc_hi_font(struct vc_data *vc, bool set)\n{\n\tif (!set) {\n\t\tvc->vc_hi_font_mask = 0;\n\t\tif (vc->vc_can_do_color) {\n\t\t\tvc->vc_complement_mask >>= 1;\n\t\t\tvc->vc_s_complement_mask >>= 1;\n\t\t}\n\t\t\t\n\t\t/* ++Edmund: reorder the attribute bits */\n\t\tif (vc->vc_can_do_color) {\n\t\t\tunsigned short *cp =\n\t\t\t    (unsigned short *) vc->vc_origin;\n\t\t\tint count = vc->vc_screenbuf_size / 2;\n\t\t\tunsigned short c;\n\t\t\tfor (; count > 0; count--, cp++) {\n\t\t\t\tc = scr_readw(cp);\n\t\t\t\tscr_writew(((c & 0xfe00) >> 1) |\n\t\t\t\t\t   (c & 0xff), cp);\n\t\t\t}\n\t\t\tc = vc->vc_video_erase_char;\n\t\t\tvc->vc_video_erase_char =\n\t\t\t    ((c & 0xfe00) >> 1) | (c & 0xff);\n\t\t\tvc->vc_attr >>= 1;\n\t\t}\n\t} else {\n\t\tvc->vc_hi_font_mask = 0x100;\n\t\tif (vc->vc_can_do_color) {\n\t\t\tvc->vc_complement_mask <<= 1;\n\t\t\tvc->vc_s_complement_mask <<= 1;\n\t\t}\n\t\t\t\n\t\t/* ++Edmund: reorder the attribute bits */\n\t\t{\n\t\t\tunsigned short *cp =\n\t\t\t    (unsigned short *) vc->vc_origin;\n\t\t\tint count = vc->vc_screenbuf_size / 2;\n\t\t\tunsigned short c;\n\t\t\tfor (; count > 0; count--, cp++) {\n\t\t\t\tunsigned short newc;\n\t\t\t\tc = scr_readw(cp);\n\t\t\t\tif (vc->vc_can_do_color)\n\t\t\t\t\tnewc =\n\t\t\t\t\t    ((c & 0xff00) << 1) | (c &\n\t\t\t\t\t\t\t\t   0xff);\n\t\t\t\telse\n\t\t\t\t\tnewc = c & ~0x100;\n\t\t\t\tscr_writew(newc, cp);\n\t\t\t}\n\t\t\tc = vc->vc_video_erase_char;\n\t\t\tif (vc->vc_can_do_color) {\n\t\t\t\tvc->vc_video_erase_char =\n\t\t\t\t    ((c & 0xff00) << 1) | (c & 0xff);\n\t\t\t\tvc->vc_attr <<= 1;\n\t\t\t} else\n\t\t\t\tvc->vc_video_erase_char = c & ~0x100;\n\t\t}\n\t}\n}\n\nstatic int fbcon_do_set_font(struct vc_data *vc, int w, int h, int charcount,\n\t\t\t     const u8 * data, int userfont)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct fbcon_display *p = &fb_display[vc->vc_num];\n\tint resize, ret, old_userfont, old_width, old_height, old_charcount;\n\tchar *old_data = NULL;\n\n\tresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\n\tif (p->userfont)\n\t\told_data = vc->vc_font.data;\n\tvc->vc_font.data = (void *)(p->fontdata = data);\n\told_userfont = p->userfont;\n\tif ((p->userfont = userfont))\n\t\tREFCOUNT(data)++;\n\n\told_width = vc->vc_font.width;\n\told_height = vc->vc_font.height;\n\told_charcount = vc->vc_font.charcount;\n\n\tvc->vc_font.width = w;\n\tvc->vc_font.height = h;\n\tvc->vc_font.charcount = charcount;\n\tif (vc->vc_hi_font_mask && charcount == 256)\n\t\tset_vc_hi_font(vc, false);\n\telse if (!vc->vc_hi_font_mask && charcount == 512)\n\t\tset_vc_hi_font(vc, true);\n\n\tif (resize) {\n\t\tint cols, rows;\n\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= w;\n\t\trows /= h;\n\t\tret = vc_resize(vc, cols, rows);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t} else if (con_is_visible(vc)\n\t\t   && vc->vc_mode == KD_TEXT) {\n\t\tfbcon_clear_margins(vc, 0);\n\t\tupdate_screen(vc);\n\t}\n\n\tif (old_data && (--REFCOUNT(old_data) == 0))\n\t\tkfree(old_data - FONT_EXTRA_WORDS * sizeof(int));\n\treturn 0;\n\nerr_out:\n\tp->fontdata = old_data;\n\tvc->vc_font.data = (void *)old_data;\n\n\tif (userfont) {\n\t\tp->userfont = old_userfont;\n\t\tif (--REFCOUNT(data) == 0)\n\t\t\tkfree(data - FONT_EXTRA_WORDS * sizeof(int));\n\t}\n\n\tvc->vc_font.width = old_width;\n\tvc->vc_font.height = old_height;\n\tvc->vc_font.charcount = old_charcount;\n\n\treturn ret;\n}\n\n/*\n *  User asked to set font; we are guaranteed that\n *\ta) width and height are in range 1..32\n *\tb) charcount does not exceed 512\n *  but lets not assume that, since someone might someday want to use larger\n *  fonts. And charcount of 512 is small for unicode support.\n *\n *  However, user space gives the font in 32 rows , regardless of\n *  actual font height. So a new API is needed if support for larger fonts\n *  is ever implemented.\n */\n\nstatic int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\tif (font->width > 32 || font->height > 32)\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||\n\t    !(info->pixmap.blit_y & BIT(font->height - 1)))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}\n\nstatic int fbcon_set_def_font(struct vc_data *vc, struct console_font *font, char *name)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tconst struct font_desc *f;\n\n\tif (!name)\n\t\tf = get_default_font(info->var.xres, info->var.yres,\n\t\t\t\t     info->pixmap.blit_x, info->pixmap.blit_y);\n\telse if (!(f = find_font(name)))\n\t\treturn -ENOENT;\n\n\tfont->width = f->width;\n\tfont->height = f->height;\n\treturn fbcon_do_set_font(vc, f->width, f->height, f->charcount, f->data, 0);\n}\n\nstatic u16 palette_red[16];\nstatic u16 palette_green[16];\nstatic u16 palette_blue[16];\n\nstatic struct fb_cmap palette_cmap = {\n\t0, 16, palette_red, palette_green, palette_blue, NULL\n};\n\nstatic void fbcon_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tint i, j, k, depth;\n\tu8 val;\n\n\tif (fbcon_is_inactive(vc, info))\n\t\treturn;\n\n\tif (!con_is_visible(vc))\n\t\treturn;\n\n\tdepth = fb_get_color_depth(&info->var, &info->fix);\n\tif (depth > 3) {\n\t\tfor (i = j = 0; i < 16; i++) {\n\t\t\tk = table[i];\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_red[k] = (val << 8) | val;\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_green[k] = (val << 8) | val;\n\t\t\tval = vc->vc_palette[j++];\n\t\t\tpalette_blue[k] = (val << 8) | val;\n\t\t}\n\t\tpalette_cmap.len = 16;\n\t\tpalette_cmap.start = 0;\n\t/*\n\t * If framebuffer is capable of less than 16 colors,\n\t * use default palette of fbcon.\n\t */\n\t} else\n\t\tfb_copy_cmap(fb_default_cmap(1 << depth), &palette_cmap);\n\n\tfb_set_cmap(&palette_cmap, info);\n}\n\nstatic u16 *fbcon_screen_pos(const struct vc_data *vc, int offset)\n{\n\treturn (u16 *) (vc->vc_origin + offset);\n}\n\nstatic unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,\n\t\t\t\t int *px, int *py)\n{\n\tunsigned long ret;\n\tint x, y;\n\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\tunsigned long offset = (pos - vc->vc_origin) / 2;\n\n\t\tx = offset % vc->vc_cols;\n\t\ty = offset / vc->vc_cols;\n\t\tret = pos + (vc->vc_cols - x) * 2;\n\t} else {\n\t\t/* Should not happen */\n\t\tx = y = 0;\n\t\tret = vc->vc_origin;\n\t}\n\tif (px)\n\t\t*px = x;\n\tif (py)\n\t\t*py = y;\n\treturn ret;\n}\n\n/* As we might be inside of softback, we may work with non-contiguous buffer,\n   that's why we have to use a separate routine. */\nstatic void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)\n{\n\twhile (cnt--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (!vc->vc_can_do_color)\n\t\t\ta ^= 0x0800;\n\t\telse if (vc->vc_hi_font_mask == 0x100)\n\t\t\ta = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |\n\t\t\t    (((a) & 0x0e00) << 4);\n\t\telse\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\tscr_writew(a, p++);\n\t}\n}\n\nvoid fbcon_suspended(struct fb_info *info)\n{\n\tstruct vc_data *vc = NULL;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\n\t/* Clear cursor, restore saved data */\n\tfbcon_cursor(vc, CM_ERASE);\n}\n\nvoid fbcon_resumed(struct fb_info *info)\n{\n\tstruct vc_data *vc;\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\n\tupdate_screen(vc);\n}\n\nstatic void fbcon_modechanged(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint rows, cols;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\tvc = vc_cons[ops->currcon].d;\n\tif (vc->vc_mode != KD_TEXT ||\n\t    fbcon_info_from_console(ops->currcon) != info)\n\t\treturn;\n\n\tp = &fb_display[vc->vc_num];\n\tset_blitting_type(vc, info);\n\n\tif (con_is_visible(vc)) {\n\t\tvar_to_display(p, &info->var, info);\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= vc->vc_font.width;\n\t\trows /= vc->vc_font.height;\n\t\tvc_resize(vc, cols, rows);\n\t\tupdatescrollmode(p, info, vc);\n\t\tscrollback_max = 0;\n\t\tscrollback_current = 0;\n\n\t\tif (!fbcon_is_inactive(vc, info)) {\n\t\t    ops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\n\t\t    ops->update_start(info);\n\t\t}\n\n\t\tfbcon_set_palette(vc, color_table);\n\t\tupdate_screen(vc);\n\t}\n}\n\nstatic void fbcon_set_all_vcs(struct fb_info *info)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tstruct fbcon_display *p;\n\tint i, rows, cols, fg = -1;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t    fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tif (con_is_visible(vc)) {\n\t\t\tfg = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = &fb_display[vc->vc_num];\n\t\tset_blitting_type(vc, info);\n\t\tvar_to_display(p, &info->var, info);\n\t\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\n\t\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\n\t\tcols /= vc->vc_font.width;\n\t\trows /= vc->vc_font.height;\n\t\tvc_resize(vc, cols, rows);\n\t}\n\n\tif (fg != -1)\n\t\tfbcon_modechanged(info);\n}\n\n\nvoid fbcon_update_vcs(struct fb_info *info, bool all)\n{\n\tif (all)\n\t\tfbcon_set_all_vcs(info);\n\telse\n\t\tfbcon_modechanged(info);\n}\nEXPORT_SYMBOL(fbcon_update_vcs);\n\n/* let fbcon check if it supports a new screen resolution */\nint fbcon_modechange_possible(struct fb_info *info, struct fb_var_screeninfo *var)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\tunsigned int i;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tif (!ops)\n\t\treturn 0;\n\n\t/* prevent setting a screen size which is smaller than font size */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tvc = vc_cons[i].d;\n\t\tif (!vc || vc->vc_mode != KD_TEXT ||\n\t\t\t   fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\n\t\tif (vc->vc_font.width  > FBCON_SWAP(var->rotate, var->xres, var->yres) ||\n\t\t    vc->vc_font.height > FBCON_SWAP(var->rotate, var->yres, var->xres))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fbcon_modechange_possible);\n\nint fbcon_mode_deleted(struct fb_info *info,\n\t\t       struct fb_videomode *mode)\n{\n\tstruct fb_info *fb_info;\n\tstruct fbcon_display *p;\n\tint i, j, found = 0;\n\n\t/* before deletion, ensure that mode is not in use */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tj = con2fb_map[i];\n\t\tif (j == -1)\n\t\t\tcontinue;\n\t\tfb_info = fbcon_registered_fb[j];\n\t\tif (fb_info != info)\n\t\t\tcontinue;\n\t\tp = &fb_display[i];\n\t\tif (!p || !p->mode)\n\t\t\tcontinue;\n\t\tif (fb_mode_is_equal(p->mode, mode)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\n#ifdef CONFIG_VT_HW_CONSOLE_BINDING\nstatic void fbcon_unbind(void)\n{\n\tint ret;\n\n\tret = do_unbind_con_driver(&fb_con, first_fb_vc, last_fb_vc,\n\t\t\t\tfbcon_is_default);\n\n\tif (!ret)\n\t\tfbcon_has_console_bind = 0;\n}\n#else\nstatic inline void fbcon_unbind(void) {}\n#endif /* CONFIG_VT_HW_CONSOLE_BINDING */\n\nvoid fbcon_fb_unbind(struct fb_info *info)\n{\n\tint i, new_idx = -1;\n\tint idx = info->node;\n\n\tconsole_lock();\n\n\tif (!fbcon_has_console_bind) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] != idx &&\n\t\t    con2fb_map[i] != -1) {\n\t\t\tnew_idx = con2fb_map[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_idx != -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == idx)\n\t\t\t\tset_con2fb_map(i, new_idx, 0);\n\t\t}\n\t} else {\n\t\tstruct fb_info *info = fbcon_registered_fb[idx];\n\n\t\t/* This is sort of like set_con2fb_map, except it maps\n\t\t * the consoles to no device and then releases the\n\t\t * oldinfo to free memory and cancel the cursor blink\n\t\t * timer. I can imagine this just becoming part of\n\t\t * set_con2fb_map where new_idx is -1\n\t\t */\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == idx) {\n\t\t\t\tcon2fb_map[i] = -1;\n\t\t\t\tif (!search_fb_in_map(idx)) {\n\t\t\t\t\tcon2fb_release_oldinfo(vc_cons[i].d,\n\t\t\t\t\t\t\t       info, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfbcon_unbind();\n\t}\n\n\tconsole_unlock();\n}\n\nvoid fbcon_fb_unregistered(struct fb_info *info)\n{\n\tint i, idx;\n\n\tconsole_lock();\n\n\tfbcon_registered_fb[info->node] = NULL;\n\tfbcon_num_registered_fb--;\n\n\tif (deferred_takeover) {\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tidx = info->node;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (con2fb_map[i] == idx)\n\t\t\tcon2fb_map[i] = -1;\n\t}\n\n\tif (idx == info_idx) {\n\t\tinfo_idx = -1;\n\n\t\tfbcon_for_each_registered_fb(i) {\n\t\t\tinfo_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info_idx != -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map[i] == -1)\n\t\t\t\tcon2fb_map[i] = info_idx;\n\t\t}\n\t}\n\n\tif (primary_device == idx)\n\t\tprimary_device = -1;\n\n\tif (!fbcon_num_registered_fb)\n\t\tdo_unregister_con_driver(&fb_con);\n\tconsole_unlock();\n}\n\nvoid fbcon_remap_all(struct fb_info *info)\n{\n\tint i, idx = info->node;\n\n\tconsole_lock();\n\tif (deferred_takeover) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map_boot[i] = idx;\n\t\tfbcon_map_override();\n\t\tconsole_unlock();\n\t\treturn;\n\t}\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\tset_con2fb_map(i, idx, 0);\n\n\tif (con_is_bound(&fb_con)) {\n\t\tprintk(KERN_INFO \"fbcon: Remapping primary device, \"\n\t\t       \"fb%i, to tty %i-%i\\n\", idx,\n\t\t       first_fb_vc + 1, last_fb_vc + 1);\n\t\tinfo_idx = idx;\n\t}\n\tconsole_unlock();\n}\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\nstatic void fbcon_select_primary(struct fb_info *info)\n{\n\tif (!map_override && primary_device == -1 &&\n\t    fb_is_primary_device(info)) {\n\t\tint i;\n\n\t\tprintk(KERN_INFO \"fbcon: %s (fb%i) is primary device\\n\",\n\t\t       info->fix.id, info->node);\n\t\tprimary_device = info->node;\n\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++)\n\t\t\tcon2fb_map_boot[i] = primary_device;\n\n\t\tif (con_is_bound(&fb_con)) {\n\t\t\tprintk(KERN_INFO \"fbcon: Remapping primary device, \"\n\t\t\t       \"fb%i, to tty %i-%i\\n\", info->node,\n\t\t\t       first_fb_vc + 1, last_fb_vc + 1);\n\t\t\tinfo_idx = primary_device;\n\t\t}\n\t}\n\n}\n#else\nstatic inline void fbcon_select_primary(struct fb_info *info)\n{\n\treturn;\n}\n#endif /* CONFIG_FRAMEBUFFER_DETECT_PRIMARY */\n\nstatic bool lockless_register_fb;\nmodule_param_named_unsafe(lockless_register_fb, lockless_register_fb, bool, 0400);\nMODULE_PARM_DESC(lockless_register_fb,\n\t\"Lockless framebuffer registration for debugging [default=off]\");\n\n/* called with console_lock held */\nstatic int do_fb_registered(struct fb_info *info)\n{\n\tint ret = 0, i, idx;\n\n\tWARN_CONSOLE_UNLOCKED();\n\n\tfbcon_registered_fb[info->node] = info;\n\tfbcon_num_registered_fb++;\n\n\tidx = info->node;\n\tfbcon_select_primary(info);\n\n\tif (deferred_takeover) {\n\t\tpr_info(\"fbcon: Deferring console take-over\\n\");\n\t\treturn 0;\n\t}\n\n\tif (info_idx == -1) {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map_boot[i] == idx) {\n\t\t\t\tinfo_idx = idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info_idx != -1)\n\t\t\tret = do_fbcon_takeover(1);\n\t} else {\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tif (con2fb_map_boot[i] == idx)\n\t\t\t\tset_con2fb_map(i, idx, 0);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint fbcon_fb_registered(struct fb_info *info)\n{\n\tint ret;\n\n\tif (!lockless_register_fb)\n\t\tconsole_lock();\n\telse\n\t\tatomic_inc(&ignore_console_lock_warning);\n\n\tret = do_fb_registered(info);\n\n\tif (!lockless_register_fb)\n\t\tconsole_unlock();\n\telse\n\t\tatomic_dec(&ignore_console_lock_warning);\n\n\treturn ret;\n}\n\nvoid fbcon_fb_blanked(struct fb_info *info, int blank)\n{\n\tstruct fbcon_ops *ops = info->fbcon_par;\n\tstruct vc_data *vc;\n\n\tif (!ops || ops->currcon < 0)\n\t\treturn;\n\n\tvc = vc_cons[ops->currcon].d;\n\tif (vc->vc_mode != KD_TEXT ||\n\t\t\tfbcon_info_from_console(ops->currcon) != info)\n\t\treturn;\n\n\tif (con_is_visible(vc)) {\n\t\tif (blank)\n\t\t\tdo_blank_screen(0);\n\t\telse\n\t\t\tdo_unblank_screen(0);\n\t}\n\tops->blank_state = blank;\n}\n\nvoid fbcon_new_modelist(struct fb_info *info)\n{\n\tint i;\n\tstruct vc_data *vc;\n\tstruct fb_var_screeninfo var;\n\tconst struct fb_videomode *mode;\n\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tif (fbcon_info_from_console(i) != info)\n\t\t\tcontinue;\n\t\tif (!fb_display[i].mode)\n\t\t\tcontinue;\n\t\tvc = vc_cons[i].d;\n\t\tdisplay_to_var(&var, &fb_display[i]);\n\t\tmode = fb_find_nearest_mode(fb_display[i].mode,\n\t\t\t\t\t    &info->modelist);\n\t\tfb_videomode_to_var(&var, mode);\n\t\tfbcon_set_disp(info, &var, vc->vc_num);\n\t}\n}\n\nvoid fbcon_get_requirement(struct fb_info *info,\n\t\t\t   struct fb_blit_caps *caps)\n{\n\tstruct vc_data *vc;\n\n\tif (caps->flags) {\n\t\tint i, charcnt;\n\n\t\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\t\tvc = vc_cons[i].d;\n\t\t\tif (vc && vc->vc_mode == KD_TEXT &&\n\t\t\t    info->node == con2fb_map[i]) {\n\t\t\t\tcaps->x |= 1 << (vc->vc_font.width - 1);\n\t\t\t\tcaps->y |= 1 << (vc->vc_font.height - 1);\n\t\t\t\tcharcnt = vc->vc_font.charcount;\n\t\t\t\tif (caps->len < charcnt)\n\t\t\t\t\tcaps->len = charcnt;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvc = vc_cons[fg_console].d;\n\n\t\tif (vc && vc->vc_mode == KD_TEXT &&\n\t\t    info->node == con2fb_map[fg_console]) {\n\t\t\tcaps->x = 1 << (vc->vc_font.width - 1);\n\t\t\tcaps->y = 1 << (vc->vc_font.height - 1);\n\t\t\tcaps->len = vc->vc_font.charcount;\n\t\t}\n\t}\n}\n\nint fbcon_set_con2fb_map_ioctl(void __user *argp)\n{\n\tstruct fb_con2fbmap con2fb;\n\tint ret;\n\n\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\n\t\treturn -EFAULT;\n\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\n\t\treturn -EINVAL;\n\tif (con2fb.framebuffer >= FB_MAX)\n\t\treturn -EINVAL;\n\tif (!fbcon_registered_fb[con2fb.framebuffer])\n\t\trequest_module(\"fb%d\", con2fb.framebuffer);\n\tif (!fbcon_registered_fb[con2fb.framebuffer]) {\n\t\treturn -EINVAL;\n\t}\n\n\tconsole_lock();\n\tret = set_con2fb_map(con2fb.console - 1,\n\t\t\t     con2fb.framebuffer, 1);\n\tconsole_unlock();\n\n\treturn ret;\n}\n\nint fbcon_get_con2fb_map_ioctl(void __user *argp)\n{\n\tstruct fb_con2fbmap con2fb;\n\n\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\n\t\treturn -EFAULT;\n\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\n\t\treturn -EINVAL;\n\n\tconsole_lock();\n\tcon2fb.framebuffer = con2fb_map[con2fb.console - 1];\n\tconsole_unlock();\n\n\treturn copy_to_user(argp, &con2fb, sizeof(con2fb)) ? -EFAULT : 0;\n}\n\n/*\n *  The console `switch' structure for the frame buffer based console\n */\n\nstatic const struct consw fb_con = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.con_startup \t\t= fbcon_startup,\n\t.con_init \t\t= fbcon_init,\n\t.con_deinit \t\t= fbcon_deinit,\n\t.con_clear \t\t= fbcon_clear,\n\t.con_putc \t\t= fbcon_putc,\n\t.con_putcs \t\t= fbcon_putcs,\n\t.con_cursor \t\t= fbcon_cursor,\n\t.con_scroll \t\t= fbcon_scroll,\n\t.con_switch \t\t= fbcon_switch,\n\t.con_blank \t\t= fbcon_blank,\n\t.con_font_set \t\t= fbcon_set_font,\n\t.con_font_get \t\t= fbcon_get_font,\n\t.con_font_default\t= fbcon_set_def_font,\n\t.con_set_palette \t= fbcon_set_palette,\n\t.con_invert_region \t= fbcon_invert_region,\n\t.con_screen_pos \t= fbcon_screen_pos,\n\t.con_getxy \t\t= fbcon_getxy,\n\t.con_resize             = fbcon_resize,\n\t.con_debug_enter\t= fbcon_debug_enter,\n\t.con_debug_leave\t= fbcon_debug_leave,\n};\n\nstatic ssize_t store_rotate(struct device *device,\n\t\t\t    struct device_attribute *attr, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct fb_info *info;\n\tint rotate, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = simple_strtoul(buf, last, 0);\n\tfbcon_rotate(info, rotate);\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic ssize_t store_rotate_all(struct device *device,\n\t\t\t\tstruct device_attribute *attr,const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct fb_info *info;\n\tint rotate, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = simple_strtoul(buf, last, 0);\n\tfbcon_rotate_all(info, rotate);\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic ssize_t show_rotate(struct device *device,\n\t\t\t   struct device_attribute *attr,char *buf)\n{\n\tstruct fb_info *info;\n\tint rotate = 0, idx;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\trotate = fbcon_get_rotate(info);\nerr:\n\tconsole_unlock();\n\treturn sysfs_emit(buf, \"%d\\n\", rotate);\n}\n\nstatic ssize_t show_cursor_blink(struct device *device,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info;\n\tstruct fbcon_ops *ops;\n\tint idx, blink = -1;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\tops = info->fbcon_par;\n\n\tif (!ops)\n\t\tgoto err;\n\n\tblink = delayed_work_pending(&ops->cursor_work);\nerr:\n\tconsole_unlock();\n\treturn sysfs_emit(buf, \"%d\\n\", blink);\n}\n\nstatic ssize_t store_cursor_blink(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fb_info *info;\n\tint blink, idx;\n\tchar **last = NULL;\n\n\tconsole_lock();\n\tidx = con2fb_map[fg_console];\n\n\tif (idx == -1 || fbcon_registered_fb[idx] == NULL)\n\t\tgoto err;\n\n\tinfo = fbcon_registered_fb[idx];\n\n\tif (!info->fbcon_par)\n\t\tgoto err;\n\n\tblink = simple_strtoul(buf, last, 0);\n\n\tif (blink) {\n\t\tfbcon_cursor_noblink = 0;\n\t\tfbcon_add_cursor_work(info);\n\t} else {\n\t\tfbcon_cursor_noblink = 1;\n\t\tfbcon_del_cursor_work(info);\n\t}\n\nerr:\n\tconsole_unlock();\n\treturn count;\n}\n\nstatic struct device_attribute device_attrs[] = {\n\t__ATTR(rotate, S_IRUGO|S_IWUSR, show_rotate, store_rotate),\n\t__ATTR(rotate_all, S_IWUSR, NULL, store_rotate_all),\n\t__ATTR(cursor_blink, S_IRUGO|S_IWUSR, show_cursor_blink,\n\t       store_cursor_blink),\n};\n\nstatic int fbcon_init_device(void)\n{\n\tint i, error = 0;\n\n\tfbcon_has_sysfs = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(device_attrs); i++) {\n\t\terror = device_create_file(fbcon_device, &device_attrs[i]);\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tdevice_remove_file(fbcon_device, &device_attrs[i]);\n\n\t\tfbcon_has_sysfs = 0;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\nstatic void fbcon_register_existing_fbs(struct work_struct *work)\n{\n\tint i;\n\n\tconsole_lock();\n\n\tdeferred_takeover = false;\n\tlogo_shown = FBCON_LOGO_DONTSHOW;\n\n\tfbcon_for_each_registered_fb(i)\n\t\tdo_fb_registered(fbcon_registered_fb[i]);\n\n\tconsole_unlock();\n}\n\nstatic struct notifier_block fbcon_output_nb;\nstatic DECLARE_WORK(fbcon_deferred_takeover_work, fbcon_register_existing_fbs);\n\nstatic int fbcon_output_notifier(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\tpr_info(\"fbcon: Taking over console\\n\");\n\n\tdummycon_unregister_output_notifier(&fbcon_output_nb);\n\n\t/* We may get called in atomic context */\n\tschedule_work(&fbcon_deferred_takeover_work);\n\n\treturn NOTIFY_OK;\n}\n#endif\n\nstatic void fbcon_start(void)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tif (conswitchp != &dummy_con)\n\t\tdeferred_takeover = false;\n\n\tif (deferred_takeover) {\n\t\tfbcon_output_nb.notifier_call = fbcon_output_notifier;\n\t\tdummycon_register_output_notifier(&fbcon_output_nb);\n\t\treturn;\n\t}\n#endif\n}\n\nvoid __init fb_console_init(void)\n{\n\tint i;\n\n\tconsole_lock();\n\tfbcon_device = device_create(fb_class, NULL, MKDEV(0, 0), NULL,\n\t\t\t\t     \"fbcon\");\n\n\tif (IS_ERR(fbcon_device)) {\n\t\tprintk(KERN_WARNING \"Unable to create device \"\n\t\t       \"for fbcon; errno = %ld\\n\",\n\t\t       PTR_ERR(fbcon_device));\n\t\tfbcon_device = NULL;\n\t} else\n\t\tfbcon_init_device();\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tcon2fb_map[i] = -1;\n\n\tfbcon_start();\n\tconsole_unlock();\n}\n\n#ifdef MODULE\n\nstatic void __exit fbcon_deinit_device(void)\n{\n\tint i;\n\n\tif (fbcon_has_sysfs) {\n\t\tfor (i = 0; i < ARRAY_SIZE(device_attrs); i++)\n\t\t\tdevice_remove_file(fbcon_device, &device_attrs[i]);\n\n\t\tfbcon_has_sysfs = 0;\n\t}\n}\n\nvoid __exit fb_console_exit(void)\n{\n#ifdef CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tconsole_lock();\n\tif (deferred_takeover)\n\t\tdummycon_unregister_output_notifier(&fbcon_output_nb);\n\tconsole_unlock();\n\n\tcancel_work_sync(&fbcon_deferred_takeover_work);\n#endif\n\n\tconsole_lock();\n\tfbcon_deinit_device();\n\tdevice_destroy(fb_class, MKDEV(0, 0));\n\n\tdo_unregister_con_driver(&fb_con);\n\tconsole_unlock();\n}\t\n#endif\n"], "filenames": ["drivers/video/fbdev/core/fbcon.c"], "buggy_code_start_loc": [2497], "buggy_code_end_loc": [2501], "fixing_code_start_loc": [2498], "fixing_code_end_loc": [2504], "type": "CWE-682", "message": "A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.", "other": {"cve": {"id": "CVE-2023-3161", "sourceIdentifier": "secalert@redhat.com", "published": "2023-06-12T20:15:12.910", "lastModified": "2023-06-22T00:17:17.553", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-682"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1335"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2", "matchCriteriaId": "108695B6-7133-4B6C-80AF-0F66880FE858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*", "matchCriteriaId": "FF501633-2F44-4913-A8EE-B021929F49F6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "2BDA597B-CAC1-4DF0-86F0-42E142C654E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "725C78C9-12CE-406F-ABE8-0813A01D66E8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "A127C155-689C-4F67-B146-44A57F4BFD85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "D34127CC-68F5-4703-A5F6-5006F803E4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "4AB8D555-648E-4F2F-98BD-3E7F45BD12A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2213485", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2b09d5d364986f724f17001ccfe4126b9b43a0be", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2b09d5d364986f724f17001ccfe4126b9b43a0be"}}