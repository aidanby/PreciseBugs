{"buggy_code": ["/*\r\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Codename One designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *  \r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n * \r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n * \r\n * Please contact Codename One through http://www.codenameone.com/ if you \r\n * need additional information or have any questions.\r\n */\r\npackage com.codename1.impl.android;\r\n\r\nimport android.Manifest;\r\nimport android.annotation.TargetApi;\r\nimport com.codename1.location.AndroidLocationManager;\r\nimport android.app.*;\r\nimport android.content.pm.PackageManager.NameNotFoundException;\r\nimport android.media.AudioTimestamp;\r\nimport android.support.v4.content.ContextCompat;\r\nimport android.view.MotionEvent;\r\nimport com.codename1.codescan.ScanResult;\r\nimport com.codename1.media.Media;\r\nimport com.codename1.ui.geom.Dimension;\r\n\r\n\r\nimport android.webkit.CookieSyncManager;\r\nimport android.content.*;\r\nimport android.content.pm.*;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.graphics.Rect;\r\nimport android.graphics.Typeface;\r\nimport android.graphics.Path;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.media.AudioManager;\r\nimport android.net.Uri;\r\nimport android.os.Vibrator;\r\nimport android.telephony.TelephonyManager;\r\nimport android.util.DisplayMetrics;\r\nimport android.util.Log;\r\nimport android.util.TypedValue;\r\nimport android.view.KeyEvent;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.view.Window;\r\nimport android.webkit.WebSettings;\r\nimport android.webkit.WebView;\r\nimport android.webkit.WebViewClient;\r\nimport android.widget.RelativeLayout;\r\nimport android.widget.TextView;\r\nimport com.codename1.ui.BrowserComponent;\r\n\r\nimport com.codename1.ui.Component;\r\nimport com.codename1.ui.Font;\r\nimport com.codename1.ui.Image;\r\nimport com.codename1.ui.PeerComponent;\r\nimport com.codename1.ui.events.ActionEvent;\r\nimport com.codename1.impl.CodenameOneImplementation;\r\nimport com.codename1.impl.VirtualKeyboardInterface;\r\nimport com.codename1.ui.plaf.UIManager;\r\nimport com.codename1.ui.util.Resources;\r\nimport java.lang.ref.SoftReference;\r\nimport java.lang.reflect.Method;\r\nimport java.net.URISyntaxException;\r\nimport java.util.Vector;\r\nimport android.database.Cursor;\r\nimport android.database.sqlite.SQLiteDatabase;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.drawable.BitmapDrawable;\r\nimport android.hardware.Camera;\r\nimport android.media.AudioFormat;\r\nimport android.media.AudioRecord;\r\nimport android.media.ExifInterface;\r\nimport android.media.MediaPlayer;\r\nimport android.media.MediaRecorder;\r\nimport android.net.ConnectivityManager;\r\nimport android.net.NetworkInfo;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Environment;\r\nimport android.os.Handler;\r\nimport android.os.IBinder;\r\nimport android.os.Looper;\r\nimport android.os.RemoteException;\r\nimport android.provider.MediaStore;\r\nimport android.provider.Settings;\r\nimport android.provider.Settings.Secure;\r\nimport android.renderscript.Allocation;\r\nimport android.renderscript.Element;\r\nimport android.renderscript.RenderScript;\r\nimport android.renderscript.ScriptIntrinsicBlur;\r\nimport android.support.v4.app.NotificationCompat;\r\nimport android.support.v4.content.FileProvider;\r\nimport android.support.v4.media.MediaBrowserCompat;\r\nimport android.support.v4.media.session.MediaControllerCompat;\r\nimport android.support.v4.media.session.PlaybackStateCompat;\r\nimport android.telephony.SmsManager;\r\nimport android.telephony.gsm.GsmCellLocation;\r\nimport android.text.Html;\r\nimport android.view.*;\r\nimport android.view.View.MeasureSpec;\r\nimport android.webkit.*;\r\nimport android.widget.*;\r\nimport com.codename1.background.BackgroundFetch;\r\nimport com.codename1.capture.VideoCaptureConstraints;\r\nimport com.codename1.codescan.CodeScanner;\r\nimport com.codename1.contacts.Contact;\r\nimport com.codename1.db.Database;\r\nimport com.codename1.impl.android.compat.app.NotificationCompatWrapper;\r\nimport com.codename1.impl.android.compat.app.NotificationCompatWrapper.ActionWrapper;\r\nimport com.codename1.impl.android.compat.app.RemoteInputWrapper;\r\nimport com.codename1.io.BufferedInputStream;\r\nimport com.codename1.io.BufferedOutputStream;\r\nimport com.codename1.io.*;\r\nimport com.codename1.l10n.L10NManager;\r\nimport com.codename1.location.LocationManager;\r\nimport com.codename1.media.AbstractMedia;\r\nimport com.codename1.media.AsyncMedia;\r\nimport com.codename1.media.AsyncMedia.MediaErrorType;\r\nimport com.codename1.media.AsyncMedia.MediaException;\r\nimport com.codename1.media.Audio;\r\nimport com.codename1.media.AudioService;\r\nimport com.codename1.media.BackgroundAudioService;\r\nimport com.codename1.media.MediaProxy;\r\nimport com.codename1.media.MediaRecorderBuilder;\r\nimport com.codename1.messaging.Message;\r\nimport com.codename1.notifications.LocalNotification;\r\nimport com.codename1.payment.Purchase;\r\nimport com.codename1.push.PushAction;\r\nimport com.codename1.push.PushActionCategory;\r\nimport com.codename1.push.PushActionsProvider;\r\nimport com.codename1.push.PushCallback;\r\nimport com.codename1.push.PushContent;\r\nimport com.codename1.ui.*;\r\nimport com.codename1.ui.Dialog;\r\nimport com.codename1.ui.Display;\r\nimport com.codename1.ui.animations.Animation;\r\nimport com.codename1.ui.animations.CommonTransitions;\r\nimport com.codename1.ui.events.ActionListener;\r\nimport com.codename1.ui.geom.GeneralPath;\r\nimport com.codename1.ui.geom.Rectangle;\r\nimport com.codename1.ui.geom.Shape;\r\nimport com.codename1.ui.layouts.BorderLayout;\r\nimport com.codename1.ui.plaf.Style;\r\nimport com.codename1.ui.util.EventDispatcher;\r\nimport com.codename1.util.AsyncResource;\r\nimport com.codename1.util.Callback;\r\nimport java.io.File;\r\nimport java.io.FileDescriptor;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.io.RandomAccessFile;\r\nimport java.io.Writer;\r\nimport java.lang.reflect.Constructor;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URI;\r\nimport java.net.URL;\r\nimport java.net.URLConnection;\r\nimport java.text.DateFormat;\r\nimport java.text.NumberFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Date;\r\nimport java.util.Hashtable;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Set;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport com.codename1.util.StringUtil;\r\nimport com.codename1.util.SuccessCallback;\r\nimport java.io.*;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Modifier;\r\nimport java.net.CookieHandler;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.NetworkInterface;\r\nimport java.net.ServerSocket;\r\nimport java.security.MessageDigest;\r\nimport java.text.ParseException;\r\nimport java.util.*;\r\nimport javax.net.ssl.HttpsURLConnection;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\n\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\nimport org.json.JSONStringer;\r\nimport org.xml.sax.SAXException;\r\n//import android.webkit.JavascriptInterface;\r\n\r\npublic class AndroidImplementation extends CodenameOneImplementation implements IntentResultListener {\r\n    public static final Thread.UncaughtExceptionHandler exceptionHandler = new Thread.UncaughtExceptionHandler() {\r\n        @Override\r\n        public void uncaughtException(Thread t, Throwable e) {\r\n            if(com.codename1.io.Log.isCrashBound()) {\r\n                com.codename1.io.Log.p(\"Uncaught exception in thread \" + t.getName());\r\n                com.codename1.io.Log.e(e);\r\n                com.codename1.io.Log.sendLog();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * make sure these important keys have a negative value when passed to\r\n     * Codename One or they might be interpreted as characters.\r\n     */\r\n    static final int DROID_IMPL_KEY_LEFT = -23446;\r\n    static final int DROID_IMPL_KEY_RIGHT = -23447;\r\n    static final int DROID_IMPL_KEY_UP = -23448;\r\n    static final int DROID_IMPL_KEY_DOWN = -23449;\r\n    static final int DROID_IMPL_KEY_FIRE = -23450;\r\n    static final int DROID_IMPL_KEY_MENU = -23451;\r\n    static final int DROID_IMPL_KEY_BACK = -23452;\r\n    static final int DROID_IMPL_KEY_BACKSPACE = -23453;\r\n    static final int DROID_IMPL_KEY_CLEAR = -23454;\r\n    static final int DROID_IMPL_KEY_SEARCH = -23455;\r\n    static final int DROID_IMPL_KEY_CALL = -23456;\r\n    static final int DROID_IMPL_KEY_VOLUME_UP = -23457;\r\n    static final int DROID_IMPL_KEY_VOLUME_DOWN = -23458;\r\n    static final int DROID_IMPL_KEY_MUTE = -23459;\r\n    static int[] leftSK = new int[]{DROID_IMPL_KEY_MENU};\r\n\r\n    /**\r\n     * @return the activity\r\n     */\r\n    public static CodenameOneActivity getActivity() {\r\n        return activity;\r\n    }\r\n\r\n    /**\r\n     * @param aActivity the activity to set\r\n     */\r\n    public static void setActivity(CodenameOneActivity aActivity) {\r\n        activity = aActivity;\r\n        if (activity != null) {\r\n            activityComponentName = activity.getComponentName();\r\n        }\r\n        \r\n    }\r\n    CodenameOneSurface myView = null;\r\n    CodenameOneTextPaint defaultFont;\r\n    private final char[] tmpchar = new char[1];\r\n    private final Rect tmprect = new Rect();\r\n    protected int defaultFontHeight;\r\n    private Vibrator v = null;\r\n    private boolean vibrateInitialized = false;\r\n    private int displayWidth;\r\n    private int displayHeight;\r\n    static CodenameOneActivity activity;\r\n    static ComponentName activityComponentName;\r\n    \r\n    private static Context context;\r\n    RelativeLayout relativeLayout;\r\n    final Vector nativePeers = new Vector();\r\n    int lastDirectionalKeyEventReceivedByWrapper;\r\n    private EventDispatcher callback;\r\n    private int timeout = -1;\r\n    private CodeScannerImpl scannerInstance;\r\n    private HashMap apIds;\r\n    private static View viewBelow;\r\n    private static View viewAbove;\r\n    private static int aboveSpacing;\r\n    private static int belowSpacing;\r\n    public static boolean asyncView = false;\r\n    public static boolean textureView = false;\r\n    private AudioService background;\r\n    private boolean asyncEditMode = false;\r\n    private boolean compatPaintMode;\r\n    private MediaRecorder recorder = null;\r\n\r\n    private boolean statusBarHidden;\r\n    private boolean superPeerMode = true;\r\n    \r\n    \r\n    private ValueCallback<Uri> mUploadMessage;\r\n    public ValueCallback<Uri[]> uploadMessage;\r\n\r\n    /**\r\n     * Keeps track of running contexts.\r\n     * @see #startContext(Context)\r\n     * @see #stopContext(Context)\r\n     */\r\n    private static HashSet<Context> activeContexts = new HashSet<Context>();\r\n\r\n    /**\r\n     * A method to be called when a Context begins its execution.  This adds the\r\n     * context to the context set.  When the contenxt's execution completes, it should\r\n     * call {@link #stopContext} to clear up resources.\r\n     * @param ctx The context that is starting.\r\n     * @see #stopContext(Context)\r\n     */\r\n    public static void startContext(Context ctx) {\r\n\r\n        while (deinitializingEdt) {\r\n            // It is possible that deinitialize was called just before the\r\n            // last context was destroyed so there is a pending deinitialize\r\n            // working its way through the system.  Give it some time\r\n            // before forcing the deinitialize\r\n            System.out.println(\"Waiting for deinitializing to complete before starting a new initialization\");\r\n            try {\r\n                Thread.sleep(30);\r\n\r\n            } catch (Exception ex){}\r\n        }\r\n        if (deinitializing && instance != null) {\r\n            instance.deinitialize();\r\n        }\r\n        synchronized(activeContexts) {\r\n            activeContexts.add(ctx);\r\n            if (instance == null) {\r\n                // If this is our first rodeo, just call Display.init() as that should\r\n                // be sufficient to set everything up.\r\n                Display.init(ctx);\r\n            } else {\r\n                // If we've initialized before, we should \"re-initialize\" the implementation\r\n                // Reinitializing will force views to be created even if the EDT was already\r\n                // running in background mode.\r\n                reinit(ctx);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleans up resources in the given context.  This method should be called by\r\n     * any Activity or Service that called startContext() when it started.\r\n     * @param ctx The context to stop.\r\n     *\r\n     * @see #startContext(Context)\r\n     */\r\n    public static void stopContext(Context ctx) {\r\n        synchronized(activeContexts) {\r\n            activeContexts.remove(ctx);\r\n            if (activeContexts.isEmpty()) {\r\n                // If we are the last context, we should deinitialize\r\n                syncDeinitialize();\r\n            } else {\r\n                if (instance != null && getActivity() != null) {\r\n                    // if this is an activity, then we should clean up\r\n                    // our UI resources anyways because the last context\r\n                    // to be cleaned up might not have access to the UI thread.\r\n                    instance.deinitialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setPlatformHint(String key, String value) {\r\n        if(key.equals(\"platformHint.compatPaintMode\")) {\r\n            compatPaintMode = value.equalsIgnoreCase(\"true\");\r\n            return;\r\n        }\r\n        if(key.equals(\"platformHint.legacyPaint\")) {\r\n            AndroidAsyncView.legacyPaintLogic = value.equalsIgnoreCase(\"true\");;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method in used internally for ads\r\n     * @param above shown above the view\r\n     * @param below shown below the view\r\n     */\r\n    public static void setViewAboveBelow(View above, View below, int spacingAbove, int spacingBelow) {\r\n        viewBelow = below;\r\n        viewAbove = above;\r\n        aboveSpacing = spacingAbove;\r\n        belowSpacing = spacingBelow;\r\n    }\r\n\r\n    static boolean hasViewAboveBelow(){\r\n        return viewBelow != null || viewAbove != null;\r\n    }\r\n\r\n    /**\r\n     * Copy the input stream into the output stream, closes both streams when finishing or in\r\n     * a case of an exception\r\n     *\r\n     * @param i source\r\n     * @param o destination\r\n     */\r\n    private static void copy(InputStream i, OutputStream o) throws IOException {\r\n        copy(i, o, 8192);\r\n    }\r\n\r\n    /**\r\n     * Copy the input stream into the output stream, closes both streams when finishing or in\r\n     * a case of an exception\r\n     *\r\n     * @param i source\r\n     * @param o destination\r\n     * @param bufferSize the size of the buffer, which should be a power of 2 large enoguh\r\n     */\r\n    private static void copy(InputStream i, OutputStream o, int bufferSize) throws IOException {\r\n        try {\r\n            byte[] buffer = new byte[bufferSize];\r\n            int size = i.read(buffer);\r\n            while(size > -1) {\r\n                o.write(buffer, 0, size);\r\n                size = i.read(buffer);\r\n            }\r\n        } finally {\r\n            sCleanup(o);\r\n            sCleanup(i);\r\n        }\r\n    }\r\n\r\n    private static void sCleanup(Object o) {\r\n        try {\r\n            if(o != null) {\r\n                if(o instanceof InputStream) {\r\n                    ((InputStream)o).close();\r\n                    return;\r\n                }\r\n                if(o instanceof OutputStream) {\r\n                    ((OutputStream)o).close();\r\n                    return;\r\n                }\r\n            }\r\n        } catch(Throwable t) {}\r\n    }\r\n\r\n    /**\r\n     * Copied here since the cleanup method in util would crash append notification that runs when the app isn't in the foreground\r\n     */\r\n    private static byte[] readInputStream(InputStream i) throws IOException {\r\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\r\n        copy(i, b);\r\n        return b.toByteArray();\r\n    }\r\n\r\n\r\n    public static void appendNotification(String type, String body, Context a) {\r\n        appendNotification(type, body, null, null, a);\r\n    }\r\n    \r\n    public static void appendNotification(String type, String body, String image, String category, Context a) {\r\n        try {\r\n            String[] fileList = a.fileList();\r\n            byte[] data = null;\r\n            for (int iter = 0; iter < fileList.length; iter++) {\r\n                if (fileList[iter].equals(\"CN1$AndroidPendingNotifications\")) {\r\n                    InputStream is = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n                    if(is != null) {\r\n                        data = readInputStream(is);\r\n                        sCleanup(a);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            DataOutputStream os = new DataOutputStream(a.openFileOutput(\"CN1$AndroidPendingNotifications\", 0));\r\n            if(data != null) {\r\n                data[0]++;\r\n                os.write(data);\r\n            } else {\r\n                os.writeByte(1);\r\n            }\r\n            String bodyType = type;\r\n            if (image != null || category != null) {\r\n                type = \"99\";\r\n            }\r\n            if(type != null) {\r\n                os.writeBoolean(true);\r\n                os.writeUTF(type);\r\n            } else {\r\n                os.writeBoolean(false);\r\n            }\r\n            if (\"99\".equals(type)) {\r\n                String msg = \"body=\"+java.net.URLEncoder.encode(body, \"UTF-8\")\r\n                        +\"&type=\"+java.net.URLEncoder.encode(bodyType, \"UTF-8\");\r\n                if (category != null) {\r\n                    msg += \"&category=\"+java.net.URLEncoder.encode(category, \"UTF-8\");\r\n                }\r\n                if (image != null) {\r\n                    image += \"&image=\"+java.net.URLEncoder.encode(image, \"UTF-8\");\r\n                }\r\n                os.writeUTF(msg);\r\n                        \r\n            } else {\r\n                os.writeUTF(body);\r\n            }\r\n            os.writeLong(System.currentTimeMillis());\r\n        } catch(IOException err) {\r\n            err.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static Map<String,String> splitQuery(String urlencodeQueryString) {\r\n        String[] parts = urlencodeQueryString.split(\"&\");\r\n        Map<String,String> out = new HashMap<String,String>();\r\n        for (String part : parts) {\r\n            int pos = part.indexOf(\"=\");\r\n            String k,v;\r\n            if (pos > 0) {\r\n                k = part.substring(0, pos);\r\n                v = part.substring(pos+1);\r\n            } else {\r\n                k = part;\r\n                v = \"\";\r\n            }\r\n            try { k = java.net.URLDecoder.decode(k, \"UTF-8\");} catch (Exception ex){}\r\n            try {v = java.net.URLDecoder.decode(v, \"UTF-8\");} catch (Exception ex){}\r\n            out.put(k, v);\r\n        }\r\n        return out;\r\n    }\r\n\r\n\r\n\r\n    public static void initPushContent(String message, String image, String messageType, String category, Context context) {\r\n        com.codename1.push.PushContent.reset();\r\n        \r\n        int iMessageType = 1;\r\n        try {iMessageType = Integer.parseInt(messageType);}catch(Throwable t){}\r\n        \r\n        String actionId = null;\r\n        String reply = null;\r\n        boolean cancel = true;\r\n        if (context instanceof Activity) {\r\n            Activity activity = (Activity)context;\r\n            Bundle extras = activity.getIntent().getExtras();\r\n            if (extras != null) {\r\n                actionId = extras.getString(\"pushActionId\");\r\n                extras.remove(\"pushActionId\");\r\n\r\n                if (actionId != null && RemoteInputWrapper.isSupported()) {\r\n                    Bundle textExtras = RemoteInputWrapper.getResultsFromIntent(activity.getIntent());\r\n                    if (textExtras != null) {\r\n                        CharSequence cs  = textExtras.getCharSequence(actionId + \"$Result\");\r\n                        if (cs != null) {\r\n                            reply = cs.toString();\r\n                        }\r\n                    }\r\n\r\n                    \r\n                }\r\n            }\r\n            \r\n        }\r\n        if (cancel) {\r\n            PushNotificationService.cancelNotification(context);\r\n        }\r\n        com.codename1.push.PushContent.setType(iMessageType);\r\n        com.codename1.push.PushContent.setCategory(category);\r\n        if (actionId != null) {\r\n            com.codename1.push.PushContent.setActionId(actionId);\r\n        }\r\n        if (reply != null) {\r\n            com.codename1.push.PushContent.setTextResponse(reply);\r\n        }\r\n        switch (iMessageType) {\r\n            case 1:\r\n            case 5:\r\n                com.codename1.push.PushContent.setBody(message);break;\r\n            case 2: com.codename1.push.PushContent.setMetaData(message);break;\r\n            case 3: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setMetaData(parts[1]);\r\n                com.codename1.push.PushContent.setBody(parts[0]);\r\n                break;\r\n            }\r\n            case 4: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setTitle(parts[0]);\r\n                com.codename1.push.PushContent.setBody(parts[1]);\r\n                break;\r\n            }\r\n            case 101: {\r\n                com.codename1.push.PushContent.setBody(message.substring(message.indexOf(\" \") + 1));\r\n                com.codename1.push.PushContent.setType(1);\r\n                break;\r\n            }\r\n            case 102: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setTitle(parts[1]);\r\n                com.codename1.push.PushContent.setBody(parts[2]);\r\n                com.codename1.push.PushContent.setType(2);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Name of file where we install the push notification categories as an XML file\r\n    // if the main class implements PushActiosProvider\r\n    private static String FILE_NAME_NOTIFICATION_CATEGORIES = \"CN1$AndroidNotificationCategories\";\r\n    \r\n    \r\n    \r\n    /**\r\n     * Action categories are defined on the Main class by implementing the PushActionsProvider, however\r\n     * the main class may not be available to the push receiver, so we need to save these categories\r\n     * to the file system when the app is installed, then the push receiver can load these actions\r\n     * when it sends a push while the app isn't running.\r\n     * @param provider A reference to the App's main class \r\n     * @throws IOException \r\n     */\r\n    public static void installNotificationActionCategories(PushActionsProvider provider) throws IOException {\r\n        // Assume that CN1 is running... this will run when the app starts\r\n        // up\r\n        Context context = getContext();\r\n        boolean requiresUpdate = false;\r\n        \r\n        File categoriesFile = new File(activity.getFilesDir().getAbsolutePath() + \"/\" + FILE_NAME_NOTIFICATION_CATEGORIES);\r\n        if (!categoriesFile.exists()) {\r\n            requiresUpdate = true;\r\n        }\r\n        if (!requiresUpdate) {\r\n            try {\r\n                PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getApplicationContext().getPackageName(), PackageManager.GET_PERMISSIONS);\r\n                if (packageInfo.lastUpdateTime > categoriesFile.lastModified()) {\r\n                    requiresUpdate = true;\r\n                }\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        \r\n        if (!requiresUpdate) {\r\n            return;\r\n        }\r\n        \r\n        OutputStream os = getContext().openFileOutput(FILE_NAME_NOTIFICATION_CATEGORIES, 0);\r\n        PushActionCategory[] categories = provider.getPushActionCategories();\r\n        javax.xml.parsers.DocumentBuilderFactory docFactory = javax.xml.parsers.DocumentBuilderFactory.newInstance();\r\n        javax.xml.parsers.DocumentBuilder docBuilder;\r\n        try {\r\n            docBuilder = docFactory.newDocumentBuilder();\r\n        } catch (ParserConfigurationException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Faield to create document builder for creating notification categories XML document\", ex);\r\n        }\r\n\r\n        // root elements\r\n        org.w3c.dom.Document doc = docBuilder.newDocument();\r\n        org.w3c.dom.Element root = (org.w3c.dom.Element)doc.createElement(\"categories\");\r\n        doc.appendChild(root);\r\n        for (PushActionCategory category : categories) {\r\n            org.w3c.dom.Element categoryEl = (org.w3c.dom.Element)doc.createElement(\"category\");\r\n            org.w3c.dom.Attr idAttr = doc.createAttribute(\"id\");\r\n            idAttr.setValue(category.getId());\r\n            categoryEl.setAttributeNode(idAttr);\r\n            \r\n            for (PushAction action : category.getActions()) {\r\n                org.w3c.dom.Element actionEl = (org.w3c.dom.Element)doc.createElement(\"action\");\r\n                org.w3c.dom.Attr actionIdAttr = doc.createAttribute(\"id\");\r\n                actionIdAttr.setValue(action.getId());\r\n                actionEl.setAttributeNode(actionIdAttr);\r\n                \r\n                \r\n                org.w3c.dom.Attr actionTitleAttr = doc.createAttribute(\"title\");\r\n                if (action.getTitle() != null) {\r\n                    actionTitleAttr.setValue(action.getTitle());\r\n                } else {\r\n                    actionTitleAttr.setValue(action.getId());\r\n                }\r\n                actionEl.setAttributeNode(actionTitleAttr);\r\n                \r\n                if (action.getIcon() != null) {\r\n                    org.w3c.dom.Attr actionIconAttr = doc.createAttribute(\"icon\");\r\n                    String iconVal = action.getIcon();\r\n                    try {\r\n                        // We'll store the resource IDs for the icon\r\n                        // rather than the icon name because that is what\r\n                        // the push notifications require.\r\n                        iconVal = \"\"+context.getResources().getIdentifier(iconVal, \"drawable\", context.getPackageName());\r\n                        actionIconAttr.setValue(iconVal);\r\n                        actionEl.setAttributeNode(actionIconAttr);\r\n                    } catch (Exception ex) {\r\n                        ex.printStackTrace();\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n                if (action.getTextInputPlaceholder() != null) {\r\n                    org.w3c.dom.Attr textInputPlaceholderAttr = doc.createAttribute(\"textInputPlaceholder\");\r\n                    textInputPlaceholderAttr.setValue(action.getTextInputPlaceholder());\r\n                    actionEl.setAttributeNode(textInputPlaceholderAttr);\r\n                }\r\n                if (action.getTextInputButtonText() != null) {\r\n                    org.w3c.dom.Attr textInputButtonTextAttr = doc.createAttribute(\"textInputButtonText\");\r\n                    textInputButtonTextAttr.setValue(action.getTextInputButtonText());\r\n                    actionEl.setAttributeNode(textInputButtonTextAttr);\r\n                }\r\n                categoryEl.appendChild(actionEl);\r\n            }\r\n            root.appendChild(categoryEl);\r\n            \r\n        }\r\n        try {\r\n            javax.xml.transform.TransformerFactory transformerFactory = javax.xml.transform.TransformerFactory.newInstance();\r\n            javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\r\n            javax.xml.transform.dom.DOMSource source = new javax.xml.transform.dom.DOMSource(doc);\r\n            javax.xml.transform.stream.StreamResult result = new javax.xml.transform.stream.StreamResult(os);\r\n            transformer.transform(source, result);\r\n            \r\n        } catch (Exception ex) {\r\n            throw new IOException(\"Failed to save notification categories as XML.\", ex);\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Retrieves the app's available push action categories from the XML file in which they\r\n     * should have been installed on the first load.\r\n     * @param context\r\n     * @return\r\n     * @throws IOException \r\n     */\r\n    private static PushActionCategory[] getInstalledPushActionCategories(Context context) throws IOException {\r\n        // NOTE:  This method may be called from the PushReceiver when the app isn't running so we can't access\r\n        // the main activity context, display properties, or any CN1 stuff.  Just native android\r\n        \r\n        File categoriesFile = new File(context.getFilesDir().getAbsolutePath() + \"/\" + FILE_NAME_NOTIFICATION_CATEGORIES);\r\n        if (!categoriesFile.exists()) {\r\n            return new PushActionCategory[0];\r\n        }\r\n        javax.xml.parsers.DocumentBuilderFactory docFactory = javax.xml.parsers.DocumentBuilderFactory.newInstance();\r\n        javax.xml.parsers.DocumentBuilder docBuilder;\r\n        try {\r\n            docBuilder = docFactory.newDocumentBuilder();\r\n        } catch (ParserConfigurationException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Faield to create document builder for creating notification categories XML document\", ex);\r\n        }\r\n        org.w3c.dom.Document doc;\r\n        try {\r\n            doc = docBuilder.parse(context.openFileInput(FILE_NAME_NOTIFICATION_CATEGORIES));\r\n        } catch (SAXException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Failed to parse instaled push action categories\", ex);\r\n        }\r\n        org.w3c.dom.Element root = doc.getDocumentElement();\r\n        java.util.List<PushActionCategory> out = new ArrayList<PushActionCategory>();\r\n        org.w3c.dom.NodeList l = root.getElementsByTagName(\"category\");\r\n        int len = l.getLength();\r\n        for (int i=0; i<len; i++) {\r\n            org.w3c.dom.Element el = (org.w3c.dom.Element)l.item(i);\r\n            java.util.List<PushAction> actions = new ArrayList<PushAction>();\r\n            org.w3c.dom.NodeList al = el.getElementsByTagName(\"action\");\r\n            int alen = al.getLength();\r\n            for (int j=0; j<alen; j++) {\r\n                org.w3c.dom.Element actionEl = (org.w3c.dom.Element)al.item(j);\r\n                String textInputPlaceholder = actionEl.hasAttribute(\"textInputPlaceholder\") ? actionEl.getAttribute(\"textInputPlaceholder\") : null;\r\n                String textInputButtonText = actionEl.hasAttribute(\"textInputButtonText\") ? actionEl.getAttribute(\"textInputButtonText\") : null;\r\n                PushAction action = new PushAction(actionEl.getAttribute(\"id\"), actionEl.getAttribute(\"title\"), actionEl.getAttribute(\"icon\"), textInputPlaceholder, textInputButtonText);\r\n                actions.add(action);\r\n            }\r\n            \r\n            PushActionCategory cat = new PushActionCategory((String)el.getAttribute(\"id\"), actions.toArray(new PushAction[actions.size()]));\r\n            out.add(cat);\r\n            \r\n        }\r\n        return out.toArray(new PushActionCategory[out.size()]);\r\n    }\r\n    \r\n    /**\r\n     * Adds actions to a push notification.  This is called by the Push broadcast receiver probably before \r\n     * Codename One is initialized\r\n     * @param provider Reference to the app's main class which implements PushActionsProvider\r\n     * @param categoryId The category ID of the push notification.\r\n     * @param builder The builder for the push notification.\r\n     * @param targetIntent The target intent... this should go to the app's main Activity.\r\n     * @param context The current context (inside the Broadcast receiver).\r\n     * @throws IOException \r\n     */\r\n    public static void addActionsToNotification(PushActionsProvider provider, String categoryId, NotificationCompat.Builder builder, Intent targetIntent, Context context) throws IOException {\r\n        // NOTE:  THis will likely run when the main activity isn't running so we won't have\r\n        // access to any display properties... just native Android APIs will be accessible.\r\n        \r\n        PushActionCategory category = null;\r\n        PushActionCategory[] categories;\r\n        if (provider != null) {\r\n            categories = provider.getPushActionCategories();\r\n        } else {\r\n            categories = getInstalledPushActionCategories(context);\r\n        }\r\n        for (PushActionCategory candidateCategory : categories) {\r\n            if (categoryId.equals(candidateCategory.getId())) {\r\n                category = candidateCategory;\r\n                break;\r\n            }\r\n        }\r\n        if (category == null) {\r\n            return;\r\n        }\r\n        \r\n        int requestCode = 1;\r\n        for (PushAction action : category.getActions()) {\r\n            Intent newIntent = (Intent)targetIntent.clone();\r\n            newIntent.putExtra(\"pushActionId\", action.getId());\r\n            PendingIntent contentIntent = PendingIntent.getActivity(context, requestCode++, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n            try {\r\n                int iconId = 0;\r\n                try { iconId = Integer.parseInt(action.getIcon());} catch (Exception ex){}\r\n                //android.app.Notification.Action.Builder actionBuilder = new android.app.Notification.Action.Builder(iconId, action.getTitle(), contentIntent);\r\n\r\n                System.out.println(\"Adding action \"+action.getId()+\", \"+action.getTitle()+\", icon=\"+iconId);\r\n                if (ActionWrapper.BuilderWrapper.isSupported()) {\r\n                    // We need to take this abstracted \"wrapper\" approach because the Action.Builder class, and RemoteInput class\r\n                    // aren't available until API 22.\r\n                    // These classes use reflection to provide support for these classes safely.\r\n                    ActionWrapper.BuilderWrapper actionBuilder = new ActionWrapper.BuilderWrapper(iconId, action.getTitle(), contentIntent);\r\n                    if (action.getTextInputPlaceholder() != null && RemoteInputWrapper.isSupported()) {\r\n                        RemoteInputWrapper.BuilderWrapper remoteInputBuilder = new RemoteInputWrapper.BuilderWrapper(action.getId()+\"$Result\");\r\n                        remoteInputBuilder.setLabel(action.getTextInputPlaceholder());\r\n\r\n                        RemoteInputWrapper remoteInput = remoteInputBuilder.build();\r\n                        actionBuilder.addRemoteInput(remoteInput);\r\n                    }\r\n                    ActionWrapper actionWrapper = actionBuilder.build();\r\n                    new NotificationCompatWrapper.BuilderWrapper(builder).addAction(actionWrapper);\r\n                } else {\r\n                    builder.addAction(iconId, action.getTitle(), contentIntent);\r\n                }\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    public static void firePendingPushes(final PushCallback c, final Context a) {\r\n        try {\r\n            if(c != null) {\r\n                InputStream i = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n                if(i == null) {\r\n                    return;\r\n                }\r\n                DataInputStream is = new DataInputStream(i);\r\n                int count = is.readByte();\r\n                for(int iter = 0 ; iter < count ; iter++) {\r\n                    boolean hasType = is.readBoolean();\r\n                    String actualType = null;\r\n                    if(hasType) {\r\n                        actualType = is.readUTF();\r\n                    }\r\n                    final String t;\r\n                    final String b;\r\n                    final String category;\r\n                    final String image;\r\n                    if (\"99\".equals(actualType)) {\r\n                        // This was a rich push\r\n                        Map<String,String> vals = splitQuery(is.readUTF());\r\n                        t = vals.get(\"type\");\r\n                        b = vals.get(\"body\");\r\n                        category = vals.get(\"category\");\r\n                        image = vals.get(\"image\");\r\n                    } else {\r\n                        t = actualType;\r\n                        b = is.readUTF();\r\n                        category = null;\r\n                        image = null;\r\n                    }\r\n                    long s = is.readLong();\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            Display.getInstance().setProperty(\"pendingPush\", \"true\");\r\n                            Display.getInstance().setProperty(\"pushType\", t);\r\n                            initPushContent(b, image, t, category, a);\r\n                            if(t != null && (\"3\".equals(t) || \"6\".equals(t))) {\r\n                                String[] a = b.split(\";\");\r\n                                c.push(a[0]);\r\n                                c.push(a[1]);\r\n                            } else if (t != null && (\"101\".equals(t))) {\r\n                                c.push(b.substring(b.indexOf(\" \")+1));\r\n                            } else {\r\n                                c.push(b);\r\n                            }\r\n                            Display.getInstance().setProperty(\"pendingPush\", null);\r\n                        }\r\n                    });\r\n                }\r\n                a.deleteFile(\"CN1$AndroidPendingNotifications\");\r\n            }\r\n        } catch(IOException err) {\r\n        }\r\n    }\r\n\r\n    public static String[] getPendingPush(String type, Context a) {\r\n        InputStream i = null;\r\n        try {\r\n            i = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n            if (i == null) {\r\n                return null;\r\n            }\r\n            DataInputStream is = new DataInputStream(i);\r\n            int count = is.readByte();\r\n            Vector v = new Vector<String>();\r\n            for (int iter = 0; iter < count; iter++) {\r\n                boolean hasType = is.readBoolean();\r\n                String actualType = null;\r\n                if (hasType) {\r\n                    actualType = is.readUTF();\r\n                }\r\n                \r\n                final String t;\r\n                final String b;\r\n                if (\"99\".equals(actualType)) {\r\n                    // This was a rich push\r\n                    Map<String,String> vals = splitQuery(is.readUTF());\r\n                    t = vals.get(\"type\");\r\n                    b = vals.get(\"body\");\r\n                    //category = vals.get(\"category\");\r\n                    //image = vals.get(\"image\");\r\n                } else {\r\n                    t = actualType;\r\n                    b = is.readUTF();\r\n                    //category = null;\r\n                    //image = null;\r\n                }\r\n                long s = is.readLong();\r\n                if(t != null && (\"3\".equals(t) || \"6\".equals(t))) {\r\n                    String[] m = b.split(\";\");\r\n                    v.add(m[0]);\r\n                } else if(t != null && \"4\".equals(t)){\r\n                    String[] m = b.split(\";\");\r\n                    v.add(m[1]);\r\n                } else if(t != null && \"2\".equals(t)){\r\n                    continue;\r\n                }else if (t != null && \"101\".equals(t)) {\r\n                    v.add(b.substring(b.indexOf(\" \")+1));\r\n                }else{\r\n                    v.add(b);\r\n                }\r\n            }\r\n            String [] retVal = new String[v.size()];\r\n            for (int j = 0; j < retVal.length; j++) {\r\n                retVal[j] = (String)v.get(j);\r\n            }\r\n            return retVal;\r\n\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if(i != null){\r\n                    i.close();\r\n                }\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static AndroidImplementation instance;\r\n\r\n    public static AndroidImplementation getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    public static void clearAppArg() {\r\n        if (instance != null) {\r\n            instance.setAppArg(null);\r\n        }\r\n    }\r\n\r\n    public static Context getContext() {\r\n        Context out = getActivity();\r\n        if (out != null) {\r\n            return out;\r\n        }\r\n        return context;\r\n    }\r\n\r\n    public void setContext(Context c) {\r\n        context = c;\r\n    }\r\n\r\n    @Override\r\n    public void init(Object m) {\r\n        // NOTE:  Do not explicitly set the PlayServices instance to anything other than\r\n        // an instance of the base PlayServices class.  The Build Server will automatically\r\n        // swap this for the appropriate subclass depending on the playServicesVersion of \r\n        // the build.\r\n        PlayServices.setInstance(new PlayServices()); // <---- DO NOT CHANGE - Build server will replace with appropriate subclass instance\r\n        if (m instanceof CodenameOneActivity) {\r\n            setContext(null);\r\n            setActivity((CodenameOneActivity) m);\r\n        } else {\r\n            setActivity(null);\r\n            setContext((Context)m);\r\n        }\r\n\r\n        instance = this;\r\n        if(getActivity() != null && getActivity().hasUI()){\r\n            if (!hasActionBar()) {\r\n                try {\r\n                    getActivity().requestWindowFeature(Window.FEATURE_NO_TITLE);\r\n                } catch (Exception e) {\r\n                    //Log.d(\"Codename One\", \"No idea why this throws a Runtime Error\", e);\r\n                }\r\n            } else {\r\n                getActivity().invalidateOptionsMenu();\r\n                try {\r\n                    getActivity().requestWindowFeature(Window.FEATURE_ACTION_BAR);\r\n                    getActivity().requestWindowFeature(Window.FEATURE_PROGRESS);\r\n\r\n                    if(android.os.Build.VERSION.SDK_INT >= 21){\r\n                        //WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS\r\n                        getActivity().getWindow().addFlags(-2147483648);\r\n                    }\r\n                } catch (Exception e) {\r\n                    //Log.d(\"Codename One\", \"No idea why this throws a Runtime Error\", e);\r\n                }\r\n                NotifyActionBar notify = new NotifyActionBar(getActivity(), false);\r\n                notify.run();\r\n            }\r\n\r\n            if(statusBarHidden) {\r\n                getActivity().getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE\r\n                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);\r\n                getActivity().getWindow().setStatusBarColor(android.graphics.Color.TRANSPARENT);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"StatusbarHidden\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"KeepScreenOn\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"DisableScreenshots\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);\r\n            }\r\n\r\n            if (m instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) m).setDefaultIntentResultListener(this);\r\n                ((CodenameOneActivity) m).setIntentResultListener(this);\r\n            }\r\n\r\n            /**\r\n             * translate our default font height depending on the screen density.\r\n             * this is required for new high resolution devices. otherwise\r\n             * everything looks awfully small.\r\n             *\r\n             * we use our default font height value of 16 and go from there. i\r\n             * thought about using new Paint().getTextSize() for this value but if\r\n             * some new version of android suddenly returns values already tranlated\r\n             * to the screen then we might end up with too large fonts. the\r\n             * documentation is not very precise on that.\r\n             */\r\n            final int defaultFontPixelHeight = 16;\r\n            this.defaultFontHeight = this.translatePixelForDPI(defaultFontPixelHeight);\r\n\r\n\r\n            this.defaultFont = (CodenameOneTextPaint) ((NativeFont) this.createFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM)).font;\r\n            Display.getInstance().setTransitionYield(-1);\r\n\r\n            initSurface();\r\n            /**\r\n             * devices are extremely sensitive so dragging should start a little\r\n             * later than suggested by default implementation.\r\n             */\r\n            this.setDragStartPercentage(1);\r\n            VirtualKeyboardInterface vkb = new AndroidKeyboard(this);\r\n            Display.getInstance().registerVirtualKeyboard(vkb);\r\n            Display.getInstance().setDefaultVirtualKeyboard(vkb);\r\n\r\n            InPlaceEditView.endEdit();\r\n\r\n            getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\r\n\r\n            if (nativePeers.size() > 0) {\r\n                for (int i = 0; i < nativePeers.size(); i++) {\r\n                    ((AndroidImplementation.AndroidPeer) nativePeers.elementAt(i)).init();\r\n                }\r\n            }\r\n        } else {\r\n            /**\r\n             * translate our default font height depending on the screen density.\r\n             * this is required for new high resolution devices. otherwise\r\n             * everything looks awfully small.\r\n             *\r\n             * we use our default font height value of 16 and go from there. i\r\n             * thought about using new Paint().getTextSize() for this value but if\r\n             * some new version of android suddenly returns values already tranlated\r\n             * to the screen then we might end up with too large fonts. the\r\n             * documentation is not very precise on that.\r\n             */\r\n            final int defaultFontPixelHeight = 16;\r\n            this.defaultFontHeight = this.translatePixelForDPI(defaultFontPixelHeight);\r\n\r\n\r\n            this.defaultFont = (CodenameOneTextPaint) ((NativeFont) this.createFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM)).font;\r\n        }\r\n        HttpURLConnection.setFollowRedirects(false);\r\n        CookieHandler.setDefault(null);\r\n        VideoCaptureConstraints.init(new AndroidVideoCaptureConstraintsCompiler());\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public boolean isInitialized(){\r\n// Removing the check for null view to prevent strange things from happening when\r\n// calling from a Service context.\r\n//        if(getActivity() != null && myView == null){\r\n//            //if the view is null deinitialize the Display\r\n//            if(super.isInitialized()){\r\n//                syncDeinitialize();\r\n//            }\r\n//            return false;\r\n//        }\r\n        return super.isInitialized();\r\n    }\r\n\r\n    /**\r\n     * Reinitializes CN1.\r\n     * @param i Context to initialize it with.\r\n     *\r\n     * @see #startContext(Context)\r\n     */\r\n    private static void reinit(Object i) {\r\n        if (instance != null && ((i instanceof CodenameOneActivity) || instance.myView == null)) {\r\n            instance.init(i);\r\n        }\r\n        Display.init(i);\r\n\r\n        // This is a hack to fix an issue that caused the screen to appear blank when\r\n        // the app is loaded from memory after being unloaded.\r\n\r\n        // This issue only seems to occur when the Activity had been unloaded\r\n        // so to test this you'll need to check the \"Don't keep activities\" checkbox under/\r\n        // Developer options.\r\n        // Developer options.\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                Display.getInstance().invokeAndBlock(new Runnable(){ public void run(){\r\n                    try {\r\n                        Thread.sleep(50);\r\n\r\n                    } catch (Exception ex){}\r\n                }});\r\n                if (!Display.isInitialized() || Display.getInstance().isMinimized()) {\r\n                    return;\r\n                }\r\n                Form cur = Display.getInstance().getCurrent();\r\n                if (cur != null) {\r\n                    cur.forceRevalidate();\r\n                }\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    private static class InvalidateOptionsMenuImpl implements Runnable {\r\n        private Activity activity;\r\n\r\n        public InvalidateOptionsMenuImpl(Activity activity) {\r\n            this.activity = activity;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            activity.invalidateOptionsMenu();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Boolean isDarkMode() {\r\n        try {\r\n            int nightModeFlags = getActivity().getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK; \r\n            switch (nightModeFlags) { \r\n                case Configuration.UI_MODE_NIGHT_YES: \r\n                    return true;\r\n                case Configuration.UI_MODE_NIGHT_NO: \r\n                    return false;\r\n                default: \r\n                    return null;\r\n            } \r\n        } catch(Throwable t) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    \r\n    private boolean hasActionBar() {\r\n        return android.os.Build.VERSION.SDK_INT >= 11;\r\n    }\r\n\r\n    public int translatePixelForDPI(int pixel) {\r\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, pixel,\r\n                getContext().getResources().getDisplayMetrics());\r\n    }\r\n\r\n    /**\r\n     * Returns the platform EDT thread priority\r\n     */\r\n    public int getEDTThreadPriority(){\r\n        return Thread.NORM_PRIORITY;\r\n    }\r\n\r\n    @Override\r\n    public int getDeviceDensity() {\r\n        DisplayMetrics metrics = new DisplayMetrics();\r\n        if (getActivity() != null) {\r\n            getActivity().getWindowManager().getDefaultDisplay().getMetrics(metrics);\r\n        } else {\r\n            metrics = getContext().getResources().getDisplayMetrics();\r\n        }\r\n\r\n        if(metrics.densityDpi < DisplayMetrics.DENSITY_MEDIUM) {\r\n            return Display.DENSITY_LOW;\r\n        }\r\n\r\n        if(metrics.densityDpi < 213) {\r\n            return Display.DENSITY_MEDIUM;\r\n        }\r\n\r\n        // 213 == TV\r\n        if(metrics.densityDpi >= 213 &&  metrics.densityDpi <= DisplayMetrics.DENSITY_HIGH) {\r\n            return Display.DENSITY_HIGH;\r\n        }\r\n\r\n        if(metrics.densityDpi > DisplayMetrics.DENSITY_HIGH && metrics.densityDpi < 400) {\r\n            return Display.DENSITY_VERY_HIGH;\r\n        }\r\n\r\n        if(metrics.densityDpi >= 400 && metrics.densityDpi < 560) {\r\n            return Display.DENSITY_HD;\r\n        }\r\n\r\n        if(metrics.densityDpi >= 560 && metrics.densityDpi <= 640) {\r\n            return Display.DENSITY_2HD;\r\n        }\r\n        if(metrics.densityDpi > 640) {\r\n            return Display.DENSITY_4K;\r\n        }\r\n\r\n        return Display.DENSITY_MEDIUM;\r\n    }\r\n\r\n    /**\r\n     * A status flag to indicate that CN1 is in the process of deinitializing.\r\n     */\r\n    private static boolean deinitializing;\r\n    private static boolean deinitializingEdt;\r\n\r\n    public static void syncDeinitialize() {\r\n        if (deinitializingEdt){\r\n            return;\r\n        }\r\n        deinitializingEdt = true; // This will get unset in {@link #deinitialize()}\r\n        deinitializing = true;\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                Display.deinitialize();\r\n                deinitializingEdt = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    public void deinitialize() {\r\n        //activity.getWindowManager().removeView(relativeLayout);\r\n        super.deinitialize();\r\n        if (getActivity() != null) {\r\n\r\n            Runnable r = new Runnable() {\r\n                public void run() {\r\n                    synchronized (AndroidImplementation.this) {\r\n                        if (!deinitializing) {\r\n                            return;\r\n                        }\r\n                        deinitializing = false;\r\n                    }\r\n                    if (nativePeers.size() > 0) {\r\n                        for (int i = 0; i < nativePeers.size(); i++) {\r\n                            ((AndroidImplementation.AndroidPeer) nativePeers.elementAt(i)).deinit();\r\n                        }\r\n                    }\r\n                    if (relativeLayout != null) {\r\n                        relativeLayout.removeAllViews();\r\n                    }\r\n                    relativeLayout = null;\r\n                    myView = null;\r\n                }\r\n            };\r\n\r\n            if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\r\n                deinitializing = true;\r\n                r.run();\r\n            } else {\r\n                deinitializing = true;\r\n                getActivity().runOnUiThread(r);\r\n            }\r\n        } else {\r\n            deinitializing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * init view. a lot of back and forth between this thread and the UI thread.\r\n     */\r\n    private void initSurface() {\r\n        if (getActivity() != null && myView == null) {\r\n            relativeLayout=  new RelativeLayout(getActivity());\r\n            relativeLayout.setLayoutParams(new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.FILL_PARENT,\r\n                    RelativeLayout.LayoutParams.FILL_PARENT));\r\n            relativeLayout.setFocusable(false);\r\n\r\n            getActivity().getWindow().setBackgroundDrawable(null);\r\n            if(asyncView) {\r\n                if(android.os.Build.VERSION.SDK_INT < 14){\r\n                    myView = new AndroidSurfaceView(getActivity(), AndroidImplementation.this);\r\n                } else {\r\n                    int hardwareAcceleration = 16777216;\r\n                    getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n                    myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n                }\r\n            } else {\r\n                int hardwareAcceleration = 16777216;\r\n                getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n                superPeerMode = true;\r\n                myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n            }\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n\r\n            relativeLayout.addView(myView.getAndroidView());\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n\r\n            int id = getActivity().getResources().getIdentifier(\"main\", \"layout\", getActivity().getApplicationInfo().packageName);\r\n            RelativeLayout root = (RelativeLayout) LayoutInflater.from(getActivity()).inflate(id, null);\r\n            if(viewAbove != null) {\r\n                RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                lp.addRule(RelativeLayout.ALIGN_PARENT_TOP);\r\n                lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n                lp2.setMargins(0, 0, aboveSpacing, 0);\r\n                relativeLayout.setLayoutParams(lp2);\r\n                root.addView(viewAbove, lp);\r\n            }\r\n            root.addView(relativeLayout);\r\n            if(viewBelow != null) {\r\n                RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                lp.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\r\n                lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n                lp2.setMargins(0, 0, 0, belowSpacing);\r\n                relativeLayout.setLayoutParams(lp2);\r\n                root.addView(viewBelow, lp);\r\n            }\r\n            getActivity().setContentView(root);\r\n            if (!myView.getAndroidView().hasFocus()) {\r\n                myView.getAndroidView().requestFocus();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void confirmControlView() {\r\n        if(myView == null){\r\n            return;\r\n        }\r\n        myView.getAndroidView().setVisibility(View.VISIBLE);\r\n        //ugly workaround for a bug where on some android versions the async view\r\n        //came back black from the background.\r\n        if(myView instanceof AndroidAsyncView){\r\n            new Thread(new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        ((AndroidAsyncView)myView).setPaintViewOnBuffer(false);\r\n                    } catch (Exception e) {\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n    }\r\n\r\n    public void hideNotifyPublic() {\r\n        super.hideNotify();\r\n        saveTextEditingState();\r\n    }\r\n\r\n    public void showNotifyPublic() {\r\n        super.showNotify();\r\n    }\r\n\r\n    @Override\r\n    public boolean isMinimized() {\r\n        return getActivity() == null || ((CodenameOneActivity)getActivity()).isBackground();\r\n    }\r\n\r\n    @Override\r\n    public boolean minimizeApplication() {\r\n        Intent startMain = new Intent(Intent.ACTION_MAIN);\r\n        startMain.addCategory(Intent.CATEGORY_HOME);\r\n        startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n        startMain.putExtra(\"WaitForResult\", Boolean.FALSE);\r\n        getContext().startActivity(startMain);\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void restoreMinimizedApplication() {\r\n        if (getActivity() != null) {\r\n            Intent i = new Intent(getActivity(), getActivity().getClass());\r\n            i.setAction(Intent.ACTION_MAIN);\r\n            i.addCategory(Intent.CATEGORY_LAUNCHER);\r\n            getContext().startActivity(i);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeInputImmediate() {\r\n        return true;\r\n    }\r\n\r\n    public void editString(final Component cmp, int maxSize, final int constraint, String text, int keyCode) {\r\n        if (keyCode > 0 && getKeyboardType() == Display.KEYBOARD_TYPE_QWERTY) {\r\n            text += (char) keyCode;\r\n        }\r\n        InPlaceEditView.edit(this, cmp, constraint);\r\n    }\r\n\r\n    protected boolean editInProgress() {\r\n        return InPlaceEditView.isEditing();\r\n    }\r\n\r\n    @Override\r\n    public boolean isAsyncEditMode() {\r\n        return asyncEditMode;\r\n    }\r\n\r\n    void setAsyncEditMode(boolean async) {\r\n        asyncEditMode = async;\r\n    }\r\n\r\n    void callHideTextEditor() {\r\n        super.hideTextEditor();\r\n    }\r\n\r\n    @Override\r\n    public void hideTextEditor() {\r\n        InPlaceEditView.hideActiveTextEditor();\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeEditorVisible(Component c) {\r\n        return super.isNativeEditorVisible(c) && !InPlaceEditView.isActiveTextEditorHidden();\r\n    }\r\n\r\n    public static void stopEditing() {\r\n        stopEditing(false);\r\n    }\r\n\r\n    public static void stopEditing(final boolean forceVKBClose){\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        final boolean[] flag = new boolean[]{false};\r\n\r\n        // InPlaceEditView.endEdit must be called from the UI thread.\r\n        // We must wait for this call to be over, otherwise Codename One's painting\r\n        // of the next form will be garbled.\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                // Must be called from the UI thread\r\n                InPlaceEditView.stopEdit(forceVKBClose);\r\n\r\n                synchronized (flag) {\r\n                    flag[0] = true;\r\n                    flag.notify();\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!flag[0]) {\r\n            // Wait (if necessary) for the asynchronous runOnUiThread to do its work\r\n            synchronized (flag) {\r\n\r\n                try {\r\n                    flag.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void saveTextEditingState() {\r\n        stopEditing(true);\r\n    }\r\n\r\n    @Override\r\n    public void stopTextEditing() {\r\n        saveTextEditingState();\r\n    }\r\n\r\n    @Override\r\n    public void stopTextEditing(final Runnable onFinish) {\r\n        final Form f = Display.getInstance().getCurrent();\r\n        f.addSizeChangedListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent evt) {\r\n                f.removeSizeChangedListener(this);\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        onFinish.run();\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        stopEditing(true);\r\n    }\r\n\r\n\r\n    protected void setLastSizeChangedWH(int w, int h) {\r\n        // not used?\r\n        //this.lastSizeChangeW = w;\r\n        //this.lastSizeChangeH = h;\r\n    }\r\n\r\n    /*@Override\r\n    public boolean handleEDTException(final Throwable err) {\r\n\r\n        final boolean[] messageComplete = new boolean[]{false};\r\n\r\n        Log.e(\"Codename One\", \"Err on EDT\", err);\r\n\r\n        activity.runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                UIManager m = UIManager.getInstance();\r\n                final FrameLayout frameLayout = new FrameLayout(\r\n                        activity);\r\n                final TextView textView = new TextView(\r\n                        activity);\r\n                textView.setGravity(Gravity.CENTER);\r\n                frameLayout.addView(textView, new FrameLayout.LayoutParams(\r\n                        FrameLayout.LayoutParams.FILL_PARENT,\r\n                        FrameLayout.LayoutParams.WRAP_CONTENT));\r\n                textView.setText(\"An internal application error occurred: \" + err.toString());\r\n                AlertDialog.Builder bob = new AlertDialog.Builder(\r\n                        activity);\r\n                bob.setView(frameLayout);\r\n                bob.setTitle(\"\");\r\n                bob.setPositiveButton(m.localize(\"ok\", \"OK\"),\r\n                        new DialogInterface.OnClickListener() {\r\n                            @Override\r\n                            public void onClick(DialogInterface d, int which) {\r\n                                d.dismiss();\r\n                                synchronized (messageComplete) {\r\n                                    messageComplete[0] = true;\r\n                                    messageComplete.notify();\r\n                                }\r\n                            }\r\n                        });\r\n                AlertDialog editDialog = bob.create();\r\n                editDialog.show();\r\n            }\r\n        });\r\n\r\n        synchronized (messageComplete) {\r\n            if (messageComplete[0]) {\r\n                return true;\r\n            }\r\n            try {\r\n                messageComplete.wait();\r\n            } catch (Exception ignored) {\r\n                ;\r\n            }\r\n        }\r\n        return true;\r\n    }*/\r\n\r\n    @Override\r\n    public InputStream getResourceAsStream(Class cls, String resource) {\r\n        try {\r\n            if (resource.startsWith(\"/\")) {\r\n                resource = resource.substring(1);\r\n            }\r\n            return getContext().getAssets().open(resource);\r\n        } catch (IOException ex) {\r\n            Log.i(\"Codename One\", \"Resource not found: \" + resource);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void pointerPressed(final int x, final int y) {\r\n        super.pointerPressed(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerPressed(final int[] x, final int[] y) {\r\n        super.pointerPressed(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerReleased(final int x, final int y) {\r\n        super.pointerReleased(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerReleased(final int[] x, final int[] y) {\r\n        super.pointerReleased(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerDragged(int x, int y) {\r\n        super.pointerDragged(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerDragged(int[] x, int[] y) {\r\n        super.pointerDragged(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected int getDragAutoActivationThreshold() {\r\n        return 1000000;\r\n    }\r\n\r\n    @Override\r\n    public void flushGraphics() {\r\n        if (myView != null) {\r\n            myView.flushGraphics();\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void flushGraphics(int x, int y, int width, int height) {\r\n        this.tmprect.set(x, y, x + width, y + height);\r\n        if (myView != null) {\r\n            myView.flushGraphics(this.tmprect);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int charWidth(Object nativeFont, char ch) {\r\n        this.tmpchar[0] = ch;\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(this.tmpchar, 0, 1);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public int charsWidth(Object nativeFont, char[] ch, int offset, int length) {\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(ch, offset, length);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public int stringWidth(Object nativeFont, String str) {\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(str);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public void setNativeFont(Object graphics, Object font) {\r\n        if (font == null) {\r\n            font = this.defaultFont;\r\n        }\r\n        if (font instanceof NativeFont) {\r\n            ((AndroidGraphics) graphics).setFont((CodenameOneTextPaint) ((NativeFont) font).font);\r\n        } else {\r\n            ((AndroidGraphics) graphics).setFont((CodenameOneTextPaint) font);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getHeight(Object nativeFont) {\r\n        CodenameOneTextPaint font = (nativeFont == null ? this.defaultFont\r\n                : (CodenameOneTextPaint) ((NativeFont) nativeFont).font);\r\n        if(font.fontHeight < 0) {\r\n            Paint.FontMetrics fm = font.getFontMetrics();\r\n            font.fontHeight = (int)Math.ceil(fm.bottom - fm.top);\r\n        }\r\n        return font.fontHeight;\r\n    }\r\n\r\n    @Override\r\n    public int getFontAscent(Object nativeFont) {\r\n        Paint font = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font);\r\n        return -Math.round(font.getFontMetrics().ascent);\r\n    }\r\n\r\n    @Override\r\n    public int getFontDescent(Object nativeFont) {\r\n        Paint font = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font);\r\n        return Math.abs(Math.round(font.getFontMetrics().descent));\r\n    }\r\n\r\n    @Override\r\n    public boolean isBaselineTextSupported() {\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    public int getFace(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.FACE_SYSTEM;\r\n        }\r\n        return ((NativeFont) nativeFont).face;\r\n    }\r\n\r\n    public int getStyle(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.STYLE_PLAIN;\r\n        }\r\n        return ((NativeFont) nativeFont).style;\r\n    }\r\n\r\n    @Override\r\n    public int getSize(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.SIZE_MEDIUM;\r\n        }\r\n        return ((NativeFont) nativeFont).size;\r\n    }\r\n\r\n    @Override\r\n    public boolean isTrueTypeSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeFontSchemeSupported() {\r\n        return true;\r\n    }\r\n\r\n    private Typeface fontToRoboto(String fontName) {\r\n        if(\"native:MainThin\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.NORMAL);\r\n        }\r\n        if(\"native:MainLight\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-light\", Typeface.NORMAL);\r\n        }\r\n        if(\"native:MainRegular\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif\", Typeface.NORMAL);\r\n        }\r\n\r\n        if(\"native:MainBold\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\r\n        }\r\n\r\n        if(\"native:MainBlack\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-black\", Typeface.BOLD);\r\n        }\r\n\r\n        if(\"native:ItalicThin\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicLight\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicRegular\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicBold\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-condensed\", Typeface.BOLD_ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicBlack\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-black\", Typeface.BOLD_ITALIC);\r\n        }\r\n\r\n        throw new IllegalArgumentException(\"Unsupported native font type: \" + fontName);\r\n    }\r\n\r\n    @Override\r\n    public Object loadTrueTypeFont(String fontName, String fileName) {\r\n        if(fontName.startsWith(\"native:\")) {\r\n            Typeface t = fontToRoboto(fontName);\r\n            int fontStyle = com.codename1.ui.Font.STYLE_PLAIN;\r\n            if(t.isBold()) {\r\n                fontStyle |= com.codename1.ui.Font.STYLE_BOLD;\r\n            }\r\n            if(t.isItalic()) {\r\n                fontStyle |= com.codename1.ui.Font.STYLE_ITALIC;\r\n            }\r\n            CodenameOneTextPaint newPaint = new CodenameOneTextPaint(t);\r\n            newPaint.setAntiAlias(true);\r\n            newPaint.setSubpixelText(true);\r\n            return new NativeFont(com.codename1.ui.Font.FACE_SYSTEM, fontStyle,\r\n                    com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fileName, 0, 0);\r\n        }\r\n        Typeface t = Typeface.createFromAsset(getContext().getAssets(), fileName);\r\n        if(t == null) {\r\n            throw new RuntimeException(\"Font not found: \" + fileName);\r\n        }\r\n        CodenameOneTextPaint newPaint = new CodenameOneTextPaint(t);\r\n        newPaint.setAntiAlias(true);\r\n        newPaint.setSubpixelText(true);\r\n        return new NativeFont(com.codename1.ui.Font.FACE_SYSTEM,\r\n                com.codename1.ui.Font.STYLE_PLAIN, com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fileName, 0, 0);\r\n    }\r\n\r\n    public static class NativeFont {\r\n        int face;\r\n        int style;\r\n        int size;\r\n        public Object font;\r\n        String fileName;\r\n        float height;\r\n        int weight;\r\n\r\n        public NativeFont(int face, int style, int size, Object font, String fileName, float height, int weight) {\r\n            this(face, style, size, font);\r\n            this.fileName = fileName;\r\n            this.height = height;\r\n            this.weight = weight;\r\n        }\r\n\r\n        public NativeFont(int face, int style, int size, Object font) {\r\n            this.face = face;\r\n            this.style = style;\r\n            this.size = size;\r\n            this.font = font;\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if(o == null) {\r\n                return false;\r\n            }\r\n            NativeFont n = ((NativeFont)o);\r\n            if(fileName != null) {\r\n                return n.fileName != null && fileName.equals(n.fileName) && n.height == height && n.weight == weight;\r\n            }\r\n            return n.face == face && n.style == style && n.size == size && font.equals(n.font);\r\n        }\r\n\r\n        public int hashCode() {\r\n            return face | style | size;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object deriveTrueTypeFont(Object font, float size, int weight) {\r\n        NativeFont fnt = (NativeFont)font;\r\n        CodenameOneTextPaint paint = (CodenameOneTextPaint)fnt.font;\r\n        paint.setAntiAlias(true);\r\n        Typeface type = paint.getTypeface();\r\n        int fontstyle = Typeface.NORMAL;\r\n        if ((weight & Font.STYLE_BOLD) != 0 || type.isBold()) {\r\n            fontstyle |= Typeface.BOLD;\r\n        }\r\n        if ((weight & Font.STYLE_ITALIC) != 0 || type.isItalic()) {\r\n            fontstyle |= Typeface.ITALIC;\r\n        }\r\n        type = Typeface.create(type, fontstyle);\r\n        CodenameOneTextPaint newPaint = new CodenameOneTextPaint(type);\r\n        newPaint.setTextSize(size);\r\n        newPaint.setAntiAlias(true);\r\n        NativeFont n = new NativeFont(com.codename1.ui.Font.FACE_SYSTEM, weight, com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fnt.fileName, size, weight);\r\n        return n;\r\n    }\r\n\r\n    @Override\r\n    public Object createFont(int face, int style, int size) {\r\n        Typeface typeface = null;\r\n        switch (face) {\r\n            case Font.FACE_MONOSPACE:\r\n                typeface = Typeface.MONOSPACE;\r\n                break;\r\n            default:\r\n                typeface = Typeface.DEFAULT;\r\n                break;\r\n        }\r\n\r\n        int fontstyle = Typeface.NORMAL;\r\n        if ((style & Font.STYLE_BOLD) != 0) {\r\n            fontstyle |= Typeface.BOLD;\r\n        }\r\n        if ((style & Font.STYLE_ITALIC) != 0) {\r\n            fontstyle |= Typeface.ITALIC;\r\n        }\r\n\r\n\r\n        int height = this.defaultFontHeight;\r\n        int diff = height / 3;\r\n\r\n        switch (size) {\r\n            case Font.SIZE_SMALL:\r\n                height -= diff;\r\n                break;\r\n            case Font.SIZE_LARGE:\r\n                height += diff;\r\n                break;\r\n        }\r\n\r\n        Paint font = new CodenameOneTextPaint(Typeface.create(typeface, fontstyle));\r\n        font.setAntiAlias(true);\r\n        font.setUnderlineText((style & Font.STYLE_UNDERLINED) != 0);\r\n        font.setTextSize(height);\r\n        return new NativeFont(face, style, size, font);\r\n\r\n    }\r\n\r\n    /**\r\n     * Loads a native font based on a lookup for a font name and attributes.\r\n     * Font lookup values can be separated by commas and thus allow fallback if\r\n     * the primary font isn't supported by the platform.\r\n     *\r\n     * @param lookup string describing the font\r\n     * @return the native font object\r\n     */\r\n    public Object loadNativeFont(String lookup) {\r\n        try {\r\n            lookup = lookup.split(\";\")[0];\r\n            int typeface = Typeface.NORMAL;\r\n            String familyName = lookup.substring(0, lookup.indexOf(\"-\"));\r\n            String style = lookup.substring(lookup.indexOf(\"-\") + 1, lookup.lastIndexOf(\"-\"));\r\n            String size = lookup.substring(lookup.lastIndexOf(\"-\") + 1, lookup.length());\r\n\r\n            if (style.equals(\"bolditalic\")) {\r\n                typeface = Typeface.BOLD_ITALIC;\r\n            } else if (style.equals(\"italic\")) {\r\n                typeface = Typeface.ITALIC;\r\n            } else if (style.equals(\"bold\")) {\r\n                typeface = Typeface.BOLD;\r\n            }\r\n            Paint font = new CodenameOneTextPaint(Typeface.create(familyName, typeface));\r\n            font.setAntiAlias(true);\r\n            font.setTextSize(Integer.parseInt(size));\r\n            return new NativeFont(0, 0, 0, font);\r\n        } catch (Exception err) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates whether loading a font by a string is supported by the platform\r\n     *\r\n     * @return true if the platform supports font lookup\r\n     */\r\n    @Override\r\n    public boolean isLookupFontSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAntiAliasedTextSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setAntiAliasedText(Object graphics, boolean a) {\r\n        android.graphics.Paint p  = ((AndroidGraphics) graphics).getFont();\r\n        if(p != null) {\r\n            p.setAntiAlias(a);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object getDefaultFont() {\r\n        CodenameOneTextPaint paint = new CodenameOneTextPaint(this.defaultFont);\r\n        return new NativeFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM, paint);\r\n    }\r\n\r\n\r\n    private AndroidGraphics nullGraphics;\r\n\r\n    private AndroidGraphics getNullGraphics() {\r\n        if (nullGraphics == null) {\r\n            Bitmap bitmap = Bitmap.createBitmap(getDisplayWidth()==0?100:getDisplayWidth(), getDisplayHeight()==0?100:getDisplayHeight(),\r\n                    Bitmap.Config.ARGB_8888);\r\n            nullGraphics = (AndroidGraphics) this.getNativeGraphics(bitmap);\r\n        }\r\n        return nullGraphics;\r\n    }\r\n\r\n\r\n    @Override\r\n    public Object getNativeGraphics() {\r\n        if(myView != null){\r\n            nullGraphics = null;\r\n            return myView.getGraphics();\r\n        }else{\r\n            return getNullGraphics();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object getNativeGraphics(Object image) {\r\n        AndroidGraphics g =  new AndroidGraphics(this, new Canvas((Bitmap) image), true);\r\n        g.setClip(0, 0, ((Bitmap)image).getWidth(), ((Bitmap)image).getHeight());\r\n        return g;\r\n    }\r\n\r\n    @Override\r\n    public void getRGB(Object nativeImage, int[] arr, int offset, int x, int y,\r\n                       int width, int height) {\r\n        ((Bitmap) nativeImage).getPixels(arr, offset, width, x, y, width,\r\n                height);\r\n    }\r\n\r\n    private int sampleSizeOverride = -1;\r\n\r\n    @Override\r\n    public Object createImage(String path) throws IOException {\r\n        int IMAGE_MAX_SIZE = getDisplayHeight();\r\n        if (exists(path)) {\r\n            Bitmap b = null;\r\n            try {\r\n                //Decode image size\r\n                BitmapFactory.Options o = new BitmapFactory.Options();\r\n                o.inJustDecodeBounds = true;\r\n                o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                InputStream fis = createFileInputStream(path);\r\n                BitmapFactory.decodeStream(fis, null, o);\r\n                fis.close();\r\n\r\n                int scale = 1;\r\n                if (o.outHeight > IMAGE_MAX_SIZE || o.outWidth > IMAGE_MAX_SIZE) {\r\n                    scale = (int) Math.pow(2, (int) Math.round(Math.log(IMAGE_MAX_SIZE / (double) Math.max(o.outHeight, o.outWidth)) / Math.log(0.5)));\r\n                }\r\n\r\n                //Decode with inSampleSize\r\n                BitmapFactory.Options o2 = new BitmapFactory.Options();\r\n                o2.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                if(sampleSizeOverride != -1) {\r\n                    o2.inSampleSize = sampleSizeOverride;\r\n                } else {\r\n                    String sampleSize = Display.getInstance().getProperty(\"android.sampleSize\", null);\r\n                    if(sampleSize != null) {\r\n                        o2.inSampleSize = Integer.parseInt(sampleSize);\r\n                    } else {\r\n                        o2.inSampleSize = scale;\r\n                    }\r\n                }\r\n                o2.inPurgeable = true;\r\n                o2.inInputShareable = true;\r\n                fis = createFileInputStream(path);\r\n                b = BitmapFactory.decodeStream(fis, null, o2);\r\n                fis.close();\r\n\r\n                //fix rotation\r\n                ExifInterface exif = new ExifInterface(removeFilePrefix(path));\r\n                int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n\r\n                int angle = 0;\r\n                switch (orientation) {\r\n                    case ExifInterface.ORIENTATION_ROTATE_90:\r\n                        angle = 90;\r\n                        break;\r\n                    case ExifInterface.ORIENTATION_ROTATE_180:\r\n                        angle = 180;\r\n                        break;\r\n                    case ExifInterface.ORIENTATION_ROTATE_270:\r\n                        angle = 270;\r\n                        break;\r\n                }\r\n\r\n                if (sampleSizeOverride < 0 && angle != 0) {\r\n                    Matrix mat = new Matrix();\r\n                    mat.postRotate(angle);\r\n                    Bitmap correctBmp = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), mat, true);\r\n                    b.recycle();\r\n                    b = correctBmp;\r\n                }\r\n            } catch (IOException e) {\r\n            }\r\n            return b;\r\n        } else {\r\n            InputStream in = this.getResourceAsStream(getClass(), path);\r\n            if (in == null) {\r\n                throw new IOException(\"Resource not found. \" + path);\r\n            }\r\n            try {\r\n                return this.createImage(in);\r\n            } finally {\r\n                if (in != null) {\r\n                    try {\r\n                        in.close();\r\n                    } catch (Exception ignored) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean areMutableImagesFast() {\r\n        if (myView == null) return false;\r\n        return !myView.alwaysRepaintAll();\r\n    }\r\n\r\n    @Override\r\n    public void repaint(Animation cmp) {\r\n        if(myView != null && myView.alwaysRepaintAll()) {\r\n            if(cmp instanceof Component) {\r\n                Component c = (Component)cmp;\r\n                c.setDirtyRegion(null);\r\n                if(c.getParent() != null) {\r\n                    cmp = c.getComponentForm();\r\n                } else {\r\n                    Form f = getCurrentForm();\r\n                    if(f != null) {\r\n                        cmp = f;\r\n                    }\r\n                }\r\n            } else {\r\n                // make sure the form is repainted for standalone anims e.g. in the case\r\n                // of replace animation\r\n                Form f = getCurrentForm();\r\n                if(f != null) {\r\n                    super.repaint(f);\r\n                }\r\n            }\r\n        }\r\n        super.repaint(cmp);\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(InputStream i) throws IOException {\r\n        BitmapFactory.Options opts = new BitmapFactory.Options();\r\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n        return BitmapFactory.decodeStream(i, null, opts);\r\n    }\r\n\r\n    @Override\r\n    public void releaseImage(Object image) {\r\n        Bitmap i = (Bitmap) image;\r\n        i.recycle();\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(byte[] bytes, int offset, int len) {\r\n        BitmapFactory.Options opts = new BitmapFactory.Options();\r\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n        try {\r\n            BitmapFactory.Options.class.getField(\"inPurgeable\").set(opts, true);\r\n        } catch (Exception e) {\r\n            // inPurgeable not supported\r\n            // http://www.droidnova.com/2d-sprite-animation-in-android-addendum,505.html\r\n        }\r\n        return BitmapFactory.decodeByteArray(bytes, offset, len, opts);\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(int[] rgb, int width, int height) {\r\n        return Bitmap.createBitmap(rgb, width, height, Bitmap.Config.ARGB_8888);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAlphaMutableImageSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object scale(Object nativeImage, int width, int height) {\r\n        return Bitmap.createScaledBitmap((Bitmap) nativeImage, width, height,\r\n                false);\r\n    }\r\n\r\n    //    @Override\r\n//    public Object rotate(Object image, int degrees) {\r\n//        Matrix matrix = new Matrix();\r\n//        matrix.postRotate(degrees);\r\n//        return Bitmap.createBitmap((Bitmap) image, 0, 0, ((Bitmap) image).getWidth(), ((Bitmap) image).getHeight(), matrix, true);\r\n//    }\r\n    @Override\r\n    public boolean isRotationDrawingSupported() {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    protected boolean cacheLinearGradients() {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeInputSupported() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the underlying OS supports opening the native navigation\r\n     * application\r\n     * @return true if the underlying OS supports launch of native navigation app\r\n     */\r\n    public boolean isOpenNativeNavigationAppSupported(){\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Opens the native navigation app in the given coordinate.\r\n     * @param latitude\r\n     * @param longitude\r\n     */\r\n    public void openNativeNavigationApp(double latitude, double longitude){\r\n        execute(\"google.navigation:ll=\" + latitude+ \",\" + longitude);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void openNativeNavigationApp(String location) {\r\n        execute(\"google.navigation:q=\" + Util.encodeUrl(location));\r\n    }\r\n\r\n    @Override\r\n    public Object createMutableImage(int width, int height, int fillColor) {\r\n        Bitmap bitmap = Bitmap.createBitmap(width, height,\r\n                Bitmap.Config.ARGB_8888);\r\n        AndroidGraphics graphics = (AndroidGraphics) this.getNativeGraphics(bitmap);\r\n        graphics.fillBitmap(fillColor);\r\n        return bitmap;\r\n    }\r\n\r\n    @Override\r\n    public int getImageHeight(Object i) {\r\n        return ((Bitmap) i).getHeight();\r\n    }\r\n\r\n    @Override\r\n    public int getImageWidth(Object i) {\r\n        return ((Bitmap) i).getWidth();\r\n    }\r\n\r\n    @Override\r\n    public void drawImage(Object graphics, Object img, int x, int y) {\r\n        ((AndroidGraphics) graphics).drawImage(img, x, y);\r\n    }\r\n\r\n    @Override\r\n    public void tileImage(Object graphics, Object img, int x, int y, int w, int h) {\r\n        ((AndroidGraphics) graphics).tileImage(img, x, y, w, h);\r\n    }\r\n\r\n    public boolean isScaledImageDrawingSupported() {\r\n        return true;\r\n    }\r\n\r\n    public void drawImage(Object graphics, Object img, int x, int y, int w, int h) {\r\n        ((AndroidGraphics) graphics).drawImage(img, x, y, w, h);\r\n    }\r\n\r\n    @Override\r\n    public void drawLine(Object graphics, int x1, int y1, int x2, int y2) {\r\n        ((AndroidGraphics) graphics).drawLine(x1, y1, x2, y2);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAntiAliasingSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setAntiAliased(Object graphics, boolean a) {\r\n        ((AndroidGraphics) graphics).getPaint().setAntiAlias(a);\r\n    }\r\n\r\n    @Override\r\n    public void drawPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {\r\n        ((AndroidGraphics) graphics).drawPolygon(xPoints, yPoints, nPoints);\r\n    }\r\n\r\n    @Override\r\n    public void fillPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {\r\n        ((AndroidGraphics) graphics).fillPolygon(xPoints, yPoints, nPoints);\r\n    }\r\n\r\n    @Override\r\n    public void drawRGB(Object graphics, int[] rgbData, int offset, int x,\r\n                        int y, int w, int h, boolean processAlpha) {\r\n        ((AndroidGraphics) graphics).drawRGB(rgbData, offset, x, y, w, h, processAlpha);\r\n    }\r\n\r\n    @Override\r\n    public void drawRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).drawRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void drawRoundRect(Object graphics, int x, int y, int width,\r\n                              int height, int arcWidth, int arcHeight) {\r\n        ((AndroidGraphics) graphics).drawRoundRect(x, y, width, height, arcWidth, arcHeight);\r\n    }\r\n\r\n    @Override\r\n    public void drawString(Object graphics, String str, int x, int y) {\r\n        ((AndroidGraphics) graphics).drawString(str, x, y);\r\n    }\r\n\r\n    @Override\r\n    public void drawArc(Object graphics, int x, int y, int width, int height,\r\n                        int startAngle, int arcAngle) {\r\n        ((AndroidGraphics) graphics).drawArc(x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void fillArc(Object graphics, int x, int y, int width, int height,\r\n                        int startAngle, int arcAngle) {\r\n        ((AndroidGraphics) graphics).fillArc(x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void fillRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).fillRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void fillRect(Object graphics, int x, int y, int w, int h, byte alpha) {\r\n        ((AndroidGraphics) graphics).fillRect(x, y, w, h, alpha);\r\n    }\r\n\r\n    @Override\r\n    public void paintComponentBackground(Object graphics, int x, int y, int width, int height, Style s) {\r\n        if((!asyncView) || compatPaintMode ) {\r\n            super.paintComponentBackground(graphics, x, y, width, height, s);\r\n            return;\r\n        }\r\n        ((AndroidGraphics) graphics).paintComponentBackground(x, y, width, height, s);\r\n    }\r\n\r\n    @Override\r\n    public void fillLinearGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, boolean horizontal) {\r\n        if(!asyncView) {\r\n            super.fillLinearGradient(graphics, startColor, endColor, x, y, width, height, horizontal);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)graphics).fillLinearGradient(startColor, endColor, x, y, width, height, horizontal);\r\n    }\r\n\r\n    @Override\r\n    public void fillRectRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, float relativeX, float relativeY, float relativeSize) {\r\n        if(!asyncView) {\r\n            super.fillRectRadialGradient(graphics, startColor, endColor, x, y, width, height, relativeX, relativeY, relativeSize);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)graphics).fillRectRadialGradient(startColor, endColor, x, y, width, height, relativeX, relativeY, relativeSize);\r\n    }\r\n\r\n    @Override\r\n    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height) {\r\n        ((AndroidGraphics)graphics).fillRadialGradient(startColor, endColor, x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, int startAngle, int arcAngle) {\r\n        ((AndroidGraphics)graphics).fillRadialGradient(startColor, endColor, x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void drawLabelComponent(Object nativeGraphics, int cmpX, int cmpY, int cmpHeight, int cmpWidth, Style style, String text, Object icon, Object stateIcon, int preserveSpaceForState, int gap, boolean rtl, boolean isOppositeSide, int textPosition, int stringWidth, boolean isTickerRunning, int tickerShiftText, boolean endsWith3Points, int valign) {\r\n        if(AndroidAsyncView.legacyPaintLogic) {\r\n            super.drawLabelComponent(nativeGraphics, cmpX, cmpY, cmpHeight, cmpWidth, style, text, icon, stateIcon, preserveSpaceForState, gap, rtl, isOppositeSide, textPosition, stringWidth, isTickerRunning, tickerShiftText, endsWith3Points, valign);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)nativeGraphics).drawLabelComponent(cmpX, cmpY, cmpHeight, cmpWidth, style, text,\r\n                (Bitmap)icon, (Bitmap)stateIcon, preserveSpaceForState, gap, rtl, isOppositeSide, textPosition, stringWidth,\r\n                isTickerRunning, tickerShiftText, endsWith3Points, valign);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void fillRoundRect(Object graphics, int x, int y, int width,\r\n                              int height, int arcWidth, int arcHeight) {\r\n        ((AndroidGraphics) graphics).fillRoundRect(x, y, width, height, arcWidth, arcHeight);\r\n    }\r\n\r\n    @Override\r\n    public int getAlpha(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getAlpha();\r\n    }\r\n\r\n    @Override\r\n    public void setAlpha(Object graphics, int alpha) {\r\n        ((AndroidGraphics) graphics).setAlpha(alpha);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAlphaGlobal() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setColor(Object graphics, int RGB) {\r\n        ((AndroidGraphics) graphics).setColor((getColor(graphics) & 0xff000000) | RGB);\r\n    }\r\n\r\n    @Override\r\n    public int getBackKeyCode() {\r\n        return DROID_IMPL_KEY_BACK;\r\n    }\r\n\r\n    @Override\r\n    public int getBackspaceKeyCode() {\r\n        return DROID_IMPL_KEY_BACKSPACE;\r\n    }\r\n\r\n    @Override\r\n    public int getClearKeyCode() {\r\n        return DROID_IMPL_KEY_CLEAR;\r\n    }\r\n\r\n    @Override\r\n    public int getClipHeight(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipHeight();\r\n    }\r\n\r\n    @Override\r\n    public int getClipWidth(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipWidth();\r\n    }\r\n\r\n    @Override\r\n    public int getClipX(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipX();\r\n    }\r\n\r\n    @Override\r\n    public int getClipY(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipY();\r\n    }\r\n\r\n    @Override\r\n    public void setClip(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).setClip(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public boolean isShapeClipSupported(Object graphics){\r\n        return Build.VERSION.SDK_INT > Build.VERSION_CODES.HONEYCOMB;\r\n    }\r\n\r\n    @Override\r\n    public void setClip(Object graphics, Shape shape) {\r\n        //Path p = cn1ShapeToAndroidPath(shape);\r\n        ((AndroidGraphics) graphics).setClip(shape);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void clipRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).clipRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public int getColor(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getColor();\r\n    }\r\n\r\n    @Override\r\n    public int getDisplayHeight() {\r\n        if (this.myView != null) {\r\n            int h = this.myView.getViewHeight();\r\n            displayHeight = h;\r\n            return h;\r\n        }\r\n        return displayHeight;\r\n    }\r\n\r\n    @Override\r\n    public int getDisplayWidth() {\r\n        if (this.myView != null) {\r\n            int w = this.myView.getViewWidth();\r\n            displayWidth = w;\r\n            return w;\r\n        }\r\n        return displayWidth;\r\n    }\r\n\r\n    @Override\r\n    public int getActualDisplayHeight() {\r\n        DisplayMetrics dm = getContext().getResources().getDisplayMetrics();\r\n        return dm.heightPixels;\r\n    }\r\n\r\n    @Override\r\n    public int getGameAction(int keyCode) {\r\n        switch (keyCode) {\r\n            case DROID_IMPL_KEY_DOWN:\r\n                return Display.GAME_DOWN;\r\n            case DROID_IMPL_KEY_UP:\r\n                return Display.GAME_UP;\r\n            case DROID_IMPL_KEY_LEFT:\r\n                return Display.GAME_LEFT;\r\n            case DROID_IMPL_KEY_RIGHT:\r\n                return Display.GAME_RIGHT;\r\n            case DROID_IMPL_KEY_FIRE:\r\n                return Display.GAME_FIRE;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getKeyCode(int gameAction) {\r\n        switch (gameAction) {\r\n            case Display.GAME_DOWN:\r\n                return DROID_IMPL_KEY_DOWN;\r\n            case Display.GAME_UP:\r\n                return DROID_IMPL_KEY_UP;\r\n            case Display.GAME_LEFT:\r\n                return DROID_IMPL_KEY_LEFT;\r\n            case Display.GAME_RIGHT:\r\n                return DROID_IMPL_KEY_RIGHT;\r\n            case Display.GAME_FIRE:\r\n                return DROID_IMPL_KEY_FIRE;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int[] getSoftkeyCode(int index) {\r\n        if (index == 0) {\r\n            return leftSK;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public int getSoftkeyCount() {\r\n        /**\r\n         * one menu button only. we may have to stuff some code here as soon as\r\n         * there are devices that no longer have only a single menu button.\r\n         */\r\n        return 1;\r\n    }\r\n\r\n    @Override\r\n    public void vibrate(int duration) {\r\n        if (!this.vibrateInitialized) {\r\n            try {\r\n                v = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);\r\n            } catch (Throwable e) {\r\n                Log.e(\"Codename One\", \"problem with virbrator(0)\", e);\r\n            } finally {\r\n                this.vibrateInitialized = true;\r\n            }\r\n        }\r\n        if (v != null) {\r\n            try {\r\n                v.vibrate(duration);\r\n            } catch (Throwable e) {\r\n                Log.e(\"Codename One\", \"problem with virbrator(1)\", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isTouchDevice() {\r\n        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN);\r\n    }\r\n\r\n    @Override\r\n    public boolean hasPendingPaints() {\r\n        //if the view is not visible make sure the edt won't wait.\r\n        if (myView != null && myView.getAndroidView().getVisibility() != View.VISIBLE) {\r\n            return true;\r\n        } else {\r\n            return super.hasPendingPaints();\r\n        }\r\n    }\r\n\r\n    public void revalidate() {\r\n        if (myView != null) {\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n            getCurrentForm().revalidate();\r\n            flushGraphics();\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public int getKeyboardType() {\r\n        if (Display.getInstance().getDefaultVirtualKeyboard().isVirtualKeyboardShowing()) {\r\n            return Display.KEYBOARD_TYPE_VIRTUAL;\r\n        }\r\n        /**\r\n         * can we detect this? but even if we could i think it is best to have\r\n         * this fixed to qwerty. we pass unicode values to Codename One in any\r\n         * case. check AndroidView.onKeyUpDown() method. and read comment below.\r\n         */\r\n        return Display.KEYBOARD_TYPE_QWERTY;\r\n        /**\r\n         * some info from the MIDP docs about keycodes:\r\n         *\r\n         * \"Applications receive keystroke events in which the individual keys\r\n         * are named within a space of key codes. Every key for which events are\r\n         * reported to MIDP applications is assigned a key code. The key code\r\n         * values are unique for each hardware key unless two keys are obvious\r\n         * synonyms for each other. MIDP defines the following key codes:\r\n         * KEY_NUM0, KEY_NUM1, KEY_NUM2, KEY_NUM3, KEY_NUM4, KEY_NUM5, KEY_NUM6,\r\n         * KEY_NUM7, KEY_NUM8, KEY_NUM9, KEY_STAR, and KEY_POUND. (These key\r\n         * codes correspond to keys on a ITU-T standard telephone keypad.) Other\r\n         * keys may be present on the keyboard, and they will generally have key\r\n         * codes distinct from those list above. In order to guarantee\r\n         * portability, applications should use only the standard key codes.\r\n         *\r\n         * The standard key codes values are equal to the Unicode encoding for\r\n         * the character that represents the key. If the device includes any\r\n         * other keys that have an obvious correspondence to a Unicode\r\n         * character, their key code values should equal the Unicode encoding\r\n         * for that character. For keys that have no corresponding Unicode\r\n         * character, the implementation must use negative values. Zero is\r\n         * defined to be an invalid key code.\"\r\n         *\r\n         * Because the MIDP implementation is our reference and that\r\n         * implementation does not interpret the given keycodes we behave alike\r\n         * and pass on the unicode values.\r\n         */\r\n    }\r\n\r\n    /**\r\n     * Exits the application...\r\n     */\r\n    public void exitApplication() {\r\n        android.os.Process.killProcess(android.os.Process.myPid());\r\n    }\r\n\r\n    @Override\r\n    public void notifyCommandBehavior(int commandBehavior) {\r\n        if (commandBehavior == Display.COMMAND_BEHAVIOR_NATIVE) {\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).enableNativeMenu(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class NotifyActionBar implements Runnable {\r\n        private Activity activity;\r\n        private boolean show;\r\n\r\n        public NotifyActionBar(Activity activity, int commandBehavior) {\r\n            this.activity = activity;\r\n            show = commandBehavior == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }\r\n\r\n        public NotifyActionBar(Activity activity, boolean show) {\r\n            this.activity = activity;\r\n            this.show = show;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            activity.invalidateOptionsMenu();\r\n            if (show) {\r\n                activity.getActionBar().show();\r\n            } else {\r\n                activity.getActionBar().hide();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String getAppArg() {\r\n        if (super.getAppArg() != null) {\r\n            // This just maintains backward compatibility in case people are manually\r\n            // setting the AppArg in their properties.  It reproduces the general\r\n            // behaviour the existed when AppArg was just another Display property.\r\n            return super.getAppArg();\r\n        }\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n\r\n        android.content.Intent intent = getActivity().getIntent();\r\n        if (intent != null) {\r\n            String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\r\n            intent.removeExtra(Intent.EXTRA_TEXT);\r\n            Uri u = intent.getData();\r\n            String scheme = intent.getScheme();\r\n            if (u == null && intent.getExtras() != null) {\r\n                if (intent.getExtras().keySet().contains(\"android.intent.extra.STREAM\")) {\r\n                    try {\r\n                        u = (Uri)intent.getParcelableExtra(\"android.intent.extra.STREAM\");\r\n                        scheme = u.getScheme();\r\n                        System.out.println(\"u=\"+u);\r\n                    } catch (Exception ex) {\r\n                        Log.d(\"Codename One\", \"Failed to load parcelable extra from intent: \"+ex.getMessage());\r\n                    }\r\n                }\r\n\r\n            }\r\n            if (u != null) {\r\n                //String scheme = intent.getScheme();\r\n                intent.setData(null);\r\n                if (\"content\".equals(scheme)) {\r\n                    try {\r\n                        InputStream attachment = getActivity().getContentResolver().openInputStream(u);\r\n                        if (attachment != null) {\r\n                            String name = getContentName(getActivity().getContentResolver(), u);\r\n                            if (name != null) {\r\n                                String filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                if(filePath.startsWith(\"file:\")) {\r\n                                    filePath = filePath.substring(5);\r\n                                }\r\n                                File f = new File(filePath);\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = attachment.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                attachment.close();\r\n                                setAppArg(addFile(filePath));\r\n                                return addFile(filePath);\r\n                            }\r\n                        }\r\n                    } catch (FileNotFoundException e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    }\r\n                } else {\r\n\r\n                    /*\r\n                    // Why do we need this special case?  u.toString()\r\n                    // will include the full URL including query string.\r\n                    // This special case causes urls like myscheme://part1/part2\r\n                    // to only return \"/part2\" which is obviously problematic and\r\n                    // is inconsistent with iOS.  Is this special case necessary\r\n                    // in some versions of Android?\r\n                    String encodedPath = u.getEncodedPath();\r\n                    if (encodedPath != null && encodedPath.length() > 0) {\r\n                        String query = u.getQuery();\r\n                        if(query != null && query.length() > 0){\r\n                            encodedPath += \"?\" + query;\r\n                        }\r\n                        setAppArg(encodedPath);\r\n                        return encodedPath;\r\n                    }\r\n                    */\r\n                    if (sharedText != null) {\r\n                        setAppArg(sharedText);\r\n                        return sharedText;\r\n                    } else {\r\n                        setAppArg(u.toString());\r\n                        return u.toString();\r\n                    }\r\n\r\n                }\r\n            } else if (sharedText != null) {\r\n                setAppArg(sharedText);\r\n                return sharedText;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getProperty(String key, String defaultValue) {\r\n        if(key.equalsIgnoreCase(\"cn1_push_prefix\")) {\r\n            /*if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get notifications\")){\r\n                return \"\";\r\n            }*/\r\n            boolean has = hasAndroidMarket();\r\n            if(has) {\r\n                return \"gcm\";\r\n            }\r\n            return defaultValue;\r\n        }\r\n        if (\"OS\".equals(key)) {\r\n            return \"Android\";\r\n        }\r\n        if (\"androidId\".equals(key)) {\r\n            return Settings.Secure.getString(getContext().getContentResolver(), Settings.Secure.ANDROID_ID);\r\n        }\r\n\r\n        /*if (\"cellId\".equals(key)) {\r\n            try {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the cellId\")){\r\n                    return defaultValue;\r\n                }\r\n                String serviceName = Context.TELEPHONY_SERVICE;\r\n                TelephonyManager telephonyManager = (TelephonyManager) getContext().getSystemService(serviceName);\r\n                int cellId = ((GsmCellLocation) telephonyManager.getCellLocation()).getCid();\r\n                return \"\" + cellId;\r\n            } catch (Throwable t) {\r\n                return defaultValue;\r\n            }\r\n        }*/\r\n        if (\"AppName\".equals(key)) {\r\n\r\n            final PackageManager pm = getContext().getPackageManager();\r\n            ApplicationInfo ai;\r\n            try {\r\n                ai = pm.getApplicationInfo(getContext().getPackageName(), 0);\r\n            } catch (NameNotFoundException e) {\r\n                ai = null;\r\n            }\r\n            String applicationName = (String) (ai != null ? pm.getApplicationLabel(ai) : null);\r\n            if(applicationName == null){\r\n                return defaultValue;\r\n            }\r\n            return applicationName;\r\n        }\r\n        if (\"AppVersion\".equals(key)) {\r\n            try {\r\n                PackageInfo i = getContext().getPackageManager().getPackageInfo(getContext().getApplicationInfo().packageName, 0);\r\n                return i.versionName;\r\n            } catch (NameNotFoundException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            return defaultValue;\r\n        }\r\n        if (\"Platform\".equals(key)) {\r\n            String p = System.getProperty(\"platform\");\r\n            if(p == null) {\r\n                return defaultValue;\r\n            }\r\n            return p;\r\n        }\r\n        if (\"User-Agent\".equals(key)) {\r\n            String ua = getUserAgent();\r\n            if(ua == null) {\r\n                return defaultValue;\r\n            }\r\n            return ua;\r\n        }\r\n        if(\"OSVer\".equals(key)) {\r\n            return \"\" + android.os.Build.VERSION.RELEASE;\r\n        }\r\n        if(\"DeviceName\".equals(key)) {\r\n            return \"\" + android.os.Build.MODEL;\r\n        }\r\n        /*try {\r\n            if (\"IMEI\".equals(key) || \"UDID\".equals(key)) {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the device ID\")){\r\n                    return \"\";\r\n                }\r\n                TelephonyManager tm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\r\n                String imei = null;\r\n                if (tm!=null && tm.getDeviceId() != null) {\r\n                    // for phones or 3g tablets\r\n                    imei = tm.getDeviceId();\r\n                } else {\r\n                    try {\r\n                        imei = Secure.getString(getContext().getContentResolver(), Secure.ANDROID_ID);\r\n                    } catch(Throwable t) {\r\n                        com.codename1.io.Log.e(t);\r\n                    }\r\n                }\r\n                return imei;\r\n            }\r\n            if (\"MSISDN\".equals(key)) {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the device ID\")){\r\n                    return \"\";\r\n                }\r\n                TelephonyManager tm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\r\n                return tm.getLine1Number();\r\n            }\r\n        } catch(Throwable t) {\r\n            // will be caused by no permissions.\r\n            return defaultValue;\r\n        }*/\r\n\r\n        if (getActivity() != null) {\r\n            android.content.Intent intent = getActivity().getIntent();\r\n            if(intent != null){\r\n                Bundle extras = intent.getExtras();\r\n                if (extras != null) {\r\n                    String value = extras.getString(key);\r\n                    if(value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!key.startsWith(\"android.permission\")) {\r\n            //these keys/values are from the Application Resources (strings values)\r\n            try {\r\n                int id = getContext().getResources().getIdentifier(key, \"string\", getContext().getApplicationInfo().packageName);\r\n                if (id != 0) {\r\n                    String val = getContext().getResources().getString(id);\r\n                    return val;\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        return System.getProperty(key, super.getProperty(key, defaultValue));\r\n    }\r\n\r\n    private String getContentName(ContentResolver resolver, Uri uri) {\r\n        Cursor cursor = resolver.query(uri, null, null, null, null);\r\n        cursor.moveToFirst();\r\n        int nameIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DISPLAY_NAME);\r\n        if (nameIndex >= 0) {\r\n            String name = cursor.getString(nameIndex);\r\n            cursor.close();\r\n            return name;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private String getUserAgent() {\r\n        try {\r\n            String userAgent = System.getProperty(\"http.agent\");\r\n            if(userAgent != null){\r\n                return userAgent;\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n        if (getActivity() == null) {\r\n            return \"Android-CN1\";\r\n        }\r\n        try {\r\n            Constructor<WebSettings> constructor = WebSettings.class.getDeclaredConstructor(Context.class, WebView.class);\r\n            constructor.setAccessible(true);\r\n            try {\r\n                WebSettings settings = constructor.newInstance(getActivity(), null);\r\n                return settings.getUserAgentString();\r\n            } finally {\r\n                constructor.setAccessible(false);\r\n            }\r\n        } catch (Exception e) {\r\n            final StringBuffer ua = new StringBuffer();\r\n            if (Thread.currentThread().getName().equalsIgnoreCase(\"main\")) {\r\n                WebView m_webview = new WebView(getActivity());\r\n                ua.append(m_webview.getSettings().getUserAgentString());\r\n                m_webview.destroy();\r\n            } else {\r\n                final boolean[] flag = new boolean[1];\r\n                Thread thread = new Thread() {\r\n                    public void run() {\r\n                        Looper.prepare();\r\n                        WebView m_webview = new WebView(getActivity());\r\n                        ua.append(m_webview.getSettings().getUserAgentString());\r\n                        m_webview.destroy();\r\n                        Looper.loop();\r\n                        flag[0] = true;\r\n                        synchronized (flag) {\r\n                            flag.notify();\r\n                        }\r\n                    }\r\n                };\r\n                thread.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n                thread.start();\r\n                while (!flag[0]) {\r\n                    synchronized (flag) {\r\n                        try {\r\n                            flag.wait(100);\r\n                        } catch (InterruptedException ex) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ua.toString();\r\n        }\r\n    }\r\n\r\n    private String getMimeType(String url){\r\n        String type = null;\r\n        String extension = MimeTypeMap.getFileExtensionFromUrl(url);\r\n        if (extension != null) {\r\n            MimeTypeMap mime = MimeTypeMap.getSingleton();\r\n\r\n            type = mime.getMimeTypeFromExtension(extension);\r\n        }\r\n        if (type == null) {\r\n            try {\r\n                Uri uri = Uri.parse(url);\r\n                ContentResolver cr = getContext().getContentResolver();\r\n                type = cr.getType(uri);\r\n            } catch (Throwable t) {\r\n                t.printStackTrace();\r\n            }\r\n        }\r\n        return type;\r\n    }\r\n\r\n    public static void copy(File src, File dst) throws IOException {\r\n        InputStream in = new FileInputStream(src);\r\n        try {\r\n            OutputStream out = new FileOutputStream(dst);\r\n            try {\r\n                // Transfer bytes from in to out\r\n                byte[] buf = new byte[8096];\r\n                int len;\r\n                while ((len = in.read(buf)) > 0) {\r\n                    out.write(buf, 0, len);\r\n                }\r\n            } finally {\r\n                out.close();\r\n            }\r\n        } finally {\r\n            in.close();\r\n        }\r\n    }\r\n\r\n    private static File makeTempCacheCopy(File file) throws IOException {\r\n        File cacheDir = new File(getContext().getCacheDir(), \"intent_files\");\r\n\r\n        // Create the storage directory if it does not exist\r\n        if (!cacheDir.exists()) {\r\n            if (!cacheDir.mkdirs()) {\r\n                Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        File copy = new File(cacheDir, \"tmp-\"+System.currentTimeMillis()+file.getName());\r\n        copy(file, copy);\r\n        return copy;\r\n\r\n    }\r\n\r\n\r\n\r\n    private Intent createIntentForURL(String url) {\r\n        Intent intent;\r\n        Uri uri;\r\n        try {\r\n            if (url.startsWith(\"intent\")) {\r\n                intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);\r\n            } else {\r\n                if(url.startsWith(\"/\") || url.startsWith(\"file:\")) {\r\n                    if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to open the file\")){\r\n                        return null;\r\n                    }\r\n                }\r\n                intent = new Intent();\r\n                intent.setAction(Intent.ACTION_VIEW);\r\n                if (url.startsWith(\"/\")) {\r\n                    File f = new File(url);\r\n                    Uri furi = null;\r\n                    try {\r\n                        furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                    } catch (Exception ex) {\r\n                        f = makeTempCacheCopy(f);\r\n                        furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                    }\r\n        \r\n        \r\n                    if (Build.VERSION.SDK_INT < 21) {\r\n                        List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n                        for (ResolveInfo resolveInfo : resInfoList) {\r\n                            String packageName = resolveInfo.activityInfo.packageName;\r\n                            getContext().grantUriPermission(packageName, furi, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                        }\r\n                    }\r\n                    \r\n                    uri = furi;\r\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                }else{\r\n\r\n                    if (url.startsWith(\"file:\")) {\r\n                        File f = new File(removeFilePrefix(url));\r\n                        System.out.println(\"File size: \"+f.length());\r\n\r\n                        Uri furi = null;\r\n                        try {\r\n                            furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                        } catch (Exception ex) {\r\n                            f = makeTempCacheCopy(f);\r\n                            furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                        }\r\n\r\n\r\n                        if (Build.VERSION.SDK_INT < 21) {\r\n                            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n                            for (ResolveInfo resolveInfo : resInfoList) {\r\n                                String packageName = resolveInfo.activityInfo.packageName;\r\n                                getContext().grantUriPermission(packageName, furi, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                            }\r\n                        }\r\n                        uri = furi;\r\n                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n\r\n\r\n                    } else {\r\n                        uri = Uri.parse(url);\r\n                    }\r\n                }\r\n                String mimeType = getMimeType(url);\r\n                if(mimeType != null){\r\n                    intent.setDataAndType(uri, mimeType);\r\n                }else{\r\n                    intent.setData(uri);\r\n                }\r\n            }\r\n\r\n            return intent;\r\n        } catch(Exception err) {\r\n            com.codename1.io.Log.e(err);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Boolean canExecute(String url) {\r\n        try {\r\n            Intent it = createIntentForURL(url);\r\n            if(it == null) {\r\n                return false;\r\n            }\r\n            final PackageManager mgr = getContext().getPackageManager();\r\n            List<ResolveInfo> list = mgr.queryIntentActivities(it, PackageManager.MATCH_DEFAULT_ONLY);\r\n            return list.size() > 0;\r\n        } catch(Exception err) {\r\n            com.codename1.io.Log.e(err);\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    public void execute(String url, ActionListener response) {\r\n        if (response != null) {\r\n            callback = new EventDispatcher();\r\n            callback.addListener(response);\r\n        }\r\n\r\n        try {\r\n            Intent intent = createIntentForURL(url);\r\n            if(intent == null) {\r\n                return;\r\n            }\r\n            if(response != null && getActivity() != null){\r\n                getActivity().startActivityForResult(intent, IntentResultListener.URI_SCHEME);\r\n            }else {\r\n                getContext().startActivity(intent);\r\n            }\r\n            return;\r\n        } catch (Exception ex) {\r\n            com.codename1.io.Log.e(ex);\r\n        }\r\n\r\n        try {\r\n            if(editInProgress()) {\r\n                stopEditing(true);\r\n            }\r\n            getContext().startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public void execute(String url) {\r\n        execute(url, null);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void playBuiltinSound(String soundIdentifier) {\r\n        if (getActivity() != null && Display.SOUND_TYPE_BUTTON_PRESS == soundIdentifier) {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    if (myView != null) {\r\n                        myView.getAndroidView().playSoundEffect(AudioManager.FX_KEY_CLICK);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    protected void playNativeBuiltinSound(Object data) {\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isBuiltinSoundAvailable(String soundIdentifier) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public boolean isNativeVideoPlayerControlsIncluded() {\r\n        return true;\r\n    }\r\n    \r\n    private static final int STATE_PAUSED = 0;\r\n    private static final int STATE_PLAYING = 1;\r\n\r\n    private int mCurrentState;\r\n\r\n    private MediaBrowserCompat mMediaBrowserCompat;\r\n    private android.support.v4.media.session.MediaControllerCompat mMediaControllerCompat;\r\n    \r\n    private android.support.v4.media.session.MediaControllerCompat.Callback mMediaControllerCompatCallback = new android.support.v4.media.session.MediaControllerCompat.Callback() {\r\n\r\n        @Override\r\n        public void onPlaybackStateChanged(PlaybackStateCompat state) {\r\n            super.onPlaybackStateChanged(state);\r\n            if( state == null ) {\r\n                return;\r\n            }\r\n\r\n            switch( state.getState() ) {\r\n                case PlaybackStateCompat.STATE_PLAYING: {\r\n                    mCurrentState = STATE_PLAYING;\r\n                    break;\r\n                }\r\n                case PlaybackStateCompat.STATE_PAUSED: {\r\n                    mCurrentState = STATE_PAUSED;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    private MediaBrowserCompat.ConnectionCallback mMediaBrowserCompatConnectionCallback = new MediaBrowserCompat.ConnectionCallback() {\r\n\r\n        @Override\r\n        public void onConnected() {\r\n            super.onConnected();\r\n            try {\r\n                mMediaControllerCompat = new MediaControllerCompat(getActivity(), mMediaBrowserCompat.getSessionToken());\r\n                mMediaControllerCompat.registerCallback(mMediaControllerCompatCallback);\r\n                MediaControllerCompat.setMediaController(getActivity(), mMediaControllerCompat);\r\n                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().play();\r\n\r\n            } catch( RemoteException e ) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    };\r\n\r\n    //BackgroundAudioService remoteControl;\r\n\r\n    @Override\r\n    public void startRemoteControl() {\r\n        super.startRemoteControl();\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                mMediaBrowserCompat = new MediaBrowserCompat(getActivity(), new ComponentName(getActivity(), BackgroundAudioService.class),\r\n                mMediaBrowserCompatConnectionCallback, getActivity().getIntent().getExtras());\r\n\r\n                mMediaBrowserCompat.connect();\r\n                AndroidNativeUtil.addLifecycleListener(new LifecycleListener() {\r\n                    @Override\r\n                    public void onCreate(Bundle savedInstanceState) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onResume() {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onPause() {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onDestroy() {\r\n                        if (mMediaBrowserCompat != null) {\r\n                            if( MediaControllerCompat.getMediaController(getActivity()).getPlaybackState().getState() == PlaybackStateCompat.STATE_PLAYING ) {\r\n                                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().pause();\r\n                            }\r\n\r\n                            mMediaBrowserCompat.disconnect();\r\n                            mMediaBrowserCompat = null;\r\n                        }\r\n                    }\r\n\r\n                    @Override\r\n                    public void onSaveInstanceState(Bundle b) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onLowMemory() {\r\n\r\n                    }\r\n                });\r\n            }\r\n            \r\n        });\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void stopRemoteControl() {\r\n        super.stopRemoteControl(); \r\n        if (mMediaBrowserCompat != null) {\r\n            if( MediaControllerCompat.getMediaController(getActivity()).getPlaybackState().getState() == PlaybackStateCompat.STATE_PLAYING ) {\r\n                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().pause();\r\n            }\r\n\r\n            mMediaBrowserCompat.disconnect();\r\n            mMediaBrowserCompat = null;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public AsyncResource<Media> createBackgroundMediaAsync(final String uri) {\r\n        final AsyncResource<Media> out = new AsyncResource<Media>();\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    out.complete(createBackgroundMedia(uri));\r\n                } catch (IOException ex) {\r\n                    out.error(ex);\r\n                }\r\n            }\r\n        }).start();\r\n\r\n        return out;\r\n    }\r\n\r\n    private int nextMediaId;\r\n    private int backgroundMediaCount;\r\n    private ServiceConnection backgroundMediaServiceConnection;\r\n    @Override\r\n    public Media createBackgroundMedia(final String uri) throws IOException {\r\n        int mediaId = nextMediaId++;\r\n        backgroundMediaCount++;\r\n\r\n        Intent serviceIntent = new Intent(getContext(), AudioService.class);\r\n        serviceIntent.putExtra(\"mediaLink\", uri);\r\n        serviceIntent.putExtra(\"mediaId\", mediaId);\r\n        if (background == null) {\r\n            ServiceConnection mConnection = new ServiceConnection() {\r\n\r\n                public void onServiceDisconnected(ComponentName name) {\r\n\r\n                    background = null;\r\n                    backgroundMediaServiceConnection = null;\r\n                }\r\n\r\n                public void onServiceConnected(ComponentName name, IBinder service) {\r\n                    AudioService.LocalBinder mLocalBinder = (AudioService.LocalBinder) service;\r\n                    AudioService svc = (AudioService)mLocalBinder.getService();\r\n                    background = svc;\r\n                }\r\n            };\r\n            backgroundMediaServiceConnection = mConnection;\r\n            boolean boundSuccess = getContext().bindService(serviceIntent, mConnection, getContext().BIND_AUTO_CREATE);\r\n            if (!boundSuccess) {\r\n                throw new RuntimeException(\"Failed to bind background media service for uri \"+uri);\r\n            }\r\n            ContextCompat.startForegroundService(getContext(), serviceIntent);\r\n            while (background == null) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        Util.sleep(200);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            ContextCompat.startForegroundService(getContext(), serviceIntent);\r\n        }\r\n\r\n        while (background.getMedia(mediaId) == null) {\r\n            Display.getInstance().invokeAndBlock(new Runnable() {\r\n                public void run() {\r\n                    Util.sleep(200);\r\n                }\r\n\r\n            });\r\n        }\r\n        Media ret = new MediaProxy(background.getMedia(mediaId)) {\r\n\r\n            \r\n            @Override\r\n            public void cleanup() {\r\n                super.cleanup();\r\n                if (--backgroundMediaCount <= 0) {\r\n                    if (backgroundMediaServiceConnection != null) {\r\n                        try {\r\n                            getContext().unbindService(backgroundMediaServiceConnection);\r\n                        } catch (IllegalArgumentException ex) {\r\n                            // This is thrown sometimes if the service has already been unbound\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        \r\n        return ret;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public Media createMedia(final String uri, boolean isVideo, final Runnable onCompletion) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        if(!uri.startsWith(FileSystemStorage.getInstance().getAppHomePath())) {\r\n            if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to play media\")){\r\n                return null;\r\n            }\r\n        }\r\n        if (uri.startsWith(\"file://\")) {\r\n            return createMedia(removeFilePrefix(uri), isVideo, onCompletion);\r\n        }\r\n        File file = null;\r\n        if (uri.indexOf(':') < 0) {\r\n            // use a file object to play to try and workaround this issue:\r\n            // http://code.google.com/p/android/issues/detail?id=4124\r\n            file = new File(uri);\r\n        }\r\n\r\n        Media retVal;\r\n\r\n        if (isVideo) {\r\n            final AndroidImplementation.Video[] video = new AndroidImplementation.Video[1];\r\n            final boolean[] flag = new boolean[1];\r\n            final File f = file;\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    VideoView v = new VideoView(getActivity());\r\n                    v.setZOrderMediaOverlay(true);\r\n                    if (f != null) {\r\n                        v.setVideoURI(Uri.fromFile(f));\r\n                    } else {\r\n                        v.setVideoURI(Uri.parse(uri));\r\n                    }\r\n                    video[0] = new AndroidImplementation.Video(v, getActivity(), onCompletion);\r\n                    flag[0] = true;\r\n                    synchronized (flag) {\r\n                        flag.notify();\r\n                    }\r\n                }\r\n            });\r\n            while (!flag[0]) {\r\n                synchronized (flag) {\r\n                    try {\r\n                        flag.wait(100);\r\n                    } catch (InterruptedException ex) {\r\n                    }\r\n                }\r\n            }\r\n            return video[0];\r\n        } else {\r\n            MediaPlayer player;\r\n            if (file != null) {\r\n                FileInputStream is = new FileInputStream(file);\r\n                player = new MediaPlayer();\r\n                player.setDataSource(is.getFD());\r\n                player.prepare();\r\n            } else {\r\n                player = MediaPlayer.create(getActivity(), Uri.parse(uri));\r\n            }\r\n            retVal = new Audio(getActivity(), player, null, onCompletion);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    @Override\r\n    public void addCompletionHandler(Media media, Runnable onCompletion) {\r\n        super.addCompletionHandler(media, onCompletion);\r\n        if (media instanceof Video) {\r\n            ((Video)media).addCompletionHandler(onCompletion);\r\n        } else if (media instanceof Audio) {\r\n            ((Audio)media).addCompletionHandler(onCompletion);\r\n        } else if (media instanceof MediaProxy) {\r\n            ((MediaProxy)media).addCompletionHandler(onCompletion);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void removeCompletionHandler(Media media, Runnable onCompletion) {\r\n        super.removeCompletionHandler(media, onCompletion);\r\n        if (media instanceof Video) {\r\n            ((Video)media).removeCompletionHandler(onCompletion);\r\n        } else if (media instanceof Audio) {\r\n            ((Audio)media).removeCompletionHandler(onCompletion);\r\n        } else if (media instanceof MediaProxy) {\r\n            ((MediaProxy)media).removeCompletionHandler(onCompletion);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public Media createMedia(InputStream stream, String mimeType, final Runnable onCompletion) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        /*if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to play media\")){\r\n            return null;\r\n        }*/\r\n        boolean isVideo = mimeType.contains(\"video\");\r\n\r\n        if (!isVideo && stream instanceof FileInputStream) {\r\n            MediaPlayer player = new MediaPlayer();\r\n            player.setDataSource(((FileInputStream) stream).getFD());\r\n            player.prepare();\r\n            return new Audio(getActivity(), player, stream, onCompletion);\r\n        }\r\n        String extension = MimeTypeMap.getFileExtensionFromUrl(mimeType);\r\n        final File temp = File.createTempFile(\"mtmp\", extension == null ? \"dat\" : extension);\r\n        temp.deleteOnExit();\r\n        OutputStream out = createFileOuputStream(temp);\r\n\r\n        byte buf[] = new byte[256];\r\n        int len = 0;\r\n        while ((len = stream.read(buf, 0, buf.length)) > -1) {\r\n            out.write(buf, 0, len);\r\n        }\r\n        out.close();\r\n        stream.close();\r\n\r\n        final Runnable finish = new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                if(onCompletion != null){\r\n                    Display.getInstance().callSerially(onCompletion);\r\n\r\n                    // makes sure the file is only deleted after the onCompletion was invoked\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            temp.delete();\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                temp.delete();\r\n            }\r\n        };\r\n\r\n        if (isVideo) {\r\n            final AndroidImplementation.Video[] retVal = new AndroidImplementation.Video[1];\r\n            final boolean[] flag = new boolean[1];\r\n\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    VideoView v = new VideoView(getActivity());\r\n                    v.setZOrderMediaOverlay(true);\r\n                    v.setVideoURI(Uri.fromFile(temp));\r\n                    retVal[0] = new AndroidImplementation.Video(v, getActivity(), finish);\r\n                    flag[0] = true;\r\n                    synchronized (flag) {\r\n                        flag.notify();\r\n                    }\r\n                }\r\n            });\r\n            while (!flag[0]) {\r\n                synchronized (flag) {\r\n                    try {\r\n                        flag.wait(100);\r\n                    } catch (InterruptedException ex) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            return retVal[0];\r\n        } else {\r\n            return createMedia(createFileInputStream(temp), mimeType, finish);\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {\r\n        return createMediaRecorder(builder.getPath(), builder.getMimeType(), builder.getSamplingRate(), builder.getBitRate(), builder.getAudioChannels(), 0, builder.isRedirectToAudioBuffer());\r\n    }\r\n\r\n    @Override\r\n    public Media createMediaRecorder(final String path, final String mimeType) throws IOException {\r\n        MediaRecorderBuilder builder = new MediaRecorderBuilder()\r\n                .path(path)\r\n                .mimeType(mimeType);\r\n        return createMediaRecorder(builder);\r\n    }\r\n    \r\n   \r\n    \r\n    private  Media createMediaRecorder(final String path, final String mimeType, final int sampleRate, final int bitRate, final int audioChannels, final int maxDuration, final boolean redirectToAudioBuffer) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        if(!checkForPermission(Manifest.permission.RECORD_AUDIO, \"This is required to record audio\")){\r\n            return null;\r\n        }\r\n        final Media[] record = new Media[1];\r\n        final IOException[] error = new IOException[1];\r\n\r\n        final Object lock = new Object();\r\n        synchronized (lock) {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    synchronized (lock) {\r\n                        if (redirectToAudioBuffer) {\r\n                            final int channelConfig =audioChannels == 1 ? android.media.AudioFormat.CHANNEL_IN_MONO\r\n                                            : audioChannels == 2 ? android.media.AudioFormat.CHANNEL_IN_STEREO\r\n                                                    : android.media.AudioFormat.CHANNEL_IN_MONO;\r\n                            final AudioRecord recorder = new AudioRecord(\r\n                                    MediaRecorder.AudioSource.MIC, \r\n                                    sampleRate, \r\n                                    channelConfig,\r\n                                    AudioFormat.ENCODING_PCM_16BIT,\r\n                                    AudioRecord.getMinBufferSize(sampleRate, channelConfig, AudioFormat.ENCODING_PCM_16BIT)\r\n                            );\r\n                            \r\n                            final com.codename1.media.AudioBuffer audioBuffer = com.codename1.media.MediaManager.getAudioBuffer(path, true, 64);\r\n                            final boolean[] stop = new boolean[1];\r\n\r\n                            record[0] = new AbstractMedia() {\r\n                                private int lastTime;\r\n                                private boolean isRecording;\r\n                                @Override\r\n                                protected void playImpl() {\r\n                                    if (isRecording) {\r\n                                        return;\r\n                                    }\r\n                                    isRecording = true;\r\n                                    recorder.startRecording();\r\n                                    fireMediaStateChange(State.Playing);\r\n                                    new Thread(new Runnable() {\r\n                                        public void run() {\r\n                                            float[] audioData = new float[audioBuffer.getMaxSize()];\r\n                                            short[] buffer = new short[AudioRecord.getMinBufferSize(recorder.getSampleRate(), recorder.getChannelCount(), AudioFormat.ENCODING_PCM_16BIT)];\r\n                                            int read = -1;\r\n                                            int index = 0;\r\n                                            \r\n                                            while (isRecording && (read = recorder.read(buffer, 0, buffer.length)) >= 0) {\r\n                                                if (read > 0) {\r\n                                                    for (int i=0; i<read; i++) {\r\n                                                        audioData[index] = ((float)buffer[i]) / 0x8000;\r\n                                                        index++;\r\n                                                        if (index >= audioData.length) {\r\n                                                            audioBuffer.copyFrom(sampleRate, audioChannels, audioData, 0, index);\r\n                                                            index = 0;\r\n                                                        }\r\n                                                    }\r\n                                                    if (index > 0) {\r\n                                                        audioBuffer.copyFrom(sampleRate, audioChannels, audioData, 0, index);\r\n                                                        index = 0;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n\r\n                                    }).start();\r\n                                }\r\n\r\n                                @Override\r\n                                protected void pauseImpl() {\r\n                                    if (!isRecording) {\r\n                                        return;\r\n                                    }\r\n                                    isRecording = false;\r\n                                    recorder.stop();\r\n\r\n\r\n                                    fireMediaStateChange(State.Paused);\r\n                                }\r\n\r\n                                @Override\r\n                                public void prepare() {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public void cleanup() {\r\n                                    pauseImpl();\r\n                                    recorder.release();\r\n                                    com.codename1.media.MediaManager.releaseAudioBuffer(path);\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getTime() {\r\n                                    if (isRecording) {\r\n                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\r\n                                            AudioTimestamp ts = new AudioTimestamp();\r\n                                            recorder.getTimestamp(ts, AudioTimestamp.TIMEBASE_MONOTONIC);\r\n                                            lastTime = (int) (ts.framePosition / ((float) sampleRate / 1000f));\r\n                                        }\r\n                                    }\r\n                                    return lastTime;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setTime(int time) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getDuration() {\r\n                                    return getTime();\r\n                                }\r\n\r\n                                @Override\r\n                                public void setVolume(int vol) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getVolume() {\r\n                                    return 0;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isPlaying() {\r\n                                    return recorder.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING;\r\n                                }\r\n\r\n                                @Override\r\n                                public Component getVideoComponent() {\r\n                                    return null;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isVideo() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isFullScreen() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setFullScreen(boolean fullScreen) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public void setNativePlayerMode(boolean nativePlayer) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isNativePlayerMode() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setVariable(String key, Object value) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public Object getVariable(String key) {\r\n                                    return null;\r\n                                }\r\n                                \r\n                            };\r\n                            lock.notify();\r\n                        } else {\r\n                            MediaRecorder recorder = new MediaRecorder();\r\n                            recorder.setAudioSource(MediaRecorder.AudioSource.MIC);\r\n                        \r\n                            if(mimeType.contains(\"amr\")){\r\n                            recorder.setOutputFormat(MediaRecorder.OutputFormat.AMR_NB);\r\n                            recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\r\n                            }else{\r\n                                recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\r\n                                recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\r\n                                recorder.setAudioSamplingRate(sampleRate);\r\n                                recorder.setAudioEncodingBitRate(bitRate);\r\n                            }\r\n                            if (audioChannels > 0) {\r\n                                recorder.setAudioChannels(audioChannels);\r\n                            }\r\n                            if (maxDuration > 0) {\r\n                                recorder.setMaxDuration(maxDuration);\r\n                            }\r\n                            recorder.setOutputFile(removeFilePrefix(path));\r\n                            try {\r\n                                recorder.prepare();\r\n                                record[0] = new AndroidRecorder(recorder);\r\n                            } catch (IllegalStateException ex) {\r\n                                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                            } catch (IOException ex) {\r\n                                error[0] = ex;\r\n                            } finally {\r\n                                lock.notify();\r\n                            }\r\n                        }\r\n                        \r\n\r\n\r\n                    }\r\n                }\r\n            });\r\n\r\n            try {\r\n                lock.wait();\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n\r\n            if (error[0] != null) {\r\n                throw error[0];\r\n            }\r\n\r\n            return record[0];\r\n        }\r\n    }\r\n\r\n    public String [] getAvailableRecordingMimeTypes(){\r\n        // audio/aac and audio/mp4 result in the same thing\r\n        // AAC are wrapped in an mp4 container.\r\n        return new String[]{\"audio/amr\", \"audio/aac\", \"audio/mp4\"};\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object createSoftWeakRef(Object o) {\r\n        return new SoftReference(o);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object extractHardRef(Object o) {\r\n        SoftReference w = (SoftReference) o;\r\n        if (w != null) {\r\n            return w.get();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public PeerComponent createNativePeer(Object nativeComponent) {\r\n        if (!(nativeComponent instanceof View)) {\r\n            throw new IllegalArgumentException(nativeComponent.getClass().getName());\r\n        }\r\n        return new AndroidImplementation.AndroidPeer((View) nativeComponent);\r\n    }\r\n\r\n    private void blockNativeFocusAll(boolean block) {\r\n        synchronized (this.nativePeers) {\r\n            final int size = this.nativePeers.size();\r\n            for (int i = 0; i < size; i++) {\r\n                AndroidImplementation.AndroidPeer next = (AndroidImplementation.AndroidPeer) this.nativePeers.get(i);\r\n                next.blockNativeFocus(block);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void onFocusChange(View view, boolean bln) {\r\n\r\n        if (bln) {\r\n            /**\r\n             * whenever the base view receives focus we automatically block\r\n             * possible native subviews from gaining focus.\r\n             */\r\n            blockNativeFocusAll(true);\r\n            if (this.lastDirectionalKeyEventReceivedByWrapper != 0) {\r\n                /**\r\n                 * because we also consume any key event in the OnKeyListener of\r\n                 * the native wrappers, we have to simulate key events to make\r\n                 * Codename One move the focus to the next component.\r\n                 */\r\n                if (myView == null) {\r\n                    return;\r\n                }\r\n                if (!myView.getAndroidView().isInTouchMode()) {\r\n                    switch (lastDirectionalKeyEventReceivedByWrapper) {\r\n                        case AndroidImplementation.DROID_IMPL_KEY_LEFT:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_RIGHT:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_UP:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_DOWN:\r\n                            Display.getInstance().keyPressed(lastDirectionalKeyEventReceivedByWrapper);\r\n                            Display.getInstance().keyReleased(lastDirectionalKeyEventReceivedByWrapper);\r\n                            break;\r\n                        default:\r\n                            Log.d(\"Codename One\", \"unexpected keycode: \" + lastDirectionalKeyEventReceivedByWrapper);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    Log.d(\"Codename One\", \"base view gained focus but no key event to process.\");\r\n                }\r\n                lastDirectionalKeyEventReceivedByWrapper = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void edtIdle(boolean enter) {\r\n        super.edtIdle(enter);\r\n        if(enter) {\r\n            // check if we have peers waiting for resize...\r\n            if(myView instanceof AndroidAsyncView) {\r\n                ((AndroidAsyncView)myView).resizeViews();\r\n            }\r\n        }\r\n    }\r\n\r\n    static final Map<View,AndroidPeer> activePeers = new HashMap<View,AndroidPeer>();\r\n\r\n\r\n    /**\r\n     * wrapper component that capsules a native view object in a Codename One\r\n     * component. this involves A LOT of back and forth between the Codename One\r\n     * EDT and the Android UI thread.\r\n     *\r\n     *\r\n     * To use it you would:\r\n     *\r\n     * 1) create your native Android view(s). Make sure to work on the Android\r\n     * UI thread when constructing and modifying them. 2) create a Codename One\r\n     * peer component by calling:\r\n     *\r\n     * com.codename1.ui.PeerComponent.create(myAndroidView);\r\n     *\r\n     * 3) currently the view's size is not automatically calculated from the\r\n     * native view. so you should set the preferred size of the Codename One\r\n     * component manually.\r\n     *\r\n     *\r\n     */\r\n    class AndroidPeer extends PeerComponent {\r\n\r\n        private View v;\r\n        private AndroidImplementation.AndroidRelativeLayout layoutWrapper = null;\r\n        private int currentVisible = View.INVISIBLE;\r\n        private boolean lightweightMode;\r\n\r\n        public AndroidPeer(View vv) {\r\n            super(vv);\r\n            this.v = vv;\r\n            if(!superPeerMode) {\r\n                v.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),\r\n                        MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));\r\n            }\r\n        }\r\n\r\n        @Override\r\n        protected Image generatePeerImage() {\r\n            try {\r\n                Bitmap bmp = AndroidNativeUtil.renderViewOnBitmap(v, getWidth(), getHeight());\r\n                if(bmp == null) {\r\n                    return Image.createImage(5, 5);\r\n                }\r\n                Image image = new AndroidImplementation.NativeImage(bmp);\r\n                return image;\r\n            } catch(Throwable t) {\r\n                t.printStackTrace();\r\n                return Image.createImage(5, 5);\r\n            }\r\n        }\r\n\r\n        protected boolean shouldRenderPeerImage() {\r\n            return !superPeerMode && (lightweightMode || !isInitialized());\r\n        }\r\n\r\n        protected void setLightweightMode(boolean l) {\r\n            if(superPeerMode) {\r\n                if (l != lightweightMode) {\r\n                    lightweightMode = l;\r\n                    if (lightweightMode) {\r\n                        Image img = generatePeerImage();\r\n                        if (img != null) {\r\n                            peerImage = img;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return;\r\n            }\r\n            doSetVisibility(!l);\r\n            if (lightweightMode == l) {\r\n                return;\r\n            }\r\n            lightweightMode = l;\r\n        }\r\n\r\n        @Override\r\n        public void setVisible(boolean visible) {\r\n            super.setVisible(visible);\r\n            this.doSetVisibility(visible);\r\n        }\r\n\r\n        void doSetVisibility(final boolean visible) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    currentVisible = visible ? View.VISIBLE : View.INVISIBLE;\r\n                    v.setVisibility(currentVisible);\r\n                    if (visible) {\r\n                        v.bringToFront();\r\n                    }\r\n                }\r\n            });\r\n            if(visible){\r\n                layoutPeer();\r\n            }\r\n        }\r\n\r\n        private void doSetVisibilityInternal(final boolean visible) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    currentVisible = visible ? View.VISIBLE : View.INVISIBLE;\r\n                    v.setVisibility(currentVisible);\r\n                    if (visible) {\r\n                        v.bringToFront();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        protected void deinitialize() {\r\n            if(!superPeerMode) {\r\n                Image i = generatePeerImage();\r\n                setPeerImage(i);\r\n                super.deinitialize();\r\n                synchronized (nativePeers) {\r\n                    nativePeers.remove(this);\r\n                }\r\n                deinit();\r\n            }else{\r\n                Image img = generatePeerImage();\r\n                if (img != null) {\r\n                    peerImage = img;\r\n                }\r\n\r\n                if(myView instanceof AndroidAsyncView){\r\n                    ((AndroidAsyncView)myView).removePeerView(v);\r\n                }\r\n                super.deinitialize();\r\n            }\r\n        }\r\n\r\n        public void deinit(){\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (peerImage == null) {\r\n                peerImage = generatePeerImage();\r\n            }\r\n            final boolean [] removed = new boolean[1];\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        if (layoutWrapper != null && AndroidImplementation.this.relativeLayout != null) {\r\n                            AndroidImplementation.this.relativeLayout.removeView(layoutWrapper);\r\n                            AndroidImplementation.this.relativeLayout.requestLayout();\r\n                            layoutWrapper = null;\r\n                        }\r\n                    } finally {\r\n                        removed[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!removed[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    public void run() {\r\n                        if (!removed[0]) {\r\n                            try {\r\n                                Thread.sleep(5);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        protected void initComponent() {\r\n            super.initComponent();\r\n            if(!superPeerMode) {\r\n                synchronized (nativePeers) {\r\n                    nativePeers.add(this);\r\n                }\r\n                init();\r\n                setPeerImage(null);\r\n            }\r\n        }\r\n\r\n        public void init(){\r\n            if(superPeerMode || getActivity() == null) {\r\n                return;\r\n            }\r\n            runOnUiThreadAndBlock(new Runnable() {\r\n                public void run() {\r\n                    if (layoutWrapper == null) {\r\n                        /**\r\n                         * wrap the native item in a layout that we can move\r\n                         * around on the surface view as we like.\r\n                         */\r\n                        layoutWrapper = new AndroidImplementation.AndroidRelativeLayout(activity, AndroidImplementation.AndroidPeer.this, v);\r\n                        layoutWrapper.setBackgroundDrawable(null);\r\n                        v.setVisibility(currentVisible);\r\n                        v.setFocusable(AndroidImplementation.AndroidPeer.this.isFocusable());\r\n                        v.setFocusableInTouchMode(true);\r\n                        ArrayList<View> viewList = new ArrayList<View>();\r\n                        viewList.add(layoutWrapper);\r\n                        v.addFocusables(viewList, View.FOCUS_DOWN);\r\n                        v.addFocusables(viewList, View.FOCUS_UP);\r\n                        v.addFocusables(viewList, View.FOCUS_LEFT);\r\n                        v.addFocusables(viewList, View.FOCUS_RIGHT);\r\n                        if (v.isFocusable() || v.isFocusableInTouchMode()) {\r\n                            if (AndroidImplementation.AndroidPeer.super.hasFocus()) {\r\n                                AndroidImplementation.this.blockNativeFocusAll(true);\r\n                                blockNativeFocus(false);\r\n                                if (!v.hasFocus()) {\r\n                                    v.requestFocus();\r\n                                }\r\n\r\n                            } else {\r\n                                blockNativeFocus(true);\r\n                            }\r\n                            layoutWrapper.setOnKeyListener(new View.OnKeyListener() {\r\n                                public boolean onKey(View view, int i, KeyEvent ke) {\r\n                                    lastDirectionalKeyEventReceivedByWrapper = CodenameOneView.internalKeyCodeTranslate(ke.getKeyCode());\r\n\r\n                                    // move focus back to base view.\r\n                                    if (AndroidImplementation.this.myView == null) return false;\r\n                                    AndroidImplementation.this.myView.getAndroidView().requestFocus();\r\n\r\n                                    /**\r\n                                     * if the wrapper has focus, then only because\r\n                                     * the wrapped native component just lost focus.\r\n                                     * we consume whatever key events we receive,\r\n                                     * just to make sure no half press/release\r\n                                     * sequence reaches the base view (and therefore\r\n                                     * Codename One).\r\n                                     */\r\n                                    return true;\r\n                                }\r\n                            });\r\n                            layoutWrapper.setOnFocusChangeListener(new View.OnFocusChangeListener() {\r\n                                public void onFocusChange(View view, boolean bln) {\r\n                                    Log.d(\"Codename One\", \"on focus change. \" + view.toString() + \" focus:\" + bln + \" touchmode: \" + v.isInTouchMode());\r\n                                }\r\n                            });\r\n                            layoutWrapper.setOnTouchListener(new View.OnTouchListener() {\r\n                                public boolean onTouch(View v, MotionEvent me) {\r\n                                    if (myView == null) return false;\r\n                                    return myView.getAndroidView().onTouchEvent(me);\r\n                                }\r\n                            });\r\n                        }\r\n                        if(AndroidImplementation.this.relativeLayout != null){\r\n                            // not sure why this happens but we got an exception where add view was called with\r\n                            // a layout that was already added...\r\n                            if(layoutWrapper.getParent() != null) {\r\n                                ((ViewGroup)layoutWrapper.getParent()).removeView(layoutWrapper);\r\n                            }\r\n                            AndroidImplementation.this.relativeLayout.addView(layoutWrapper);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        private Image peerImage;\r\n        public void paint(final Graphics g) {\r\n            if(superPeerMode) {\r\n                Object nativeGraphics = com.codename1.ui.Accessor.getNativeGraphics(g);\r\n\r\n                Object o = v.getLayoutParams();\r\n                AndroidAsyncView.LayoutParams lp;\r\n                if(o instanceof AndroidAsyncView.LayoutParams) {\r\n                    lp = (AndroidAsyncView.LayoutParams) o;\r\n                    if (lp == null) {\r\n                        lp = new AndroidAsyncView.LayoutParams(\r\n                                getX() + g.getTranslateX(),\r\n                                getY() + g.getTranslateY(),\r\n                                getWidth(),\r\n                                getHeight(), AndroidPeer.this);\r\n                        final AndroidAsyncView.LayoutParams finalLp = lp;\r\n                        activity.runOnUiThread(new Runnable() {\r\n                            @Override\r\n                            public void run() {\r\n                                v.setLayoutParams(finalLp);\r\n                            }\r\n                        });\r\n                        lp.dirty = true;\r\n                    } else {\r\n                        int x = getX() + g.getTranslateX();\r\n                        int y = getY() + g.getTranslateY();\r\n                        int w = getWidth();\r\n                        int h = getHeight();\r\n                        if (x != lp.x || y != lp.y || w != lp.w || h != lp.h) {\r\n                            lp.dirty = true;\r\n                            lp.x = x;\r\n                            lp.y = y;\r\n                            lp.w = w;\r\n                            lp.h = h;\r\n                        }\r\n                    }\r\n                } else {\r\n                    final AndroidAsyncView.LayoutParams finalLp = new AndroidAsyncView.LayoutParams(\r\n                            getX() + g.getTranslateX(),\r\n                            getY() + g.getTranslateY(),\r\n                            getWidth(),\r\n                            getHeight(), AndroidPeer.this);\r\n                    activity.runOnUiThread(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            v.setLayoutParams(finalLp);\r\n                        }\r\n                    });\r\n                    finalLp.dirty = true;\r\n                    lp = finalLp;\r\n                }\r\n\r\n                // this is a mutable image or side menu etc. where the peer is drawn on a different form...\r\n                // Special case...\r\n                if(nativeGraphics.getClass() == AndroidGraphics.class) {\r\n                    if(peerImage == null) {\r\n                        peerImage = generatePeerImage();\r\n                    }\r\n                    //systemOut(\"Drawing native image\");\r\n                    g.drawImage(peerImage, getX(), getY());\r\n                    return;\r\n                }\r\n                synchronized(activePeers) {\r\n                    activePeers.put(v, this);\r\n                }\r\n                ((AndroidGraphics) nativeGraphics).drawView(v, lp);\r\n                if (lightweightMode && peerImage != null) {\r\n                    g.drawImage(peerImage, getX(), getY(), getWidth(), getHeight());\r\n                }\r\n            } else {\r\n                super.paint(g);\r\n            }\r\n        }\r\n\r\n        boolean _initialized() {\r\n            return isInitialized();\r\n        }\r\n\r\n        @Override\r\n        protected void onPositionSizeChange() {\r\n            if(!superPeerMode) {\r\n                Form f = getComponentForm();\r\n                if (v.getVisibility() == View.INVISIBLE\r\n                        && f != null\r\n                        && Display.getInstance().getCurrent() == f) {\r\n                    doSetVisibilityInternal(true);\r\n                    return;\r\n                }\r\n                layoutPeer();\r\n            }\r\n        }\r\n\r\n        protected void layoutPeer(){\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if(!superPeerMode) {\r\n                // called by Codename One EDT to position the native component.\r\n                activity.runOnUiThread(new Runnable() {\r\n                    public void run() {\r\n                        if (layoutWrapper != null) {\r\n                            if (v.getVisibility() == View.VISIBLE) {\r\n\r\n                                RelativeLayout.LayoutParams layoutParams = layoutWrapper.createMyLayoutParams(\r\n                                        AndroidImplementation.AndroidPeer.this.getAbsoluteX(),\r\n                                        AndroidImplementation.AndroidPeer.this.getAbsoluteY(),\r\n                                        AndroidImplementation.AndroidPeer.this.getWidth(),\r\n                                        AndroidImplementation.AndroidPeer.this.getHeight());\r\n                                layoutWrapper.setLayoutParams(layoutParams);\r\n                                if (AndroidImplementation.this.relativeLayout != null) {\r\n                                    AndroidImplementation.this.relativeLayout.requestLayout();\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        void blockNativeFocus(boolean block) {\r\n            if (layoutWrapper != null) {\r\n                layoutWrapper.setDescendantFocusability(block\r\n                        ? ViewGroup.FOCUS_BLOCK_DESCENDANTS : ViewGroup.FOCUS_AFTER_DESCENDANTS);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean isFocusable() {\r\n            // EDT\r\n            if (v != null) {\r\n                return v.isFocusableInTouchMode() || v.isFocusable();\r\n            } else {\r\n                return super.isFocusable();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setFocusable(final boolean focusable) {\r\n            // EDT\r\n            super.setFocusable(focusable);\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    v.setFocusable(focusable);\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void focusGained() {\r\n            Log.d(\"Codename One\", \"native focus gain\");\r\n            // EDT\r\n            super.focusGained();\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    // allow this one to gain focus\r\n                    blockNativeFocus(false);\r\n                    if (!v.hasFocus()) {\r\n                        if (v.isInTouchMode()) {\r\n                            v.requestFocusFromTouch();\r\n                        } else {\r\n                            v.requestFocus();\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void focusLost() {\r\n            Log.d(\"Codename One\", \"native focus loss\");\r\n            // EDT\r\n            super.focusLost();\r\n            if (layoutWrapper != null && getActivity() != null) {\r\n                getActivity().runOnUiThread(new Runnable() {\r\n                    public void run() {\r\n                        if(isInitialized()) {\r\n                            // request focus of the wrapper. that will trigger the\r\n                            // android focus listener and move focus back to the\r\n                            // base view.\r\n                            layoutWrapper.requestFocus();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        public void release() {\r\n            deinitialize();\r\n        }\r\n\r\n        @Override\r\n        protected Dimension calcPreferredSize() {\r\n            int w = 1;\r\n            int h = 1;\r\n            Drawable d = v.getBackground();\r\n            if (d != null) {\r\n                w = d.getMinimumWidth();\r\n                h = d.getMinimumHeight();\r\n            }\r\n            w = Math.max(v.getMeasuredWidth(), w);\r\n            h = Math.max(v.getMeasuredHeight(), h);\r\n            if (v instanceof TextView) {\r\n                TextView tv = (TextView)v;\r\n                w = (int) android.text.Layout.getDesiredWidth(((TextView) v).getText(), ((TextView) v).getPaint());\r\n                int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);\r\n                tv.measure(w, heightMeasureSpec);\r\n                h = (int)Math.max(h, tv.getMeasuredHeight());\r\n\r\n\r\n            }\r\n            return new Dimension(w, h);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * inner class that wraps the native components. this is a useful thingy to\r\n     * handle focus stuff and buffering.\r\n     */\r\n    class AndroidRelativeLayout extends RelativeLayout {\r\n\r\n        private AndroidImplementation.AndroidPeer peer;\r\n\r\n        public AndroidRelativeLayout(Context activity, AndroidImplementation.AndroidPeer peer, View v) {\r\n            super(activity);\r\n\r\n            this.peer = peer;\r\n            this.setLayoutParams(createMyLayoutParams(peer.getAbsoluteX(), peer.getAbsoluteY(),\r\n                    peer.getWidth(), peer.getHeight()));\r\n            if (v.getParent() != null) {\r\n                ((ViewGroup)v.getParent()).removeView(v);\r\n            }\r\n            this.addView(v, new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.FILL_PARENT,\r\n                    RelativeLayout.LayoutParams.FILL_PARENT));\r\n            this.setDrawingCacheEnabled(false);\r\n            this.setAlwaysDrawnWithCacheEnabled(false);\r\n            this.setFocusable(true);\r\n            this.setFocusableInTouchMode(false);\r\n            this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\r\n\r\n        }\r\n\r\n        /**\r\n         * create a layout parameter object that holds the native component's\r\n         * position.\r\n         *\r\n         * @return\r\n         */\r\n        private RelativeLayout.LayoutParams createMyLayoutParams(int x, int y, int width, int height) {\r\n            RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.WRAP_CONTENT,\r\n                    RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n            layoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);\r\n            layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);\r\n            layoutParams.width = width;\r\n            layoutParams.height = height;\r\n            layoutParams.leftMargin = x;\r\n            layoutParams.topMargin = y;\r\n            return layoutParams;\r\n        }\r\n\r\n        @Override\r\n        public boolean dispatchKeyEvent(KeyEvent event) {\r\n\r\n            int keycode = event.getKeyCode();\r\n            keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n            if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK) {\r\n                switch (event.getAction()) {\r\n                    case KeyEvent.ACTION_DOWN:\r\n                        Display.getInstance().keyPressed(keycode);\r\n                        break;\r\n                    case KeyEvent.ACTION_UP:\r\n                        Display.getInstance().keyReleased(keycode);\r\n                        break;\r\n                }\r\n                return true;\r\n            } else {\r\n                return super.dispatchKeyEvent(event);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private boolean testedNativeTheme;\r\n    private boolean nativeThemeAvailable;\r\n\r\n    public boolean hasNativeTheme() {\r\n        if (!testedNativeTheme) {\r\n            testedNativeTheme = true;\r\n            try {\r\n                InputStream is;\r\n                if (android.os.Build.VERSION.SDK_INT < 14 && !isTablet()) {\r\n                    is = getResourceAsStream(getClass(), \"/androidTheme.res\");\r\n                } else {\r\n                    is = getResourceAsStream(getClass(), \"/android_holo_light.res\");\r\n                }\r\n                nativeThemeAvailable = is != null;\r\n                if (is != null) {\r\n                    is.close();\r\n                }\r\n            } catch (IOException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        return nativeThemeAvailable;\r\n    }\r\n\r\n    /**\r\n     * Installs the native theme, this is only applicable if hasNativeTheme()\r\n     * returned true. Notice that this method might replace the\r\n     * DefaultLookAndFeel instance and the default transitions.\r\n     */\r\n    public void installNativeTheme() {\r\n        hasNativeTheme();\r\n        if (nativeThemeAvailable) {\r\n            try {\r\n                InputStream is;\r\n                if (android.os.Build.VERSION.SDK_INT < 14 && !isTablet() || Display.getInstance().getProperty(\"and.hololight\", \"false\").equals(\"true\")) {\r\n                    is = getResourceAsStream(getClass(), \"/androidTheme.res\");\r\n                } else {\r\n                    is = getResourceAsStream(getClass(), \"/android_holo_light.res\");\r\n                }\r\n                Resources r = Resources.open(is);\r\n                Hashtable h = r.getTheme(r.getThemeResourceNames()[0]);\r\n                h.put(\"@commandBehavior\", \"Native\");\r\n                UIManager.getInstance().setThemeProps(h);\r\n                is.close();\r\n                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_NATIVE);\r\n            } catch (IOException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean isNativeBrowserComponentSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setNativeBrowserScrollingEnabled(final PeerComponent browserPeer, final boolean e) {\r\n        super.setNativeBrowserScrollingEnabled(browserPeer, e);\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                AndroidBrowserComponent bc = (AndroidBrowserComponent)browserPeer;\r\n                bc.setScrollingEnabled(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void setPinchToZoomEnabled(final PeerComponent browserPeer, final boolean e) {\r\n        super.setPinchToZoomEnabled(browserPeer, e);\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                AndroidBrowserComponent bc = (AndroidBrowserComponent)browserPeer;\r\n                bc.setPinchZoomEnabled(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    public PeerComponent createBrowserComponent(final Object parent) {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        final AndroidImplementation.AndroidBrowserComponent[] bc = new AndroidImplementation.AndroidBrowserComponent[1];\r\n        final Throwable[] error = new Throwable[1];\r\n        final Object lock = new Object();\r\n\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n\r\n                synchronized (lock) {\r\n                    try {\r\n                        WebView wv = new WebView(getActivity()) {\r\n\r\n                            @Override\r\n                            public boolean dispatchKeyEvent(KeyEvent event) {\r\n\r\n                                int keycode = event.getKeyCode();\r\n                                keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n                                if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK || \r\n                                    (keycode == KeyEvent.KEYCODE_MENU && \r\n                                        Display.getInstance().getCommandBehavior() != Display.COMMAND_BEHAVIOR_NATIVE)) {\r\n                                    switch (event.getAction()) {\r\n                                        case KeyEvent.ACTION_DOWN:\r\n                                            Display.getInstance().keyPressed(keycode);\r\n                                            break;\r\n                                        case KeyEvent.ACTION_UP:\r\n                                            Display.getInstance().keyReleased(keycode);\r\n                                            break;\r\n                                    }\r\n                                    return true;\r\n                                } else {\r\n                                    if(Display.getInstance().getProperty(\r\n                                        \"android.propogateKeyEvents\", \"false\").\r\n                                            equalsIgnoreCase(\"true\") && \r\n                                        myView instanceof AndroidAsyncView) {\r\n                                        switch (event.getAction()) {\r\n                                            case KeyEvent.ACTION_DOWN:\r\n                                                Display.getInstance().keyPressed(keycode);\r\n                                                break;\r\n                                            case KeyEvent.ACTION_UP:\r\n                                                Display.getInstance().keyReleased(keycode);\r\n                                                break;\r\n                                        }\r\n                                        return true;\r\n                                    }                                    \r\n                                                                        \r\n                                    return super.dispatchKeyEvent(event);\r\n                                }\r\n                            }\r\n                        };\r\n                        wv.setOnTouchListener(new View.OnTouchListener() {\r\n\r\n                            @Override\r\n                            public boolean onTouch(View v, MotionEvent event) {\r\n                                switch (event.getAction()) {\r\n                                    case MotionEvent.ACTION_DOWN:\r\n                                    case MotionEvent.ACTION_UP:\r\n                                        if (!v.hasFocus()) {\r\n                                            v.requestFocus();\r\n                                        }\r\n                                        break;\r\n                                }\r\n                                return false;\r\n                            }\r\n                        });\r\n                        \r\n                        if (android.os.Build.VERSION.SDK_INT >= 19) {\r\n                            if (\"true\".equals(Display.getInstance().getProperty(\"android.webContentsDebuggingEnabled\", \"false\"))) {\r\n                                wv.setWebContentsDebuggingEnabled(true);\r\n                            }\r\n                        }\r\n                        wv.getSettings().setDomStorageEnabled(true);\r\n                        wv.getSettings().setAllowFileAccess(true);\r\n                        wv.getSettings().setAllowContentAccess(true);\r\n                        wv.requestFocus(View.FOCUS_DOWN);\r\n                        wv.setFocusableInTouchMode(true);\r\n                        if (android.os.Build.VERSION.SDK_INT >= 17) {\r\n                            wv.getSettings().setMediaPlaybackRequiresUserGesture(false);\r\n                        }\r\n                        bc[0] = new AndroidImplementation.AndroidBrowserComponent(wv, getActivity(), parent);\r\n                        lock.notify();\r\n                    } catch (Throwable t) {\r\n                        error[0] = t;\r\n                        lock.notify();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        while (bc[0] == null && error[0] == null) {\r\n            Display.getInstance().invokeAndBlock(new Runnable() {\r\n                public void run() {\r\n                    synchronized (lock) {\r\n                        if (bc[0] == null && error[0] == null) {\r\n                            try {\r\n                                lock.wait(20);\r\n                            } catch (InterruptedException ex) {\r\n                                ex.printStackTrace();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            });\r\n        }\r\n        if (error[0] != null) {\r\n            throw new RuntimeException(error[0]);\r\n        }\r\n        return bc[0];\r\n    }\r\n\r\n    public void setBrowserProperty(PeerComponent browserPeer, String key, Object value) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).setProperty(key, value);\r\n    }\r\n\r\n    public String getBrowserTitle(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).getTitle();\r\n    }\r\n\r\n    public String getBrowserURL(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).getURL();\r\n    }\r\n\r\n    @Override\r\n    public void setBrowserURL(PeerComponent browserPeer, String url, Map<String, String> headers) {\r\n        if (url.startsWith(\"jar:\")) {\r\n            url = url.substring(6);\r\n            if(url.indexOf(\"/\") != 0) {\r\n                url = \"/\"+url;\r\n            }\r\n\r\n            url = \"file:///android_asset\"+url;\r\n        }\r\n        AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        if(bc.parent.fireBrowserNavigationCallbacks(url)) {\r\n            bc.setURL(url, headers);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isURLWithCustomHeadersSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setBrowserURL(PeerComponent browserPeer, String url) {\r\n        setBrowserURL(browserPeer, url, null);\r\n    }\r\n\r\n    public void browserStop(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).stop();\r\n    }\r\n\r\n    public void browserDestroy(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).destroy();\r\n    }\r\n\r\n    /**\r\n     * Reload the current page\r\n     *\r\n     * @param browserPeer browser instance\r\n     */\r\n    public void browserReload(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).reload();\r\n    }\r\n\r\n    /**\r\n     * Indicates whether back is currently available\r\n     *\r\n     * @param browserPeer browser instance\r\n     * @return true if back should work\r\n     */\r\n    public boolean browserHasBack(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).hasBack();\r\n    }\r\n\r\n    public boolean browserHasForward(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).hasForward();\r\n    }\r\n\r\n    public void browserBack(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).back();\r\n    }\r\n\r\n    public void browserForward(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).forward();\r\n    }\r\n\r\n    public void browserClearHistory(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).clearHistory();\r\n    }\r\n\r\n    public void setBrowserPage(PeerComponent browserPeer, String html, String baseUrl) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).setPage(html, baseUrl);\r\n    }\r\n\r\n    public void browserExposeInJavaScript(PeerComponent browserPeer, Object o, String name) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).exposeInJavaScript(o, name);\r\n    }\r\n\r\n    private boolean useEvaluateJavascript() {\r\n        return android.os.Build.VERSION.SDK_INT >= 19;\r\n    }\r\n    \r\n\r\n    private int jsCallbackIndex=0;\r\n\r\n    private void execJSUnsafe(WebView web, String js) {\r\n        if (useEvaluateJavascript()) {\r\n            web.evaluateJavascript(js, null);\r\n        } else {\r\n            web.loadUrl(\"javascript:(function(){\"+js+\"})()\");\r\n        }\r\n    }\r\n\r\n    private void execJSSafe(final WebView web, final String js) {\r\n        if (useJSDispatchThread()) {\r\n            runOnJSDispatchThread(new Runnable() {\r\n                public void run() {\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        public void run() {\r\n                            execJSUnsafe(web, js);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    execJSUnsafe(web, js);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private void execJSUnsafe(final AndroidBrowserComponent bc, final String javaScript, final ValueCallback<String> resultCallback) {\r\n        if (useEvaluateJavascript()) {\r\n            try {\r\n                bc.web.evaluateJavascript(javaScript, resultCallback);\r\n            } catch (Throwable t) {\r\n                com.codename1.io.Log.e(t);\r\n                resultCallback.onReceiveValue(null);\r\n            }\r\n        } else {\r\n            jsCallbackIndex = (++jsCallbackIndex) % 1024;\r\n            int index = jsCallbackIndex;\r\n\r\n            // The jsCallback is a special java object exposed to javascript that we use\r\n            // to return values from javascript to java.\r\n            synchronized (bc.jsCallback){\r\n                // Initialize the return value to null\r\n                while (!bc.jsCallback.isIndexAvailable(index)) {\r\n                    index++;\r\n                }\r\n                jsCallbackIndex = index+1;\r\n            }\r\n            final int fIndex = index;\r\n            // We are placing the javascript inside eval() so we need to escape\r\n            // the input.\r\n            String escaped = StringUtil.replaceAll(javaScript, \"\\\\\", \"\\\\\\\\\");\r\n            escaped = StringUtil.replaceAll(escaped, \"'\", \"\\\\'\");\r\n\r\n            final String js = \"javascript:(function(){\"\r\n\r\n                    + \"try{\"\r\n                    +bc.jsCallback.jsInit()\r\n                    +bc.jsCallback.jsCleanup()\r\n                    + AndroidBrowserComponentCallback.JS_RETURNVAL_VARNAME+\"[\"+index+\"]\"\r\n                    + \"=eval('\"+escaped +\"');} catch (e){console.log(e)};\"\r\n                    + AndroidBrowserComponentCallback.JS_VAR_NAME+\".addReturnValue(\" + index+\", ''+\"\r\n\r\n                    + AndroidBrowserComponentCallback.JS_RETURNVAL_VARNAME+\"[\"+index+\"]\"\r\n                    + \");})()\";\r\n\r\n            // Send the Javascript string via SetURL.\r\n            // NOTE!! This is sent asynchronously so we will need to wait for\r\n            // the result to come in.\r\n            bc.setURL(js, null);\r\n            if (resultCallback == null) {\r\n                return;\r\n            }\r\n            Thread t = new Thread(new Runnable() {\r\n                public void run() {\r\n                    int maxTries = 500;\r\n                    int tryCounter = 0;\r\n\r\n                    // If we are not on the EDT, then it is safe to just loop and wait.\r\n                    while (!bc.jsCallback.isValueSet(fIndex) && tryCounter++ < maxTries) {\r\n                        synchronized(bc.jsCallback){\r\n                            Util.wait(bc.jsCallback, 20);\r\n                        }\r\n                    }\r\n\r\n                    if (bc.jsCallback.isValueSet(fIndex)) {\r\n                        String retval = bc.jsCallback.getReturnValue(fIndex);\r\n                        bc.jsCallback.remove(fIndex);\r\n                        resultCallback.onReceiveValue(retval != null ? JSONObject.quote(retval) : null);\r\n\r\n                    } else {\r\n                        com.codename1.io.Log.e(new RuntimeException(\"Failed to execute javascript \"+js+\" after maximum wait time.\"));\r\n                        resultCallback.onReceiveValue(null);\r\n                    }\r\n                }\r\n            });\r\n            t.start();\r\n\r\n        }\r\n    }\r\n\r\n    private void execJSSafe(final AndroidBrowserComponent bc, final String javaScript, final ValueCallback<String> resultCallback) {\r\n        if (useJSDispatchThread()) {\r\n            runOnJSDispatchThread(new Runnable() {\r\n                public void run() {\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        public void run() {\r\n                            execJSUnsafe(bc, javaScript, resultCallback);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    execJSUnsafe(bc, javaScript, resultCallback);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void browserExecute(final PeerComponent browserPeer, final String javaScript) {\r\n        final AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        execJSSafe(bc.web, javaScript);\r\n    }\r\n\r\n    private com.codename1.util.EasyThread jsDispatchThread;\r\n    private com.codename1.util.EasyThread jsDispatchThread() {\r\n        if (jsDispatchThread == null) {\r\n            jsDispatchThread = com.codename1.util.EasyThread.start(\"JS Dispatch Thread\");\r\n        }\r\n        return jsDispatchThread;\r\n    }\r\n\r\n    private boolean useJSDispatchThread() {\r\n\r\n        // Before version 24, we need a separate JS dispatch thread to prevent deadlocks\r\n        return true;//Build.VERSION.SDK_INT < 24;\r\n    }\r\n\r\n    public boolean isJSDispatchThread() {\r\n        if (useJSDispatchThread()) {\r\n            return jsDispatchThread().isThisIt();\r\n        } else {\r\n            return (Looper.getMainLooper().getThread() == Thread.currentThread());\r\n        }\r\n    }\r\n\r\n    public boolean runOnJSDispatchThread(Runnable r) {\r\n        if (isJSDispatchThread()) {\r\n            r.run();\r\n            return true;\r\n        }\r\n        if (useJSDispatchThread()) {\r\n            jsDispatchThread().run(r);\r\n        } else {\r\n            getActivity().runOnUiThread(r);\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Executes javascript and returns a string result where appropriate.\r\n     * @param browserPeer\r\n     * @param javaScript\r\n     * @return\r\n     */\r\n    @Override\r\n    public String browserExecuteAndReturnString(final PeerComponent browserPeer, final String javaScript) {\r\n        final AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        final String[] result = new String[1];\r\n        final boolean[] complete = new boolean[1];\r\n\r\n        execJSSafe(bc, javaScript, new ValueCallback<String>() {\r\n            @Override\r\n            public void onReceiveValue(String value) {\r\n                synchronized(result) {\r\n                    complete[0] = true;\r\n                    result[0] = value;\r\n                    result.notify();\r\n                }\r\n            }\r\n        });\r\n        synchronized(result) {\r\n            if (!complete[0]) {\r\n                Util.wait(result, 10000);\r\n            }\r\n        }\r\n        if (result[0] == null) {\r\n            return null;\r\n        } else {\r\n            org.json.JSONTokener tok = new org.json.JSONTokener(\"{\\\"result\\\":\"+result[0]+\"}\");\r\n            try {\r\n                JSONObject jso = new JSONObject(tok);\r\n                return jso.getString(\"result\");\r\n            } catch (Throwable ex) {\r\n                com.codename1.io.Log.e(ex);\r\n                return null;\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean supportsBrowserExecuteAndReturnString(PeerComponent browserPeer) {\r\n        return true;\r\n    }\r\n\r\n    public boolean canForceOrientation() {\r\n        return true;\r\n    }\r\n\r\n    public void lockOrientation(boolean portrait) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        if(portrait){\r\n            getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\r\n        }else{\r\n            getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\r\n        }\r\n    }\r\n\r\n    public void unlockOrientation() {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);\r\n    }\r\n\r\n\r\n\r\n    public boolean isAffineSupported() {\r\n        return true;\r\n    }\r\n\r\n    public void resetAffine(Object nativeGraphics) {\r\n        ((AndroidGraphics) nativeGraphics).resetAffine();\r\n    }\r\n\r\n    public void scale(Object nativeGraphics, float x, float y) {\r\n        ((AndroidGraphics) nativeGraphics).scale(x, y);\r\n    }\r\n\r\n    public void rotate(Object nativeGraphics, float angle) {\r\n        ((AndroidGraphics) nativeGraphics).rotate(angle);\r\n    }\r\n\r\n    public void rotate(Object nativeGraphics, float angle, int x, int y) {\r\n        ((AndroidGraphics) nativeGraphics).rotate(angle, x, y);\r\n    }\r\n\r\n    public void shear(Object nativeGraphics, float x, float y) {\r\n    }\r\n\r\n    public boolean isTablet() {\r\n        return (getContext().getResources().getConfiguration().screenLayout\r\n                & Configuration.SCREENLAYOUT_SIZE_MASK)\r\n                >= Configuration.SCREENLAYOUT_SIZE_LARGE;\r\n    }\r\n\r\n    /**\r\n     * Executes r on the UI thread and blocks the EDT to completion\r\n     * @param r runnable to execute\r\n     */\r\n    public static void runOnUiThreadAndBlock(final Runnable r) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot run on UI thread because getActivity() is null.  This generally means we are running inside a service in the background so UI access is disabled.\");\r\n        }\r\n\r\n        final boolean[] completed = new boolean[1];\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    r.run();\r\n                } catch(Throwable t) {\r\n                    com.codename1.io.Log.e(t);\r\n                }\r\n                synchronized(completed) {\r\n                    completed[0] = true;\r\n                    completed.notify();\r\n                }\r\n            }\r\n        });\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                synchronized(completed) {\r\n                    while(!completed[0]) {\r\n                        try {\r\n                            completed.wait();\r\n                        } catch(InterruptedException err) {}\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    public static void runOnUiThreadSync(final Runnable r) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot run on UI thread because getActivity() is null.  This generally means we are running inside a service in the background so UI access is disabled.\");\r\n        }\r\n\r\n        final boolean[] completed = new boolean[1];\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    r.run();\r\n                } catch(Throwable t) {\r\n                    com.codename1.io.Log.e(t);\r\n                }\r\n                synchronized(completed) {\r\n                    completed[0] = true;\r\n                    completed.notify();\r\n                }\r\n            }\r\n        });\r\n        synchronized(completed) {\r\n            while(!completed[0]) {\r\n                try {\r\n                    completed.wait();\r\n                } catch(InterruptedException err) {}\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public int convertToPixels(int dipCount, boolean horizontal) {\r\n        DisplayMetrics dm = getContext().getResources().getDisplayMetrics();\r\n        float ppi = dm.density * 160f;\r\n        return (int) (((float) dipCount) / 25.4f * ppi);\r\n    }\r\n\r\n    public boolean isPortrait() {\r\n        int orientation = getContext().getResources().getConfiguration().orientation;\r\n        if (orientation == Configuration.ORIENTATION_UNDEFINED\r\n                || orientation == Configuration.ORIENTATION_SQUARE) {\r\n            return super.isPortrait();\r\n        }\r\n        return orientation == Configuration.ORIENTATION_PORTRAIT;\r\n    }\r\n\r\n    /**\r\n     * Checks if this platform supports sharing cookies between Native components (e.g. BrowserComponent)\r\n     * and ConnectionRequests.  Currently only Android and iOS ports support this.\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isNativeCookieSharingSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void clearNativeCookies() {\r\n        CookieManager mgr = getCookieManager();\r\n        mgr.removeAllCookie();\r\n    }\r\n    private static CookieManager cookieManager;\r\n    private static CookieManager getCookieManager() {\r\n        if (android.os.Build.VERSION.SDK_INT >= 21) {\r\n            return CookieManager.getInstance();\r\n        }\r\n        if (cookieManager == null) {\r\n            CookieSyncManager.createInstance(getContext()); // Fixes a crash on Android 4.3\r\n            // https://stackoverflow.com/a/20552998/2935174\r\n            cookieManager = CookieManager.getInstance();\r\n        }\r\n        return CookieManager.getInstance();\r\n    }\r\n\r\n    @Override\r\n    public Vector getCookiesForURL(String url) {\r\n        if (isUseNativeCookieStore()) {\r\n            try {\r\n                URI uri = new URI(url);\r\n\r\n\r\n                CookieManager mgr = getCookieManager();\r\n                mgr.removeExpiredCookie();\r\n                String domain = uri.getHost();\r\n                String cookieStr = mgr.getCookie(url);\r\n                if (cookieStr != null) {\r\n                    String[] cookies = cookieStr.split(\";\");\r\n                    int len = cookies.length;\r\n                    Vector out = new Vector();\r\n                    for (int i = 0; i < len; i++) {\r\n                        Cookie c = new Cookie();\r\n                        String[] parts = cookies[i].split(\"=\");\r\n                        c.setName(parts[0].trim());\r\n                        if (parts.length > 1) {\r\n                            c.setValue(parts[1].trim());\r\n                        } else {\r\n                            c.setValue(\"\");\r\n                        }\r\n                        c.setDomain(domain);\r\n                        out.add(c);\r\n                    }\r\n                    return out;\r\n                }\r\n            } catch (Exception ex) {\r\n                com.codename1.io.Log.e(ex);\r\n            }\r\n            return new Vector();\r\n        }\r\n        return super.getCookiesForURL(url);\r\n    }\r\n\r\n    public class WebAppInterface {\r\n        BrowserComponent bc;\r\n        /** Instantiate the interface and set the context */\r\n        WebAppInterface(BrowserComponent bc) {\r\n            this.bc = bc;\r\n        }\r\n\r\n        @JavascriptInterface   // must be added for API 17 or higher\r\n        public boolean shouldNavigate(String url) {\r\n            return bc.fireBrowserNavigationCallbacks(url);\r\n        }\r\n    }\r\n    \r\n    class AndroidBrowserComponent extends AndroidImplementation.AndroidPeer {\r\n\r\n        private Activity act;\r\n        private WebView web;\r\n        private BrowserComponent parent;\r\n        private boolean scrollingEnabled = true;\r\n        protected AndroidBrowserComponentCallback jsCallback;\r\n        private boolean lightweightMode = false;\r\n        private ProgressDialog progressBar;\r\n        private boolean hideProgress;\r\n        private int layerType;\r\n\r\n\r\n        public AndroidBrowserComponent(final WebView web, Activity act, Object p) {\r\n            super(web);\r\n            if(!superPeerMode) {\r\n                doSetVisibility(false);\r\n            }\r\n            parent = (BrowserComponent) p;\r\n            this.web = web;\r\n            layerType = web.getLayerType();\r\n            web.getSettings().setJavaScriptEnabled(true);\r\n            web.getSettings().setSupportZoom(parent.isPinchToZoomEnabled());\r\n            this.act = act;\r\n            jsCallback = new AndroidBrowserComponentCallback();\r\n            hideProgress = Display.getInstance().getProperty(\"WebLoadingHidden\", \"false\").equals(\"true\");\r\n\r\n            web.addJavascriptInterface(jsCallback, AndroidBrowserComponentCallback.JS_VAR_NAME);\r\n            web.addJavascriptInterface(new WebAppInterface(parent), \"cn1application\");\r\n\r\n            web.setWebViewClient(new WebViewClient() {\r\n                \r\n                \r\n                \r\n                public void onLoadResource(WebView view, String url) {\r\n                    if (Display.getInstance().getProperty(\"syncNativeCookies\", \"false\").equals(\"true\")) {\r\n                        try {\r\n                            URI uri = new URI(url);\r\n                            CookieManager mgr = getCookieManager();\r\n                            mgr.removeExpiredCookie();\r\n                            String domain = uri.getHost();\r\n                            removeCookiesForDomain(domain);\r\n                            String cookieStr = mgr.getCookie(url);\r\n                            if (cookieStr != null) {\r\n                                String[] cookies = cookieStr.split(\";\");\r\n                                int len = cookies.length;\r\n                                ArrayList out = new ArrayList();\r\n                                for (int i = 0; i < len; i++) {\r\n                                    Cookie c = new Cookie();\r\n                                    String[] parts = cookies[i].split(\"=\");\r\n                                    c.setName(parts[0].trim());\r\n                                    if (parts.length > 1) {\r\n                                        c.setValue(parts[1].trim());\r\n                                    } else {\r\n                                        c.setValue(\"\");\r\n                                    }\r\n                                    c.setDomain(domain);\r\n                                    out.add(c);\r\n                                }\r\n                                Cookie[] cookiesArr = new Cookie[out.size()];\r\n                                out.toArray(cookiesArr);\r\n                                AndroidImplementation.this.addCookie(cookiesArr, false);\r\n                            }\r\n\r\n                        } catch (URISyntaxException ex) {\r\n\r\n                        }\r\n                    }\r\n                    parent.fireWebEvent(\"onLoadResource\", new ActionEvent(url));\r\n                    super.onLoadResource(view, url);\r\n                    setShouldCalcPreferredSize(true);\r\n                }\r\n\r\n                @Override\r\n                public void onPageStarted(WebView view, String url, Bitmap favicon) {\r\n                    if (getActivity() == null) {\r\n                        return;\r\n                    }\r\n\r\n                    parent.fireWebEvent(\"onStart\", new ActionEvent(url));\r\n                    super.onPageStarted(view, url, favicon);\r\n                    dismissProgress();\r\n                    //show the progress only if there is no ActionBar\r\n                    if(!hideProgress && !isNativeTitle()){\r\n                        progressBar = ProgressDialog.show(getActivity(), null, \"Loading...\");\r\n                        //if the page hasn't finished for more the 10 sec, dismiss\r\n                        //the dialog\r\n                        Timer t= new Timer();\r\n                        t.schedule(new TimerTask() {\r\n                            @Override\r\n                            public void run() {\r\n                                dismissProgress();\r\n                            }\r\n                        }, 10000);\r\n                    }\r\n                }\r\n\r\n                public void onPageFinished(WebView view, String url) {\r\n                    parent.fireWebEvent(\"onLoad\", new ActionEvent(url));\r\n                    super.onPageFinished(view, url);\r\n                    setShouldCalcPreferredSize(true);\r\n                    dismissProgress();\r\n                }\r\n\r\n                private void dismissProgress() {\r\n                    if (progressBar != null && progressBar.isShowing()) {\r\n                        progressBar.dismiss();\r\n                        Display.getInstance().callSerially(new Runnable() {\r\n\r\n                            public void run() {\r\n                                setVisible(true);\r\n                                repaint();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {\r\n                    parent.fireWebEvent(\"onError\", new ActionEvent(description, errorCode));\r\n                    super.onReceivedError(view, errorCode, description, failingUrl);\r\n                    super.shouldOverrideKeyEvent(view, null);\r\n                    dismissProgress();\r\n                }\r\n\r\n                public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {\r\n                    int keyCode = event.getKeyCode();\r\n                    if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {\r\n                        return true;\r\n                    }\r\n\r\n                    return super.shouldOverrideKeyEvent(view, event);\r\n                }\r\n\r\n                public boolean shouldOverrideUrlLoading(WebView view, String url) {\r\n                    if (url.startsWith(\"jar:\")) {\r\n                        setURL(url, null);\r\n                        return true;\r\n                    }\r\n\r\n                    // this will fail if dial permission isn't declared\r\n                    if(url.startsWith(\"tel:\")) {\r\n                        if(parent.fireBrowserNavigationCallbacks(url)) {\r\n                            try {\r\n                                Intent dialer = new Intent(android.content.Intent.ACTION_DIAL, Uri.parse(url));\r\n                                getContext().startActivity(dialer);\r\n                            } catch(Throwable t) {}\r\n                        }\r\n                        return true;\r\n                    }\r\n                    // this will fail if dial permission isn't declared\r\n                    if(url.startsWith(\"mailto:\")) {\r\n                        if(parent.fireBrowserNavigationCallbacks(url)) {\r\n                            try {\r\n                                Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(url));\r\n                                getContext().startActivity(emailIntent);\r\n                            } catch(Throwable t) {}\r\n                        }\r\n                        return true;\r\n                    }\r\n                    return !parent.fireBrowserNavigationCallbacks(url);\r\n                }\r\n\r\n\r\n            });\r\n\r\n            web.setWebChromeClient(new WebChromeClient(){\r\n                // For 3.0+ Devices (Start)\r\n                // onActivityResult attached before constructor\r\n                protected void openFileChooser(ValueCallback uploadMsg, String acceptType)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent i = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    i.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    i.setType(acceptType);\r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(i, \"File Browser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n\r\n                // For Lollipop 5.0+ Devices\r\n                public boolean onShowFileChooser(WebView mWebView, ValueCallback<Uri[]> filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)\r\n                {\r\n                    if (uploadMessage != null) {\r\n                        uploadMessage.onReceiveValue(null);\r\n                        uploadMessage = null;\r\n                    }\r\n\r\n                    uploadMessage = filePathCallback;\r\n\r\n                    Intent intent = fileChooserParams.createIntent();\r\n                    try\r\n                    {\r\n                        AndroidNativeUtil.getActivity().startActivityForResult(intent, REQUEST_SELECT_FILE);\r\n                    } catch (ActivityNotFoundException e)\r\n                    {\r\n                        uploadMessage = null;\r\n                        Toast.makeText(getActivity().getApplicationContext(), \"Cannot Open File Chooser\", Toast.LENGTH_LONG).show();\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                //For Android 4.1 only\r\n                protected void openFileChooser(ValueCallback<Uri> uploadMsg, String acceptType, String capture)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent intent = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    intent.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    intent.setType(acceptType);\r\n                    \r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(intent, \"File Browser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n                protected void openFileChooser(ValueCallback<Uri> uploadMsg)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent i = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    i.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    i.setType(\"image/*\");\r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(i, \"File Chooser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n                \r\n                @Override\r\n                public boolean onConsoleMessage(ConsoleMessage consoleMessage) {\r\n                    com.codename1.io.Log.p(\"[\"+consoleMessage.messageLevel()+\"] \"+consoleMessage.message()+\" On line \"+consoleMessage.lineNumber()+\" of \"+consoleMessage.sourceId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public void onProgressChanged(WebView view, int newProgress) {\r\n                    parent.fireWebEvent(\"Progress\", new ActionEvent(parent, ActionEvent.Type.Progress, newProgress));\r\n                    if(!hideProgress && isNativeTitle() && getCurrentForm() != null && getCurrentForm().getTitle() != null && getCurrentForm().getTitle().length() > 0 ){\r\n                        if(getActivity() != null){\r\n                            try{\r\n                                getActivity().setProgressBarVisibility(true);\r\n                                getActivity().setProgress(newProgress * 100);\r\n                                if(newProgress == 100){\r\n                                    getActivity().setProgressBarVisibility(false);\r\n                                }\r\n                            }catch(Throwable t){\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onGeolocationPermissionsShowPrompt(String origin,\r\n                                                               GeolocationPermissions.Callback callback) {\r\n                    // Always grant permission since the app itself requires location\r\n                    // permission and the user has therefore already granted it\r\n                    callback.invoke(origin, true, false);\r\n                }\r\n\r\n                @Override\r\n                public void onPermissionRequest(final PermissionRequest request) {\r\n\r\n                    Log.d(\"Codename One\", \"onPermissionRequest\");\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        @TargetApi(Build.VERSION_CODES.LOLLIPOP)\r\n                        @Override\r\n                        public void run() {\r\n                            String allowedOrigins = Display.getInstance().getProperty(\"android.WebView.grantPermissionsFrom\", null);\r\n                            if (allowedOrigins != null) {\r\n                                String[] origins = Util.split(allowedOrigins, \" \");\r\n                                boolean allowed = false;\r\n                                for (String origin : origins) {\r\n                                    if (request.getOrigin().toString().equals(origin)) {\r\n                                        allowed = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (allowed) {\r\n                                    Log.d(\"Codename One\", \"Allowing permission for \"+Arrays.toString(request.getResources())+\" in web view for origin \"+request.getOrigin());\r\n                                    request.grant(request.getResources());\r\n                                } else {\r\n                                    Log.d(\"Codename One\", \"Denying permission for \"+Arrays.toString(request.getResources())+\" in web view for origin \"+request.getOrigin());\r\n                                    request.deny();\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void initComponent() {\r\n            if(android.os.Build.VERSION.SDK_INT == 21 && web.getLayerType() != layerType){\r\n                act.runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        web.setLayerType(layerType, null); //setting layer type to original state\r\n                    }\r\n                });\r\n            }\r\n            super.initComponent();\r\n            blockNativeFocus(false);\r\n            setPeerImage(null);\r\n        }\r\n\r\n\r\n        @Override\r\n        protected Image generatePeerImage() {\r\n            try {\r\n                final Bitmap nativeBuffer = Bitmap.createBitmap(\r\n                        getWidth(), getHeight(), Bitmap.Config.ARGB_8888);\r\n                Image image = new AndroidImplementation.NativeImage(nativeBuffer);\r\n                getActivity().runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        try {\r\n                            Canvas canvas = new Canvas(nativeBuffer);\r\n                            web.draw(canvas);\r\n                        } catch(Throwable t) {\r\n                            t.printStackTrace();\r\n                        }\r\n                    }\r\n                });\r\n                return image;\r\n            } catch(Throwable t) {\r\n                t.printStackTrace();\r\n                return Image.createImage(5, 5);\r\n            }\r\n        }\r\n\r\n        protected boolean shouldRenderPeerImage() {\r\n            return lightweightMode || !isInitialized();\r\n        }\r\n\r\n        protected void setLightweightMode(boolean l) {\r\n            doSetVisibility(!l);\r\n            if (lightweightMode == l) {\r\n                return;\r\n            }\r\n            lightweightMode = l;\r\n        }\r\n\r\n\r\n\r\n        public void setScrollingEnabled(final boolean enabled){\r\n            this.scrollingEnabled = enabled;\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.setHorizontalScrollBarEnabled(enabled);\r\n                    web.setVerticalScrollBarEnabled(enabled);\r\n                    if ( !enabled ){\r\n                        web.setOnTouchListener(new View.OnTouchListener(){\r\n\r\n                            @Override\r\n                            public boolean onTouch(View view, MotionEvent me) {\r\n                                return (me.getAction() == MotionEvent.ACTION_MOVE);\r\n                            }\r\n\r\n                        });\r\n                    } else {\r\n                        web.setOnTouchListener(null);\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n\r\n        public boolean isScrollingEnabled(){\r\n            return scrollingEnabled;\r\n        }\r\n\r\n        public void setProperty(final String key, final Object value) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    WebSettings s = web.getSettings();\r\n                    if(key.equalsIgnoreCase(\"useragent\")) {\r\n                        s.setUserAgentString((String)value);\r\n                        return;\r\n                    }\r\n                    try {\r\n                        s.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\r\n                    } catch(Throwable t) {\r\n                        // the method isn't available in Android 4.x\r\n                    }\r\n                    String methodName = \"set\" + key;\r\n                    for (Method m : s.getClass().getMethods()) {\r\n                        if (m.getName().equalsIgnoreCase(methodName) && m.getParameterTypes().length == 1) {\r\n                            try {\r\n                                m.invoke(s, value);\r\n                            } catch (Exception ex) {\r\n                                ex.printStackTrace();\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public String getTitle() {\r\n            final String[] retVal = new String[1];\r\n            final boolean[] complete = new boolean[1];\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n\r\n                        retVal[0] = web.getTitle();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0];\r\n        }\r\n\r\n        public String getURL() {\r\n            final String[] retVal = new String[1];\r\n            final boolean[] complete = new boolean[1];\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.getUrl();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0];\r\n        }\r\n\r\n        public void setURL(final String url, final Map<String, String> headers) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    if(headers != null) {\r\n                        web.loadUrl(url, headers);\r\n                    } else {\r\n                        web.loadUrl(url);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public void reload() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.reload();\r\n                }\r\n            });\r\n        }\r\n\r\n        public boolean hasBack() {\r\n            final Boolean [] retVal = new Boolean[1];\r\n            final boolean[] complete = new boolean[1];\r\n\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.canGoBack();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0].booleanValue();\r\n        }\r\n\r\n        public boolean hasForward() {\r\n            final Boolean [] retVal = new Boolean[1];\r\n            final boolean[] complete = new boolean[1];\r\n\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.canGoForward();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0].booleanValue();\r\n        }\r\n\r\n        public void back() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.goBack();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void forward() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.goForward();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void clearHistory() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.clearHistory();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void stop() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.stopLoading();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void destroy() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.destroy();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void setPage(final String html, final String baseUrl) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.loadDataWithBaseURL(baseUrl, html, \"text/html\", \"UTF-8\", null);\r\n                }\r\n            });\r\n        }\r\n\r\n        public void exposeInJavaScript(final Object o, final String name) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.addJavascriptInterface(o, name);\r\n                }\r\n            });\r\n        }\r\n\r\n        public  void setPinchZoomEnabled(final boolean e) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.getSettings().setSupportZoom(e);\r\n                    web.getSettings().setBuiltInZoomControls(e);\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void deinitialize() {\r\n            act.runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    if(android.os.Build.VERSION.SDK_INT == 21) { // bugfix for Android 5.0.x\r\n                        web.setLayerType(View.LAYER_TYPE_SOFTWARE, null); //setting layer type to software to prevent the sigseg 11 crash\r\n                    }\r\n                }\r\n            });\r\n            super.deinitialize();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public Object connect(String url, boolean read, boolean write, int timeout) throws IOException {\r\n        URL u = new URL(url);\r\n        CookieHandler.setDefault(null);\r\n        URLConnection con = u.openConnection();\r\n        if (con instanceof HttpURLConnection) {\r\n            HttpURLConnection c = (HttpURLConnection) con;\r\n            c.setUseCaches(false);\r\n            c.setDefaultUseCaches(false);\r\n            c.setInstanceFollowRedirects(false);\r\n            if(timeout > -1) {\r\n                c.setConnectTimeout(timeout);\r\n            }\r\n\r\n            if (android.os.Build.VERSION.SDK_INT > 13) {\r\n                c.setRequestProperty(\"Connection\", \"close\");\r\n            }\r\n        }\r\n        con.setDoInput(read);\r\n        con.setDoOutput(write);\r\n        return con;\r\n    }\r\n    \r\n    @Override\r\n    public void setReadTimeout(Object connection, int readTimeout) {\r\n        if (connection instanceof URLConnection) {\r\n            ((URLConnection)connection).setReadTimeout(readTimeout);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    @Override\r\n    public boolean isReadTimeoutSupported() {\r\n        return true;\r\n    }\r\n    \r\n    @Override\r\n    public void setInsecure(Object connection, boolean insecure) {\r\n        if (insecure) {\r\n            if (connection instanceof HttpsURLConnection) {\r\n                HttpsURLConnection conn = (HttpsURLConnection)connection;\r\n                try {\r\n                    TrustModifier.relaxHostChecking(conn);\r\n                } catch (Exception ex) {\r\n                    com.codename1.io.Log.e(ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object connect(String url, boolean read, boolean write) throws IOException {\r\n        return connect(url, read, write, timeout);\r\n    }\r\n\r\n\r\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\r\n\r\n    private static String dumpHex(byte[] data) {\r\n        final int n = data.length;\r\n        final StringBuilder sb = new StringBuilder(n * 3 - 1);\r\n        for (int i = 0; i < n; i++) {\r\n            if (i > 0) {\r\n                sb.append(' ');\r\n            }\r\n            sb.append(HEX_CHARS[(data[i] >> 4) & 0x0F]);\r\n            sb.append(HEX_CHARS[data[i] & 0x0F]);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    @Override\r\n    public String[] getSSLCertificates(Object connection, String url) throws IOException {\r\n        if (connection instanceof HttpsURLConnection) {\r\n            HttpsURLConnection conn = (HttpsURLConnection)connection;\r\n\r\n            try {\r\n                conn.connect();\r\n                java.security.cert.Certificate[] certs = conn.getServerCertificates();\r\n                String[] out = new String[certs.length * 2];\r\n                int i=0;\r\n                for (java.security.cert.Certificate cert : certs) {\r\n                    {\r\n                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\r\n                        md.update(cert.getEncoded());\r\n                        out[i++] = \"SHA-256:\" + dumpHex(md.digest());\r\n                    }\r\n                    {\r\n                        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\r\n                        md.update(cert.getEncoded());\r\n                        out[i++] = \"SHA1:\" + dumpHex(md.digest());\r\n                    }\r\n\r\n                }\r\n                return out;\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        return new String[0];\r\n\r\n    }\r\n\r\n    @Override\r\n    public boolean canGetSSLCertificates() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHeader(Object connection, String key, String val) {\r\n        ((URLConnection) connection).setRequestProperty(key, val);\r\n    }\r\n\r\n    @Override\r\n    public void setChunkedStreamingMode(Object connection, int bufferLen){\r\n        HttpURLConnection con = ((HttpURLConnection) connection);\r\n        con.setChunkedStreamingMode(bufferLen);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openOutputStream(Object connection) throws IOException {\r\n        if (connection instanceof String) {\r\n            String con = (String)connection;\r\n            if (con.startsWith(\"file://\")) {\r\n                con = con.substring(7);\r\n            }\r\n\r\n            OutputStream fc = createFileOuputStream((String) con);\r\n            BufferedOutputStream o = new BufferedOutputStream(fc, (String) con);\r\n            return o;\r\n        }\r\n        return new BufferedOutputStream(((URLConnection) connection).getOutputStream(), connection.toString());\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openOutputStream(Object connection, int offset) throws IOException {\r\n        String con = (String) connection;\r\n        con = removeFilePrefix(con);\r\n        RandomAccessFile rf = new RandomAccessFile(con, \"rw\");\r\n        rf.seek(offset);\r\n        FileOutputStream fc = new FileOutputStream(rf.getFD());\r\n        BufferedOutputStream o = new BufferedOutputStream(fc, con);\r\n        o.setConnection(rf);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void cleanup(Object o) {\r\n        try {\r\n            super.cleanup(o);\r\n            if (o != null) {\r\n                if (o instanceof RandomAccessFile) {\r\n                    ((RandomAccessFile) o).close();\r\n                }\r\n            }\r\n        } catch (Throwable ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream openInputStream(Object connection) throws IOException {\r\n        if (connection instanceof String) {\r\n            String con = (String) connection;\r\n            if (con.startsWith(\"file://\")) {\r\n                con = con.substring(7);\r\n            }\r\n            InputStream fc = createFileInputStream(con);\r\n            BufferedInputStream o = new BufferedInputStream(fc, con);\r\n            return o;\r\n        }\r\n        if(connection instanceof HttpURLConnection) {\r\n            HttpURLConnection ht = (HttpURLConnection)connection;\r\n            if(ht.getResponseCode() < 400) {\r\n                return new BufferedInputStream(ht.getInputStream());\r\n            }\r\n            return new BufferedInputStream(ht.getErrorStream());\r\n        } else {\r\n            return new BufferedInputStream(((URLConnection) connection).getInputStream());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHttpMethod(Object connection, String method) throws IOException {\r\n        if(method.equalsIgnoreCase(\"patch\")) {\r\n            allowPatch((HttpURLConnection) connection);\r\n        }\r\n        ((HttpURLConnection) connection).setRequestMethod(method);\r\n    }\r\n\r\n    // the following block is based on a few suggestions in this stack overflow \r\n    // answer https://stackoverflow.com/questions/25163131/httpurlconnection-invalid-http-method-patch\r\n    private static boolean enabledPatch;\r\n    private static boolean patchFailed;\r\n    private static void allowPatch(HttpURLConnection connection) {\r\n        if(enabledPatch) {\r\n            return;\r\n        }\r\n        if(patchFailed) {\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n            return;\r\n        }\r\n        try {\r\n            Field methodsField = HttpURLConnection.class.getDeclaredField(\"methods\");\r\n\r\n            Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n            modifiersField.setAccessible(true);\r\n            modifiersField.setInt(methodsField, methodsField.getModifiers() & ~Modifier.FINAL);\r\n\r\n            methodsField.setAccessible(true);\r\n\r\n            String[] oldMethods = (String[]) methodsField.get(null);\r\n            Set<String> methodsSet = new LinkedHashSet<String>(Arrays.asList(oldMethods));\r\n            methodsSet.addAll(Arrays.asList(\"PATCH\"));\r\n            String[] newMethods = methodsSet.toArray(new String[0]);\r\n\r\n            methodsField.set(null/*static field*/, newMethods);\r\n            enabledPatch = true;\r\n        } catch (NoSuchFieldException e) {\r\n            patchFailed = true;\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n        } catch(IllegalAccessException ee) {\r\n            patchFailed = true;\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n        }\r\n    }    \r\n    \r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setPostRequest(Object connection, boolean p) {\r\n        try {\r\n            if (p) {\r\n                ((HttpURLConnection) connection).setRequestMethod(\"POST\");\r\n            } else {\r\n                ((HttpURLConnection) connection).setRequestMethod(\"GET\");\r\n            }\r\n        } catch (IOException err) {\r\n            // an exception here doesn't make sense\r\n            err.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getResponseCode(Object connection) throws IOException {\r\n        // workaround for Android bug discussed here: http://stackoverflow.com/questions/17638398/androids-httpurlconnection-throws-eofexception-on-head-requests\r\n        HttpURLConnection con = (HttpURLConnection) connection;\r\n        if(\"head\".equalsIgnoreCase(con.getRequestMethod())) {\r\n            con.setDoOutput(false);\r\n            con.setRequestProperty( \"Accept-Encoding\", \"\" );\r\n        }\r\n        return ((HttpURLConnection) connection).getResponseCode();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getResponseMessage(Object connection) throws IOException {\r\n        return ((HttpURLConnection) connection).getResponseMessage();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getContentLength(Object connection) {\r\n        return ((HttpURLConnection) connection).getContentLength();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getHeaderField(String name, Object connection) throws IOException {\r\n        return ((HttpURLConnection) connection).getHeaderField(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getHeaderFieldNames(Object connection) throws IOException {\r\n        Set<String> s = ((HttpURLConnection) connection).getHeaderFields().keySet();\r\n        String[] resp = new String[s.size()];\r\n        s.toArray(resp);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getHeaderFields(String name, Object connection) throws IOException {\r\n        HttpURLConnection c = (HttpURLConnection) connection;\r\n        List<String> headers = new ArrayList<String>();\r\n\r\n        // we need to merge headers with differing case since this should be case insensitive\r\n        for(String key : c.getHeaderFields().keySet()) {\r\n            if(key != null && key.equalsIgnoreCase(name)) {\r\n                headers.addAll(c.getHeaderFields().get(key));\r\n            }\r\n        }\r\n        if (headers.size() > 0) {\r\n            List<String> v = new ArrayList<String>();\r\n            v.addAll(headers);\r\n            Collections.reverse(v);\r\n            String[] s = new String[v.size()];\r\n            v.toArray(s);\r\n            return s;\r\n        }\r\n        // workaround for a bug in some android devices\r\n        String f = c.getHeaderField(name);\r\n        if(f != null && f.length() > 0) {\r\n            return new String[] {f};\r\n        }\r\n        return null;\r\n\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void deleteStorageFile(String name) {\r\n        getContext().deleteFile(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream createStorageOutputStream(String name) throws IOException {\r\n        return getContext().openFileOutput(name, 0);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream createStorageInputStream(String name) throws IOException {\r\n        return getContext().openFileInput(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean storageFileExists(String name) {\r\n        String[] fileList = getContext().fileList();\r\n        for (int iter = 0; iter < fileList.length; iter++) {\r\n            if (fileList[iter].equals(name)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listStorageEntries() {\r\n        return getContext().fileList();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getStorageEntrySize(String name) {\r\n        return (int)new File(getContext().getFilesDir(), name).length();\r\n    }\r\n\r\n    private String addFile(String s) {\r\n        // I explicitly don't create a \"proper URL\" since code might rely on the fact that the file isn't encoded\r\n        if(s != null && s.startsWith(\"/\")) {\r\n            return \"file://\" + s;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listFilesystemRoots() {\r\n\r\n        if(!checkForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, \"This is required to browse the file system\")){\r\n            return new String[]{};\r\n        }\r\n\r\n        String [] storageDirs = getStorageDirectories();\r\n        if(storageDirs != null){\r\n            String [] roots = new String[storageDirs.length + 1];\r\n            System.arraycopy(storageDirs, 0, roots, 0, storageDirs.length);\r\n            roots[roots.length - 1] = addFile(Environment.getRootDirectory().getAbsolutePath());\r\n            return roots;\r\n        }\r\n        return new String[]{addFile(Environment.getRootDirectory().getAbsolutePath())};\r\n    }\r\n\r\n    @Override\r\n    public boolean hasCachesDir() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String getCachesDir() {\r\n        return getContext().getCacheDir().getAbsolutePath();\r\n    }\r\n\r\n\r\n\r\n    private String[] getStorageDirectories() {\r\n        String [] storageDirs = null;\r\n\r\n        String storageDev = Environment.getExternalStorageDirectory().getPath();\r\n        String storageRoot = storageDev.substring(0, storageDev.length() - 1);\r\n        BufferedReader bufReader = null;\r\n\r\n        try {\r\n            bufReader = new BufferedReader(new FileReader(\"/proc/mounts\"));\r\n            ArrayList<String> list = new ArrayList<String>();\r\n            String line;\r\n\r\n            while ((line = bufReader.readLine()) != null) {\r\n                if (line.contains(\"vfat\") || line.contains(\"/mnt\") || line.contains(\"/storage\")) {\r\n                    StringTokenizer tokens = new StringTokenizer(line, \" \");\r\n                    String s = tokens.nextToken();\r\n                    s = tokens.nextToken(); // Take the second token, i.e. mount point\r\n\r\n                    if (s.indexOf(\"secure\") != -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (s.startsWith(storageRoot) == true) {\r\n                        list.add(s);\r\n                        continue;\r\n                    }\r\n\r\n                    if (line.contains(\"vfat\") && line.contains(\"/mnt\")) {\r\n                        list.add(s);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            int count = list.size();\r\n\r\n            if (count < 2) {\r\n                storageDirs = new String[] {\r\n                        storageDev\r\n                };\r\n            }\r\n            else {\r\n                storageDirs = new String[count];\r\n\r\n                for (int i = 0; i < count; i++) {\r\n                    storageDirs[i] = (String) list.get(i);\r\n                }\r\n            }\r\n        }\r\n        catch (FileNotFoundException e) {}\r\n        catch (IOException e) {}\r\n        finally {\r\n            if (bufReader != null) {\r\n                try {\r\n                    bufReader.close();\r\n                }\r\n                catch (IOException e) {}\r\n            }\r\n\r\n            return storageDirs;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getAppHomePath() {\r\n        return addFile(getContext().getFilesDir().getAbsolutePath() + \"/\");\r\n    }\r\n\r\n    @Override\r\n    public String toNativePath(String path) {\r\n        return removeFilePrefix(path);\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listFiles(String directory) throws IOException {\r\n        directory = removeFilePrefix(directory);\r\n        return new File(directory).list();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getRootSizeBytes(String root) {\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getRootAvailableSpace(String root) {\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void mkdir(String directory) {\r\n        directory = removeFilePrefix(directory);\r\n        new File(directory).mkdir();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void deleteFile(String file) {\r\n        file = removeFilePrefix(file);\r\n        File f = new File(file);\r\n        f.delete();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isHidden(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).isHidden();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHidden(String file, boolean h) {\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getFileLength(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).length();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getFileLastModified(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).lastModified();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isDirectory(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).isDirectory();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public char getFileSystemSeparator() {\r\n        return File.separatorChar;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openFileOutputStream(String file) throws IOException {\r\n        file = removeFilePrefix(file);\r\n        OutputStream os = null;\r\n        try{\r\n            os = createFileOuputStream(file);\r\n        }catch(FileNotFoundException fne){\r\n            //It is impossible to know if a path is considered an external\r\n            //storage on the various android's versions.\r\n            //So we try to open the path and if failed due to permission we will\r\n            //ask for the permission from the user\r\n            if(fne.getMessage().contains(\"Permission denied\")){\r\n\r\n                if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to access the file\")){\r\n                    //The user refused to give access.\r\n                    return null;\r\n                }else{\r\n                    //The user gave permission try again to access the path\r\n                    return createFileOuputStream(file);\r\n                }\r\n\r\n            }else{\r\n                throw fne;\r\n            }\r\n        }\r\n\r\n        return os;\r\n    }\r\n\r\n    private String removeFilePrefix(String file) {\r\n        if (file.contains(\"/files//storage/emulated/\")) {\r\n            // TODO: Find a better fix for issue https://github.com/codenameone/CodenameOne/issues/3204\r\n            // The gallery is returning files inside the directory /storage/emulated/0/DCIM/Camera/...\r\n            // The path is translated wrong because this path is not listed in any of the root\r\n            // paths of the file system.\r\n            // This issue is related to scoped storage. in API 29.\r\n            // https://stackoverflow.com/questions/56992682/android-9-api-29-storage-emulated-0-pictures-mypic-png-open-failed-eacces\r\n            // \r\n            // This hack works around the problem (and seems to fix it for my test device) by simply\r\n            // looking for this pattern in the path, and stripping everything before\r\n            // the /storage/emulated/...\r\n            // Not good.  Needs to be revisited. - SJH Sept 25, 2020\r\n            return file.substring(file.indexOf(\"/files//storage/emulated/\")+ 7);\r\n        }\r\n        if (file.startsWith(\"file://\")) {\r\n            return file.substring(7);\r\n        }\r\n        if (file.startsWith(\"file:/\")) {\r\n            return file.substring(5);\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream openFileInputStream(String file) throws IOException {\r\n        file = removeFilePrefix(file);\r\n        InputStream is = null;\r\n        try{\r\n            is = createFileInputStream(file);\r\n        }catch(FileNotFoundException fne){\r\n            //It is impossible to know if a path is considered an external\r\n            //storage on the various android's versions.\r\n            //So we try to open the path and if failed due to permission we will\r\n            //ask for the permission from the user\r\n            if(fne.getMessage().contains(\"Permission denied\")){\r\n\r\n                if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to access the file\")){\r\n                    //The user refused to give access.\r\n                    return null;\r\n                }else{\r\n                    //The user gave permission try again to access the path\r\n                    return openFileInputStream(file);\r\n                }\r\n\r\n            }else{\r\n                throw fne;\r\n            }\r\n        }\r\n\r\n        return is;\r\n    }\r\n\r\n    @Override\r\n    public boolean isMultiTouch() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean exists(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).exists();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void rename(String file, String newName) {\r\n        file = removeFilePrefix(file);\r\n        new File(file).renameTo(new File(new File(file).getParentFile(), newName));\r\n    }\r\n\r\n    protected File createFileObject(String fileName) {\r\n        return new File(fileName);\r\n    }\r\n\r\n    protected InputStream createFileInputStream(String fileName) throws FileNotFoundException {\r\n        return new FileInputStream(removeFilePrefix(fileName));\r\n    }\r\n\r\n    protected InputStream createFileInputStream(File f) throws FileNotFoundException {\r\n        return new FileInputStream(f);\r\n    }\r\n\r\n    protected OutputStream createFileOuputStream(String fileName) throws FileNotFoundException {\r\n        return new FileOutputStream(removeFilePrefix(fileName));\r\n    }\r\n\r\n    protected OutputStream createFileOuputStream(java.io.File f) throws FileNotFoundException {\r\n        return new FileOutputStream(f);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean shouldWriteUTFAsGetBytes() {\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void closingOutput(OutputStream s) {\r\n        // For some reasons the Android guys chose not doing this by default:\r\n        // http://android-developers.blogspot.com/2010/12/saving-data-safely.html\r\n        // this seems to be a mistake of sacrificing stability for minor performance\r\n        // gains which will only be noticeable on a server.\r\n        if (s != null) {\r\n            if (s instanceof FileOutputStream) {\r\n                try {\r\n                    FileDescriptor fd = ((FileOutputStream) s).getFD();\r\n                    if (fd != null) {\r\n                        fd.sync();\r\n                    }\r\n                } catch (IOException ex) {\r\n                    // this exception doesn't help us\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void printStackTraceToStream(Throwable t, Writer o) {\r\n        PrintWriter p = new PrintWriter(o);\r\n        t.printStackTrace(p);\r\n    }\r\n\r\n    /**\r\n     * This method returns the platform Location Control\r\n     *\r\n     * @return LocationControl Object\r\n     */\r\n    public LocationManager getLocationManager() {\r\n        boolean permissionGranted = false;\r\n        if (Build.VERSION.SDK_INT >= 29  && \"true\".equals(Display.getInstance().getProperty(\"android.requiresBackgroundLocationPermissionForAPI29\", \"false\"))) {\r\n\r\n            if (checkForPermission(\"android.permission.ACCESS_BACKGROUND_LOCATION\", \"This is required to get the location\")) {\r\n                permissionGranted = true;\r\n            }\r\n\r\n        }\r\n        if (!permissionGranted && !checkForPermission( Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get the location\")) {\r\n            return null;\r\n        }\r\n\r\n\r\n        boolean includesPlayServices = Display.getInstance().getProperty(\"IncludeGPlayServices\", \"false\").equals(\"true\");\r\n        if (includesPlayServices && hasAndroidMarket()) {\r\n            try {\r\n                Class clazz = Class.forName(\"com.codename1.location.AndroidLocationPlayServiceManager\");\r\n                return (com.codename1.location.LocationManager)clazz.getMethod(\"getInstance\").invoke(null);\r\n            } catch (Exception e) {\r\n                return AndroidLocationManager.getInstance(getContext());\r\n            }\r\n        } else {\r\n            return AndroidLocationManager.getInstance(getContext());\r\n        }\r\n    }\r\n\r\n    private String fixAttachmentPath(String attachment) {\r\n        com.codename1.io.File cn1File = new com.codename1.io.File(attachment);\r\n        File mediaStorageDir = new File(new File(getContext().getCacheDir(), \"intent_files\"), \"Attachment\");\r\n\r\n        // Create the storage directory if it does not exist\r\n        if (!mediaStorageDir.exists()) {\r\n            if (!mediaStorageDir.mkdirs()) {\r\n                Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        File newFile = new File(mediaStorageDir.getPath() + File.separator\r\n                    + cn1File.getName());\r\n        if(newFile.exists()) {\r\n            // Create a media file name\r\n            String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\r\n            newFile = new File(mediaStorageDir.getPath() + File.separator\r\n                    + \"IMG_\" + timeStamp + \"_\" + cn1File.getName());\r\n        }\r\n\r\n\r\n        //Uri fileUri = Uri.fromFile(newFile);\r\n        newFile.getParentFile().mkdirs();\r\n        //Uri imageUri = Uri.fromFile(newFile);\r\n        Uri fileUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n\r\n        try {\r\n            InputStream is = FileSystemStorage.getInstance().openInputStream(attachment);\r\n            OutputStream os = new FileOutputStream(newFile);\r\n            byte [] buf = new byte[1024];\r\n            int len;\r\n            while((len = is.read(buf)) > -1){\r\n                os.write(buf, 0, len);\r\n            }\r\n            is.close();\r\n            os.close();\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n\r\n        return fileUri.toString();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void sendMessage(String[] recipients, String subject, Message msg) {\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        Intent emailIntent;\r\n        String attachment = msg.getAttachment();\r\n        boolean hasAttachment = (attachment != null && attachment.length() > 0) || msg.getAttachments().size() > 0;\r\n\r\n        if(msg.getMimeType().equals(Message.MIME_TEXT) && !hasAttachment){\r\n            StringBuilder to = new StringBuilder();\r\n            for (int i = 0; i < recipients.length; i++) {\r\n                to.append(recipients[i]);\r\n                to.append(\";\");\r\n            }\r\n            emailIntent = new Intent(Intent.ACTION_SENDTO,\r\n                    Uri.parse(\r\n                            \"mailto:\" + to.toString()\r\n                                    + \"?subject=\" + Uri.encode(subject)\r\n                                    + \"&body=\" + Uri.encode(msg.getContent())));\r\n        }else{\r\n            if (hasAttachment) {\r\n                if(msg.getAttachments().size() > 1) {\r\n                    emailIntent = new Intent(android.content.Intent.ACTION_SEND_MULTIPLE);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                    emailIntent.setType(msg.getMimeType());\r\n                    ArrayList<Uri> uris = new ArrayList<Uri>();\r\n\r\n                    for(String path : msg.getAttachments().keySet()) {\r\n                        uris.add(Uri.parse(fixAttachmentPath(path)));\r\n                    }\r\n\r\n                    emailIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);\r\n                } else {\r\n                    emailIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                    emailIntent.setType(msg.getMimeType());\r\n                    emailIntent.setType(msg.getAttachmentMimeType());\r\n                    //if the attachment is in the uder home dir we need to copy it\r\n                    //to an accessible dir\r\n                    attachment = fixAttachmentPath(attachment);\r\n                    emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(attachment));\r\n                }\r\n            } else {\r\n                emailIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                emailIntent.setType(msg.getMimeType());\r\n            }\r\n            if (msg.getMimeType().equals(Message.MIME_HTML)) {\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, Html.fromHtml(msg.getContent()));\r\n            }else{\r\n                /*\r\n                // Attempted this workaround to fix the ClassCastException that occurs on android when\r\n                // there are multiple attachments.  Unfortunately, this fixes the stack trace, but\r\n                // has the unwanted side-effect of producing a blank message body.\r\n                // Same workaround for HTML mimetype also fails the same way.\r\n                // Conclusion, Just live with the stack trace.  It doesn't seem to affect the\r\n                // execution of the program... treat it as a warning.\r\n                // See https://github.com/codenameone/CodenameOne/issues/1782\r\n                if (msg.getAttachments().size() > 1) {\r\n                    ArrayList<String> contentArr = new ArrayList<String>();\r\n                    contentArr.add(msg.getContent());\r\n                    emailIntent.putStringArrayListExtra(android.content.Intent.EXTRA_TEXT, contentArr);\r\n                } else {\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, msg.getContent());\r\n\r\n                }*/\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, msg.getContent());\r\n            }\r\n\r\n        }\r\n        final String attach = attachment;\r\n        AndroidNativeUtil.startActivityForResult(Intent.createChooser(emailIntent, \"Send mail...\"), new IntentResultListener() {\r\n\r\n            @Override\r\n            public void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n                if(attach != null && attach.length() > 0 && attach.contains(\"tmp\")){\r\n                    FileSystemStorage.getInstance().delete(attach);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void dial(String phoneNumber) {\r\n        Intent dialer = new Intent(android.content.Intent.ACTION_DIAL, Uri.parse(\"tel:\" + phoneNumber));\r\n        getContext().startActivity(dialer);\r\n    }\r\n\r\n    @Override\r\n    public int getSMSSupport() {\r\n        if(canDial()) {\r\n            return Display.SMS_INTERACTIVE;\r\n        }\r\n        return Display.SMS_NOT_SUPPORTED;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void sendSMS(final String phoneNumber, final String message, boolean i) throws IOException {\r\n        /*if(!checkForPermission(Manifest.permission.SEND_SMS, \"This is required to send a SMS\")){\r\n            return;\r\n        }*/\r\n        if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to send a SMS\")){\r\n            return;\r\n        }\r\n        if(i) {\r\n            Intent smsIntent = null;\r\n            if(android.os.Build.VERSION.SDK_INT < 19){\r\n                smsIntent = new Intent(Intent.ACTION_VIEW);\r\n                smsIntent.setType(\"vnd.android-dir/mms-sms\");\r\n                smsIntent.putExtra(\"address\", phoneNumber);\r\n                smsIntent.putExtra(\"sms_body\",message);\r\n            }else{\r\n                smsIntent = new Intent(Intent.ACTION_SENDTO);\r\n                smsIntent.setData(Uri.parse(\"smsto:\" + Uri.encode(phoneNumber)));\r\n                smsIntent.putExtra(\"sms_body\", message);\r\n            }\r\n            getContext().startActivity(smsIntent);\r\n\r\n        } /*else {\r\n            SmsManager sms = SmsManager.getDefault();\r\n            ArrayList<String> parts = sms.divideMessage(message);\r\n            sms.sendMultipartTextMessage(phoneNumber, null, parts, null, null);\r\n        }*/\r\n    }\r\n\r\n    @Override\r\n    public void dismissNotification(Object o) {\r\n        NotificationManager notificationManager = (NotificationManager) getContext().getSystemService(Activity.NOTIFICATION_SERVICE);\r\n        if(o != null){\r\n            Integer n = (Integer)o;\r\n            notificationManager.cancel(\"CN1\", n.intValue());\r\n        }else{\r\n            notificationManager.cancelAll();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isNotificationSupported() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Keys of display properties that need to be made available to Services\r\n     * i.e. must be accessible even if CN1 is not initialized.\r\n     * \r\n     * This is accomplished by setting them inside init().  Then they\r\n     * are written to file so that they can be accessed inside a service\r\n     * like push notification service.\r\n     */\r\n    private static final String[] servicePropertyKeys = new String[]{\r\n        \"android.NotificationChannel.id\",\r\n        \"android.NotificationChannel.name\",\r\n        \"android.NotificationChannel.description\",\r\n        \"android.NotificationChannel.importance\",\r\n        \"android.NotificationChannel.enableLights\",\r\n        \"android.NotificationChannel.lightColor\",\r\n        \"android.NotificationChannel.enableVibration\",\r\n        \"android.NotificationChannel.vibrationPattern\",\r\n        \"android.NotoficationChannel.soundUri\"\r\n    };\r\n    \r\n    /**\r\n     * Flag to indicate if any of the service properties have been changed.\r\n     */\r\n    private static boolean servicePropertiesDirty() {\r\n        for (String key : servicePropertyKeys) {\r\n            if (Display.getInstance().getProperty(key, null) != null) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Stores properties that need to be accessible to services.   \r\n     * i.e. must be accessible even if CN1 is not initialized.\r\n     * \r\n     * This is accomplished by setting them inside init().  Then they\r\n     * are written to file so that they can be accessed inside a service\r\n     * like push notification service.\r\n     */\r\n    private static Map<String,String> serviceProperties;\r\n    \r\n    /**\r\n     * Gets the service properties.  Will read properties from file so that\r\n     * they are available even if CN1 is not initialized.\r\n     * @param a\r\n     * @return \r\n     */\r\n    public static Map<String,String> getServiceProperties(Context a) {\r\n        if (serviceProperties == null) {\r\n            InputStream i = null;\r\n            try {\r\n                serviceProperties = new HashMap<String,String>();\r\n                try {\r\n                    i = a.openFileInput(\"CN1$AndroidServiceProperties\");\r\n                } catch (FileNotFoundException notFoundEx){}\r\n                if(i == null) {\r\n                    return serviceProperties;\r\n                }\r\n                DataInputStream is = new DataInputStream(i);\r\n                int count = is.readInt();\r\n                for (int idx=0; idx<count; idx++) {\r\n                    String key = is.readUTF();\r\n                    String value = is.readUTF();\r\n                    serviceProperties.put(key, value);\r\n                }\r\n            } catch (IOException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } finally {\r\n                try {\r\n                    if (i != null) i.close();\r\n                } catch (Throwable ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n            }\r\n        }\r\n        return serviceProperties;\r\n    }\r\n    \r\n    public static void writeServiceProperties(Context a) {\r\n        if (servicePropertiesDirty()) {\r\n            Map<String,String> out = getServiceProperties(a);\r\n            \r\n            \r\n            for (String key : servicePropertyKeys) {\r\n                \r\n                String val = Display.getInstance().getProperty(key, null);\r\n                if (val != null) {\r\n                    out.put(key, val);\r\n                }\r\n                if (\"true\".equals(Display.getInstance().getProperty(key+\"#delete\", null))) {\r\n                    out.remove(key);\r\n                    \r\n                }\r\n            }\r\n            \r\n            OutputStream os = null;\r\n            try {\r\n                os = a.openFileOutput(\"CN1$AndroidServiceProperties\", 0);\r\n                if (os == null) {\r\n                    System.out.println(\"Failed to save service properties null output stream\");\r\n                    return;\r\n                }\r\n                DataOutputStream dos = new DataOutputStream(os);\r\n                dos.writeInt(out.size());\r\n                for (String key : out.keySet()) {\r\n                    dos.writeUTF(key);\r\n                    dos.writeUTF((String)out.get(key));\r\n                }\r\n                serviceProperties = null;\r\n            } catch (FileNotFoundException ex) {\r\n                System.out.println(\"Service properties file not found.  This is normal for the first run.   On subsequent runs, the file should exist.\");\r\n            } catch (IOException ex) {\r\n                \r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } finally {\r\n                try {\r\n                    if (os != null) os.close();\r\n                } catch (Throwable ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Gets a \"service\" display property.  This is a property that is available\r\n     * even if CN1 is not initialized.  They are written to file after init() so that \r\n     * they are available thereafter to services like push notification services.\r\n     * @param key THe key\r\n     * @param defaultValue The default value\r\n     * @param context Context\r\n     * @return The value.\r\n     */\r\n    public static String getServiceProperty(String key, String defaultValue, Context context) {\r\n        if (Display.isInitialized()) {\r\n            return Display.getInstance().getProperty(key, defaultValue);\r\n        }\r\n        String val = getServiceProperties(context).get(key);\r\n        return val == null ? defaultValue : val;\r\n    }\r\n    \r\n    /**\r\n     * Sets the notification channel on a notification builder.  Uses service properties to \r\n     * set properties of channel.\r\n     * @param nm The notification manager.\r\n     * @param mNotifyBuilder The notify builder\r\n     * @param context The context\r\n     * @since 7.0\r\n     */\r\n    public static void setNotificationChannel(NotificationManager nm, NotificationCompat.Builder mNotifyBuilder, Context context) {\r\n        setNotificationChannel(nm, mNotifyBuilder, context, (String)null);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Sets the notification channel on a notification builder.  Uses service properties to \r\n     * set properties of channel.\r\n     * @param nm The notification manager.\r\n     * @param mNotifyBuilder The notify builder\r\n     * @param context The context\r\n     * @param soundName The name of the sound to use for notifications on this channel.  E.g. mysound.mp3.  This feature is not yet implemented, but\r\n     *  parameter is added now to scaffold compatibility with build daemon until implementation is complete.\r\n     * @since 8.0\r\n     */\r\n    public static void setNotificationChannel(NotificationManager nm, NotificationCompat.Builder mNotifyBuilder, Context context, String soundName) {\r\n        if (android.os.Build.VERSION.SDK_INT >= 26) {\r\n            try {\r\n                NotificationManager mNotificationManager = nm;\r\n                              \r\n                String id = getServiceProperty(\"android.NotificationChannel.id\", \"cn1-channel\", context);\r\n                \r\n                CharSequence name = getServiceProperty(\"android.NotificationChannel.name\", \"Notifications\", context);\r\n                \r\n                String description = getServiceProperty(\"android.NotificationChannel.description\", \"Remote notifications\", context);\r\n                \r\n                // NotificationManager.IMPORTANCE_LOW = 2\r\n                // NotificationManager.IMPORTANCE_HIGH = 4  // <-- Minimum level to produce sound.\r\n                int importance = Integer.parseInt(getServiceProperty(\"android.NotificationChannel.importance\", \"4\", context));\r\n                    // Note: Currently we use a single notification channel for the app, but if the app uses different kinds of \r\n                    // push notifications, then this may not be sufficient.   E.g. The app may send both silent push notifications\r\n                    // and regular notifications - but their settings (e.g. sound) are all managed through one channel with\r\n                    // same settings. \r\n                    // TODO Add support for multiple channels.\r\n                    // See https://github.com/codenameone/CodenameOne/issues/2583\r\n                \r\n                Class clsNotificationChannel = Class.forName(\"android.app.NotificationChannel\");\r\n                //android.app.NotificationChannel mChannel = new android.app.NotificationChannel(id, name, importance);\r\n                Constructor constructor = clsNotificationChannel.getConstructor(java.lang.String.class, java.lang.CharSequence.class, int.class);\r\n                Object mChannel = constructor.newInstance(new Object[]{id, name, importance});\r\n                \r\n                Method method = clsNotificationChannel.getMethod(\"setDescription\", java.lang.String.class);\r\n                method.invoke(mChannel, new Object[]{description});\r\n                //mChannel.setDescription(description);\r\n                \r\n                method = clsNotificationChannel.getMethod(\"enableLights\", boolean.class);\r\n                method.invoke(mChannel, new Object[]{Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableLights\", \"true\", context))});\r\n                //mChannel.enableLights(Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableLights\", \"true\", context)));\r\n                \r\n                method = clsNotificationChannel.getMethod(\"setLightColor\", int.class);\r\n                method.invoke(mChannel, new Object[]{Integer.parseInt(getServiceProperty(\"android.NotificationChannel.lightColor\", \"\" + android.graphics.Color.RED, context))});\r\n                //mChannel.setLightColor(Integer.parseInt(getServiceProperty(\"android.NotificationChannel.lightColor\", \"\" + android.graphics.Color.RED, context)));\r\n                \r\n                method = clsNotificationChannel.getMethod(\"enableVibration\", boolean.class);\r\n                method.invoke(mChannel, new Object[]{Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableVibration\", \"false\", context))});\r\n                //mChannel.enableVibration(Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableVibration\", \"false\", context)));\r\n                String vibrationPatternStr = getServiceProperty(\"android.NotificationChannel.vibrationPattern\", null, context);\r\n                if (vibrationPatternStr != null) {\r\n                    String[] parts = vibrationPatternStr.split(\",\");\r\n                    int len = parts.length;\r\n                    long[] pattern = new long[len];\r\n                    for (int i = 0; i < len; i++) {\r\n                        pattern[i] = Long.parseLong(parts[i].trim());\r\n                    }\r\n                    method = clsNotificationChannel.getMethod(\"setVibrationPattern\", long[].class);\r\n                    method.invoke(mChannel, new Object[]{pattern});\r\n                    //mChannel.setVibrationPattern(pattern);\r\n                }\r\n                \r\n                String soundUri = getServiceProperty(\"android.NotificationChannel.soundUri\", null, context);\r\n                if (soundUri != null) {\r\n                    Uri uri= android.net.Uri.parse(soundUri);\r\n                    \r\n                    android.media.AudioAttributes audioAttributes = new android.media.AudioAttributes.Builder()\r\n                            .setContentType(android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION)\r\n                            .setUsage(android.media.AudioAttributes.USAGE_NOTIFICATION)\r\n                            .build();\r\n                    method = clsNotificationChannel.getMethod(\"setSound\", android.net.Uri.class, android.media.AudioAttributes.class);\r\n                    method.invoke(mChannel, new Object[]{uri, audioAttributes});\r\n                }\r\n                \r\n                method = NotificationManager.class.getMethod(\"createNotificationChannel\", clsNotificationChannel);\r\n                method.invoke(mNotificationManager, new Object[]{mChannel});\r\n                //mNotificationManager.createNotificationChannel(mChannel);\r\n                try {\r\n                    // For some reason I can't find the app-support-v4.jar for\r\n                    // API 26 that includes this method so that I can compile in netbeans.\r\n                    // So we use reflection...  If someone coming after can find a newer version\r\n                    // that has setChannelId(), please rip out this ugly reflection hack and\r\n                    // replace it with a proper call to mNotifyBuilder.setChannelId(id)\r\n                    mNotifyBuilder.getClass().getMethod(\"setChannelId\", new Class[]{String.class}).invoke(mNotifyBuilder, new Object[]{id});\r\n                } catch (Exception ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n                //mNotifyBuilder.setChannelId(id);\r\n            } catch (ClassNotFoundException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (NoSuchMethodException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (SecurityException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (IllegalAccessException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (IllegalArgumentException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (InvocationTargetException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (InstantiationException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n            //mNotifyBuilder.setChannelId(id);\r\n        }\r\n\r\n    }\r\n    \r\n    public Object notifyStatusBar(String tickerText, String contentTitle,\r\n                                  String contentBody, boolean vibrate, boolean flashLights, Hashtable args) {\r\n        int id = getContext().getResources().getIdentifier(\"icon\", \"drawable\", getContext().getApplicationInfo().packageName);\r\n\r\n        NotificationManager notificationManager = (NotificationManager) getContext().getSystemService(Activity.NOTIFICATION_SERVICE);\r\n\r\n        Intent notificationIntent = new Intent();\r\n        notificationIntent.setComponent(activityComponentName);\r\n        PendingIntent contentIntent = PendingIntent.getActivity(getContext(), 0, notificationIntent, 0);\r\n\r\n\r\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(getContext())\r\n                .setContentIntent(contentIntent)\r\n                .setSmallIcon(id)\r\n                .setContentTitle(contentTitle)\r\n                .setTicker(tickerText);\r\n        if(flashLights){\r\n            builder.setLights(0, 1000, 1000);\r\n        }\r\n        if(vibrate){\r\n            builder.setVibrate(new long[]{0, 100, 1000});\r\n        }\r\n        if(args != null) {\r\n            Boolean b = (Boolean)args.get(\"persist\");\r\n            if(b != null && b.booleanValue()) {\r\n                builder.setAutoCancel(false);\r\n                builder.setOngoing(true);\r\n            } else {\r\n                builder.setAutoCancel(false);\r\n            }\r\n        } else {\r\n            builder.setAutoCancel(true);\r\n        }\r\n        Notification notification = builder.build();\r\n        int notifyId = 10001;\r\n        notificationManager.notify(\"CN1\", notifyId, notification);\r\n        return new Integer(notifyId);\r\n    }\r\n\r\n    public boolean isContactsPermissionGranted() {\r\n        if (android.os.Build.VERSION.SDK_INT < 23) {\r\n            return true;\r\n        }\r\n\r\n        if (android.support.v4.content.ContextCompat.checkSelfPermission(getContext(),\r\n                Manifest.permission.READ_CONTACTS)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    @Override\r\n    public String[] getAllContacts(boolean withNumbers) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return new String[]{};\r\n        }\r\n        return AndroidContactsManager.getInstance().getContacts(getContext(), withNumbers);\r\n    }\r\n\r\n    @Override\r\n    public Contact getContactById(String id) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().getContact(getContext(), id);\r\n    }\r\n\r\n    @Override\r\n    public Contact getContactById(String id, boolean includesFullName, boolean includesPicture,\r\n                                  boolean includesNumbers, boolean includesEmail, boolean includeAddress){\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().getContact(getContext(), id, includesFullName, includesPicture,\r\n                includesNumbers, includesEmail, includeAddress);\r\n    }\r\n\r\n    @Override\r\n    public Contact[] getAllContacts(boolean withNumbers, boolean includesFullName, boolean includesPicture, boolean includesNumbers, boolean includesEmail, boolean includeAddress) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return new Contact[]{};\r\n        }\r\n        return AndroidContactsManager.getInstance().getAllContacts(getContext(), withNumbers, includesFullName, includesPicture, includesNumbers, includesEmail, includeAddress);\r\n    }\r\n\r\n    @Override\r\n    public boolean isGetAllContactsFast() {\r\n        return true;\r\n    }\r\n\r\n    public String createContact(String firstName, String surname, String officePhone, String homePhone, String cellPhone, String email) {\r\n        if(!checkForPermission(Manifest.permission.WRITE_CONTACTS, \"This is required to create a contact\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().createContact(getContext(), firstName, surname, officePhone, homePhone, cellPhone, email);\r\n    }\r\n\r\n    public boolean deleteContact(String id) {\r\n        if(!checkForPermission(Manifest.permission.WRITE_CONTACTS, \"This is required to delete a contact\")){\r\n            return false;\r\n        }\r\n        return AndroidContactsManager.getInstance().deleteContact(getContext(), id);\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeShareSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void share(String text, String image, String mimeType, Rectangle sourceRect){\r\n        /*if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to perform share\")){\r\n            return;\r\n        }*/\r\n        Intent shareIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n        if(image == null){\r\n            shareIntent.setType(\"text/plain\");\r\n            shareIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);\r\n        }else{\r\n            shareIntent.setType(mimeType);\r\n            shareIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(fixAttachmentPath(image)));\r\n            shareIntent.putExtra(Intent.EXTRA_TEXT, text);\r\n        }\r\n        getContext().startActivity(Intent.createChooser(shareIntent, \"Share with...\"));\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getPlatformName() {\r\n        return \"and\";\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getPlatformOverrides() {\r\n        if (isTablet()) {\r\n            return new String[]{\"tablet\", \"android\", \"android-tab\"};\r\n        } else {\r\n            return new String[]{\"phone\", \"android\", \"android-phone\"};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void copyToClipboard(final Object obj) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int sdk = android.os.Build.VERSION.SDK_INT;\r\n                if (sdk < 11) {\r\n                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    clipboard.setText(obj.toString());\r\n                } else {\r\n                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    android.content.ClipData clip = ClipData.newPlainText(\"Codename One\", obj.toString());\r\n                    clipboard.setPrimaryClip(clip);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object getPasteDataFromClipboard() {\r\n        if (getContext() == null) {\r\n            return null;\r\n        }\r\n        final Object[] response = new Object[1];\r\n        runOnUiThreadAndBlock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int sdk = android.os.Build.VERSION.SDK_INT;\r\n                if (sdk < 11) {\r\n                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    response[0] = clipboard.getText().toString();\r\n                } else {\r\n                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);\r\n                    response[0] = item.getText();\r\n                }\r\n            }\r\n        });\r\n        return response[0];\r\n    }\r\n\r\n    public static MediaException createMediaException(int extra) {\r\n        MediaErrorType type;\r\n        String message;\r\n        switch (extra) {\r\n\r\n            case MediaPlayer.MEDIA_ERROR_IO:\r\n                type = MediaErrorType.Network;\r\n                message = \"IO error\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_MALFORMED:\r\n                type = MediaErrorType.Decode;\r\n                message = \"Media was malformed\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK:\r\n                type = MediaErrorType.SrcNotSupported;\r\n                message = \"Not valie for progressive playback\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\r\n                type = MediaErrorType.Network;\r\n                message = \"Server died\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_TIMED_OUT:\r\n                type = MediaErrorType.Network;\r\n                message = \"Timed out\";\r\n                break;\r\n\r\n            case MediaPlayer.MEDIA_ERROR_UNKNOWN:\r\n                type = MediaErrorType.Network;\r\n                message = \"Unknown error\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_UNSUPPORTED:\r\n                type = MediaErrorType.SrcNotSupported;\r\n                message = \"Unsupported media\";\r\n                break;\r\n            default:\r\n                type = MediaErrorType.Network;\r\n                message = \"Unknown error\";\r\n        }\r\n        return new MediaException(type, message);\r\n    }\r\n\r\n\r\n    public class Video extends AndroidImplementation.AndroidPeer implements AsyncMedia {\r\n        \r\n        private VideoView nativeVideo;\r\n        private Activity activity;\r\n        private boolean fullScreen = false;\r\n        private Rectangle bounds;\r\n        private boolean nativeController = true;\r\n        private boolean nativePlayer;\r\n        private Form curentForm;\r\n        private List<Runnable> completionHandlers;\r\n        private final EventDispatcher errorListeners = new EventDispatcher();\r\n        \r\n        private final EventDispatcher stateChangeListeners = new EventDispatcher();\r\n        private PlayRequest pendingPlayRequest;\r\n        private PauseRequest pendingPauseRequest;\r\n\r\n        @Override\r\n        public State getState() {\r\n            if (isPlaying()) {\r\n                return State.Playing;\r\n            } else {\r\n                return State.Paused;\r\n            }\r\n        }\r\n        \r\n        protected void fireMediaStateChange(State newState) {\r\n            if (stateChangeListeners.hasListeners() && newState != getState()) {\r\n                stateChangeListeners.fireActionEvent(new MediaStateChangeEvent(this, getState(), newState));\r\n            }\r\n        }\r\n        \r\n        @Override\r\n        public void addMediaStateChangeListener(ActionListener<MediaStateChangeEvent> l) {\r\n            \r\n            stateChangeListeners.addListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void removeMediaStateChangeListener(ActionListener<MediaStateChangeEvent> l) {\r\n            \r\n            stateChangeListeners.removeListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void addMediaErrorListener(ActionListener<MediaErrorEvent> l) {\r\n            errorListeners.addListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void removeMediaErrorListener(ActionListener<MediaErrorEvent> l) {\r\n            errorListeners.removeListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public PlayRequest playAsync() {\r\n            final PlayRequest out = new PlayRequest();\r\n            out.ready(new SuccessCallback<AsyncMedia>() {\r\n                @Override\r\n                public void onSucess(AsyncMedia value) {\r\n                    if (out == pendingPlayRequest) {\r\n                        pendingPlayRequest = null;\r\n                    }\r\n                }\r\n            }).except(new SuccessCallback<Throwable>() {\r\n                @Override\r\n                public void onSucess(Throwable value) {\r\n                    if (out == pendingPlayRequest) {\r\n                        pendingPlayRequest = null;\r\n                    }\r\n                }\r\n            });\r\n            ;\r\n            if (pendingPlayRequest != null) {\r\n                pendingPlayRequest.ready(new SuccessCallback<AsyncMedia>() {\r\n                    @Override\r\n                    public void onSucess(AsyncMedia value) {\r\n                        if (!out.isDone()) {\r\n                            out.complete(value);\r\n                        }\r\n                    }\r\n                }).except(new SuccessCallback<Throwable>() {\r\n                    @Override\r\n                    public void onSucess(Throwable value) {\r\n                        if (!out.isDone()) {\r\n                            out.error(value);\r\n                        }\r\n                    }\r\n                });\r\n                return out;\r\n            } else {\r\n                pendingPlayRequest = out;\r\n            }\r\n            \r\n            ActionListener<MediaStateChangeEvent> onStateChange = new ActionListener<MediaStateChangeEvent>() {\r\n                @Override\r\n                public void actionPerformed(MediaStateChangeEvent evt) {\r\n                    stateChangeListeners.removeListener(this);\r\n                    if (!out.isDone()) {\r\n                        if (evt.getNewState() == State.Playing) {\r\n                            out.complete(Video.this);\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                \r\n            };\r\n            \r\n            stateChangeListeners.addListener(onStateChange);\r\n            play();\r\n            \r\n            return out;\r\n            \r\n        }\r\n        \r\n        @Override\r\n        public PauseRequest pauseAsync() {\r\n            final PauseRequest out = new PauseRequest();\r\n            out.ready(new SuccessCallback<AsyncMedia>() {\r\n                @Override\r\n                public void onSucess(AsyncMedia value) {\r\n                    if (out == pendingPauseRequest) {\r\n                        pendingPauseRequest = null;\r\n                    }\r\n                }\r\n            }).except(new SuccessCallback<Throwable>() {\r\n                @Override\r\n                public void onSucess(Throwable value) {\r\n                    if (out == pendingPauseRequest) {\r\n                        pendingPauseRequest = null;\r\n                    }\r\n                }\r\n            });\r\n            ;\r\n            if (pendingPauseRequest != null) {\r\n                pendingPauseRequest.ready(new SuccessCallback<AsyncMedia>() {\r\n                    @Override\r\n                    public void onSucess(AsyncMedia value) {\r\n                        if (!out.isDone()) {\r\n                            out.complete(value);\r\n                        }\r\n                    }\r\n                }).except(new SuccessCallback<Throwable>() {\r\n                    @Override\r\n                    public void onSucess(Throwable value) {\r\n                        if (!out.isDone()) {\r\n                            out.error(value);\r\n                        }\r\n                    }\r\n                });\r\n                return out;\r\n            } else {\r\n                pendingPauseRequest = out;\r\n            }\r\n            \r\n            ActionListener<MediaStateChangeEvent> onStateChange = new ActionListener<MediaStateChangeEvent>() {\r\n                @Override\r\n                public void actionPerformed(MediaStateChangeEvent evt) {\r\n                    stateChangeListeners.removeListener(this);\r\n                    if (!out.isDone()) {\r\n                        if (evt.getNewState() == State.Paused) {\r\n                            out.complete(Video.this);\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                \r\n            };\r\n            \r\n            stateChangeListeners.addListener(onStateChange);\r\n            play();\r\n            \r\n            return out;\r\n        }\r\n        \r\n\r\n        public Video(final VideoView nativeVideo, final Activity activity, final Runnable onCompletion) {\r\n            super(new RelativeLayout(activity));\r\n            this.nativeVideo = nativeVideo;\r\n            RelativeLayout rl = (RelativeLayout)getNativePeer();\r\n\r\n            rl.addView(nativeVideo);\r\n            RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams(getWidth(), getHeight());\r\n            layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n            layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n            rl.setLayoutParams(layout);\r\n            rl.requestLayout();\r\n\r\n            this.activity = activity;\r\n            if (nativeController) {\r\n                MediaController mc = new AndroidImplementation.CN1MediaController();\r\n                nativeVideo.setMediaController(mc);\r\n            }\r\n\r\n            nativeVideo.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {\r\n                @Override\r\n                public void onCompletion(MediaPlayer arg0) {\r\n                    fireMediaStateChange(State.Paused);\r\n                    \r\n                    fireCompletionHandlers();\r\n                }\r\n            });\r\n            if (onCompletion != null) {\r\n                addCompletionHandler(onCompletion);\r\n            }\r\n\r\n            nativeVideo.setOnErrorListener(new MediaPlayer.OnErrorListener() {\r\n                @Override\r\n                public boolean onError(MediaPlayer mp, int what, int extra) {\r\n                    com.codename1.io.Log.p(\"Media player error: \" + mp + \" what: \" + what + \" extra: \" + extra);\r\n                    errorListeners.fireActionEvent(new MediaErrorEvent(Video.this, createMediaException(extra)));\r\n                    fireMediaStateChange(State.Paused);\r\n                    fireCompletionHandlers();\r\n                    return true;\r\n                }\r\n            });\r\n\r\n        }\r\n        \r\n        \r\n        \r\n        private void fireCompletionHandlers() {\r\n            if (completionHandlers != null && !completionHandlers.isEmpty()) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    public void run() {\r\n                        if (completionHandlers != null && !completionHandlers.isEmpty()) {\r\n                            ArrayList<Runnable> toRun;\r\n                            synchronized(Video.this) {\r\n                                toRun = new ArrayList<Runnable>(completionHandlers);\r\n                            }\r\n                            for (Runnable r : toRun) {\r\n                                r.run();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        private void setNativeController(final boolean nativeController) {\r\n            if (nativeController != this.nativeController) {\r\n                this.nativeController = nativeController;\r\n                if (nativeVideo != null) {\r\n                    Activity activity = getActivity();\r\n                    if (activity != null) {\r\n                        activity.runOnUiThread(new Runnable() {\r\n\r\n                            @Override\r\n                            public void run() {\r\n                                if (nativeVideo != null) {\r\n                                    MediaController mc = new AndroidImplementation.CN1MediaController();\r\n                                    nativeVideo.setMediaController(mc);\r\n                                    if (!nativeController) mc.setVisibility(View.GONE);\r\n                                    else mc.setVisibility(View.VISIBLE);\r\n\r\n                                }\r\n                            }\r\n\r\n                        });\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void init() {\r\n            super.init();\r\n            setVisible(true);\r\n        }\r\n\r\n        public void prepare() {\r\n        }\r\n\r\n        @Override\r\n        public void play() {\r\n            Component cmp = getVideoComponent();\r\n            if (cmp.getParent() == null && nativePlayer && curentForm == null) {\r\n                curentForm = Display.getInstance().getCurrent();\r\n                Form f = new Form();\r\n                f.setBackCommand(new Command(\"\") {\r\n                    @Override\r\n                    public void actionPerformed(ActionEvent evt) {\r\n                        Component cmp = getVideoComponent();\r\n                        if(cmp != null) {\r\n                            cmp.remove();\r\n                            pause();\r\n                        }\r\n                        curentForm.showBack();\r\n                        curentForm = null;\r\n                    }\r\n                });\r\n                f.setLayout(new BorderLayout());\r\n\r\n                if(cmp.getParent() != null) {\r\n                    cmp.getParent().removeComponent(cmp);\r\n                }\r\n                f.addComponent(BorderLayout.CENTER, cmp);\r\n                f.show();\r\n            }\r\n            nativeVideo.start();\r\n            fireMediaStateChange(State.Playing);\r\n        }\r\n\r\n        @Override\r\n        public void pause() {\r\n            if(nativeVideo != null && nativeVideo.canPause()){\r\n                nativeVideo.pause();\r\n                fireMediaStateChange(State.Paused);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void cleanup() {\r\n            if(nativeVideo != null) {\r\n                nativeVideo.stopPlayback();\r\n                fireMediaStateChange(State.Paused);\r\n            }\r\n            nativeVideo = null;\r\n            if (nativePlayer && curentForm != null) {\r\n                curentForm.showBack();\r\n                curentForm = null;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public int getTime() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.getCurrentPosition();\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public void setTime(int time) {\r\n            if(nativeVideo != null){\r\n                nativeVideo.seekTo(time);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public int getDuration() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.getDuration();\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public void setVolume(int vol) {\r\n            // float v = ((float) vol) / 100.0F;\r\n            AudioManager am = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);\r\n            int max = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC);\r\n            am.setStreamVolume(AudioManager.STREAM_MUSIC, vol, 0);\r\n        }\r\n\r\n        @Override\r\n        public int getVolume() {\r\n            AudioManager am = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);\r\n            return am.getStreamVolume(AudioManager.STREAM_MUSIC);\r\n        }\r\n\r\n        @Override\r\n        public boolean isVideo() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean isFullScreen() {\r\n            return fullScreen || nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public void setFullScreen(boolean fullScreen) {\r\n            this.fullScreen = fullScreen;\r\n            if (fullScreen) {\r\n                bounds = new Rectangle(getBounds());\r\n                setX(0);\r\n                setY(0);\r\n                setWidth(Display.getInstance().getDisplayWidth());\r\n                setHeight(Display.getInstance().getDisplayHeight());\r\n            } else {\r\n                if (bounds != null) {\r\n                    setX(bounds.getX());\r\n                    setY(bounds.getY());\r\n                    setWidth(bounds.getSize().getWidth());\r\n                    setHeight(bounds.getSize().getHeight());\r\n                }\r\n            }\r\n            repaint();\r\n        }\r\n\r\n        @Override\r\n        public Component getVideoComponent() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n        protected Dimension calcPreferredSize() {\r\n            if(nativeVideo != null){\r\n                return new Dimension(nativeVideo.getWidth(), nativeVideo.getHeight());\r\n            }\r\n            return new Dimension();\r\n        }\r\n\r\n        @Override\r\n        public void setWidth(final int width) {\r\n            super.setWidth(width);\r\n            final int currH = getHeight();\r\n            if(nativeVideo != null){\r\n                activity.runOnUiThread(new Runnable() {\r\n\r\n                    public void run() {\r\n                        float nh = nativeVideo.getHeight();\r\n                        float nw = nativeVideo.getWidth();\r\n                        float w = width;\r\n                        float h = currH;\r\n                        if (nh != 0 && nw != 0) {\r\n                            h = width * nh / nw;\r\n                            if (h > getHeight()) {\r\n                                h = getHeight();\r\n                                w = h * nw / nh;\r\n                            }\r\n                            if (w > getWidth()) {\r\n                                w = getWidth();\r\n                                h = w * nh / nw;\r\n                            }\r\n                        }\r\n                        RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams((int)w, (int)h);\r\n                        layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n                        layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n                        nativeVideo.setLayoutParams(layout);\r\n                        nativeVideo.requestLayout();\r\n                        nativeVideo.getHolder().setSizeFromLayout();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setHeight(final int height) {\r\n            super.setHeight(height);\r\n            final int currW = getWidth();\r\n            if(nativeVideo != null){\r\n                activity.runOnUiThread(new Runnable() {\r\n\r\n                    public void run() {\r\n                        float nh = nativeVideo.getHeight();\r\n                        float nw = nativeVideo.getWidth();\r\n                        float h = height;\r\n                        float w = currW;\r\n                        if (nh != 0 && nw != 0) {\r\n                            w = h * nw / nh;\r\n                            if (h > getHeight()) {\r\n                                h = getHeight();\r\n                                w = h * nw / nh;\r\n                            }\r\n                            if (w > getWidth()) {\r\n                                w = getWidth();\r\n                                h = w * nh / nw;\r\n                            }\r\n                        }\r\n                        RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams((int)w, (int)h);\r\n                        layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n                        layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n                        nativeVideo.setLayoutParams(layout);\r\n                        nativeVideo.requestLayout();\r\n                        nativeVideo.getHolder().setSizeFromLayout();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setNativePlayerMode(boolean nativePlayer) {\r\n            this.nativePlayer = nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public boolean isNativePlayerMode() {\r\n            return nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public boolean isPlaying() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.isPlaying();\r\n            }\r\n            return false;\r\n        }\r\n\r\n        public void setVariable(String key, Object value) {\r\n            if (nativeVideo != null && Media.VARIABLE_NATIVE_CONTRLOLS_EMBEDDED.equals(key) && value instanceof Boolean) {\r\n                setNativeController((Boolean)value);\r\n            }\r\n        }\r\n\r\n        public Object getVariable(String key) {\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void addMediaCompletionHandler(Runnable onComplete) {\r\n            addCompletionHandler(onComplete);\r\n        }\r\n\r\n        \r\n        \r\n        private void addCompletionHandler(Runnable onCompletion) {\r\n            synchronized(this) {\r\n                if (completionHandlers == null) {\r\n                    completionHandlers = new ArrayList<Runnable>();\r\n                }\r\n                completionHandlers.add(onCompletion);\r\n            }\r\n        }\r\n        \r\n        private void removeCompletionHandler(Runnable onCompletion) {\r\n            synchronized(this) {\r\n                if (completionHandlers != null) {\r\n                    completionHandlers.remove(onCompletion);\r\n                }\r\n            }\r\n        }\r\n\r\n      \r\n    }\r\n\r\n\r\n    private String getImageFilePath(Uri uri) {\r\n\r\n        File file = new File(uri.getPath());\r\n        String scheme = uri.getScheme();\r\n        //String[] filePaths = file.getPath().split(\":\");\r\n        //String image_id = filePath[filePath.length - 1];\r\n        String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n        Cursor cursor = getContext().getContentResolver().query(\r\n                android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\r\n                new String[]{ MediaStore.Images.Media.DATA},\r\n                null,\r\n                null,\r\n                null\r\n        );\r\n        cursor.moveToFirst();\r\n        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n        String filePath = cursor.getString(columnIndex);\r\n        cursor.close();\r\n\r\n        if (filePath == null || \"content\".equals(scheme)) {\r\n            //if the file is not on the filesystem download it and save it\r\n            //locally\r\n            try {\r\n                InputStream inputStream = getContext().getContentResolver().openInputStream(uri);\r\n                if (inputStream != null) {\r\n                    String name = new File(uri.toString()).getName();//getContentName(getContext().getContentResolver(), uri);\r\n                    if (name != null) {\r\n                        String homePath = getAppHomePath();\r\n                        if (homePath.endsWith(\"/\")) {\r\n                            homePath = homePath.substring(0, homePath.length()-1);\r\n                        }\r\n                        filePath = homePath\r\n                                + getFileSystemSeparator() + name;\r\n                        File f = new File(removeFilePrefix(filePath));\r\n                        OutputStream tmp = createFileOuputStream(f);\r\n                        byte[] buffer = new byte[1024];\r\n                        int read = -1;\r\n                        while ((read = inputStream.read(buffer)) > -1) {\r\n                            tmp.write(buffer, 0, read);\r\n                        }\r\n                        tmp.close();\r\n                        inputStream.close();\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        //long len = new com.codename1.io.File(filePath).length();\r\n        return filePath;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    @Override\r\n    public void onActivityResult(int requestCode, int resultCode, Intent intent) {\r\n\r\n        if (requestCode == ZOOZ_PAYMENT) {\r\n            ((IntentResultListener) pur).onActivityResult(requestCode, resultCode, intent);\r\n            return;\r\n        }\r\n\r\n        if (requestCode == REQUEST_SELECT_FILE || requestCode == FILECHOOSER_RESULTCODE) {\r\n            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n                if (requestCode == REQUEST_SELECT_FILE) {\r\n                    if (uploadMessage == null) {\r\n                        return;\r\n                    }\r\n                    uploadMessage.onReceiveValue(WebChromeClient.FileChooserParams.parseResult(resultCode, intent));\r\n                    uploadMessage = null;\r\n                }\r\n            }\r\n            else if (requestCode == FILECHOOSER_RESULTCODE) {\r\n                if (null == mUploadMessage) {\r\n                    return;\r\n                }\r\n            // Use MainActivity.RESULT_OK if you're implementing WebView inside Fragment\r\n            // Use RESULT_OK only if you're implementing WebView inside an Activity\r\n                Uri result = intent == null || resultCode != Activity.RESULT_OK ? null : intent.getData();\r\n                mUploadMessage.onReceiveValue(result);\r\n                mUploadMessage = null;\r\n            }\r\n            else {\r\n\r\n                Toast.makeText(getActivity().getApplicationContext(), \"Failed to Upload File\", Toast.LENGTH_LONG).show();\r\n            }\r\n            return;\r\n        }\r\n\r\n        \r\n        if (resultCode == Activity.RESULT_OK) {\r\n            if (requestCode == CAPTURE_IMAGE) {\r\n                try {\r\n                    String imageUri = (String) Storage.getInstance().readObject(\"imageUri\");\r\n                    Vector pathandId = StringUtil.tokenizeString(imageUri, \";\");\r\n                    String path = (String)pathandId.get(0);\r\n                    String lastId = (String)pathandId.get(1);\r\n                    Storage.getInstance().deleteStorageFile(\"imageUri\");\r\n                    clearMediaDB(lastId, path);\r\n                    callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                    return;\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (requestCode == CAPTURE_VIDEO) {\r\n                String path = (String) Storage.getInstance().readObject(\"videoUri\");\r\n                Storage.getInstance().deleteStorageFile(\"videoUri\");\r\n                callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                return;\r\n            } else if (requestCode == CAPTURE_AUDIO) {\r\n                Uri data = intent.getData();\r\n                String path = convertImageUriToFilePath(data, getContext());\r\n                callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                return;\r\n                \r\n            } else if (requestCode == OPEN_GALLERY_MULTI) {\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\r\n                    if(intent.getClipData() != null){\r\n                        // If it was a multi-request\r\n                        ArrayList<String> selectedPaths = new ArrayList<String>();\r\n                        int count = intent.getClipData().getItemCount();\r\n                        for (int i=0; i<count; i++){\r\n\r\n                            Uri uri = intent.getClipData().getItemAt(i).getUri();\r\n                            String p = getImageFilePath(uri);\r\n                            if (p != null) {\r\n                                selectedPaths.add(p);\r\n                            }\r\n                        }\r\n                        callback.fireActionEvent(new ActionEvent(selectedPaths.toArray(new String[selectedPaths.size()])));\r\n                        return;\r\n                    }\r\n                } else {\r\n                    com.codename1.io.Log.e(new RuntimeException(\"OPEN_GALLERY_MULTI requires android sdk 16 (jelly bean) or higher\"));\r\n                    callback.fireActionEvent(null);\r\n                }\r\n\r\n                Uri selectedImage = intent.getData();\r\n                String scheme = intent.getScheme();\r\n\r\n                String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n                Cursor cursor = getContext().getContentResolver().query(selectedImage, filePathColumn, null, null, null);\r\n\r\n                // this happens on Android devices, not exactly sure what the use case is\r\n                if(cursor == null) {\r\n                    callback.fireActionEvent(null);\r\n                    return;\r\n                }\r\n\r\n                cursor.moveToFirst();\r\n                int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n                String filePath = cursor.getString(columnIndex);\r\n                cursor.close();\r\n                boolean fileExists = false;\r\n                if (filePath != null) {\r\n                    File file = new File(filePath);\r\n                    fileExists = file.exists() && file.canRead();\r\n                }\r\n\r\n                if (!fileExists && \"content\".equals(scheme)) {\r\n                    //if the file is not on the filesystem download it and save it\r\n                    //locally\r\n                    try {\r\n                        InputStream inputStream = getContext().getContentResolver().openInputStream(selectedImage);\r\n                        if (inputStream != null) {\r\n                            String name = getContentName(getContext().getContentResolver(), selectedImage);\r\n                            if (name != null) {\r\n                                filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                File f = new File(removeFilePrefix(filePath));\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = inputStream.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                inputStream.close();\r\n                            }\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n\r\n                callback.fireActionEvent(new ActionEvent(new String[]{filePath}));\r\n                return;\r\n            } else if (requestCode == OPEN_GALLERY) {\r\n                \r\n                Uri selectedImage = intent.getData();\r\n                String scheme = intent.getScheme();\r\n\r\n                String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n                Cursor cursor = getContext().getContentResolver().query(selectedImage, filePathColumn, null, null, null);\r\n\r\n                // this happens on Android devices, not exactly sure what the use case is\r\n                if(cursor == null) {\r\n                    callback.fireActionEvent(null);\r\n                    return;\r\n                }\r\n\r\n                cursor.moveToFirst();\r\n                int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n                String filePath = cursor.getString(columnIndex);\r\n                cursor.close();\r\n                boolean fileExists = false;\r\n                if (filePath != null) {\r\n                    File file = new File(filePath);\r\n                    fileExists = file.exists() && file.canRead();\r\n                }\r\n\r\n                if (!fileExists && \"content\".equals(scheme)) {\r\n                    //if the file is not on the filesystem download it and save it\r\n                    //locally\r\n                    try {\r\n                        InputStream inputStream = getContext().getContentResolver().openInputStream(selectedImage);\r\n                        if (inputStream != null) {\r\n                            String name = getContentName(getContext().getContentResolver(), selectedImage);\r\n                            if (name != null) {\r\n                                filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                File f = new File(removeFilePrefix(filePath));\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = inputStream.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                inputStream.close();\r\n                            }\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n\r\n                callback.fireActionEvent(new ActionEvent(filePath));\r\n                return;\r\n            } else {\r\n                if(callback != null) {\r\n                    callback.fireActionEvent(new ActionEvent(\"ok\"));\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        //clean imageUri\r\n        String imageUri = (String) Storage.getInstance().readObject(\"imageUri\");\r\n        if(imageUri != null){\r\n            Storage.getInstance().deleteStorageFile(\"imageUri\");\r\n        }\r\n\r\n        if(callback != null) {\r\n            callback.fireActionEvent(null);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void capturePhoto(ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot capture photo in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to take a picture\")){\r\n            return;\r\n        }\r\n        if (getRequestedPermissions().contains(Manifest.permission.CAMERA)) {\r\n            // Normally we don't need to request the CAMERA permission since we use\r\n            // the ACTION_IMAGE_CAPTURE intent, which handles permissions itself.\r\n            // BUT: If the camera permission is included in the Manifest file, the \r\n            // intent will defer to the app's permissions, and on Android 6, \r\n            // the permission is denied unless we do the runtime check for permission.\r\n            // See https://github.com/codenameone/CodenameOne/issues/2409#issuecomment-391696058\r\n            if(!checkForPermission(Manifest.permission.CAMERA, \"This is required to take a picture\")){\r\n                return;\r\n            }\r\n        }\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent intent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);\r\n\r\n        File newFile = getOutputMediaFile(false);\r\n        newFile.getParentFile().mkdirs();\r\n        newFile.getParentFile().setWritable(true, false);\r\n        //Uri imageUri = Uri.fromFile(newFile);\r\n        Uri imageUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, imageUri);\r\n\r\n        String lastImageID = getLastImageId();\r\n        Storage.getInstance().writeObject(\"imageUri\", newFile.getAbsolutePath() + \";\" + lastImageID);\r\n\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, imageUri);\r\n        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n        \r\n        if (Build.VERSION.SDK_INT < 21) {\r\n            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n            for (ResolveInfo resolveInfo : resInfoList) {\r\n                String packageName = resolveInfo.activityInfo.packageName;\r\n                getContext().grantUriPermission(packageName, imageUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n            }\r\n        }\r\n\r\n        getActivity().startActivityForResult(intent, CAPTURE_IMAGE);\r\n    }\r\n\r\n    @Override\r\n    public void captureVideo(ActionListener response) {\r\n        captureVideo(null, response);\r\n    }\r\n    \r\n    @Override\r\n    public void captureVideo(VideoCaptureConstraints cnst, ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot capture video in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to take a video\")){\r\n            return;\r\n        }\r\n        if (getRequestedPermissions().contains(Manifest.permission.CAMERA)) {\r\n            // Normally we don't need to request the CAMERA permission since we use\r\n            // the ACTION_VIDEO_CAPTURE intent, which handles permissions itself.\r\n            // BUT: If the camera permission is included in the Manifest file, the \r\n            // intent will defer to the app's permissions, and on Android 6, \r\n            // the permission is denied unless we do the runtime check for permission.\r\n            // See https://github.com/codenameone/CodenameOne/issues/2409#issuecomment-391696058\r\n            if(!checkForPermission(Manifest.permission.CAMERA, \"This is required to take a video\")){\r\n                return;\r\n            }\r\n        }\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent intent = new Intent(android.provider.MediaStore.ACTION_VIDEO_CAPTURE);\r\n        if (cnst != null) {\r\n            switch (cnst.getQuality()) {\r\n                case VideoCaptureConstraints.QUALITY_LOW:\r\n                    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0);\r\n                    break;\r\n                case VideoCaptureConstraints.QUALITY_HIGH:\r\n                    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);\r\n                    break;\r\n            }\r\n            \r\n            if (cnst.getMaxFileSize() > 0) {\r\n                intent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, cnst.getMaxFileSize());\r\n            }\r\n            if (cnst.getMaxLength() > 0) {\r\n                intent.putExtra(MediaStore.EXTRA_DURATION_LIMIT, cnst.getMaxLength());\r\n            }\r\n        }\r\n        \r\n\r\n        File newFile = getOutputMediaFile(true);\r\n        newFile.getParentFile().mkdirs();\r\n        newFile.getParentFile().setWritable(true, false);\r\n        Uri videoUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n\r\n        Storage.getInstance().writeObject(\"videoUri\", newFile.getAbsolutePath());\r\n\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, videoUri);\r\n        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n        if (Build.VERSION.SDK_INT < 21) {\r\n            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n            for (ResolveInfo resolveInfo : resInfoList) {\r\n                String packageName = resolveInfo.activityInfo.packageName;\r\n                getContext().grantUriPermission(packageName, videoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n            }\r\n        }\r\n        \r\n        this.getActivity().startActivityForResult(intent, CAPTURE_VIDEO);\r\n    }\r\n\r\n    public void captureAudio(final ActionListener response) {\r\n\r\n        if(!checkForPermission(Manifest.permission.RECORD_AUDIO, \"This is required to record the audio\")){\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            final Form current = Display.getInstance().getCurrent();\r\n\r\n            final File temp = File.createTempFile(\"mtmp\", \".3gpp\");\r\n            temp.deleteOnExit();\r\n\r\n            if (recorder != null) {\r\n                recorder.release();\r\n            }\r\n            recorder = new MediaRecorder();\r\n            recorder.setAudioSource(MediaRecorder.AudioSource.MIC);\r\n            recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\r\n            recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_WB);\r\n            recorder.setOutputFile(temp.getAbsolutePath());\r\n\r\n            final Form recording = new Form(\"Recording\");\r\n            recording.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n            recording.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n            recording.setLayout(new BorderLayout());\r\n\r\n            recorder.prepare();\r\n            recorder.start();\r\n\r\n            final Label time = new Label(\"00:00\");\r\n            time.getAllStyles().setAlignment(Component.CENTER);\r\n            Font f = Font.createSystemFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_LARGE);\r\n            f = f.derive(getDisplayHeight() / 10, Font.STYLE_PLAIN);\r\n            time.getAllStyles().setFont(f);\r\n            recording.addComponent(BorderLayout.CENTER, time);\r\n\r\n            recording.registerAnimated(new Animation() {\r\n\r\n                long current = System.currentTimeMillis();\r\n                long zero = current;\r\n                int sec = 0;\r\n\r\n                public boolean animate() {\r\n                    long now = System.currentTimeMillis();\r\n                    if (now - current > 1000) {\r\n                        current = now;\r\n                        sec++;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                public void paint(Graphics g) {\r\n                    int seconds = sec % 60;\r\n                    int minutes = sec / 60;\r\n\r\n                    String secStr = seconds < 10 ? \"0\" + seconds : \"\" + seconds;\r\n                    String minStr = minutes < 10 ? \"0\" + minutes : \"\" + minutes;\r\n\r\n                    String txt = minStr + \":\" + secStr;\r\n                    time.setText(txt);\r\n                }\r\n            });\r\n\r\n            Container south = new Container(new com.codename1.ui.layouts.GridLayout(1, 2));\r\n            Command cancel = new Command(\"Cancel\") {\r\n\r\n                @Override\r\n                public void actionPerformed(ActionEvent evt) {\r\n                    if (recorder != null) {\r\n                        recorder.stop();\r\n                        recorder.release();\r\n                        recorder = null;\r\n                    }\r\n                    current.showBack();\r\n                    response.actionPerformed(null);\r\n                }\r\n\r\n            };\r\n            recording.setBackCommand(cancel);\r\n            south.add(new com.codename1.ui.Button(cancel));\r\n            south.add(new com.codename1.ui.Button(new Command(\"Save\") {\r\n\r\n                @Override\r\n                public void actionPerformed(ActionEvent evt) {\r\n                    if (recorder != null) {\r\n                        recorder.stop();\r\n                        recorder.release();\r\n                        recorder = null;\r\n                    }\r\n                    current.showBack();\r\n                    response.actionPerformed(new ActionEvent(temp.getAbsolutePath()));\r\n                }\r\n\r\n            }));\r\n            recording.addComponent(BorderLayout.SOUTH, south);\r\n            recording.show();\r\n\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n            throw new RuntimeException(\"failed to start audio recording\");\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Opens the device image gallery\r\n     *\r\n     * @param response callback for the resulting image\r\n     *\r\n     * \r\n     * DISABLING:  openGallery() should take care of this\r\n    public void openImageGallery(ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot open image gallery in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to browse the photos\")){\r\n            return;\r\n        }\r\n\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent galleryIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.INTERNAL_CONTENT_URI);\r\n        this.getActivity().startActivityForResult(galleryIntent, OPEN_GALLERY);\r\n    }\r\n    * */\r\n\r\n    @Override\r\n    public boolean isGalleryTypeSupported(int type) {\r\n        if (super.isGalleryTypeSupported(type)) {\r\n            return true;\r\n        }\r\n        if (type == -9999 || type == -9998) {\r\n            return true;\r\n        }\r\n        if (android.os.Build.VERSION.SDK_INT >= 16) {\r\n            switch (type) {\r\n\r\n                case Display.GALLERY_ALL_MULTI:\r\n                case Display.GALLERY_VIDEO_MULTI:\r\n                case Display.GALLERY_IMAGE_MULTI:\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    \r\n    public void openGallery(final ActionListener response, int type){\r\n        if (!isGalleryTypeSupported(type)) {\r\n            throw new IllegalArgumentException(\"Gallery type \"+type+\" not supported on this platform.\");\r\n        }\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot open galery in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to browse the photos\")){\r\n            return;\r\n        }\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        final boolean multi;\r\n        switch (type) {\r\n            case Display.GALLERY_ALL_MULTI:\r\n                multi=true;\r\n                type = Display.GALLERY_ALL;\r\n                break;\r\n            case Display.GALLERY_VIDEO_MULTI:\r\n                multi=true;\r\n                type = Display.GALLERY_VIDEO;\r\n                break;\r\n            case Display.GALLERY_IMAGE_MULTI:\r\n                multi = true;\r\n                type = Display.GALLERY_IMAGE;\r\n                break;\r\n            case -9998:\r\n                multi = true;\r\n                type = -9999;\r\n                break;\r\n            default:\r\n                multi = false;\r\n        }\r\n        \r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent galleryIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.INTERNAL_CONTENT_URI);\r\n        if (multi) {\r\n            galleryIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\r\n        }\r\n        if(type == Display.GALLERY_VIDEO){\r\n            galleryIntent.setType(\"video/*\");\r\n        }else if(type == Display.GALLERY_IMAGE){\r\n            galleryIntent.setType(\"image/*\");\r\n        }else if(type == Display.GALLERY_ALL){\r\n            galleryIntent.setType(\"image/* video/*\");\r\n        }else if (type == -9999) {\r\n            galleryIntent = new Intent();\r\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {\r\n                galleryIntent.setAction(Intent.ACTION_OPEN_DOCUMENT);\r\n            } else {\r\n                galleryIntent.setAction(Intent.ACTION_GET_CONTENT);\r\n            }\r\n            galleryIntent.addCategory(Intent.CATEGORY_OPENABLE);\r\n\r\n            // set MIME type for image\r\n            galleryIntent.setType(\"*/*\");\r\n            galleryIntent.putExtra(Intent.EXTRA_MIME_TYPES, Display.getInstance().getProperty(\"android.openGallery.accept\", \"*/*\").split(\",\"));\r\n        }else{\r\n            galleryIntent.setType(\"*/*\");\r\n        }\r\n        this.getActivity().startActivityForResult(galleryIntent, multi ? OPEN_GALLERY_MULTI: OPEN_GALLERY);\r\n    }\r\n\r\n    class NativeImage extends Image {\r\n\r\n        public NativeImage(Bitmap nativeImage) {\r\n            super(nativeImage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a File for saving an image or video\r\n     */\r\n    private File getOutputMediaFile(boolean isVideo) {\r\n        // To be safe, you should check that the SDCard is mounted\r\n        // using Environment.getExternalStorageState() before doing this.\r\n        if (getActivity() != null) {\r\n            return GetOutputMediaFile.getOutputMediaFile(isVideo, getActivity());\r\n        } else {\r\n            return GetOutputMediaFile.getOutputMediaFile(isVideo, getContext(), \"Video\");\r\n        }\r\n    }\r\n\r\n    private static class GetOutputMediaFile {\r\n\r\n        public static File getOutputMediaFile(boolean isVideo,Activity activity) {\r\n            activity.getComponentName();\r\n            return getOutputMediaFile(isVideo, activity, activity.getTitle());\r\n        }\r\n\r\n        public static File getOutputMediaFile(boolean isVideo, Context activity, CharSequence title) {\r\n\r\n\r\n            File mediaStorageDir = new File(new File(getContext().getCacheDir(), \"intent_files\"), \"\"+title);\r\n\r\n            // Create the storage directory if it does not exist\r\n            if (!mediaStorageDir.exists()) {\r\n                if (!mediaStorageDir.mkdirs()) {\r\n                    Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Create a media file name\r\n            String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\r\n            File mediaFile = null;\r\n            if (!isVideo) {\r\n                mediaFile = new File(mediaStorageDir.getPath() + File.separator\r\n                        + \"IMG_\" + timeStamp + \".jpg\");\r\n            } else {\r\n                mediaFile = new File(mediaStorageDir.getPath() + File.separator\r\n                        + \"VID_\" + timeStamp + \".mp4\");\r\n            }\r\n\r\n            return mediaFile;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void systemOut(String content){\r\n        Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), content);\r\n    }\r\n\r\n    private boolean hasAndroidMarket() {\r\n        return hasAndroidMarket(getContext());\r\n    }\r\n\r\n    private static final String GooglePlayStorePackageNameOld = \"com.google.market\";\r\n    private static final String GooglePlayStorePackageNameNew = \"com.android.vending\";\r\n\r\n    /**\r\n     * Indicates whether this is a Google certified device which means that it\r\n     * has Android market etc.\r\n     */\r\n    public static boolean hasAndroidMarket(Context activity) {\r\n        final PackageManager packageManager = activity.getPackageManager();\r\n        List<PackageInfo> packages = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);\r\n        for (PackageInfo packageInfo : packages) {\r\n            if (packageInfo.packageName.equals(GooglePlayStorePackageNameOld) ||\r\n                    packageInfo.packageName.equals(GooglePlayStorePackageNameNew)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public void registerPush(Hashtable metaData, boolean noFallback) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        boolean has = hasAndroidMarket();\r\n        if (!has) {\r\n            Log.d(\"Codename One\", \"Device doesn't have Android market/google play can't register for push!\");\r\n            return;\r\n        }\r\n        String id = (String)metaData.get(com.codename1.push.Push.GOOGLE_PUSH_KEY);\r\n        if (id == null) {\r\n            id = Display.getInstance().getProperty(\"gcm.sender_id\", null);\r\n        }\r\n        if(has) {\r\n            Log.d(\"Codename One\", \"Sending async push request for id: \" + id);\r\n            ((CodenameOneActivity) getActivity()).registerForPush(id);\r\n        } else {\r\n            PushNotificationService.forceStartService(getActivity().getPackageName() + \".PushNotificationService\", getActivity());\r\n            if(!registerServerPush(id, getApplicationKey(), (byte)10, \"\", getPackageName())) {\r\n                sendPushRegistrationError(\"Server registration error\", 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void stopPollingLoop() {\r\n        stopPolling();\r\n    }\r\n\r\n    public static void registerPolling() {\r\n        registerPollingFallback();\r\n    }\r\n\r\n    @Override\r\n    public void deregisterPush() {\r\n        boolean has = hasAndroidMarket();\r\n        if (has) {\r\n            ((CodenameOneActivity) getActivity()).stopReceivingPush();\r\n            deregisterPushFromServer();\r\n        } else {\r\n            super.deregisterPush();\r\n        }\r\n    }\r\n\r\n    private static String convertImageUriToFilePath(Uri imageUri, Context activity) {\r\n        Cursor cursor = null;\r\n        String[] proj = {MediaStore.Images.Media.DATA};\r\n        cursor = activity.getContentResolver().query(imageUri, proj, null, null, null);\r\n        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);\r\n        cursor.moveToFirst();\r\n        String path = cursor.getString(column_index);\r\n        cursor.close();\r\n        return path;\r\n    }\r\n\r\n    class CN1MediaController extends MediaController {\r\n\r\n        public CN1MediaController() {\r\n            super(getActivity());\r\n        }\r\n\r\n        @Override\r\n        public boolean dispatchKeyEvent(KeyEvent event) {\r\n            int keycode = event.getKeyCode();\r\n            keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n            if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK) {\r\n                Display.getInstance().keyPressed(keycode);\r\n                Display.getInstance().keyReleased(keycode);\r\n                return true;\r\n            } else {\r\n                return super.dispatchKeyEvent(event);\r\n            }\r\n        }\r\n    }\r\n    private L10NManager l10n;\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public L10NManager getLocalizationManager() {\r\n        if (l10n == null) {\r\n            final Locale l = Locale.getDefault();\r\n            l10n = new L10NManager(l.getLanguage(), l.getCountry()) {\r\n                public double parseDouble(String localeFormattedDecimal) {\r\n                    try {\r\n                        return NumberFormat.getNumberInstance().parse(localeFormattedDecimal).doubleValue();\r\n                    } catch (ParseException err) {\r\n                        return Double.parseDouble(localeFormattedDecimal);\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public String getLongMonthName(Date date) {\r\n                    java.text.SimpleDateFormat fmt = new java.text.SimpleDateFormat(\"MMMM\", l);\r\n                    return fmt.format(date);\r\n                }\r\n\r\n                @Override\r\n                public String getShortMonthName(Date date) {\r\n                    java.text.SimpleDateFormat fmt = new java.text.SimpleDateFormat(\"MMM\", l);\r\n                    return fmt.format(date);\r\n                }\r\n                \r\n                \r\n\r\n                public String format(int number) {\r\n                    return NumberFormat.getNumberInstance().format(number);\r\n                }\r\n\r\n                public String format(double number) {\r\n                    return NumberFormat.getNumberInstance().format(number);\r\n                }\r\n\r\n                public String formatCurrency(double currency) {\r\n                    return NumberFormat.getCurrencyInstance().format(currency);\r\n                }\r\n\r\n                public String formatDateLongStyle(Date d) {\r\n                    return DateFormat.getDateInstance(DateFormat.LONG).format(d);\r\n                }\r\n\r\n                public String formatDateShortStyle(Date d) {\r\n                    return DateFormat.getDateInstance(DateFormat.SHORT).format(d);\r\n                }\r\n\r\n                public String formatDateTime(Date d) {\r\n                    return DateFormat.getDateTimeInstance().format(d);\r\n                }\r\n\r\n                public String formatDateTimeMedium(Date d) {\r\n                    DateFormat dd = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);\r\n                    return dd.format(d);\r\n                }\r\n\r\n                public String formatDateTimeShort(Date d) {\r\n                    DateFormat dd = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\r\n                    return dd.format(d);\r\n                }\r\n\r\n                public String getCurrencySymbol() {\r\n                    return NumberFormat.getInstance().getCurrency().getSymbol();\r\n                }\r\n\r\n                public void setLocale(String locale, String language) {\r\n                    super.setLocale(locale, language);\r\n                    Locale l = new Locale(language, locale);\r\n                    Locale.setDefault(l);\r\n                }\r\n            };\r\n        }\r\n        return l10n;\r\n    }\r\n    private com.codename1.ui.util.ImageIO imIO;\r\n\r\n    @Override\r\n    public com.codename1.ui.util.ImageIO getImageIO() {\r\n        if (imIO == null) {\r\n            imIO = new com.codename1.ui.util.ImageIO() {\r\n                @Override\r\n                public Dimension getImageSize(String imageFilePath) throws IOException {\r\n                    BitmapFactory.Options o = new BitmapFactory.Options();\r\n                    o.inJustDecodeBounds = true;\r\n                    o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                    InputStream fis = createFileInputStream(imageFilePath);\r\n                    BitmapFactory.decodeStream(fis, null, o);\r\n                    fis.close();\r\n\r\n                    ExifInterface exif = new ExifInterface(removeFilePrefix(imageFilePath));\r\n\r\n                    // if the image is in portrait mode\r\n                    int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n                    if(orientation == ExifInterface.ORIENTATION_ROTATE_90 || orientation == ExifInterface.ORIENTATION_ROTATE_270) {\r\n                        return new Dimension(o.outHeight, o.outWidth);\r\n                    }\r\n                    return new Dimension(o.outWidth, o.outHeight);\r\n                }\r\n\r\n                private Dimension getImageSizeNoRotation(String imageFilePath) throws IOException {\r\n                    BitmapFactory.Options o = new BitmapFactory.Options();\r\n                    o.inJustDecodeBounds = true;\r\n                    o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                    InputStream fis = createFileInputStream(imageFilePath);\r\n                    BitmapFactory.decodeStream(fis, null, o);\r\n                    fis.close();\r\n\r\n                    return new Dimension(o.outWidth, o.outHeight);\r\n                }\r\n\r\n                @Override\r\n                public void save(InputStream image, OutputStream response, String format, int width, int height, float quality) throws IOException {\r\n                    Bitmap.CompressFormat f = Bitmap.CompressFormat.PNG;\r\n                    if (format == FORMAT_JPEG) {\r\n                        f = Bitmap.CompressFormat.JPEG;\r\n                    }\r\n                    Image img = Image.createImage(image).scaled(width, height);\r\n                    Bitmap b = (Bitmap) img.getImage();\r\n                    b.compress(f, (int) (quality * 100), response);\r\n                }\r\n\r\n                @Override\r\n                public String saveAndKeepAspect(String imageFilePath, String preferredOutputPath, String format, int width, int height, float quality, boolean onlyDownscale, boolean scaleToFill) throws IOException{\r\n                    ExifInterface exif = new ExifInterface(removeFilePrefix(imageFilePath));\r\n                    Dimension d = getImageSizeNoRotation(imageFilePath);\r\n                    if(onlyDownscale) {\r\n                        if(scaleToFill) {\r\n                            if(d.getHeight() <= height || d.getWidth() <= width) {\r\n                                return imageFilePath;\r\n                            }\r\n                        } else {\r\n                            if(d.getHeight() <= height && d.getWidth() <= width) {\r\n                                return imageFilePath;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    float ratio = ((float)d.getWidth()) / ((float)d.getHeight());\r\n                    int heightBasedOnWidth = (int)(((float)width) / ratio);\r\n                    int widthBasedOnHeight = (int)(((float)height) * ratio);\r\n                    if(scaleToFill) {\r\n                        if(heightBasedOnWidth >= width) {\r\n                            height = heightBasedOnWidth;\r\n                        } else {\r\n                            width = widthBasedOnHeight;\r\n                        }\r\n                    } else {\r\n                        if(heightBasedOnWidth > width) {\r\n                            width = widthBasedOnHeight;\r\n                        } else {\r\n                            height = heightBasedOnWidth;\r\n                        }\r\n                    }\r\n                    sampleSizeOverride = Math.max(d.getWidth()/width, d.getHeight()/height);\r\n                    OutputStream im = FileSystemStorage.getInstance().openOutputStream(preferredOutputPath);\r\n                    Image i = Image.createImage(imageFilePath);\r\n                    Image newImage = i.scaled(width, height);\r\n                    int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n\r\n                    int angle = 0;\r\n                    switch (orientation) {\r\n                        case ExifInterface.ORIENTATION_ROTATE_90:\r\n                            angle = 90;\r\n                            break;\r\n                        case ExifInterface.ORIENTATION_ROTATE_180:\r\n                            angle = 180;\r\n                            break;\r\n                        case ExifInterface.ORIENTATION_ROTATE_270:\r\n                            angle = 270;\r\n                            break;\r\n                    }\r\n                    if (angle != 0) {\r\n                        Matrix mat = new Matrix();\r\n                        mat.postRotate(angle);\r\n                        Bitmap b = (Bitmap)newImage.getImage();\r\n                        Bitmap correctBmp = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), mat, true);\r\n                        b.recycle();\r\n                        newImage.dispose();\r\n                        Image tmp = Image.createImage(correctBmp);\r\n                        newImage = tmp;\r\n                        save(tmp, im, format, quality);\r\n                    } else {\r\n                        save(imageFilePath, im, format, width, height, quality);\r\n                    }\r\n                    sampleSizeOverride =  -1;\r\n                    return preferredOutputPath;\r\n                }\r\n\r\n                @Override\r\n                public void save(String imageFilePath, OutputStream response, String format, int width, int height, float quality) throws IOException {\r\n                    Image i = Image.createImage(imageFilePath);\r\n                    Image newImage = i.scaled(width, height);\r\n                    save(newImage, response, format, quality);\r\n                    newImage.dispose();\r\n                    i.dispose();\r\n                }\r\n\r\n                @Override\r\n                protected void saveImage(Image img, OutputStream response, String format, float quality) throws IOException {\r\n                    Bitmap.CompressFormat f = Bitmap.CompressFormat.PNG;\r\n                    if (format == FORMAT_JPEG) {\r\n                        f = Bitmap.CompressFormat.JPEG;\r\n                    }\r\n                    Bitmap b = (Bitmap) img.getImage();\r\n                    b.compress(f, (int) (quality * 100), response);\r\n                }\r\n\r\n                @Override\r\n                public boolean isFormatSupported(String format) {\r\n                    return format == FORMAT_JPEG || format == FORMAT_PNG;\r\n                }\r\n            };\r\n        }\r\n        return imIO;\r\n    }\r\n\r\n    @Override\r\n    public Database openOrCreateDB(String databaseName) throws IOException {\r\n        SQLiteDatabase db;\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            db = SQLiteDatabase.openOrCreateDatabase(FileSystemStorage.getInstance().toNativePath(databaseName), null);\r\n        } else {\r\n            db = getContext().openOrCreateDatabase(databaseName, getContext().MODE_PRIVATE, null);\r\n        }\r\n        return new AndroidDB(db);\r\n    }\r\n\r\n    @Override\r\n    public boolean isDatabaseCustomPathSupported() {\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n    @Override\r\n    public void deleteDB(String databaseName) throws IOException {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            deleteFile(databaseName);\r\n            return;\r\n        }\r\n        getContext().deleteDatabase(databaseName);\r\n    }\r\n\r\n    @Override\r\n    public boolean existsDB(String databaseName) {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            return exists(databaseName);\r\n        }\r\n        File db = new File(getContext().getApplicationInfo().dataDir + \"/databases/\" + databaseName);\r\n        return db.exists();\r\n    }\r\n\r\n    public String getDatabasePath(String databaseName) {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            return databaseName;\r\n        }\r\n        File db = new File(getContext().getApplicationInfo().dataDir + \"/databases/\" + databaseName);\r\n        return db.getAbsolutePath();\r\n    }\r\n\r\n    public boolean isNativeTitle() {\r\n        if(com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n            return false;\r\n        }\r\n        Form f = getCurrentForm();\r\n        boolean nativeCommand;\r\n        if(f != null){\r\n            nativeCommand = f.getMenuBar().getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }else{\r\n            nativeCommand = getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }\r\n        return hasActionBar() && nativeCommand;\r\n    }\r\n\r\n    public void refreshNativeTitle(){\r\n        if (getActivity() == null || com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n            return;\r\n        }\r\n        Form f = getCurrentForm();\r\n        if (f != null && isNativeTitle() &&  !(f instanceof Dialog)) {\r\n            getActivity().runOnUiThread(new SetCurrentFormImpl(getActivity(), f));\r\n        }\r\n    }\r\n\r\n    public void setCurrentForm(final Form f) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        if(getCurrentForm() == null){\r\n            flushGraphics();\r\n        }\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        super.setCurrentForm(f);\r\n        if (isNativeTitle() &&  !(f instanceof Dialog)) {\r\n            getActivity().runOnUiThread(new SetCurrentFormImpl(getActivity(), f));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setNativeCommands(Vector commands) {\r\n        refreshNativeTitle();\r\n    }\r\n\r\n    @Override\r\n    public boolean isScreenLockSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void lockScreen(){\r\n        ((CodenameOneActivity)getContext()).lockScreen();\r\n    }\r\n\r\n    @Override\r\n    public void unlockScreen(){\r\n        ((CodenameOneActivity)getContext()).unlockScreen();\r\n    }\r\n\r\n    private static class SetCurrentFormImpl implements Runnable {\r\n        private Activity activity;\r\n        private Form f;\r\n\r\n        public SetCurrentFormImpl(Activity activity, Form f) {\r\n            this.activity = activity;\r\n            this.f = f;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            if(com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n                return;\r\n            }\r\n            ActionBar ab = activity.getActionBar();\r\n            String title = f.getTitle();\r\n            boolean hasMenuBtn = false;\r\n            if(android.os.Build.VERSION.SDK_INT >= 14){\r\n                try {\r\n                    ViewConfiguration vc = ViewConfiguration.get(activity);\r\n                    Method m = vc.getClass().getMethod(\"hasPermanentMenuKey\", (Class[])null);\r\n                    hasMenuBtn = ((Boolean)m.invoke(vc, (Object[])null)).booleanValue();\r\n                } catch(Throwable t) {\r\n                    t.printStackTrace();\r\n                }\r\n            }\r\n            if((title != null && title.length() > 0) || (f.getCommandCount() > 0 && !hasMenuBtn)){\r\n                activity.runOnUiThread(new NotifyActionBar(activity, true));\r\n            }else{\r\n                activity.runOnUiThread(new NotifyActionBar(activity, false));\r\n                return;\r\n            }\r\n\r\n            ab.setTitle(title);\r\n            ab.setDisplayHomeAsUpEnabled(f.getBackCommand() != null);\r\n            if(android.os.Build.VERSION.SDK_INT >= 14){\r\n                Image icon = f.getTitleComponent().getIcon();\r\n                try {\r\n                    if(icon != null){\r\n                        ab.getClass().getMethod(\"setIcon\", Drawable.class).invoke(ab, new BitmapDrawable(activity.getResources(), (Bitmap)icon.getImage()));\r\n                    }else{\r\n                        if(activity.getApplicationInfo().icon != 0){\r\n                            ab.getClass().getMethod(\"setIcon\", Integer.TYPE).invoke(ab, activity.getApplicationInfo().icon);\r\n                        }\r\n                    }\r\n                    activity.runOnUiThread(new InvalidateOptionsMenuImpl(activity));\r\n                } catch(Throwable t) {\r\n                    t.printStackTrace();\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    private Purchase pur;\r\n\r\n    @Override\r\n    public Purchase getInAppPurchase() {\r\n        try {\r\n            pur = ZoozPurchase.class.newInstance();\r\n            return pur;\r\n        } catch(Throwable t) {\r\n            return super.getInAppPurchase();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isTimeoutSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setTimeout(int t) {\r\n        timeout = t;\r\n    }\r\n\r\n    @Override\r\n    public CodeScanner getCodeScanner() {\r\n        if(scannerInstance == null) {\r\n            scannerInstance = new CodeScannerImpl();\r\n        }\r\n        return scannerInstance;\r\n    }\r\n\r\n    public void addCookie(Cookie c, boolean addToWebViewCookieManager, boolean sync) {\r\n        if(addToWebViewCookieManager) {\r\n            CookieManager mgr;\r\n            CookieSyncManager syncer;\r\n            try {\r\n                syncer = CookieSyncManager.getInstance();\r\n                mgr = getCookieManager();\r\n            } catch(IllegalStateException ex) {\r\n                syncer = CookieSyncManager.createInstance(this.getContext());\r\n                mgr = getCookieManager();\r\n            }\r\n            java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(\"EEE, dd-MMM-yyyy HH:mm:ss z\");\r\n            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n            addCookie(c, mgr, format);\r\n            if(sync) {\r\n                syncer.sync();\r\n            }\r\n        }\r\n        super.addCookie(c);\r\n\r\n\r\n\r\n    }\r\n\r\n    private void addCookie(Cookie c, CookieManager mgr, java.text.SimpleDateFormat format) {\r\n\r\n        String d = c.getDomain();\r\n        String port = \"\";\r\n        if (d.contains(\":\")) {\r\n            // For some reason, the port must be stripped and stored separately\r\n            // or it won't retrieve it properly.\r\n            // https://github.com/codenameone/CodenameOne/issues/2804\r\n            port = \"; Port=\" + d.substring(d.indexOf(\":\")+1);\r\n            d = d.substring(0, d.indexOf(\":\"));\r\n        }\r\n        String cookieString = c.getName() + \"=\" + c.getValue() +\r\n                \"; Domain=\" + d +\r\n                port +\r\n                \"; Path=\" + c.getPath() +\r\n                \"; \" + (c.isSecure() ? \"Secure;\" : \"\")\r\n                + (c.getExpires() != 0 ? (\" Expires=\"+format.format(new Date(c.getExpires()))+\";\") : \"\")\r\n                + (c.isHttpOnly() ? \"httpOnly;\" : \"\");\r\n        String cookieUrl = \"http\" +\r\n                (c.isSecure() ? \"s\" : \"\") + \"://\" +\r\n                d +\r\n                c.getPath();\r\n        mgr.setCookie(cookieUrl, cookieString);\r\n    }\r\n\r\n    public void addCookie(Cookie[] cs, boolean addToWebViewCookieManager, boolean sync) {\r\n        if(addToWebViewCookieManager) {\r\n            CookieManager mgr;\r\n            CookieSyncManager syncer;\r\n            try {\r\n                syncer = CookieSyncManager.getInstance();\r\n                mgr = getCookieManager();\r\n            } catch(IllegalStateException ex) {\r\n                syncer = CookieSyncManager.createInstance(this.getContext());\r\n                mgr = getCookieManager();\r\n            }\r\n            java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(\"EEE, dd-MMM-yyyy HH:mm:ss z\");\r\n            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n\r\n            for (Cookie c : cs) {\r\n                addCookie(c, mgr, format);\r\n\r\n            }\r\n\r\n            if(sync) {\r\n                syncer.sync();\r\n            }\r\n        }\r\n        super.addCookie(cs);\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void addCookie(Cookie c) {\r\n        if(isUseNativeCookieStore()) {\r\n            this.addCookie(c, true, true);\r\n        } else {\r\n            super.addCookie(c);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void addCookie(Cookie[] cookiesArray) {\r\n        if(isUseNativeCookieStore()) {\r\n            this.addCookie(cookiesArray, true);\r\n        } else {\r\n            super.addCookie(cookiesArray);\r\n        }\r\n    }\r\n\r\n    public void addCookie(Cookie[] cookiesArray, boolean addToWebViewCookieManager){\r\n        addCookie(cookiesArray, addToWebViewCookieManager, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    class CodeScannerImpl extends CodeScanner implements IntentResultListener {\r\n        private ScanResult callback;\r\n\r\n        @Override\r\n        public void scanQRCode(ScanResult callback) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).setIntentResultListener(this);\r\n            }\r\n            this.callback = callback;\r\n            IntentIntegrator in = new IntentIntegrator(getActivity());\r\n            if(!in.initiateScan(IntentIntegrator.QR_CODE_TYPES, \"QR_CODE_MODE\")){\r\n                // restore old activity handling\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if(CodeScannerImpl.this != null && CodeScannerImpl.this.callback != null) {\r\n                            CodeScannerImpl.this.callback.scanError(-1, \"no scan app\");\r\n                            CodeScannerImpl.this.callback = null;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (getActivity() instanceof CodenameOneActivity) {\r\n                    ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void scanBarCode(ScanResult callback) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).setIntentResultListener(this);\r\n            }\r\n            this.callback = callback;\r\n            IntentIntegrator in = new IntentIntegrator(getActivity());\r\n            Collection<String> types = IntentIntegrator.PRODUCT_CODE_TYPES;\r\n            if(Display.getInstance().getProperty(\"scanAllCodeTypes\", \"false\").equals(\"true\")) {\r\n                types = IntentIntegrator.ALL_CODE_TYPES;\r\n            }\r\n            if(Display.getInstance().getProperty(\"android.scanTypes\", null) != null) {\r\n                String[] arr = Display.getInstance().getProperty(\"android.scanTypes\", null).split(\";\");\r\n                types = Arrays.asList(arr);\r\n            }\r\n\r\n            if(!in.initiateScan(types, \"ONE_D_MODE\")){\r\n                // restore old activity handling\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        CodeScannerImpl.this.callback.scanError(-1, \"no scan app\");\r\n                        CodeScannerImpl.this.callback = null;\r\n                    }\r\n                });\r\n\r\n                if (getActivity() instanceof CodenameOneActivity) {\r\n                    ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n                }\r\n            }\r\n        }\r\n\r\n        public void onActivityResult(int requestCode, final int resultCode, Intent data) {\r\n            if (requestCode == IntentIntegrator.REQUEST_CODE && callback != null) {\r\n                final ScanResult sr = callback;\r\n                if (resultCode == Activity.RESULT_OK) {\r\n                    final String contents = data.getStringExtra(\"SCAN_RESULT\");\r\n                    final String formatName = data.getStringExtra(\"SCAN_RESULT_FORMAT\");\r\n                    final byte[] rawBytes = data.getByteArrayExtra(\"SCAN_RESULT_BYTES\");\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanCompleted(contents, formatName, rawBytes);\r\n                        }\r\n                    });\r\n                } else if(resultCode == Activity.RESULT_CANCELED) {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanCanceled();\r\n                        }\r\n                    });\r\n\r\n                } else {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanError(resultCode, null);\r\n                        }\r\n                    });\r\n                }\r\n                callback = null;\r\n            }\r\n\r\n            // restore old activity handling\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean hasCamera() {\r\n        try {\r\n            int numCameras = Camera.getNumberOfCameras();\r\n            return numCameras > 0;\r\n        } catch(Throwable t) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public String getCurrentAccessPoint() {\r\n\r\n        ConnectivityManager cm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        NetworkInfo info = cm.getActiveNetworkInfo();\r\n        if (info == null) {\r\n            return null;\r\n        }\r\n        String apName = info.getTypeName() + \"_\" + info.getSubtypeName();\r\n        if (info.getExtraInfo() != null) {\r\n            apName += \"_\" + info.getExtraInfo();\r\n        }\r\n        return apName;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getAPIds() {\r\n        if (apIds == null) {\r\n            apIds = new HashMap();\r\n            NetworkInfo[] aps = ((ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE)).getAllNetworkInfo();\r\n            for (int i = 0; i < aps.length; i++) {\r\n                String apName = aps[i].getTypeName() + \"_\" + aps[i].getSubtypeName();\r\n                if (aps[i].getExtraInfo() != null) {\r\n                    apName += \"_\" + aps[i].getExtraInfo();\r\n                }\r\n                apIds.put(apName, aps[i]);\r\n            }\r\n        }\r\n        if (apIds.isEmpty()) {\r\n            return null;\r\n        }\r\n        String[] ret = new String[apIds.size()];\r\n        Iterator iter = apIds.keySet().iterator();\r\n        for (int i = 0; iter.hasNext(); i++) {\r\n            ret[i] = iter.next().toString();\r\n        }\r\n        return ret;\r\n\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getAPType(String id) {\r\n        if (apIds == null) {\r\n            getAPIds();\r\n        }\r\n        NetworkInfo info = (NetworkInfo) apIds.get(id);\r\n        if (info == null) {\r\n            return NetworkManager.ACCESS_POINT_TYPE_UNKNOWN;\r\n        }\r\n        int type = info.getType();\r\n        int subType = info.getSubtype();\r\n        if (type == ConnectivityManager.TYPE_WIFI) {\r\n            return NetworkManager.ACCESS_POINT_TYPE_WLAN;\r\n        } else if (type == ConnectivityManager.TYPE_MOBILE) {\r\n            switch (subType) {\r\n                case TelephonyManager.NETWORK_TYPE_1xRTT:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 50-100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_CDMA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 14-64 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EDGE:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 50-100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_0:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 400-1000 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_A:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 600-1400 kbps\r\n                case TelephonyManager.NETWORK_TYPE_GPRS:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_HSDPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 2-14 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_HSPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 700-1700 kbps\r\n                case TelephonyManager.NETWORK_TYPE_HSUPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 1-23 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_UMTS:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 400-7000 kbps\r\n            /*\r\n                 * Above API level 7, make sure to set android:targetSdkVersion\r\n                 * to appropriate level to use these\r\n                 */\r\n                case TelephonyManager.NETWORK_TYPE_EHRPD: // API level 11\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 1-2 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_B: // API level 9\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 5 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_HSPAP: // API level 13\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 10-20 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_IDEN: // API level 8\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~25 kbps\r\n                case TelephonyManager.NETWORK_TYPE_LTE: // API level 11\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 10+ Mbps\r\n                // Unknown\r\n                case TelephonyManager.NETWORK_TYPE_UNKNOWN:\r\n                default:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G;\r\n            }\r\n        } else {\r\n            return NetworkManager.ACCESS_POINT_TYPE_UNKNOWN;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setCurrentAccessPoint(String id) {\r\n\r\n        if (apIds == null) {\r\n            getAPIds();\r\n        }\r\n        NetworkInfo info = (NetworkInfo) apIds.get(id);\r\n        if (info == null || info.isConnectedOrConnecting()) {\r\n            return;\r\n\r\n        }\r\n        ConnectivityManager cm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        cm.setNetworkPreference(info.getType());\r\n    }\r\n\r\n    private void scanMedia(File file) {\r\n        Uri uri = Uri.fromFile(file);\r\n        Intent scanFileIntent = new Intent(\r\n                Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);\r\n        getActivity().sendBroadcast(scanFileIntent);\r\n    }\r\n\r\n    /**\r\n     * Gets the last image id from the media store\r\n     *\r\n     * @return\r\n     */\r\n    private String getLastImageId() {\r\n        int idVal = 0;;\r\n        final String[] imageColumns = {MediaStore.Images.Media._ID};\r\n        final String imageOrderBy = MediaStore.Images.Media._ID + \" DESC\";\r\n        final String imageWhere = null;\r\n        final String[] imageArguments = null;\r\n        Cursor imageCursor = getContext().getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageColumns, imageWhere, imageArguments, imageOrderBy);\r\n        if (imageCursor.moveToFirst()) {\r\n            int id = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));\r\n            imageCursor.close();\r\n            idVal = id;\r\n        }\r\n        return \"\" + idVal;\r\n    }\r\n\r\n    private void clearMediaDB(String lastId, String capturePath) {\r\n        final String[] imageColumns = {MediaStore.Images.Media.DATA, MediaStore.Images.Media.DATE_TAKEN, MediaStore.Images.Media.SIZE, MediaStore.Images.Media._ID};\r\n        final String imageOrderBy = MediaStore.Images.Media._ID + \" DESC\";\r\n        final String imageWhere = MediaStore.Images.Media._ID + \">?\";\r\n        final String[] imageArguments = {lastId};\r\n        Cursor imageCursor = getContext().getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageColumns, imageWhere, imageArguments, imageOrderBy);\r\n        if (imageCursor.getCount() > 1) {\r\n            while (imageCursor.moveToNext()) {\r\n                int id = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));\r\n                String path = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DATA));\r\n                Long takenTimeStamp = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN));\r\n                Long size = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));\r\n                if (path.contentEquals(capturePath)) {\r\n                    // Remove it\r\n                    ContentResolver cr = getContext().getContentResolver();\r\n                    cr.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStore.Images.Media._ID + \"=?\", new String[]{Long.toString(id)});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        imageCursor.close();\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean isNativePickerTypeSupported(int pickerType) {\r\n        if(android.os.Build.VERSION.SDK_INT >= 11) {\r\n            return pickerType == Display.PICKER_TYPE_DATE || pickerType == Display.PICKER_TYPE_TIME || pickerType == Display.PICKER_TYPE_STRINGS;\r\n        }\r\n        return pickerType == Display.PICKER_TYPE_DATE || pickerType == Display.PICKER_TYPE_TIME;\r\n    }\r\n\r\n    @Override\r\n    public Object showNativePicker(final int type, final Component source, final Object currentValue, final Object data) {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        final boolean [] canceled = new boolean[1];\r\n        final boolean [] dismissed = new boolean[1];\r\n\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        if(type == Display.PICKER_TYPE_TIME) {\r\n\r\n            class TimePick implements TimePickerDialog.OnTimeSetListener, TimePickerDialog.OnCancelListener, Runnable {\r\n                int result = ((Integer)currentValue).intValue();\r\n                public void onTimeSet(TimePicker tp, int hour, int minute) {\r\n                    result = hour * 60 + minute;\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onCancel(DialogInterface di) {\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized (this) {\r\n                        notify();\r\n                    }\r\n                }\r\n            }\r\n            final TimePick pickInstance = new TimePick();\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    int hour = ((Integer)currentValue).intValue() / 60;\r\n                    int minute = ((Integer)currentValue).intValue() % 60;\r\n                    TimePickerDialog tp = new TimePickerDialog(getActivity(), pickInstance, hour, minute, true){\r\n\r\n                        @Override\r\n                        public void cancel() {\r\n                            super.cancel();\r\n                            dismissed[0] = true;\r\n                            canceled[0] = true;\r\n                        }\r\n\r\n                        @Override\r\n                        public void dismiss() {\r\n                            super.dismiss();\r\n                            dismissed[0] = true;\r\n                        }\r\n\r\n                    };\r\n                    tp.setOnCancelListener(pickInstance);\r\n                    //DateFormat.is24HourFormat(activity));\r\n                    tp.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            if(canceled[0]) {\r\n                return null;\r\n            }\r\n            return new Integer(pickInstance.result);\r\n        }\r\n        if(type == Display.PICKER_TYPE_DATE) {\r\n            final java.util.Calendar cl = java.util.Calendar.getInstance();\r\n            if(currentValue != null) {\r\n                cl.setTime((Date)currentValue);\r\n            }\r\n            class DatePick implements DatePickerDialog.OnDateSetListener,DatePickerDialog.OnCancelListener, Runnable {\r\n                Date result = (Date)currentValue;\r\n\r\n                public void onDateSet(DatePicker dp, int year, int month, int day) {\r\n                    java.util.Calendar c = java.util.Calendar.getInstance();\r\n                    c.set(java.util.Calendar.YEAR, year);\r\n                    c.set(java.util.Calendar.MONTH, month);\r\n                    c.set(java.util.Calendar.DAY_OF_MONTH, day);\r\n                    result = c.getTime();\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                public void onCancel(DialogInterface di) {\r\n                    result = null;\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n            }\r\n            final DatePick pickInstance = new DatePick();\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    DatePickerDialog tp = new DatePickerDialog(getActivity(), pickInstance, cl.get(java.util.Calendar.YEAR), cl.get(java.util.Calendar.MONTH), cl.get(java.util.Calendar.DAY_OF_MONTH)){\r\n\r\n                        @Override\r\n                        public void cancel() {\r\n                            super.cancel();\r\n                            dismissed[0] = true;\r\n                            canceled[0] = true;\r\n                        }\r\n\r\n                        @Override\r\n                        public void dismiss() {\r\n                            super.dismiss();\r\n                            dismissed[0] = true;\r\n                        }\r\n\r\n                    };\r\n                    tp.setOnCancelListener(pickInstance);\r\n                    tp.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            return pickInstance.result;\r\n        }\r\n        if(type == Display.PICKER_TYPE_STRINGS) {\r\n            final String[] values = (String[])data;\r\n            class StringPick implements Runnable, NumberPicker.OnValueChangeListener {\r\n                int result = -1;\r\n\r\n                StringPick() {\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                public void cancel() {\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void ok() {\r\n                    canceled[0] = false;\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onValueChange(NumberPicker np, int oldVal, int newVal) {\r\n                    result = newVal;\r\n                }\r\n            }\r\n\r\n            final StringPick pickInstance = new StringPick();\r\n            for(int iter = 0 ; iter < values.length ; iter++) {\r\n                if(values[iter].equals(currentValue)) {\r\n                    pickInstance.result = iter;\r\n                    break;\r\n                }\r\n            }\r\n            if (pickInstance.result == -1 && values.length > 0) {\r\n                // The picker will default to showing the first element anyways\r\n                // If we don't set the result to 0, then the user has to first\r\n                // scroll to a different number, then back to the first option\r\n                // to pick the first option.\r\n                pickInstance.result = 0;\r\n            }\r\n\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    NumberPicker picker = new NumberPicker(getActivity());\r\n                    if(source.getClientProperty(\"showKeyboard\") == null) {\r\n                        picker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);\r\n                    }\r\n                    picker.setMinValue(0);\r\n                    picker.setMaxValue(values.length - 1);\r\n                    picker.setDisplayedValues(values);\r\n                    picker.setOnValueChangedListener(pickInstance);\r\n                    if(pickInstance.result > -1) {\r\n                        picker.setValue(pickInstance.result);\r\n                    }\r\n                    RelativeLayout linearLayout = new RelativeLayout(getActivity());\r\n                    RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(50, 50);\r\n                    RelativeLayout.LayoutParams numPicerParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                    numPicerParams.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                    linearLayout.setLayoutParams(params);\r\n                    linearLayout.addView(picker,numPicerParams);\r\n\r\n                    AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(getActivity());\r\n                    alertDialogBuilder.setView(linearLayout);\r\n                    alertDialogBuilder\r\n                            .setCancelable(false)\r\n                            .setPositiveButton(\"Ok\",\r\n                                    new DialogInterface.OnClickListener() {\r\n                                        public void onClick(DialogInterface dialog,\r\n                                                            int id) {\r\n                                            pickInstance.ok();\r\n                                        }\r\n                                    })\r\n                            .setNegativeButton(\"Cancel\",\r\n                                    new DialogInterface.OnClickListener() {\r\n                                        public void onClick(DialogInterface dialog,\r\n                                                            int id) {\r\n                                            dialog.cancel();\r\n                                            pickInstance.cancel();\r\n                                        }\r\n                                    });\r\n                    AlertDialog alertDialog = alertDialogBuilder.create();\r\n                    alertDialog.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            if(canceled[0]) {\r\n                return null;\r\n            }\r\n            if(pickInstance.result < 0) {\r\n                return null;\r\n            }\r\n            return values[pickInstance.result];\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    private ServerSockets serverSockets;\r\n    private synchronized ServerSockets getServerSockets() {\r\n        if (serverSockets == null) {\r\n            serverSockets = new ServerSockets();\r\n        }\r\n        return serverSockets;\r\n    }\r\n    \r\n    class ServerSockets {\r\n        Map<Integer,ServerSocket> socks = new HashMap<Integer,ServerSocket>();\r\n        \r\n        public synchronized ServerSocket get(int port) throws IOException {\r\n            if (socks.containsKey(port)) {\r\n                ServerSocket sock = socks.get(port);\r\n                if (sock.isClosed()) {\r\n                    sock = new ServerSocket(port);\r\n                    socks.put(port, sock);\r\n                }\r\n                return sock;\r\n            } else {\r\n                ServerSocket sock = new ServerSocket(port);\r\n                socks.put(port, sock);\r\n                return sock;\r\n            }\r\n        }\r\n        \r\n        \r\n    }\r\n\r\n    class SocketImpl {\r\n        java.net.Socket socketInstance;\r\n        int errorCode = -1;\r\n        String errorMessage = null;\r\n        InputStream is;\r\n        OutputStream os;\r\n\r\n        public boolean connect(String param, int param1, int connectTimeout) {\r\n            try {\r\n                socketInstance = new java.net.Socket();\r\n                socketInstance.connect(new InetSocketAddress(param, param1), connectTimeout);\r\n                return true;\r\n            } catch(Exception err) {\r\n                err.printStackTrace();\r\n                errorMessage = err.toString();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        private InputStream getInput() throws IOException {\r\n            if(is == null) {\r\n                if(socketInstance != null) {\r\n                    is = socketInstance.getInputStream();\r\n                } else {\r\n\r\n                }\r\n            }\r\n            return is;\r\n        }\r\n\r\n        private OutputStream getOutput() throws IOException {\r\n            if(os == null) {\r\n                os = socketInstance.getOutputStream();\r\n            }\r\n            return os;\r\n        }\r\n\r\n        public int getAvailableInput() {\r\n            try {\r\n                return getInput().available();\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        public String getErrorMessage() {\r\n            return errorMessage;\r\n        }\r\n\r\n        public byte[] readFromStream() {\r\n            try {\r\n                int av = getAvailableInput();\r\n                if(av > 0) {\r\n                    byte[] arr = new byte[av];\r\n                    int size = getInput().read(arr);\r\n                    if(size == arr.length) {\r\n                        return arr;\r\n                    }\r\n                    return shrink(arr, size);\r\n                }\r\n                byte[] arr = new byte[8192];\r\n                int size = getInput().read(arr);\r\n                if(size == arr.length) {\r\n                    return arr;\r\n                }\r\n                return shrink(arr, size);\r\n            } catch(IOException err) {\r\n                err.printStackTrace();\r\n                errorMessage = err.toString();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        private byte[] shrink(byte[] arr, int size) {\r\n            if(size == -1) {\r\n                return null;\r\n            }\r\n            byte[] n = new byte[size];\r\n            System.arraycopy(arr, 0, n, 0, size);\r\n            return n;\r\n        }\r\n\r\n        public void writeToStream(byte[] param) {\r\n            try {\r\n                OutputStream os = getOutput();\r\n                os.write(param);\r\n                os.flush();\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n        }\r\n\r\n        public void disconnect() {\r\n            try {\r\n                if(socketInstance != null) {\r\n                    if(is != null) {\r\n                        try {\r\n                            is.close();\r\n                        } catch(IOException err) {}\r\n                    }\r\n                    if(os != null) {\r\n                        try {\r\n                            os.close();\r\n                        } catch(IOException err) {}\r\n                    }\r\n                    socketInstance.close();\r\n                    socketInstance = null;\r\n                }\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n        }\r\n\r\n        public Object listen(int param) {\r\n            try {\r\n                ServerSocket serverSocketInstance = getServerSockets().get(param);\r\n                socketInstance = serverSocketInstance.accept();\r\n                SocketImpl si = new SocketImpl();\r\n                si.socketInstance = socketInstance;\r\n                return si;\r\n            } catch(Exception err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public boolean isConnected() {\r\n            return socketInstance != null;\r\n        }\r\n\r\n        public int getErrorCode() {\r\n            return errorCode;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object connectSocket(String host, int port) {\r\n        return connectSocket(host, port, 0);\r\n    }\r\n\r\n    \r\n    \r\n    @Override\r\n    public Object connectSocket(String host, int port, int connectTimeout) {\r\n        SocketImpl i = new SocketImpl();\r\n        if(i.connect(host, port, connectTimeout)) {\r\n            return i;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Object listenSocket(int port) {\r\n        return new SocketImpl().listen(port);\r\n    }\r\n\r\n    @Override\r\n    public String getHostOrIP() {\r\n        try {\r\n            InetAddress i = java.net.InetAddress.getLocalHost();\r\n            if(i.isLoopbackAddress()) {\r\n                Enumeration<NetworkInterface> nie = NetworkInterface.getNetworkInterfaces();\r\n                while(nie.hasMoreElements()) {\r\n                    NetworkInterface current = nie.nextElement();\r\n                    if(!current.isLoopback()) {\r\n                        Enumeration<InetAddress> iae = current.getInetAddresses();\r\n                        while(iae.hasMoreElements()) {\r\n                            InetAddress currentI = iae.nextElement();\r\n                            if(!currentI.isLoopbackAddress()) {\r\n                                return currentI.getHostAddress();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return i.getHostAddress();\r\n        } catch(Throwable t) {\r\n            com.codename1.io.Log.e(t);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void disconnectSocket(Object socket) {\r\n        ((SocketImpl)socket).disconnect();\r\n    }\r\n\r\n    @Override\r\n    public boolean isSocketConnected(Object socket) {\r\n        return ((SocketImpl)socket).isConnected();\r\n    }\r\n\r\n    \r\n\r\n    @Override\r\n    public boolean isServerSocketAvailable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isSocketAvailable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String getSocketErrorMessage(Object socket) {\r\n        return ((SocketImpl)socket).getErrorMessage();\r\n    }\r\n\r\n    @Override\r\n    public int getSocketErrorCode(Object socket) {\r\n        return ((SocketImpl)socket).getErrorCode();\r\n    }\r\n\r\n    @Override\r\n    public int getSocketAvailableInput(Object socket) {\r\n        return ((SocketImpl)socket).getAvailableInput();\r\n    }\r\n\r\n    @Override\r\n    public byte[] readFromSocketStream(Object socket) {\r\n        return ((SocketImpl)socket).readFromStream();\r\n    }\r\n\r\n    @Override\r\n    public void writeToSocketStream(Object socket, byte[] data) {\r\n        ((SocketImpl)socket).writeToStream(data);\r\n    }\r\n\r\n    //Begin new Graphics Work\r\n    @Override\r\n    public boolean isShapeSupported(Object graphics) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isTransformSupported(Object graphics) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isPerspectiveTransformSupported(Object graphics){\r\n        return android.os.Build.VERSION.SDK_INT >= 14;\r\n    }\r\n\r\n    @Override\r\n    public void fillShape(Object graphics, com.codename1.ui.geom.Shape shape) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n        Path p = cn1ShapeToAndroidPath(shape);\r\n        ag.fillPath(p);\r\n    }\r\n\r\n    @Override\r\n    public void drawShape(Object graphics, com.codename1.ui.geom.Shape shape, com.codename1.ui.Stroke stroke) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n        Path p = cn1ShapeToAndroidPath(shape);\r\n        ag.drawPath(p, stroke);\r\n\r\n    }\r\n\r\n    @Override\r\n    public void drawShadow(Object graphics, Object image, int x, int y, int offsetX, int offsetY, int blurRadius, int spreadRadius, int color, float opacity) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n\r\n        ag.drawShadow(image, x, y, offsetX, offsetY, blurRadius, spreadRadius, color, opacity);\r\n    }\r\n\r\n    @Override\r\n    public boolean isDrawShadowSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isDrawShadowFast() {\r\n        return false;\r\n    }\r\n    // BEGIN TRANSFORMATION METHODS---------------------------------------------------------\r\n\r\n\r\n\r\n    @Override\r\n    public boolean transformEqualsImpl(Transform t1, Transform t2) {\r\n        Object o1 = null;\r\n        if(t1 != null) {\r\n            o1 = t1.getNativeTransform();\r\n        }\r\n        Object o2 = null;\r\n        if(t2 != null) {\r\n            o2 = t2.getNativeTransform();\r\n        }\r\n        return transformNativeEqualsImpl(o1, o2);\r\n    }\r\n\r\n    @Override\r\n    public boolean transformNativeEqualsImpl(Object t1, Object t2) {\r\n        if ( t1 != null ){\r\n            CN1Matrix4f m1 = (CN1Matrix4f)t1;\r\n            CN1Matrix4f m2 = (CN1Matrix4f)t2;\r\n            return m1.equals(m2);\r\n        } else {\r\n            return t2 == null;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean isTransformSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isPerspectiveTransformSupported() {\r\n\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformAffine(double m00, double m10, double m01, double m11, double m02, double m12) {\r\n        CN1Matrix4f t = CN1Matrix4f.make(new float[]{\r\n                (float)m00, (float)m10, 0, 0,\r\n                (float)m01, (float)m11, 0, 0,\r\n                0, 0, 1, 0,\r\n                (float)m02, (float)m12, 0, 1\r\n        });\r\n        return t;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformAffine(Object nativeTransform, double m00, double m10, double m01, double m11, double m02, double m12) {\r\n        ((CN1Matrix4f)nativeTransform).setData(new float[]{\r\n                (float)m00, (float)m10, 0, 0,\r\n                (float)m01, (float)m11, 0, 0,\r\n                0, 0, 1, 0,\r\n                (float)m02, (float)m12, 0, 1\r\n        });\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public Object makeTransformTranslation(float translateX, float translateY, float translateZ) {\r\n        return CN1Matrix4f.makeTranslation(translateX, translateY, translateZ);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformTranslation(Object nativeTransform, float translateX, float translateY, float translateZ) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        m.reset();\r\n        m.translate(translateX, translateY, translateZ);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformScale(float scaleX, float scaleY, float scaleZ) {\r\n        CN1Matrix4f t = CN1Matrix4f.makeIdentity();\r\n        t.scale(scaleX, scaleY, scaleZ);\r\n        return t;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformScale(Object nativeTransform, float scaleX, float scaleY, float scaleZ) {\r\n        CN1Matrix4f t = (CN1Matrix4f)nativeTransform;\r\n        t.reset();\r\n        t.scale(scaleX, scaleY, scaleZ);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformRotation(float angle, float x, float y, float z) {\r\n        return CN1Matrix4f.makeRotation(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformRotation(Object nativeTransform, float angle, float x, float y, float z) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        m.reset();\r\n        m.rotate(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformPerspective(float fovy, float aspect, float zNear, float zFar) {\r\n        return CN1Matrix4f.makePerspective(fovy, aspect, zNear, zFar);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformPerspective(Object nativeGraphics, float fovy, float aspect, float zNear, float zFar) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setPerspective(fovy, aspect, zNear, zFar);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformOrtho(float left, float right, float bottom, float top, float near, float far) {\r\n        return CN1Matrix4f.makeOrtho(left, right, bottom, top, near, far);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformOrtho(Object nativeGraphics, float left, float right, float bottom, float top, float near, float far) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setOrtho(left, right, bottom, top, near, far);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformCamera(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {\r\n        return CN1Matrix4f.makeCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformCamera(Object nativeGraphics, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void transformRotate(Object nativeTransform, float angle, float x, float y, float z) {\r\n        ((CN1Matrix4f)nativeTransform).rotate(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void transformTranslate(Object nativeTransform, float x, float y, float z) {\r\n        //((Matrix) nativeTransform).preTranslate(x, y);\r\n        ((CN1Matrix4f)nativeTransform).translate(x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void transformScale(Object nativeTransform, float x, float y, float z) {\r\n        //((Matrix) nativeTransform).preScale(x, y);\r\n        ((CN1Matrix4f)nativeTransform).scale(x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformInverse(Object nativeTransform) {\r\n\r\n        CN1Matrix4f inverted = CN1Matrix4f.makeIdentity();\r\n        inverted.setData(((CN1Matrix4f)nativeTransform).getData());\r\n        if( inverted.invert()){\r\n            return inverted;\r\n        }\r\n        return null;\r\n\r\n        //Matrix inverted = new Matrix();\r\n        //if(((Matrix) nativeTransform).invert(inverted)){\r\n        //    return inverted;\r\n        //}\r\n        //return null;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformInverse(Object nativeTransform) throws com.codename1.ui.Transform.NotInvertibleException {\r\n\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        if (!m.invert()) {\r\n            throw new com.codename1.ui.Transform.NotInvertibleException();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setTransformIdentity(Object transform) {\r\n        CN1Matrix4f m = (CN1Matrix4f)transform;\r\n        m.setIdentity();\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformIdentity() {\r\n        return CN1Matrix4f.makeIdentity();\r\n    }\r\n\r\n    @Override\r\n    public void copyTransform(Object src, Object dest) {\r\n        CN1Matrix4f t1 = (CN1Matrix4f) src;\r\n        CN1Matrix4f t2 = (CN1Matrix4f) dest;\r\n        t2.setData(t1.getData());\r\n    }\r\n\r\n    @Override\r\n    public void concatenateTransform(Object t1, Object t2) {\r\n        //((Matrix) t1).preConcat((Matrix) t2);\r\n        ((CN1Matrix4f)t1).concatenate((CN1Matrix4f)t2);\r\n    }\r\n\r\n    @Override\r\n    public void transformPoint(Object nativeTransform, float[] in, float[] out) {\r\n        //Matrix t = (Matrix) nativeTransform;\r\n        //t.mapPoints(in, 0, out, 0, 2);\r\n        ((CN1Matrix4f)nativeTransform).transformCoord(in, out);\r\n    }\r\n\r\n    @Override\r\n    public void setTransform(Object graphics, Transform transform) {\r\n        AndroidGraphics ag = (AndroidGraphics) graphics;\r\n        Transform existing = ag.getTransform();\r\n        if (existing == null) {\r\n            existing = transform == null ? Transform.makeIdentity() : transform.copy();\r\n            ag.setTransform(existing);\r\n        } else {\r\n            if (transform == null) {\r\n                existing.setIdentity();\r\n            } else {\r\n                existing.setTransform(transform);\r\n            }\r\n            ag.setTransform(existing); // sets dirty flag for transform\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public com.codename1.ui.Transform getTransform(Object graphics) {\r\n        com.codename1.ui.Transform t = ((AndroidGraphics) graphics).getTransform();\r\n        if (t == null) {\r\n            return Transform.makeIdentity();\r\n        }\r\n        Transform t2 = Transform.makeIdentity();\r\n        t2.setTransform(t);\r\n        return t2;\r\n    }\r\n\r\n    @Override\r\n    public void getTransform(Object graphics, Transform transform) {\r\n        com.codename1.ui.Transform t = ((AndroidGraphics) graphics).getTransform();\r\n        if (t == null) {\r\n            transform.setIdentity();\r\n        } else {\r\n            transform.setTransform(t);\r\n        }\r\n    }\r\n\r\n\r\n    // END TRANSFORM STUFF\r\n\r\n\r\n    static Path cn1ShapeToAndroidPath(com.codename1.ui.geom.Shape shape, Path p) {\r\n        //Path p = new Path();\r\n        p.rewind();\r\n        \r\n        com.codename1.ui.geom.PathIterator it = shape.getPathIterator();\r\n        switch (it.getWindingRule()) {\r\n            case GeneralPath.WIND_EVEN_ODD:\r\n                p.setFillType(Path.FillType.EVEN_ODD);\r\n                break;\r\n            case GeneralPath.WIND_NON_ZERO:\r\n                p.setFillType(Path.FillType.WINDING);\r\n                break;\r\n        }\r\n        //p.setWindingRule(it.getWindingRule() == com.codename1.ui.geom.PathIterator.WIND_EVEN_ODD ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO);\r\n        float[] buf = new float[6];\r\n        while (!it.isDone()) {\r\n            int type = it.currentSegment(buf);\r\n            switch (type) {\r\n                case com.codename1.ui.geom.PathIterator.SEG_MOVETO:\r\n                    p.moveTo(buf[0], buf[1]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_LINETO:\r\n                    p.lineTo(buf[0], buf[1]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_QUADTO:\r\n                    p.quadTo(buf[0], buf[1], buf[2], buf[3]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_CUBICTO:\r\n                    p.cubicTo(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_CLOSE:\r\n                    p.close();\r\n                    break;\r\n\r\n            }\r\n            it.next();\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    static Path cn1ShapeToAndroidPath(com.codename1.ui.geom.Shape shape) {\r\n        return cn1ShapeToAndroidPath(shape, new Path());\r\n    }\r\n\r\n    /**\r\n     * The ID used for a local notification that should actually trigger a background\r\n     * fetch.  This type of notification is handled specially by the {@link LocalNotificationPublisher}.  It\r\n     * doesn't display a notification to the user, but instead just calls the {@link #performBackgroundFetch() }\r\n     * method.\r\n     */\r\n    static final String BACKGROUND_FETCH_NOTIFICATION_ID=\"$$$CN1_BACKGROUND_FETCH$$$\";\r\n\r\n\r\n    /**\r\n     * Calls the background fetch callback.  If the app is in teh background, this will\r\n     * check to see if the lifecycle class implements the {@link com.codename1.background.BackgroundFetch}\r\n     * interface.  If it does, it will execute its {@link com.codename1.background.BackgroundFetch#performBackgroundFetch(long, com.codename1.util.Callback) }\r\n     * method.\r\n     * @param blocking True if this should block until it is complete.\r\n     */\r\n    public static void performBackgroundFetch(boolean blocking) {\r\n\r\n        if (Display.getInstance().isMinimized()) {\r\n            // By definition, background fetch should only occur if the app is minimized.\r\n            // This keeps it consistent with the iOS implementation that doesn't have a \r\n            // choice\r\n            final boolean[] complete = new boolean[1];\r\n            final Object lock = new Object();\r\n            final BackgroundFetch bgFetchListener = instance.getBackgroundFetchListener();\r\n            final long timeout = System.currentTimeMillis()+25000;\r\n            if (bgFetchListener != null) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    public void run() {\r\n                        bgFetchListener.performBackgroundFetch(timeout, new Callback<Boolean>() {\r\n\r\n                            @Override\r\n                            public void onSucess(Boolean value) {\r\n                                // On Android the OS doesn't care whether it worked or not\r\n                                // So we'll just consume this.\r\n                                synchronized (lock) {\r\n                                    complete[0] = true;\r\n                                    lock.notify();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Object sender, Throwable err, int errorCode, String errorMessage) {\r\n                                com.codename1.io.Log.e(err);\r\n                                synchronized (lock) {\r\n                                    complete[0] = true;\r\n                                    lock.notify();\r\n                                }\r\n                            }\r\n\r\n                        });\r\n                    }\r\n                });\r\n\r\n            }\r\n\r\n            while (blocking && !complete[0]) {\r\n                synchronized(lock) {\r\n                    try {\r\n                        lock.wait(1000);\r\n                    } catch (Exception ex){}\r\n                }\r\n                if (!complete[0]) {\r\n                    System.out.println(\"Waiting for background fetch to complete.  Make sure your background fetch handler calls onSuccess() or onError() in the callback when complete\");\r\n\r\n                }\r\n                if (System.currentTimeMillis() > timeout) {\r\n                    System.out.println(\"Background fetch exceeded time alotted.  Not waiting for its completion\");\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the background fetch service.\r\n     */\r\n    public void startBackgroundFetchService() {\r\n        LocalNotification n = new LocalNotification();\r\n        n.setId(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n        cancelLocalNotification(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n        // We schedule a local notification\r\n        // First callback will be at the repeat interval\r\n        // We don't specify a repeat interval because the scheduleLocalNotification will \r\n        // set that for us using the getPreferredBackgroundFetchInterval method.\r\n        scheduleLocalNotification(n, System.currentTimeMillis() + getPreferredBackgroundFetchInterval() * 1000, 0);\r\n    }\r\n\r\n    public void stopBackgroundFetchService() {\r\n        cancelLocalNotification(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n    }\r\n\r\n\r\n    private boolean backgroundFetchInitialized;\r\n\r\n    @Override\r\n    public void setPreferredBackgroundFetchInterval(int seconds) {\r\n        int oldInterval = getPreferredBackgroundFetchInterval();\r\n        super.setPreferredBackgroundFetchInterval(seconds);\r\n\r\n        if (!backgroundFetchInitialized || oldInterval != seconds) {\r\n            backgroundFetchInitialized = true;\r\n            if (seconds > 0) {\r\n                startBackgroundFetchService();\r\n            } else {\r\n                stopBackgroundFetchService();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public boolean isBackgroundFetchSupported() {\r\n        return true;\r\n    }\r\n    public static BackgroundFetch backgroundFetchListener;\r\n\r\n    BackgroundFetch getBackgroundFetchListener() {\r\n        if (getActivity() != null && getActivity().getApp() instanceof BackgroundFetch) {\r\n            return (BackgroundFetch)getActivity().getApp();\r\n        } else if (backgroundFetchListener != null) {\r\n            return backgroundFetchListener;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void scheduleLocalNotification(LocalNotification notif, long firstTime, int repeat) {\r\n\r\n        final Intent notificationIntent = new Intent(getContext(), LocalNotificationPublisher.class);\r\n        notificationIntent.setAction(getContext().getApplicationInfo().packageName + \".\" + notif.getId());\r\n        notificationIntent.putExtra(LocalNotificationPublisher.NOTIFICATION, createBundleFromNotification(notif));\r\n\r\n        Intent contentIntent = new Intent();\r\n        if (activityComponentName != null) {\r\n            contentIntent.setComponent(activityComponentName);\r\n        } else {\r\n            try {\r\n                contentIntent.setComponent(getContext().getPackageManager().getLaunchIntentForPackage(getContext().getApplicationInfo().packageName).getComponent());\r\n            } catch (Exception ex) {\r\n                System.err.println(\"Failed to get the component name for local notification.  Local notification may not work.\");\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        contentIntent.putExtra(\"LocalNotificationID\", notif.getId());\r\n\r\n        if (BACKGROUND_FETCH_NOTIFICATION_ID.equals(notif.getId()) && getBackgroundFetchListener() != null) {\r\n            Context context = AndroidNativeUtil.getContext();\r\n\r\n            Intent intent = new Intent(context, BackgroundFetchHandler.class);\r\n            //there is an bug that causes this to not to workhttps://code.google.com/p/android/issues/detail?id=81812\r\n            //intent.putExtra(\"backgroundClass\", getBackgroundLocationListener().getName());\r\n            //an ugly workaround to the putExtra bug \r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + getBackgroundFetchListener().getClass().getName()));\r\n            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\r\n                    intent,\r\n                    PendingIntent.FLAG_UPDATE_CURRENT);\r\n            notificationIntent.putExtra(LocalNotificationPublisher.BACKGROUND_FETCH_INTENT, pendingIntent);\r\n\r\n        } else {\r\n            contentIntent.setData(Uri.parse(\"http://codenameone.com/a?LocalNotificationID=\"+Uri.encode(notif.getId())));\r\n        }\r\n        PendingIntent pendingContentIntent = PendingIntent.getActivity(getContext(), 0, contentIntent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n\r\n        notificationIntent.putExtra(LocalNotificationPublisher.NOTIFICATION_INTENT, pendingContentIntent);\r\n\r\n\r\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(getContext(), 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n\r\n        AlarmManager alarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);\r\n        if (BACKGROUND_FETCH_NOTIFICATION_ID.equals(notif.getId())) {\r\n            alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, getPreferredBackgroundFetchInterval() * 1000, pendingIntent);\r\n        } else {\r\n            if(repeat == LocalNotification.REPEAT_NONE){\r\n                alarmManager.set(AlarmManager.RTC_WAKEUP, firstTime, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_MINUTE){\r\n\r\n                alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, 60*1000, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_HOUR){\r\n\r\n                alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_HALF_HOUR, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_DAY){\r\n\r\n                alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_DAY, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_WEEK){\r\n\r\n                alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_DAY * 7, pendingIntent);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cancelLocalNotification(String notificationId) {\r\n        Intent notificationIntent = new Intent(getContext(), LocalNotificationPublisher.class);\r\n        notificationIntent.setAction(getContext().getApplicationInfo().packageName + \".\" + notificationId);\r\n\r\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(getContext(), 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n        AlarmManager alarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);\r\n        alarmManager.cancel(pendingIntent);\r\n    }\r\n\r\n    static Bundle createBundleFromNotification(LocalNotification notif){\r\n        Bundle b = new Bundle();\r\n        b.putString(\"NOTIF_ID\", notif.getId());\r\n        b.putString(\"NOTIF_TITLE\", notif.getAlertTitle());\r\n        b.putString(\"NOTIF_BODY\", notif.getAlertBody());\r\n        b.putString(\"NOTIF_SOUND\", notif.getAlertSound());\r\n        b.putString(\"NOTIF_IMAGE\", notif.getAlertImage());\r\n        b.putInt(\"NOTIF_NUMBER\", notif.getBadgeNumber());\r\n        return b;\r\n    }\r\n\r\n    static LocalNotification createNotificationFromBundle(Bundle b){\r\n        LocalNotification n = new LocalNotification();\r\n        n.setId(b.getString(\"NOTIF_ID\"));\r\n        n.setAlertTitle(b.getString(\"NOTIF_TITLE\"));\r\n        n.setAlertBody(b.getString(\"NOTIF_BODY\"));\r\n        n.setAlertSound(b.getString(\"NOTIF_SOUND\"));\r\n        n.setAlertImage(b.getString(\"NOTIF_IMAGE\"));\r\n        n.setBadgeNumber(b.getInt(\"NOTIF_NUMBER\"));\r\n        return n;\r\n    }\r\n\r\n    boolean brokenGaussian;\r\n    public Image gaussianBlurImage(Image image, float radius) {\r\n        try {\r\n            Bitmap outputBitmap = Bitmap.createBitmap((Bitmap)image.getImage());\r\n\r\n            RenderScript rs = RenderScript.create(getContext());\r\n            try {\r\n                ScriptIntrinsicBlur theIntrinsic = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\r\n                Allocation tmpIn = Allocation.createFromBitmap(rs, (Bitmap)image.getImage());\r\n                Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap);\r\n                theIntrinsic.setRadius(radius);\r\n                theIntrinsic.setInput(tmpIn);\r\n                theIntrinsic.forEach(tmpOut);\r\n                tmpOut.copyTo(outputBitmap);\r\n                tmpIn.destroy();\r\n                tmpOut.destroy();\r\n                theIntrinsic.destroy();\r\n            } finally {\r\n                rs.destroy();\r\n            }\r\n\r\n            return new NativeImage(outputBitmap);\r\n        } catch(Throwable t) {\r\n            brokenGaussian = true;\r\n            return image;\r\n        }\r\n    }\r\n\r\n    public boolean isGaussianBlurSupported() {\r\n        return (!brokenGaussian) && android.os.Build.VERSION.SDK_INT >= 11;\r\n    }\r\n\r\n    public static boolean checkForPermission(String permission, String description){\r\n        return checkForPermission(permission, description, false);\r\n    }\r\n\r\n    /**\r\n     * Return a list of all of the permissions that have been requested by the app (granted or no).\r\n     * This can be used to see which permissions are included in the manifest file.\r\n     * @return \r\n     */\r\n    public static List<String> getRequestedPermissions() {\r\n        PackageManager pm = getContext().getPackageManager();\r\n        try\r\n        {\r\n            PackageInfo packageInfo = pm.getPackageInfo(getContext().getPackageName(), PackageManager.GET_PERMISSIONS);\r\n            String[] requestedPermissions = null;\r\n            if (packageInfo != null) {\r\n                requestedPermissions = packageInfo.requestedPermissions;\r\n                return Arrays.asList(requestedPermissions);\r\n            }\r\n            return new ArrayList<String>();\r\n        }\r\n        catch (PackageManager.NameNotFoundException e)\r\n        {\r\n            com.codename1.io.Log.e(e);\r\n            return new ArrayList<String>();\r\n        }\r\n    }\r\n    \r\n    public static boolean checkForPermission(String permission, String description, boolean forceAsk){\r\n        //before sdk 23 no need to ask for permission\r\n        if(android.os.Build.VERSION.SDK_INT < 23){\r\n            return true;\r\n        }\r\n\r\n        String prompt = Display.getInstance().getProperty(permission, description);\r\n\r\n        if (android.support.v4.content.ContextCompat.checkSelfPermission(getContext(),\r\n                permission)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n\r\n            if (getActivity() == null) {\r\n                return false;\r\n            }\r\n\r\n            // Should we show an explanation?\r\n            if (!forceAsk && android.support.v4.app.ActivityCompat.shouldShowRequestPermissionRationale(getActivity(),\r\n                    permission)) {\r\n\r\n                // Show an expanation to the user *asynchronously* -- don't block\r\n                if(Dialog.show(\"Requires permission\", prompt, \"Ask again\", \"Don't Ask\")){\r\n                    return checkForPermission(permission, description, true);\r\n                }else {\r\n                    return false;\r\n                }\r\n            } else {\r\n\r\n                // No explanation needed, we can request the permission.\r\n                ((CodenameOneActivity)getActivity()).setRequestForPermission(true);\r\n                ((CodenameOneActivity)getActivity()).setWaitingForPermissionResult(true);\r\n                android.support.v4.app.ActivityCompat.requestPermissions(getActivity(),\r\n                        new String[]{permission},\r\n                        1);\r\n                //wait for a response\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        while(((CodenameOneActivity)getActivity()).isRequestForPermission()) {\r\n                            try {\r\n                                Thread.sleep(50);\r\n                            } catch (InterruptedException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                //check again if the permission is given after the dialog was displayed\r\n                return android.support.v4.content.ContextCompat.checkSelfPermission(getActivity(),\r\n                        permission) == PackageManager.PERMISSION_GRANTED;\r\n\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean isJailbrokenDevice() {\r\n        try {\r\n            Runtime.getRuntime().exec(\"su\");\r\n            return true;\r\n        } catch(Throwable t) {\r\n            com.codename1.io.Log.e(t);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n", "/*\n * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores\n * CA 94065 USA or visit www.oracle.com if you need additional information or\n * have any questions.\n */\npackage com.codename1.impl.android;\n\nimport android.app.Activity;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.graphics.Bitmap;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.os.Bundle;\nimport android.os.PowerManager;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.Window;\nimport android.widget.Toast;\n\nimport com.codename1.payment.Product;\nimport com.codename1.ui.Command;\nimport com.codename1.ui.Display;\nimport com.codename1.ui.Form;\nimport com.codename1.ui.Image;\nimport com.codename1.ui.Toolbar;\nimport com.codename1.ui.events.ActionEvent;\n\nimport java.util.Vector;\n\npublic class CodenameOneActivity extends Activity {\n\n\n\n\n    private Menu menu;\n    private boolean nativeMenu = false;\n    private IntentResultListener intentResultListener;\n    private IntentResultListener defaultResultListener;\n    private boolean waitingForResult, waitingForPermissionResult;\n    private boolean background;\n    private Vector intentResult = new Vector();\n    boolean requestForPermission = false;\n\n    private IBillingSupport billingSupport;\n\n    private PowerManager.WakeLock wakeLock;\n\n    /**\n     * Overriden by stub, returns the user application instance.\n     */\n    protected Object getApp() {\n        return null;\n    }\n\n    boolean wasPurchased(String item) {\n        if (billingSupport != null) {\n            return billingSupport.wasPurchased(item);\n        }\n        return false;\n    }\n\n    void purchase(final String item) {\n        if (billingSupport != null) billingSupport.purchase(item);\n    }\n\n\n    void subscribe(final String item) {\n        if (billingSupport != null) billingSupport.subscribe(item);\n    }\n\n\n    protected IBillingSupport createBillingSupport() {\n        return null;\n    }\n\n    private IBillingSupport getBillingSupport() {\n        if (billingSupport == null) {\n            billingSupport = createBillingSupport();\n        }\n        return billingSupport;\n    }\n\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        AndroidImplementation.setActivity(this);\n        AndroidNativeUtil.onResume();\n        if (isBillingEnabled() && getBillingSupport() != null) {\n            billingSupport.consumeAndAcknowlegePurchases();\n        }\n        background = false;\n    }\n\n    /**\n     * Overriden by subclasses to return true if billing is supported on this\n     * build\n     *\n     * @return false\n     */\n    protected boolean isBillingEnabled() {\n        return false;\n    }\n\n    /**\n     * Get the Android native Menu\n     *\n     * @return the Android Menu Object\n     */\n    public Menu getMenu() {\n        return menu;\n    }\n\n    /**\n     * This method will enable the Android native Menu system instead of the\n     * regular Form Menu.\n     *\n     * @param enable\n     */\n    public void enableNativeMenu(boolean enable) {\n        nativeMenu = enable;\n    }\n\n    @Override\n    public void onBackPressed() {\n        Display.getInstance().keyPressed(AndroidImplementation.DROID_IMPL_KEY_BACK);\n        Display.getInstance().keyReleased(AndroidImplementation.DROID_IMPL_KEY_BACK);\n    }\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AndroidImplementation.setActivity(this);\n        AndroidNativeUtil.onCreate(savedInstanceState);\n\n        if (android.os.Build.VERSION.SDK_INT >= 11) {\n            getWindow().requestFeature(Window.FEATURE_ACTION_BAR);\n            getActionBar().hide();\n        }\n\n        try {\n            if (isBillingEnabled()) {\n                String k = getBase64EncodedPublicKey();\n                if(k.length() == 0){\n                    Log.e(\"Codename One\", \"android.licenseKey base64 is not configured\");\n                }\n                getBillingSupport().initBilling();\n\n\n            }\n        } catch (Throwable t) {\n            // might happen if billing permissions are missing\n            System.out.print(\"This exception is totally valid and here only for debugging purposes\");\n            t.printStackTrace();\n        }\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n    }\n\n    @Override\n    protected void onStop() {\n        AndroidImplementation.clearAppArg();\n        super.onStop();\n        background = true;\n        unlockScreen();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        AndroidNativeUtil.onDestroy();\n        if (isBillingEnabled()) {\n            getBillingSupport().onDestroy();\n        }\n        unlockScreen();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        this.menu = menu;\n        // By returning true we signal let Android know that we want the menu\n        // to be displayed\n        return nativeMenu && Display.isInitialized() && Display.getInstance().getCurrent() != null;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        AndroidNativeUtil.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onLowMemory() {\n        super.onLowMemory();\n        AndroidNativeUtil.onLowMemory();\n    }\n\n    @Override\n    protected void onPause() {\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.onPause();\n        AndroidNativeUtil.onPause();\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n\n        menu.clear();\n\n        try {\n            Form currentForm = Display.getInstance().getCurrent();\n            if (currentForm == null || Toolbar.isGlobalToolbar()) {\n                return false;\n            }\n\n            int numCommands = currentForm.getCommandCount();\n\n            // If there are no commands, there's nothing to put in the menu\n            if (numCommands == 0) {\n                return false;\n            }\n\n            // Build menu items from commands\n            for (int n = 0; n < numCommands; n++) {\n                Command command = currentForm.getCommand(n);\n                if (command != null) {\n                    String txt = currentForm.getUIManager().localize(command.getCommandName(), command.getCommandName());\n                    MenuItem item = menu.add(Menu.NONE, n, Menu.NONE, txt);\n\n                    Image icon = command.getIcon();\n                    if (icon != null) {\n                        Bitmap b = (Bitmap) icon.getImage();\n                        // Using BitmapDrawable with resources, to use device density (from 1.6 and above).\n                        BitmapDrawable d = new BitmapDrawable(getResources(), b);\n                        item.setIcon(d);\n                    }\n                    if (!command.isEnabled()) {\n                        item.setEnabled(false);\n                    }\n                    if (android.os.Build.VERSION.SDK_INT >= 11 && command.getClientProperty(\"android:showAsAction\") != null) {\n                        String androidShowAsAction = command.getClientProperty(\"android:showAsAction\").toString();\n                        // From https://developer.android.com/guide/topics/resources/menu-resource.html\n                        // \"ifRoom\" | \"never\" | \"withText\" | \"always\" | \"collapseActionView\"\n                        if (androidShowAsAction.equalsIgnoreCase(\"ifRoom\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"never\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"withText\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"always\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n                        } else if (android.os.Build.VERSION.SDK_INT >= 14 && androidShowAsAction.equalsIgnoreCase(\"collapseActionView\")) {\n                            item.setShowAsAction(8); //MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW\n                        }\n                    }\n                }\n            }\n        } catch (Throwable t) {\n        }\n\n        return nativeMenu;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        super.onOptionsItemSelected(item);\n\n        final Form currentForm = Display.getInstance().getCurrent();\n        if (currentForm == null) {\n            return false;\n        }\n        Command cmd = null;\n        final boolean[] tmpProp = new boolean[1];\n        if (item.getItemId() == android.R.id.home) {\n            cmd = currentForm.getBackCommand();\n            if (cmd == null) {\n                return false;\n            }\n            cmd.putClientProperty(\"source\", \"ActionBar\");\n            tmpProp[0] = true;\n        }\n\n        int commandIndex = item.getItemId();\n        if (cmd == null) {\n            cmd = currentForm.getCommand(commandIndex);\n        }\n        final Command command = cmd;\n        final ActionEvent actionEvent = new ActionEvent(command);\n\n        //stop edit if the keybaord is open\n        AndroidImplementation.stopEditing();\n        // Protect ourselves from commands that misbehave. A crash here will crash the entire application\n        Display.getInstance().callSerially(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    currentForm.dispatchCommand(command, actionEvent);\n                    //remove the temp source property\n                    if (tmpProp[0]) {\n                        command.putClientProperty(\"source\", null);\n                    }\n                } catch (Throwable e) {\n                    Log.e(\"CodenameOneActivity.onOptionsItemSelected\", e.toString() + Log.getStackTraceString(e));\n                }\n            }\n        });\n\n        return true;\n    }\n\n    protected void fireIntentResult() {\n        if (intentResult.size() > 0) {\n            final IntentResult response = (IntentResult) intentResult.get(0);\n            if (intentResultListener != null && response != null) {\n                Display.getInstance().callSerially(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        intentResultListener.onActivityResult(response.getRequestCode(),\n                                response.getResultCode(),\n                                response.getData());\n                    }\n                });\n            }\n        }\n    }\n\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n        IntentResult response = new IntentResult(requestCode, resultCode, data);\n        intentResult.add(response);\n    }\n\n    public void setIntentResultListener(IntentResultListener l) {\n        //if the activity is waiting for result don't override the intent listener\n        if(waitingForResult){\n            return;\n        }\n        this.intentResultListener = l;\n        if (l != null && l != defaultResultListener) {\n            waitingForResult = true;\n        }\n    }\n\n    public void setDefaultIntentResultListener(IntentResultListener l) {\n        this.defaultResultListener = l;\n    }\n\n    public void restoreIntentResultListener() {\n        waitingForResult = false;\n        setIntentResultListener(defaultResultListener);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        Bundle extra = intent.getExtras();\n        if(extra != null && extra.containsKey(\"WaitForResult\") && !extra.getBoolean(\"WaitForResult\")){\n            waitingForResult = false;            \n        }else{\n            waitingForResult = true;\n        }\n        intentResult = new Vector();\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void startActivity(Intent intent) {\n        Bundle extra = intent.getExtras();\n        if(extra != null && extra.containsKey(\"WaitForResult\") && !extra.getBoolean(\"WaitForResult\")){\n            waitingForResult = false;            \n        }else{\n            waitingForResult = true;\n        }\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.startActivity(intent);\n    }\n\n    public boolean isWaitingForResult() {\n        return waitingForResult;\n    }\n\n    protected void setWaitingForResult(boolean waitingForResult) {\n        this.waitingForResult = waitingForResult;\n    }\n\n    public boolean isBackground() {\n        return background;\n    }\n\n    public void registerForPush(String key) {\n        Intent registrationIntent = new Intent(\"com.google.android.c2dm.intent.REGISTER\");\n        registrationIntent.setPackage(\"com.google.android.gms\");\n        registrationIntent.putExtra(\"app\", PendingIntent.getBroadcast(this, 0, new Intent(), 0)); // boilerplate\n        registrationIntent.putExtra(\"sender\", key);\n        startService(registrationIntent);\n    }\n\n    public void stopReceivingPush() {\n        Intent unregIntent = new Intent(\"com.google.android.c2dm.intent.UNREGISTER\");\n        unregIntent.setPackage(\"com.google.android.gms\");\n        unregIntent.putExtra(\"app\", PendingIntent.getBroadcast(this, 0, new Intent(), 0));\n        startService(unregIntent);\n    }\n\n    public void lockScreen() {\n        unlockScreen();\n        try {\n            android.os.PowerManager pm = (android.os.PowerManager) getSystemService(android.content.Context.POWER_SERVICE);\n            wakeLock = pm.newWakeLock(android.os.PowerManager.SCREEN_BRIGHT_WAKE_LOCK | android.os.PowerManager.ACQUIRE_CAUSES_WAKEUP | android.os.PowerManager.ON_AFTER_RELEASE, \"Codename One\");\n        } catch (Exception excp) {\n            excp.printStackTrace();\n        }\n        if (wakeLock != null) {\n            wakeLock.acquire();\n        }\n    }\n\n    public void unlockScreen() {\n        if (wakeLock != null && wakeLock.isHeld()) {\n            wakeLock.release();\n            wakeLock = null;\n        }\n    }\n\n    public String getBase64EncodedPublicKey() {\n        String key = Display.getInstance().getProperty(\"android.licenseKey\", \"\");        \n        return key;\n    }\n\n\n\n    String getPayload() {\n        return \"\";\n    }\n\n\n\n\n\n\n\n    public boolean isConsumable(String item) {\n        if (getBillingSupport() != null) {\n            return getBillingSupport().isConsumable(item);\n        }\n        return false;\n    }\n\n    Product[] getProducts(String[] skus){\n        if (getBillingSupport() != null) {\n            return getBillingSupport().getProducts(skus, false);\n        }\n        return new Product[0];\n    }\n    \n\n    \n\n\n    public void setRequestForPermission(boolean requestForPermission) {\n        this.requestForPermission = requestForPermission;\n    }\n\n    public void setWaitingForPermissionResult(boolean waitingForPermissionResult) {\n        this.waitingForPermissionResult = waitingForPermissionResult;\n    }\n\n    public boolean isWaitingForPermissionResult() {\n        return waitingForPermissionResult;\n    }\n\n    public boolean isRequestForPermission() {\n        return requestForPermission;\n    }\n\n    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n        if(grantResults != null || grantResults.length == 0) {\n            requestForPermission = false;\n            return;\n        }\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            Log.i(\"Codename One\", \"PERMISSION_GRANTED\");\n        } else {\n            // Permission Denied\n            Toast.makeText(this, \"Permission is denied\", Toast.LENGTH_SHORT).show();\n        }\n        requestForPermission = false;\n    }\n    \n    public boolean hasUI(){\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Codename One designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *  \n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n * \n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n * \n * Please contact Codename One through http://www.codenameone.com/ if you \n * need additional information or have any questions.\n */\npackage com.codename1.impl.android;\n\nimport android.app.Activity;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.os.IBinder;\nimport com.codename1.push.PushCallback;\nimport com.codename1.ui.Display;\n\n/**\n * This class implements a push notification fallback service for applications that require\n * push notification support but don't have Android Market installed\n *\n * @author Shai Almog\n */\npublic abstract class PushNotificationService extends Service implements PushCallback {\n\n    private java.util.Map<String,String> properties = new java.util.HashMap<String,String>();\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n    \n    @Override\n    public void onCreate() {\n    }\n    \n    private String getProperty(String propertyName, String defaultValue) {\n        String val = properties.get(propertyName);\n        if (val == null) {\n            return defaultValue;\n        }\n        return val;\n    }\n    \n    public void setProperty(String propertyName, String val) {\n        properties.put(propertyName, val);\n        \n    }\n    \n    public static void startServiceIfRequired(Class service, Context ctx) {\n        if(!AndroidImplementation.hasAndroidMarket(ctx)) {\n            SharedPreferences sh = ctx.getSharedPreferences(\"C2DMNeeded\", Context.MODE_PRIVATE);\n            if(sh.getBoolean(\"C2DMNeeded\", false)) {\n                Intent i = new Intent();\n                i.setAction(service.getClass().getName());\n                ctx.startService(i);\n            }\n        }\n    }\n    \n    public static void forceStartService(String service, Context ctx) {\n        if(!AndroidImplementation.hasAndroidMarket(ctx)) {\n            SharedPreferences sh = ctx.getSharedPreferences(\"C2DMNeeded\", Context.MODE_PRIVATE);\n            Editor editor = sh.edit();\n            editor.putBoolean(\"C2DMNeeded\", true);\n            editor.commit();\n            Intent i = new Intent();\n            i.setAction(service);\n            ctx.startService(i);\n        }\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        AndroidImplementation.registerPolling();\n        return START_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        AndroidImplementation.stopPollingLoop();\n    }\n    \n    public abstract PushCallback getPushCallbackInstance();\n    public abstract Class getStubClass();\n    \n    @Override\n    public void push(final String value) {\n        final PushCallback callback = getPushCallbackInstance();\n        if(callback != null) {\n            Display.getInstance().callSerially(new Runnable() {\n                public void run() {\n                    callback.push(value);\n                }\n            });\n        } else {\n            NotificationManager nm = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);\n            Intent newIntent = new Intent(this, getStubClass());\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\n\n\n\n            Notification.Builder builder = new Notification.Builder(this)\n                    .setContentIntent(contentIntent)\n                    .setSmallIcon(android.R.drawable.stat_notify_sync)\n                    .setTicker(value)\n                    .setAutoCancel(true)\n                    .setWhen(System.currentTimeMillis())\n                    .setContentTitle(value)\n\n                    .setDefaults(Notification.DEFAULT_ALL);\n\n\n\n\n            // The following section is commented out so that builds against SDKs below 26\n            // won't fail.\n            /*<SDK26>\n            if(android.os.Build.VERSION.SDK_INT >= 21){\n                builder.setCategory(\"Notification\");\n            }\n            if (android.os.Build.VERSION.SDK_INT >= 26) {\n                NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n                String id = getProperty(\"android.NotificationChannel.id\", \"cn1-channel\");\n\n                CharSequence name = getProperty(\"android.NotificationChannel.name\", \"Notifications\");\n\n                String description = getProperty(\"android.NotificationChannel.description\", \"Remote notifications\");\n\n                int importance = Integer.parseInt(getProperty(\"android.NotificationChannel.importance\", \"\"+NotificationManager.IMPORTANCE_HIGH));\n\n                android.app.NotificationChannel mChannel = new android.app.NotificationChannel(id, name,importance);\n\n                mChannel.setDescription(description);\n\n                mChannel.enableLights(Boolean.parseBoolean(getProperty(\"android.NotificationChannel.enableLights\", \"true\")));\n\n                mChannel.setLightColor(Integer.parseInt(getProperty(\"android.NotificationChannel.lightColor\", \"\"+android.graphics.Color.RED)));\n\n                mChannel.enableVibration(Boolean.parseBoolean(getProperty(\"android.NotificationChannel.enableVibration\", \"false\")));\n                String vibrationPatternStr = getProperty(\"android.NotificationChannel.vibrationPattern\", null);\n                if (vibrationPatternStr != null) {\n                    String[] parts = vibrationPatternStr.split(\",\");\n                    int len = parts.length;\n                    long[] pattern = new long[len];\n                    for (int i=0; i<len; i++) {\n                        pattern[i] = Long.parseLong(parts[i].trim());\n                    }\n                    mChannel.setVibrationPattern(pattern);\n                }\n\n\n\n                mNotificationManager.createNotificationChannel(mChannel);\n                System.out.println(\"Setting push channel to \"+id);\n                builder.setChannelId(id);\n            }\n            </SDK26>*/\n\n            Notification notif = builder.build();\n            int notifId = getNotifyId();//(int)System.currentTimeMillis();\n\n            //notif.extras.putInt(\"notificationId\", notifId);\n            nm.notify(notifId, notif);\n        }\n    }\n\n    static int getNotifyId() {\n        return 1;\n    }\n\n    static void cancelNotification(Context context) {\n        NotificationManager nm = (NotificationManager) context.getSystemService(Activity.NOTIFICATION_SERVICE);\n        nm.cancel(getNotifyId());\n    }\n\n    @Override\n    public void registeredForPush(String deviceId) {\n    }\n\n    @Override\n    public void pushRegistrationError(String error, int errorCode) {\n    }\n}\n", "/*\r\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Codename One designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *\r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n *\r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n *\r\n * Please contact Codename One through http://www.codenameone.com/ if you\r\n * need additional information or have any questions.\r\n */\r\npackage com.codename1.location;\r\n\r\nimport android.Manifest;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.net.Uri;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.Looper;\r\nimport android.os.Parcel;\r\nimport android.os.Parcelable;\r\n\r\nimport android.support.annotation.NonNull;\r\nimport android.support.annotation.RequiresApi;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport com.codename1.impl.android.AndroidImplementation;\r\nimport com.codename1.impl.android.AndroidNativeUtil;\r\nimport com.codename1.impl.android.LifecycleListener;\r\nimport com.codename1.impl.android.PlayServices;\r\nimport com.codename1.io.Log;\r\nimport com.codename1.ui.Display;\r\nimport com.google.android.gms.common.ConnectionResult;\r\nimport com.google.android.gms.common.api.GoogleApiClient;\r\nimport com.google.android.gms.location.*;\r\nimport com.google.android.gms.location.Geofence;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.tasks.OnFailureListener;\r\nimport com.google.android.gms.tasks.OnSuccessListener;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n *\r\n * @author Chen\r\n */\r\npublic class AndroidLocationPlayServiceManager extends com.codename1.location.LocationManager implements\r\n        GoogleApiClient.ConnectionCallbacks,\r\n        GoogleApiClient.OnConnectionFailedListener,\r\n        com.google.android.gms.location.LocationListener,\r\n        LifecycleListener {\r\n\r\n\r\n\r\n    static class ParcelableUtil {\r\n        public static byte[] marshall(Parcelable parceable) {\r\n            Parcel parcel = Parcel.obtain();\r\n            parceable.writeToParcel(parcel, 0);\r\n            byte[] bytes = parcel.marshall();\r\n            parcel.recycle();\r\n            return bytes;\r\n        }\r\n\r\n        public static Parcel unmarshall(byte[] bytes) {\r\n            Parcel parcel = Parcel.obtain();\r\n            parcel.unmarshall(bytes, 0, bytes.length);\r\n            parcel.setDataPosition(0); // This is extremely important!\r\n            return parcel;\r\n        }\r\n\r\n        public static <T> T unmarshall(byte[] bytes, Parcelable.Creator<T> creator) {\r\n            Parcel parcel = unmarshall(bytes);\r\n            T result = creator.createFromParcel(parcel);\r\n            parcel.recycle();\r\n            return result;\r\n        }\r\n    }\r\n\r\n    public final LocationCallback callback = new LocationCallback() {\r\n        public void onLocationResult(LocationResult var1) {\r\n            AndroidLocationPlayServiceManager.this.onLocationChanged(var1.getLastLocation());\r\n        }\r\n\r\n        public void onLocationAvailability(LocationAvailability var1) {\r\n\r\n        }\r\n    };\r\n\r\n    public static AndroidLocationPlayServiceManager inMemoryBackgroundLocationListener;\r\n\r\n    private GoogleApiClient mGoogleApiClient;\r\n    private GeofencingClient geofencingClient;\r\n\r\n    private LocationRequest locationRequest;\r\n\r\n    private static AndroidLocationPlayServiceManager instance = new AndroidLocationPlayServiceManager();\r\n\r\n    public AndroidLocationPlayServiceManager() {\r\n    }\r\n\r\n    public static AndroidLocationPlayServiceManager getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    @Override\r\n    public Location getCurrentLocation() throws IOException {\r\n        Location l = getLastKnownLocation();\r\n        if (l == null) {\r\n            throw new IOException(\"cannot retrieve location try later\");\r\n        }\r\n        return l;\r\n    }\r\n\r\n    @Override\r\n    public Location getLastKnownLocation() {\r\n        while (!getmGoogleApiClient().isConnected()) {\r\n            try {\r\n                Thread.sleep(300);\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        //android.location.Location location = LocationServices.FusedLocationApi.getLastLocation(getmGoogleApiClient());\r\n        android.location.Location location = PlayServices.getInstance().getLastKnownLocation(getmGoogleApiClient());\r\n        if (location != null) {\r\n            return AndroidLocationManager.convert(location);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    protected void bindListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        LocationRequest r = locationRequest;\r\n\r\n                        com.codename1.location.LocationRequest request = getRequest();\r\n                        if (request != null) {\r\n                            LocationRequest lr = LocationRequest.create();\r\n                            if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_HIGH_ACCUARCY) {\r\n                                lr.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n                            } else if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_MEDIUM_ACCUARCY) {\r\n                                lr.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);\r\n                            } else {\r\n                                lr.setPriority(LocationRequest.PRIORITY_LOW_POWER);\r\n                            }\r\n                            lr.setInterval(request.getInterval());\r\n                            r = lr;\r\n                        }\r\n                        if (AndroidImplementation.getActivity() == null) {\r\n                            // we are in the background\r\n                            // Sometimes using regular locations in the background causes a crash\r\n                            // so we need to use the pending intent version.\r\n                            Context context = AndroidNativeUtil.getContext();\r\n\r\n                            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n                            //there is an bug that causes this to not to workhttps://code.google.com/p/android/issues/detail?id=81812\r\n                            //intent.putExtra(\"backgroundClass\", getBackgroundLocationListener().getName());\r\n                            //an ugly workaround to the putExtra bug \r\n                            if (bgListenerClass != null) {\r\n                                intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n                            }\r\n                            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\r\n                                    intent,\r\n                                    PendingIntent.FLAG_UPDATE_CURRENT);\r\n                            inMemoryBackgroundLocationListener = AndroidLocationPlayServiceManager.this;\r\n\r\n\r\n                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, pendingIntent);\r\n                            requestLocationUpdates(context, r, pendingIntent);\r\n                        } else {\r\n                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, AndroidLocationPlayServiceManager.this);\r\n                            requestLocationUpdates(AndroidNativeUtil.getContext(), r, AndroidLocationPlayServiceManager.this);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    private void requestLocationUpdates(Context context, LocationRequest req, PendingIntent pendingIntent) {\r\n        PlayServices.getInstance().requestLocationUpdates(getmGoogleApiClient(), context, req, pendingIntent);\r\n    }\r\n\r\n\r\n    private PendingIntent createBackgroundPendingIntent() {\r\n        return createBackgroundPendingIntent(false);\r\n    }\r\n\r\n    private PendingIntent createBackgroundPendingIntent(boolean forceService) {\r\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return null;\r\n        }\r\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\r\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n            return pendingIntent;\r\n        } else {\r\n\r\n\r\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\r\n                    intent,\r\n                    PendingIntent.FLAG_UPDATE_CURRENT);\r\n            return pendingIntent;\r\n        }\r\n    }\r\n\r\n    static android.location.Location extractLocationFromIntent(Intent intent) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            LocationResult locationResult = LocationResult.extractResult(intent);\r\n            if (locationResult == null) {\r\n                return null;\r\n            }\r\n            return locationResult.getLastLocation();\r\n        } else {\r\n            return intent.getParcelableExtra(FusedLocationProviderApi.KEY_LOCATION_CHANGED);\r\n        }\r\n    }\r\n\r\n    private void requestLocationUpdates(Context context, LocationRequest req, AndroidLocationPlayServiceManager mgr) {\r\n        PlayServices.getInstance().requestLocationUpdates(getmGoogleApiClient(), context, req, mgr);\r\n    }\r\n\r\n    private void removeLocationUpdates(Context context, AndroidLocationPlayServiceManager mgr) {\r\n        PlayServices.getInstance().removeLocationUpdates(getmGoogleApiClient(), context, mgr);\r\n    }\r\n\r\n    private void removeLocationUpdates(Context context, PendingIntent pendingIntent) {\r\n        PlayServices.getInstance().removeLocationUpdates(getmGoogleApiClient(), context, pendingIntent);\r\n    }\r\n\r\n    @Override\r\n    protected void clearListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //mGoogleApiClient must be connected\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        if (inMemoryBackgroundLocationListener != null) {\r\n                            Context context = AndroidNativeUtil.getContext();\r\n                            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n                            if (bgListenerClass != null) {\r\n                                intent.putExtra(\"backgroundClass\", bgListenerClass.getName());\r\n                            }\r\n                            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\r\n                                    intent,\r\n                                    PendingIntent.FLAG_UPDATE_CURRENT);\r\n\r\n                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), pendingIntent);\r\n                            removeLocationUpdates(context, pendingIntent);\r\n                            inMemoryBackgroundLocationListener = null;\r\n                        } else {\r\n                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), AndroidLocationPlayServiceManager.this);\r\n                            removeLocationUpdates(AndroidNativeUtil.getContext(), AndroidLocationPlayServiceManager.this);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    protected void bindBackgroundListener() {\r\n        if (!checkBackgroundLocationPermission()) {\r\n            return;\r\n        }\r\n\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        //don't be too aggressive for location updates in the background\r\n                        LocationRequest req = LocationRequest.create();\r\n                        setupBackgroundLocationRequest(req);\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n                        PendingIntent pendingIntent = createBackgroundPendingIntent();\r\n                        requestLocationUpdates(context, req, pendingIntent);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    private void setupBackgroundLocationRequest(LocationRequest req) {\r\n        Display d = Display.getInstance();\r\n        String priorityStr = d.getProperty(\"android.backgroundLocation.priority\", \"PRIORITY_BALANCED_POWER_ACCURACY\");\r\n        String fastestIntervalStr = d.getProperty(\"android.backgroundLocation.fastestInterval\", \"5000\");\r\n        String intervalStr = d.getProperty(\"android.backgroundLocation.interval\", \"10000\");\r\n        String smallestDisplacementStr = d.getProperty(\"android.backgroundLocation.smallestDisplacement\", \"50\");\r\n\r\n        int priority = LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY;\r\n        if (\"PRIORITY_HIGH_ACCURACY\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_HIGH_ACCURACY;\r\n        } else if (\"PRIORITY_LOW_POWER\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_LOW_POWER;\r\n        } else if (\"PRIORITY_NO_POWER\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_NO_POWER;\r\n        }\r\n\r\n        long interval = Long.parseLong(intervalStr);\r\n        long fastestInterval = Long.parseLong(fastestIntervalStr);\r\n        int smallestDisplacement = Integer.parseInt(smallestDisplacementStr);\r\n\r\n        req.setPriority(priority)\r\n                .setFastestInterval(fastestInterval)\r\n                .setInterval(interval)\r\n                .setSmallestDisplacement(smallestDisplacement);\r\n    }\r\n\r\n    @Override\r\n    protected void clearBackgroundListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //mGoogleApiClient must be connected\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n                        PendingIntent pendingIntent = createBackgroundPendingIntent();\r\n                        removeLocationUpdates(context, pendingIntent);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    @Override\r\n    public void onLocationChanged(final android.location.Location loc) {\r\n        synchronized (this) {\r\n            final com.codename1.location.LocationListener l = getLocationListener();\r\n            if (l != null) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        Location lastLocation = AndroidLocationManager.convert(loc);\r\n                        l.locationUpdated(lastLocation);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onConnected(Bundle bundle) {\r\n        locationRequest = LocationRequest.create();\r\n        locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n        locationRequest.setInterval(1000); // Update location every second\r\n\r\n        setLocationManagerStatus(AVAILABLE);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionSuspended(int i) {\r\n        setLocationManagerStatus(TEMPORARILY_UNAVAILABLE);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionFailed(ConnectionResult cr) {\r\n        setLocationManagerStatus(OUT_OF_SERVICE);\r\n    }\r\n\r\n\r\n    private void setLocationManagerStatus(final int status) {\r\n\r\n        int current = getStatus();\r\n        if (current != status) {\r\n            setStatus(status);\r\n            synchronized (this) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        com.codename1.location.LocationListener l = getLocationListener();\r\n                        if (l != null) {\r\n                            l.providerStateChanged(status);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private PendingIntent geofencePendingIntent;\r\n\r\n    private PendingIntent createGeofencePendingIntent(Class geofenceListenerClass, com.codename1.location.Geofence gf, boolean forceService) {\r\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n\r\n\r\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            if (geofencePendingIntent != null) {\r\n                return geofencePendingIntent;\r\n            }\r\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\r\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_GEOFENCE_TRANSITIONS);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + geofenceListenerClass.getName()));\r\n            //intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_GEOFENCE_TRANSITIONS);\r\n            geofencePendingIntent = PendingIntent.getBroadcast(AndroidNativeUtil.getContext().getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n            return geofencePendingIntent;\r\n        } else {\r\n\r\n            Intent intent = new Intent(context, GeofenceHandler.class);\r\n            intent.putExtra(\"geofenceClass\", geofenceListenerClass.getName());\r\n            intent.putExtra(\"geofenceID\", gf.getId());\r\n            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\r\n                    intent,\r\n                    PendingIntent.FLAG_UPDATE_CURRENT);\r\n\r\n\r\n            return pendingIntent;\r\n        }\r\n    }\r\n\r\n    @RequiresApi(api = 29)\r\n    private boolean checkBackgroundLocationPermission() {\r\n        if (!AndroidNativeUtil.checkForPermission(\"android.permission.ACCESS_BACKGROUND_LOCATION\", \"This is required to get the location\")) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void addGeoFencing(final Class GeofenceListenerClass, final com.codename1.location.Geofence gf) {\r\n        //Display.getInstance().scheduleBackgroundTask(new Runnable() {\r\n        boolean fineLocationAllowed = AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get location\");\r\n        if (fineLocationAllowed && android.os.Build.VERSION.SDK_INT >= 29) {\r\n\r\n            if (!checkBackgroundLocationPermission()) {\r\n                return;\r\n            }\r\n\r\n        } else if (!fineLocationAllowed) {\r\n            fineLocationAllowed = AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get the location\");\r\n        }\r\n        if (!fineLocationAllowed) {\r\n            Log.e(new RuntimeException(\"Permission denied for geofence\"));\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                //com.codename1.io.Log.p(\"PLACES add \"+gf.getId()+\" 1\");\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                //com.codename1.io.Log.p(\"PLACES add \"+gf.getId()+\" 2\");\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n\r\n                        PendingIntent pendingIntent = createGeofencePendingIntent(GeofenceListenerClass, gf, false);\r\n                        final ArrayList<Geofence> geofences = new ArrayList<Geofence>();\r\n                        geofences.add(new Geofence.Builder()\r\n                                .setRequestId(gf.getId())\r\n                                .setCircularRegion(gf.getLoc().getLatitude(), gf.getLoc().getLongitude(), gf.getRadius())\r\n                                .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER\r\n                                        | Geofence.GEOFENCE_TRANSITION_EXIT)\r\n                                .setExpirationDuration(gf.getExpiration() > 0 ? gf.getExpiration() : Geofence.NEVER_EXPIRE)\r\n                                .build());\r\n\r\n                        GeofencingRequest.Builder builder = new GeofencingRequest.Builder();\r\n                        builder.setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER);\r\n                        builder.addGeofences(geofences);\r\n\r\n                        if (!AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"Fine location permission required\")) {\r\n                            // TODO: Consider calling\r\n                            //    ActivityCompat#requestPermissions\r\n                            // here to request the missing permissions, and then overriding\r\n                            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                            //                                          int[] grantResults)\r\n                            // to handle the case where the user grants the permission. See the documentation\r\n                            // for ActivityCompat#requestPermissions for more details.\r\n                            System.out.println(\"No permission\");\r\n                            return;\r\n                        }\r\n                        geofencingClient = geofencingClient == null ? LocationServices.getGeofencingClient(AndroidNativeUtil.getContext().getApplicationContext()) :\r\n                                geofencingClient;\r\n                        geofencingClient.addGeofences(builder.build(), pendingIntent)\r\n                                .addOnSuccessListener(AndroidNativeUtil.getActivity(), new OnSuccessListener<Void>() {\r\n                                    @Override\r\n                                    public void onSuccess(Void aVoid) {\r\n                                        // Geofences added\r\n                                        // ...\r\n\r\n                                        //com.codename1.io.Log.p(\"Geofence added successfully \" + geofences);\r\n                                    }\r\n                                })\r\n                                .addOnFailureListener(AndroidNativeUtil.getActivity(), new OnFailureListener() {\r\n                                    @Override\r\n                                    public void onFailure(@NonNull Exception e) {\r\n                                        // Failed to add geofences\r\n                                        // ...\r\n                                        com.codename1.io.Log.e(e);\r\n                                    }\r\n                                });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    /**\r\n     * Stop tracking a Geofence if isGeofenceSupported() returns false this\r\n     * method does nothing\r\n     *\r\n     * @param id a Geofence id to stop tracking\r\n     */\r\n    public void removeGeoFencing(final String id) {\r\n        //Display.getInstance().scheduleBackgroundTask(new Runnable() {\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                //com.codename1.io.Log.p(\"PLACES remove \"+id);\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                //com.codename1.io.Log.p(\"PLACES remove \"+id+\" 2\");\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n\r\n                        ArrayList<String> ids = new ArrayList<String>();\r\n                        ids.add(id);\r\n                        geofencingClient = geofencingClient == null ? LocationServices.getGeofencingClient(AndroidNativeUtil.getContext().getApplicationContext()) :\r\n                                geofencingClient;\r\n                        geofencingClient.removeGeofences(ids);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    /**\r\n     * LifeCycle methods\r\n     *\r\n     */\r\n    @Override\r\n    public void onCreate(Bundle savedInstanceState) {\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        getmGoogleApiClient(); // This should initialize it if it isn't already.\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {\r\n            mGoogleApiClient.disconnect();\r\n        }\r\n        if (mGoogleApiClient != null) {\r\n            mGoogleApiClient = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onSaveInstanceState(Bundle b) {\r\n    }\r\n\r\n    @Override\r\n    public void onLowMemory() {\r\n    }\r\n\r\n    @Override\r\n    public boolean isGPSDetectionSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isBackgroundLocationSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isGeofenceSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isGPSEnabled() {\r\n        Context context = AndroidNativeUtil.getContext();\r\n        android.location.LocationManager locationManager = (android.location.LocationManager) context.getSystemService(Context.LOCATION_SERVICE);\r\n        return locationManager.isProviderEnabled(android.location.LocationManager.GPS_PROVIDER);\r\n    }\r\n\r\n    /**\r\n     * @return the mGoogleApiClient\r\n     */\r\n    private GoogleApiClient getmGoogleApiClient() {\r\n        if (mGoogleApiClient == null) {\r\n            mGoogleApiClient = new GoogleApiClient.Builder(AndroidNativeUtil.getContext())\r\n                    .addApi(LocationServices.API)\r\n                    .addConnectionCallbacks(this)\r\n                    .addOnConnectionFailedListener(this)\r\n                    .build();\r\n            if (!mGoogleApiClient.isConnected()) {\r\n                mGoogleApiClient.connect();\r\n            }\r\n        }\r\n\r\n        return mGoogleApiClient;\r\n    }\r\n\r\n    /**\r\n     * @param mGoogleApiClient the mGoogleApiClient to set\r\n     */\r\n    private void setmGoogleApiClient(GoogleApiClient mGoogleApiClient) {\r\n        this.mGoogleApiClient = mGoogleApiClient;\r\n    }\r\n\r\n}", "/*\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Codename One designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *  \n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n * \n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n * \n * Please contact Codename One through http://www.codenameone.com/ if you \n * need additional information or have any questions.\n */\npackage com.codename1.media;\n\n\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.os.Build;\n\nimport android.os.Bundle;\nimport android.os.ResultReceiver;\n//import android.support.annotation.NonNull;\n//import android.support.annotation.Nullable;\nimport android.support.v4.app.NotificationManagerCompat;\nimport android.support.v4.media.MediaBrowserCompat;\nimport android.support.v4.media.MediaBrowserServiceCompat;\nimport android.support.v4.media.MediaMetadataCompat;\nimport android.support.v4.app.NotificationCompat;\nimport android.support.v4.media.app.NotificationCompat.MediaStyle;\nimport android.support.v4.media.session.MediaButtonReceiver;\nimport android.support.v4.media.session.MediaSessionCompat;\nimport android.support.v4.media.session.PlaybackStateCompat;\n\nimport android.text.TextUtils;\n\nimport com.codename1.ui.Display;\n\n\nimport java.util.List;\n\n/**\n * A service used for communicating with the remote control (on the lock screen) for background\n * media.\n * @author shannah\n */\n\npublic class BackgroundAudioService extends MediaBrowserServiceCompat implements MediaPlayer.OnCompletionListener, AudioManager.OnAudioFocusChangeListener  {\n\n    public static final String COMMAND_EXAMPLE = \"command_example\";\n    private static final String TAG_FOREGROUND_SERVICE = \"FOREGROUND_SERVICE\";\n    private static BackgroundAudioService instance;\n    public static BackgroundAudioService getInstance() {\n        return instance;\n    }\n\n\n    //private MediaPlayer mMediaPlayer;\n    private MediaSessionCompat mMediaSessionCompat;\n\n    private BroadcastReceiver mNoisyReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            //if( mMediaPlayer != null && mMediaPlayer.isPlaying() ) {\n            if( RemoteControlCallback.isPlaying() ) {\n                RemoteControlCallback.pause();\n                initMediaSession();\n                showPausedNotification();\n            }\n        }\n    };\n\n\n\n    private MediaSessionCompat.Callback mMediaSessionCallback = new MediaSessionCompat.Callback() {\n\n        @Override\n        public boolean onMediaButtonEvent(Intent mediaButtonEvent) {\n            return super.onMediaButtonEvent(mediaButtonEvent);\n        }\n\n        @Override\n        public void onPlay() {\n            //super.onPlay();\n            if( !successfullyRetrievedAudioFocus() ) {\n                return;\n            }\n\n            mMediaSessionCompat.setActive(true);\n            setMediaPlaybackState(PlaybackStateCompat.STATE_PLAYING);\n\n\n            //mMediaPlayer.start();\n            RemoteControlCallback.play();\n            initMediaSessionMetadata();\n            showPlayingNotification();\n        }\n\n        @Override\n        public void onPause() {\n            //super.onPause();\n\n            if( RemoteControlCallback.isPlaying()) {\n                //mMediaPlayer.pause();\n                RemoteControlCallback.pause();\n                setMediaPlaybackState(PlaybackStateCompat.STATE_PAUSED);\n                showPausedNotification();\n            }\n        }\n\n        @Override\n        public void onPlayFromMediaId(String mediaId, Bundle extras) {\n            super.onPlayFromMediaId(mediaId, extras);\n        }\n\n        @Override\n        public void onFastForward() {\n            super.onFastForward();\n            RemoteControlCallback.fastForward();\n        }\n\n        @Override\n        public void onRewind() {\n            super.onRewind();\n            RemoteControlCallback.rewind();\n        }\n\n        @Override\n        public void onSkipToNext() {\n            super.onSkipToNext();\n            RemoteControlCallback.skipToNext();\n        }\n\n        @Override\n        public void onSkipToPrevious() {\n            super.onSkipToPrevious();\n            RemoteControlCallback.skipToPrevious();\n        }\n\n        @Override\n        public void onStop() {\n            super.onStop();\n            RemoteControlCallback.stop();\n            initMediaSessionMetadata();\n            showPausedNotification();\n        }\n        \n\n\n        @Override\n        public void onCommand(String command, Bundle extras, ResultReceiver cb) {\n            super.onCommand(command, extras, cb);\n            if( COMMAND_EXAMPLE.equalsIgnoreCase(command) ) {\n                //Custom command here\n            }\n        }\n\n        @Override\n        public void onSeekTo(long pos) {\n            super.onSeekTo(pos);\n            RemoteControlCallback.seekTo(pos);\n        }\n\n    };\n\n    @Override\n    public void onCreate() {\n        instance = this;\n        super.onCreate();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);\n        if( builder != null ) {\n            startForeground(1, builder.build());\n        }\n        //initMediaPlayer();\n        initMediaSession();\n        initNoisyReceiver();\n    }\n\n    private void initNoisyReceiver() {\n        //Handles headphones coming unplugged. cannot be done through a manifest receiver\n        IntentFilter filter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);\n        registerReceiver(mNoisyReceiver, filter);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n        audioManager.abandonAudioFocus(this);\n        unregisterReceiver(mNoisyReceiver);\n        mMediaSessionCompat.release();\n        NotificationManagerCompat.from(this).cancel(1);\n        stopForeground(true);\n    }\n\n   \n\n    void showPlayingNotification() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n        NotificationCompat.Builder builder = MediaStyleHelper.from(BackgroundAudioService.this, mMediaSessionCompat);\n        if( builder == null ) {\n            return;\n        }\n\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_previous, \"Prev\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_pause, \"Pause\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_PLAY_PAUSE)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_next, \"Next\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_NEXT)));\n\n\n\n        builder.setStyle(new MediaStyle()\n                .setShowActionsInCompactView(0, 1, 2)\n                .setShowCancelButton(true)\n                .setCancelButtonIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(\n                        this, PlaybackStateCompat.ACTION_STOP))\n                .setMediaSession(mMediaSessionCompat.getSessionToken()));\n        builder.setSmallIcon(android.R.drawable.stat_notify_sync);\n        Notification notification = builder.build();\n\n        NotificationManagerCompat.from(BackgroundAudioService.this).notify(1, notification);\n    }\n\n    void showPausedNotification() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n        NotificationCompat.Builder builder = MediaStyleHelper.from(this, mMediaSessionCompat);\n        if( builder == null ) {\n            return;\n        }\n\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_previous, \"Prev\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_play, \"Play\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_PLAY_PAUSE)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_next, \"Next\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_NEXT)));\n\n\n        builder.setStyle(new MediaStyle().setShowActionsInCompactView(0, 1, 2).setMediaSession(mMediaSessionCompat.getSessionToken()));\n        builder.setSmallIcon(android.R.drawable.stat_notify_sync);\n        Notification notification = builder.build();\n\n        NotificationManagerCompat.from(this).notify(1, notification);\n    }\n\n\n\n\n\n    private void initMediaSession() {\n        ComponentName mediaButtonReceiver = new ComponentName(getApplicationContext(), MediaButtonReceiver.class);\n        mMediaSessionCompat = new MediaSessionCompat(getApplicationContext(), \"Tag\", mediaButtonReceiver, null);\n\n        mMediaSessionCompat.setCallback(mMediaSessionCallback);\n        mMediaSessionCompat.setFlags( MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS | MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS );\n\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        mediaButtonIntent.setClass(this, MediaButtonReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, mediaButtonIntent, 0);\n        mMediaSessionCompat.setMediaButtonReceiver(pendingIntent);\n\n        setSessionToken(mMediaSessionCompat.getSessionToken());\n    }\n\n    private void setMediaPlaybackState(int state) {\n        PlaybackStateCompat.Builder playbackstateBuilder = new PlaybackStateCompat.Builder();\n        if( state == PlaybackStateCompat.STATE_PLAYING ) {\n            playbackstateBuilder.setActions(PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS);\n        } else {\n            playbackstateBuilder.setActions(PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS);\n        }\n        playbackstateBuilder.setState(state, PlaybackStateCompat.PLAYBACK_POSITION_UNKNOWN, 0);\n        mMediaSessionCompat.setPlaybackState(playbackstateBuilder.build());\n    }\n\n    void initMediaSessionMetadata() {\n        MediaMetadataCompat.Builder metadataBuilder = new MediaMetadataCompat.Builder();\n        //Notification icon in card\n        MediaMetaData md = RemoteControlCallback.getMetaData();\n        if (md == null) {\n            \n            return;\n        }\n        if (md.getDisplayIcon() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, i);\n        }\n        if (md.getAlbumArt() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, i);\n        }\n\n        //lock screen icon for pre lollipop\n        if (md.getArt() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_ART, i);\n        }\n        \n        metadataBuilder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE, md.getTitle());\n        metadataBuilder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_SUBTITLE, md.getSubtitle());\n        metadataBuilder.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, md.getTrackNumber());\n        metadataBuilder.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, md.getNumTracks());\n\n        mMediaSessionCompat.setMetadata(metadataBuilder.build());\n    }\n\n    private boolean successfullyRetrievedAudioFocus() {\n        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n\n        int result = audioManager.requestAudioFocus(this,\n                AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);\n\n        return result == AudioManager.AUDIOFOCUS_GAIN;\n    }\n\n\n    //Not important for general audio service, required for class\n    //@Nullable\n    @Override\n    public BrowserRoot onGetRoot( String clientPackageName, int clientUid,  Bundle rootHints) {\n        if(TextUtils.equals(clientPackageName, getPackageName())) {\n            return new BrowserRoot(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), null);\n        }\n\n        return null;\n    }\n\n    //Not important for general audio service, required for class\n    @Override\n    public void onLoadChildren(String parentId, Result<List<MediaBrowserCompat.MediaItem>> result) {\n        result.sendResult(null);\n    }\n\n    @Override\n    public void onAudioFocusChange(int focusChange) {\n        switch( focusChange ) {\n            case AudioManager.AUDIOFOCUS_LOSS: {\n                if( RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.stop();\n                    initMediaSessionMetadata();\n                    showPausedNotification();\n                }\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: {\n                RemoteControlCallback.pause();\n                initMediaSessionMetadata();\n                showPausedNotification();\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: {\n                if( RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.setVolume(0.3f, 0.3f);\n                }\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_GAIN: {\n                \n                if( !RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.play();\n                    initMediaSessionMetadata();\n                    showPlayingNotification();\n                }\n                RemoteControlCallback.setVolume(1.0f, 1.0f);\n                \n                break;\n            }\n        }\n    }\n\n    @Override\n    public void onCompletion(MediaPlayer mediaPlayer) {\n        \n        /*\n        if( mediaPlayer != null ) {\n            mMediaPlayer.release();\n        }\n*/\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        MediaButtonReceiver.handleIntent(mMediaSessionCompat, intent);\n        return super.onStartCommand(intent, flags, startId);\n    }\n    \n    static final String CHANNEL_ID = \"media_playback_channel\";\n\n    @android.support.annotation.RequiresApi(Build.VERSION_CODES.O)\n    private  void createChannel() {\n        createChannelStatic(this);\n    }\n\n\n\n    @android.support.annotation.RequiresApi(Build.VERSION_CODES.O)\n    static void createChannelStatic(Context ctx) {\n        NotificationManager\n                mNotificationManager =\n                (NotificationManager) ctx\n                        .getSystemService(Context.NOTIFICATION_SERVICE);\n        // The id of the channel.\n        String id = CHANNEL_ID;\n        // The user-visible name of the channel.\n        CharSequence name = \"Media playback\";\n        // The user-visible description of the channel.\n        String description = \"Media playback controls\";\n        int importance = NotificationManager.IMPORTANCE_LOW;\n        NotificationChannel mChannel = new NotificationChannel(id, name, importance);\n        // Configure the notification channel.\n        mChannel.setDescription(description);\n        mChannel.setShowBadge(false);\n        mChannel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);\n        mNotificationManager.createNotificationChannel(mChannel);\n    }\n}"], "fixing_code": ["/*\r\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Codename One designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *  \r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n * \r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n * \r\n * Please contact Codename One through http://www.codenameone.com/ if you \r\n * need additional information or have any questions.\r\n */\r\npackage com.codename1.impl.android;\r\n\r\nimport android.Manifest;\r\nimport android.annotation.TargetApi;\r\nimport com.codename1.location.AndroidLocationManager;\r\nimport android.app.*;\r\nimport android.content.pm.PackageManager.NameNotFoundException;\r\nimport android.media.AudioTimestamp;\r\nimport android.support.v4.content.ContextCompat;\r\nimport android.view.MotionEvent;\r\nimport com.codename1.codescan.ScanResult;\r\nimport com.codename1.media.Media;\r\nimport com.codename1.ui.geom.Dimension;\r\n\r\n\r\nimport android.webkit.CookieSyncManager;\r\nimport android.content.*;\r\nimport android.content.pm.*;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.graphics.Rect;\r\nimport android.graphics.Typeface;\r\nimport android.graphics.Path;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.media.AudioManager;\r\nimport android.net.Uri;\r\nimport android.os.Vibrator;\r\nimport android.telephony.TelephonyManager;\r\nimport android.util.DisplayMetrics;\r\nimport android.util.Log;\r\nimport android.util.TypedValue;\r\nimport android.view.KeyEvent;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.view.Window;\r\nimport android.webkit.WebSettings;\r\nimport android.webkit.WebView;\r\nimport android.webkit.WebViewClient;\r\nimport android.widget.RelativeLayout;\r\nimport android.widget.TextView;\r\nimport com.codename1.ui.BrowserComponent;\r\n\r\nimport com.codename1.ui.Component;\r\nimport com.codename1.ui.Font;\r\nimport com.codename1.ui.Image;\r\nimport com.codename1.ui.PeerComponent;\r\nimport com.codename1.ui.events.ActionEvent;\r\nimport com.codename1.impl.CodenameOneImplementation;\r\nimport com.codename1.impl.VirtualKeyboardInterface;\r\nimport com.codename1.ui.plaf.UIManager;\r\nimport com.codename1.ui.util.Resources;\r\nimport java.lang.ref.SoftReference;\r\nimport java.lang.reflect.Method;\r\nimport java.net.URISyntaxException;\r\nimport java.util.Vector;\r\nimport android.database.Cursor;\r\nimport android.database.sqlite.SQLiteDatabase;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.drawable.BitmapDrawable;\r\nimport android.hardware.Camera;\r\nimport android.media.AudioFormat;\r\nimport android.media.AudioRecord;\r\nimport android.media.ExifInterface;\r\nimport android.media.MediaPlayer;\r\nimport android.media.MediaRecorder;\r\nimport android.net.ConnectivityManager;\r\nimport android.net.NetworkInfo;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Environment;\r\nimport android.os.Handler;\r\nimport android.os.IBinder;\r\nimport android.os.Looper;\r\nimport android.os.RemoteException;\r\nimport android.provider.MediaStore;\r\nimport android.provider.Settings;\r\nimport android.provider.Settings.Secure;\r\nimport android.renderscript.Allocation;\r\nimport android.renderscript.Element;\r\nimport android.renderscript.RenderScript;\r\nimport android.renderscript.ScriptIntrinsicBlur;\r\nimport android.support.v4.app.NotificationCompat;\r\nimport android.support.v4.content.FileProvider;\r\nimport android.support.v4.media.MediaBrowserCompat;\r\nimport android.support.v4.media.session.MediaControllerCompat;\r\nimport android.support.v4.media.session.PlaybackStateCompat;\r\nimport android.telephony.SmsManager;\r\nimport android.telephony.gsm.GsmCellLocation;\r\nimport android.text.Html;\r\nimport android.view.*;\r\nimport android.view.View.MeasureSpec;\r\nimport android.webkit.*;\r\nimport android.widget.*;\r\nimport com.codename1.background.BackgroundFetch;\r\nimport com.codename1.capture.VideoCaptureConstraints;\r\nimport com.codename1.codescan.CodeScanner;\r\nimport com.codename1.contacts.Contact;\r\nimport com.codename1.db.Database;\r\nimport com.codename1.impl.android.compat.app.NotificationCompatWrapper;\r\nimport com.codename1.impl.android.compat.app.NotificationCompatWrapper.ActionWrapper;\r\nimport com.codename1.impl.android.compat.app.RemoteInputWrapper;\r\nimport com.codename1.io.BufferedInputStream;\r\nimport com.codename1.io.BufferedOutputStream;\r\nimport com.codename1.io.*;\r\nimport com.codename1.l10n.L10NManager;\r\nimport com.codename1.location.LocationManager;\r\nimport com.codename1.media.AbstractMedia;\r\nimport com.codename1.media.AsyncMedia;\r\nimport com.codename1.media.AsyncMedia.MediaErrorType;\r\nimport com.codename1.media.AsyncMedia.MediaException;\r\nimport com.codename1.media.Audio;\r\nimport com.codename1.media.AudioService;\r\nimport com.codename1.media.BackgroundAudioService;\r\nimport com.codename1.media.MediaProxy;\r\nimport com.codename1.media.MediaRecorderBuilder;\r\nimport com.codename1.messaging.Message;\r\nimport com.codename1.notifications.LocalNotification;\r\nimport com.codename1.payment.Purchase;\r\nimport com.codename1.push.PushAction;\r\nimport com.codename1.push.PushActionCategory;\r\nimport com.codename1.push.PushActionsProvider;\r\nimport com.codename1.push.PushCallback;\r\nimport com.codename1.push.PushContent;\r\nimport com.codename1.ui.*;\r\nimport com.codename1.ui.Dialog;\r\nimport com.codename1.ui.Display;\r\nimport com.codename1.ui.animations.Animation;\r\nimport com.codename1.ui.animations.CommonTransitions;\r\nimport com.codename1.ui.events.ActionListener;\r\nimport com.codename1.ui.geom.GeneralPath;\r\nimport com.codename1.ui.geom.Rectangle;\r\nimport com.codename1.ui.geom.Shape;\r\nimport com.codename1.ui.layouts.BorderLayout;\r\nimport com.codename1.ui.plaf.Style;\r\nimport com.codename1.ui.util.EventDispatcher;\r\nimport com.codename1.util.AsyncResource;\r\nimport com.codename1.util.Callback;\r\nimport java.io.File;\r\nimport java.io.FileDescriptor;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.io.RandomAccessFile;\r\nimport java.io.Writer;\r\nimport java.lang.reflect.Constructor;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URI;\r\nimport java.net.URL;\r\nimport java.net.URLConnection;\r\nimport java.text.DateFormat;\r\nimport java.text.NumberFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Date;\r\nimport java.util.Hashtable;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Set;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport com.codename1.util.StringUtil;\r\nimport com.codename1.util.SuccessCallback;\r\nimport java.io.*;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Modifier;\r\nimport java.net.CookieHandler;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.NetworkInterface;\r\nimport java.net.ServerSocket;\r\nimport java.security.MessageDigest;\r\nimport java.text.ParseException;\r\nimport java.util.*;\r\nimport javax.net.ssl.HttpsURLConnection;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\n\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\nimport org.json.JSONStringer;\r\nimport org.xml.sax.SAXException;\r\n//import android.webkit.JavascriptInterface;\r\n\r\npublic class AndroidImplementation extends CodenameOneImplementation implements IntentResultListener {\r\n    public static final Thread.UncaughtExceptionHandler exceptionHandler = new Thread.UncaughtExceptionHandler() {\r\n        @Override\r\n        public void uncaughtException(Thread t, Throwable e) {\r\n            if(com.codename1.io.Log.isCrashBound()) {\r\n                com.codename1.io.Log.p(\"Uncaught exception in thread \" + t.getName());\r\n                com.codename1.io.Log.e(e);\r\n                com.codename1.io.Log.sendLog();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * make sure these important keys have a negative value when passed to\r\n     * Codename One or they might be interpreted as characters.\r\n     */\r\n    static final int DROID_IMPL_KEY_LEFT = -23446;\r\n    static final int DROID_IMPL_KEY_RIGHT = -23447;\r\n    static final int DROID_IMPL_KEY_UP = -23448;\r\n    static final int DROID_IMPL_KEY_DOWN = -23449;\r\n    static final int DROID_IMPL_KEY_FIRE = -23450;\r\n    static final int DROID_IMPL_KEY_MENU = -23451;\r\n    static final int DROID_IMPL_KEY_BACK = -23452;\r\n    static final int DROID_IMPL_KEY_BACKSPACE = -23453;\r\n    static final int DROID_IMPL_KEY_CLEAR = -23454;\r\n    static final int DROID_IMPL_KEY_SEARCH = -23455;\r\n    static final int DROID_IMPL_KEY_CALL = -23456;\r\n    static final int DROID_IMPL_KEY_VOLUME_UP = -23457;\r\n    static final int DROID_IMPL_KEY_VOLUME_DOWN = -23458;\r\n    static final int DROID_IMPL_KEY_MUTE = -23459;\r\n    static int[] leftSK = new int[]{DROID_IMPL_KEY_MENU};\r\n\r\n    /**\r\n     * @return the activity\r\n     */\r\n    public static CodenameOneActivity getActivity() {\r\n        return activity;\r\n    }\r\n\r\n    /**\r\n     * @param aActivity the activity to set\r\n     */\r\n    public static void setActivity(CodenameOneActivity aActivity) {\r\n        activity = aActivity;\r\n        if (activity != null) {\r\n            activityComponentName = activity.getComponentName();\r\n        }\r\n        \r\n    }\r\n    CodenameOneSurface myView = null;\r\n    CodenameOneTextPaint defaultFont;\r\n    private final char[] tmpchar = new char[1];\r\n    private final Rect tmprect = new Rect();\r\n    protected int defaultFontHeight;\r\n    private Vibrator v = null;\r\n    private boolean vibrateInitialized = false;\r\n    private int displayWidth;\r\n    private int displayHeight;\r\n    static CodenameOneActivity activity;\r\n    static ComponentName activityComponentName;\r\n    \r\n    private static Context context;\r\n    RelativeLayout relativeLayout;\r\n    final Vector nativePeers = new Vector();\r\n    int lastDirectionalKeyEventReceivedByWrapper;\r\n    private EventDispatcher callback;\r\n    private int timeout = -1;\r\n    private CodeScannerImpl scannerInstance;\r\n    private HashMap apIds;\r\n    private static View viewBelow;\r\n    private static View viewAbove;\r\n    private static int aboveSpacing;\r\n    private static int belowSpacing;\r\n    public static boolean asyncView = false;\r\n    public static boolean textureView = false;\r\n    private AudioService background;\r\n    private boolean asyncEditMode = false;\r\n    private boolean compatPaintMode;\r\n    private MediaRecorder recorder = null;\r\n\r\n    private boolean statusBarHidden;\r\n    private boolean superPeerMode = true;\r\n    \r\n    \r\n    private ValueCallback<Uri> mUploadMessage;\r\n    public ValueCallback<Uri[]> uploadMessage;\r\n\r\n    /**\r\n     * Keeps track of running contexts.\r\n     * @see #startContext(Context)\r\n     * @see #stopContext(Context)\r\n     */\r\n    private static HashSet<Context> activeContexts = new HashSet<Context>();\r\n\r\n    /**\r\n     * A method to be called when a Context begins its execution.  This adds the\r\n     * context to the context set.  When the contenxt's execution completes, it should\r\n     * call {@link #stopContext} to clear up resources.\r\n     * @param ctx The context that is starting.\r\n     * @see #stopContext(Context)\r\n     */\r\n    public static void startContext(Context ctx) {\r\n\r\n        while (deinitializingEdt) {\r\n            // It is possible that deinitialize was called just before the\r\n            // last context was destroyed so there is a pending deinitialize\r\n            // working its way through the system.  Give it some time\r\n            // before forcing the deinitialize\r\n            System.out.println(\"Waiting for deinitializing to complete before starting a new initialization\");\r\n            try {\r\n                Thread.sleep(30);\r\n\r\n            } catch (Exception ex){}\r\n        }\r\n        if (deinitializing && instance != null) {\r\n            instance.deinitialize();\r\n        }\r\n        synchronized(activeContexts) {\r\n            activeContexts.add(ctx);\r\n            if (instance == null) {\r\n                // If this is our first rodeo, just call Display.init() as that should\r\n                // be sufficient to set everything up.\r\n                Display.init(ctx);\r\n            } else {\r\n                // If we've initialized before, we should \"re-initialize\" the implementation\r\n                // Reinitializing will force views to be created even if the EDT was already\r\n                // running in background mode.\r\n                reinit(ctx);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleans up resources in the given context.  This method should be called by\r\n     * any Activity or Service that called startContext() when it started.\r\n     * @param ctx The context to stop.\r\n     *\r\n     * @see #startContext(Context)\r\n     */\r\n    public static void stopContext(Context ctx) {\r\n        synchronized(activeContexts) {\r\n            activeContexts.remove(ctx);\r\n            if (activeContexts.isEmpty()) {\r\n                // If we are the last context, we should deinitialize\r\n                syncDeinitialize();\r\n            } else {\r\n                if (instance != null && getActivity() != null) {\r\n                    // if this is an activity, then we should clean up\r\n                    // our UI resources anyways because the last context\r\n                    // to be cleaned up might not have access to the UI thread.\r\n                    instance.deinitialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setPlatformHint(String key, String value) {\r\n        if(key.equals(\"platformHint.compatPaintMode\")) {\r\n            compatPaintMode = value.equalsIgnoreCase(\"true\");\r\n            return;\r\n        }\r\n        if(key.equals(\"platformHint.legacyPaint\")) {\r\n            AndroidAsyncView.legacyPaintLogic = value.equalsIgnoreCase(\"true\");;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method in used internally for ads\r\n     * @param above shown above the view\r\n     * @param below shown below the view\r\n     */\r\n    public static void setViewAboveBelow(View above, View below, int spacingAbove, int spacingBelow) {\r\n        viewBelow = below;\r\n        viewAbove = above;\r\n        aboveSpacing = spacingAbove;\r\n        belowSpacing = spacingBelow;\r\n    }\r\n\r\n    static boolean hasViewAboveBelow(){\r\n        return viewBelow != null || viewAbove != null;\r\n    }\r\n\r\n    /**\r\n     * Copy the input stream into the output stream, closes both streams when finishing or in\r\n     * a case of an exception\r\n     *\r\n     * @param i source\r\n     * @param o destination\r\n     */\r\n    private static void copy(InputStream i, OutputStream o) throws IOException {\r\n        copy(i, o, 8192);\r\n    }\r\n\r\n    /**\r\n     * Copy the input stream into the output stream, closes both streams when finishing or in\r\n     * a case of an exception\r\n     *\r\n     * @param i source\r\n     * @param o destination\r\n     * @param bufferSize the size of the buffer, which should be a power of 2 large enoguh\r\n     */\r\n    private static void copy(InputStream i, OutputStream o, int bufferSize) throws IOException {\r\n        try {\r\n            byte[] buffer = new byte[bufferSize];\r\n            int size = i.read(buffer);\r\n            while(size > -1) {\r\n                o.write(buffer, 0, size);\r\n                size = i.read(buffer);\r\n            }\r\n        } finally {\r\n            sCleanup(o);\r\n            sCleanup(i);\r\n        }\r\n    }\r\n\r\n    private static void sCleanup(Object o) {\r\n        try {\r\n            if(o != null) {\r\n                if(o instanceof InputStream) {\r\n                    ((InputStream)o).close();\r\n                    return;\r\n                }\r\n                if(o instanceof OutputStream) {\r\n                    ((OutputStream)o).close();\r\n                    return;\r\n                }\r\n            }\r\n        } catch(Throwable t) {}\r\n    }\r\n\r\n    /**\r\n     * Copied here since the cleanup method in util would crash append notification that runs when the app isn't in the foreground\r\n     */\r\n    private static byte[] readInputStream(InputStream i) throws IOException {\r\n        ByteArrayOutputStream b = new ByteArrayOutputStream();\r\n        copy(i, b);\r\n        return b.toByteArray();\r\n    }\r\n\r\n\r\n    public static void appendNotification(String type, String body, Context a) {\r\n        appendNotification(type, body, null, null, a);\r\n    }\r\n    \r\n    public static void appendNotification(String type, String body, String image, String category, Context a) {\r\n        try {\r\n            String[] fileList = a.fileList();\r\n            byte[] data = null;\r\n            for (int iter = 0; iter < fileList.length; iter++) {\r\n                if (fileList[iter].equals(\"CN1$AndroidPendingNotifications\")) {\r\n                    InputStream is = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n                    if(is != null) {\r\n                        data = readInputStream(is);\r\n                        sCleanup(a);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            DataOutputStream os = new DataOutputStream(a.openFileOutput(\"CN1$AndroidPendingNotifications\", 0));\r\n            if(data != null) {\r\n                data[0]++;\r\n                os.write(data);\r\n            } else {\r\n                os.writeByte(1);\r\n            }\r\n            String bodyType = type;\r\n            if (image != null || category != null) {\r\n                type = \"99\";\r\n            }\r\n            if(type != null) {\r\n                os.writeBoolean(true);\r\n                os.writeUTF(type);\r\n            } else {\r\n                os.writeBoolean(false);\r\n            }\r\n            if (\"99\".equals(type)) {\r\n                String msg = \"body=\"+java.net.URLEncoder.encode(body, \"UTF-8\")\r\n                        +\"&type=\"+java.net.URLEncoder.encode(bodyType, \"UTF-8\");\r\n                if (category != null) {\r\n                    msg += \"&category=\"+java.net.URLEncoder.encode(category, \"UTF-8\");\r\n                }\r\n                if (image != null) {\r\n                    image += \"&image=\"+java.net.URLEncoder.encode(image, \"UTF-8\");\r\n                }\r\n                os.writeUTF(msg);\r\n                        \r\n            } else {\r\n                os.writeUTF(body);\r\n            }\r\n            os.writeLong(System.currentTimeMillis());\r\n        } catch(IOException err) {\r\n            err.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static Map<String,String> splitQuery(String urlencodeQueryString) {\r\n        String[] parts = urlencodeQueryString.split(\"&\");\r\n        Map<String,String> out = new HashMap<String,String>();\r\n        for (String part : parts) {\r\n            int pos = part.indexOf(\"=\");\r\n            String k,v;\r\n            if (pos > 0) {\r\n                k = part.substring(0, pos);\r\n                v = part.substring(pos+1);\r\n            } else {\r\n                k = part;\r\n                v = \"\";\r\n            }\r\n            try { k = java.net.URLDecoder.decode(k, \"UTF-8\");} catch (Exception ex){}\r\n            try {v = java.net.URLDecoder.decode(v, \"UTF-8\");} catch (Exception ex){}\r\n            out.put(k, v);\r\n        }\r\n        return out;\r\n    }\r\n\r\n\r\n\r\n    public static void initPushContent(String message, String image, String messageType, String category, Context context) {\r\n        com.codename1.push.PushContent.reset();\r\n        \r\n        int iMessageType = 1;\r\n        try {iMessageType = Integer.parseInt(messageType);}catch(Throwable t){}\r\n        \r\n        String actionId = null;\r\n        String reply = null;\r\n        boolean cancel = true;\r\n        if (context instanceof Activity) {\r\n            Activity activity = (Activity)context;\r\n            Bundle extras = activity.getIntent().getExtras();\r\n            if (extras != null) {\r\n                actionId = extras.getString(\"pushActionId\");\r\n                extras.remove(\"pushActionId\");\r\n\r\n                if (actionId != null && RemoteInputWrapper.isSupported()) {\r\n                    Bundle textExtras = RemoteInputWrapper.getResultsFromIntent(activity.getIntent());\r\n                    if (textExtras != null) {\r\n                        CharSequence cs  = textExtras.getCharSequence(actionId + \"$Result\");\r\n                        if (cs != null) {\r\n                            reply = cs.toString();\r\n                        }\r\n                    }\r\n\r\n                    \r\n                }\r\n            }\r\n            \r\n        }\r\n        if (cancel) {\r\n            PushNotificationService.cancelNotification(context);\r\n        }\r\n        com.codename1.push.PushContent.setType(iMessageType);\r\n        com.codename1.push.PushContent.setCategory(category);\r\n        if (actionId != null) {\r\n            com.codename1.push.PushContent.setActionId(actionId);\r\n        }\r\n        if (reply != null) {\r\n            com.codename1.push.PushContent.setTextResponse(reply);\r\n        }\r\n        switch (iMessageType) {\r\n            case 1:\r\n            case 5:\r\n                com.codename1.push.PushContent.setBody(message);break;\r\n            case 2: com.codename1.push.PushContent.setMetaData(message);break;\r\n            case 3: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setMetaData(parts[1]);\r\n                com.codename1.push.PushContent.setBody(parts[0]);\r\n                break;\r\n            }\r\n            case 4: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setTitle(parts[0]);\r\n                com.codename1.push.PushContent.setBody(parts[1]);\r\n                break;\r\n            }\r\n            case 101: {\r\n                com.codename1.push.PushContent.setBody(message.substring(message.indexOf(\" \") + 1));\r\n                com.codename1.push.PushContent.setType(1);\r\n                break;\r\n            }\r\n            case 102: {\r\n                String[] parts = message.split(\";\");\r\n                com.codename1.push.PushContent.setTitle(parts[1]);\r\n                com.codename1.push.PushContent.setBody(parts[2]);\r\n                com.codename1.push.PushContent.setType(2);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Name of file where we install the push notification categories as an XML file\r\n    // if the main class implements PushActiosProvider\r\n    private static String FILE_NAME_NOTIFICATION_CATEGORIES = \"CN1$AndroidNotificationCategories\";\r\n    \r\n    \r\n    \r\n    /**\r\n     * Action categories are defined on the Main class by implementing the PushActionsProvider, however\r\n     * the main class may not be available to the push receiver, so we need to save these categories\r\n     * to the file system when the app is installed, then the push receiver can load these actions\r\n     * when it sends a push while the app isn't running.\r\n     * @param provider A reference to the App's main class \r\n     * @throws IOException \r\n     */\r\n    public static void installNotificationActionCategories(PushActionsProvider provider) throws IOException {\r\n        // Assume that CN1 is running... this will run when the app starts\r\n        // up\r\n        Context context = getContext();\r\n        boolean requiresUpdate = false;\r\n        \r\n        File categoriesFile = new File(activity.getFilesDir().getAbsolutePath() + \"/\" + FILE_NAME_NOTIFICATION_CATEGORIES);\r\n        if (!categoriesFile.exists()) {\r\n            requiresUpdate = true;\r\n        }\r\n        if (!requiresUpdate) {\r\n            try {\r\n                PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getApplicationContext().getPackageName(), PackageManager.GET_PERMISSIONS);\r\n                if (packageInfo.lastUpdateTime > categoriesFile.lastModified()) {\r\n                    requiresUpdate = true;\r\n                }\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        \r\n        if (!requiresUpdate) {\r\n            return;\r\n        }\r\n        \r\n        OutputStream os = getContext().openFileOutput(FILE_NAME_NOTIFICATION_CATEGORIES, 0);\r\n        PushActionCategory[] categories = provider.getPushActionCategories();\r\n        javax.xml.parsers.DocumentBuilderFactory docFactory = javax.xml.parsers.DocumentBuilderFactory.newInstance();\r\n        javax.xml.parsers.DocumentBuilder docBuilder;\r\n        try {\r\n            docBuilder = docFactory.newDocumentBuilder();\r\n        } catch (ParserConfigurationException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Faield to create document builder for creating notification categories XML document\", ex);\r\n        }\r\n\r\n        // root elements\r\n        org.w3c.dom.Document doc = docBuilder.newDocument();\r\n        org.w3c.dom.Element root = (org.w3c.dom.Element)doc.createElement(\"categories\");\r\n        doc.appendChild(root);\r\n        for (PushActionCategory category : categories) {\r\n            org.w3c.dom.Element categoryEl = (org.w3c.dom.Element)doc.createElement(\"category\");\r\n            org.w3c.dom.Attr idAttr = doc.createAttribute(\"id\");\r\n            idAttr.setValue(category.getId());\r\n            categoryEl.setAttributeNode(idAttr);\r\n            \r\n            for (PushAction action : category.getActions()) {\r\n                org.w3c.dom.Element actionEl = (org.w3c.dom.Element)doc.createElement(\"action\");\r\n                org.w3c.dom.Attr actionIdAttr = doc.createAttribute(\"id\");\r\n                actionIdAttr.setValue(action.getId());\r\n                actionEl.setAttributeNode(actionIdAttr);\r\n                \r\n                \r\n                org.w3c.dom.Attr actionTitleAttr = doc.createAttribute(\"title\");\r\n                if (action.getTitle() != null) {\r\n                    actionTitleAttr.setValue(action.getTitle());\r\n                } else {\r\n                    actionTitleAttr.setValue(action.getId());\r\n                }\r\n                actionEl.setAttributeNode(actionTitleAttr);\r\n                \r\n                if (action.getIcon() != null) {\r\n                    org.w3c.dom.Attr actionIconAttr = doc.createAttribute(\"icon\");\r\n                    String iconVal = action.getIcon();\r\n                    try {\r\n                        // We'll store the resource IDs for the icon\r\n                        // rather than the icon name because that is what\r\n                        // the push notifications require.\r\n                        iconVal = \"\"+context.getResources().getIdentifier(iconVal, \"drawable\", context.getPackageName());\r\n                        actionIconAttr.setValue(iconVal);\r\n                        actionEl.setAttributeNode(actionIconAttr);\r\n                    } catch (Exception ex) {\r\n                        ex.printStackTrace();\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n                if (action.getTextInputPlaceholder() != null) {\r\n                    org.w3c.dom.Attr textInputPlaceholderAttr = doc.createAttribute(\"textInputPlaceholder\");\r\n                    textInputPlaceholderAttr.setValue(action.getTextInputPlaceholder());\r\n                    actionEl.setAttributeNode(textInputPlaceholderAttr);\r\n                }\r\n                if (action.getTextInputButtonText() != null) {\r\n                    org.w3c.dom.Attr textInputButtonTextAttr = doc.createAttribute(\"textInputButtonText\");\r\n                    textInputButtonTextAttr.setValue(action.getTextInputButtonText());\r\n                    actionEl.setAttributeNode(textInputButtonTextAttr);\r\n                }\r\n                categoryEl.appendChild(actionEl);\r\n            }\r\n            root.appendChild(categoryEl);\r\n            \r\n        }\r\n        try {\r\n            javax.xml.transform.TransformerFactory transformerFactory = javax.xml.transform.TransformerFactory.newInstance();\r\n            javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\r\n            javax.xml.transform.dom.DOMSource source = new javax.xml.transform.dom.DOMSource(doc);\r\n            javax.xml.transform.stream.StreamResult result = new javax.xml.transform.stream.StreamResult(os);\r\n            transformer.transform(source, result);\r\n            \r\n        } catch (Exception ex) {\r\n            throw new IOException(\"Failed to save notification categories as XML.\", ex);\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Retrieves the app's available push action categories from the XML file in which they\r\n     * should have been installed on the first load.\r\n     * @param context\r\n     * @return\r\n     * @throws IOException \r\n     */\r\n    private static PushActionCategory[] getInstalledPushActionCategories(Context context) throws IOException {\r\n        // NOTE:  This method may be called from the PushReceiver when the app isn't running so we can't access\r\n        // the main activity context, display properties, or any CN1 stuff.  Just native android\r\n        \r\n        File categoriesFile = new File(context.getFilesDir().getAbsolutePath() + \"/\" + FILE_NAME_NOTIFICATION_CATEGORIES);\r\n        if (!categoriesFile.exists()) {\r\n            return new PushActionCategory[0];\r\n        }\r\n        javax.xml.parsers.DocumentBuilderFactory docFactory = javax.xml.parsers.DocumentBuilderFactory.newInstance();\r\n        javax.xml.parsers.DocumentBuilder docBuilder;\r\n        try {\r\n            docBuilder = docFactory.newDocumentBuilder();\r\n        } catch (ParserConfigurationException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Faield to create document builder for creating notification categories XML document\", ex);\r\n        }\r\n        org.w3c.dom.Document doc;\r\n        try {\r\n            doc = docBuilder.parse(context.openFileInput(FILE_NAME_NOTIFICATION_CATEGORIES));\r\n        } catch (SAXException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            throw new IOException(\"Failed to parse instaled push action categories\", ex);\r\n        }\r\n        org.w3c.dom.Element root = doc.getDocumentElement();\r\n        java.util.List<PushActionCategory> out = new ArrayList<PushActionCategory>();\r\n        org.w3c.dom.NodeList l = root.getElementsByTagName(\"category\");\r\n        int len = l.getLength();\r\n        for (int i=0; i<len; i++) {\r\n            org.w3c.dom.Element el = (org.w3c.dom.Element)l.item(i);\r\n            java.util.List<PushAction> actions = new ArrayList<PushAction>();\r\n            org.w3c.dom.NodeList al = el.getElementsByTagName(\"action\");\r\n            int alen = al.getLength();\r\n            for (int j=0; j<alen; j++) {\r\n                org.w3c.dom.Element actionEl = (org.w3c.dom.Element)al.item(j);\r\n                String textInputPlaceholder = actionEl.hasAttribute(\"textInputPlaceholder\") ? actionEl.getAttribute(\"textInputPlaceholder\") : null;\r\n                String textInputButtonText = actionEl.hasAttribute(\"textInputButtonText\") ? actionEl.getAttribute(\"textInputButtonText\") : null;\r\n                PushAction action = new PushAction(actionEl.getAttribute(\"id\"), actionEl.getAttribute(\"title\"), actionEl.getAttribute(\"icon\"), textInputPlaceholder, textInputButtonText);\r\n                actions.add(action);\r\n            }\r\n            \r\n            PushActionCategory cat = new PushActionCategory((String)el.getAttribute(\"id\"), actions.toArray(new PushAction[actions.size()]));\r\n            out.add(cat);\r\n            \r\n        }\r\n        return out.toArray(new PushActionCategory[out.size()]);\r\n    }\r\n\r\n    public static PendingIntent createPendingIntent(Context ctx, int value, Intent intent) {\r\n        if (android.os.Build.VERSION.SDK_INT >= 23) {\r\n            // PendingIntent.FLAG_IMMUTABLE\r\n            return PendingIntent.getActivity(ctx, value, newIntent, 67108864);\r\n        } else {\r\n            return PendingIntent.getActivity(ctx, value, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n        }\r\n    }\r\n\r\n    public static PendingIntent getPendingIntent(Context ctx, int value, Intent intent) {\r\n        if (android.os.Build.VERSION.SDK_INT >= 23) {\r\n            // PendingIntent.FLAG_IMMUTABLE\r\n            return PendingIntent.getService(ctx, value, newIntent, 67108864);\r\n        } else {\r\n            return PendingIntent.getService(ctx, value, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n        }\r\n        PendingIntent.getService\r\n    }\r\n\r\n    public static PendingIntent getBroadcastPendingIntent(Context ctx, int value, Intent intent) {\r\n        if (android.os.Build.VERSION.SDK_INT >= 23) {\r\n            // PendingIntent.FLAG_IMMUTABLE\r\n            return PendingIntent.getBroadcast(ctx, value, newIntent, 67108864);\r\n        } else {\r\n            return PendingIntent.getBroadcast(ctx, value, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n        }\r\n        PendingIntent.getService\r\n    }\r\n\r\n    /**\r\n     * Adds actions to a push notification.  This is called by the Push broadcast receiver probably before \r\n     * Codename One is initialized\r\n     * @param provider Reference to the app's main class which implements PushActionsProvider\r\n     * @param categoryId The category ID of the push notification.\r\n     * @param builder The builder for the push notification.\r\n     * @param targetIntent The target intent... this should go to the app's main Activity.\r\n     * @param context The current context (inside the Broadcast receiver).\r\n     * @throws IOException \r\n     */\r\n    public static void addActionsToNotification(PushActionsProvider provider, String categoryId, NotificationCompat.Builder builder, Intent targetIntent, Context context) throws IOException {\r\n        // NOTE:  THis will likely run when the main activity isn't running so we won't have\r\n        // access to any display properties... just native Android APIs will be accessible.\r\n        \r\n        PushActionCategory category = null;\r\n        PushActionCategory[] categories;\r\n        if (provider != null) {\r\n            categories = provider.getPushActionCategories();\r\n        } else {\r\n            categories = getInstalledPushActionCategories(context);\r\n        }\r\n        for (PushActionCategory candidateCategory : categories) {\r\n            if (categoryId.equals(candidateCategory.getId())) {\r\n                category = candidateCategory;\r\n                break;\r\n            }\r\n        }\r\n        if (category == null) {\r\n            return;\r\n        }\r\n        \r\n        int requestCode = 1;\r\n        for (PushAction action : category.getActions()) {\r\n            Intent newIntent = (Intent)targetIntent.clone();\r\n            newIntent.putExtra(\"pushActionId\", action.getId());\r\n            PendingIntent contentIntent = createPendingIntent(context, requestCode++, newIntent);\r\n            try {\r\n                int iconId = 0;\r\n                try { iconId = Integer.parseInt(action.getIcon());} catch (Exception ex){}\r\n                //android.app.Notification.Action.Builder actionBuilder = new android.app.Notification.Action.Builder(iconId, action.getTitle(), contentIntent);\r\n\r\n                System.out.println(\"Adding action \"+action.getId()+\", \"+action.getTitle()+\", icon=\"+iconId);\r\n                if (ActionWrapper.BuilderWrapper.isSupported()) {\r\n                    // We need to take this abstracted \"wrapper\" approach because the Action.Builder class, and RemoteInput class\r\n                    // aren't available until API 22.\r\n                    // These classes use reflection to provide support for these classes safely.\r\n                    ActionWrapper.BuilderWrapper actionBuilder = new ActionWrapper.BuilderWrapper(iconId, action.getTitle(), contentIntent);\r\n                    if (action.getTextInputPlaceholder() != null && RemoteInputWrapper.isSupported()) {\r\n                        RemoteInputWrapper.BuilderWrapper remoteInputBuilder = new RemoteInputWrapper.BuilderWrapper(action.getId()+\"$Result\");\r\n                        remoteInputBuilder.setLabel(action.getTextInputPlaceholder());\r\n\r\n                        RemoteInputWrapper remoteInput = remoteInputBuilder.build();\r\n                        actionBuilder.addRemoteInput(remoteInput);\r\n                    }\r\n                    ActionWrapper actionWrapper = actionBuilder.build();\r\n                    new NotificationCompatWrapper.BuilderWrapper(builder).addAction(actionWrapper);\r\n                } else {\r\n                    builder.addAction(iconId, action.getTitle(), contentIntent);\r\n                }\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    public static void firePendingPushes(final PushCallback c, final Context a) {\r\n        try {\r\n            if(c != null) {\r\n                InputStream i = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n                if(i == null) {\r\n                    return;\r\n                }\r\n                DataInputStream is = new DataInputStream(i);\r\n                int count = is.readByte();\r\n                for(int iter = 0 ; iter < count ; iter++) {\r\n                    boolean hasType = is.readBoolean();\r\n                    String actualType = null;\r\n                    if(hasType) {\r\n                        actualType = is.readUTF();\r\n                    }\r\n                    final String t;\r\n                    final String b;\r\n                    final String category;\r\n                    final String image;\r\n                    if (\"99\".equals(actualType)) {\r\n                        // This was a rich push\r\n                        Map<String,String> vals = splitQuery(is.readUTF());\r\n                        t = vals.get(\"type\");\r\n                        b = vals.get(\"body\");\r\n                        category = vals.get(\"category\");\r\n                        image = vals.get(\"image\");\r\n                    } else {\r\n                        t = actualType;\r\n                        b = is.readUTF();\r\n                        category = null;\r\n                        image = null;\r\n                    }\r\n                    long s = is.readLong();\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            Display.getInstance().setProperty(\"pendingPush\", \"true\");\r\n                            Display.getInstance().setProperty(\"pushType\", t);\r\n                            initPushContent(b, image, t, category, a);\r\n                            if(t != null && (\"3\".equals(t) || \"6\".equals(t))) {\r\n                                String[] a = b.split(\";\");\r\n                                c.push(a[0]);\r\n                                c.push(a[1]);\r\n                            } else if (t != null && (\"101\".equals(t))) {\r\n                                c.push(b.substring(b.indexOf(\" \")+1));\r\n                            } else {\r\n                                c.push(b);\r\n                            }\r\n                            Display.getInstance().setProperty(\"pendingPush\", null);\r\n                        }\r\n                    });\r\n                }\r\n                a.deleteFile(\"CN1$AndroidPendingNotifications\");\r\n            }\r\n        } catch(IOException err) {\r\n        }\r\n    }\r\n\r\n    public static String[] getPendingPush(String type, Context a) {\r\n        InputStream i = null;\r\n        try {\r\n            i = a.openFileInput(\"CN1$AndroidPendingNotifications\");\r\n            if (i == null) {\r\n                return null;\r\n            }\r\n            DataInputStream is = new DataInputStream(i);\r\n            int count = is.readByte();\r\n            Vector v = new Vector<String>();\r\n            for (int iter = 0; iter < count; iter++) {\r\n                boolean hasType = is.readBoolean();\r\n                String actualType = null;\r\n                if (hasType) {\r\n                    actualType = is.readUTF();\r\n                }\r\n                \r\n                final String t;\r\n                final String b;\r\n                if (\"99\".equals(actualType)) {\r\n                    // This was a rich push\r\n                    Map<String,String> vals = splitQuery(is.readUTF());\r\n                    t = vals.get(\"type\");\r\n                    b = vals.get(\"body\");\r\n                    //category = vals.get(\"category\");\r\n                    //image = vals.get(\"image\");\r\n                } else {\r\n                    t = actualType;\r\n                    b = is.readUTF();\r\n                    //category = null;\r\n                    //image = null;\r\n                }\r\n                long s = is.readLong();\r\n                if(t != null && (\"3\".equals(t) || \"6\".equals(t))) {\r\n                    String[] m = b.split(\";\");\r\n                    v.add(m[0]);\r\n                } else if(t != null && \"4\".equals(t)){\r\n                    String[] m = b.split(\";\");\r\n                    v.add(m[1]);\r\n                } else if(t != null && \"2\".equals(t)){\r\n                    continue;\r\n                }else if (t != null && \"101\".equals(t)) {\r\n                    v.add(b.substring(b.indexOf(\" \")+1));\r\n                }else{\r\n                    v.add(b);\r\n                }\r\n            }\r\n            String [] retVal = new String[v.size()];\r\n            for (int j = 0; j < retVal.length; j++) {\r\n                retVal[j] = (String)v.get(j);\r\n            }\r\n            return retVal;\r\n\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if(i != null){\r\n                    i.close();\r\n                }\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static AndroidImplementation instance;\r\n\r\n    public static AndroidImplementation getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    public static void clearAppArg() {\r\n        if (instance != null) {\r\n            instance.setAppArg(null);\r\n        }\r\n    }\r\n\r\n    public static Context getContext() {\r\n        Context out = getActivity();\r\n        if (out != null) {\r\n            return out;\r\n        }\r\n        return context;\r\n    }\r\n\r\n    public void setContext(Context c) {\r\n        context = c;\r\n    }\r\n\r\n    @Override\r\n    public void init(Object m) {\r\n        // NOTE:  Do not explicitly set the PlayServices instance to anything other than\r\n        // an instance of the base PlayServices class.  The Build Server will automatically\r\n        // swap this for the appropriate subclass depending on the playServicesVersion of \r\n        // the build.\r\n        PlayServices.setInstance(new PlayServices()); // <---- DO NOT CHANGE - Build server will replace with appropriate subclass instance\r\n        if (m instanceof CodenameOneActivity) {\r\n            setContext(null);\r\n            setActivity((CodenameOneActivity) m);\r\n        } else {\r\n            setActivity(null);\r\n            setContext((Context)m);\r\n        }\r\n\r\n        instance = this;\r\n        if(getActivity() != null && getActivity().hasUI()){\r\n            if (!hasActionBar()) {\r\n                try {\r\n                    getActivity().requestWindowFeature(Window.FEATURE_NO_TITLE);\r\n                } catch (Exception e) {\r\n                    //Log.d(\"Codename One\", \"No idea why this throws a Runtime Error\", e);\r\n                }\r\n            } else {\r\n                getActivity().invalidateOptionsMenu();\r\n                try {\r\n                    getActivity().requestWindowFeature(Window.FEATURE_ACTION_BAR);\r\n                    getActivity().requestWindowFeature(Window.FEATURE_PROGRESS);\r\n\r\n                    if(android.os.Build.VERSION.SDK_INT >= 21){\r\n                        //WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS\r\n                        getActivity().getWindow().addFlags(-2147483648);\r\n                    }\r\n                } catch (Exception e) {\r\n                    //Log.d(\"Codename One\", \"No idea why this throws a Runtime Error\", e);\r\n                }\r\n                NotifyActionBar notify = new NotifyActionBar(getActivity(), false);\r\n                notify.run();\r\n            }\r\n\r\n            if(statusBarHidden) {\r\n                getActivity().getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE\r\n                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);\r\n                getActivity().getWindow().setStatusBarColor(android.graphics.Color.TRANSPARENT);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"StatusbarHidden\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"KeepScreenOn\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\r\n            }\r\n\r\n            if(Display.getInstance().getProperty(\"DisableScreenshots\", \"\").equals(\"true\")){\r\n                getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);\r\n            }\r\n\r\n            if (m instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) m).setDefaultIntentResultListener(this);\r\n                ((CodenameOneActivity) m).setIntentResultListener(this);\r\n            }\r\n\r\n            /**\r\n             * translate our default font height depending on the screen density.\r\n             * this is required for new high resolution devices. otherwise\r\n             * everything looks awfully small.\r\n             *\r\n             * we use our default font height value of 16 and go from there. i\r\n             * thought about using new Paint().getTextSize() for this value but if\r\n             * some new version of android suddenly returns values already tranlated\r\n             * to the screen then we might end up with too large fonts. the\r\n             * documentation is not very precise on that.\r\n             */\r\n            final int defaultFontPixelHeight = 16;\r\n            this.defaultFontHeight = this.translatePixelForDPI(defaultFontPixelHeight);\r\n\r\n\r\n            this.defaultFont = (CodenameOneTextPaint) ((NativeFont) this.createFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM)).font;\r\n            Display.getInstance().setTransitionYield(-1);\r\n\r\n            initSurface();\r\n            /**\r\n             * devices are extremely sensitive so dragging should start a little\r\n             * later than suggested by default implementation.\r\n             */\r\n            this.setDragStartPercentage(1);\r\n            VirtualKeyboardInterface vkb = new AndroidKeyboard(this);\r\n            Display.getInstance().registerVirtualKeyboard(vkb);\r\n            Display.getInstance().setDefaultVirtualKeyboard(vkb);\r\n\r\n            InPlaceEditView.endEdit();\r\n\r\n            getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\r\n\r\n            if (nativePeers.size() > 0) {\r\n                for (int i = 0; i < nativePeers.size(); i++) {\r\n                    ((AndroidImplementation.AndroidPeer) nativePeers.elementAt(i)).init();\r\n                }\r\n            }\r\n        } else {\r\n            /**\r\n             * translate our default font height depending on the screen density.\r\n             * this is required for new high resolution devices. otherwise\r\n             * everything looks awfully small.\r\n             *\r\n             * we use our default font height value of 16 and go from there. i\r\n             * thought about using new Paint().getTextSize() for this value but if\r\n             * some new version of android suddenly returns values already tranlated\r\n             * to the screen then we might end up with too large fonts. the\r\n             * documentation is not very precise on that.\r\n             */\r\n            final int defaultFontPixelHeight = 16;\r\n            this.defaultFontHeight = this.translatePixelForDPI(defaultFontPixelHeight);\r\n\r\n\r\n            this.defaultFont = (CodenameOneTextPaint) ((NativeFont) this.createFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM)).font;\r\n        }\r\n        HttpURLConnection.setFollowRedirects(false);\r\n        CookieHandler.setDefault(null);\r\n        VideoCaptureConstraints.init(new AndroidVideoCaptureConstraintsCompiler());\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public boolean isInitialized(){\r\n// Removing the check for null view to prevent strange things from happening when\r\n// calling from a Service context.\r\n//        if(getActivity() != null && myView == null){\r\n//            //if the view is null deinitialize the Display\r\n//            if(super.isInitialized()){\r\n//                syncDeinitialize();\r\n//            }\r\n//            return false;\r\n//        }\r\n        return super.isInitialized();\r\n    }\r\n\r\n    /**\r\n     * Reinitializes CN1.\r\n     * @param i Context to initialize it with.\r\n     *\r\n     * @see #startContext(Context)\r\n     */\r\n    private static void reinit(Object i) {\r\n        if (instance != null && ((i instanceof CodenameOneActivity) || instance.myView == null)) {\r\n            instance.init(i);\r\n        }\r\n        Display.init(i);\r\n\r\n        // This is a hack to fix an issue that caused the screen to appear blank when\r\n        // the app is loaded from memory after being unloaded.\r\n\r\n        // This issue only seems to occur when the Activity had been unloaded\r\n        // so to test this you'll need to check the \"Don't keep activities\" checkbox under/\r\n        // Developer options.\r\n        // Developer options.\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                Display.getInstance().invokeAndBlock(new Runnable(){ public void run(){\r\n                    try {\r\n                        Thread.sleep(50);\r\n\r\n                    } catch (Exception ex){}\r\n                }});\r\n                if (!Display.isInitialized() || Display.getInstance().isMinimized()) {\r\n                    return;\r\n                }\r\n                Form cur = Display.getInstance().getCurrent();\r\n                if (cur != null) {\r\n                    cur.forceRevalidate();\r\n                }\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    private static class InvalidateOptionsMenuImpl implements Runnable {\r\n        private Activity activity;\r\n\r\n        public InvalidateOptionsMenuImpl(Activity activity) {\r\n            this.activity = activity;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            activity.invalidateOptionsMenu();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Boolean isDarkMode() {\r\n        try {\r\n            int nightModeFlags = getActivity().getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK; \r\n            switch (nightModeFlags) { \r\n                case Configuration.UI_MODE_NIGHT_YES: \r\n                    return true;\r\n                case Configuration.UI_MODE_NIGHT_NO: \r\n                    return false;\r\n                default: \r\n                    return null;\r\n            } \r\n        } catch(Throwable t) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    \r\n    private boolean hasActionBar() {\r\n        return android.os.Build.VERSION.SDK_INT >= 11;\r\n    }\r\n\r\n    public int translatePixelForDPI(int pixel) {\r\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, pixel,\r\n                getContext().getResources().getDisplayMetrics());\r\n    }\r\n\r\n    /**\r\n     * Returns the platform EDT thread priority\r\n     */\r\n    public int getEDTThreadPriority(){\r\n        return Thread.NORM_PRIORITY;\r\n    }\r\n\r\n    @Override\r\n    public int getDeviceDensity() {\r\n        DisplayMetrics metrics = new DisplayMetrics();\r\n        if (getActivity() != null) {\r\n            getActivity().getWindowManager().getDefaultDisplay().getMetrics(metrics);\r\n        } else {\r\n            metrics = getContext().getResources().getDisplayMetrics();\r\n        }\r\n\r\n        if(metrics.densityDpi < DisplayMetrics.DENSITY_MEDIUM) {\r\n            return Display.DENSITY_LOW;\r\n        }\r\n\r\n        if(metrics.densityDpi < 213) {\r\n            return Display.DENSITY_MEDIUM;\r\n        }\r\n\r\n        // 213 == TV\r\n        if(metrics.densityDpi >= 213 &&  metrics.densityDpi <= DisplayMetrics.DENSITY_HIGH) {\r\n            return Display.DENSITY_HIGH;\r\n        }\r\n\r\n        if(metrics.densityDpi > DisplayMetrics.DENSITY_HIGH && metrics.densityDpi < 400) {\r\n            return Display.DENSITY_VERY_HIGH;\r\n        }\r\n\r\n        if(metrics.densityDpi >= 400 && metrics.densityDpi < 560) {\r\n            return Display.DENSITY_HD;\r\n        }\r\n\r\n        if(metrics.densityDpi >= 560 && metrics.densityDpi <= 640) {\r\n            return Display.DENSITY_2HD;\r\n        }\r\n        if(metrics.densityDpi > 640) {\r\n            return Display.DENSITY_4K;\r\n        }\r\n\r\n        return Display.DENSITY_MEDIUM;\r\n    }\r\n\r\n    /**\r\n     * A status flag to indicate that CN1 is in the process of deinitializing.\r\n     */\r\n    private static boolean deinitializing;\r\n    private static boolean deinitializingEdt;\r\n\r\n    public static void syncDeinitialize() {\r\n        if (deinitializingEdt){\r\n            return;\r\n        }\r\n        deinitializingEdt = true; // This will get unset in {@link #deinitialize()}\r\n        deinitializing = true;\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                Display.deinitialize();\r\n                deinitializingEdt = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    public void deinitialize() {\r\n        //activity.getWindowManager().removeView(relativeLayout);\r\n        super.deinitialize();\r\n        if (getActivity() != null) {\r\n\r\n            Runnable r = new Runnable() {\r\n                public void run() {\r\n                    synchronized (AndroidImplementation.this) {\r\n                        if (!deinitializing) {\r\n                            return;\r\n                        }\r\n                        deinitializing = false;\r\n                    }\r\n                    if (nativePeers.size() > 0) {\r\n                        for (int i = 0; i < nativePeers.size(); i++) {\r\n                            ((AndroidImplementation.AndroidPeer) nativePeers.elementAt(i)).deinit();\r\n                        }\r\n                    }\r\n                    if (relativeLayout != null) {\r\n                        relativeLayout.removeAllViews();\r\n                    }\r\n                    relativeLayout = null;\r\n                    myView = null;\r\n                }\r\n            };\r\n\r\n            if (Looper.getMainLooper().getThread() == Thread.currentThread()) {\r\n                deinitializing = true;\r\n                r.run();\r\n            } else {\r\n                deinitializing = true;\r\n                getActivity().runOnUiThread(r);\r\n            }\r\n        } else {\r\n            deinitializing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * init view. a lot of back and forth between this thread and the UI thread.\r\n     */\r\n    private void initSurface() {\r\n        if (getActivity() != null && myView == null) {\r\n            relativeLayout=  new RelativeLayout(getActivity());\r\n            relativeLayout.setLayoutParams(new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.FILL_PARENT,\r\n                    RelativeLayout.LayoutParams.FILL_PARENT));\r\n            relativeLayout.setFocusable(false);\r\n\r\n            getActivity().getWindow().setBackgroundDrawable(null);\r\n            if(asyncView) {\r\n                if(android.os.Build.VERSION.SDK_INT < 14){\r\n                    myView = new AndroidSurfaceView(getActivity(), AndroidImplementation.this);\r\n                } else {\r\n                    int hardwareAcceleration = 16777216;\r\n                    getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n                    myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n                }\r\n            } else {\r\n                int hardwareAcceleration = 16777216;\r\n                getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n                superPeerMode = true;\r\n                myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n            }\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n\r\n            relativeLayout.addView(myView.getAndroidView());\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n\r\n            int id = getActivity().getResources().getIdentifier(\"main\", \"layout\", getActivity().getApplicationInfo().packageName);\r\n            RelativeLayout root = (RelativeLayout) LayoutInflater.from(getActivity()).inflate(id, null);\r\n            if(viewAbove != null) {\r\n                RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                lp.addRule(RelativeLayout.ALIGN_PARENT_TOP);\r\n                lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n                lp2.setMargins(0, 0, aboveSpacing, 0);\r\n                relativeLayout.setLayoutParams(lp2);\r\n                root.addView(viewAbove, lp);\r\n            }\r\n            root.addView(relativeLayout);\r\n            if(viewBelow != null) {\r\n                RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                lp.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\r\n                lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n                lp2.setMargins(0, 0, 0, belowSpacing);\r\n                relativeLayout.setLayoutParams(lp2);\r\n                root.addView(viewBelow, lp);\r\n            }\r\n            getActivity().setContentView(root);\r\n            if (!myView.getAndroidView().hasFocus()) {\r\n                myView.getAndroidView().requestFocus();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void confirmControlView() {\r\n        if(myView == null){\r\n            return;\r\n        }\r\n        myView.getAndroidView().setVisibility(View.VISIBLE);\r\n        //ugly workaround for a bug where on some android versions the async view\r\n        //came back black from the background.\r\n        if(myView instanceof AndroidAsyncView){\r\n            new Thread(new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        ((AndroidAsyncView)myView).setPaintViewOnBuffer(false);\r\n                    } catch (Exception e) {\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n    }\r\n\r\n    public void hideNotifyPublic() {\r\n        super.hideNotify();\r\n        saveTextEditingState();\r\n    }\r\n\r\n    public void showNotifyPublic() {\r\n        super.showNotify();\r\n    }\r\n\r\n    @Override\r\n    public boolean isMinimized() {\r\n        return getActivity() == null || ((CodenameOneActivity)getActivity()).isBackground();\r\n    }\r\n\r\n    @Override\r\n    public boolean minimizeApplication() {\r\n        Intent startMain = new Intent(Intent.ACTION_MAIN);\r\n        startMain.addCategory(Intent.CATEGORY_HOME);\r\n        startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n        startMain.putExtra(\"WaitForResult\", Boolean.FALSE);\r\n        getContext().startActivity(startMain);\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void restoreMinimizedApplication() {\r\n        if (getActivity() != null) {\r\n            Intent i = new Intent(getActivity(), getActivity().getClass());\r\n            i.setAction(Intent.ACTION_MAIN);\r\n            i.addCategory(Intent.CATEGORY_LAUNCHER);\r\n            getContext().startActivity(i);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeInputImmediate() {\r\n        return true;\r\n    }\r\n\r\n    public void editString(final Component cmp, int maxSize, final int constraint, String text, int keyCode) {\r\n        if (keyCode > 0 && getKeyboardType() == Display.KEYBOARD_TYPE_QWERTY) {\r\n            text += (char) keyCode;\r\n        }\r\n        InPlaceEditView.edit(this, cmp, constraint);\r\n    }\r\n\r\n    protected boolean editInProgress() {\r\n        return InPlaceEditView.isEditing();\r\n    }\r\n\r\n    @Override\r\n    public boolean isAsyncEditMode() {\r\n        return asyncEditMode;\r\n    }\r\n\r\n    void setAsyncEditMode(boolean async) {\r\n        asyncEditMode = async;\r\n    }\r\n\r\n    void callHideTextEditor() {\r\n        super.hideTextEditor();\r\n    }\r\n\r\n    @Override\r\n    public void hideTextEditor() {\r\n        InPlaceEditView.hideActiveTextEditor();\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeEditorVisible(Component c) {\r\n        return super.isNativeEditorVisible(c) && !InPlaceEditView.isActiveTextEditorHidden();\r\n    }\r\n\r\n    public static void stopEditing() {\r\n        stopEditing(false);\r\n    }\r\n\r\n    public static void stopEditing(final boolean forceVKBClose){\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        final boolean[] flag = new boolean[]{false};\r\n\r\n        // InPlaceEditView.endEdit must be called from the UI thread.\r\n        // We must wait for this call to be over, otherwise Codename One's painting\r\n        // of the next form will be garbled.\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                // Must be called from the UI thread\r\n                InPlaceEditView.stopEdit(forceVKBClose);\r\n\r\n                synchronized (flag) {\r\n                    flag[0] = true;\r\n                    flag.notify();\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!flag[0]) {\r\n            // Wait (if necessary) for the asynchronous runOnUiThread to do its work\r\n            synchronized (flag) {\r\n\r\n                try {\r\n                    flag.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void saveTextEditingState() {\r\n        stopEditing(true);\r\n    }\r\n\r\n    @Override\r\n    public void stopTextEditing() {\r\n        saveTextEditingState();\r\n    }\r\n\r\n    @Override\r\n    public void stopTextEditing(final Runnable onFinish) {\r\n        final Form f = Display.getInstance().getCurrent();\r\n        f.addSizeChangedListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent evt) {\r\n                f.removeSizeChangedListener(this);\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        onFinish.run();\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        stopEditing(true);\r\n    }\r\n\r\n\r\n    protected void setLastSizeChangedWH(int w, int h) {\r\n        // not used?\r\n        //this.lastSizeChangeW = w;\r\n        //this.lastSizeChangeH = h;\r\n    }\r\n\r\n    /*@Override\r\n    public boolean handleEDTException(final Throwable err) {\r\n\r\n        final boolean[] messageComplete = new boolean[]{false};\r\n\r\n        Log.e(\"Codename One\", \"Err on EDT\", err);\r\n\r\n        activity.runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                UIManager m = UIManager.getInstance();\r\n                final FrameLayout frameLayout = new FrameLayout(\r\n                        activity);\r\n                final TextView textView = new TextView(\r\n                        activity);\r\n                textView.setGravity(Gravity.CENTER);\r\n                frameLayout.addView(textView, new FrameLayout.LayoutParams(\r\n                        FrameLayout.LayoutParams.FILL_PARENT,\r\n                        FrameLayout.LayoutParams.WRAP_CONTENT));\r\n                textView.setText(\"An internal application error occurred: \" + err.toString());\r\n                AlertDialog.Builder bob = new AlertDialog.Builder(\r\n                        activity);\r\n                bob.setView(frameLayout);\r\n                bob.setTitle(\"\");\r\n                bob.setPositiveButton(m.localize(\"ok\", \"OK\"),\r\n                        new DialogInterface.OnClickListener() {\r\n                            @Override\r\n                            public void onClick(DialogInterface d, int which) {\r\n                                d.dismiss();\r\n                                synchronized (messageComplete) {\r\n                                    messageComplete[0] = true;\r\n                                    messageComplete.notify();\r\n                                }\r\n                            }\r\n                        });\r\n                AlertDialog editDialog = bob.create();\r\n                editDialog.show();\r\n            }\r\n        });\r\n\r\n        synchronized (messageComplete) {\r\n            if (messageComplete[0]) {\r\n                return true;\r\n            }\r\n            try {\r\n                messageComplete.wait();\r\n            } catch (Exception ignored) {\r\n                ;\r\n            }\r\n        }\r\n        return true;\r\n    }*/\r\n\r\n    @Override\r\n    public InputStream getResourceAsStream(Class cls, String resource) {\r\n        try {\r\n            if (resource.startsWith(\"/\")) {\r\n                resource = resource.substring(1);\r\n            }\r\n            return getContext().getAssets().open(resource);\r\n        } catch (IOException ex) {\r\n            Log.i(\"Codename One\", \"Resource not found: \" + resource);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void pointerPressed(final int x, final int y) {\r\n        super.pointerPressed(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerPressed(final int[] x, final int[] y) {\r\n        super.pointerPressed(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerReleased(final int x, final int y) {\r\n        super.pointerReleased(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerReleased(final int[] x, final int[] y) {\r\n        super.pointerReleased(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerDragged(int x, int y) {\r\n        super.pointerDragged(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected void pointerDragged(int[] x, int[] y) {\r\n        super.pointerDragged(x, y);\r\n    }\r\n\r\n    @Override\r\n    protected int getDragAutoActivationThreshold() {\r\n        return 1000000;\r\n    }\r\n\r\n    @Override\r\n    public void flushGraphics() {\r\n        if (myView != null) {\r\n            myView.flushGraphics();\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void flushGraphics(int x, int y, int width, int height) {\r\n        this.tmprect.set(x, y, x + width, y + height);\r\n        if (myView != null) {\r\n            myView.flushGraphics(this.tmprect);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int charWidth(Object nativeFont, char ch) {\r\n        this.tmpchar[0] = ch;\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(this.tmpchar, 0, 1);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public int charsWidth(Object nativeFont, char[] ch, int offset, int length) {\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(ch, offset, length);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public int stringWidth(Object nativeFont, String str) {\r\n        float w = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font).measureText(str);\r\n        if (w - (int) w > 0) {\r\n            return (int) (w + 1);\r\n        }\r\n        return (int) w;\r\n    }\r\n\r\n    @Override\r\n    public void setNativeFont(Object graphics, Object font) {\r\n        if (font == null) {\r\n            font = this.defaultFont;\r\n        }\r\n        if (font instanceof NativeFont) {\r\n            ((AndroidGraphics) graphics).setFont((CodenameOneTextPaint) ((NativeFont) font).font);\r\n        } else {\r\n            ((AndroidGraphics) graphics).setFont((CodenameOneTextPaint) font);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getHeight(Object nativeFont) {\r\n        CodenameOneTextPaint font = (nativeFont == null ? this.defaultFont\r\n                : (CodenameOneTextPaint) ((NativeFont) nativeFont).font);\r\n        if(font.fontHeight < 0) {\r\n            Paint.FontMetrics fm = font.getFontMetrics();\r\n            font.fontHeight = (int)Math.ceil(fm.bottom - fm.top);\r\n        }\r\n        return font.fontHeight;\r\n    }\r\n\r\n    @Override\r\n    public int getFontAscent(Object nativeFont) {\r\n        Paint font = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font);\r\n        return -Math.round(font.getFontMetrics().ascent);\r\n    }\r\n\r\n    @Override\r\n    public int getFontDescent(Object nativeFont) {\r\n        Paint font = (nativeFont == null ? this.defaultFont\r\n                : (Paint) ((NativeFont) nativeFont).font);\r\n        return Math.abs(Math.round(font.getFontMetrics().descent));\r\n    }\r\n\r\n    @Override\r\n    public boolean isBaselineTextSupported() {\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    public int getFace(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.FACE_SYSTEM;\r\n        }\r\n        return ((NativeFont) nativeFont).face;\r\n    }\r\n\r\n    public int getStyle(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.STYLE_PLAIN;\r\n        }\r\n        return ((NativeFont) nativeFont).style;\r\n    }\r\n\r\n    @Override\r\n    public int getSize(Object nativeFont) {\r\n        if (nativeFont == null) {\r\n            return Font.SIZE_MEDIUM;\r\n        }\r\n        return ((NativeFont) nativeFont).size;\r\n    }\r\n\r\n    @Override\r\n    public boolean isTrueTypeSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeFontSchemeSupported() {\r\n        return true;\r\n    }\r\n\r\n    private Typeface fontToRoboto(String fontName) {\r\n        if(\"native:MainThin\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.NORMAL);\r\n        }\r\n        if(\"native:MainLight\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-light\", Typeface.NORMAL);\r\n        }\r\n        if(\"native:MainRegular\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif\", Typeface.NORMAL);\r\n        }\r\n\r\n        if(\"native:MainBold\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\r\n        }\r\n\r\n        if(\"native:MainBlack\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-black\", Typeface.BOLD);\r\n        }\r\n\r\n        if(\"native:ItalicThin\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicLight\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-thin\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicRegular\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif\", Typeface.ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicBold\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-condensed\", Typeface.BOLD_ITALIC);\r\n        }\r\n\r\n        if(\"native:ItalicBlack\".equals(fontName)) {\r\n            return Typeface.create(\"sans-serif-black\", Typeface.BOLD_ITALIC);\r\n        }\r\n\r\n        throw new IllegalArgumentException(\"Unsupported native font type: \" + fontName);\r\n    }\r\n\r\n    @Override\r\n    public Object loadTrueTypeFont(String fontName, String fileName) {\r\n        if(fontName.startsWith(\"native:\")) {\r\n            Typeface t = fontToRoboto(fontName);\r\n            int fontStyle = com.codename1.ui.Font.STYLE_PLAIN;\r\n            if(t.isBold()) {\r\n                fontStyle |= com.codename1.ui.Font.STYLE_BOLD;\r\n            }\r\n            if(t.isItalic()) {\r\n                fontStyle |= com.codename1.ui.Font.STYLE_ITALIC;\r\n            }\r\n            CodenameOneTextPaint newPaint = new CodenameOneTextPaint(t);\r\n            newPaint.setAntiAlias(true);\r\n            newPaint.setSubpixelText(true);\r\n            return new NativeFont(com.codename1.ui.Font.FACE_SYSTEM, fontStyle,\r\n                    com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fileName, 0, 0);\r\n        }\r\n        Typeface t = Typeface.createFromAsset(getContext().getAssets(), fileName);\r\n        if(t == null) {\r\n            throw new RuntimeException(\"Font not found: \" + fileName);\r\n        }\r\n        CodenameOneTextPaint newPaint = new CodenameOneTextPaint(t);\r\n        newPaint.setAntiAlias(true);\r\n        newPaint.setSubpixelText(true);\r\n        return new NativeFont(com.codename1.ui.Font.FACE_SYSTEM,\r\n                com.codename1.ui.Font.STYLE_PLAIN, com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fileName, 0, 0);\r\n    }\r\n\r\n    public static class NativeFont {\r\n        int face;\r\n        int style;\r\n        int size;\r\n        public Object font;\r\n        String fileName;\r\n        float height;\r\n        int weight;\r\n\r\n        public NativeFont(int face, int style, int size, Object font, String fileName, float height, int weight) {\r\n            this(face, style, size, font);\r\n            this.fileName = fileName;\r\n            this.height = height;\r\n            this.weight = weight;\r\n        }\r\n\r\n        public NativeFont(int face, int style, int size, Object font) {\r\n            this.face = face;\r\n            this.style = style;\r\n            this.size = size;\r\n            this.font = font;\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if(o == null) {\r\n                return false;\r\n            }\r\n            NativeFont n = ((NativeFont)o);\r\n            if(fileName != null) {\r\n                return n.fileName != null && fileName.equals(n.fileName) && n.height == height && n.weight == weight;\r\n            }\r\n            return n.face == face && n.style == style && n.size == size && font.equals(n.font);\r\n        }\r\n\r\n        public int hashCode() {\r\n            return face | style | size;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object deriveTrueTypeFont(Object font, float size, int weight) {\r\n        NativeFont fnt = (NativeFont)font;\r\n        CodenameOneTextPaint paint = (CodenameOneTextPaint)fnt.font;\r\n        paint.setAntiAlias(true);\r\n        Typeface type = paint.getTypeface();\r\n        int fontstyle = Typeface.NORMAL;\r\n        if ((weight & Font.STYLE_BOLD) != 0 || type.isBold()) {\r\n            fontstyle |= Typeface.BOLD;\r\n        }\r\n        if ((weight & Font.STYLE_ITALIC) != 0 || type.isItalic()) {\r\n            fontstyle |= Typeface.ITALIC;\r\n        }\r\n        type = Typeface.create(type, fontstyle);\r\n        CodenameOneTextPaint newPaint = new CodenameOneTextPaint(type);\r\n        newPaint.setTextSize(size);\r\n        newPaint.setAntiAlias(true);\r\n        NativeFont n = new NativeFont(com.codename1.ui.Font.FACE_SYSTEM, weight, com.codename1.ui.Font.SIZE_MEDIUM, newPaint, fnt.fileName, size, weight);\r\n        return n;\r\n    }\r\n\r\n    @Override\r\n    public Object createFont(int face, int style, int size) {\r\n        Typeface typeface = null;\r\n        switch (face) {\r\n            case Font.FACE_MONOSPACE:\r\n                typeface = Typeface.MONOSPACE;\r\n                break;\r\n            default:\r\n                typeface = Typeface.DEFAULT;\r\n                break;\r\n        }\r\n\r\n        int fontstyle = Typeface.NORMAL;\r\n        if ((style & Font.STYLE_BOLD) != 0) {\r\n            fontstyle |= Typeface.BOLD;\r\n        }\r\n        if ((style & Font.STYLE_ITALIC) != 0) {\r\n            fontstyle |= Typeface.ITALIC;\r\n        }\r\n\r\n\r\n        int height = this.defaultFontHeight;\r\n        int diff = height / 3;\r\n\r\n        switch (size) {\r\n            case Font.SIZE_SMALL:\r\n                height -= diff;\r\n                break;\r\n            case Font.SIZE_LARGE:\r\n                height += diff;\r\n                break;\r\n        }\r\n\r\n        Paint font = new CodenameOneTextPaint(Typeface.create(typeface, fontstyle));\r\n        font.setAntiAlias(true);\r\n        font.setUnderlineText((style & Font.STYLE_UNDERLINED) != 0);\r\n        font.setTextSize(height);\r\n        return new NativeFont(face, style, size, font);\r\n\r\n    }\r\n\r\n    /**\r\n     * Loads a native font based on a lookup for a font name and attributes.\r\n     * Font lookup values can be separated by commas and thus allow fallback if\r\n     * the primary font isn't supported by the platform.\r\n     *\r\n     * @param lookup string describing the font\r\n     * @return the native font object\r\n     */\r\n    public Object loadNativeFont(String lookup) {\r\n        try {\r\n            lookup = lookup.split(\";\")[0];\r\n            int typeface = Typeface.NORMAL;\r\n            String familyName = lookup.substring(0, lookup.indexOf(\"-\"));\r\n            String style = lookup.substring(lookup.indexOf(\"-\") + 1, lookup.lastIndexOf(\"-\"));\r\n            String size = lookup.substring(lookup.lastIndexOf(\"-\") + 1, lookup.length());\r\n\r\n            if (style.equals(\"bolditalic\")) {\r\n                typeface = Typeface.BOLD_ITALIC;\r\n            } else if (style.equals(\"italic\")) {\r\n                typeface = Typeface.ITALIC;\r\n            } else if (style.equals(\"bold\")) {\r\n                typeface = Typeface.BOLD;\r\n            }\r\n            Paint font = new CodenameOneTextPaint(Typeface.create(familyName, typeface));\r\n            font.setAntiAlias(true);\r\n            font.setTextSize(Integer.parseInt(size));\r\n            return new NativeFont(0, 0, 0, font);\r\n        } catch (Exception err) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates whether loading a font by a string is supported by the platform\r\n     *\r\n     * @return true if the platform supports font lookup\r\n     */\r\n    @Override\r\n    public boolean isLookupFontSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAntiAliasedTextSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setAntiAliasedText(Object graphics, boolean a) {\r\n        android.graphics.Paint p  = ((AndroidGraphics) graphics).getFont();\r\n        if(p != null) {\r\n            p.setAntiAlias(a);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object getDefaultFont() {\r\n        CodenameOneTextPaint paint = new CodenameOneTextPaint(this.defaultFont);\r\n        return new NativeFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_MEDIUM, paint);\r\n    }\r\n\r\n\r\n    private AndroidGraphics nullGraphics;\r\n\r\n    private AndroidGraphics getNullGraphics() {\r\n        if (nullGraphics == null) {\r\n            Bitmap bitmap = Bitmap.createBitmap(getDisplayWidth()==0?100:getDisplayWidth(), getDisplayHeight()==0?100:getDisplayHeight(),\r\n                    Bitmap.Config.ARGB_8888);\r\n            nullGraphics = (AndroidGraphics) this.getNativeGraphics(bitmap);\r\n        }\r\n        return nullGraphics;\r\n    }\r\n\r\n\r\n    @Override\r\n    public Object getNativeGraphics() {\r\n        if(myView != null){\r\n            nullGraphics = null;\r\n            return myView.getGraphics();\r\n        }else{\r\n            return getNullGraphics();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object getNativeGraphics(Object image) {\r\n        AndroidGraphics g =  new AndroidGraphics(this, new Canvas((Bitmap) image), true);\r\n        g.setClip(0, 0, ((Bitmap)image).getWidth(), ((Bitmap)image).getHeight());\r\n        return g;\r\n    }\r\n\r\n    @Override\r\n    public void getRGB(Object nativeImage, int[] arr, int offset, int x, int y,\r\n                       int width, int height) {\r\n        ((Bitmap) nativeImage).getPixels(arr, offset, width, x, y, width,\r\n                height);\r\n    }\r\n\r\n    private int sampleSizeOverride = -1;\r\n\r\n    @Override\r\n    public Object createImage(String path) throws IOException {\r\n        int IMAGE_MAX_SIZE = getDisplayHeight();\r\n        if (exists(path)) {\r\n            Bitmap b = null;\r\n            try {\r\n                //Decode image size\r\n                BitmapFactory.Options o = new BitmapFactory.Options();\r\n                o.inJustDecodeBounds = true;\r\n                o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                InputStream fis = createFileInputStream(path);\r\n                BitmapFactory.decodeStream(fis, null, o);\r\n                fis.close();\r\n\r\n                int scale = 1;\r\n                if (o.outHeight > IMAGE_MAX_SIZE || o.outWidth > IMAGE_MAX_SIZE) {\r\n                    scale = (int) Math.pow(2, (int) Math.round(Math.log(IMAGE_MAX_SIZE / (double) Math.max(o.outHeight, o.outWidth)) / Math.log(0.5)));\r\n                }\r\n\r\n                //Decode with inSampleSize\r\n                BitmapFactory.Options o2 = new BitmapFactory.Options();\r\n                o2.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                if(sampleSizeOverride != -1) {\r\n                    o2.inSampleSize = sampleSizeOverride;\r\n                } else {\r\n                    String sampleSize = Display.getInstance().getProperty(\"android.sampleSize\", null);\r\n                    if(sampleSize != null) {\r\n                        o2.inSampleSize = Integer.parseInt(sampleSize);\r\n                    } else {\r\n                        o2.inSampleSize = scale;\r\n                    }\r\n                }\r\n                o2.inPurgeable = true;\r\n                o2.inInputShareable = true;\r\n                fis = createFileInputStream(path);\r\n                b = BitmapFactory.decodeStream(fis, null, o2);\r\n                fis.close();\r\n\r\n                //fix rotation\r\n                ExifInterface exif = new ExifInterface(removeFilePrefix(path));\r\n                int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n\r\n                int angle = 0;\r\n                switch (orientation) {\r\n                    case ExifInterface.ORIENTATION_ROTATE_90:\r\n                        angle = 90;\r\n                        break;\r\n                    case ExifInterface.ORIENTATION_ROTATE_180:\r\n                        angle = 180;\r\n                        break;\r\n                    case ExifInterface.ORIENTATION_ROTATE_270:\r\n                        angle = 270;\r\n                        break;\r\n                }\r\n\r\n                if (sampleSizeOverride < 0 && angle != 0) {\r\n                    Matrix mat = new Matrix();\r\n                    mat.postRotate(angle);\r\n                    Bitmap correctBmp = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), mat, true);\r\n                    b.recycle();\r\n                    b = correctBmp;\r\n                }\r\n            } catch (IOException e) {\r\n            }\r\n            return b;\r\n        } else {\r\n            InputStream in = this.getResourceAsStream(getClass(), path);\r\n            if (in == null) {\r\n                throw new IOException(\"Resource not found. \" + path);\r\n            }\r\n            try {\r\n                return this.createImage(in);\r\n            } finally {\r\n                if (in != null) {\r\n                    try {\r\n                        in.close();\r\n                    } catch (Exception ignored) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean areMutableImagesFast() {\r\n        if (myView == null) return false;\r\n        return !myView.alwaysRepaintAll();\r\n    }\r\n\r\n    @Override\r\n    public void repaint(Animation cmp) {\r\n        if(myView != null && myView.alwaysRepaintAll()) {\r\n            if(cmp instanceof Component) {\r\n                Component c = (Component)cmp;\r\n                c.setDirtyRegion(null);\r\n                if(c.getParent() != null) {\r\n                    cmp = c.getComponentForm();\r\n                } else {\r\n                    Form f = getCurrentForm();\r\n                    if(f != null) {\r\n                        cmp = f;\r\n                    }\r\n                }\r\n            } else {\r\n                // make sure the form is repainted for standalone anims e.g. in the case\r\n                // of replace animation\r\n                Form f = getCurrentForm();\r\n                if(f != null) {\r\n                    super.repaint(f);\r\n                }\r\n            }\r\n        }\r\n        super.repaint(cmp);\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(InputStream i) throws IOException {\r\n        BitmapFactory.Options opts = new BitmapFactory.Options();\r\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n        return BitmapFactory.decodeStream(i, null, opts);\r\n    }\r\n\r\n    @Override\r\n    public void releaseImage(Object image) {\r\n        Bitmap i = (Bitmap) image;\r\n        i.recycle();\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(byte[] bytes, int offset, int len) {\r\n        BitmapFactory.Options opts = new BitmapFactory.Options();\r\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n        try {\r\n            BitmapFactory.Options.class.getField(\"inPurgeable\").set(opts, true);\r\n        } catch (Exception e) {\r\n            // inPurgeable not supported\r\n            // http://www.droidnova.com/2d-sprite-animation-in-android-addendum,505.html\r\n        }\r\n        return BitmapFactory.decodeByteArray(bytes, offset, len, opts);\r\n    }\r\n\r\n    @Override\r\n    public Object createImage(int[] rgb, int width, int height) {\r\n        return Bitmap.createBitmap(rgb, width, height, Bitmap.Config.ARGB_8888);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAlphaMutableImageSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object scale(Object nativeImage, int width, int height) {\r\n        return Bitmap.createScaledBitmap((Bitmap) nativeImage, width, height,\r\n                false);\r\n    }\r\n\r\n    //    @Override\r\n//    public Object rotate(Object image, int degrees) {\r\n//        Matrix matrix = new Matrix();\r\n//        matrix.postRotate(degrees);\r\n//        return Bitmap.createBitmap((Bitmap) image, 0, 0, ((Bitmap) image).getWidth(), ((Bitmap) image).getHeight(), matrix, true);\r\n//    }\r\n    @Override\r\n    public boolean isRotationDrawingSupported() {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    protected boolean cacheLinearGradients() {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeInputSupported() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the underlying OS supports opening the native navigation\r\n     * application\r\n     * @return true if the underlying OS supports launch of native navigation app\r\n     */\r\n    public boolean isOpenNativeNavigationAppSupported(){\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Opens the native navigation app in the given coordinate.\r\n     * @param latitude\r\n     * @param longitude\r\n     */\r\n    public void openNativeNavigationApp(double latitude, double longitude){\r\n        execute(\"google.navigation:ll=\" + latitude+ \",\" + longitude);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void openNativeNavigationApp(String location) {\r\n        execute(\"google.navigation:q=\" + Util.encodeUrl(location));\r\n    }\r\n\r\n    @Override\r\n    public Object createMutableImage(int width, int height, int fillColor) {\r\n        Bitmap bitmap = Bitmap.createBitmap(width, height,\r\n                Bitmap.Config.ARGB_8888);\r\n        AndroidGraphics graphics = (AndroidGraphics) this.getNativeGraphics(bitmap);\r\n        graphics.fillBitmap(fillColor);\r\n        return bitmap;\r\n    }\r\n\r\n    @Override\r\n    public int getImageHeight(Object i) {\r\n        return ((Bitmap) i).getHeight();\r\n    }\r\n\r\n    @Override\r\n    public int getImageWidth(Object i) {\r\n        return ((Bitmap) i).getWidth();\r\n    }\r\n\r\n    @Override\r\n    public void drawImage(Object graphics, Object img, int x, int y) {\r\n        ((AndroidGraphics) graphics).drawImage(img, x, y);\r\n    }\r\n\r\n    @Override\r\n    public void tileImage(Object graphics, Object img, int x, int y, int w, int h) {\r\n        ((AndroidGraphics) graphics).tileImage(img, x, y, w, h);\r\n    }\r\n\r\n    public boolean isScaledImageDrawingSupported() {\r\n        return true;\r\n    }\r\n\r\n    public void drawImage(Object graphics, Object img, int x, int y, int w, int h) {\r\n        ((AndroidGraphics) graphics).drawImage(img, x, y, w, h);\r\n    }\r\n\r\n    @Override\r\n    public void drawLine(Object graphics, int x1, int y1, int x2, int y2) {\r\n        ((AndroidGraphics) graphics).drawLine(x1, y1, x2, y2);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAntiAliasingSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setAntiAliased(Object graphics, boolean a) {\r\n        ((AndroidGraphics) graphics).getPaint().setAntiAlias(a);\r\n    }\r\n\r\n    @Override\r\n    public void drawPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {\r\n        ((AndroidGraphics) graphics).drawPolygon(xPoints, yPoints, nPoints);\r\n    }\r\n\r\n    @Override\r\n    public void fillPolygon(Object graphics, int[] xPoints, int[] yPoints, int nPoints) {\r\n        ((AndroidGraphics) graphics).fillPolygon(xPoints, yPoints, nPoints);\r\n    }\r\n\r\n    @Override\r\n    public void drawRGB(Object graphics, int[] rgbData, int offset, int x,\r\n                        int y, int w, int h, boolean processAlpha) {\r\n        ((AndroidGraphics) graphics).drawRGB(rgbData, offset, x, y, w, h, processAlpha);\r\n    }\r\n\r\n    @Override\r\n    public void drawRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).drawRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void drawRoundRect(Object graphics, int x, int y, int width,\r\n                              int height, int arcWidth, int arcHeight) {\r\n        ((AndroidGraphics) graphics).drawRoundRect(x, y, width, height, arcWidth, arcHeight);\r\n    }\r\n\r\n    @Override\r\n    public void drawString(Object graphics, String str, int x, int y) {\r\n        ((AndroidGraphics) graphics).drawString(str, x, y);\r\n    }\r\n\r\n    @Override\r\n    public void drawArc(Object graphics, int x, int y, int width, int height,\r\n                        int startAngle, int arcAngle) {\r\n        ((AndroidGraphics) graphics).drawArc(x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void fillArc(Object graphics, int x, int y, int width, int height,\r\n                        int startAngle, int arcAngle) {\r\n        ((AndroidGraphics) graphics).fillArc(x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void fillRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).fillRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void fillRect(Object graphics, int x, int y, int w, int h, byte alpha) {\r\n        ((AndroidGraphics) graphics).fillRect(x, y, w, h, alpha);\r\n    }\r\n\r\n    @Override\r\n    public void paintComponentBackground(Object graphics, int x, int y, int width, int height, Style s) {\r\n        if((!asyncView) || compatPaintMode ) {\r\n            super.paintComponentBackground(graphics, x, y, width, height, s);\r\n            return;\r\n        }\r\n        ((AndroidGraphics) graphics).paintComponentBackground(x, y, width, height, s);\r\n    }\r\n\r\n    @Override\r\n    public void fillLinearGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, boolean horizontal) {\r\n        if(!asyncView) {\r\n            super.fillLinearGradient(graphics, startColor, endColor, x, y, width, height, horizontal);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)graphics).fillLinearGradient(startColor, endColor, x, y, width, height, horizontal);\r\n    }\r\n\r\n    @Override\r\n    public void fillRectRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, float relativeX, float relativeY, float relativeSize) {\r\n        if(!asyncView) {\r\n            super.fillRectRadialGradient(graphics, startColor, endColor, x, y, width, height, relativeX, relativeY, relativeSize);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)graphics).fillRectRadialGradient(startColor, endColor, x, y, width, height, relativeX, relativeY, relativeSize);\r\n    }\r\n\r\n    @Override\r\n    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height) {\r\n        ((AndroidGraphics)graphics).fillRadialGradient(startColor, endColor, x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public void fillRadialGradient(Object graphics, int startColor, int endColor, int x, int y, int width, int height, int startAngle, int arcAngle) {\r\n        ((AndroidGraphics)graphics).fillRadialGradient(startColor, endColor, x, y, width, height, startAngle, arcAngle);\r\n    }\r\n\r\n    @Override\r\n    public void drawLabelComponent(Object nativeGraphics, int cmpX, int cmpY, int cmpHeight, int cmpWidth, Style style, String text, Object icon, Object stateIcon, int preserveSpaceForState, int gap, boolean rtl, boolean isOppositeSide, int textPosition, int stringWidth, boolean isTickerRunning, int tickerShiftText, boolean endsWith3Points, int valign) {\r\n        if(AndroidAsyncView.legacyPaintLogic) {\r\n            super.drawLabelComponent(nativeGraphics, cmpX, cmpY, cmpHeight, cmpWidth, style, text, icon, stateIcon, preserveSpaceForState, gap, rtl, isOppositeSide, textPosition, stringWidth, isTickerRunning, tickerShiftText, endsWith3Points, valign);\r\n            return;\r\n        }\r\n        ((AndroidGraphics)nativeGraphics).drawLabelComponent(cmpX, cmpY, cmpHeight, cmpWidth, style, text,\r\n                (Bitmap)icon, (Bitmap)stateIcon, preserveSpaceForState, gap, rtl, isOppositeSide, textPosition, stringWidth,\r\n                isTickerRunning, tickerShiftText, endsWith3Points, valign);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void fillRoundRect(Object graphics, int x, int y, int width,\r\n                              int height, int arcWidth, int arcHeight) {\r\n        ((AndroidGraphics) graphics).fillRoundRect(x, y, width, height, arcWidth, arcHeight);\r\n    }\r\n\r\n    @Override\r\n    public int getAlpha(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getAlpha();\r\n    }\r\n\r\n    @Override\r\n    public void setAlpha(Object graphics, int alpha) {\r\n        ((AndroidGraphics) graphics).setAlpha(alpha);\r\n    }\r\n\r\n    @Override\r\n    public boolean isAlphaGlobal() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setColor(Object graphics, int RGB) {\r\n        ((AndroidGraphics) graphics).setColor((getColor(graphics) & 0xff000000) | RGB);\r\n    }\r\n\r\n    @Override\r\n    public int getBackKeyCode() {\r\n        return DROID_IMPL_KEY_BACK;\r\n    }\r\n\r\n    @Override\r\n    public int getBackspaceKeyCode() {\r\n        return DROID_IMPL_KEY_BACKSPACE;\r\n    }\r\n\r\n    @Override\r\n    public int getClearKeyCode() {\r\n        return DROID_IMPL_KEY_CLEAR;\r\n    }\r\n\r\n    @Override\r\n    public int getClipHeight(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipHeight();\r\n    }\r\n\r\n    @Override\r\n    public int getClipWidth(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipWidth();\r\n    }\r\n\r\n    @Override\r\n    public int getClipX(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipX();\r\n    }\r\n\r\n    @Override\r\n    public int getClipY(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getClipY();\r\n    }\r\n\r\n    @Override\r\n    public void setClip(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).setClip(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public boolean isShapeClipSupported(Object graphics){\r\n        return Build.VERSION.SDK_INT > Build.VERSION_CODES.HONEYCOMB;\r\n    }\r\n\r\n    @Override\r\n    public void setClip(Object graphics, Shape shape) {\r\n        //Path p = cn1ShapeToAndroidPath(shape);\r\n        ((AndroidGraphics) graphics).setClip(shape);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void clipRect(Object graphics, int x, int y, int width, int height) {\r\n        ((AndroidGraphics) graphics).clipRect(x, y, width, height);\r\n    }\r\n\r\n    @Override\r\n    public int getColor(Object graphics) {\r\n        return ((AndroidGraphics) graphics).getColor();\r\n    }\r\n\r\n    @Override\r\n    public int getDisplayHeight() {\r\n        if (this.myView != null) {\r\n            int h = this.myView.getViewHeight();\r\n            displayHeight = h;\r\n            return h;\r\n        }\r\n        return displayHeight;\r\n    }\r\n\r\n    @Override\r\n    public int getDisplayWidth() {\r\n        if (this.myView != null) {\r\n            int w = this.myView.getViewWidth();\r\n            displayWidth = w;\r\n            return w;\r\n        }\r\n        return displayWidth;\r\n    }\r\n\r\n    @Override\r\n    public int getActualDisplayHeight() {\r\n        DisplayMetrics dm = getContext().getResources().getDisplayMetrics();\r\n        return dm.heightPixels;\r\n    }\r\n\r\n    @Override\r\n    public int getGameAction(int keyCode) {\r\n        switch (keyCode) {\r\n            case DROID_IMPL_KEY_DOWN:\r\n                return Display.GAME_DOWN;\r\n            case DROID_IMPL_KEY_UP:\r\n                return Display.GAME_UP;\r\n            case DROID_IMPL_KEY_LEFT:\r\n                return Display.GAME_LEFT;\r\n            case DROID_IMPL_KEY_RIGHT:\r\n                return Display.GAME_RIGHT;\r\n            case DROID_IMPL_KEY_FIRE:\r\n                return Display.GAME_FIRE;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getKeyCode(int gameAction) {\r\n        switch (gameAction) {\r\n            case Display.GAME_DOWN:\r\n                return DROID_IMPL_KEY_DOWN;\r\n            case Display.GAME_UP:\r\n                return DROID_IMPL_KEY_UP;\r\n            case Display.GAME_LEFT:\r\n                return DROID_IMPL_KEY_LEFT;\r\n            case Display.GAME_RIGHT:\r\n                return DROID_IMPL_KEY_RIGHT;\r\n            case Display.GAME_FIRE:\r\n                return DROID_IMPL_KEY_FIRE;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int[] getSoftkeyCode(int index) {\r\n        if (index == 0) {\r\n            return leftSK;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public int getSoftkeyCount() {\r\n        /**\r\n         * one menu button only. we may have to stuff some code here as soon as\r\n         * there are devices that no longer have only a single menu button.\r\n         */\r\n        return 1;\r\n    }\r\n\r\n    @Override\r\n    public void vibrate(int duration) {\r\n        if (!this.vibrateInitialized) {\r\n            try {\r\n                v = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);\r\n            } catch (Throwable e) {\r\n                Log.e(\"Codename One\", \"problem with virbrator(0)\", e);\r\n            } finally {\r\n                this.vibrateInitialized = true;\r\n            }\r\n        }\r\n        if (v != null) {\r\n            try {\r\n                v.vibrate(duration);\r\n            } catch (Throwable e) {\r\n                Log.e(\"Codename One\", \"problem with virbrator(1)\", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isTouchDevice() {\r\n        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN);\r\n    }\r\n\r\n    @Override\r\n    public boolean hasPendingPaints() {\r\n        //if the view is not visible make sure the edt won't wait.\r\n        if (myView != null && myView.getAndroidView().getVisibility() != View.VISIBLE) {\r\n            return true;\r\n        } else {\r\n            return super.hasPendingPaints();\r\n        }\r\n    }\r\n\r\n    public void revalidate() {\r\n        if (myView != null) {\r\n            myView.getAndroidView().setVisibility(View.VISIBLE);\r\n            getCurrentForm().revalidate();\r\n            flushGraphics();\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public int getKeyboardType() {\r\n        if (Display.getInstance().getDefaultVirtualKeyboard().isVirtualKeyboardShowing()) {\r\n            return Display.KEYBOARD_TYPE_VIRTUAL;\r\n        }\r\n        /**\r\n         * can we detect this? but even if we could i think it is best to have\r\n         * this fixed to qwerty. we pass unicode values to Codename One in any\r\n         * case. check AndroidView.onKeyUpDown() method. and read comment below.\r\n         */\r\n        return Display.KEYBOARD_TYPE_QWERTY;\r\n        /**\r\n         * some info from the MIDP docs about keycodes:\r\n         *\r\n         * \"Applications receive keystroke events in which the individual keys\r\n         * are named within a space of key codes. Every key for which events are\r\n         * reported to MIDP applications is assigned a key code. The key code\r\n         * values are unique for each hardware key unless two keys are obvious\r\n         * synonyms for each other. MIDP defines the following key codes:\r\n         * KEY_NUM0, KEY_NUM1, KEY_NUM2, KEY_NUM3, KEY_NUM4, KEY_NUM5, KEY_NUM6,\r\n         * KEY_NUM7, KEY_NUM8, KEY_NUM9, KEY_STAR, and KEY_POUND. (These key\r\n         * codes correspond to keys on a ITU-T standard telephone keypad.) Other\r\n         * keys may be present on the keyboard, and they will generally have key\r\n         * codes distinct from those list above. In order to guarantee\r\n         * portability, applications should use only the standard key codes.\r\n         *\r\n         * The standard key codes values are equal to the Unicode encoding for\r\n         * the character that represents the key. If the device includes any\r\n         * other keys that have an obvious correspondence to a Unicode\r\n         * character, their key code values should equal the Unicode encoding\r\n         * for that character. For keys that have no corresponding Unicode\r\n         * character, the implementation must use negative values. Zero is\r\n         * defined to be an invalid key code.\"\r\n         *\r\n         * Because the MIDP implementation is our reference and that\r\n         * implementation does not interpret the given keycodes we behave alike\r\n         * and pass on the unicode values.\r\n         */\r\n    }\r\n\r\n    /**\r\n     * Exits the application...\r\n     */\r\n    public void exitApplication() {\r\n        android.os.Process.killProcess(android.os.Process.myPid());\r\n    }\r\n\r\n    @Override\r\n    public void notifyCommandBehavior(int commandBehavior) {\r\n        if (commandBehavior == Display.COMMAND_BEHAVIOR_NATIVE) {\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).enableNativeMenu(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class NotifyActionBar implements Runnable {\r\n        private Activity activity;\r\n        private boolean show;\r\n\r\n        public NotifyActionBar(Activity activity, int commandBehavior) {\r\n            this.activity = activity;\r\n            show = commandBehavior == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }\r\n\r\n        public NotifyActionBar(Activity activity, boolean show) {\r\n            this.activity = activity;\r\n            this.show = show;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            activity.invalidateOptionsMenu();\r\n            if (show) {\r\n                activity.getActionBar().show();\r\n            } else {\r\n                activity.getActionBar().hide();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String getAppArg() {\r\n        if (super.getAppArg() != null) {\r\n            // This just maintains backward compatibility in case people are manually\r\n            // setting the AppArg in their properties.  It reproduces the general\r\n            // behaviour the existed when AppArg was just another Display property.\r\n            return super.getAppArg();\r\n        }\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n\r\n        android.content.Intent intent = getActivity().getIntent();\r\n        if (intent != null) {\r\n            String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\r\n            intent.removeExtra(Intent.EXTRA_TEXT);\r\n            Uri u = intent.getData();\r\n            String scheme = intent.getScheme();\r\n            if (u == null && intent.getExtras() != null) {\r\n                if (intent.getExtras().keySet().contains(\"android.intent.extra.STREAM\")) {\r\n                    try {\r\n                        u = (Uri)intent.getParcelableExtra(\"android.intent.extra.STREAM\");\r\n                        scheme = u.getScheme();\r\n                        System.out.println(\"u=\"+u);\r\n                    } catch (Exception ex) {\r\n                        Log.d(\"Codename One\", \"Failed to load parcelable extra from intent: \"+ex.getMessage());\r\n                    }\r\n                }\r\n\r\n            }\r\n            if (u != null) {\r\n                //String scheme = intent.getScheme();\r\n                intent.setData(null);\r\n                if (\"content\".equals(scheme)) {\r\n                    try {\r\n                        InputStream attachment = getActivity().getContentResolver().openInputStream(u);\r\n                        if (attachment != null) {\r\n                            String name = getContentName(getActivity().getContentResolver(), u);\r\n                            if (name != null) {\r\n                                String filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                if(filePath.startsWith(\"file:\")) {\r\n                                    filePath = filePath.substring(5);\r\n                                }\r\n                                File f = new File(filePath);\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = attachment.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                attachment.close();\r\n                                setAppArg(addFile(filePath));\r\n                                return addFile(filePath);\r\n                            }\r\n                        }\r\n                    } catch (FileNotFoundException e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                        return null;\r\n                    }\r\n                } else {\r\n\r\n                    /*\r\n                    // Why do we need this special case?  u.toString()\r\n                    // will include the full URL including query string.\r\n                    // This special case causes urls like myscheme://part1/part2\r\n                    // to only return \"/part2\" which is obviously problematic and\r\n                    // is inconsistent with iOS.  Is this special case necessary\r\n                    // in some versions of Android?\r\n                    String encodedPath = u.getEncodedPath();\r\n                    if (encodedPath != null && encodedPath.length() > 0) {\r\n                        String query = u.getQuery();\r\n                        if(query != null && query.length() > 0){\r\n                            encodedPath += \"?\" + query;\r\n                        }\r\n                        setAppArg(encodedPath);\r\n                        return encodedPath;\r\n                    }\r\n                    */\r\n                    if (sharedText != null) {\r\n                        setAppArg(sharedText);\r\n                        return sharedText;\r\n                    } else {\r\n                        setAppArg(u.toString());\r\n                        return u.toString();\r\n                    }\r\n\r\n                }\r\n            } else if (sharedText != null) {\r\n                setAppArg(sharedText);\r\n                return sharedText;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getProperty(String key, String defaultValue) {\r\n        if(key.equalsIgnoreCase(\"cn1_push_prefix\")) {\r\n            /*if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get notifications\")){\r\n                return \"\";\r\n            }*/\r\n            boolean has = hasAndroidMarket();\r\n            if(has) {\r\n                return \"gcm\";\r\n            }\r\n            return defaultValue;\r\n        }\r\n        if (\"OS\".equals(key)) {\r\n            return \"Android\";\r\n        }\r\n        if (\"androidId\".equals(key)) {\r\n            return Settings.Secure.getString(getContext().getContentResolver(), Settings.Secure.ANDROID_ID);\r\n        }\r\n\r\n        /*if (\"cellId\".equals(key)) {\r\n            try {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the cellId\")){\r\n                    return defaultValue;\r\n                }\r\n                String serviceName = Context.TELEPHONY_SERVICE;\r\n                TelephonyManager telephonyManager = (TelephonyManager) getContext().getSystemService(serviceName);\r\n                int cellId = ((GsmCellLocation) telephonyManager.getCellLocation()).getCid();\r\n                return \"\" + cellId;\r\n            } catch (Throwable t) {\r\n                return defaultValue;\r\n            }\r\n        }*/\r\n        if (\"AppName\".equals(key)) {\r\n\r\n            final PackageManager pm = getContext().getPackageManager();\r\n            ApplicationInfo ai;\r\n            try {\r\n                ai = pm.getApplicationInfo(getContext().getPackageName(), 0);\r\n            } catch (NameNotFoundException e) {\r\n                ai = null;\r\n            }\r\n            String applicationName = (String) (ai != null ? pm.getApplicationLabel(ai) : null);\r\n            if(applicationName == null){\r\n                return defaultValue;\r\n            }\r\n            return applicationName;\r\n        }\r\n        if (\"AppVersion\".equals(key)) {\r\n            try {\r\n                PackageInfo i = getContext().getPackageManager().getPackageInfo(getContext().getApplicationInfo().packageName, 0);\r\n                return i.versionName;\r\n            } catch (NameNotFoundException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            return defaultValue;\r\n        }\r\n        if (\"Platform\".equals(key)) {\r\n            String p = System.getProperty(\"platform\");\r\n            if(p == null) {\r\n                return defaultValue;\r\n            }\r\n            return p;\r\n        }\r\n        if (\"User-Agent\".equals(key)) {\r\n            String ua = getUserAgent();\r\n            if(ua == null) {\r\n                return defaultValue;\r\n            }\r\n            return ua;\r\n        }\r\n        if(\"OSVer\".equals(key)) {\r\n            return \"\" + android.os.Build.VERSION.RELEASE;\r\n        }\r\n        if(\"DeviceName\".equals(key)) {\r\n            return \"\" + android.os.Build.MODEL;\r\n        }\r\n        /*try {\r\n            if (\"IMEI\".equals(key) || \"UDID\".equals(key)) {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the device ID\")){\r\n                    return \"\";\r\n                }\r\n                TelephonyManager tm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\r\n                String imei = null;\r\n                if (tm!=null && tm.getDeviceId() != null) {\r\n                    // for phones or 3g tablets\r\n                    imei = tm.getDeviceId();\r\n                } else {\r\n                    try {\r\n                        imei = Secure.getString(getContext().getContentResolver(), Secure.ANDROID_ID);\r\n                    } catch(Throwable t) {\r\n                        com.codename1.io.Log.e(t);\r\n                    }\r\n                }\r\n                return imei;\r\n            }\r\n            if (\"MSISDN\".equals(key)) {\r\n                if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to get the device ID\")){\r\n                    return \"\";\r\n                }\r\n                TelephonyManager tm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\r\n                return tm.getLine1Number();\r\n            }\r\n        } catch(Throwable t) {\r\n            // will be caused by no permissions.\r\n            return defaultValue;\r\n        }*/\r\n\r\n        if (getActivity() != null) {\r\n            android.content.Intent intent = getActivity().getIntent();\r\n            if(intent != null){\r\n                Bundle extras = intent.getExtras();\r\n                if (extras != null) {\r\n                    String value = extras.getString(key);\r\n                    if(value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!key.startsWith(\"android.permission\")) {\r\n            //these keys/values are from the Application Resources (strings values)\r\n            try {\r\n                int id = getContext().getResources().getIdentifier(key, \"string\", getContext().getApplicationInfo().packageName);\r\n                if (id != 0) {\r\n                    String val = getContext().getResources().getString(id);\r\n                    return val;\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        return System.getProperty(key, super.getProperty(key, defaultValue));\r\n    }\r\n\r\n    private String getContentName(ContentResolver resolver, Uri uri) {\r\n        Cursor cursor = resolver.query(uri, null, null, null, null);\r\n        cursor.moveToFirst();\r\n        int nameIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DISPLAY_NAME);\r\n        if (nameIndex >= 0) {\r\n            String name = cursor.getString(nameIndex);\r\n            cursor.close();\r\n            return name;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private String getUserAgent() {\r\n        try {\r\n            String userAgent = System.getProperty(\"http.agent\");\r\n            if(userAgent != null){\r\n                return userAgent;\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n        if (getActivity() == null) {\r\n            return \"Android-CN1\";\r\n        }\r\n        try {\r\n            Constructor<WebSettings> constructor = WebSettings.class.getDeclaredConstructor(Context.class, WebView.class);\r\n            constructor.setAccessible(true);\r\n            try {\r\n                WebSettings settings = constructor.newInstance(getActivity(), null);\r\n                return settings.getUserAgentString();\r\n            } finally {\r\n                constructor.setAccessible(false);\r\n            }\r\n        } catch (Exception e) {\r\n            final StringBuffer ua = new StringBuffer();\r\n            if (Thread.currentThread().getName().equalsIgnoreCase(\"main\")) {\r\n                WebView m_webview = new WebView(getActivity());\r\n                ua.append(m_webview.getSettings().getUserAgentString());\r\n                m_webview.destroy();\r\n            } else {\r\n                final boolean[] flag = new boolean[1];\r\n                Thread thread = new Thread() {\r\n                    public void run() {\r\n                        Looper.prepare();\r\n                        WebView m_webview = new WebView(getActivity());\r\n                        ua.append(m_webview.getSettings().getUserAgentString());\r\n                        m_webview.destroy();\r\n                        Looper.loop();\r\n                        flag[0] = true;\r\n                        synchronized (flag) {\r\n                            flag.notify();\r\n                        }\r\n                    }\r\n                };\r\n                thread.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n                thread.start();\r\n                while (!flag[0]) {\r\n                    synchronized (flag) {\r\n                        try {\r\n                            flag.wait(100);\r\n                        } catch (InterruptedException ex) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ua.toString();\r\n        }\r\n    }\r\n\r\n    private String getMimeType(String url){\r\n        String type = null;\r\n        String extension = MimeTypeMap.getFileExtensionFromUrl(url);\r\n        if (extension != null) {\r\n            MimeTypeMap mime = MimeTypeMap.getSingleton();\r\n\r\n            type = mime.getMimeTypeFromExtension(extension);\r\n        }\r\n        if (type == null) {\r\n            try {\r\n                Uri uri = Uri.parse(url);\r\n                ContentResolver cr = getContext().getContentResolver();\r\n                type = cr.getType(uri);\r\n            } catch (Throwable t) {\r\n                t.printStackTrace();\r\n            }\r\n        }\r\n        return type;\r\n    }\r\n\r\n    public static void copy(File src, File dst) throws IOException {\r\n        InputStream in = new FileInputStream(src);\r\n        try {\r\n            OutputStream out = new FileOutputStream(dst);\r\n            try {\r\n                // Transfer bytes from in to out\r\n                byte[] buf = new byte[8096];\r\n                int len;\r\n                while ((len = in.read(buf)) > 0) {\r\n                    out.write(buf, 0, len);\r\n                }\r\n            } finally {\r\n                out.close();\r\n            }\r\n        } finally {\r\n            in.close();\r\n        }\r\n    }\r\n\r\n    private static File makeTempCacheCopy(File file) throws IOException {\r\n        File cacheDir = new File(getContext().getCacheDir(), \"intent_files\");\r\n\r\n        // Create the storage directory if it does not exist\r\n        if (!cacheDir.exists()) {\r\n            if (!cacheDir.mkdirs()) {\r\n                Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        File copy = new File(cacheDir, \"tmp-\"+System.currentTimeMillis()+file.getName());\r\n        copy(file, copy);\r\n        return copy;\r\n\r\n    }\r\n\r\n\r\n\r\n    private Intent createIntentForURL(String url) {\r\n        Intent intent;\r\n        Uri uri;\r\n        try {\r\n            if (url.startsWith(\"intent\")) {\r\n                intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);\r\n            } else {\r\n                if(url.startsWith(\"/\") || url.startsWith(\"file:\")) {\r\n                    if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to open the file\")){\r\n                        return null;\r\n                    }\r\n                }\r\n                intent = new Intent();\r\n                intent.setAction(Intent.ACTION_VIEW);\r\n                if (url.startsWith(\"/\")) {\r\n                    File f = new File(url);\r\n                    Uri furi = null;\r\n                    try {\r\n                        furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                    } catch (Exception ex) {\r\n                        f = makeTempCacheCopy(f);\r\n                        furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                    }\r\n        \r\n        \r\n                    if (Build.VERSION.SDK_INT < 21) {\r\n                        List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n                        for (ResolveInfo resolveInfo : resInfoList) {\r\n                            String packageName = resolveInfo.activityInfo.packageName;\r\n                            getContext().grantUriPermission(packageName, furi, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                        }\r\n                    }\r\n                    \r\n                    uri = furi;\r\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                }else{\r\n\r\n                    if (url.startsWith(\"file:\")) {\r\n                        File f = new File(removeFilePrefix(url));\r\n                        System.out.println(\"File size: \"+f.length());\r\n\r\n                        Uri furi = null;\r\n                        try {\r\n                            furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                        } catch (Exception ex) {\r\n                            f = makeTempCacheCopy(f);\r\n                            furi = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", f);\r\n                        }\r\n\r\n\r\n                        if (Build.VERSION.SDK_INT < 21) {\r\n                            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n                            for (ResolveInfo resolveInfo : resInfoList) {\r\n                                String packageName = resolveInfo.activityInfo.packageName;\r\n                                getContext().grantUriPermission(packageName, furi, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n                            }\r\n                        }\r\n                        uri = furi;\r\n                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n\r\n\r\n                    } else {\r\n                        uri = Uri.parse(url);\r\n                    }\r\n                }\r\n                String mimeType = getMimeType(url);\r\n                if(mimeType != null){\r\n                    intent.setDataAndType(uri, mimeType);\r\n                }else{\r\n                    intent.setData(uri);\r\n                }\r\n            }\r\n\r\n            return intent;\r\n        } catch(Exception err) {\r\n            com.codename1.io.Log.e(err);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Boolean canExecute(String url) {\r\n        try {\r\n            Intent it = createIntentForURL(url);\r\n            if(it == null) {\r\n                return false;\r\n            }\r\n            final PackageManager mgr = getContext().getPackageManager();\r\n            List<ResolveInfo> list = mgr.queryIntentActivities(it, PackageManager.MATCH_DEFAULT_ONLY);\r\n            return list.size() > 0;\r\n        } catch(Exception err) {\r\n            com.codename1.io.Log.e(err);\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    public void execute(String url, ActionListener response) {\r\n        if (response != null) {\r\n            callback = new EventDispatcher();\r\n            callback.addListener(response);\r\n        }\r\n\r\n        try {\r\n            Intent intent = createIntentForURL(url);\r\n            if(intent == null) {\r\n                return;\r\n            }\r\n            if(response != null && getActivity() != null){\r\n                getActivity().startActivityForResult(intent, IntentResultListener.URI_SCHEME);\r\n            }else {\r\n                getContext().startActivity(intent);\r\n            }\r\n            return;\r\n        } catch (Exception ex) {\r\n            com.codename1.io.Log.e(ex);\r\n        }\r\n\r\n        try {\r\n            if(editInProgress()) {\r\n                stopEditing(true);\r\n            }\r\n            getContext().startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public void execute(String url) {\r\n        execute(url, null);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void playBuiltinSound(String soundIdentifier) {\r\n        if (getActivity() != null && Display.SOUND_TYPE_BUTTON_PRESS == soundIdentifier) {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    if (myView != null) {\r\n                        myView.getAndroidView().playSoundEffect(AudioManager.FX_KEY_CLICK);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    protected void playNativeBuiltinSound(Object data) {\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isBuiltinSoundAvailable(String soundIdentifier) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public boolean isNativeVideoPlayerControlsIncluded() {\r\n        return true;\r\n    }\r\n    \r\n    private static final int STATE_PAUSED = 0;\r\n    private static final int STATE_PLAYING = 1;\r\n\r\n    private int mCurrentState;\r\n\r\n    private MediaBrowserCompat mMediaBrowserCompat;\r\n    private android.support.v4.media.session.MediaControllerCompat mMediaControllerCompat;\r\n    \r\n    private android.support.v4.media.session.MediaControllerCompat.Callback mMediaControllerCompatCallback = new android.support.v4.media.session.MediaControllerCompat.Callback() {\r\n\r\n        @Override\r\n        public void onPlaybackStateChanged(PlaybackStateCompat state) {\r\n            super.onPlaybackStateChanged(state);\r\n            if( state == null ) {\r\n                return;\r\n            }\r\n\r\n            switch( state.getState() ) {\r\n                case PlaybackStateCompat.STATE_PLAYING: {\r\n                    mCurrentState = STATE_PLAYING;\r\n                    break;\r\n                }\r\n                case PlaybackStateCompat.STATE_PAUSED: {\r\n                    mCurrentState = STATE_PAUSED;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    private MediaBrowserCompat.ConnectionCallback mMediaBrowserCompatConnectionCallback = new MediaBrowserCompat.ConnectionCallback() {\r\n\r\n        @Override\r\n        public void onConnected() {\r\n            super.onConnected();\r\n            try {\r\n                mMediaControllerCompat = new MediaControllerCompat(getActivity(), mMediaBrowserCompat.getSessionToken());\r\n                mMediaControllerCompat.registerCallback(mMediaControllerCompatCallback);\r\n                MediaControllerCompat.setMediaController(getActivity(), mMediaControllerCompat);\r\n                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().play();\r\n\r\n            } catch( RemoteException e ) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    };\r\n\r\n    //BackgroundAudioService remoteControl;\r\n\r\n    @Override\r\n    public void startRemoteControl() {\r\n        super.startRemoteControl();\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                mMediaBrowserCompat = new MediaBrowserCompat(getActivity(), new ComponentName(getActivity(), BackgroundAudioService.class),\r\n                mMediaBrowserCompatConnectionCallback, getActivity().getIntent().getExtras());\r\n\r\n                mMediaBrowserCompat.connect();\r\n                AndroidNativeUtil.addLifecycleListener(new LifecycleListener() {\r\n                    @Override\r\n                    public void onCreate(Bundle savedInstanceState) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onResume() {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onPause() {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onDestroy() {\r\n                        if (mMediaBrowserCompat != null) {\r\n                            if( MediaControllerCompat.getMediaController(getActivity()).getPlaybackState().getState() == PlaybackStateCompat.STATE_PLAYING ) {\r\n                                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().pause();\r\n                            }\r\n\r\n                            mMediaBrowserCompat.disconnect();\r\n                            mMediaBrowserCompat = null;\r\n                        }\r\n                    }\r\n\r\n                    @Override\r\n                    public void onSaveInstanceState(Bundle b) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public void onLowMemory() {\r\n\r\n                    }\r\n                });\r\n            }\r\n            \r\n        });\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void stopRemoteControl() {\r\n        super.stopRemoteControl(); \r\n        if (mMediaBrowserCompat != null) {\r\n            if( MediaControllerCompat.getMediaController(getActivity()).getPlaybackState().getState() == PlaybackStateCompat.STATE_PLAYING ) {\r\n                MediaControllerCompat.getMediaController(getActivity()).getTransportControls().pause();\r\n            }\r\n\r\n            mMediaBrowserCompat.disconnect();\r\n            mMediaBrowserCompat = null;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public AsyncResource<Media> createBackgroundMediaAsync(final String uri) {\r\n        final AsyncResource<Media> out = new AsyncResource<Media>();\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    out.complete(createBackgroundMedia(uri));\r\n                } catch (IOException ex) {\r\n                    out.error(ex);\r\n                }\r\n            }\r\n        }).start();\r\n\r\n        return out;\r\n    }\r\n\r\n    private int nextMediaId;\r\n    private int backgroundMediaCount;\r\n    private ServiceConnection backgroundMediaServiceConnection;\r\n    @Override\r\n    public Media createBackgroundMedia(final String uri) throws IOException {\r\n        int mediaId = nextMediaId++;\r\n        backgroundMediaCount++;\r\n\r\n        Intent serviceIntent = new Intent(getContext(), AudioService.class);\r\n        serviceIntent.putExtra(\"mediaLink\", uri);\r\n        serviceIntent.putExtra(\"mediaId\", mediaId);\r\n        if (background == null) {\r\n            ServiceConnection mConnection = new ServiceConnection() {\r\n\r\n                public void onServiceDisconnected(ComponentName name) {\r\n\r\n                    background = null;\r\n                    backgroundMediaServiceConnection = null;\r\n                }\r\n\r\n                public void onServiceConnected(ComponentName name, IBinder service) {\r\n                    AudioService.LocalBinder mLocalBinder = (AudioService.LocalBinder) service;\r\n                    AudioService svc = (AudioService)mLocalBinder.getService();\r\n                    background = svc;\r\n                }\r\n            };\r\n            backgroundMediaServiceConnection = mConnection;\r\n            boolean boundSuccess = getContext().bindService(serviceIntent, mConnection, getContext().BIND_AUTO_CREATE);\r\n            if (!boundSuccess) {\r\n                throw new RuntimeException(\"Failed to bind background media service for uri \"+uri);\r\n            }\r\n            ContextCompat.startForegroundService(getContext(), serviceIntent);\r\n            while (background == null) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        Util.sleep(200);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            ContextCompat.startForegroundService(getContext(), serviceIntent);\r\n        }\r\n\r\n        while (background.getMedia(mediaId) == null) {\r\n            Display.getInstance().invokeAndBlock(new Runnable() {\r\n                public void run() {\r\n                    Util.sleep(200);\r\n                }\r\n\r\n            });\r\n        }\r\n        Media ret = new MediaProxy(background.getMedia(mediaId)) {\r\n\r\n            \r\n            @Override\r\n            public void cleanup() {\r\n                super.cleanup();\r\n                if (--backgroundMediaCount <= 0) {\r\n                    if (backgroundMediaServiceConnection != null) {\r\n                        try {\r\n                            getContext().unbindService(backgroundMediaServiceConnection);\r\n                        } catch (IllegalArgumentException ex) {\r\n                            // This is thrown sometimes if the service has already been unbound\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        \r\n        return ret;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public Media createMedia(final String uri, boolean isVideo, final Runnable onCompletion) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        if(!uri.startsWith(FileSystemStorage.getInstance().getAppHomePath())) {\r\n            if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to play media\")){\r\n                return null;\r\n            }\r\n        }\r\n        if (uri.startsWith(\"file://\")) {\r\n            return createMedia(removeFilePrefix(uri), isVideo, onCompletion);\r\n        }\r\n        File file = null;\r\n        if (uri.indexOf(':') < 0) {\r\n            // use a file object to play to try and workaround this issue:\r\n            // http://code.google.com/p/android/issues/detail?id=4124\r\n            file = new File(uri);\r\n        }\r\n\r\n        Media retVal;\r\n\r\n        if (isVideo) {\r\n            final AndroidImplementation.Video[] video = new AndroidImplementation.Video[1];\r\n            final boolean[] flag = new boolean[1];\r\n            final File f = file;\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    VideoView v = new VideoView(getActivity());\r\n                    v.setZOrderMediaOverlay(true);\r\n                    if (f != null) {\r\n                        v.setVideoURI(Uri.fromFile(f));\r\n                    } else {\r\n                        v.setVideoURI(Uri.parse(uri));\r\n                    }\r\n                    video[0] = new AndroidImplementation.Video(v, getActivity(), onCompletion);\r\n                    flag[0] = true;\r\n                    synchronized (flag) {\r\n                        flag.notify();\r\n                    }\r\n                }\r\n            });\r\n            while (!flag[0]) {\r\n                synchronized (flag) {\r\n                    try {\r\n                        flag.wait(100);\r\n                    } catch (InterruptedException ex) {\r\n                    }\r\n                }\r\n            }\r\n            return video[0];\r\n        } else {\r\n            MediaPlayer player;\r\n            if (file != null) {\r\n                FileInputStream is = new FileInputStream(file);\r\n                player = new MediaPlayer();\r\n                player.setDataSource(is.getFD());\r\n                player.prepare();\r\n            } else {\r\n                player = MediaPlayer.create(getActivity(), Uri.parse(uri));\r\n            }\r\n            retVal = new Audio(getActivity(), player, null, onCompletion);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    @Override\r\n    public void addCompletionHandler(Media media, Runnable onCompletion) {\r\n        super.addCompletionHandler(media, onCompletion);\r\n        if (media instanceof Video) {\r\n            ((Video)media).addCompletionHandler(onCompletion);\r\n        } else if (media instanceof Audio) {\r\n            ((Audio)media).addCompletionHandler(onCompletion);\r\n        } else if (media instanceof MediaProxy) {\r\n            ((MediaProxy)media).addCompletionHandler(onCompletion);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void removeCompletionHandler(Media media, Runnable onCompletion) {\r\n        super.removeCompletionHandler(media, onCompletion);\r\n        if (media instanceof Video) {\r\n            ((Video)media).removeCompletionHandler(onCompletion);\r\n        } else if (media instanceof Audio) {\r\n            ((Audio)media).removeCompletionHandler(onCompletion);\r\n        } else if (media instanceof MediaProxy) {\r\n            ((MediaProxy)media).removeCompletionHandler(onCompletion);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    @Override\r\n    public Media createMedia(InputStream stream, String mimeType, final Runnable onCompletion) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        /*if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to play media\")){\r\n            return null;\r\n        }*/\r\n        boolean isVideo = mimeType.contains(\"video\");\r\n\r\n        if (!isVideo && stream instanceof FileInputStream) {\r\n            MediaPlayer player = new MediaPlayer();\r\n            player.setDataSource(((FileInputStream) stream).getFD());\r\n            player.prepare();\r\n            return new Audio(getActivity(), player, stream, onCompletion);\r\n        }\r\n        String extension = MimeTypeMap.getFileExtensionFromUrl(mimeType);\r\n        final File temp = File.createTempFile(\"mtmp\", extension == null ? \"dat\" : extension);\r\n        temp.deleteOnExit();\r\n        OutputStream out = createFileOuputStream(temp);\r\n\r\n        byte buf[] = new byte[256];\r\n        int len = 0;\r\n        while ((len = stream.read(buf, 0, buf.length)) > -1) {\r\n            out.write(buf, 0, len);\r\n        }\r\n        out.close();\r\n        stream.close();\r\n\r\n        final Runnable finish = new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                if(onCompletion != null){\r\n                    Display.getInstance().callSerially(onCompletion);\r\n\r\n                    // makes sure the file is only deleted after the onCompletion was invoked\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            temp.delete();\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                temp.delete();\r\n            }\r\n        };\r\n\r\n        if (isVideo) {\r\n            final AndroidImplementation.Video[] retVal = new AndroidImplementation.Video[1];\r\n            final boolean[] flag = new boolean[1];\r\n\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    VideoView v = new VideoView(getActivity());\r\n                    v.setZOrderMediaOverlay(true);\r\n                    v.setVideoURI(Uri.fromFile(temp));\r\n                    retVal[0] = new AndroidImplementation.Video(v, getActivity(), finish);\r\n                    flag[0] = true;\r\n                    synchronized (flag) {\r\n                        flag.notify();\r\n                    }\r\n                }\r\n            });\r\n            while (!flag[0]) {\r\n                synchronized (flag) {\r\n                    try {\r\n                        flag.wait(100);\r\n                    } catch (InterruptedException ex) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            return retVal[0];\r\n        } else {\r\n            return createMedia(createFileInputStream(temp), mimeType, finish);\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {\r\n        return createMediaRecorder(builder.getPath(), builder.getMimeType(), builder.getSamplingRate(), builder.getBitRate(), builder.getAudioChannels(), 0, builder.isRedirectToAudioBuffer());\r\n    }\r\n\r\n    @Override\r\n    public Media createMediaRecorder(final String path, final String mimeType) throws IOException {\r\n        MediaRecorderBuilder builder = new MediaRecorderBuilder()\r\n                .path(path)\r\n                .mimeType(mimeType);\r\n        return createMediaRecorder(builder);\r\n    }\r\n    \r\n   \r\n    \r\n    private  Media createMediaRecorder(final String path, final String mimeType, final int sampleRate, final int bitRate, final int audioChannels, final int maxDuration, final boolean redirectToAudioBuffer) throws IOException {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        if(!checkForPermission(Manifest.permission.RECORD_AUDIO, \"This is required to record audio\")){\r\n            return null;\r\n        }\r\n        final Media[] record = new Media[1];\r\n        final IOException[] error = new IOException[1];\r\n\r\n        final Object lock = new Object();\r\n        synchronized (lock) {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    synchronized (lock) {\r\n                        if (redirectToAudioBuffer) {\r\n                            final int channelConfig =audioChannels == 1 ? android.media.AudioFormat.CHANNEL_IN_MONO\r\n                                            : audioChannels == 2 ? android.media.AudioFormat.CHANNEL_IN_STEREO\r\n                                                    : android.media.AudioFormat.CHANNEL_IN_MONO;\r\n                            final AudioRecord recorder = new AudioRecord(\r\n                                    MediaRecorder.AudioSource.MIC, \r\n                                    sampleRate, \r\n                                    channelConfig,\r\n                                    AudioFormat.ENCODING_PCM_16BIT,\r\n                                    AudioRecord.getMinBufferSize(sampleRate, channelConfig, AudioFormat.ENCODING_PCM_16BIT)\r\n                            );\r\n                            \r\n                            final com.codename1.media.AudioBuffer audioBuffer = com.codename1.media.MediaManager.getAudioBuffer(path, true, 64);\r\n                            final boolean[] stop = new boolean[1];\r\n\r\n                            record[0] = new AbstractMedia() {\r\n                                private int lastTime;\r\n                                private boolean isRecording;\r\n                                @Override\r\n                                protected void playImpl() {\r\n                                    if (isRecording) {\r\n                                        return;\r\n                                    }\r\n                                    isRecording = true;\r\n                                    recorder.startRecording();\r\n                                    fireMediaStateChange(State.Playing);\r\n                                    new Thread(new Runnable() {\r\n                                        public void run() {\r\n                                            float[] audioData = new float[audioBuffer.getMaxSize()];\r\n                                            short[] buffer = new short[AudioRecord.getMinBufferSize(recorder.getSampleRate(), recorder.getChannelCount(), AudioFormat.ENCODING_PCM_16BIT)];\r\n                                            int read = -1;\r\n                                            int index = 0;\r\n                                            \r\n                                            while (isRecording && (read = recorder.read(buffer, 0, buffer.length)) >= 0) {\r\n                                                if (read > 0) {\r\n                                                    for (int i=0; i<read; i++) {\r\n                                                        audioData[index] = ((float)buffer[i]) / 0x8000;\r\n                                                        index++;\r\n                                                        if (index >= audioData.length) {\r\n                                                            audioBuffer.copyFrom(sampleRate, audioChannels, audioData, 0, index);\r\n                                                            index = 0;\r\n                                                        }\r\n                                                    }\r\n                                                    if (index > 0) {\r\n                                                        audioBuffer.copyFrom(sampleRate, audioChannels, audioData, 0, index);\r\n                                                        index = 0;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n\r\n                                    }).start();\r\n                                }\r\n\r\n                                @Override\r\n                                protected void pauseImpl() {\r\n                                    if (!isRecording) {\r\n                                        return;\r\n                                    }\r\n                                    isRecording = false;\r\n                                    recorder.stop();\r\n\r\n\r\n                                    fireMediaStateChange(State.Paused);\r\n                                }\r\n\r\n                                @Override\r\n                                public void prepare() {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public void cleanup() {\r\n                                    pauseImpl();\r\n                                    recorder.release();\r\n                                    com.codename1.media.MediaManager.releaseAudioBuffer(path);\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getTime() {\r\n                                    if (isRecording) {\r\n                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\r\n                                            AudioTimestamp ts = new AudioTimestamp();\r\n                                            recorder.getTimestamp(ts, AudioTimestamp.TIMEBASE_MONOTONIC);\r\n                                            lastTime = (int) (ts.framePosition / ((float) sampleRate / 1000f));\r\n                                        }\r\n                                    }\r\n                                    return lastTime;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setTime(int time) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getDuration() {\r\n                                    return getTime();\r\n                                }\r\n\r\n                                @Override\r\n                                public void setVolume(int vol) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public int getVolume() {\r\n                                    return 0;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isPlaying() {\r\n                                    return recorder.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING;\r\n                                }\r\n\r\n                                @Override\r\n                                public Component getVideoComponent() {\r\n                                    return null;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isVideo() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isFullScreen() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setFullScreen(boolean fullScreen) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public void setNativePlayerMode(boolean nativePlayer) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public boolean isNativePlayerMode() {\r\n                                    return false;\r\n                                }\r\n\r\n                                @Override\r\n                                public void setVariable(String key, Object value) {\r\n                                    \r\n                                }\r\n\r\n                                @Override\r\n                                public Object getVariable(String key) {\r\n                                    return null;\r\n                                }\r\n                                \r\n                            };\r\n                            lock.notify();\r\n                        } else {\r\n                            MediaRecorder recorder = new MediaRecorder();\r\n                            recorder.setAudioSource(MediaRecorder.AudioSource.MIC);\r\n                        \r\n                            if(mimeType.contains(\"amr\")){\r\n                            recorder.setOutputFormat(MediaRecorder.OutputFormat.AMR_NB);\r\n                            recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\r\n                            }else{\r\n                                recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\r\n                                recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\r\n                                recorder.setAudioSamplingRate(sampleRate);\r\n                                recorder.setAudioEncodingBitRate(bitRate);\r\n                            }\r\n                            if (audioChannels > 0) {\r\n                                recorder.setAudioChannels(audioChannels);\r\n                            }\r\n                            if (maxDuration > 0) {\r\n                                recorder.setMaxDuration(maxDuration);\r\n                            }\r\n                            recorder.setOutputFile(removeFilePrefix(path));\r\n                            try {\r\n                                recorder.prepare();\r\n                                record[0] = new AndroidRecorder(recorder);\r\n                            } catch (IllegalStateException ex) {\r\n                                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                            } catch (IOException ex) {\r\n                                error[0] = ex;\r\n                            } finally {\r\n                                lock.notify();\r\n                            }\r\n                        }\r\n                        \r\n\r\n\r\n                    }\r\n                }\r\n            });\r\n\r\n            try {\r\n                lock.wait();\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n\r\n            if (error[0] != null) {\r\n                throw error[0];\r\n            }\r\n\r\n            return record[0];\r\n        }\r\n    }\r\n\r\n    public String [] getAvailableRecordingMimeTypes(){\r\n        // audio/aac and audio/mp4 result in the same thing\r\n        // AAC are wrapped in an mp4 container.\r\n        return new String[]{\"audio/amr\", \"audio/aac\", \"audio/mp4\"};\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object createSoftWeakRef(Object o) {\r\n        return new SoftReference(o);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object extractHardRef(Object o) {\r\n        SoftReference w = (SoftReference) o;\r\n        if (w != null) {\r\n            return w.get();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public PeerComponent createNativePeer(Object nativeComponent) {\r\n        if (!(nativeComponent instanceof View)) {\r\n            throw new IllegalArgumentException(nativeComponent.getClass().getName());\r\n        }\r\n        return new AndroidImplementation.AndroidPeer((View) nativeComponent);\r\n    }\r\n\r\n    private void blockNativeFocusAll(boolean block) {\r\n        synchronized (this.nativePeers) {\r\n            final int size = this.nativePeers.size();\r\n            for (int i = 0; i < size; i++) {\r\n                AndroidImplementation.AndroidPeer next = (AndroidImplementation.AndroidPeer) this.nativePeers.get(i);\r\n                next.blockNativeFocus(block);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void onFocusChange(View view, boolean bln) {\r\n\r\n        if (bln) {\r\n            /**\r\n             * whenever the base view receives focus we automatically block\r\n             * possible native subviews from gaining focus.\r\n             */\r\n            blockNativeFocusAll(true);\r\n            if (this.lastDirectionalKeyEventReceivedByWrapper != 0) {\r\n                /**\r\n                 * because we also consume any key event in the OnKeyListener of\r\n                 * the native wrappers, we have to simulate key events to make\r\n                 * Codename One move the focus to the next component.\r\n                 */\r\n                if (myView == null) {\r\n                    return;\r\n                }\r\n                if (!myView.getAndroidView().isInTouchMode()) {\r\n                    switch (lastDirectionalKeyEventReceivedByWrapper) {\r\n                        case AndroidImplementation.DROID_IMPL_KEY_LEFT:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_RIGHT:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_UP:\r\n                        case AndroidImplementation.DROID_IMPL_KEY_DOWN:\r\n                            Display.getInstance().keyPressed(lastDirectionalKeyEventReceivedByWrapper);\r\n                            Display.getInstance().keyReleased(lastDirectionalKeyEventReceivedByWrapper);\r\n                            break;\r\n                        default:\r\n                            Log.d(\"Codename One\", \"unexpected keycode: \" + lastDirectionalKeyEventReceivedByWrapper);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    Log.d(\"Codename One\", \"base view gained focus but no key event to process.\");\r\n                }\r\n                lastDirectionalKeyEventReceivedByWrapper = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void edtIdle(boolean enter) {\r\n        super.edtIdle(enter);\r\n        if(enter) {\r\n            // check if we have peers waiting for resize...\r\n            if(myView instanceof AndroidAsyncView) {\r\n                ((AndroidAsyncView)myView).resizeViews();\r\n            }\r\n        }\r\n    }\r\n\r\n    static final Map<View,AndroidPeer> activePeers = new HashMap<View,AndroidPeer>();\r\n\r\n\r\n    /**\r\n     * wrapper component that capsules a native view object in a Codename One\r\n     * component. this involves A LOT of back and forth between the Codename One\r\n     * EDT and the Android UI thread.\r\n     *\r\n     *\r\n     * To use it you would:\r\n     *\r\n     * 1) create your native Android view(s). Make sure to work on the Android\r\n     * UI thread when constructing and modifying them. 2) create a Codename One\r\n     * peer component by calling:\r\n     *\r\n     * com.codename1.ui.PeerComponent.create(myAndroidView);\r\n     *\r\n     * 3) currently the view's size is not automatically calculated from the\r\n     * native view. so you should set the preferred size of the Codename One\r\n     * component manually.\r\n     *\r\n     *\r\n     */\r\n    class AndroidPeer extends PeerComponent {\r\n\r\n        private View v;\r\n        private AndroidImplementation.AndroidRelativeLayout layoutWrapper = null;\r\n        private int currentVisible = View.INVISIBLE;\r\n        private boolean lightweightMode;\r\n\r\n        public AndroidPeer(View vv) {\r\n            super(vv);\r\n            this.v = vv;\r\n            if(!superPeerMode) {\r\n                v.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),\r\n                        MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));\r\n            }\r\n        }\r\n\r\n        @Override\r\n        protected Image generatePeerImage() {\r\n            try {\r\n                Bitmap bmp = AndroidNativeUtil.renderViewOnBitmap(v, getWidth(), getHeight());\r\n                if(bmp == null) {\r\n                    return Image.createImage(5, 5);\r\n                }\r\n                Image image = new AndroidImplementation.NativeImage(bmp);\r\n                return image;\r\n            } catch(Throwable t) {\r\n                t.printStackTrace();\r\n                return Image.createImage(5, 5);\r\n            }\r\n        }\r\n\r\n        protected boolean shouldRenderPeerImage() {\r\n            return !superPeerMode && (lightweightMode || !isInitialized());\r\n        }\r\n\r\n        protected void setLightweightMode(boolean l) {\r\n            if(superPeerMode) {\r\n                if (l != lightweightMode) {\r\n                    lightweightMode = l;\r\n                    if (lightweightMode) {\r\n                        Image img = generatePeerImage();\r\n                        if (img != null) {\r\n                            peerImage = img;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return;\r\n            }\r\n            doSetVisibility(!l);\r\n            if (lightweightMode == l) {\r\n                return;\r\n            }\r\n            lightweightMode = l;\r\n        }\r\n\r\n        @Override\r\n        public void setVisible(boolean visible) {\r\n            super.setVisible(visible);\r\n            this.doSetVisibility(visible);\r\n        }\r\n\r\n        void doSetVisibility(final boolean visible) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    currentVisible = visible ? View.VISIBLE : View.INVISIBLE;\r\n                    v.setVisibility(currentVisible);\r\n                    if (visible) {\r\n                        v.bringToFront();\r\n                    }\r\n                }\r\n            });\r\n            if(visible){\r\n                layoutPeer();\r\n            }\r\n        }\r\n\r\n        private void doSetVisibilityInternal(final boolean visible) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    currentVisible = visible ? View.VISIBLE : View.INVISIBLE;\r\n                    v.setVisibility(currentVisible);\r\n                    if (visible) {\r\n                        v.bringToFront();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        protected void deinitialize() {\r\n            if(!superPeerMode) {\r\n                Image i = generatePeerImage();\r\n                setPeerImage(i);\r\n                super.deinitialize();\r\n                synchronized (nativePeers) {\r\n                    nativePeers.remove(this);\r\n                }\r\n                deinit();\r\n            }else{\r\n                Image img = generatePeerImage();\r\n                if (img != null) {\r\n                    peerImage = img;\r\n                }\r\n\r\n                if(myView instanceof AndroidAsyncView){\r\n                    ((AndroidAsyncView)myView).removePeerView(v);\r\n                }\r\n                super.deinitialize();\r\n            }\r\n        }\r\n\r\n        public void deinit(){\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (peerImage == null) {\r\n                peerImage = generatePeerImage();\r\n            }\r\n            final boolean [] removed = new boolean[1];\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        if (layoutWrapper != null && AndroidImplementation.this.relativeLayout != null) {\r\n                            AndroidImplementation.this.relativeLayout.removeView(layoutWrapper);\r\n                            AndroidImplementation.this.relativeLayout.requestLayout();\r\n                            layoutWrapper = null;\r\n                        }\r\n                    } finally {\r\n                        removed[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!removed[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    public void run() {\r\n                        if (!removed[0]) {\r\n                            try {\r\n                                Thread.sleep(5);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        protected void initComponent() {\r\n            super.initComponent();\r\n            if(!superPeerMode) {\r\n                synchronized (nativePeers) {\r\n                    nativePeers.add(this);\r\n                }\r\n                init();\r\n                setPeerImage(null);\r\n            }\r\n        }\r\n\r\n        public void init(){\r\n            if(superPeerMode || getActivity() == null) {\r\n                return;\r\n            }\r\n            runOnUiThreadAndBlock(new Runnable() {\r\n                public void run() {\r\n                    if (layoutWrapper == null) {\r\n                        /**\r\n                         * wrap the native item in a layout that we can move\r\n                         * around on the surface view as we like.\r\n                         */\r\n                        layoutWrapper = new AndroidImplementation.AndroidRelativeLayout(activity, AndroidImplementation.AndroidPeer.this, v);\r\n                        layoutWrapper.setBackgroundDrawable(null);\r\n                        v.setVisibility(currentVisible);\r\n                        v.setFocusable(AndroidImplementation.AndroidPeer.this.isFocusable());\r\n                        v.setFocusableInTouchMode(true);\r\n                        ArrayList<View> viewList = new ArrayList<View>();\r\n                        viewList.add(layoutWrapper);\r\n                        v.addFocusables(viewList, View.FOCUS_DOWN);\r\n                        v.addFocusables(viewList, View.FOCUS_UP);\r\n                        v.addFocusables(viewList, View.FOCUS_LEFT);\r\n                        v.addFocusables(viewList, View.FOCUS_RIGHT);\r\n                        if (v.isFocusable() || v.isFocusableInTouchMode()) {\r\n                            if (AndroidImplementation.AndroidPeer.super.hasFocus()) {\r\n                                AndroidImplementation.this.blockNativeFocusAll(true);\r\n                                blockNativeFocus(false);\r\n                                if (!v.hasFocus()) {\r\n                                    v.requestFocus();\r\n                                }\r\n\r\n                            } else {\r\n                                blockNativeFocus(true);\r\n                            }\r\n                            layoutWrapper.setOnKeyListener(new View.OnKeyListener() {\r\n                                public boolean onKey(View view, int i, KeyEvent ke) {\r\n                                    lastDirectionalKeyEventReceivedByWrapper = CodenameOneView.internalKeyCodeTranslate(ke.getKeyCode());\r\n\r\n                                    // move focus back to base view.\r\n                                    if (AndroidImplementation.this.myView == null) return false;\r\n                                    AndroidImplementation.this.myView.getAndroidView().requestFocus();\r\n\r\n                                    /**\r\n                                     * if the wrapper has focus, then only because\r\n                                     * the wrapped native component just lost focus.\r\n                                     * we consume whatever key events we receive,\r\n                                     * just to make sure no half press/release\r\n                                     * sequence reaches the base view (and therefore\r\n                                     * Codename One).\r\n                                     */\r\n                                    return true;\r\n                                }\r\n                            });\r\n                            layoutWrapper.setOnFocusChangeListener(new View.OnFocusChangeListener() {\r\n                                public void onFocusChange(View view, boolean bln) {\r\n                                    Log.d(\"Codename One\", \"on focus change. \" + view.toString() + \" focus:\" + bln + \" touchmode: \" + v.isInTouchMode());\r\n                                }\r\n                            });\r\n                            layoutWrapper.setOnTouchListener(new View.OnTouchListener() {\r\n                                public boolean onTouch(View v, MotionEvent me) {\r\n                                    if (myView == null) return false;\r\n                                    return myView.getAndroidView().onTouchEvent(me);\r\n                                }\r\n                            });\r\n                        }\r\n                        if(AndroidImplementation.this.relativeLayout != null){\r\n                            // not sure why this happens but we got an exception where add view was called with\r\n                            // a layout that was already added...\r\n                            if(layoutWrapper.getParent() != null) {\r\n                                ((ViewGroup)layoutWrapper.getParent()).removeView(layoutWrapper);\r\n                            }\r\n                            AndroidImplementation.this.relativeLayout.addView(layoutWrapper);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        private Image peerImage;\r\n        public void paint(final Graphics g) {\r\n            if(superPeerMode) {\r\n                Object nativeGraphics = com.codename1.ui.Accessor.getNativeGraphics(g);\r\n\r\n                Object o = v.getLayoutParams();\r\n                AndroidAsyncView.LayoutParams lp;\r\n                if(o instanceof AndroidAsyncView.LayoutParams) {\r\n                    lp = (AndroidAsyncView.LayoutParams) o;\r\n                    if (lp == null) {\r\n                        lp = new AndroidAsyncView.LayoutParams(\r\n                                getX() + g.getTranslateX(),\r\n                                getY() + g.getTranslateY(),\r\n                                getWidth(),\r\n                                getHeight(), AndroidPeer.this);\r\n                        final AndroidAsyncView.LayoutParams finalLp = lp;\r\n                        activity.runOnUiThread(new Runnable() {\r\n                            @Override\r\n                            public void run() {\r\n                                v.setLayoutParams(finalLp);\r\n                            }\r\n                        });\r\n                        lp.dirty = true;\r\n                    } else {\r\n                        int x = getX() + g.getTranslateX();\r\n                        int y = getY() + g.getTranslateY();\r\n                        int w = getWidth();\r\n                        int h = getHeight();\r\n                        if (x != lp.x || y != lp.y || w != lp.w || h != lp.h) {\r\n                            lp.dirty = true;\r\n                            lp.x = x;\r\n                            lp.y = y;\r\n                            lp.w = w;\r\n                            lp.h = h;\r\n                        }\r\n                    }\r\n                } else {\r\n                    final AndroidAsyncView.LayoutParams finalLp = new AndroidAsyncView.LayoutParams(\r\n                            getX() + g.getTranslateX(),\r\n                            getY() + g.getTranslateY(),\r\n                            getWidth(),\r\n                            getHeight(), AndroidPeer.this);\r\n                    activity.runOnUiThread(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            v.setLayoutParams(finalLp);\r\n                        }\r\n                    });\r\n                    finalLp.dirty = true;\r\n                    lp = finalLp;\r\n                }\r\n\r\n                // this is a mutable image or side menu etc. where the peer is drawn on a different form...\r\n                // Special case...\r\n                if(nativeGraphics.getClass() == AndroidGraphics.class) {\r\n                    if(peerImage == null) {\r\n                        peerImage = generatePeerImage();\r\n                    }\r\n                    //systemOut(\"Drawing native image\");\r\n                    g.drawImage(peerImage, getX(), getY());\r\n                    return;\r\n                }\r\n                synchronized(activePeers) {\r\n                    activePeers.put(v, this);\r\n                }\r\n                ((AndroidGraphics) nativeGraphics).drawView(v, lp);\r\n                if (lightweightMode && peerImage != null) {\r\n                    g.drawImage(peerImage, getX(), getY(), getWidth(), getHeight());\r\n                }\r\n            } else {\r\n                super.paint(g);\r\n            }\r\n        }\r\n\r\n        boolean _initialized() {\r\n            return isInitialized();\r\n        }\r\n\r\n        @Override\r\n        protected void onPositionSizeChange() {\r\n            if(!superPeerMode) {\r\n                Form f = getComponentForm();\r\n                if (v.getVisibility() == View.INVISIBLE\r\n                        && f != null\r\n                        && Display.getInstance().getCurrent() == f) {\r\n                    doSetVisibilityInternal(true);\r\n                    return;\r\n                }\r\n                layoutPeer();\r\n            }\r\n        }\r\n\r\n        protected void layoutPeer(){\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if(!superPeerMode) {\r\n                // called by Codename One EDT to position the native component.\r\n                activity.runOnUiThread(new Runnable() {\r\n                    public void run() {\r\n                        if (layoutWrapper != null) {\r\n                            if (v.getVisibility() == View.VISIBLE) {\r\n\r\n                                RelativeLayout.LayoutParams layoutParams = layoutWrapper.createMyLayoutParams(\r\n                                        AndroidImplementation.AndroidPeer.this.getAbsoluteX(),\r\n                                        AndroidImplementation.AndroidPeer.this.getAbsoluteY(),\r\n                                        AndroidImplementation.AndroidPeer.this.getWidth(),\r\n                                        AndroidImplementation.AndroidPeer.this.getHeight());\r\n                                layoutWrapper.setLayoutParams(layoutParams);\r\n                                if (AndroidImplementation.this.relativeLayout != null) {\r\n                                    AndroidImplementation.this.relativeLayout.requestLayout();\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        void blockNativeFocus(boolean block) {\r\n            if (layoutWrapper != null) {\r\n                layoutWrapper.setDescendantFocusability(block\r\n                        ? ViewGroup.FOCUS_BLOCK_DESCENDANTS : ViewGroup.FOCUS_AFTER_DESCENDANTS);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean isFocusable() {\r\n            // EDT\r\n            if (v != null) {\r\n                return v.isFocusableInTouchMode() || v.isFocusable();\r\n            } else {\r\n                return super.isFocusable();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setFocusable(final boolean focusable) {\r\n            // EDT\r\n            super.setFocusable(focusable);\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    v.setFocusable(focusable);\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void focusGained() {\r\n            Log.d(\"Codename One\", \"native focus gain\");\r\n            // EDT\r\n            super.focusGained();\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    // allow this one to gain focus\r\n                    blockNativeFocus(false);\r\n                    if (!v.hasFocus()) {\r\n                        if (v.isInTouchMode()) {\r\n                            v.requestFocusFromTouch();\r\n                        } else {\r\n                            v.requestFocus();\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void focusLost() {\r\n            Log.d(\"Codename One\", \"native focus loss\");\r\n            // EDT\r\n            super.focusLost();\r\n            if (layoutWrapper != null && getActivity() != null) {\r\n                getActivity().runOnUiThread(new Runnable() {\r\n                    public void run() {\r\n                        if(isInitialized()) {\r\n                            // request focus of the wrapper. that will trigger the\r\n                            // android focus listener and move focus back to the\r\n                            // base view.\r\n                            layoutWrapper.requestFocus();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        public void release() {\r\n            deinitialize();\r\n        }\r\n\r\n        @Override\r\n        protected Dimension calcPreferredSize() {\r\n            int w = 1;\r\n            int h = 1;\r\n            Drawable d = v.getBackground();\r\n            if (d != null) {\r\n                w = d.getMinimumWidth();\r\n                h = d.getMinimumHeight();\r\n            }\r\n            w = Math.max(v.getMeasuredWidth(), w);\r\n            h = Math.max(v.getMeasuredHeight(), h);\r\n            if (v instanceof TextView) {\r\n                TextView tv = (TextView)v;\r\n                w = (int) android.text.Layout.getDesiredWidth(((TextView) v).getText(), ((TextView) v).getPaint());\r\n                int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);\r\n                tv.measure(w, heightMeasureSpec);\r\n                h = (int)Math.max(h, tv.getMeasuredHeight());\r\n\r\n\r\n            }\r\n            return new Dimension(w, h);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * inner class that wraps the native components. this is a useful thingy to\r\n     * handle focus stuff and buffering.\r\n     */\r\n    class AndroidRelativeLayout extends RelativeLayout {\r\n\r\n        private AndroidImplementation.AndroidPeer peer;\r\n\r\n        public AndroidRelativeLayout(Context activity, AndroidImplementation.AndroidPeer peer, View v) {\r\n            super(activity);\r\n\r\n            this.peer = peer;\r\n            this.setLayoutParams(createMyLayoutParams(peer.getAbsoluteX(), peer.getAbsoluteY(),\r\n                    peer.getWidth(), peer.getHeight()));\r\n            if (v.getParent() != null) {\r\n                ((ViewGroup)v.getParent()).removeView(v);\r\n            }\r\n            this.addView(v, new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.FILL_PARENT,\r\n                    RelativeLayout.LayoutParams.FILL_PARENT));\r\n            this.setDrawingCacheEnabled(false);\r\n            this.setAlwaysDrawnWithCacheEnabled(false);\r\n            this.setFocusable(true);\r\n            this.setFocusableInTouchMode(false);\r\n            this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\r\n\r\n        }\r\n\r\n        /**\r\n         * create a layout parameter object that holds the native component's\r\n         * position.\r\n         *\r\n         * @return\r\n         */\r\n        private RelativeLayout.LayoutParams createMyLayoutParams(int x, int y, int width, int height) {\r\n            RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\r\n                    RelativeLayout.LayoutParams.WRAP_CONTENT,\r\n                    RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n            layoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);\r\n            layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);\r\n            layoutParams.width = width;\r\n            layoutParams.height = height;\r\n            layoutParams.leftMargin = x;\r\n            layoutParams.topMargin = y;\r\n            return layoutParams;\r\n        }\r\n\r\n        @Override\r\n        public boolean dispatchKeyEvent(KeyEvent event) {\r\n\r\n            int keycode = event.getKeyCode();\r\n            keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n            if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK) {\r\n                switch (event.getAction()) {\r\n                    case KeyEvent.ACTION_DOWN:\r\n                        Display.getInstance().keyPressed(keycode);\r\n                        break;\r\n                    case KeyEvent.ACTION_UP:\r\n                        Display.getInstance().keyReleased(keycode);\r\n                        break;\r\n                }\r\n                return true;\r\n            } else {\r\n                return super.dispatchKeyEvent(event);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private boolean testedNativeTheme;\r\n    private boolean nativeThemeAvailable;\r\n\r\n    public boolean hasNativeTheme() {\r\n        if (!testedNativeTheme) {\r\n            testedNativeTheme = true;\r\n            try {\r\n                InputStream is;\r\n                if (android.os.Build.VERSION.SDK_INT < 14 && !isTablet()) {\r\n                    is = getResourceAsStream(getClass(), \"/androidTheme.res\");\r\n                } else {\r\n                    is = getResourceAsStream(getClass(), \"/android_holo_light.res\");\r\n                }\r\n                nativeThemeAvailable = is != null;\r\n                if (is != null) {\r\n                    is.close();\r\n                }\r\n            } catch (IOException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        return nativeThemeAvailable;\r\n    }\r\n\r\n    /**\r\n     * Installs the native theme, this is only applicable if hasNativeTheme()\r\n     * returned true. Notice that this method might replace the\r\n     * DefaultLookAndFeel instance and the default transitions.\r\n     */\r\n    public void installNativeTheme() {\r\n        hasNativeTheme();\r\n        if (nativeThemeAvailable) {\r\n            try {\r\n                InputStream is;\r\n                if (android.os.Build.VERSION.SDK_INT < 14 && !isTablet() || Display.getInstance().getProperty(\"and.hololight\", \"false\").equals(\"true\")) {\r\n                    is = getResourceAsStream(getClass(), \"/androidTheme.res\");\r\n                } else {\r\n                    is = getResourceAsStream(getClass(), \"/android_holo_light.res\");\r\n                }\r\n                Resources r = Resources.open(is);\r\n                Hashtable h = r.getTheme(r.getThemeResourceNames()[0]);\r\n                h.put(\"@commandBehavior\", \"Native\");\r\n                UIManager.getInstance().setThemeProps(h);\r\n                is.close();\r\n                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_NATIVE);\r\n            } catch (IOException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean isNativeBrowserComponentSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setNativeBrowserScrollingEnabled(final PeerComponent browserPeer, final boolean e) {\r\n        super.setNativeBrowserScrollingEnabled(browserPeer, e);\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                AndroidBrowserComponent bc = (AndroidBrowserComponent)browserPeer;\r\n                bc.setScrollingEnabled(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void setPinchToZoomEnabled(final PeerComponent browserPeer, final boolean e) {\r\n        super.setPinchToZoomEnabled(browserPeer, e);\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                AndroidBrowserComponent bc = (AndroidBrowserComponent)browserPeer;\r\n                bc.setPinchZoomEnabled(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    public PeerComponent createBrowserComponent(final Object parent) {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        final AndroidImplementation.AndroidBrowserComponent[] bc = new AndroidImplementation.AndroidBrowserComponent[1];\r\n        final Throwable[] error = new Throwable[1];\r\n        final Object lock = new Object();\r\n\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n\r\n                synchronized (lock) {\r\n                    try {\r\n                        WebView wv = new WebView(getActivity()) {\r\n\r\n                            @Override\r\n                            public boolean dispatchKeyEvent(KeyEvent event) {\r\n\r\n                                int keycode = event.getKeyCode();\r\n                                keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n                                if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK || \r\n                                    (keycode == KeyEvent.KEYCODE_MENU && \r\n                                        Display.getInstance().getCommandBehavior() != Display.COMMAND_BEHAVIOR_NATIVE)) {\r\n                                    switch (event.getAction()) {\r\n                                        case KeyEvent.ACTION_DOWN:\r\n                                            Display.getInstance().keyPressed(keycode);\r\n                                            break;\r\n                                        case KeyEvent.ACTION_UP:\r\n                                            Display.getInstance().keyReleased(keycode);\r\n                                            break;\r\n                                    }\r\n                                    return true;\r\n                                } else {\r\n                                    if(Display.getInstance().getProperty(\r\n                                        \"android.propogateKeyEvents\", \"false\").\r\n                                            equalsIgnoreCase(\"true\") && \r\n                                        myView instanceof AndroidAsyncView) {\r\n                                        switch (event.getAction()) {\r\n                                            case KeyEvent.ACTION_DOWN:\r\n                                                Display.getInstance().keyPressed(keycode);\r\n                                                break;\r\n                                            case KeyEvent.ACTION_UP:\r\n                                                Display.getInstance().keyReleased(keycode);\r\n                                                break;\r\n                                        }\r\n                                        return true;\r\n                                    }                                    \r\n                                                                        \r\n                                    return super.dispatchKeyEvent(event);\r\n                                }\r\n                            }\r\n                        };\r\n                        wv.setOnTouchListener(new View.OnTouchListener() {\r\n\r\n                            @Override\r\n                            public boolean onTouch(View v, MotionEvent event) {\r\n                                switch (event.getAction()) {\r\n                                    case MotionEvent.ACTION_DOWN:\r\n                                    case MotionEvent.ACTION_UP:\r\n                                        if (!v.hasFocus()) {\r\n                                            v.requestFocus();\r\n                                        }\r\n                                        break;\r\n                                }\r\n                                return false;\r\n                            }\r\n                        });\r\n                        \r\n                        if (android.os.Build.VERSION.SDK_INT >= 19) {\r\n                            if (\"true\".equals(Display.getInstance().getProperty(\"android.webContentsDebuggingEnabled\", \"false\"))) {\r\n                                wv.setWebContentsDebuggingEnabled(true);\r\n                            }\r\n                        }\r\n                        wv.getSettings().setDomStorageEnabled(true);\r\n                        wv.getSettings().setAllowFileAccess(true);\r\n                        wv.getSettings().setAllowContentAccess(true);\r\n                        wv.requestFocus(View.FOCUS_DOWN);\r\n                        wv.setFocusableInTouchMode(true);\r\n                        if (android.os.Build.VERSION.SDK_INT >= 17) {\r\n                            wv.getSettings().setMediaPlaybackRequiresUserGesture(false);\r\n                        }\r\n                        bc[0] = new AndroidImplementation.AndroidBrowserComponent(wv, getActivity(), parent);\r\n                        lock.notify();\r\n                    } catch (Throwable t) {\r\n                        error[0] = t;\r\n                        lock.notify();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        while (bc[0] == null && error[0] == null) {\r\n            Display.getInstance().invokeAndBlock(new Runnable() {\r\n                public void run() {\r\n                    synchronized (lock) {\r\n                        if (bc[0] == null && error[0] == null) {\r\n                            try {\r\n                                lock.wait(20);\r\n                            } catch (InterruptedException ex) {\r\n                                ex.printStackTrace();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            });\r\n        }\r\n        if (error[0] != null) {\r\n            throw new RuntimeException(error[0]);\r\n        }\r\n        return bc[0];\r\n    }\r\n\r\n    public void setBrowserProperty(PeerComponent browserPeer, String key, Object value) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).setProperty(key, value);\r\n    }\r\n\r\n    public String getBrowserTitle(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).getTitle();\r\n    }\r\n\r\n    public String getBrowserURL(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).getURL();\r\n    }\r\n\r\n    @Override\r\n    public void setBrowserURL(PeerComponent browserPeer, String url, Map<String, String> headers) {\r\n        if (url.startsWith(\"jar:\")) {\r\n            url = url.substring(6);\r\n            if(url.indexOf(\"/\") != 0) {\r\n                url = \"/\"+url;\r\n            }\r\n\r\n            url = \"file:///android_asset\"+url;\r\n        }\r\n        AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        if(bc.parent.fireBrowserNavigationCallbacks(url)) {\r\n            bc.setURL(url, headers);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isURLWithCustomHeadersSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setBrowserURL(PeerComponent browserPeer, String url) {\r\n        setBrowserURL(browserPeer, url, null);\r\n    }\r\n\r\n    public void browserStop(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).stop();\r\n    }\r\n\r\n    public void browserDestroy(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).destroy();\r\n    }\r\n\r\n    /**\r\n     * Reload the current page\r\n     *\r\n     * @param browserPeer browser instance\r\n     */\r\n    public void browserReload(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).reload();\r\n    }\r\n\r\n    /**\r\n     * Indicates whether back is currently available\r\n     *\r\n     * @param browserPeer browser instance\r\n     * @return true if back should work\r\n     */\r\n    public boolean browserHasBack(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).hasBack();\r\n    }\r\n\r\n    public boolean browserHasForward(PeerComponent browserPeer) {\r\n        return ((AndroidImplementation.AndroidBrowserComponent) browserPeer).hasForward();\r\n    }\r\n\r\n    public void browserBack(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).back();\r\n    }\r\n\r\n    public void browserForward(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).forward();\r\n    }\r\n\r\n    public void browserClearHistory(PeerComponent browserPeer) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).clearHistory();\r\n    }\r\n\r\n    public void setBrowserPage(PeerComponent browserPeer, String html, String baseUrl) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).setPage(html, baseUrl);\r\n    }\r\n\r\n    public void browserExposeInJavaScript(PeerComponent browserPeer, Object o, String name) {\r\n        ((AndroidImplementation.AndroidBrowserComponent) browserPeer).exposeInJavaScript(o, name);\r\n    }\r\n\r\n    private boolean useEvaluateJavascript() {\r\n        return android.os.Build.VERSION.SDK_INT >= 19;\r\n    }\r\n    \r\n\r\n    private int jsCallbackIndex=0;\r\n\r\n    private void execJSUnsafe(WebView web, String js) {\r\n        if (useEvaluateJavascript()) {\r\n            web.evaluateJavascript(js, null);\r\n        } else {\r\n            web.loadUrl(\"javascript:(function(){\"+js+\"})()\");\r\n        }\r\n    }\r\n\r\n    private void execJSSafe(final WebView web, final String js) {\r\n        if (useJSDispatchThread()) {\r\n            runOnJSDispatchThread(new Runnable() {\r\n                public void run() {\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        public void run() {\r\n                            execJSUnsafe(web, js);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    execJSUnsafe(web, js);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private void execJSUnsafe(final AndroidBrowserComponent bc, final String javaScript, final ValueCallback<String> resultCallback) {\r\n        if (useEvaluateJavascript()) {\r\n            try {\r\n                bc.web.evaluateJavascript(javaScript, resultCallback);\r\n            } catch (Throwable t) {\r\n                com.codename1.io.Log.e(t);\r\n                resultCallback.onReceiveValue(null);\r\n            }\r\n        } else {\r\n            jsCallbackIndex = (++jsCallbackIndex) % 1024;\r\n            int index = jsCallbackIndex;\r\n\r\n            // The jsCallback is a special java object exposed to javascript that we use\r\n            // to return values from javascript to java.\r\n            synchronized (bc.jsCallback){\r\n                // Initialize the return value to null\r\n                while (!bc.jsCallback.isIndexAvailable(index)) {\r\n                    index++;\r\n                }\r\n                jsCallbackIndex = index+1;\r\n            }\r\n            final int fIndex = index;\r\n            // We are placing the javascript inside eval() so we need to escape\r\n            // the input.\r\n            String escaped = StringUtil.replaceAll(javaScript, \"\\\\\", \"\\\\\\\\\");\r\n            escaped = StringUtil.replaceAll(escaped, \"'\", \"\\\\'\");\r\n\r\n            final String js = \"javascript:(function(){\"\r\n\r\n                    + \"try{\"\r\n                    +bc.jsCallback.jsInit()\r\n                    +bc.jsCallback.jsCleanup()\r\n                    + AndroidBrowserComponentCallback.JS_RETURNVAL_VARNAME+\"[\"+index+\"]\"\r\n                    + \"=eval('\"+escaped +\"');} catch (e){console.log(e)};\"\r\n                    + AndroidBrowserComponentCallback.JS_VAR_NAME+\".addReturnValue(\" + index+\", ''+\"\r\n\r\n                    + AndroidBrowserComponentCallback.JS_RETURNVAL_VARNAME+\"[\"+index+\"]\"\r\n                    + \");})()\";\r\n\r\n            // Send the Javascript string via SetURL.\r\n            // NOTE!! This is sent asynchronously so we will need to wait for\r\n            // the result to come in.\r\n            bc.setURL(js, null);\r\n            if (resultCallback == null) {\r\n                return;\r\n            }\r\n            Thread t = new Thread(new Runnable() {\r\n                public void run() {\r\n                    int maxTries = 500;\r\n                    int tryCounter = 0;\r\n\r\n                    // If we are not on the EDT, then it is safe to just loop and wait.\r\n                    while (!bc.jsCallback.isValueSet(fIndex) && tryCounter++ < maxTries) {\r\n                        synchronized(bc.jsCallback){\r\n                            Util.wait(bc.jsCallback, 20);\r\n                        }\r\n                    }\r\n\r\n                    if (bc.jsCallback.isValueSet(fIndex)) {\r\n                        String retval = bc.jsCallback.getReturnValue(fIndex);\r\n                        bc.jsCallback.remove(fIndex);\r\n                        resultCallback.onReceiveValue(retval != null ? JSONObject.quote(retval) : null);\r\n\r\n                    } else {\r\n                        com.codename1.io.Log.e(new RuntimeException(\"Failed to execute javascript \"+js+\" after maximum wait time.\"));\r\n                        resultCallback.onReceiveValue(null);\r\n                    }\r\n                }\r\n            });\r\n            t.start();\r\n\r\n        }\r\n    }\r\n\r\n    private void execJSSafe(final AndroidBrowserComponent bc, final String javaScript, final ValueCallback<String> resultCallback) {\r\n        if (useJSDispatchThread()) {\r\n            runOnJSDispatchThread(new Runnable() {\r\n                public void run() {\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        public void run() {\r\n                            execJSUnsafe(bc, javaScript, resultCallback);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    execJSUnsafe(bc, javaScript, resultCallback);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void browserExecute(final PeerComponent browserPeer, final String javaScript) {\r\n        final AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        execJSSafe(bc.web, javaScript);\r\n    }\r\n\r\n    private com.codename1.util.EasyThread jsDispatchThread;\r\n    private com.codename1.util.EasyThread jsDispatchThread() {\r\n        if (jsDispatchThread == null) {\r\n            jsDispatchThread = com.codename1.util.EasyThread.start(\"JS Dispatch Thread\");\r\n        }\r\n        return jsDispatchThread;\r\n    }\r\n\r\n    private boolean useJSDispatchThread() {\r\n\r\n        // Before version 24, we need a separate JS dispatch thread to prevent deadlocks\r\n        return true;//Build.VERSION.SDK_INT < 24;\r\n    }\r\n\r\n    public boolean isJSDispatchThread() {\r\n        if (useJSDispatchThread()) {\r\n            return jsDispatchThread().isThisIt();\r\n        } else {\r\n            return (Looper.getMainLooper().getThread() == Thread.currentThread());\r\n        }\r\n    }\r\n\r\n    public boolean runOnJSDispatchThread(Runnable r) {\r\n        if (isJSDispatchThread()) {\r\n            r.run();\r\n            return true;\r\n        }\r\n        if (useJSDispatchThread()) {\r\n            jsDispatchThread().run(r);\r\n        } else {\r\n            getActivity().runOnUiThread(r);\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Executes javascript and returns a string result where appropriate.\r\n     * @param browserPeer\r\n     * @param javaScript\r\n     * @return\r\n     */\r\n    @Override\r\n    public String browserExecuteAndReturnString(final PeerComponent browserPeer, final String javaScript) {\r\n        final AndroidImplementation.AndroidBrowserComponent bc = (AndroidImplementation.AndroidBrowserComponent) browserPeer;\r\n        final String[] result = new String[1];\r\n        final boolean[] complete = new boolean[1];\r\n\r\n        execJSSafe(bc, javaScript, new ValueCallback<String>() {\r\n            @Override\r\n            public void onReceiveValue(String value) {\r\n                synchronized(result) {\r\n                    complete[0] = true;\r\n                    result[0] = value;\r\n                    result.notify();\r\n                }\r\n            }\r\n        });\r\n        synchronized(result) {\r\n            if (!complete[0]) {\r\n                Util.wait(result, 10000);\r\n            }\r\n        }\r\n        if (result[0] == null) {\r\n            return null;\r\n        } else {\r\n            org.json.JSONTokener tok = new org.json.JSONTokener(\"{\\\"result\\\":\"+result[0]+\"}\");\r\n            try {\r\n                JSONObject jso = new JSONObject(tok);\r\n                return jso.getString(\"result\");\r\n            } catch (Throwable ex) {\r\n                com.codename1.io.Log.e(ex);\r\n                return null;\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public boolean supportsBrowserExecuteAndReturnString(PeerComponent browserPeer) {\r\n        return true;\r\n    }\r\n\r\n    public boolean canForceOrientation() {\r\n        return true;\r\n    }\r\n\r\n    public void lockOrientation(boolean portrait) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        if(portrait){\r\n            getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\r\n        }else{\r\n            getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\r\n        }\r\n    }\r\n\r\n    public void unlockOrientation() {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);\r\n    }\r\n\r\n\r\n\r\n    public boolean isAffineSupported() {\r\n        return true;\r\n    }\r\n\r\n    public void resetAffine(Object nativeGraphics) {\r\n        ((AndroidGraphics) nativeGraphics).resetAffine();\r\n    }\r\n\r\n    public void scale(Object nativeGraphics, float x, float y) {\r\n        ((AndroidGraphics) nativeGraphics).scale(x, y);\r\n    }\r\n\r\n    public void rotate(Object nativeGraphics, float angle) {\r\n        ((AndroidGraphics) nativeGraphics).rotate(angle);\r\n    }\r\n\r\n    public void rotate(Object nativeGraphics, float angle, int x, int y) {\r\n        ((AndroidGraphics) nativeGraphics).rotate(angle, x, y);\r\n    }\r\n\r\n    public void shear(Object nativeGraphics, float x, float y) {\r\n    }\r\n\r\n    public boolean isTablet() {\r\n        return (getContext().getResources().getConfiguration().screenLayout\r\n                & Configuration.SCREENLAYOUT_SIZE_MASK)\r\n                >= Configuration.SCREENLAYOUT_SIZE_LARGE;\r\n    }\r\n\r\n    /**\r\n     * Executes r on the UI thread and blocks the EDT to completion\r\n     * @param r runnable to execute\r\n     */\r\n    public static void runOnUiThreadAndBlock(final Runnable r) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot run on UI thread because getActivity() is null.  This generally means we are running inside a service in the background so UI access is disabled.\");\r\n        }\r\n\r\n        final boolean[] completed = new boolean[1];\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    r.run();\r\n                } catch(Throwable t) {\r\n                    com.codename1.io.Log.e(t);\r\n                }\r\n                synchronized(completed) {\r\n                    completed[0] = true;\r\n                    completed.notify();\r\n                }\r\n            }\r\n        });\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                synchronized(completed) {\r\n                    while(!completed[0]) {\r\n                        try {\r\n                            completed.wait();\r\n                        } catch(InterruptedException err) {}\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    public static void runOnUiThreadSync(final Runnable r) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot run on UI thread because getActivity() is null.  This generally means we are running inside a service in the background so UI access is disabled.\");\r\n        }\r\n\r\n        final boolean[] completed = new boolean[1];\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    r.run();\r\n                } catch(Throwable t) {\r\n                    com.codename1.io.Log.e(t);\r\n                }\r\n                synchronized(completed) {\r\n                    completed[0] = true;\r\n                    completed.notify();\r\n                }\r\n            }\r\n        });\r\n        synchronized(completed) {\r\n            while(!completed[0]) {\r\n                try {\r\n                    completed.wait();\r\n                } catch(InterruptedException err) {}\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public int convertToPixels(int dipCount, boolean horizontal) {\r\n        DisplayMetrics dm = getContext().getResources().getDisplayMetrics();\r\n        float ppi = dm.density * 160f;\r\n        return (int) (((float) dipCount) / 25.4f * ppi);\r\n    }\r\n\r\n    public boolean isPortrait() {\r\n        int orientation = getContext().getResources().getConfiguration().orientation;\r\n        if (orientation == Configuration.ORIENTATION_UNDEFINED\r\n                || orientation == Configuration.ORIENTATION_SQUARE) {\r\n            return super.isPortrait();\r\n        }\r\n        return orientation == Configuration.ORIENTATION_PORTRAIT;\r\n    }\r\n\r\n    /**\r\n     * Checks if this platform supports sharing cookies between Native components (e.g. BrowserComponent)\r\n     * and ConnectionRequests.  Currently only Android and iOS ports support this.\r\n     * @return\r\n     */\r\n    @Override\r\n    public boolean isNativeCookieSharingSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void clearNativeCookies() {\r\n        CookieManager mgr = getCookieManager();\r\n        mgr.removeAllCookie();\r\n    }\r\n    private static CookieManager cookieManager;\r\n    private static CookieManager getCookieManager() {\r\n        if (android.os.Build.VERSION.SDK_INT >= 21) {\r\n            return CookieManager.getInstance();\r\n        }\r\n        if (cookieManager == null) {\r\n            CookieSyncManager.createInstance(getContext()); // Fixes a crash on Android 4.3\r\n            // https://stackoverflow.com/a/20552998/2935174\r\n            cookieManager = CookieManager.getInstance();\r\n        }\r\n        return CookieManager.getInstance();\r\n    }\r\n\r\n    @Override\r\n    public Vector getCookiesForURL(String url) {\r\n        if (isUseNativeCookieStore()) {\r\n            try {\r\n                URI uri = new URI(url);\r\n\r\n\r\n                CookieManager mgr = getCookieManager();\r\n                mgr.removeExpiredCookie();\r\n                String domain = uri.getHost();\r\n                String cookieStr = mgr.getCookie(url);\r\n                if (cookieStr != null) {\r\n                    String[] cookies = cookieStr.split(\";\");\r\n                    int len = cookies.length;\r\n                    Vector out = new Vector();\r\n                    for (int i = 0; i < len; i++) {\r\n                        Cookie c = new Cookie();\r\n                        String[] parts = cookies[i].split(\"=\");\r\n                        c.setName(parts[0].trim());\r\n                        if (parts.length > 1) {\r\n                            c.setValue(parts[1].trim());\r\n                        } else {\r\n                            c.setValue(\"\");\r\n                        }\r\n                        c.setDomain(domain);\r\n                        out.add(c);\r\n                    }\r\n                    return out;\r\n                }\r\n            } catch (Exception ex) {\r\n                com.codename1.io.Log.e(ex);\r\n            }\r\n            return new Vector();\r\n        }\r\n        return super.getCookiesForURL(url);\r\n    }\r\n\r\n    public class WebAppInterface {\r\n        BrowserComponent bc;\r\n        /** Instantiate the interface and set the context */\r\n        WebAppInterface(BrowserComponent bc) {\r\n            this.bc = bc;\r\n        }\r\n\r\n        @JavascriptInterface   // must be added for API 17 or higher\r\n        public boolean shouldNavigate(String url) {\r\n            return bc.fireBrowserNavigationCallbacks(url);\r\n        }\r\n    }\r\n    \r\n    class AndroidBrowserComponent extends AndroidImplementation.AndroidPeer {\r\n\r\n        private Activity act;\r\n        private WebView web;\r\n        private BrowserComponent parent;\r\n        private boolean scrollingEnabled = true;\r\n        protected AndroidBrowserComponentCallback jsCallback;\r\n        private boolean lightweightMode = false;\r\n        private ProgressDialog progressBar;\r\n        private boolean hideProgress;\r\n        private int layerType;\r\n\r\n\r\n        public AndroidBrowserComponent(final WebView web, Activity act, Object p) {\r\n            super(web);\r\n            if(!superPeerMode) {\r\n                doSetVisibility(false);\r\n            }\r\n            parent = (BrowserComponent) p;\r\n            this.web = web;\r\n            layerType = web.getLayerType();\r\n            web.getSettings().setJavaScriptEnabled(true);\r\n            web.getSettings().setSupportZoom(parent.isPinchToZoomEnabled());\r\n            this.act = act;\r\n            jsCallback = new AndroidBrowserComponentCallback();\r\n            hideProgress = Display.getInstance().getProperty(\"WebLoadingHidden\", \"false\").equals(\"true\");\r\n\r\n            web.addJavascriptInterface(jsCallback, AndroidBrowserComponentCallback.JS_VAR_NAME);\r\n            web.addJavascriptInterface(new WebAppInterface(parent), \"cn1application\");\r\n\r\n            web.setWebViewClient(new WebViewClient() {\r\n                \r\n                \r\n                \r\n                public void onLoadResource(WebView view, String url) {\r\n                    if (Display.getInstance().getProperty(\"syncNativeCookies\", \"false\").equals(\"true\")) {\r\n                        try {\r\n                            URI uri = new URI(url);\r\n                            CookieManager mgr = getCookieManager();\r\n                            mgr.removeExpiredCookie();\r\n                            String domain = uri.getHost();\r\n                            removeCookiesForDomain(domain);\r\n                            String cookieStr = mgr.getCookie(url);\r\n                            if (cookieStr != null) {\r\n                                String[] cookies = cookieStr.split(\";\");\r\n                                int len = cookies.length;\r\n                                ArrayList out = new ArrayList();\r\n                                for (int i = 0; i < len; i++) {\r\n                                    Cookie c = new Cookie();\r\n                                    String[] parts = cookies[i].split(\"=\");\r\n                                    c.setName(parts[0].trim());\r\n                                    if (parts.length > 1) {\r\n                                        c.setValue(parts[1].trim());\r\n                                    } else {\r\n                                        c.setValue(\"\");\r\n                                    }\r\n                                    c.setDomain(domain);\r\n                                    out.add(c);\r\n                                }\r\n                                Cookie[] cookiesArr = new Cookie[out.size()];\r\n                                out.toArray(cookiesArr);\r\n                                AndroidImplementation.this.addCookie(cookiesArr, false);\r\n                            }\r\n\r\n                        } catch (URISyntaxException ex) {\r\n\r\n                        }\r\n                    }\r\n                    parent.fireWebEvent(\"onLoadResource\", new ActionEvent(url));\r\n                    super.onLoadResource(view, url);\r\n                    setShouldCalcPreferredSize(true);\r\n                }\r\n\r\n                @Override\r\n                public void onPageStarted(WebView view, String url, Bitmap favicon) {\r\n                    if (getActivity() == null) {\r\n                        return;\r\n                    }\r\n\r\n                    parent.fireWebEvent(\"onStart\", new ActionEvent(url));\r\n                    super.onPageStarted(view, url, favicon);\r\n                    dismissProgress();\r\n                    //show the progress only if there is no ActionBar\r\n                    if(!hideProgress && !isNativeTitle()){\r\n                        progressBar = ProgressDialog.show(getActivity(), null, \"Loading...\");\r\n                        //if the page hasn't finished for more the 10 sec, dismiss\r\n                        //the dialog\r\n                        Timer t= new Timer();\r\n                        t.schedule(new TimerTask() {\r\n                            @Override\r\n                            public void run() {\r\n                                dismissProgress();\r\n                            }\r\n                        }, 10000);\r\n                    }\r\n                }\r\n\r\n                public void onPageFinished(WebView view, String url) {\r\n                    parent.fireWebEvent(\"onLoad\", new ActionEvent(url));\r\n                    super.onPageFinished(view, url);\r\n                    setShouldCalcPreferredSize(true);\r\n                    dismissProgress();\r\n                }\r\n\r\n                private void dismissProgress() {\r\n                    if (progressBar != null && progressBar.isShowing()) {\r\n                        progressBar.dismiss();\r\n                        Display.getInstance().callSerially(new Runnable() {\r\n\r\n                            public void run() {\r\n                                setVisible(true);\r\n                                repaint();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {\r\n                    parent.fireWebEvent(\"onError\", new ActionEvent(description, errorCode));\r\n                    super.onReceivedError(view, errorCode, description, failingUrl);\r\n                    super.shouldOverrideKeyEvent(view, null);\r\n                    dismissProgress();\r\n                }\r\n\r\n                public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {\r\n                    int keyCode = event.getKeyCode();\r\n                    if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {\r\n                        return true;\r\n                    }\r\n\r\n                    return super.shouldOverrideKeyEvent(view, event);\r\n                }\r\n\r\n                public boolean shouldOverrideUrlLoading(WebView view, String url) {\r\n                    if (url.startsWith(\"jar:\")) {\r\n                        setURL(url, null);\r\n                        return true;\r\n                    }\r\n\r\n                    // this will fail if dial permission isn't declared\r\n                    if(url.startsWith(\"tel:\")) {\r\n                        if(parent.fireBrowserNavigationCallbacks(url)) {\r\n                            try {\r\n                                Intent dialer = new Intent(android.content.Intent.ACTION_DIAL, Uri.parse(url));\r\n                                getContext().startActivity(dialer);\r\n                            } catch(Throwable t) {}\r\n                        }\r\n                        return true;\r\n                    }\r\n                    // this will fail if dial permission isn't declared\r\n                    if(url.startsWith(\"mailto:\")) {\r\n                        if(parent.fireBrowserNavigationCallbacks(url)) {\r\n                            try {\r\n                                Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(url));\r\n                                getContext().startActivity(emailIntent);\r\n                            } catch(Throwable t) {}\r\n                        }\r\n                        return true;\r\n                    }\r\n                    return !parent.fireBrowserNavigationCallbacks(url);\r\n                }\r\n\r\n\r\n            });\r\n\r\n            web.setWebChromeClient(new WebChromeClient(){\r\n                // For 3.0+ Devices (Start)\r\n                // onActivityResult attached before constructor\r\n                protected void openFileChooser(ValueCallback uploadMsg, String acceptType)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent i = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    i.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    i.setType(acceptType);\r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(i, \"File Browser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n\r\n                // For Lollipop 5.0+ Devices\r\n                public boolean onShowFileChooser(WebView mWebView, ValueCallback<Uri[]> filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)\r\n                {\r\n                    if (uploadMessage != null) {\r\n                        uploadMessage.onReceiveValue(null);\r\n                        uploadMessage = null;\r\n                    }\r\n\r\n                    uploadMessage = filePathCallback;\r\n\r\n                    Intent intent = fileChooserParams.createIntent();\r\n                    try\r\n                    {\r\n                        AndroidNativeUtil.getActivity().startActivityForResult(intent, REQUEST_SELECT_FILE);\r\n                    } catch (ActivityNotFoundException e)\r\n                    {\r\n                        uploadMessage = null;\r\n                        Toast.makeText(getActivity().getApplicationContext(), \"Cannot Open File Chooser\", Toast.LENGTH_LONG).show();\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                //For Android 4.1 only\r\n                protected void openFileChooser(ValueCallback<Uri> uploadMsg, String acceptType, String capture)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent intent = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    intent.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    intent.setType(acceptType);\r\n                    \r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(intent, \"File Browser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n                protected void openFileChooser(ValueCallback<Uri> uploadMsg)\r\n                {\r\n                    mUploadMessage = uploadMsg;\r\n                    Intent i = new Intent(Intent.ACTION_GET_CONTENT);\r\n                    i.addCategory(Intent.CATEGORY_OPENABLE);\r\n                    i.setType(\"image/*\");\r\n                    AndroidNativeUtil.getActivity().startActivityForResult(Intent.createChooser(i, \"File Chooser\"), FILECHOOSER_RESULTCODE);\r\n                }\r\n\r\n                \r\n                @Override\r\n                public boolean onConsoleMessage(ConsoleMessage consoleMessage) {\r\n                    com.codename1.io.Log.p(\"[\"+consoleMessage.messageLevel()+\"] \"+consoleMessage.message()+\" On line \"+consoleMessage.lineNumber()+\" of \"+consoleMessage.sourceId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public void onProgressChanged(WebView view, int newProgress) {\r\n                    parent.fireWebEvent(\"Progress\", new ActionEvent(parent, ActionEvent.Type.Progress, newProgress));\r\n                    if(!hideProgress && isNativeTitle() && getCurrentForm() != null && getCurrentForm().getTitle() != null && getCurrentForm().getTitle().length() > 0 ){\r\n                        if(getActivity() != null){\r\n                            try{\r\n                                getActivity().setProgressBarVisibility(true);\r\n                                getActivity().setProgress(newProgress * 100);\r\n                                if(newProgress == 100){\r\n                                    getActivity().setProgressBarVisibility(false);\r\n                                }\r\n                            }catch(Throwable t){\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onGeolocationPermissionsShowPrompt(String origin,\r\n                                                               GeolocationPermissions.Callback callback) {\r\n                    // Always grant permission since the app itself requires location\r\n                    // permission and the user has therefore already granted it\r\n                    callback.invoke(origin, true, false);\r\n                }\r\n\r\n                @Override\r\n                public void onPermissionRequest(final PermissionRequest request) {\r\n\r\n                    Log.d(\"Codename One\", \"onPermissionRequest\");\r\n                    getActivity().runOnUiThread(new Runnable() {\r\n                        @TargetApi(Build.VERSION_CODES.LOLLIPOP)\r\n                        @Override\r\n                        public void run() {\r\n                            String allowedOrigins = Display.getInstance().getProperty(\"android.WebView.grantPermissionsFrom\", null);\r\n                            if (allowedOrigins != null) {\r\n                                String[] origins = Util.split(allowedOrigins, \" \");\r\n                                boolean allowed = false;\r\n                                for (String origin : origins) {\r\n                                    if (request.getOrigin().toString().equals(origin)) {\r\n                                        allowed = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (allowed) {\r\n                                    Log.d(\"Codename One\", \"Allowing permission for \"+Arrays.toString(request.getResources())+\" in web view for origin \"+request.getOrigin());\r\n                                    request.grant(request.getResources());\r\n                                } else {\r\n                                    Log.d(\"Codename One\", \"Denying permission for \"+Arrays.toString(request.getResources())+\" in web view for origin \"+request.getOrigin());\r\n                                    request.deny();\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void initComponent() {\r\n            if(android.os.Build.VERSION.SDK_INT == 21 && web.getLayerType() != layerType){\r\n                act.runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        web.setLayerType(layerType, null); //setting layer type to original state\r\n                    }\r\n                });\r\n            }\r\n            super.initComponent();\r\n            blockNativeFocus(false);\r\n            setPeerImage(null);\r\n        }\r\n\r\n\r\n        @Override\r\n        protected Image generatePeerImage() {\r\n            try {\r\n                final Bitmap nativeBuffer = Bitmap.createBitmap(\r\n                        getWidth(), getHeight(), Bitmap.Config.ARGB_8888);\r\n                Image image = new AndroidImplementation.NativeImage(nativeBuffer);\r\n                getActivity().runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        try {\r\n                            Canvas canvas = new Canvas(nativeBuffer);\r\n                            web.draw(canvas);\r\n                        } catch(Throwable t) {\r\n                            t.printStackTrace();\r\n                        }\r\n                    }\r\n                });\r\n                return image;\r\n            } catch(Throwable t) {\r\n                t.printStackTrace();\r\n                return Image.createImage(5, 5);\r\n            }\r\n        }\r\n\r\n        protected boolean shouldRenderPeerImage() {\r\n            return lightweightMode || !isInitialized();\r\n        }\r\n\r\n        protected void setLightweightMode(boolean l) {\r\n            doSetVisibility(!l);\r\n            if (lightweightMode == l) {\r\n                return;\r\n            }\r\n            lightweightMode = l;\r\n        }\r\n\r\n\r\n\r\n        public void setScrollingEnabled(final boolean enabled){\r\n            this.scrollingEnabled = enabled;\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.setHorizontalScrollBarEnabled(enabled);\r\n                    web.setVerticalScrollBarEnabled(enabled);\r\n                    if ( !enabled ){\r\n                        web.setOnTouchListener(new View.OnTouchListener(){\r\n\r\n                            @Override\r\n                            public boolean onTouch(View view, MotionEvent me) {\r\n                                return (me.getAction() == MotionEvent.ACTION_MOVE);\r\n                            }\r\n\r\n                        });\r\n                    } else {\r\n                        web.setOnTouchListener(null);\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n\r\n        public boolean isScrollingEnabled(){\r\n            return scrollingEnabled;\r\n        }\r\n\r\n        public void setProperty(final String key, final Object value) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    WebSettings s = web.getSettings();\r\n                    if(key.equalsIgnoreCase(\"useragent\")) {\r\n                        s.setUserAgentString((String)value);\r\n                        return;\r\n                    }\r\n                    try {\r\n                        s.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\r\n                    } catch(Throwable t) {\r\n                        // the method isn't available in Android 4.x\r\n                    }\r\n                    String methodName = \"set\" + key;\r\n                    for (Method m : s.getClass().getMethods()) {\r\n                        if (m.getName().equalsIgnoreCase(methodName) && m.getParameterTypes().length == 1) {\r\n                            try {\r\n                                m.invoke(s, value);\r\n                            } catch (Exception ex) {\r\n                                ex.printStackTrace();\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public String getTitle() {\r\n            final String[] retVal = new String[1];\r\n            final boolean[] complete = new boolean[1];\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n\r\n                        retVal[0] = web.getTitle();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0];\r\n        }\r\n\r\n        public String getURL() {\r\n            final String[] retVal = new String[1];\r\n            final boolean[] complete = new boolean[1];\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.getUrl();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0];\r\n        }\r\n\r\n        public void setURL(final String url, final Map<String, String> headers) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    if(headers != null) {\r\n                        web.loadUrl(url, headers);\r\n                    } else {\r\n                        web.loadUrl(url);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public void reload() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.reload();\r\n                }\r\n            });\r\n        }\r\n\r\n        public boolean hasBack() {\r\n            final Boolean [] retVal = new Boolean[1];\r\n            final boolean[] complete = new boolean[1];\r\n\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.canGoBack();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0].booleanValue();\r\n        }\r\n\r\n        public boolean hasForward() {\r\n            final Boolean [] retVal = new Boolean[1];\r\n            final boolean[] complete = new boolean[1];\r\n\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        retVal[0] = web.canGoForward();\r\n                    } finally {\r\n                        complete[0] = true;\r\n                    }\r\n                }\r\n            });\r\n\r\n            while (!complete[0]) {\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (!complete[0]) {\r\n                            try {\r\n                                Thread.sleep(20);\r\n                            } catch (InterruptedException ex) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return retVal[0].booleanValue();\r\n        }\r\n\r\n        public void back() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.goBack();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void forward() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.goForward();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void clearHistory() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.clearHistory();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void stop() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.stopLoading();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void destroy() {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.destroy();\r\n                }\r\n            });\r\n        }\r\n\r\n        public void setPage(final String html, final String baseUrl) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.loadDataWithBaseURL(baseUrl, html, \"text/html\", \"UTF-8\", null);\r\n                }\r\n            });\r\n        }\r\n\r\n        public void exposeInJavaScript(final Object o, final String name) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.addJavascriptInterface(o, name);\r\n                }\r\n            });\r\n        }\r\n\r\n        public  void setPinchZoomEnabled(final boolean e) {\r\n            act.runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    web.getSettings().setSupportZoom(e);\r\n                    web.getSettings().setBuiltInZoomControls(e);\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        protected void deinitialize() {\r\n            act.runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    if(android.os.Build.VERSION.SDK_INT == 21) { // bugfix for Android 5.0.x\r\n                        web.setLayerType(View.LAYER_TYPE_SOFTWARE, null); //setting layer type to software to prevent the sigseg 11 crash\r\n                    }\r\n                }\r\n            });\r\n            super.deinitialize();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public Object connect(String url, boolean read, boolean write, int timeout) throws IOException {\r\n        URL u = new URL(url);\r\n        CookieHandler.setDefault(null);\r\n        URLConnection con = u.openConnection();\r\n        if (con instanceof HttpURLConnection) {\r\n            HttpURLConnection c = (HttpURLConnection) con;\r\n            c.setUseCaches(false);\r\n            c.setDefaultUseCaches(false);\r\n            c.setInstanceFollowRedirects(false);\r\n            if(timeout > -1) {\r\n                c.setConnectTimeout(timeout);\r\n            }\r\n\r\n            if (android.os.Build.VERSION.SDK_INT > 13) {\r\n                c.setRequestProperty(\"Connection\", \"close\");\r\n            }\r\n        }\r\n        con.setDoInput(read);\r\n        con.setDoOutput(write);\r\n        return con;\r\n    }\r\n    \r\n    @Override\r\n    public void setReadTimeout(Object connection, int readTimeout) {\r\n        if (connection instanceof URLConnection) {\r\n            ((URLConnection)connection).setReadTimeout(readTimeout);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    @Override\r\n    public boolean isReadTimeoutSupported() {\r\n        return true;\r\n    }\r\n    \r\n    @Override\r\n    public void setInsecure(Object connection, boolean insecure) {\r\n        if (insecure) {\r\n            if (connection instanceof HttpsURLConnection) {\r\n                HttpsURLConnection conn = (HttpsURLConnection)connection;\r\n                try {\r\n                    TrustModifier.relaxHostChecking(conn);\r\n                } catch (Exception ex) {\r\n                    com.codename1.io.Log.e(ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object connect(String url, boolean read, boolean write) throws IOException {\r\n        return connect(url, read, write, timeout);\r\n    }\r\n\r\n\r\n    private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\r\n\r\n    private static String dumpHex(byte[] data) {\r\n        final int n = data.length;\r\n        final StringBuilder sb = new StringBuilder(n * 3 - 1);\r\n        for (int i = 0; i < n; i++) {\r\n            if (i > 0) {\r\n                sb.append(' ');\r\n            }\r\n            sb.append(HEX_CHARS[(data[i] >> 4) & 0x0F]);\r\n            sb.append(HEX_CHARS[data[i] & 0x0F]);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    @Override\r\n    public String[] getSSLCertificates(Object connection, String url) throws IOException {\r\n        if (connection instanceof HttpsURLConnection) {\r\n            HttpsURLConnection conn = (HttpsURLConnection)connection;\r\n\r\n            try {\r\n                conn.connect();\r\n                java.security.cert.Certificate[] certs = conn.getServerCertificates();\r\n                String[] out = new String[certs.length * 2];\r\n                int i=0;\r\n                for (java.security.cert.Certificate cert : certs) {\r\n                    {\r\n                        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\r\n                        md.update(cert.getEncoded());\r\n                        out[i++] = \"SHA-256:\" + dumpHex(md.digest());\r\n                    }\r\n                    {\r\n                        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\r\n                        md.update(cert.getEncoded());\r\n                        out[i++] = \"SHA1:\" + dumpHex(md.digest());\r\n                    }\r\n\r\n                }\r\n                return out;\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        return new String[0];\r\n\r\n    }\r\n\r\n    @Override\r\n    public boolean canGetSSLCertificates() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHeader(Object connection, String key, String val) {\r\n        ((URLConnection) connection).setRequestProperty(key, val);\r\n    }\r\n\r\n    @Override\r\n    public void setChunkedStreamingMode(Object connection, int bufferLen){\r\n        HttpURLConnection con = ((HttpURLConnection) connection);\r\n        con.setChunkedStreamingMode(bufferLen);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openOutputStream(Object connection) throws IOException {\r\n        if (connection instanceof String) {\r\n            String con = (String)connection;\r\n            if (con.startsWith(\"file://\")) {\r\n                con = con.substring(7);\r\n            }\r\n\r\n            OutputStream fc = createFileOuputStream((String) con);\r\n            BufferedOutputStream o = new BufferedOutputStream(fc, (String) con);\r\n            return o;\r\n        }\r\n        return new BufferedOutputStream(((URLConnection) connection).getOutputStream(), connection.toString());\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openOutputStream(Object connection, int offset) throws IOException {\r\n        String con = (String) connection;\r\n        con = removeFilePrefix(con);\r\n        RandomAccessFile rf = new RandomAccessFile(con, \"rw\");\r\n        rf.seek(offset);\r\n        FileOutputStream fc = new FileOutputStream(rf.getFD());\r\n        BufferedOutputStream o = new BufferedOutputStream(fc, con);\r\n        o.setConnection(rf);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void cleanup(Object o) {\r\n        try {\r\n            super.cleanup(o);\r\n            if (o != null) {\r\n                if (o instanceof RandomAccessFile) {\r\n                    ((RandomAccessFile) o).close();\r\n                }\r\n            }\r\n        } catch (Throwable ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream openInputStream(Object connection) throws IOException {\r\n        if (connection instanceof String) {\r\n            String con = (String) connection;\r\n            if (con.startsWith(\"file://\")) {\r\n                con = con.substring(7);\r\n            }\r\n            InputStream fc = createFileInputStream(con);\r\n            BufferedInputStream o = new BufferedInputStream(fc, con);\r\n            return o;\r\n        }\r\n        if(connection instanceof HttpURLConnection) {\r\n            HttpURLConnection ht = (HttpURLConnection)connection;\r\n            if(ht.getResponseCode() < 400) {\r\n                return new BufferedInputStream(ht.getInputStream());\r\n            }\r\n            return new BufferedInputStream(ht.getErrorStream());\r\n        } else {\r\n            return new BufferedInputStream(((URLConnection) connection).getInputStream());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHttpMethod(Object connection, String method) throws IOException {\r\n        if(method.equalsIgnoreCase(\"patch\")) {\r\n            allowPatch((HttpURLConnection) connection);\r\n        }\r\n        ((HttpURLConnection) connection).setRequestMethod(method);\r\n    }\r\n\r\n    // the following block is based on a few suggestions in this stack overflow \r\n    // answer https://stackoverflow.com/questions/25163131/httpurlconnection-invalid-http-method-patch\r\n    private static boolean enabledPatch;\r\n    private static boolean patchFailed;\r\n    private static void allowPatch(HttpURLConnection connection) {\r\n        if(enabledPatch) {\r\n            return;\r\n        }\r\n        if(patchFailed) {\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n            return;\r\n        }\r\n        try {\r\n            Field methodsField = HttpURLConnection.class.getDeclaredField(\"methods\");\r\n\r\n            Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n            modifiersField.setAccessible(true);\r\n            modifiersField.setInt(methodsField, methodsField.getModifiers() & ~Modifier.FINAL);\r\n\r\n            methodsField.setAccessible(true);\r\n\r\n            String[] oldMethods = (String[]) methodsField.get(null);\r\n            Set<String> methodsSet = new LinkedHashSet<String>(Arrays.asList(oldMethods));\r\n            methodsSet.addAll(Arrays.asList(\"PATCH\"));\r\n            String[] newMethods = methodsSet.toArray(new String[0]);\r\n\r\n            methodsField.set(null/*static field*/, newMethods);\r\n            enabledPatch = true;\r\n        } catch (NoSuchFieldException e) {\r\n            patchFailed = true;\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n        } catch(IllegalAccessException ee) {\r\n            patchFailed = true;\r\n            connection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\r\n        }\r\n    }    \r\n    \r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setPostRequest(Object connection, boolean p) {\r\n        try {\r\n            if (p) {\r\n                ((HttpURLConnection) connection).setRequestMethod(\"POST\");\r\n            } else {\r\n                ((HttpURLConnection) connection).setRequestMethod(\"GET\");\r\n            }\r\n        } catch (IOException err) {\r\n            // an exception here doesn't make sense\r\n            err.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getResponseCode(Object connection) throws IOException {\r\n        // workaround for Android bug discussed here: http://stackoverflow.com/questions/17638398/androids-httpurlconnection-throws-eofexception-on-head-requests\r\n        HttpURLConnection con = (HttpURLConnection) connection;\r\n        if(\"head\".equalsIgnoreCase(con.getRequestMethod())) {\r\n            con.setDoOutput(false);\r\n            con.setRequestProperty( \"Accept-Encoding\", \"\" );\r\n        }\r\n        return ((HttpURLConnection) connection).getResponseCode();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getResponseMessage(Object connection) throws IOException {\r\n        return ((HttpURLConnection) connection).getResponseMessage();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getContentLength(Object connection) {\r\n        return ((HttpURLConnection) connection).getContentLength();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getHeaderField(String name, Object connection) throws IOException {\r\n        return ((HttpURLConnection) connection).getHeaderField(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getHeaderFieldNames(Object connection) throws IOException {\r\n        Set<String> s = ((HttpURLConnection) connection).getHeaderFields().keySet();\r\n        String[] resp = new String[s.size()];\r\n        s.toArray(resp);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getHeaderFields(String name, Object connection) throws IOException {\r\n        HttpURLConnection c = (HttpURLConnection) connection;\r\n        List<String> headers = new ArrayList<String>();\r\n\r\n        // we need to merge headers with differing case since this should be case insensitive\r\n        for(String key : c.getHeaderFields().keySet()) {\r\n            if(key != null && key.equalsIgnoreCase(name)) {\r\n                headers.addAll(c.getHeaderFields().get(key));\r\n            }\r\n        }\r\n        if (headers.size() > 0) {\r\n            List<String> v = new ArrayList<String>();\r\n            v.addAll(headers);\r\n            Collections.reverse(v);\r\n            String[] s = new String[v.size()];\r\n            v.toArray(s);\r\n            return s;\r\n        }\r\n        // workaround for a bug in some android devices\r\n        String f = c.getHeaderField(name);\r\n        if(f != null && f.length() > 0) {\r\n            return new String[] {f};\r\n        }\r\n        return null;\r\n\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void deleteStorageFile(String name) {\r\n        getContext().deleteFile(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream createStorageOutputStream(String name) throws IOException {\r\n        return getContext().openFileOutput(name, 0);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream createStorageInputStream(String name) throws IOException {\r\n        return getContext().openFileInput(name);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean storageFileExists(String name) {\r\n        String[] fileList = getContext().fileList();\r\n        for (int iter = 0; iter < fileList.length; iter++) {\r\n            if (fileList[iter].equals(name)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listStorageEntries() {\r\n        return getContext().fileList();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getStorageEntrySize(String name) {\r\n        return (int)new File(getContext().getFilesDir(), name).length();\r\n    }\r\n\r\n    private String addFile(String s) {\r\n        // I explicitly don't create a \"proper URL\" since code might rely on the fact that the file isn't encoded\r\n        if(s != null && s.startsWith(\"/\")) {\r\n            return \"file://\" + s;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listFilesystemRoots() {\r\n\r\n        if(!checkForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, \"This is required to browse the file system\")){\r\n            return new String[]{};\r\n        }\r\n\r\n        String [] storageDirs = getStorageDirectories();\r\n        if(storageDirs != null){\r\n            String [] roots = new String[storageDirs.length + 1];\r\n            System.arraycopy(storageDirs, 0, roots, 0, storageDirs.length);\r\n            roots[roots.length - 1] = addFile(Environment.getRootDirectory().getAbsolutePath());\r\n            return roots;\r\n        }\r\n        return new String[]{addFile(Environment.getRootDirectory().getAbsolutePath())};\r\n    }\r\n\r\n    @Override\r\n    public boolean hasCachesDir() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String getCachesDir() {\r\n        return getContext().getCacheDir().getAbsolutePath();\r\n    }\r\n\r\n\r\n\r\n    private String[] getStorageDirectories() {\r\n        String [] storageDirs = null;\r\n\r\n        String storageDev = Environment.getExternalStorageDirectory().getPath();\r\n        String storageRoot = storageDev.substring(0, storageDev.length() - 1);\r\n        BufferedReader bufReader = null;\r\n\r\n        try {\r\n            bufReader = new BufferedReader(new FileReader(\"/proc/mounts\"));\r\n            ArrayList<String> list = new ArrayList<String>();\r\n            String line;\r\n\r\n            while ((line = bufReader.readLine()) != null) {\r\n                if (line.contains(\"vfat\") || line.contains(\"/mnt\") || line.contains(\"/storage\")) {\r\n                    StringTokenizer tokens = new StringTokenizer(line, \" \");\r\n                    String s = tokens.nextToken();\r\n                    s = tokens.nextToken(); // Take the second token, i.e. mount point\r\n\r\n                    if (s.indexOf(\"secure\") != -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (s.startsWith(storageRoot) == true) {\r\n                        list.add(s);\r\n                        continue;\r\n                    }\r\n\r\n                    if (line.contains(\"vfat\") && line.contains(\"/mnt\")) {\r\n                        list.add(s);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            int count = list.size();\r\n\r\n            if (count < 2) {\r\n                storageDirs = new String[] {\r\n                        storageDev\r\n                };\r\n            }\r\n            else {\r\n                storageDirs = new String[count];\r\n\r\n                for (int i = 0; i < count; i++) {\r\n                    storageDirs[i] = (String) list.get(i);\r\n                }\r\n            }\r\n        }\r\n        catch (FileNotFoundException e) {}\r\n        catch (IOException e) {}\r\n        finally {\r\n            if (bufReader != null) {\r\n                try {\r\n                    bufReader.close();\r\n                }\r\n                catch (IOException e) {}\r\n            }\r\n\r\n            return storageDirs;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getAppHomePath() {\r\n        return addFile(getContext().getFilesDir().getAbsolutePath() + \"/\");\r\n    }\r\n\r\n    @Override\r\n    public String toNativePath(String path) {\r\n        return removeFilePrefix(path);\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] listFiles(String directory) throws IOException {\r\n        directory = removeFilePrefix(directory);\r\n        return new File(directory).list();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getRootSizeBytes(String root) {\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getRootAvailableSpace(String root) {\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void mkdir(String directory) {\r\n        directory = removeFilePrefix(directory);\r\n        new File(directory).mkdir();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void deleteFile(String file) {\r\n        file = removeFilePrefix(file);\r\n        File f = new File(file);\r\n        f.delete();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isHidden(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).isHidden();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setHidden(String file, boolean h) {\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getFileLength(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).length();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public long getFileLastModified(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).lastModified();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean isDirectory(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).isDirectory();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public char getFileSystemSeparator() {\r\n        return File.separatorChar;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public OutputStream openFileOutputStream(String file) throws IOException {\r\n        file = removeFilePrefix(file);\r\n        OutputStream os = null;\r\n        try{\r\n            os = createFileOuputStream(file);\r\n        }catch(FileNotFoundException fne){\r\n            //It is impossible to know if a path is considered an external\r\n            //storage on the various android's versions.\r\n            //So we try to open the path and if failed due to permission we will\r\n            //ask for the permission from the user\r\n            if(fne.getMessage().contains(\"Permission denied\")){\r\n\r\n                if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to access the file\")){\r\n                    //The user refused to give access.\r\n                    return null;\r\n                }else{\r\n                    //The user gave permission try again to access the path\r\n                    return createFileOuputStream(file);\r\n                }\r\n\r\n            }else{\r\n                throw fne;\r\n            }\r\n        }\r\n\r\n        return os;\r\n    }\r\n\r\n    private String removeFilePrefix(String file) {\r\n        if (file.contains(\"/files//storage/emulated/\")) {\r\n            // TODO: Find a better fix for issue https://github.com/codenameone/CodenameOne/issues/3204\r\n            // The gallery is returning files inside the directory /storage/emulated/0/DCIM/Camera/...\r\n            // The path is translated wrong because this path is not listed in any of the root\r\n            // paths of the file system.\r\n            // This issue is related to scoped storage. in API 29.\r\n            // https://stackoverflow.com/questions/56992682/android-9-api-29-storage-emulated-0-pictures-mypic-png-open-failed-eacces\r\n            // \r\n            // This hack works around the problem (and seems to fix it for my test device) by simply\r\n            // looking for this pattern in the path, and stripping everything before\r\n            // the /storage/emulated/...\r\n            // Not good.  Needs to be revisited. - SJH Sept 25, 2020\r\n            return file.substring(file.indexOf(\"/files//storage/emulated/\")+ 7);\r\n        }\r\n        if (file.startsWith(\"file://\")) {\r\n            return file.substring(7);\r\n        }\r\n        if (file.startsWith(\"file:/\")) {\r\n            return file.substring(5);\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public InputStream openFileInputStream(String file) throws IOException {\r\n        file = removeFilePrefix(file);\r\n        InputStream is = null;\r\n        try{\r\n            is = createFileInputStream(file);\r\n        }catch(FileNotFoundException fne){\r\n            //It is impossible to know if a path is considered an external\r\n            //storage on the various android's versions.\r\n            //So we try to open the path and if failed due to permission we will\r\n            //ask for the permission from the user\r\n            if(fne.getMessage().contains(\"Permission denied\")){\r\n\r\n                if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to access the file\")){\r\n                    //The user refused to give access.\r\n                    return null;\r\n                }else{\r\n                    //The user gave permission try again to access the path\r\n                    return openFileInputStream(file);\r\n                }\r\n\r\n            }else{\r\n                throw fne;\r\n            }\r\n        }\r\n\r\n        return is;\r\n    }\r\n\r\n    @Override\r\n    public boolean isMultiTouch() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean exists(String file) {\r\n        file = removeFilePrefix(file);\r\n        return new File(file).exists();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void rename(String file, String newName) {\r\n        file = removeFilePrefix(file);\r\n        new File(file).renameTo(new File(new File(file).getParentFile(), newName));\r\n    }\r\n\r\n    protected File createFileObject(String fileName) {\r\n        return new File(fileName);\r\n    }\r\n\r\n    protected InputStream createFileInputStream(String fileName) throws FileNotFoundException {\r\n        return new FileInputStream(removeFilePrefix(fileName));\r\n    }\r\n\r\n    protected InputStream createFileInputStream(File f) throws FileNotFoundException {\r\n        return new FileInputStream(f);\r\n    }\r\n\r\n    protected OutputStream createFileOuputStream(String fileName) throws FileNotFoundException {\r\n        return new FileOutputStream(removeFilePrefix(fileName));\r\n    }\r\n\r\n    protected OutputStream createFileOuputStream(java.io.File f) throws FileNotFoundException {\r\n        return new FileOutputStream(f);\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public boolean shouldWriteUTFAsGetBytes() {\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void closingOutput(OutputStream s) {\r\n        // For some reasons the Android guys chose not doing this by default:\r\n        // http://android-developers.blogspot.com/2010/12/saving-data-safely.html\r\n        // this seems to be a mistake of sacrificing stability for minor performance\r\n        // gains which will only be noticeable on a server.\r\n        if (s != null) {\r\n            if (s instanceof FileOutputStream) {\r\n                try {\r\n                    FileDescriptor fd = ((FileOutputStream) s).getFD();\r\n                    if (fd != null) {\r\n                        fd.sync();\r\n                    }\r\n                } catch (IOException ex) {\r\n                    // this exception doesn't help us\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void printStackTraceToStream(Throwable t, Writer o) {\r\n        PrintWriter p = new PrintWriter(o);\r\n        t.printStackTrace(p);\r\n    }\r\n\r\n    /**\r\n     * This method returns the platform Location Control\r\n     *\r\n     * @return LocationControl Object\r\n     */\r\n    public LocationManager getLocationManager() {\r\n        boolean permissionGranted = false;\r\n        if (Build.VERSION.SDK_INT >= 29  && \"true\".equals(Display.getInstance().getProperty(\"android.requiresBackgroundLocationPermissionForAPI29\", \"false\"))) {\r\n\r\n            if (checkForPermission(\"android.permission.ACCESS_BACKGROUND_LOCATION\", \"This is required to get the location\")) {\r\n                permissionGranted = true;\r\n            }\r\n\r\n        }\r\n        if (!permissionGranted && !checkForPermission( Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get the location\")) {\r\n            return null;\r\n        }\r\n\r\n\r\n        boolean includesPlayServices = Display.getInstance().getProperty(\"IncludeGPlayServices\", \"false\").equals(\"true\");\r\n        if (includesPlayServices && hasAndroidMarket()) {\r\n            try {\r\n                Class clazz = Class.forName(\"com.codename1.location.AndroidLocationPlayServiceManager\");\r\n                return (com.codename1.location.LocationManager)clazz.getMethod(\"getInstance\").invoke(null);\r\n            } catch (Exception e) {\r\n                return AndroidLocationManager.getInstance(getContext());\r\n            }\r\n        } else {\r\n            return AndroidLocationManager.getInstance(getContext());\r\n        }\r\n    }\r\n\r\n    private String fixAttachmentPath(String attachment) {\r\n        com.codename1.io.File cn1File = new com.codename1.io.File(attachment);\r\n        File mediaStorageDir = new File(new File(getContext().getCacheDir(), \"intent_files\"), \"Attachment\");\r\n\r\n        // Create the storage directory if it does not exist\r\n        if (!mediaStorageDir.exists()) {\r\n            if (!mediaStorageDir.mkdirs()) {\r\n                Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        File newFile = new File(mediaStorageDir.getPath() + File.separator\r\n                    + cn1File.getName());\r\n        if(newFile.exists()) {\r\n            // Create a media file name\r\n            String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\r\n            newFile = new File(mediaStorageDir.getPath() + File.separator\r\n                    + \"IMG_\" + timeStamp + \"_\" + cn1File.getName());\r\n        }\r\n\r\n\r\n        //Uri fileUri = Uri.fromFile(newFile);\r\n        newFile.getParentFile().mkdirs();\r\n        //Uri imageUri = Uri.fromFile(newFile);\r\n        Uri fileUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n\r\n        try {\r\n            InputStream is = FileSystemStorage.getInstance().openInputStream(attachment);\r\n            OutputStream os = new FileOutputStream(newFile);\r\n            byte [] buf = new byte[1024];\r\n            int len;\r\n            while((len = is.read(buf)) > -1){\r\n                os.write(buf, 0, len);\r\n            }\r\n            is.close();\r\n            os.close();\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n\r\n        return fileUri.toString();\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void sendMessage(String[] recipients, String subject, Message msg) {\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        Intent emailIntent;\r\n        String attachment = msg.getAttachment();\r\n        boolean hasAttachment = (attachment != null && attachment.length() > 0) || msg.getAttachments().size() > 0;\r\n\r\n        if(msg.getMimeType().equals(Message.MIME_TEXT) && !hasAttachment){\r\n            StringBuilder to = new StringBuilder();\r\n            for (int i = 0; i < recipients.length; i++) {\r\n                to.append(recipients[i]);\r\n                to.append(\";\");\r\n            }\r\n            emailIntent = new Intent(Intent.ACTION_SENDTO,\r\n                    Uri.parse(\r\n                            \"mailto:\" + to.toString()\r\n                                    + \"?subject=\" + Uri.encode(subject)\r\n                                    + \"&body=\" + Uri.encode(msg.getContent())));\r\n        }else{\r\n            if (hasAttachment) {\r\n                if(msg.getAttachments().size() > 1) {\r\n                    emailIntent = new Intent(android.content.Intent.ACTION_SEND_MULTIPLE);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                    emailIntent.setType(msg.getMimeType());\r\n                    ArrayList<Uri> uris = new ArrayList<Uri>();\r\n\r\n                    for(String path : msg.getAttachments().keySet()) {\r\n                        uris.add(Uri.parse(fixAttachmentPath(path)));\r\n                    }\r\n\r\n                    emailIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);\r\n                } else {\r\n                    emailIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                    emailIntent.setType(msg.getMimeType());\r\n                    emailIntent.setType(msg.getAttachmentMimeType());\r\n                    //if the attachment is in the uder home dir we need to copy it\r\n                    //to an accessible dir\r\n                    attachment = fixAttachmentPath(attachment);\r\n                    emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(attachment));\r\n                }\r\n            } else {\r\n                emailIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL, recipients);\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);\r\n                emailIntent.setType(msg.getMimeType());\r\n            }\r\n            if (msg.getMimeType().equals(Message.MIME_HTML)) {\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, Html.fromHtml(msg.getContent()));\r\n            }else{\r\n                /*\r\n                // Attempted this workaround to fix the ClassCastException that occurs on android when\r\n                // there are multiple attachments.  Unfortunately, this fixes the stack trace, but\r\n                // has the unwanted side-effect of producing a blank message body.\r\n                // Same workaround for HTML mimetype also fails the same way.\r\n                // Conclusion, Just live with the stack trace.  It doesn't seem to affect the\r\n                // execution of the program... treat it as a warning.\r\n                // See https://github.com/codenameone/CodenameOne/issues/1782\r\n                if (msg.getAttachments().size() > 1) {\r\n                    ArrayList<String> contentArr = new ArrayList<String>();\r\n                    contentArr.add(msg.getContent());\r\n                    emailIntent.putStringArrayListExtra(android.content.Intent.EXTRA_TEXT, contentArr);\r\n                } else {\r\n                    emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, msg.getContent());\r\n\r\n                }*/\r\n                emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, msg.getContent());\r\n            }\r\n\r\n        }\r\n        final String attach = attachment;\r\n        AndroidNativeUtil.startActivityForResult(Intent.createChooser(emailIntent, \"Send mail...\"), new IntentResultListener() {\r\n\r\n            @Override\r\n            public void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n                if(attach != null && attach.length() > 0 && attach.contains(\"tmp\")){\r\n                    FileSystemStorage.getInstance().delete(attach);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void dial(String phoneNumber) {\r\n        Intent dialer = new Intent(android.content.Intent.ACTION_DIAL, Uri.parse(\"tel:\" + phoneNumber));\r\n        getContext().startActivity(dialer);\r\n    }\r\n\r\n    @Override\r\n    public int getSMSSupport() {\r\n        if(canDial()) {\r\n            return Display.SMS_INTERACTIVE;\r\n        }\r\n        return Display.SMS_NOT_SUPPORTED;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void sendSMS(final String phoneNumber, final String message, boolean i) throws IOException {\r\n        /*if(!checkForPermission(Manifest.permission.SEND_SMS, \"This is required to send a SMS\")){\r\n            return;\r\n        }*/\r\n        if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to send a SMS\")){\r\n            return;\r\n        }\r\n        if(i) {\r\n            Intent smsIntent = null;\r\n            if(android.os.Build.VERSION.SDK_INT < 19){\r\n                smsIntent = new Intent(Intent.ACTION_VIEW);\r\n                smsIntent.setType(\"vnd.android-dir/mms-sms\");\r\n                smsIntent.putExtra(\"address\", phoneNumber);\r\n                smsIntent.putExtra(\"sms_body\",message);\r\n            }else{\r\n                smsIntent = new Intent(Intent.ACTION_SENDTO);\r\n                smsIntent.setData(Uri.parse(\"smsto:\" + Uri.encode(phoneNumber)));\r\n                smsIntent.putExtra(\"sms_body\", message);\r\n            }\r\n            getContext().startActivity(smsIntent);\r\n\r\n        } /*else {\r\n            SmsManager sms = SmsManager.getDefault();\r\n            ArrayList<String> parts = sms.divideMessage(message);\r\n            sms.sendMultipartTextMessage(phoneNumber, null, parts, null, null);\r\n        }*/\r\n    }\r\n\r\n    @Override\r\n    public void dismissNotification(Object o) {\r\n        NotificationManager notificationManager = (NotificationManager) getContext().getSystemService(Activity.NOTIFICATION_SERVICE);\r\n        if(o != null){\r\n            Integer n = (Integer)o;\r\n            notificationManager.cancel(\"CN1\", n.intValue());\r\n        }else{\r\n            notificationManager.cancelAll();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isNotificationSupported() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Keys of display properties that need to be made available to Services\r\n     * i.e. must be accessible even if CN1 is not initialized.\r\n     * \r\n     * This is accomplished by setting them inside init().  Then they\r\n     * are written to file so that they can be accessed inside a service\r\n     * like push notification service.\r\n     */\r\n    private static final String[] servicePropertyKeys = new String[]{\r\n        \"android.NotificationChannel.id\",\r\n        \"android.NotificationChannel.name\",\r\n        \"android.NotificationChannel.description\",\r\n        \"android.NotificationChannel.importance\",\r\n        \"android.NotificationChannel.enableLights\",\r\n        \"android.NotificationChannel.lightColor\",\r\n        \"android.NotificationChannel.enableVibration\",\r\n        \"android.NotificationChannel.vibrationPattern\",\r\n        \"android.NotoficationChannel.soundUri\"\r\n    };\r\n    \r\n    /**\r\n     * Flag to indicate if any of the service properties have been changed.\r\n     */\r\n    private static boolean servicePropertiesDirty() {\r\n        for (String key : servicePropertyKeys) {\r\n            if (Display.getInstance().getProperty(key, null) != null) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Stores properties that need to be accessible to services.   \r\n     * i.e. must be accessible even if CN1 is not initialized.\r\n     * \r\n     * This is accomplished by setting them inside init().  Then they\r\n     * are written to file so that they can be accessed inside a service\r\n     * like push notification service.\r\n     */\r\n    private static Map<String,String> serviceProperties;\r\n    \r\n    /**\r\n     * Gets the service properties.  Will read properties from file so that\r\n     * they are available even if CN1 is not initialized.\r\n     * @param a\r\n     * @return \r\n     */\r\n    public static Map<String,String> getServiceProperties(Context a) {\r\n        if (serviceProperties == null) {\r\n            InputStream i = null;\r\n            try {\r\n                serviceProperties = new HashMap<String,String>();\r\n                try {\r\n                    i = a.openFileInput(\"CN1$AndroidServiceProperties\");\r\n                } catch (FileNotFoundException notFoundEx){}\r\n                if(i == null) {\r\n                    return serviceProperties;\r\n                }\r\n                DataInputStream is = new DataInputStream(i);\r\n                int count = is.readInt();\r\n                for (int idx=0; idx<count; idx++) {\r\n                    String key = is.readUTF();\r\n                    String value = is.readUTF();\r\n                    serviceProperties.put(key, value);\r\n                }\r\n            } catch (IOException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } finally {\r\n                try {\r\n                    if (i != null) i.close();\r\n                } catch (Throwable ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n            }\r\n        }\r\n        return serviceProperties;\r\n    }\r\n    \r\n    public static void writeServiceProperties(Context a) {\r\n        if (servicePropertiesDirty()) {\r\n            Map<String,String> out = getServiceProperties(a);\r\n            \r\n            \r\n            for (String key : servicePropertyKeys) {\r\n                \r\n                String val = Display.getInstance().getProperty(key, null);\r\n                if (val != null) {\r\n                    out.put(key, val);\r\n                }\r\n                if (\"true\".equals(Display.getInstance().getProperty(key+\"#delete\", null))) {\r\n                    out.remove(key);\r\n                    \r\n                }\r\n            }\r\n            \r\n            OutputStream os = null;\r\n            try {\r\n                os = a.openFileOutput(\"CN1$AndroidServiceProperties\", 0);\r\n                if (os == null) {\r\n                    System.out.println(\"Failed to save service properties null output stream\");\r\n                    return;\r\n                }\r\n                DataOutputStream dos = new DataOutputStream(os);\r\n                dos.writeInt(out.size());\r\n                for (String key : out.keySet()) {\r\n                    dos.writeUTF(key);\r\n                    dos.writeUTF((String)out.get(key));\r\n                }\r\n                serviceProperties = null;\r\n            } catch (FileNotFoundException ex) {\r\n                System.out.println(\"Service properties file not found.  This is normal for the first run.   On subsequent runs, the file should exist.\");\r\n            } catch (IOException ex) {\r\n                \r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } finally {\r\n                try {\r\n                    if (os != null) os.close();\r\n                } catch (Throwable ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Gets a \"service\" display property.  This is a property that is available\r\n     * even if CN1 is not initialized.  They are written to file after init() so that \r\n     * they are available thereafter to services like push notification services.\r\n     * @param key THe key\r\n     * @param defaultValue The default value\r\n     * @param context Context\r\n     * @return The value.\r\n     */\r\n    public static String getServiceProperty(String key, String defaultValue, Context context) {\r\n        if (Display.isInitialized()) {\r\n            return Display.getInstance().getProperty(key, defaultValue);\r\n        }\r\n        String val = getServiceProperties(context).get(key);\r\n        return val == null ? defaultValue : val;\r\n    }\r\n    \r\n    /**\r\n     * Sets the notification channel on a notification builder.  Uses service properties to \r\n     * set properties of channel.\r\n     * @param nm The notification manager.\r\n     * @param mNotifyBuilder The notify builder\r\n     * @param context The context\r\n     * @since 7.0\r\n     */\r\n    public static void setNotificationChannel(NotificationManager nm, NotificationCompat.Builder mNotifyBuilder, Context context) {\r\n        setNotificationChannel(nm, mNotifyBuilder, context, (String)null);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Sets the notification channel on a notification builder.  Uses service properties to \r\n     * set properties of channel.\r\n     * @param nm The notification manager.\r\n     * @param mNotifyBuilder The notify builder\r\n     * @param context The context\r\n     * @param soundName The name of the sound to use for notifications on this channel.  E.g. mysound.mp3.  This feature is not yet implemented, but\r\n     *  parameter is added now to scaffold compatibility with build daemon until implementation is complete.\r\n     * @since 8.0\r\n     */\r\n    public static void setNotificationChannel(NotificationManager nm, NotificationCompat.Builder mNotifyBuilder, Context context, String soundName) {\r\n        if (android.os.Build.VERSION.SDK_INT >= 26) {\r\n            try {\r\n                NotificationManager mNotificationManager = nm;\r\n                              \r\n                String id = getServiceProperty(\"android.NotificationChannel.id\", \"cn1-channel\", context);\r\n                \r\n                CharSequence name = getServiceProperty(\"android.NotificationChannel.name\", \"Notifications\", context);\r\n                \r\n                String description = getServiceProperty(\"android.NotificationChannel.description\", \"Remote notifications\", context);\r\n                \r\n                // NotificationManager.IMPORTANCE_LOW = 2\r\n                // NotificationManager.IMPORTANCE_HIGH = 4  // <-- Minimum level to produce sound.\r\n                int importance = Integer.parseInt(getServiceProperty(\"android.NotificationChannel.importance\", \"4\", context));\r\n                    // Note: Currently we use a single notification channel for the app, but if the app uses different kinds of \r\n                    // push notifications, then this may not be sufficient.   E.g. The app may send both silent push notifications\r\n                    // and regular notifications - but their settings (e.g. sound) are all managed through one channel with\r\n                    // same settings. \r\n                    // TODO Add support for multiple channels.\r\n                    // See https://github.com/codenameone/CodenameOne/issues/2583\r\n                \r\n                Class clsNotificationChannel = Class.forName(\"android.app.NotificationChannel\");\r\n                //android.app.NotificationChannel mChannel = new android.app.NotificationChannel(id, name, importance);\r\n                Constructor constructor = clsNotificationChannel.getConstructor(java.lang.String.class, java.lang.CharSequence.class, int.class);\r\n                Object mChannel = constructor.newInstance(new Object[]{id, name, importance});\r\n                \r\n                Method method = clsNotificationChannel.getMethod(\"setDescription\", java.lang.String.class);\r\n                method.invoke(mChannel, new Object[]{description});\r\n                //mChannel.setDescription(description);\r\n                \r\n                method = clsNotificationChannel.getMethod(\"enableLights\", boolean.class);\r\n                method.invoke(mChannel, new Object[]{Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableLights\", \"true\", context))});\r\n                //mChannel.enableLights(Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableLights\", \"true\", context)));\r\n                \r\n                method = clsNotificationChannel.getMethod(\"setLightColor\", int.class);\r\n                method.invoke(mChannel, new Object[]{Integer.parseInt(getServiceProperty(\"android.NotificationChannel.lightColor\", \"\" + android.graphics.Color.RED, context))});\r\n                //mChannel.setLightColor(Integer.parseInt(getServiceProperty(\"android.NotificationChannel.lightColor\", \"\" + android.graphics.Color.RED, context)));\r\n                \r\n                method = clsNotificationChannel.getMethod(\"enableVibration\", boolean.class);\r\n                method.invoke(mChannel, new Object[]{Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableVibration\", \"false\", context))});\r\n                //mChannel.enableVibration(Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableVibration\", \"false\", context)));\r\n                String vibrationPatternStr = getServiceProperty(\"android.NotificationChannel.vibrationPattern\", null, context);\r\n                if (vibrationPatternStr != null) {\r\n                    String[] parts = vibrationPatternStr.split(\",\");\r\n                    int len = parts.length;\r\n                    long[] pattern = new long[len];\r\n                    for (int i = 0; i < len; i++) {\r\n                        pattern[i] = Long.parseLong(parts[i].trim());\r\n                    }\r\n                    method = clsNotificationChannel.getMethod(\"setVibrationPattern\", long[].class);\r\n                    method.invoke(mChannel, new Object[]{pattern});\r\n                    //mChannel.setVibrationPattern(pattern);\r\n                }\r\n                \r\n                String soundUri = getServiceProperty(\"android.NotificationChannel.soundUri\", null, context);\r\n                if (soundUri != null) {\r\n                    Uri uri= android.net.Uri.parse(soundUri);\r\n                    \r\n                    android.media.AudioAttributes audioAttributes = new android.media.AudioAttributes.Builder()\r\n                            .setContentType(android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION)\r\n                            .setUsage(android.media.AudioAttributes.USAGE_NOTIFICATION)\r\n                            .build();\r\n                    method = clsNotificationChannel.getMethod(\"setSound\", android.net.Uri.class, android.media.AudioAttributes.class);\r\n                    method.invoke(mChannel, new Object[]{uri, audioAttributes});\r\n                }\r\n                \r\n                method = NotificationManager.class.getMethod(\"createNotificationChannel\", clsNotificationChannel);\r\n                method.invoke(mNotificationManager, new Object[]{mChannel});\r\n                //mNotificationManager.createNotificationChannel(mChannel);\r\n                try {\r\n                    // For some reason I can't find the app-support-v4.jar for\r\n                    // API 26 that includes this method so that I can compile in netbeans.\r\n                    // So we use reflection...  If someone coming after can find a newer version\r\n                    // that has setChannelId(), please rip out this ugly reflection hack and\r\n                    // replace it with a proper call to mNotifyBuilder.setChannelId(id)\r\n                    mNotifyBuilder.getClass().getMethod(\"setChannelId\", new Class[]{String.class}).invoke(mNotifyBuilder, new Object[]{id});\r\n                } catch (Exception ex) {\r\n                    Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n                }\r\n                //mNotifyBuilder.setChannelId(id);\r\n            } catch (ClassNotFoundException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (NoSuchMethodException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (SecurityException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (IllegalAccessException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (IllegalArgumentException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (InvocationTargetException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            } catch (InstantiationException ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n            //mNotifyBuilder.setChannelId(id);\r\n        }\r\n\r\n    }\r\n    \r\n    public Object notifyStatusBar(String tickerText, String contentTitle,\r\n                                  String contentBody, boolean vibrate, boolean flashLights, Hashtable args) {\r\n        int id = getContext().getResources().getIdentifier(\"icon\", \"drawable\", getContext().getApplicationInfo().packageName);\r\n\r\n        NotificationManager notificationManager = (NotificationManager) getContext().getSystemService(Activity.NOTIFICATION_SERVICE);\r\n\r\n        Intent notificationIntent = new Intent();\r\n        notificationIntent.setComponent(activityComponentName);\r\n        PendingIntent contentIntent = createPendingIntent(getContext(), 0, notificationIntent);\r\n\r\n\r\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(getContext())\r\n                .setContentIntent(contentIntent)\r\n                .setSmallIcon(id)\r\n                .setContentTitle(contentTitle)\r\n                .setTicker(tickerText);\r\n        if(flashLights){\r\n            builder.setLights(0, 1000, 1000);\r\n        }\r\n        if(vibrate){\r\n            builder.setVibrate(new long[]{0, 100, 1000});\r\n        }\r\n        if(args != null) {\r\n            Boolean b = (Boolean)args.get(\"persist\");\r\n            if(b != null && b.booleanValue()) {\r\n                builder.setAutoCancel(false);\r\n                builder.setOngoing(true);\r\n            } else {\r\n                builder.setAutoCancel(false);\r\n            }\r\n        } else {\r\n            builder.setAutoCancel(true);\r\n        }\r\n        Notification notification = builder.build();\r\n        int notifyId = 10001;\r\n        notificationManager.notify(\"CN1\", notifyId, notification);\r\n        return new Integer(notifyId);\r\n    }\r\n\r\n    public boolean isContactsPermissionGranted() {\r\n        if (android.os.Build.VERSION.SDK_INT < 23) {\r\n            return true;\r\n        }\r\n\r\n        if (android.support.v4.content.ContextCompat.checkSelfPermission(getContext(),\r\n                Manifest.permission.READ_CONTACTS)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    @Override\r\n    public String[] getAllContacts(boolean withNumbers) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return new String[]{};\r\n        }\r\n        return AndroidContactsManager.getInstance().getContacts(getContext(), withNumbers);\r\n    }\r\n\r\n    @Override\r\n    public Contact getContactById(String id) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().getContact(getContext(), id);\r\n    }\r\n\r\n    @Override\r\n    public Contact getContactById(String id, boolean includesFullName, boolean includesPicture,\r\n                                  boolean includesNumbers, boolean includesEmail, boolean includeAddress){\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().getContact(getContext(), id, includesFullName, includesPicture,\r\n                includesNumbers, includesEmail, includeAddress);\r\n    }\r\n\r\n    @Override\r\n    public Contact[] getAllContacts(boolean withNumbers, boolean includesFullName, boolean includesPicture, boolean includesNumbers, boolean includesEmail, boolean includeAddress) {\r\n        if(!checkForPermission(Manifest.permission.READ_CONTACTS, \"This is required to get the contacts\")){\r\n            return new Contact[]{};\r\n        }\r\n        return AndroidContactsManager.getInstance().getAllContacts(getContext(), withNumbers, includesFullName, includesPicture, includesNumbers, includesEmail, includeAddress);\r\n    }\r\n\r\n    @Override\r\n    public boolean isGetAllContactsFast() {\r\n        return true;\r\n    }\r\n\r\n    public String createContact(String firstName, String surname, String officePhone, String homePhone, String cellPhone, String email) {\r\n        if(!checkForPermission(Manifest.permission.WRITE_CONTACTS, \"This is required to create a contact\")){\r\n            return null;\r\n        }\r\n        return AndroidContactsManager.getInstance().createContact(getContext(), firstName, surname, officePhone, homePhone, cellPhone, email);\r\n    }\r\n\r\n    public boolean deleteContact(String id) {\r\n        if(!checkForPermission(Manifest.permission.WRITE_CONTACTS, \"This is required to delete a contact\")){\r\n            return false;\r\n        }\r\n        return AndroidContactsManager.getInstance().deleteContact(getContext(), id);\r\n    }\r\n\r\n    @Override\r\n    public boolean isNativeShareSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void share(String text, String image, String mimeType, Rectangle sourceRect){\r\n        /*if(!checkForPermission(Manifest.permission.READ_PHONE_STATE, \"This is required to perform share\")){\r\n            return;\r\n        }*/\r\n        Intent shareIntent = new Intent(android.content.Intent.ACTION_SEND);\r\n        if(image == null){\r\n            shareIntent.setType(\"text/plain\");\r\n            shareIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);\r\n        }else{\r\n            shareIntent.setType(mimeType);\r\n            shareIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(fixAttachmentPath(image)));\r\n            shareIntent.putExtra(Intent.EXTRA_TEXT, text);\r\n        }\r\n        getContext().startActivity(Intent.createChooser(shareIntent, \"Share with...\"));\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String getPlatformName() {\r\n        return \"and\";\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getPlatformOverrides() {\r\n        if (isTablet()) {\r\n            return new String[]{\"tablet\", \"android\", \"android-tab\"};\r\n        } else {\r\n            return new String[]{\"phone\", \"android\", \"android-phone\"};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void copyToClipboard(final Object obj) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        getActivity().runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int sdk = android.os.Build.VERSION.SDK_INT;\r\n                if (sdk < 11) {\r\n                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    clipboard.setText(obj.toString());\r\n                } else {\r\n                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    android.content.ClipData clip = ClipData.newPlainText(\"Codename One\", obj.toString());\r\n                    clipboard.setPrimaryClip(clip);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public Object getPasteDataFromClipboard() {\r\n        if (getContext() == null) {\r\n            return null;\r\n        }\r\n        final Object[] response = new Object[1];\r\n        runOnUiThreadAndBlock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int sdk = android.os.Build.VERSION.SDK_INT;\r\n                if (sdk < 11) {\r\n                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    response[0] = clipboard.getText().toString();\r\n                } else {\r\n                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);\r\n                    ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);\r\n                    response[0] = item.getText();\r\n                }\r\n            }\r\n        });\r\n        return response[0];\r\n    }\r\n\r\n    public static MediaException createMediaException(int extra) {\r\n        MediaErrorType type;\r\n        String message;\r\n        switch (extra) {\r\n\r\n            case MediaPlayer.MEDIA_ERROR_IO:\r\n                type = MediaErrorType.Network;\r\n                message = \"IO error\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_MALFORMED:\r\n                type = MediaErrorType.Decode;\r\n                message = \"Media was malformed\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK:\r\n                type = MediaErrorType.SrcNotSupported;\r\n                message = \"Not valie for progressive playback\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\r\n                type = MediaErrorType.Network;\r\n                message = \"Server died\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_TIMED_OUT:\r\n                type = MediaErrorType.Network;\r\n                message = \"Timed out\";\r\n                break;\r\n\r\n            case MediaPlayer.MEDIA_ERROR_UNKNOWN:\r\n                type = MediaErrorType.Network;\r\n                message = \"Unknown error\";\r\n                break;\r\n            case MediaPlayer.MEDIA_ERROR_UNSUPPORTED:\r\n                type = MediaErrorType.SrcNotSupported;\r\n                message = \"Unsupported media\";\r\n                break;\r\n            default:\r\n                type = MediaErrorType.Network;\r\n                message = \"Unknown error\";\r\n        }\r\n        return new MediaException(type, message);\r\n    }\r\n\r\n\r\n    public class Video extends AndroidImplementation.AndroidPeer implements AsyncMedia {\r\n        \r\n        private VideoView nativeVideo;\r\n        private Activity activity;\r\n        private boolean fullScreen = false;\r\n        private Rectangle bounds;\r\n        private boolean nativeController = true;\r\n        private boolean nativePlayer;\r\n        private Form curentForm;\r\n        private List<Runnable> completionHandlers;\r\n        private final EventDispatcher errorListeners = new EventDispatcher();\r\n        \r\n        private final EventDispatcher stateChangeListeners = new EventDispatcher();\r\n        private PlayRequest pendingPlayRequest;\r\n        private PauseRequest pendingPauseRequest;\r\n\r\n        @Override\r\n        public State getState() {\r\n            if (isPlaying()) {\r\n                return State.Playing;\r\n            } else {\r\n                return State.Paused;\r\n            }\r\n        }\r\n        \r\n        protected void fireMediaStateChange(State newState) {\r\n            if (stateChangeListeners.hasListeners() && newState != getState()) {\r\n                stateChangeListeners.fireActionEvent(new MediaStateChangeEvent(this, getState(), newState));\r\n            }\r\n        }\r\n        \r\n        @Override\r\n        public void addMediaStateChangeListener(ActionListener<MediaStateChangeEvent> l) {\r\n            \r\n            stateChangeListeners.addListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void removeMediaStateChangeListener(ActionListener<MediaStateChangeEvent> l) {\r\n            \r\n            stateChangeListeners.removeListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void addMediaErrorListener(ActionListener<MediaErrorEvent> l) {\r\n            errorListeners.addListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public void removeMediaErrorListener(ActionListener<MediaErrorEvent> l) {\r\n            errorListeners.removeListener(l);\r\n        }\r\n        \r\n        @Override\r\n        public PlayRequest playAsync() {\r\n            final PlayRequest out = new PlayRequest();\r\n            out.ready(new SuccessCallback<AsyncMedia>() {\r\n                @Override\r\n                public void onSucess(AsyncMedia value) {\r\n                    if (out == pendingPlayRequest) {\r\n                        pendingPlayRequest = null;\r\n                    }\r\n                }\r\n            }).except(new SuccessCallback<Throwable>() {\r\n                @Override\r\n                public void onSucess(Throwable value) {\r\n                    if (out == pendingPlayRequest) {\r\n                        pendingPlayRequest = null;\r\n                    }\r\n                }\r\n            });\r\n            ;\r\n            if (pendingPlayRequest != null) {\r\n                pendingPlayRequest.ready(new SuccessCallback<AsyncMedia>() {\r\n                    @Override\r\n                    public void onSucess(AsyncMedia value) {\r\n                        if (!out.isDone()) {\r\n                            out.complete(value);\r\n                        }\r\n                    }\r\n                }).except(new SuccessCallback<Throwable>() {\r\n                    @Override\r\n                    public void onSucess(Throwable value) {\r\n                        if (!out.isDone()) {\r\n                            out.error(value);\r\n                        }\r\n                    }\r\n                });\r\n                return out;\r\n            } else {\r\n                pendingPlayRequest = out;\r\n            }\r\n            \r\n            ActionListener<MediaStateChangeEvent> onStateChange = new ActionListener<MediaStateChangeEvent>() {\r\n                @Override\r\n                public void actionPerformed(MediaStateChangeEvent evt) {\r\n                    stateChangeListeners.removeListener(this);\r\n                    if (!out.isDone()) {\r\n                        if (evt.getNewState() == State.Playing) {\r\n                            out.complete(Video.this);\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                \r\n            };\r\n            \r\n            stateChangeListeners.addListener(onStateChange);\r\n            play();\r\n            \r\n            return out;\r\n            \r\n        }\r\n        \r\n        @Override\r\n        public PauseRequest pauseAsync() {\r\n            final PauseRequest out = new PauseRequest();\r\n            out.ready(new SuccessCallback<AsyncMedia>() {\r\n                @Override\r\n                public void onSucess(AsyncMedia value) {\r\n                    if (out == pendingPauseRequest) {\r\n                        pendingPauseRequest = null;\r\n                    }\r\n                }\r\n            }).except(new SuccessCallback<Throwable>() {\r\n                @Override\r\n                public void onSucess(Throwable value) {\r\n                    if (out == pendingPauseRequest) {\r\n                        pendingPauseRequest = null;\r\n                    }\r\n                }\r\n            });\r\n            ;\r\n            if (pendingPauseRequest != null) {\r\n                pendingPauseRequest.ready(new SuccessCallback<AsyncMedia>() {\r\n                    @Override\r\n                    public void onSucess(AsyncMedia value) {\r\n                        if (!out.isDone()) {\r\n                            out.complete(value);\r\n                        }\r\n                    }\r\n                }).except(new SuccessCallback<Throwable>() {\r\n                    @Override\r\n                    public void onSucess(Throwable value) {\r\n                        if (!out.isDone()) {\r\n                            out.error(value);\r\n                        }\r\n                    }\r\n                });\r\n                return out;\r\n            } else {\r\n                pendingPauseRequest = out;\r\n            }\r\n            \r\n            ActionListener<MediaStateChangeEvent> onStateChange = new ActionListener<MediaStateChangeEvent>() {\r\n                @Override\r\n                public void actionPerformed(MediaStateChangeEvent evt) {\r\n                    stateChangeListeners.removeListener(this);\r\n                    if (!out.isDone()) {\r\n                        if (evt.getNewState() == State.Paused) {\r\n                            out.complete(Video.this);\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                \r\n            };\r\n            \r\n            stateChangeListeners.addListener(onStateChange);\r\n            play();\r\n            \r\n            return out;\r\n        }\r\n        \r\n\r\n        public Video(final VideoView nativeVideo, final Activity activity, final Runnable onCompletion) {\r\n            super(new RelativeLayout(activity));\r\n            this.nativeVideo = nativeVideo;\r\n            RelativeLayout rl = (RelativeLayout)getNativePeer();\r\n\r\n            rl.addView(nativeVideo);\r\n            RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams(getWidth(), getHeight());\r\n            layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n            layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n            rl.setLayoutParams(layout);\r\n            rl.requestLayout();\r\n\r\n            this.activity = activity;\r\n            if (nativeController) {\r\n                MediaController mc = new AndroidImplementation.CN1MediaController();\r\n                nativeVideo.setMediaController(mc);\r\n            }\r\n\r\n            nativeVideo.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {\r\n                @Override\r\n                public void onCompletion(MediaPlayer arg0) {\r\n                    fireMediaStateChange(State.Paused);\r\n                    \r\n                    fireCompletionHandlers();\r\n                }\r\n            });\r\n            if (onCompletion != null) {\r\n                addCompletionHandler(onCompletion);\r\n            }\r\n\r\n            nativeVideo.setOnErrorListener(new MediaPlayer.OnErrorListener() {\r\n                @Override\r\n                public boolean onError(MediaPlayer mp, int what, int extra) {\r\n                    com.codename1.io.Log.p(\"Media player error: \" + mp + \" what: \" + what + \" extra: \" + extra);\r\n                    errorListeners.fireActionEvent(new MediaErrorEvent(Video.this, createMediaException(extra)));\r\n                    fireMediaStateChange(State.Paused);\r\n                    fireCompletionHandlers();\r\n                    return true;\r\n                }\r\n            });\r\n\r\n        }\r\n        \r\n        \r\n        \r\n        private void fireCompletionHandlers() {\r\n            if (completionHandlers != null && !completionHandlers.isEmpty()) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    public void run() {\r\n                        if (completionHandlers != null && !completionHandlers.isEmpty()) {\r\n                            ArrayList<Runnable> toRun;\r\n                            synchronized(Video.this) {\r\n                                toRun = new ArrayList<Runnable>(completionHandlers);\r\n                            }\r\n                            for (Runnable r : toRun) {\r\n                                r.run();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        private void setNativeController(final boolean nativeController) {\r\n            if (nativeController != this.nativeController) {\r\n                this.nativeController = nativeController;\r\n                if (nativeVideo != null) {\r\n                    Activity activity = getActivity();\r\n                    if (activity != null) {\r\n                        activity.runOnUiThread(new Runnable() {\r\n\r\n                            @Override\r\n                            public void run() {\r\n                                if (nativeVideo != null) {\r\n                                    MediaController mc = new AndroidImplementation.CN1MediaController();\r\n                                    nativeVideo.setMediaController(mc);\r\n                                    if (!nativeController) mc.setVisibility(View.GONE);\r\n                                    else mc.setVisibility(View.VISIBLE);\r\n\r\n                                }\r\n                            }\r\n\r\n                        });\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void init() {\r\n            super.init();\r\n            setVisible(true);\r\n        }\r\n\r\n        public void prepare() {\r\n        }\r\n\r\n        @Override\r\n        public void play() {\r\n            Component cmp = getVideoComponent();\r\n            if (cmp.getParent() == null && nativePlayer && curentForm == null) {\r\n                curentForm = Display.getInstance().getCurrent();\r\n                Form f = new Form();\r\n                f.setBackCommand(new Command(\"\") {\r\n                    @Override\r\n                    public void actionPerformed(ActionEvent evt) {\r\n                        Component cmp = getVideoComponent();\r\n                        if(cmp != null) {\r\n                            cmp.remove();\r\n                            pause();\r\n                        }\r\n                        curentForm.showBack();\r\n                        curentForm = null;\r\n                    }\r\n                });\r\n                f.setLayout(new BorderLayout());\r\n\r\n                if(cmp.getParent() != null) {\r\n                    cmp.getParent().removeComponent(cmp);\r\n                }\r\n                f.addComponent(BorderLayout.CENTER, cmp);\r\n                f.show();\r\n            }\r\n            nativeVideo.start();\r\n            fireMediaStateChange(State.Playing);\r\n        }\r\n\r\n        @Override\r\n        public void pause() {\r\n            if(nativeVideo != null && nativeVideo.canPause()){\r\n                nativeVideo.pause();\r\n                fireMediaStateChange(State.Paused);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void cleanup() {\r\n            if(nativeVideo != null) {\r\n                nativeVideo.stopPlayback();\r\n                fireMediaStateChange(State.Paused);\r\n            }\r\n            nativeVideo = null;\r\n            if (nativePlayer && curentForm != null) {\r\n                curentForm.showBack();\r\n                curentForm = null;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public int getTime() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.getCurrentPosition();\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public void setTime(int time) {\r\n            if(nativeVideo != null){\r\n                nativeVideo.seekTo(time);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public int getDuration() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.getDuration();\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        @Override\r\n        public void setVolume(int vol) {\r\n            // float v = ((float) vol) / 100.0F;\r\n            AudioManager am = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);\r\n            int max = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC);\r\n            am.setStreamVolume(AudioManager.STREAM_MUSIC, vol, 0);\r\n        }\r\n\r\n        @Override\r\n        public int getVolume() {\r\n            AudioManager am = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);\r\n            return am.getStreamVolume(AudioManager.STREAM_MUSIC);\r\n        }\r\n\r\n        @Override\r\n        public boolean isVideo() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean isFullScreen() {\r\n            return fullScreen || nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public void setFullScreen(boolean fullScreen) {\r\n            this.fullScreen = fullScreen;\r\n            if (fullScreen) {\r\n                bounds = new Rectangle(getBounds());\r\n                setX(0);\r\n                setY(0);\r\n                setWidth(Display.getInstance().getDisplayWidth());\r\n                setHeight(Display.getInstance().getDisplayHeight());\r\n            } else {\r\n                if (bounds != null) {\r\n                    setX(bounds.getX());\r\n                    setY(bounds.getY());\r\n                    setWidth(bounds.getSize().getWidth());\r\n                    setHeight(bounds.getSize().getHeight());\r\n                }\r\n            }\r\n            repaint();\r\n        }\r\n\r\n        @Override\r\n        public Component getVideoComponent() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n        protected Dimension calcPreferredSize() {\r\n            if(nativeVideo != null){\r\n                return new Dimension(nativeVideo.getWidth(), nativeVideo.getHeight());\r\n            }\r\n            return new Dimension();\r\n        }\r\n\r\n        @Override\r\n        public void setWidth(final int width) {\r\n            super.setWidth(width);\r\n            final int currH = getHeight();\r\n            if(nativeVideo != null){\r\n                activity.runOnUiThread(new Runnable() {\r\n\r\n                    public void run() {\r\n                        float nh = nativeVideo.getHeight();\r\n                        float nw = nativeVideo.getWidth();\r\n                        float w = width;\r\n                        float h = currH;\r\n                        if (nh != 0 && nw != 0) {\r\n                            h = width * nh / nw;\r\n                            if (h > getHeight()) {\r\n                                h = getHeight();\r\n                                w = h * nw / nh;\r\n                            }\r\n                            if (w > getWidth()) {\r\n                                w = getWidth();\r\n                                h = w * nh / nw;\r\n                            }\r\n                        }\r\n                        RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams((int)w, (int)h);\r\n                        layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n                        layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n                        nativeVideo.setLayoutParams(layout);\r\n                        nativeVideo.requestLayout();\r\n                        nativeVideo.getHolder().setSizeFromLayout();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setHeight(final int height) {\r\n            super.setHeight(height);\r\n            final int currW = getWidth();\r\n            if(nativeVideo != null){\r\n                activity.runOnUiThread(new Runnable() {\r\n\r\n                    public void run() {\r\n                        float nh = nativeVideo.getHeight();\r\n                        float nw = nativeVideo.getWidth();\r\n                        float h = height;\r\n                        float w = currW;\r\n                        if (nh != 0 && nw != 0) {\r\n                            w = h * nw / nh;\r\n                            if (h > getHeight()) {\r\n                                h = getHeight();\r\n                                w = h * nw / nh;\r\n                            }\r\n                            if (w > getWidth()) {\r\n                                w = getWidth();\r\n                                h = w * nh / nw;\r\n                            }\r\n                        }\r\n                        RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams((int)w, (int)h);\r\n                        layout.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n                        layout.addRule(RelativeLayout.CENTER_VERTICAL);\r\n                        nativeVideo.setLayoutParams(layout);\r\n                        nativeVideo.requestLayout();\r\n                        nativeVideo.getHolder().setSizeFromLayout();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void setNativePlayerMode(boolean nativePlayer) {\r\n            this.nativePlayer = nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public boolean isNativePlayerMode() {\r\n            return nativePlayer;\r\n        }\r\n\r\n        @Override\r\n        public boolean isPlaying() {\r\n            if(nativeVideo != null){\r\n                return nativeVideo.isPlaying();\r\n            }\r\n            return false;\r\n        }\r\n\r\n        public void setVariable(String key, Object value) {\r\n            if (nativeVideo != null && Media.VARIABLE_NATIVE_CONTRLOLS_EMBEDDED.equals(key) && value instanceof Boolean) {\r\n                setNativeController((Boolean)value);\r\n            }\r\n        }\r\n\r\n        public Object getVariable(String key) {\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void addMediaCompletionHandler(Runnable onComplete) {\r\n            addCompletionHandler(onComplete);\r\n        }\r\n\r\n        \r\n        \r\n        private void addCompletionHandler(Runnable onCompletion) {\r\n            synchronized(this) {\r\n                if (completionHandlers == null) {\r\n                    completionHandlers = new ArrayList<Runnable>();\r\n                }\r\n                completionHandlers.add(onCompletion);\r\n            }\r\n        }\r\n        \r\n        private void removeCompletionHandler(Runnable onCompletion) {\r\n            synchronized(this) {\r\n                if (completionHandlers != null) {\r\n                    completionHandlers.remove(onCompletion);\r\n                }\r\n            }\r\n        }\r\n\r\n      \r\n    }\r\n\r\n\r\n    private String getImageFilePath(Uri uri) {\r\n\r\n        File file = new File(uri.getPath());\r\n        String scheme = uri.getScheme();\r\n        //String[] filePaths = file.getPath().split(\":\");\r\n        //String image_id = filePath[filePath.length - 1];\r\n        String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n        Cursor cursor = getContext().getContentResolver().query(\r\n                android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\r\n                new String[]{ MediaStore.Images.Media.DATA},\r\n                null,\r\n                null,\r\n                null\r\n        );\r\n        cursor.moveToFirst();\r\n        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n        String filePath = cursor.getString(columnIndex);\r\n        cursor.close();\r\n\r\n        if (filePath == null || \"content\".equals(scheme)) {\r\n            //if the file is not on the filesystem download it and save it\r\n            //locally\r\n            try {\r\n                InputStream inputStream = getContext().getContentResolver().openInputStream(uri);\r\n                if (inputStream != null) {\r\n                    String name = new File(uri.toString()).getName();//getContentName(getContext().getContentResolver(), uri);\r\n                    if (name != null) {\r\n                        String homePath = getAppHomePath();\r\n                        if (homePath.endsWith(\"/\")) {\r\n                            homePath = homePath.substring(0, homePath.length()-1);\r\n                        }\r\n                        filePath = homePath\r\n                                + getFileSystemSeparator() + name;\r\n                        File f = new File(removeFilePrefix(filePath));\r\n                        OutputStream tmp = createFileOuputStream(f);\r\n                        byte[] buffer = new byte[1024];\r\n                        int read = -1;\r\n                        while ((read = inputStream.read(buffer)) > -1) {\r\n                            tmp.write(buffer, 0, read);\r\n                        }\r\n                        tmp.close();\r\n                        inputStream.close();\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        //long len = new com.codename1.io.File(filePath).length();\r\n        return filePath;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    @Override\r\n    public void onActivityResult(int requestCode, int resultCode, Intent intent) {\r\n\r\n        if (requestCode == ZOOZ_PAYMENT) {\r\n            ((IntentResultListener) pur).onActivityResult(requestCode, resultCode, intent);\r\n            return;\r\n        }\r\n\r\n        if (requestCode == REQUEST_SELECT_FILE || requestCode == FILECHOOSER_RESULTCODE) {\r\n            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n                if (requestCode == REQUEST_SELECT_FILE) {\r\n                    if (uploadMessage == null) {\r\n                        return;\r\n                    }\r\n                    uploadMessage.onReceiveValue(WebChromeClient.FileChooserParams.parseResult(resultCode, intent));\r\n                    uploadMessage = null;\r\n                }\r\n            }\r\n            else if (requestCode == FILECHOOSER_RESULTCODE) {\r\n                if (null == mUploadMessage) {\r\n                    return;\r\n                }\r\n            // Use MainActivity.RESULT_OK if you're implementing WebView inside Fragment\r\n            // Use RESULT_OK only if you're implementing WebView inside an Activity\r\n                Uri result = intent == null || resultCode != Activity.RESULT_OK ? null : intent.getData();\r\n                mUploadMessage.onReceiveValue(result);\r\n                mUploadMessage = null;\r\n            }\r\n            else {\r\n\r\n                Toast.makeText(getActivity().getApplicationContext(), \"Failed to Upload File\", Toast.LENGTH_LONG).show();\r\n            }\r\n            return;\r\n        }\r\n\r\n        \r\n        if (resultCode == Activity.RESULT_OK) {\r\n            if (requestCode == CAPTURE_IMAGE) {\r\n                try {\r\n                    String imageUri = (String) Storage.getInstance().readObject(\"imageUri\");\r\n                    Vector pathandId = StringUtil.tokenizeString(imageUri, \";\");\r\n                    String path = (String)pathandId.get(0);\r\n                    String lastId = (String)pathandId.get(1);\r\n                    Storage.getInstance().deleteStorageFile(\"imageUri\");\r\n                    clearMediaDB(lastId, path);\r\n                    callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                    return;\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (requestCode == CAPTURE_VIDEO) {\r\n                String path = (String) Storage.getInstance().readObject(\"videoUri\");\r\n                Storage.getInstance().deleteStorageFile(\"videoUri\");\r\n                callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                return;\r\n            } else if (requestCode == CAPTURE_AUDIO) {\r\n                Uri data = intent.getData();\r\n                String path = convertImageUriToFilePath(data, getContext());\r\n                callback.fireActionEvent(new ActionEvent(addFile(path)));\r\n                return;\r\n                \r\n            } else if (requestCode == OPEN_GALLERY_MULTI) {\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\r\n                    if(intent.getClipData() != null){\r\n                        // If it was a multi-request\r\n                        ArrayList<String> selectedPaths = new ArrayList<String>();\r\n                        int count = intent.getClipData().getItemCount();\r\n                        for (int i=0; i<count; i++){\r\n\r\n                            Uri uri = intent.getClipData().getItemAt(i).getUri();\r\n                            String p = getImageFilePath(uri);\r\n                            if (p != null) {\r\n                                selectedPaths.add(p);\r\n                            }\r\n                        }\r\n                        callback.fireActionEvent(new ActionEvent(selectedPaths.toArray(new String[selectedPaths.size()])));\r\n                        return;\r\n                    }\r\n                } else {\r\n                    com.codename1.io.Log.e(new RuntimeException(\"OPEN_GALLERY_MULTI requires android sdk 16 (jelly bean) or higher\"));\r\n                    callback.fireActionEvent(null);\r\n                }\r\n\r\n                Uri selectedImage = intent.getData();\r\n                String scheme = intent.getScheme();\r\n\r\n                String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n                Cursor cursor = getContext().getContentResolver().query(selectedImage, filePathColumn, null, null, null);\r\n\r\n                // this happens on Android devices, not exactly sure what the use case is\r\n                if(cursor == null) {\r\n                    callback.fireActionEvent(null);\r\n                    return;\r\n                }\r\n\r\n                cursor.moveToFirst();\r\n                int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n                String filePath = cursor.getString(columnIndex);\r\n                cursor.close();\r\n                boolean fileExists = false;\r\n                if (filePath != null) {\r\n                    File file = new File(filePath);\r\n                    fileExists = file.exists() && file.canRead();\r\n                }\r\n\r\n                if (!fileExists && \"content\".equals(scheme)) {\r\n                    //if the file is not on the filesystem download it and save it\r\n                    //locally\r\n                    try {\r\n                        InputStream inputStream = getContext().getContentResolver().openInputStream(selectedImage);\r\n                        if (inputStream != null) {\r\n                            String name = getContentName(getContext().getContentResolver(), selectedImage);\r\n                            if (name != null) {\r\n                                filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                File f = new File(removeFilePrefix(filePath));\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = inputStream.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                inputStream.close();\r\n                            }\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n\r\n                callback.fireActionEvent(new ActionEvent(new String[]{filePath}));\r\n                return;\r\n            } else if (requestCode == OPEN_GALLERY) {\r\n                \r\n                Uri selectedImage = intent.getData();\r\n                String scheme = intent.getScheme();\r\n\r\n                String[] filePathColumn = {MediaStore.Images.Media.DATA};\r\n                Cursor cursor = getContext().getContentResolver().query(selectedImage, filePathColumn, null, null, null);\r\n\r\n                // this happens on Android devices, not exactly sure what the use case is\r\n                if(cursor == null) {\r\n                    callback.fireActionEvent(null);\r\n                    return;\r\n                }\r\n\r\n                cursor.moveToFirst();\r\n                int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\r\n                String filePath = cursor.getString(columnIndex);\r\n                cursor.close();\r\n                boolean fileExists = false;\r\n                if (filePath != null) {\r\n                    File file = new File(filePath);\r\n                    fileExists = file.exists() && file.canRead();\r\n                }\r\n\r\n                if (!fileExists && \"content\".equals(scheme)) {\r\n                    //if the file is not on the filesystem download it and save it\r\n                    //locally\r\n                    try {\r\n                        InputStream inputStream = getContext().getContentResolver().openInputStream(selectedImage);\r\n                        if (inputStream != null) {\r\n                            String name = getContentName(getContext().getContentResolver(), selectedImage);\r\n                            if (name != null) {\r\n                                filePath = getAppHomePath()\r\n                                        + getFileSystemSeparator() + name;\r\n                                File f = new File(removeFilePrefix(filePath));\r\n                                OutputStream tmp = createFileOuputStream(f);\r\n                                byte[] buffer = new byte[1024];\r\n                                int read = -1;\r\n                                while ((read = inputStream.read(buffer)) > -1) {\r\n                                    tmp.write(buffer, 0, read);\r\n                                }\r\n                                tmp.close();\r\n                                inputStream.close();\r\n                            }\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n\r\n                callback.fireActionEvent(new ActionEvent(filePath));\r\n                return;\r\n            } else {\r\n                if(callback != null) {\r\n                    callback.fireActionEvent(new ActionEvent(\"ok\"));\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        //clean imageUri\r\n        String imageUri = (String) Storage.getInstance().readObject(\"imageUri\");\r\n        if(imageUri != null){\r\n            Storage.getInstance().deleteStorageFile(\"imageUri\");\r\n        }\r\n\r\n        if(callback != null) {\r\n            callback.fireActionEvent(null);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void capturePhoto(ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot capture photo in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to take a picture\")){\r\n            return;\r\n        }\r\n        if (getRequestedPermissions().contains(Manifest.permission.CAMERA)) {\r\n            // Normally we don't need to request the CAMERA permission since we use\r\n            // the ACTION_IMAGE_CAPTURE intent, which handles permissions itself.\r\n            // BUT: If the camera permission is included in the Manifest file, the \r\n            // intent will defer to the app's permissions, and on Android 6, \r\n            // the permission is denied unless we do the runtime check for permission.\r\n            // See https://github.com/codenameone/CodenameOne/issues/2409#issuecomment-391696058\r\n            if(!checkForPermission(Manifest.permission.CAMERA, \"This is required to take a picture\")){\r\n                return;\r\n            }\r\n        }\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent intent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);\r\n\r\n        File newFile = getOutputMediaFile(false);\r\n        newFile.getParentFile().mkdirs();\r\n        newFile.getParentFile().setWritable(true, false);\r\n        //Uri imageUri = Uri.fromFile(newFile);\r\n        Uri imageUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, imageUri);\r\n\r\n        String lastImageID = getLastImageId();\r\n        Storage.getInstance().writeObject(\"imageUri\", newFile.getAbsolutePath() + \";\" + lastImageID);\r\n\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, imageUri);\r\n        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n        \r\n        if (Build.VERSION.SDK_INT < 21) {\r\n            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n            for (ResolveInfo resolveInfo : resInfoList) {\r\n                String packageName = resolveInfo.activityInfo.packageName;\r\n                getContext().grantUriPermission(packageName, imageUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n            }\r\n        }\r\n\r\n        getActivity().startActivityForResult(intent, CAPTURE_IMAGE);\r\n    }\r\n\r\n    @Override\r\n    public void captureVideo(ActionListener response) {\r\n        captureVideo(null, response);\r\n    }\r\n    \r\n    @Override\r\n    public void captureVideo(VideoCaptureConstraints cnst, ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot capture video in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to take a video\")){\r\n            return;\r\n        }\r\n        if (getRequestedPermissions().contains(Manifest.permission.CAMERA)) {\r\n            // Normally we don't need to request the CAMERA permission since we use\r\n            // the ACTION_VIDEO_CAPTURE intent, which handles permissions itself.\r\n            // BUT: If the camera permission is included in the Manifest file, the \r\n            // intent will defer to the app's permissions, and on Android 6, \r\n            // the permission is denied unless we do the runtime check for permission.\r\n            // See https://github.com/codenameone/CodenameOne/issues/2409#issuecomment-391696058\r\n            if(!checkForPermission(Manifest.permission.CAMERA, \"This is required to take a video\")){\r\n                return;\r\n            }\r\n        }\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent intent = new Intent(android.provider.MediaStore.ACTION_VIDEO_CAPTURE);\r\n        if (cnst != null) {\r\n            switch (cnst.getQuality()) {\r\n                case VideoCaptureConstraints.QUALITY_LOW:\r\n                    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0);\r\n                    break;\r\n                case VideoCaptureConstraints.QUALITY_HIGH:\r\n                    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);\r\n                    break;\r\n            }\r\n            \r\n            if (cnst.getMaxFileSize() > 0) {\r\n                intent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, cnst.getMaxFileSize());\r\n            }\r\n            if (cnst.getMaxLength() > 0) {\r\n                intent.putExtra(MediaStore.EXTRA_DURATION_LIMIT, cnst.getMaxLength());\r\n            }\r\n        }\r\n        \r\n\r\n        File newFile = getOutputMediaFile(true);\r\n        newFile.getParentFile().mkdirs();\r\n        newFile.getParentFile().setWritable(true, false);\r\n        Uri videoUri = FileProvider.getUriForFile(getContext(), getContext().getPackageName()+\".provider\", newFile);\r\n\r\n        Storage.getInstance().writeObject(\"videoUri\", newFile.getAbsolutePath());\r\n\r\n        intent.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, videoUri);\r\n        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n        if (Build.VERSION.SDK_INT < 21) {\r\n            List<ResolveInfo> resInfoList = getContext().getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\r\n            for (ResolveInfo resolveInfo : resInfoList) {\r\n                String packageName = resolveInfo.activityInfo.packageName;\r\n                getContext().grantUriPermission(packageName, videoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n            }\r\n        }\r\n        \r\n        this.getActivity().startActivityForResult(intent, CAPTURE_VIDEO);\r\n    }\r\n\r\n    public void captureAudio(final ActionListener response) {\r\n\r\n        if(!checkForPermission(Manifest.permission.RECORD_AUDIO, \"This is required to record the audio\")){\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            final Form current = Display.getInstance().getCurrent();\r\n\r\n            final File temp = File.createTempFile(\"mtmp\", \".3gpp\");\r\n            temp.deleteOnExit();\r\n\r\n            if (recorder != null) {\r\n                recorder.release();\r\n            }\r\n            recorder = new MediaRecorder();\r\n            recorder.setAudioSource(MediaRecorder.AudioSource.MIC);\r\n            recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\r\n            recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_WB);\r\n            recorder.setOutputFile(temp.getAbsolutePath());\r\n\r\n            final Form recording = new Form(\"Recording\");\r\n            recording.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n            recording.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n            recording.setLayout(new BorderLayout());\r\n\r\n            recorder.prepare();\r\n            recorder.start();\r\n\r\n            final Label time = new Label(\"00:00\");\r\n            time.getAllStyles().setAlignment(Component.CENTER);\r\n            Font f = Font.createSystemFont(Font.FACE_SYSTEM, Font.STYLE_PLAIN, Font.SIZE_LARGE);\r\n            f = f.derive(getDisplayHeight() / 10, Font.STYLE_PLAIN);\r\n            time.getAllStyles().setFont(f);\r\n            recording.addComponent(BorderLayout.CENTER, time);\r\n\r\n            recording.registerAnimated(new Animation() {\r\n\r\n                long current = System.currentTimeMillis();\r\n                long zero = current;\r\n                int sec = 0;\r\n\r\n                public boolean animate() {\r\n                    long now = System.currentTimeMillis();\r\n                    if (now - current > 1000) {\r\n                        current = now;\r\n                        sec++;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                public void paint(Graphics g) {\r\n                    int seconds = sec % 60;\r\n                    int minutes = sec / 60;\r\n\r\n                    String secStr = seconds < 10 ? \"0\" + seconds : \"\" + seconds;\r\n                    String minStr = minutes < 10 ? \"0\" + minutes : \"\" + minutes;\r\n\r\n                    String txt = minStr + \":\" + secStr;\r\n                    time.setText(txt);\r\n                }\r\n            });\r\n\r\n            Container south = new Container(new com.codename1.ui.layouts.GridLayout(1, 2));\r\n            Command cancel = new Command(\"Cancel\") {\r\n\r\n                @Override\r\n                public void actionPerformed(ActionEvent evt) {\r\n                    if (recorder != null) {\r\n                        recorder.stop();\r\n                        recorder.release();\r\n                        recorder = null;\r\n                    }\r\n                    current.showBack();\r\n                    response.actionPerformed(null);\r\n                }\r\n\r\n            };\r\n            recording.setBackCommand(cancel);\r\n            south.add(new com.codename1.ui.Button(cancel));\r\n            south.add(new com.codename1.ui.Button(new Command(\"Save\") {\r\n\r\n                @Override\r\n                public void actionPerformed(ActionEvent evt) {\r\n                    if (recorder != null) {\r\n                        recorder.stop();\r\n                        recorder.release();\r\n                        recorder = null;\r\n                    }\r\n                    current.showBack();\r\n                    response.actionPerformed(new ActionEvent(temp.getAbsolutePath()));\r\n                }\r\n\r\n            }));\r\n            recording.addComponent(BorderLayout.SOUTH, south);\r\n            recording.show();\r\n\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n            throw new RuntimeException(\"failed to start audio recording\");\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Opens the device image gallery\r\n     *\r\n     * @param response callback for the resulting image\r\n     *\r\n     * \r\n     * DISABLING:  openGallery() should take care of this\r\n    public void openImageGallery(ActionListener response) {\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot open image gallery in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to browse the photos\")){\r\n            return;\r\n        }\r\n\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n\r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent galleryIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.INTERNAL_CONTENT_URI);\r\n        this.getActivity().startActivityForResult(galleryIntent, OPEN_GALLERY);\r\n    }\r\n    * */\r\n\r\n    @Override\r\n    public boolean isGalleryTypeSupported(int type) {\r\n        if (super.isGalleryTypeSupported(type)) {\r\n            return true;\r\n        }\r\n        if (type == -9999 || type == -9998) {\r\n            return true;\r\n        }\r\n        if (android.os.Build.VERSION.SDK_INT >= 16) {\r\n            switch (type) {\r\n\r\n                case Display.GALLERY_ALL_MULTI:\r\n                case Display.GALLERY_VIDEO_MULTI:\r\n                case Display.GALLERY_IMAGE_MULTI:\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    \r\n    public void openGallery(final ActionListener response, int type){\r\n        if (!isGalleryTypeSupported(type)) {\r\n            throw new IllegalArgumentException(\"Gallery type \"+type+\" not supported on this platform.\");\r\n        }\r\n        if (getActivity() == null) {\r\n            throw new RuntimeException(\"Cannot open galery in background mode\");\r\n        }\r\n        if(!checkForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, \"This is required to browse the photos\")){\r\n            return;\r\n        }\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        final boolean multi;\r\n        switch (type) {\r\n            case Display.GALLERY_ALL_MULTI:\r\n                multi=true;\r\n                type = Display.GALLERY_ALL;\r\n                break;\r\n            case Display.GALLERY_VIDEO_MULTI:\r\n                multi=true;\r\n                type = Display.GALLERY_VIDEO;\r\n                break;\r\n            case Display.GALLERY_IMAGE_MULTI:\r\n                multi = true;\r\n                type = Display.GALLERY_IMAGE;\r\n                break;\r\n            case -9998:\r\n                multi = true;\r\n                type = -9999;\r\n                break;\r\n            default:\r\n                multi = false;\r\n        }\r\n        \r\n        callback = new EventDispatcher();\r\n        callback.addListener(response);\r\n        Intent galleryIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.INTERNAL_CONTENT_URI);\r\n        if (multi) {\r\n            galleryIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\r\n        }\r\n        if(type == Display.GALLERY_VIDEO){\r\n            galleryIntent.setType(\"video/*\");\r\n        }else if(type == Display.GALLERY_IMAGE){\r\n            galleryIntent.setType(\"image/*\");\r\n        }else if(type == Display.GALLERY_ALL){\r\n            galleryIntent.setType(\"image/* video/*\");\r\n        }else if (type == -9999) {\r\n            galleryIntent = new Intent();\r\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {\r\n                galleryIntent.setAction(Intent.ACTION_OPEN_DOCUMENT);\r\n            } else {\r\n                galleryIntent.setAction(Intent.ACTION_GET_CONTENT);\r\n            }\r\n            galleryIntent.addCategory(Intent.CATEGORY_OPENABLE);\r\n\r\n            // set MIME type for image\r\n            galleryIntent.setType(\"*/*\");\r\n            galleryIntent.putExtra(Intent.EXTRA_MIME_TYPES, Display.getInstance().getProperty(\"android.openGallery.accept\", \"*/*\").split(\",\"));\r\n        }else{\r\n            galleryIntent.setType(\"*/*\");\r\n        }\r\n        this.getActivity().startActivityForResult(galleryIntent, multi ? OPEN_GALLERY_MULTI: OPEN_GALLERY);\r\n    }\r\n\r\n    class NativeImage extends Image {\r\n\r\n        public NativeImage(Bitmap nativeImage) {\r\n            super(nativeImage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a File for saving an image or video\r\n     */\r\n    private File getOutputMediaFile(boolean isVideo) {\r\n        // To be safe, you should check that the SDCard is mounted\r\n        // using Environment.getExternalStorageState() before doing this.\r\n        if (getActivity() != null) {\r\n            return GetOutputMediaFile.getOutputMediaFile(isVideo, getActivity());\r\n        } else {\r\n            return GetOutputMediaFile.getOutputMediaFile(isVideo, getContext(), \"Video\");\r\n        }\r\n    }\r\n\r\n    private static class GetOutputMediaFile {\r\n\r\n        public static File getOutputMediaFile(boolean isVideo,Activity activity) {\r\n            activity.getComponentName();\r\n            return getOutputMediaFile(isVideo, activity, activity.getTitle());\r\n        }\r\n\r\n        public static File getOutputMediaFile(boolean isVideo, Context activity, CharSequence title) {\r\n\r\n\r\n            File mediaStorageDir = new File(new File(getContext().getCacheDir(), \"intent_files\"), \"\"+title);\r\n\r\n            // Create the storage directory if it does not exist\r\n            if (!mediaStorageDir.exists()) {\r\n                if (!mediaStorageDir.mkdirs()) {\r\n                    Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), \"failed to create directory\");\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Create a media file name\r\n            String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\r\n            File mediaFile = null;\r\n            if (!isVideo) {\r\n                mediaFile = new File(mediaStorageDir.getPath() + File.separator\r\n                        + \"IMG_\" + timeStamp + \".jpg\");\r\n            } else {\r\n                mediaFile = new File(mediaStorageDir.getPath() + File.separator\r\n                        + \"VID_\" + timeStamp + \".mp4\");\r\n            }\r\n\r\n            return mediaFile;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void systemOut(String content){\r\n        Log.d(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), content);\r\n    }\r\n\r\n    private boolean hasAndroidMarket() {\r\n        return hasAndroidMarket(getContext());\r\n    }\r\n\r\n    private static final String GooglePlayStorePackageNameOld = \"com.google.market\";\r\n    private static final String GooglePlayStorePackageNameNew = \"com.android.vending\";\r\n\r\n    /**\r\n     * Indicates whether this is a Google certified device which means that it\r\n     * has Android market etc.\r\n     */\r\n    public static boolean hasAndroidMarket(Context activity) {\r\n        final PackageManager packageManager = activity.getPackageManager();\r\n        List<PackageInfo> packages = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);\r\n        for (PackageInfo packageInfo : packages) {\r\n            if (packageInfo.packageName.equals(GooglePlayStorePackageNameOld) ||\r\n                    packageInfo.packageName.equals(GooglePlayStorePackageNameNew)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public void registerPush(Hashtable metaData, boolean noFallback) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        boolean has = hasAndroidMarket();\r\n        if (!has) {\r\n            Log.d(\"Codename One\", \"Device doesn't have Android market/google play can't register for push!\");\r\n            return;\r\n        }\r\n        String id = (String)metaData.get(com.codename1.push.Push.GOOGLE_PUSH_KEY);\r\n        if (id == null) {\r\n            id = Display.getInstance().getProperty(\"gcm.sender_id\", null);\r\n        }\r\n        if(has) {\r\n            Log.d(\"Codename One\", \"Sending async push request for id: \" + id);\r\n            ((CodenameOneActivity) getActivity()).registerForPush(id);\r\n        } else {\r\n            PushNotificationService.forceStartService(getActivity().getPackageName() + \".PushNotificationService\", getActivity());\r\n            if(!registerServerPush(id, getApplicationKey(), (byte)10, \"\", getPackageName())) {\r\n                sendPushRegistrationError(\"Server registration error\", 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void stopPollingLoop() {\r\n        stopPolling();\r\n    }\r\n\r\n    public static void registerPolling() {\r\n        registerPollingFallback();\r\n    }\r\n\r\n    @Override\r\n    public void deregisterPush() {\r\n        boolean has = hasAndroidMarket();\r\n        if (has) {\r\n            ((CodenameOneActivity) getActivity()).stopReceivingPush();\r\n            deregisterPushFromServer();\r\n        } else {\r\n            super.deregisterPush();\r\n        }\r\n    }\r\n\r\n    private static String convertImageUriToFilePath(Uri imageUri, Context activity) {\r\n        Cursor cursor = null;\r\n        String[] proj = {MediaStore.Images.Media.DATA};\r\n        cursor = activity.getContentResolver().query(imageUri, proj, null, null, null);\r\n        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);\r\n        cursor.moveToFirst();\r\n        String path = cursor.getString(column_index);\r\n        cursor.close();\r\n        return path;\r\n    }\r\n\r\n    class CN1MediaController extends MediaController {\r\n\r\n        public CN1MediaController() {\r\n            super(getActivity());\r\n        }\r\n\r\n        @Override\r\n        public boolean dispatchKeyEvent(KeyEvent event) {\r\n            int keycode = event.getKeyCode();\r\n            keycode = CodenameOneView.internalKeyCodeTranslate(keycode);\r\n            if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK) {\r\n                Display.getInstance().keyPressed(keycode);\r\n                Display.getInstance().keyReleased(keycode);\r\n                return true;\r\n            } else {\r\n                return super.dispatchKeyEvent(event);\r\n            }\r\n        }\r\n    }\r\n    private L10NManager l10n;\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public L10NManager getLocalizationManager() {\r\n        if (l10n == null) {\r\n            final Locale l = Locale.getDefault();\r\n            l10n = new L10NManager(l.getLanguage(), l.getCountry()) {\r\n                public double parseDouble(String localeFormattedDecimal) {\r\n                    try {\r\n                        return NumberFormat.getNumberInstance().parse(localeFormattedDecimal).doubleValue();\r\n                    } catch (ParseException err) {\r\n                        return Double.parseDouble(localeFormattedDecimal);\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public String getLongMonthName(Date date) {\r\n                    java.text.SimpleDateFormat fmt = new java.text.SimpleDateFormat(\"MMMM\", l);\r\n                    return fmt.format(date);\r\n                }\r\n\r\n                @Override\r\n                public String getShortMonthName(Date date) {\r\n                    java.text.SimpleDateFormat fmt = new java.text.SimpleDateFormat(\"MMM\", l);\r\n                    return fmt.format(date);\r\n                }\r\n                \r\n                \r\n\r\n                public String format(int number) {\r\n                    return NumberFormat.getNumberInstance().format(number);\r\n                }\r\n\r\n                public String format(double number) {\r\n                    return NumberFormat.getNumberInstance().format(number);\r\n                }\r\n\r\n                public String formatCurrency(double currency) {\r\n                    return NumberFormat.getCurrencyInstance().format(currency);\r\n                }\r\n\r\n                public String formatDateLongStyle(Date d) {\r\n                    return DateFormat.getDateInstance(DateFormat.LONG).format(d);\r\n                }\r\n\r\n                public String formatDateShortStyle(Date d) {\r\n                    return DateFormat.getDateInstance(DateFormat.SHORT).format(d);\r\n                }\r\n\r\n                public String formatDateTime(Date d) {\r\n                    return DateFormat.getDateTimeInstance().format(d);\r\n                }\r\n\r\n                public String formatDateTimeMedium(Date d) {\r\n                    DateFormat dd = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);\r\n                    return dd.format(d);\r\n                }\r\n\r\n                public String formatDateTimeShort(Date d) {\r\n                    DateFormat dd = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);\r\n                    return dd.format(d);\r\n                }\r\n\r\n                public String getCurrencySymbol() {\r\n                    return NumberFormat.getInstance().getCurrency().getSymbol();\r\n                }\r\n\r\n                public void setLocale(String locale, String language) {\r\n                    super.setLocale(locale, language);\r\n                    Locale l = new Locale(language, locale);\r\n                    Locale.setDefault(l);\r\n                }\r\n            };\r\n        }\r\n        return l10n;\r\n    }\r\n    private com.codename1.ui.util.ImageIO imIO;\r\n\r\n    @Override\r\n    public com.codename1.ui.util.ImageIO getImageIO() {\r\n        if (imIO == null) {\r\n            imIO = new com.codename1.ui.util.ImageIO() {\r\n                @Override\r\n                public Dimension getImageSize(String imageFilePath) throws IOException {\r\n                    BitmapFactory.Options o = new BitmapFactory.Options();\r\n                    o.inJustDecodeBounds = true;\r\n                    o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                    InputStream fis = createFileInputStream(imageFilePath);\r\n                    BitmapFactory.decodeStream(fis, null, o);\r\n                    fis.close();\r\n\r\n                    ExifInterface exif = new ExifInterface(removeFilePrefix(imageFilePath));\r\n\r\n                    // if the image is in portrait mode\r\n                    int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n                    if(orientation == ExifInterface.ORIENTATION_ROTATE_90 || orientation == ExifInterface.ORIENTATION_ROTATE_270) {\r\n                        return new Dimension(o.outHeight, o.outWidth);\r\n                    }\r\n                    return new Dimension(o.outWidth, o.outHeight);\r\n                }\r\n\r\n                private Dimension getImageSizeNoRotation(String imageFilePath) throws IOException {\r\n                    BitmapFactory.Options o = new BitmapFactory.Options();\r\n                    o.inJustDecodeBounds = true;\r\n                    o.inPreferredConfig = Bitmap.Config.ARGB_8888;\r\n\r\n                    InputStream fis = createFileInputStream(imageFilePath);\r\n                    BitmapFactory.decodeStream(fis, null, o);\r\n                    fis.close();\r\n\r\n                    return new Dimension(o.outWidth, o.outHeight);\r\n                }\r\n\r\n                @Override\r\n                public void save(InputStream image, OutputStream response, String format, int width, int height, float quality) throws IOException {\r\n                    Bitmap.CompressFormat f = Bitmap.CompressFormat.PNG;\r\n                    if (format == FORMAT_JPEG) {\r\n                        f = Bitmap.CompressFormat.JPEG;\r\n                    }\r\n                    Image img = Image.createImage(image).scaled(width, height);\r\n                    Bitmap b = (Bitmap) img.getImage();\r\n                    b.compress(f, (int) (quality * 100), response);\r\n                }\r\n\r\n                @Override\r\n                public String saveAndKeepAspect(String imageFilePath, String preferredOutputPath, String format, int width, int height, float quality, boolean onlyDownscale, boolean scaleToFill) throws IOException{\r\n                    ExifInterface exif = new ExifInterface(removeFilePrefix(imageFilePath));\r\n                    Dimension d = getImageSizeNoRotation(imageFilePath);\r\n                    if(onlyDownscale) {\r\n                        if(scaleToFill) {\r\n                            if(d.getHeight() <= height || d.getWidth() <= width) {\r\n                                return imageFilePath;\r\n                            }\r\n                        } else {\r\n                            if(d.getHeight() <= height && d.getWidth() <= width) {\r\n                                return imageFilePath;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    float ratio = ((float)d.getWidth()) / ((float)d.getHeight());\r\n                    int heightBasedOnWidth = (int)(((float)width) / ratio);\r\n                    int widthBasedOnHeight = (int)(((float)height) * ratio);\r\n                    if(scaleToFill) {\r\n                        if(heightBasedOnWidth >= width) {\r\n                            height = heightBasedOnWidth;\r\n                        } else {\r\n                            width = widthBasedOnHeight;\r\n                        }\r\n                    } else {\r\n                        if(heightBasedOnWidth > width) {\r\n                            width = widthBasedOnHeight;\r\n                        } else {\r\n                            height = heightBasedOnWidth;\r\n                        }\r\n                    }\r\n                    sampleSizeOverride = Math.max(d.getWidth()/width, d.getHeight()/height);\r\n                    OutputStream im = FileSystemStorage.getInstance().openOutputStream(preferredOutputPath);\r\n                    Image i = Image.createImage(imageFilePath);\r\n                    Image newImage = i.scaled(width, height);\r\n                    int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n\r\n                    int angle = 0;\r\n                    switch (orientation) {\r\n                        case ExifInterface.ORIENTATION_ROTATE_90:\r\n                            angle = 90;\r\n                            break;\r\n                        case ExifInterface.ORIENTATION_ROTATE_180:\r\n                            angle = 180;\r\n                            break;\r\n                        case ExifInterface.ORIENTATION_ROTATE_270:\r\n                            angle = 270;\r\n                            break;\r\n                    }\r\n                    if (angle != 0) {\r\n                        Matrix mat = new Matrix();\r\n                        mat.postRotate(angle);\r\n                        Bitmap b = (Bitmap)newImage.getImage();\r\n                        Bitmap correctBmp = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), mat, true);\r\n                        b.recycle();\r\n                        newImage.dispose();\r\n                        Image tmp = Image.createImage(correctBmp);\r\n                        newImage = tmp;\r\n                        save(tmp, im, format, quality);\r\n                    } else {\r\n                        save(imageFilePath, im, format, width, height, quality);\r\n                    }\r\n                    sampleSizeOverride =  -1;\r\n                    return preferredOutputPath;\r\n                }\r\n\r\n                @Override\r\n                public void save(String imageFilePath, OutputStream response, String format, int width, int height, float quality) throws IOException {\r\n                    Image i = Image.createImage(imageFilePath);\r\n                    Image newImage = i.scaled(width, height);\r\n                    save(newImage, response, format, quality);\r\n                    newImage.dispose();\r\n                    i.dispose();\r\n                }\r\n\r\n                @Override\r\n                protected void saveImage(Image img, OutputStream response, String format, float quality) throws IOException {\r\n                    Bitmap.CompressFormat f = Bitmap.CompressFormat.PNG;\r\n                    if (format == FORMAT_JPEG) {\r\n                        f = Bitmap.CompressFormat.JPEG;\r\n                    }\r\n                    Bitmap b = (Bitmap) img.getImage();\r\n                    b.compress(f, (int) (quality * 100), response);\r\n                }\r\n\r\n                @Override\r\n                public boolean isFormatSupported(String format) {\r\n                    return format == FORMAT_JPEG || format == FORMAT_PNG;\r\n                }\r\n            };\r\n        }\r\n        return imIO;\r\n    }\r\n\r\n    @Override\r\n    public Database openOrCreateDB(String databaseName) throws IOException {\r\n        SQLiteDatabase db;\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            db = SQLiteDatabase.openOrCreateDatabase(FileSystemStorage.getInstance().toNativePath(databaseName), null);\r\n        } else {\r\n            db = getContext().openOrCreateDatabase(databaseName, getContext().MODE_PRIVATE, null);\r\n        }\r\n        return new AndroidDB(db);\r\n    }\r\n\r\n    @Override\r\n    public boolean isDatabaseCustomPathSupported() {\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n    @Override\r\n    public void deleteDB(String databaseName) throws IOException {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            deleteFile(databaseName);\r\n            return;\r\n        }\r\n        getContext().deleteDatabase(databaseName);\r\n    }\r\n\r\n    @Override\r\n    public boolean existsDB(String databaseName) {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            return exists(databaseName);\r\n        }\r\n        File db = new File(getContext().getApplicationInfo().dataDir + \"/databases/\" + databaseName);\r\n        return db.exists();\r\n    }\r\n\r\n    public String getDatabasePath(String databaseName) {\r\n        if (databaseName.startsWith(\"file://\")) {\r\n            return databaseName;\r\n        }\r\n        File db = new File(getContext().getApplicationInfo().dataDir + \"/databases/\" + databaseName);\r\n        return db.getAbsolutePath();\r\n    }\r\n\r\n    public boolean isNativeTitle() {\r\n        if(com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n            return false;\r\n        }\r\n        Form f = getCurrentForm();\r\n        boolean nativeCommand;\r\n        if(f != null){\r\n            nativeCommand = f.getMenuBar().getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }else{\r\n            nativeCommand = getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE;\r\n        }\r\n        return hasActionBar() && nativeCommand;\r\n    }\r\n\r\n    public void refreshNativeTitle(){\r\n        if (getActivity() == null || com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n            return;\r\n        }\r\n        Form f = getCurrentForm();\r\n        if (f != null && isNativeTitle() &&  !(f instanceof Dialog)) {\r\n            getActivity().runOnUiThread(new SetCurrentFormImpl(getActivity(), f));\r\n        }\r\n    }\r\n\r\n    public void setCurrentForm(final Form f) {\r\n        if (getActivity() == null) {\r\n            return;\r\n        }\r\n        if(getCurrentForm() == null){\r\n            flushGraphics();\r\n        }\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        super.setCurrentForm(f);\r\n        if (isNativeTitle() &&  !(f instanceof Dialog)) {\r\n            getActivity().runOnUiThread(new SetCurrentFormImpl(getActivity(), f));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setNativeCommands(Vector commands) {\r\n        refreshNativeTitle();\r\n    }\r\n\r\n    @Override\r\n    public boolean isScreenLockSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void lockScreen(){\r\n        ((CodenameOneActivity)getContext()).lockScreen();\r\n    }\r\n\r\n    @Override\r\n    public void unlockScreen(){\r\n        ((CodenameOneActivity)getContext()).unlockScreen();\r\n    }\r\n\r\n    private static class SetCurrentFormImpl implements Runnable {\r\n        private Activity activity;\r\n        private Form f;\r\n\r\n        public SetCurrentFormImpl(Activity activity, Form f) {\r\n            this.activity = activity;\r\n            this.f = f;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            if(com.codename1.ui.Toolbar.isGlobalToolbar()) {\r\n                return;\r\n            }\r\n            ActionBar ab = activity.getActionBar();\r\n            String title = f.getTitle();\r\n            boolean hasMenuBtn = false;\r\n            if(android.os.Build.VERSION.SDK_INT >= 14){\r\n                try {\r\n                    ViewConfiguration vc = ViewConfiguration.get(activity);\r\n                    Method m = vc.getClass().getMethod(\"hasPermanentMenuKey\", (Class[])null);\r\n                    hasMenuBtn = ((Boolean)m.invoke(vc, (Object[])null)).booleanValue();\r\n                } catch(Throwable t) {\r\n                    t.printStackTrace();\r\n                }\r\n            }\r\n            if((title != null && title.length() > 0) || (f.getCommandCount() > 0 && !hasMenuBtn)){\r\n                activity.runOnUiThread(new NotifyActionBar(activity, true));\r\n            }else{\r\n                activity.runOnUiThread(new NotifyActionBar(activity, false));\r\n                return;\r\n            }\r\n\r\n            ab.setTitle(title);\r\n            ab.setDisplayHomeAsUpEnabled(f.getBackCommand() != null);\r\n            if(android.os.Build.VERSION.SDK_INT >= 14){\r\n                Image icon = f.getTitleComponent().getIcon();\r\n                try {\r\n                    if(icon != null){\r\n                        ab.getClass().getMethod(\"setIcon\", Drawable.class).invoke(ab, new BitmapDrawable(activity.getResources(), (Bitmap)icon.getImage()));\r\n                    }else{\r\n                        if(activity.getApplicationInfo().icon != 0){\r\n                            ab.getClass().getMethod(\"setIcon\", Integer.TYPE).invoke(ab, activity.getApplicationInfo().icon);\r\n                        }\r\n                    }\r\n                    activity.runOnUiThread(new InvalidateOptionsMenuImpl(activity));\r\n                } catch(Throwable t) {\r\n                    t.printStackTrace();\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    private Purchase pur;\r\n\r\n    @Override\r\n    public Purchase getInAppPurchase() {\r\n        try {\r\n            pur = ZoozPurchase.class.newInstance();\r\n            return pur;\r\n        } catch(Throwable t) {\r\n            return super.getInAppPurchase();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isTimeoutSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void setTimeout(int t) {\r\n        timeout = t;\r\n    }\r\n\r\n    @Override\r\n    public CodeScanner getCodeScanner() {\r\n        if(scannerInstance == null) {\r\n            scannerInstance = new CodeScannerImpl();\r\n        }\r\n        return scannerInstance;\r\n    }\r\n\r\n    public void addCookie(Cookie c, boolean addToWebViewCookieManager, boolean sync) {\r\n        if(addToWebViewCookieManager) {\r\n            CookieManager mgr;\r\n            CookieSyncManager syncer;\r\n            try {\r\n                syncer = CookieSyncManager.getInstance();\r\n                mgr = getCookieManager();\r\n            } catch(IllegalStateException ex) {\r\n                syncer = CookieSyncManager.createInstance(this.getContext());\r\n                mgr = getCookieManager();\r\n            }\r\n            java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(\"EEE, dd-MMM-yyyy HH:mm:ss z\");\r\n            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n            addCookie(c, mgr, format);\r\n            if(sync) {\r\n                syncer.sync();\r\n            }\r\n        }\r\n        super.addCookie(c);\r\n\r\n\r\n\r\n    }\r\n\r\n    private void addCookie(Cookie c, CookieManager mgr, java.text.SimpleDateFormat format) {\r\n\r\n        String d = c.getDomain();\r\n        String port = \"\";\r\n        if (d.contains(\":\")) {\r\n            // For some reason, the port must be stripped and stored separately\r\n            // or it won't retrieve it properly.\r\n            // https://github.com/codenameone/CodenameOne/issues/2804\r\n            port = \"; Port=\" + d.substring(d.indexOf(\":\")+1);\r\n            d = d.substring(0, d.indexOf(\":\"));\r\n        }\r\n        String cookieString = c.getName() + \"=\" + c.getValue() +\r\n                \"; Domain=\" + d +\r\n                port +\r\n                \"; Path=\" + c.getPath() +\r\n                \"; \" + (c.isSecure() ? \"Secure;\" : \"\")\r\n                + (c.getExpires() != 0 ? (\" Expires=\"+format.format(new Date(c.getExpires()))+\";\") : \"\")\r\n                + (c.isHttpOnly() ? \"httpOnly;\" : \"\");\r\n        String cookieUrl = \"http\" +\r\n                (c.isSecure() ? \"s\" : \"\") + \"://\" +\r\n                d +\r\n                c.getPath();\r\n        mgr.setCookie(cookieUrl, cookieString);\r\n    }\r\n\r\n    public void addCookie(Cookie[] cs, boolean addToWebViewCookieManager, boolean sync) {\r\n        if(addToWebViewCookieManager) {\r\n            CookieManager mgr;\r\n            CookieSyncManager syncer;\r\n            try {\r\n                syncer = CookieSyncManager.getInstance();\r\n                mgr = getCookieManager();\r\n            } catch(IllegalStateException ex) {\r\n                syncer = CookieSyncManager.createInstance(this.getContext());\r\n                mgr = getCookieManager();\r\n            }\r\n            java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(\"EEE, dd-MMM-yyyy HH:mm:ss z\");\r\n            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n\r\n            for (Cookie c : cs) {\r\n                addCookie(c, mgr, format);\r\n\r\n            }\r\n\r\n            if(sync) {\r\n                syncer.sync();\r\n            }\r\n        }\r\n        super.addCookie(cs);\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void addCookie(Cookie c) {\r\n        if(isUseNativeCookieStore()) {\r\n            this.addCookie(c, true, true);\r\n        } else {\r\n            super.addCookie(c);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void addCookie(Cookie[] cookiesArray) {\r\n        if(isUseNativeCookieStore()) {\r\n            this.addCookie(cookiesArray, true);\r\n        } else {\r\n            super.addCookie(cookiesArray);\r\n        }\r\n    }\r\n\r\n    public void addCookie(Cookie[] cookiesArray, boolean addToWebViewCookieManager){\r\n        addCookie(cookiesArray, addToWebViewCookieManager, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    class CodeScannerImpl extends CodeScanner implements IntentResultListener {\r\n        private ScanResult callback;\r\n\r\n        @Override\r\n        public void scanQRCode(ScanResult callback) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).setIntentResultListener(this);\r\n            }\r\n            this.callback = callback;\r\n            IntentIntegrator in = new IntentIntegrator(getActivity());\r\n            if(!in.initiateScan(IntentIntegrator.QR_CODE_TYPES, \"QR_CODE_MODE\")){\r\n                // restore old activity handling\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if(CodeScannerImpl.this != null && CodeScannerImpl.this.callback != null) {\r\n                            CodeScannerImpl.this.callback.scanError(-1, \"no scan app\");\r\n                            CodeScannerImpl.this.callback = null;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (getActivity() instanceof CodenameOneActivity) {\r\n                    ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void scanBarCode(ScanResult callback) {\r\n            if (getActivity() == null) {\r\n                return;\r\n            }\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).setIntentResultListener(this);\r\n            }\r\n            this.callback = callback;\r\n            IntentIntegrator in = new IntentIntegrator(getActivity());\r\n            Collection<String> types = IntentIntegrator.PRODUCT_CODE_TYPES;\r\n            if(Display.getInstance().getProperty(\"scanAllCodeTypes\", \"false\").equals(\"true\")) {\r\n                types = IntentIntegrator.ALL_CODE_TYPES;\r\n            }\r\n            if(Display.getInstance().getProperty(\"android.scanTypes\", null) != null) {\r\n                String[] arr = Display.getInstance().getProperty(\"android.scanTypes\", null).split(\";\");\r\n                types = Arrays.asList(arr);\r\n            }\r\n\r\n            if(!in.initiateScan(types, \"ONE_D_MODE\")){\r\n                // restore old activity handling\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        CodeScannerImpl.this.callback.scanError(-1, \"no scan app\");\r\n                        CodeScannerImpl.this.callback = null;\r\n                    }\r\n                });\r\n\r\n                if (getActivity() instanceof CodenameOneActivity) {\r\n                    ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n                }\r\n            }\r\n        }\r\n\r\n        public void onActivityResult(int requestCode, final int resultCode, Intent data) {\r\n            if (requestCode == IntentIntegrator.REQUEST_CODE && callback != null) {\r\n                final ScanResult sr = callback;\r\n                if (resultCode == Activity.RESULT_OK) {\r\n                    final String contents = data.getStringExtra(\"SCAN_RESULT\");\r\n                    final String formatName = data.getStringExtra(\"SCAN_RESULT_FORMAT\");\r\n                    final byte[] rawBytes = data.getByteArrayExtra(\"SCAN_RESULT_BYTES\");\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanCompleted(contents, formatName, rawBytes);\r\n                        }\r\n                    });\r\n                } else if(resultCode == Activity.RESULT_CANCELED) {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanCanceled();\r\n                        }\r\n                    });\r\n\r\n                } else {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            sr.scanError(resultCode, null);\r\n                        }\r\n                    });\r\n                }\r\n                callback = null;\r\n            }\r\n\r\n            // restore old activity handling\r\n            if (getActivity() instanceof CodenameOneActivity) {\r\n                ((CodenameOneActivity) getActivity()).restoreIntentResultListener();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean hasCamera() {\r\n        try {\r\n            int numCameras = Camera.getNumberOfCameras();\r\n            return numCameras > 0;\r\n        } catch(Throwable t) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public String getCurrentAccessPoint() {\r\n\r\n        ConnectivityManager cm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        NetworkInfo info = cm.getActiveNetworkInfo();\r\n        if (info == null) {\r\n            return null;\r\n        }\r\n        String apName = info.getTypeName() + \"_\" + info.getSubtypeName();\r\n        if (info.getExtraInfo() != null) {\r\n            apName += \"_\" + info.getExtraInfo();\r\n        }\r\n        return apName;\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public String[] getAPIds() {\r\n        if (apIds == null) {\r\n            apIds = new HashMap();\r\n            NetworkInfo[] aps = ((ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE)).getAllNetworkInfo();\r\n            for (int i = 0; i < aps.length; i++) {\r\n                String apName = aps[i].getTypeName() + \"_\" + aps[i].getSubtypeName();\r\n                if (aps[i].getExtraInfo() != null) {\r\n                    apName += \"_\" + aps[i].getExtraInfo();\r\n                }\r\n                apIds.put(apName, aps[i]);\r\n            }\r\n        }\r\n        if (apIds.isEmpty()) {\r\n            return null;\r\n        }\r\n        String[] ret = new String[apIds.size()];\r\n        Iterator iter = apIds.keySet().iterator();\r\n        for (int i = 0; iter.hasNext(); i++) {\r\n            ret[i] = iter.next().toString();\r\n        }\r\n        return ret;\r\n\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public int getAPType(String id) {\r\n        if (apIds == null) {\r\n            getAPIds();\r\n        }\r\n        NetworkInfo info = (NetworkInfo) apIds.get(id);\r\n        if (info == null) {\r\n            return NetworkManager.ACCESS_POINT_TYPE_UNKNOWN;\r\n        }\r\n        int type = info.getType();\r\n        int subType = info.getSubtype();\r\n        if (type == ConnectivityManager.TYPE_WIFI) {\r\n            return NetworkManager.ACCESS_POINT_TYPE_WLAN;\r\n        } else if (type == ConnectivityManager.TYPE_MOBILE) {\r\n            switch (subType) {\r\n                case TelephonyManager.NETWORK_TYPE_1xRTT:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 50-100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_CDMA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 14-64 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EDGE:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 50-100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_0:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 400-1000 kbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_A:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 600-1400 kbps\r\n                case TelephonyManager.NETWORK_TYPE_GPRS:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~ 100 kbps\r\n                case TelephonyManager.NETWORK_TYPE_HSDPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 2-14 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_HSPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 700-1700 kbps\r\n                case TelephonyManager.NETWORK_TYPE_HSUPA:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 1-23 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_UMTS:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 400-7000 kbps\r\n            /*\r\n                 * Above API level 7, make sure to set android:targetSdkVersion\r\n                 * to appropriate level to use these\r\n                 */\r\n                case TelephonyManager.NETWORK_TYPE_EHRPD: // API level 11\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 1-2 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_EVDO_B: // API level 9\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 5 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_HSPAP: // API level 13\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 10-20 Mbps\r\n                case TelephonyManager.NETWORK_TYPE_IDEN: // API level 8\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G; // ~25 kbps\r\n                case TelephonyManager.NETWORK_TYPE_LTE: // API level 11\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK3G; // ~ 10+ Mbps\r\n                // Unknown\r\n                case TelephonyManager.NETWORK_TYPE_UNKNOWN:\r\n                default:\r\n                    return NetworkManager.ACCESS_POINT_TYPE_NETWORK2G;\r\n            }\r\n        } else {\r\n            return NetworkManager.ACCESS_POINT_TYPE_UNKNOWN;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    public void setCurrentAccessPoint(String id) {\r\n\r\n        if (apIds == null) {\r\n            getAPIds();\r\n        }\r\n        NetworkInfo info = (NetworkInfo) apIds.get(id);\r\n        if (info == null || info.isConnectedOrConnecting()) {\r\n            return;\r\n\r\n        }\r\n        ConnectivityManager cm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);\r\n        cm.setNetworkPreference(info.getType());\r\n    }\r\n\r\n    private void scanMedia(File file) {\r\n        Uri uri = Uri.fromFile(file);\r\n        Intent scanFileIntent = new Intent(\r\n                Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);\r\n        getActivity().sendBroadcast(scanFileIntent);\r\n    }\r\n\r\n    /**\r\n     * Gets the last image id from the media store\r\n     *\r\n     * @return\r\n     */\r\n    private String getLastImageId() {\r\n        int idVal = 0;;\r\n        final String[] imageColumns = {MediaStore.Images.Media._ID};\r\n        final String imageOrderBy = MediaStore.Images.Media._ID + \" DESC\";\r\n        final String imageWhere = null;\r\n        final String[] imageArguments = null;\r\n        Cursor imageCursor = getContext().getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageColumns, imageWhere, imageArguments, imageOrderBy);\r\n        if (imageCursor.moveToFirst()) {\r\n            int id = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));\r\n            imageCursor.close();\r\n            idVal = id;\r\n        }\r\n        return \"\" + idVal;\r\n    }\r\n\r\n    private void clearMediaDB(String lastId, String capturePath) {\r\n        final String[] imageColumns = {MediaStore.Images.Media.DATA, MediaStore.Images.Media.DATE_TAKEN, MediaStore.Images.Media.SIZE, MediaStore.Images.Media._ID};\r\n        final String imageOrderBy = MediaStore.Images.Media._ID + \" DESC\";\r\n        final String imageWhere = MediaStore.Images.Media._ID + \">?\";\r\n        final String[] imageArguments = {lastId};\r\n        Cursor imageCursor = getContext().getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageColumns, imageWhere, imageArguments, imageOrderBy);\r\n        if (imageCursor.getCount() > 1) {\r\n            while (imageCursor.moveToNext()) {\r\n                int id = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));\r\n                String path = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DATA));\r\n                Long takenTimeStamp = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN));\r\n                Long size = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));\r\n                if (path.contentEquals(capturePath)) {\r\n                    // Remove it\r\n                    ContentResolver cr = getContext().getContentResolver();\r\n                    cr.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStore.Images.Media._ID + \"=?\", new String[]{Long.toString(id)});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        imageCursor.close();\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean isNativePickerTypeSupported(int pickerType) {\r\n        if(android.os.Build.VERSION.SDK_INT >= 11) {\r\n            return pickerType == Display.PICKER_TYPE_DATE || pickerType == Display.PICKER_TYPE_TIME || pickerType == Display.PICKER_TYPE_STRINGS;\r\n        }\r\n        return pickerType == Display.PICKER_TYPE_DATE || pickerType == Display.PICKER_TYPE_TIME;\r\n    }\r\n\r\n    @Override\r\n    public Object showNativePicker(final int type, final Component source, final Object currentValue, final Object data) {\r\n        if (getActivity() == null) {\r\n            return null;\r\n        }\r\n        final boolean [] canceled = new boolean[1];\r\n        final boolean [] dismissed = new boolean[1];\r\n\r\n        if(editInProgress()) {\r\n            stopEditing(true);\r\n        }\r\n        if(type == Display.PICKER_TYPE_TIME) {\r\n\r\n            class TimePick implements TimePickerDialog.OnTimeSetListener, TimePickerDialog.OnCancelListener, Runnable {\r\n                int result = ((Integer)currentValue).intValue();\r\n                public void onTimeSet(TimePicker tp, int hour, int minute) {\r\n                    result = hour * 60 + minute;\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onCancel(DialogInterface di) {\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized (this) {\r\n                        notify();\r\n                    }\r\n                }\r\n            }\r\n            final TimePick pickInstance = new TimePick();\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    int hour = ((Integer)currentValue).intValue() / 60;\r\n                    int minute = ((Integer)currentValue).intValue() % 60;\r\n                    TimePickerDialog tp = new TimePickerDialog(getActivity(), pickInstance, hour, minute, true){\r\n\r\n                        @Override\r\n                        public void cancel() {\r\n                            super.cancel();\r\n                            dismissed[0] = true;\r\n                            canceled[0] = true;\r\n                        }\r\n\r\n                        @Override\r\n                        public void dismiss() {\r\n                            super.dismiss();\r\n                            dismissed[0] = true;\r\n                        }\r\n\r\n                    };\r\n                    tp.setOnCancelListener(pickInstance);\r\n                    //DateFormat.is24HourFormat(activity));\r\n                    tp.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            if(canceled[0]) {\r\n                return null;\r\n            }\r\n            return new Integer(pickInstance.result);\r\n        }\r\n        if(type == Display.PICKER_TYPE_DATE) {\r\n            final java.util.Calendar cl = java.util.Calendar.getInstance();\r\n            if(currentValue != null) {\r\n                cl.setTime((Date)currentValue);\r\n            }\r\n            class DatePick implements DatePickerDialog.OnDateSetListener,DatePickerDialog.OnCancelListener, Runnable {\r\n                Date result = (Date)currentValue;\r\n\r\n                public void onDateSet(DatePicker dp, int year, int month, int day) {\r\n                    java.util.Calendar c = java.util.Calendar.getInstance();\r\n                    c.set(java.util.Calendar.YEAR, year);\r\n                    c.set(java.util.Calendar.MONTH, month);\r\n                    c.set(java.util.Calendar.DAY_OF_MONTH, day);\r\n                    result = c.getTime();\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                public void onCancel(DialogInterface di) {\r\n                    result = null;\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n            }\r\n            final DatePick pickInstance = new DatePick();\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    DatePickerDialog tp = new DatePickerDialog(getActivity(), pickInstance, cl.get(java.util.Calendar.YEAR), cl.get(java.util.Calendar.MONTH), cl.get(java.util.Calendar.DAY_OF_MONTH)){\r\n\r\n                        @Override\r\n                        public void cancel() {\r\n                            super.cancel();\r\n                            dismissed[0] = true;\r\n                            canceled[0] = true;\r\n                        }\r\n\r\n                        @Override\r\n                        public void dismiss() {\r\n                            super.dismiss();\r\n                            dismissed[0] = true;\r\n                        }\r\n\r\n                    };\r\n                    tp.setOnCancelListener(pickInstance);\r\n                    tp.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            return pickInstance.result;\r\n        }\r\n        if(type == Display.PICKER_TYPE_STRINGS) {\r\n            final String[] values = (String[])data;\r\n            class StringPick implements Runnable, NumberPicker.OnValueChangeListener {\r\n                int result = -1;\r\n\r\n                StringPick() {\r\n                }\r\n\r\n                public void run() {\r\n                    while(!dismissed[0]) {\r\n                        synchronized(this) {\r\n                            try {\r\n                                wait(50);\r\n                            } catch(InterruptedException er) {}\r\n                        }\r\n                    }\r\n                }\r\n\r\n                public void cancel() {\r\n                    dismissed[0] = true;\r\n                    canceled[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                public void ok() {\r\n                    canceled[0] = false;\r\n                    dismissed[0] = true;\r\n                    synchronized(this) {\r\n                        notify();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onValueChange(NumberPicker np, int oldVal, int newVal) {\r\n                    result = newVal;\r\n                }\r\n            }\r\n\r\n            final StringPick pickInstance = new StringPick();\r\n            for(int iter = 0 ; iter < values.length ; iter++) {\r\n                if(values[iter].equals(currentValue)) {\r\n                    pickInstance.result = iter;\r\n                    break;\r\n                }\r\n            }\r\n            if (pickInstance.result == -1 && values.length > 0) {\r\n                // The picker will default to showing the first element anyways\r\n                // If we don't set the result to 0, then the user has to first\r\n                // scroll to a different number, then back to the first option\r\n                // to pick the first option.\r\n                pickInstance.result = 0;\r\n            }\r\n\r\n            getActivity().runOnUiThread(new Runnable() {\r\n                public void run() {\r\n                    NumberPicker picker = new NumberPicker(getActivity());\r\n                    if(source.getClientProperty(\"showKeyboard\") == null) {\r\n                        picker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);\r\n                    }\r\n                    picker.setMinValue(0);\r\n                    picker.setMaxValue(values.length - 1);\r\n                    picker.setDisplayedValues(values);\r\n                    picker.setOnValueChangedListener(pickInstance);\r\n                    if(pickInstance.result > -1) {\r\n                        picker.setValue(pickInstance.result);\r\n                    }\r\n                    RelativeLayout linearLayout = new RelativeLayout(getActivity());\r\n                    RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(50, 50);\r\n                    RelativeLayout.LayoutParams numPicerParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n                    numPicerParams.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n\r\n                    linearLayout.setLayoutParams(params);\r\n                    linearLayout.addView(picker,numPicerParams);\r\n\r\n                    AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(getActivity());\r\n                    alertDialogBuilder.setView(linearLayout);\r\n                    alertDialogBuilder\r\n                            .setCancelable(false)\r\n                            .setPositiveButton(\"Ok\",\r\n                                    new DialogInterface.OnClickListener() {\r\n                                        public void onClick(DialogInterface dialog,\r\n                                                            int id) {\r\n                                            pickInstance.ok();\r\n                                        }\r\n                                    })\r\n                            .setNegativeButton(\"Cancel\",\r\n                                    new DialogInterface.OnClickListener() {\r\n                                        public void onClick(DialogInterface dialog,\r\n                                                            int id) {\r\n                                            dialog.cancel();\r\n                                            pickInstance.cancel();\r\n                                        }\r\n                                    });\r\n                    AlertDialog alertDialog = alertDialogBuilder.create();\r\n                    alertDialog.show();\r\n                }\r\n            });\r\n            Display.getInstance().invokeAndBlock(pickInstance);\r\n            if(canceled[0]) {\r\n                return null;\r\n            }\r\n            if(pickInstance.result < 0) {\r\n                return null;\r\n            }\r\n            return values[pickInstance.result];\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    private ServerSockets serverSockets;\r\n    private synchronized ServerSockets getServerSockets() {\r\n        if (serverSockets == null) {\r\n            serverSockets = new ServerSockets();\r\n        }\r\n        return serverSockets;\r\n    }\r\n    \r\n    class ServerSockets {\r\n        Map<Integer,ServerSocket> socks = new HashMap<Integer,ServerSocket>();\r\n        \r\n        public synchronized ServerSocket get(int port) throws IOException {\r\n            if (socks.containsKey(port)) {\r\n                ServerSocket sock = socks.get(port);\r\n                if (sock.isClosed()) {\r\n                    sock = new ServerSocket(port);\r\n                    socks.put(port, sock);\r\n                }\r\n                return sock;\r\n            } else {\r\n                ServerSocket sock = new ServerSocket(port);\r\n                socks.put(port, sock);\r\n                return sock;\r\n            }\r\n        }\r\n        \r\n        \r\n    }\r\n\r\n    class SocketImpl {\r\n        java.net.Socket socketInstance;\r\n        int errorCode = -1;\r\n        String errorMessage = null;\r\n        InputStream is;\r\n        OutputStream os;\r\n\r\n        public boolean connect(String param, int param1, int connectTimeout) {\r\n            try {\r\n                socketInstance = new java.net.Socket();\r\n                socketInstance.connect(new InetSocketAddress(param, param1), connectTimeout);\r\n                return true;\r\n            } catch(Exception err) {\r\n                err.printStackTrace();\r\n                errorMessage = err.toString();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        private InputStream getInput() throws IOException {\r\n            if(is == null) {\r\n                if(socketInstance != null) {\r\n                    is = socketInstance.getInputStream();\r\n                } else {\r\n\r\n                }\r\n            }\r\n            return is;\r\n        }\r\n\r\n        private OutputStream getOutput() throws IOException {\r\n            if(os == null) {\r\n                os = socketInstance.getOutputStream();\r\n            }\r\n            return os;\r\n        }\r\n\r\n        public int getAvailableInput() {\r\n            try {\r\n                return getInput().available();\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        public String getErrorMessage() {\r\n            return errorMessage;\r\n        }\r\n\r\n        public byte[] readFromStream() {\r\n            try {\r\n                int av = getAvailableInput();\r\n                if(av > 0) {\r\n                    byte[] arr = new byte[av];\r\n                    int size = getInput().read(arr);\r\n                    if(size == arr.length) {\r\n                        return arr;\r\n                    }\r\n                    return shrink(arr, size);\r\n                }\r\n                byte[] arr = new byte[8192];\r\n                int size = getInput().read(arr);\r\n                if(size == arr.length) {\r\n                    return arr;\r\n                }\r\n                return shrink(arr, size);\r\n            } catch(IOException err) {\r\n                err.printStackTrace();\r\n                errorMessage = err.toString();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        private byte[] shrink(byte[] arr, int size) {\r\n            if(size == -1) {\r\n                return null;\r\n            }\r\n            byte[] n = new byte[size];\r\n            System.arraycopy(arr, 0, n, 0, size);\r\n            return n;\r\n        }\r\n\r\n        public void writeToStream(byte[] param) {\r\n            try {\r\n                OutputStream os = getOutput();\r\n                os.write(param);\r\n                os.flush();\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n        }\r\n\r\n        public void disconnect() {\r\n            try {\r\n                if(socketInstance != null) {\r\n                    if(is != null) {\r\n                        try {\r\n                            is.close();\r\n                        } catch(IOException err) {}\r\n                    }\r\n                    if(os != null) {\r\n                        try {\r\n                            os.close();\r\n                        } catch(IOException err) {}\r\n                    }\r\n                    socketInstance.close();\r\n                    socketInstance = null;\r\n                }\r\n            } catch(IOException err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n            }\r\n        }\r\n\r\n        public Object listen(int param) {\r\n            try {\r\n                ServerSocket serverSocketInstance = getServerSockets().get(param);\r\n                socketInstance = serverSocketInstance.accept();\r\n                SocketImpl si = new SocketImpl();\r\n                si.socketInstance = socketInstance;\r\n                return si;\r\n            } catch(Exception err) {\r\n                errorMessage = err.toString();\r\n                err.printStackTrace();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public boolean isConnected() {\r\n            return socketInstance != null;\r\n        }\r\n\r\n        public int getErrorCode() {\r\n            return errorCode;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Object connectSocket(String host, int port) {\r\n        return connectSocket(host, port, 0);\r\n    }\r\n\r\n    \r\n    \r\n    @Override\r\n    public Object connectSocket(String host, int port, int connectTimeout) {\r\n        SocketImpl i = new SocketImpl();\r\n        if(i.connect(host, port, connectTimeout)) {\r\n            return i;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Object listenSocket(int port) {\r\n        return new SocketImpl().listen(port);\r\n    }\r\n\r\n    @Override\r\n    public String getHostOrIP() {\r\n        try {\r\n            InetAddress i = java.net.InetAddress.getLocalHost();\r\n            if(i.isLoopbackAddress()) {\r\n                Enumeration<NetworkInterface> nie = NetworkInterface.getNetworkInterfaces();\r\n                while(nie.hasMoreElements()) {\r\n                    NetworkInterface current = nie.nextElement();\r\n                    if(!current.isLoopback()) {\r\n                        Enumeration<InetAddress> iae = current.getInetAddresses();\r\n                        while(iae.hasMoreElements()) {\r\n                            InetAddress currentI = iae.nextElement();\r\n                            if(!currentI.isLoopbackAddress()) {\r\n                                return currentI.getHostAddress();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return i.getHostAddress();\r\n        } catch(Throwable t) {\r\n            com.codename1.io.Log.e(t);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void disconnectSocket(Object socket) {\r\n        ((SocketImpl)socket).disconnect();\r\n    }\r\n\r\n    @Override\r\n    public boolean isSocketConnected(Object socket) {\r\n        return ((SocketImpl)socket).isConnected();\r\n    }\r\n\r\n    \r\n\r\n    @Override\r\n    public boolean isServerSocketAvailable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isSocketAvailable() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String getSocketErrorMessage(Object socket) {\r\n        return ((SocketImpl)socket).getErrorMessage();\r\n    }\r\n\r\n    @Override\r\n    public int getSocketErrorCode(Object socket) {\r\n        return ((SocketImpl)socket).getErrorCode();\r\n    }\r\n\r\n    @Override\r\n    public int getSocketAvailableInput(Object socket) {\r\n        return ((SocketImpl)socket).getAvailableInput();\r\n    }\r\n\r\n    @Override\r\n    public byte[] readFromSocketStream(Object socket) {\r\n        return ((SocketImpl)socket).readFromStream();\r\n    }\r\n\r\n    @Override\r\n    public void writeToSocketStream(Object socket, byte[] data) {\r\n        ((SocketImpl)socket).writeToStream(data);\r\n    }\r\n\r\n    //Begin new Graphics Work\r\n    @Override\r\n    public boolean isShapeSupported(Object graphics) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isTransformSupported(Object graphics) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isPerspectiveTransformSupported(Object graphics){\r\n        return android.os.Build.VERSION.SDK_INT >= 14;\r\n    }\r\n\r\n    @Override\r\n    public void fillShape(Object graphics, com.codename1.ui.geom.Shape shape) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n        Path p = cn1ShapeToAndroidPath(shape);\r\n        ag.fillPath(p);\r\n    }\r\n\r\n    @Override\r\n    public void drawShape(Object graphics, com.codename1.ui.geom.Shape shape, com.codename1.ui.Stroke stroke) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n        Path p = cn1ShapeToAndroidPath(shape);\r\n        ag.drawPath(p, stroke);\r\n\r\n    }\r\n\r\n    @Override\r\n    public void drawShadow(Object graphics, Object image, int x, int y, int offsetX, int offsetY, int blurRadius, int spreadRadius, int color, float opacity) {\r\n        AndroidGraphics ag = (AndroidGraphics)graphics;\r\n\r\n        ag.drawShadow(image, x, y, offsetX, offsetY, blurRadius, spreadRadius, color, opacity);\r\n    }\r\n\r\n    @Override\r\n    public boolean isDrawShadowSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isDrawShadowFast() {\r\n        return false;\r\n    }\r\n    // BEGIN TRANSFORMATION METHODS---------------------------------------------------------\r\n\r\n\r\n\r\n    @Override\r\n    public boolean transformEqualsImpl(Transform t1, Transform t2) {\r\n        Object o1 = null;\r\n        if(t1 != null) {\r\n            o1 = t1.getNativeTransform();\r\n        }\r\n        Object o2 = null;\r\n        if(t2 != null) {\r\n            o2 = t2.getNativeTransform();\r\n        }\r\n        return transformNativeEqualsImpl(o1, o2);\r\n    }\r\n\r\n    @Override\r\n    public boolean transformNativeEqualsImpl(Object t1, Object t2) {\r\n        if ( t1 != null ){\r\n            CN1Matrix4f m1 = (CN1Matrix4f)t1;\r\n            CN1Matrix4f m2 = (CN1Matrix4f)t2;\r\n            return m1.equals(m2);\r\n        } else {\r\n            return t2 == null;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean isTransformSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isPerspectiveTransformSupported() {\r\n\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformAffine(double m00, double m10, double m01, double m11, double m02, double m12) {\r\n        CN1Matrix4f t = CN1Matrix4f.make(new float[]{\r\n                (float)m00, (float)m10, 0, 0,\r\n                (float)m01, (float)m11, 0, 0,\r\n                0, 0, 1, 0,\r\n                (float)m02, (float)m12, 0, 1\r\n        });\r\n        return t;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformAffine(Object nativeTransform, double m00, double m10, double m01, double m11, double m02, double m12) {\r\n        ((CN1Matrix4f)nativeTransform).setData(new float[]{\r\n                (float)m00, (float)m10, 0, 0,\r\n                (float)m01, (float)m11, 0, 0,\r\n                0, 0, 1, 0,\r\n                (float)m02, (float)m12, 0, 1\r\n        });\r\n    }\r\n    \r\n    \r\n    @Override\r\n    public Object makeTransformTranslation(float translateX, float translateY, float translateZ) {\r\n        return CN1Matrix4f.makeTranslation(translateX, translateY, translateZ);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformTranslation(Object nativeTransform, float translateX, float translateY, float translateZ) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        m.reset();\r\n        m.translate(translateX, translateY, translateZ);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformScale(float scaleX, float scaleY, float scaleZ) {\r\n        CN1Matrix4f t = CN1Matrix4f.makeIdentity();\r\n        t.scale(scaleX, scaleY, scaleZ);\r\n        return t;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformScale(Object nativeTransform, float scaleX, float scaleY, float scaleZ) {\r\n        CN1Matrix4f t = (CN1Matrix4f)nativeTransform;\r\n        t.reset();\r\n        t.scale(scaleX, scaleY, scaleZ);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformRotation(float angle, float x, float y, float z) {\r\n        return CN1Matrix4f.makeRotation(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformRotation(Object nativeTransform, float angle, float x, float y, float z) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        m.reset();\r\n        m.rotate(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformPerspective(float fovy, float aspect, float zNear, float zFar) {\r\n        return CN1Matrix4f.makePerspective(fovy, aspect, zNear, zFar);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformPerspective(Object nativeGraphics, float fovy, float aspect, float zNear, float zFar) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setPerspective(fovy, aspect, zNear, zFar);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformOrtho(float left, float right, float bottom, float top, float near, float far) {\r\n        return CN1Matrix4f.makeOrtho(left, right, bottom, top, near, far);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformOrtho(Object nativeGraphics, float left, float right, float bottom, float top, float near, float far) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setOrtho(left, right, bottom, top, near, far);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformCamera(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {\r\n        return CN1Matrix4f.makeCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);\r\n    }\r\n\r\n    @Override\r\n    public void setTransformCamera(Object nativeGraphics, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;\r\n        m.setCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void transformRotate(Object nativeTransform, float angle, float x, float y, float z) {\r\n        ((CN1Matrix4f)nativeTransform).rotate(angle, x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void transformTranslate(Object nativeTransform, float x, float y, float z) {\r\n        //((Matrix) nativeTransform).preTranslate(x, y);\r\n        ((CN1Matrix4f)nativeTransform).translate(x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public void transformScale(Object nativeTransform, float x, float y, float z) {\r\n        //((Matrix) nativeTransform).preScale(x, y);\r\n        ((CN1Matrix4f)nativeTransform).scale(x, y, z);\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformInverse(Object nativeTransform) {\r\n\r\n        CN1Matrix4f inverted = CN1Matrix4f.makeIdentity();\r\n        inverted.setData(((CN1Matrix4f)nativeTransform).getData());\r\n        if( inverted.invert()){\r\n            return inverted;\r\n        }\r\n        return null;\r\n\r\n        //Matrix inverted = new Matrix();\r\n        //if(((Matrix) nativeTransform).invert(inverted)){\r\n        //    return inverted;\r\n        //}\r\n        //return null;\r\n    }\r\n\r\n    @Override\r\n    public void setTransformInverse(Object nativeTransform) throws com.codename1.ui.Transform.NotInvertibleException {\r\n\r\n        CN1Matrix4f m = (CN1Matrix4f)nativeTransform;\r\n        if (!m.invert()) {\r\n            throw new com.codename1.ui.Transform.NotInvertibleException();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setTransformIdentity(Object transform) {\r\n        CN1Matrix4f m = (CN1Matrix4f)transform;\r\n        m.setIdentity();\r\n    }\r\n\r\n    @Override\r\n    public Object makeTransformIdentity() {\r\n        return CN1Matrix4f.makeIdentity();\r\n    }\r\n\r\n    @Override\r\n    public void copyTransform(Object src, Object dest) {\r\n        CN1Matrix4f t1 = (CN1Matrix4f) src;\r\n        CN1Matrix4f t2 = (CN1Matrix4f) dest;\r\n        t2.setData(t1.getData());\r\n    }\r\n\r\n    @Override\r\n    public void concatenateTransform(Object t1, Object t2) {\r\n        //((Matrix) t1).preConcat((Matrix) t2);\r\n        ((CN1Matrix4f)t1).concatenate((CN1Matrix4f)t2);\r\n    }\r\n\r\n    @Override\r\n    public void transformPoint(Object nativeTransform, float[] in, float[] out) {\r\n        //Matrix t = (Matrix) nativeTransform;\r\n        //t.mapPoints(in, 0, out, 0, 2);\r\n        ((CN1Matrix4f)nativeTransform).transformCoord(in, out);\r\n    }\r\n\r\n    @Override\r\n    public void setTransform(Object graphics, Transform transform) {\r\n        AndroidGraphics ag = (AndroidGraphics) graphics;\r\n        Transform existing = ag.getTransform();\r\n        if (existing == null) {\r\n            existing = transform == null ? Transform.makeIdentity() : transform.copy();\r\n            ag.setTransform(existing);\r\n        } else {\r\n            if (transform == null) {\r\n                existing.setIdentity();\r\n            } else {\r\n                existing.setTransform(transform);\r\n            }\r\n            ag.setTransform(existing); // sets dirty flag for transform\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public com.codename1.ui.Transform getTransform(Object graphics) {\r\n        com.codename1.ui.Transform t = ((AndroidGraphics) graphics).getTransform();\r\n        if (t == null) {\r\n            return Transform.makeIdentity();\r\n        }\r\n        Transform t2 = Transform.makeIdentity();\r\n        t2.setTransform(t);\r\n        return t2;\r\n    }\r\n\r\n    @Override\r\n    public void getTransform(Object graphics, Transform transform) {\r\n        com.codename1.ui.Transform t = ((AndroidGraphics) graphics).getTransform();\r\n        if (t == null) {\r\n            transform.setIdentity();\r\n        } else {\r\n            transform.setTransform(t);\r\n        }\r\n    }\r\n\r\n\r\n    // END TRANSFORM STUFF\r\n\r\n\r\n    static Path cn1ShapeToAndroidPath(com.codename1.ui.geom.Shape shape, Path p) {\r\n        //Path p = new Path();\r\n        p.rewind();\r\n        \r\n        com.codename1.ui.geom.PathIterator it = shape.getPathIterator();\r\n        switch (it.getWindingRule()) {\r\n            case GeneralPath.WIND_EVEN_ODD:\r\n                p.setFillType(Path.FillType.EVEN_ODD);\r\n                break;\r\n            case GeneralPath.WIND_NON_ZERO:\r\n                p.setFillType(Path.FillType.WINDING);\r\n                break;\r\n        }\r\n        //p.setWindingRule(it.getWindingRule() == com.codename1.ui.geom.PathIterator.WIND_EVEN_ODD ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO);\r\n        float[] buf = new float[6];\r\n        while (!it.isDone()) {\r\n            int type = it.currentSegment(buf);\r\n            switch (type) {\r\n                case com.codename1.ui.geom.PathIterator.SEG_MOVETO:\r\n                    p.moveTo(buf[0], buf[1]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_LINETO:\r\n                    p.lineTo(buf[0], buf[1]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_QUADTO:\r\n                    p.quadTo(buf[0], buf[1], buf[2], buf[3]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_CUBICTO:\r\n                    p.cubicTo(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\r\n                    break;\r\n                case com.codename1.ui.geom.PathIterator.SEG_CLOSE:\r\n                    p.close();\r\n                    break;\r\n\r\n            }\r\n            it.next();\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    static Path cn1ShapeToAndroidPath(com.codename1.ui.geom.Shape shape) {\r\n        return cn1ShapeToAndroidPath(shape, new Path());\r\n    }\r\n\r\n    /**\r\n     * The ID used for a local notification that should actually trigger a background\r\n     * fetch.  This type of notification is handled specially by the {@link LocalNotificationPublisher}.  It\r\n     * doesn't display a notification to the user, but instead just calls the {@link #performBackgroundFetch() }\r\n     * method.\r\n     */\r\n    static final String BACKGROUND_FETCH_NOTIFICATION_ID=\"$$$CN1_BACKGROUND_FETCH$$$\";\r\n\r\n\r\n    /**\r\n     * Calls the background fetch callback.  If the app is in teh background, this will\r\n     * check to see if the lifecycle class implements the {@link com.codename1.background.BackgroundFetch}\r\n     * interface.  If it does, it will execute its {@link com.codename1.background.BackgroundFetch#performBackgroundFetch(long, com.codename1.util.Callback) }\r\n     * method.\r\n     * @param blocking True if this should block until it is complete.\r\n     */\r\n    public static void performBackgroundFetch(boolean blocking) {\r\n\r\n        if (Display.getInstance().isMinimized()) {\r\n            // By definition, background fetch should only occur if the app is minimized.\r\n            // This keeps it consistent with the iOS implementation that doesn't have a \r\n            // choice\r\n            final boolean[] complete = new boolean[1];\r\n            final Object lock = new Object();\r\n            final BackgroundFetch bgFetchListener = instance.getBackgroundFetchListener();\r\n            final long timeout = System.currentTimeMillis()+25000;\r\n            if (bgFetchListener != null) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    public void run() {\r\n                        bgFetchListener.performBackgroundFetch(timeout, new Callback<Boolean>() {\r\n\r\n                            @Override\r\n                            public void onSucess(Boolean value) {\r\n                                // On Android the OS doesn't care whether it worked or not\r\n                                // So we'll just consume this.\r\n                                synchronized (lock) {\r\n                                    complete[0] = true;\r\n                                    lock.notify();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Object sender, Throwable err, int errorCode, String errorMessage) {\r\n                                com.codename1.io.Log.e(err);\r\n                                synchronized (lock) {\r\n                                    complete[0] = true;\r\n                                    lock.notify();\r\n                                }\r\n                            }\r\n\r\n                        });\r\n                    }\r\n                });\r\n\r\n            }\r\n\r\n            while (blocking && !complete[0]) {\r\n                synchronized(lock) {\r\n                    try {\r\n                        lock.wait(1000);\r\n                    } catch (Exception ex){}\r\n                }\r\n                if (!complete[0]) {\r\n                    System.out.println(\"Waiting for background fetch to complete.  Make sure your background fetch handler calls onSuccess() or onError() in the callback when complete\");\r\n\r\n                }\r\n                if (System.currentTimeMillis() > timeout) {\r\n                    System.out.println(\"Background fetch exceeded time alotted.  Not waiting for its completion\");\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the background fetch service.\r\n     */\r\n    public void startBackgroundFetchService() {\r\n        LocalNotification n = new LocalNotification();\r\n        n.setId(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n        cancelLocalNotification(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n        // We schedule a local notification\r\n        // First callback will be at the repeat interval\r\n        // We don't specify a repeat interval because the scheduleLocalNotification will \r\n        // set that for us using the getPreferredBackgroundFetchInterval method.\r\n        scheduleLocalNotification(n, System.currentTimeMillis() + getPreferredBackgroundFetchInterval() * 1000, 0);\r\n    }\r\n\r\n    public void stopBackgroundFetchService() {\r\n        cancelLocalNotification(BACKGROUND_FETCH_NOTIFICATION_ID);\r\n    }\r\n\r\n\r\n    private boolean backgroundFetchInitialized;\r\n\r\n    @Override\r\n    public void setPreferredBackgroundFetchInterval(int seconds) {\r\n        int oldInterval = getPreferredBackgroundFetchInterval();\r\n        super.setPreferredBackgroundFetchInterval(seconds);\r\n\r\n        if (!backgroundFetchInitialized || oldInterval != seconds) {\r\n            backgroundFetchInitialized = true;\r\n            if (seconds > 0) {\r\n                startBackgroundFetchService();\r\n            } else {\r\n                stopBackgroundFetchService();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public boolean isBackgroundFetchSupported() {\r\n        return true;\r\n    }\r\n    public static BackgroundFetch backgroundFetchListener;\r\n\r\n    BackgroundFetch getBackgroundFetchListener() {\r\n        if (getActivity() != null && getActivity().getApp() instanceof BackgroundFetch) {\r\n            return (BackgroundFetch)getActivity().getApp();\r\n        } else if (backgroundFetchListener != null) {\r\n            return backgroundFetchListener;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void scheduleLocalNotification(LocalNotification notif, long firstTime, int repeat) {\r\n\r\n        final Intent notificationIntent = new Intent(getContext(), LocalNotificationPublisher.class);\r\n        notificationIntent.setAction(getContext().getApplicationInfo().packageName + \".\" + notif.getId());\r\n        notificationIntent.putExtra(LocalNotificationPublisher.NOTIFICATION, createBundleFromNotification(notif));\r\n\r\n        Intent contentIntent = new Intent();\r\n        if (activityComponentName != null) {\r\n            contentIntent.setComponent(activityComponentName);\r\n        } else {\r\n            try {\r\n                contentIntent.setComponent(getContext().getPackageManager().getLaunchIntentForPackage(getContext().getApplicationInfo().packageName).getComponent());\r\n            } catch (Exception ex) {\r\n                System.err.println(\"Failed to get the component name for local notification.  Local notification may not work.\");\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        contentIntent.putExtra(\"LocalNotificationID\", notif.getId());\r\n\r\n        if (BACKGROUND_FETCH_NOTIFICATION_ID.equals(notif.getId()) && getBackgroundFetchListener() != null) {\r\n            Context context = AndroidNativeUtil.getContext();\r\n\r\n            Intent intent = new Intent(context, BackgroundFetchHandler.class);\r\n            //there is an bug that causes this to not to workhttps://code.google.com/p/android/issues/detail?id=81812\r\n            //intent.putExtra(\"backgroundClass\", getBackgroundLocationListener().getName());\r\n            //an ugly workaround to the putExtra bug \r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + getBackgroundFetchListener().getClass().getName()));\r\n            PendingIntent pendingIntent = getPendingIntent(context, 0,\r\n                    intent);\r\n            notificationIntent.putExtra(LocalNotificationPublisher.BACKGROUND_FETCH_INTENT, pendingIntent);\r\n\r\n        } else {\r\n            contentIntent.setData(Uri.parse(\"http://codenameone.com/a?LocalNotificationID=\"+Uri.encode(notif.getId())));\r\n        }\r\n        PendingIntent pendingContentIntent = createPendingIntent(getContext(), 0, contentIntent);\r\n\r\n        notificationIntent.putExtra(LocalNotificationPublisher.NOTIFICATION_INTENT, pendingContentIntent);\r\n\r\n\r\n        PendingIntent pendingIntent = getBroadcastPendingIntent(getContext(), 0, notificationIntent);\r\n\r\n        AlarmManager alarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);\r\n        if (BACKGROUND_FETCH_NOTIFICATION_ID.equals(notif.getId())) {\r\n            alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, getPreferredBackgroundFetchInterval() * 1000, pendingIntent);\r\n        } else {\r\n            if(repeat == LocalNotification.REPEAT_NONE){\r\n                alarmManager.set(AlarmManager.RTC_WAKEUP, firstTime, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_MINUTE){\r\n\r\n                alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, 60*1000, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_HOUR){\r\n\r\n                alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_HALF_HOUR, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_DAY){\r\n\r\n                alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_DAY, pendingIntent);\r\n\r\n            }else if(repeat == LocalNotification.REPEAT_WEEK){\r\n\r\n                alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, firstTime, AlarmManager.INTERVAL_DAY * 7, pendingIntent);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cancelLocalNotification(String notificationId) {\r\n        Intent notificationIntent = new Intent(getContext(), LocalNotificationPublisher.class);\r\n        notificationIntent.setAction(getContext().getApplicationInfo().packageName + \".\" + notificationId);\r\n\r\n        PendingIntent pendingIntent = getBroadcastPendingIntent(getContext(), 0, notificationIntent);\r\n        AlarmManager alarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);\r\n        alarmManager.cancel(pendingIntent);\r\n    }\r\n\r\n    static Bundle createBundleFromNotification(LocalNotification notif){\r\n        Bundle b = new Bundle();\r\n        b.putString(\"NOTIF_ID\", notif.getId());\r\n        b.putString(\"NOTIF_TITLE\", notif.getAlertTitle());\r\n        b.putString(\"NOTIF_BODY\", notif.getAlertBody());\r\n        b.putString(\"NOTIF_SOUND\", notif.getAlertSound());\r\n        b.putString(\"NOTIF_IMAGE\", notif.getAlertImage());\r\n        b.putInt(\"NOTIF_NUMBER\", notif.getBadgeNumber());\r\n        return b;\r\n    }\r\n\r\n    static LocalNotification createNotificationFromBundle(Bundle b){\r\n        LocalNotification n = new LocalNotification();\r\n        n.setId(b.getString(\"NOTIF_ID\"));\r\n        n.setAlertTitle(b.getString(\"NOTIF_TITLE\"));\r\n        n.setAlertBody(b.getString(\"NOTIF_BODY\"));\r\n        n.setAlertSound(b.getString(\"NOTIF_SOUND\"));\r\n        n.setAlertImage(b.getString(\"NOTIF_IMAGE\"));\r\n        n.setBadgeNumber(b.getInt(\"NOTIF_NUMBER\"));\r\n        return n;\r\n    }\r\n\r\n    boolean brokenGaussian;\r\n    public Image gaussianBlurImage(Image image, float radius) {\r\n        try {\r\n            Bitmap outputBitmap = Bitmap.createBitmap((Bitmap)image.getImage());\r\n\r\n            RenderScript rs = RenderScript.create(getContext());\r\n            try {\r\n                ScriptIntrinsicBlur theIntrinsic = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\r\n                Allocation tmpIn = Allocation.createFromBitmap(rs, (Bitmap)image.getImage());\r\n                Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap);\r\n                theIntrinsic.setRadius(radius);\r\n                theIntrinsic.setInput(tmpIn);\r\n                theIntrinsic.forEach(tmpOut);\r\n                tmpOut.copyTo(outputBitmap);\r\n                tmpIn.destroy();\r\n                tmpOut.destroy();\r\n                theIntrinsic.destroy();\r\n            } finally {\r\n                rs.destroy();\r\n            }\r\n\r\n            return new NativeImage(outputBitmap);\r\n        } catch(Throwable t) {\r\n            brokenGaussian = true;\r\n            return image;\r\n        }\r\n    }\r\n\r\n    public boolean isGaussianBlurSupported() {\r\n        return (!brokenGaussian) && android.os.Build.VERSION.SDK_INT >= 11;\r\n    }\r\n\r\n    public static boolean checkForPermission(String permission, String description){\r\n        return checkForPermission(permission, description, false);\r\n    }\r\n\r\n    /**\r\n     * Return a list of all of the permissions that have been requested by the app (granted or no).\r\n     * This can be used to see which permissions are included in the manifest file.\r\n     * @return \r\n     */\r\n    public static List<String> getRequestedPermissions() {\r\n        PackageManager pm = getContext().getPackageManager();\r\n        try\r\n        {\r\n            PackageInfo packageInfo = pm.getPackageInfo(getContext().getPackageName(), PackageManager.GET_PERMISSIONS);\r\n            String[] requestedPermissions = null;\r\n            if (packageInfo != null) {\r\n                requestedPermissions = packageInfo.requestedPermissions;\r\n                return Arrays.asList(requestedPermissions);\r\n            }\r\n            return new ArrayList<String>();\r\n        }\r\n        catch (PackageManager.NameNotFoundException e)\r\n        {\r\n            com.codename1.io.Log.e(e);\r\n            return new ArrayList<String>();\r\n        }\r\n    }\r\n    \r\n    public static boolean checkForPermission(String permission, String description, boolean forceAsk){\r\n        //before sdk 23 no need to ask for permission\r\n        if(android.os.Build.VERSION.SDK_INT < 23){\r\n            return true;\r\n        }\r\n\r\n        String prompt = Display.getInstance().getProperty(permission, description);\r\n\r\n        if (android.support.v4.content.ContextCompat.checkSelfPermission(getContext(),\r\n                permission)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n\r\n            if (getActivity() == null) {\r\n                return false;\r\n            }\r\n\r\n            // Should we show an explanation?\r\n            if (!forceAsk && android.support.v4.app.ActivityCompat.shouldShowRequestPermissionRationale(getActivity(),\r\n                    permission)) {\r\n\r\n                // Show an expanation to the user *asynchronously* -- don't block\r\n                if(Dialog.show(\"Requires permission\", prompt, \"Ask again\", \"Don't Ask\")){\r\n                    return checkForPermission(permission, description, true);\r\n                }else {\r\n                    return false;\r\n                }\r\n            } else {\r\n\r\n                // No explanation needed, we can request the permission.\r\n                ((CodenameOneActivity)getActivity()).setRequestForPermission(true);\r\n                ((CodenameOneActivity)getActivity()).setWaitingForPermissionResult(true);\r\n                android.support.v4.app.ActivityCompat.requestPermissions(getActivity(),\r\n                        new String[]{permission},\r\n                        1);\r\n                //wait for a response\r\n                Display.getInstance().invokeAndBlock(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        while(((CodenameOneActivity)getActivity()).isRequestForPermission()) {\r\n                            try {\r\n                                Thread.sleep(50);\r\n                            } catch (InterruptedException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                //check again if the permission is given after the dialog was displayed\r\n                return android.support.v4.content.ContextCompat.checkSelfPermission(getActivity(),\r\n                        permission) == PackageManager.PERMISSION_GRANTED;\r\n\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean isJailbrokenDevice() {\r\n        try {\r\n            Runtime.getRuntime().exec(\"su\");\r\n            return true;\r\n        } catch(Throwable t) {\r\n            com.codename1.io.Log.e(t);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n", "/*\n * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores\n * CA 94065 USA or visit www.oracle.com if you need additional information or\n * have any questions.\n */\npackage com.codename1.impl.android;\n\nimport android.app.Activity;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.graphics.Bitmap;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.os.Bundle;\nimport android.os.PowerManager;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.Window;\nimport android.widget.Toast;\n\nimport com.codename1.payment.Product;\nimport com.codename1.ui.Command;\nimport com.codename1.ui.Display;\nimport com.codename1.ui.Form;\nimport com.codename1.ui.Image;\nimport com.codename1.ui.Toolbar;\nimport com.codename1.ui.events.ActionEvent;\n\nimport java.util.Vector;\n\npublic class CodenameOneActivity extends Activity {\n\n\n\n\n    private Menu menu;\n    private boolean nativeMenu = false;\n    private IntentResultListener intentResultListener;\n    private IntentResultListener defaultResultListener;\n    private boolean waitingForResult, waitingForPermissionResult;\n    private boolean background;\n    private Vector intentResult = new Vector();\n    boolean requestForPermission = false;\n\n    private IBillingSupport billingSupport;\n\n    private PowerManager.WakeLock wakeLock;\n\n    /**\n     * Overriden by stub, returns the user application instance.\n     */\n    protected Object getApp() {\n        return null;\n    }\n\n    boolean wasPurchased(String item) {\n        if (billingSupport != null) {\n            return billingSupport.wasPurchased(item);\n        }\n        return false;\n    }\n\n    void purchase(final String item) {\n        if (billingSupport != null) billingSupport.purchase(item);\n    }\n\n\n    void subscribe(final String item) {\n        if (billingSupport != null) billingSupport.subscribe(item);\n    }\n\n\n    protected IBillingSupport createBillingSupport() {\n        return null;\n    }\n\n    private IBillingSupport getBillingSupport() {\n        if (billingSupport == null) {\n            billingSupport = createBillingSupport();\n        }\n        return billingSupport;\n    }\n\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        AndroidImplementation.setActivity(this);\n        AndroidNativeUtil.onResume();\n        if (isBillingEnabled() && getBillingSupport() != null) {\n            billingSupport.consumeAndAcknowlegePurchases();\n        }\n        background = false;\n    }\n\n    /**\n     * Overriden by subclasses to return true if billing is supported on this\n     * build\n     *\n     * @return false\n     */\n    protected boolean isBillingEnabled() {\n        return false;\n    }\n\n    /**\n     * Get the Android native Menu\n     *\n     * @return the Android Menu Object\n     */\n    public Menu getMenu() {\n        return menu;\n    }\n\n    /**\n     * This method will enable the Android native Menu system instead of the\n     * regular Form Menu.\n     *\n     * @param enable\n     */\n    public void enableNativeMenu(boolean enable) {\n        nativeMenu = enable;\n    }\n\n    @Override\n    public void onBackPressed() {\n        Display.getInstance().keyPressed(AndroidImplementation.DROID_IMPL_KEY_BACK);\n        Display.getInstance().keyReleased(AndroidImplementation.DROID_IMPL_KEY_BACK);\n    }\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AndroidImplementation.setActivity(this);\n        AndroidNativeUtil.onCreate(savedInstanceState);\n\n        if (android.os.Build.VERSION.SDK_INT >= 11) {\n            getWindow().requestFeature(Window.FEATURE_ACTION_BAR);\n            getActionBar().hide();\n        }\n\n        try {\n            if (isBillingEnabled()) {\n                String k = getBase64EncodedPublicKey();\n                if(k.length() == 0){\n                    Log.e(\"Codename One\", \"android.licenseKey base64 is not configured\");\n                }\n                getBillingSupport().initBilling();\n\n\n            }\n        } catch (Throwable t) {\n            // might happen if billing permissions are missing\n            System.out.print(\"This exception is totally valid and here only for debugging purposes\");\n            t.printStackTrace();\n        }\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n    }\n\n    @Override\n    protected void onStop() {\n        AndroidImplementation.clearAppArg();\n        super.onStop();\n        background = true;\n        unlockScreen();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        AndroidNativeUtil.onDestroy();\n        if (isBillingEnabled()) {\n            getBillingSupport().onDestroy();\n        }\n        unlockScreen();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        this.menu = menu;\n        // By returning true we signal let Android know that we want the menu\n        // to be displayed\n        return nativeMenu && Display.isInitialized() && Display.getInstance().getCurrent() != null;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        AndroidNativeUtil.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onLowMemory() {\n        super.onLowMemory();\n        AndroidNativeUtil.onLowMemory();\n    }\n\n    @Override\n    protected void onPause() {\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.onPause();\n        AndroidNativeUtil.onPause();\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n\n        menu.clear();\n\n        try {\n            Form currentForm = Display.getInstance().getCurrent();\n            if (currentForm == null || Toolbar.isGlobalToolbar()) {\n                return false;\n            }\n\n            int numCommands = currentForm.getCommandCount();\n\n            // If there are no commands, there's nothing to put in the menu\n            if (numCommands == 0) {\n                return false;\n            }\n\n            // Build menu items from commands\n            for (int n = 0; n < numCommands; n++) {\n                Command command = currentForm.getCommand(n);\n                if (command != null) {\n                    String txt = currentForm.getUIManager().localize(command.getCommandName(), command.getCommandName());\n                    MenuItem item = menu.add(Menu.NONE, n, Menu.NONE, txt);\n\n                    Image icon = command.getIcon();\n                    if (icon != null) {\n                        Bitmap b = (Bitmap) icon.getImage();\n                        // Using BitmapDrawable with resources, to use device density (from 1.6 and above).\n                        BitmapDrawable d = new BitmapDrawable(getResources(), b);\n                        item.setIcon(d);\n                    }\n                    if (!command.isEnabled()) {\n                        item.setEnabled(false);\n                    }\n                    if (android.os.Build.VERSION.SDK_INT >= 11 && command.getClientProperty(\"android:showAsAction\") != null) {\n                        String androidShowAsAction = command.getClientProperty(\"android:showAsAction\").toString();\n                        // From https://developer.android.com/guide/topics/resources/menu-resource.html\n                        // \"ifRoom\" | \"never\" | \"withText\" | \"always\" | \"collapseActionView\"\n                        if (androidShowAsAction.equalsIgnoreCase(\"ifRoom\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"never\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"withText\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);\n                        } else if (androidShowAsAction.equalsIgnoreCase(\"always\")) {\n                            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n                        } else if (android.os.Build.VERSION.SDK_INT >= 14 && androidShowAsAction.equalsIgnoreCase(\"collapseActionView\")) {\n                            item.setShowAsAction(8); //MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW\n                        }\n                    }\n                }\n            }\n        } catch (Throwable t) {\n        }\n\n        return nativeMenu;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        super.onOptionsItemSelected(item);\n\n        final Form currentForm = Display.getInstance().getCurrent();\n        if (currentForm == null) {\n            return false;\n        }\n        Command cmd = null;\n        final boolean[] tmpProp = new boolean[1];\n        if (item.getItemId() == android.R.id.home) {\n            cmd = currentForm.getBackCommand();\n            if (cmd == null) {\n                return false;\n            }\n            cmd.putClientProperty(\"source\", \"ActionBar\");\n            tmpProp[0] = true;\n        }\n\n        int commandIndex = item.getItemId();\n        if (cmd == null) {\n            cmd = currentForm.getCommand(commandIndex);\n        }\n        final Command command = cmd;\n        final ActionEvent actionEvent = new ActionEvent(command);\n\n        //stop edit if the keybaord is open\n        AndroidImplementation.stopEditing();\n        // Protect ourselves from commands that misbehave. A crash here will crash the entire application\n        Display.getInstance().callSerially(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    currentForm.dispatchCommand(command, actionEvent);\n                    //remove the temp source property\n                    if (tmpProp[0]) {\n                        command.putClientProperty(\"source\", null);\n                    }\n                } catch (Throwable e) {\n                    Log.e(\"CodenameOneActivity.onOptionsItemSelected\", e.toString() + Log.getStackTraceString(e));\n                }\n            }\n        });\n\n        return true;\n    }\n\n    protected void fireIntentResult() {\n        if (intentResult.size() > 0) {\n            final IntentResult response = (IntentResult) intentResult.get(0);\n            if (intentResultListener != null && response != null) {\n                Display.getInstance().callSerially(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        intentResultListener.onActivityResult(response.getRequestCode(),\n                                response.getResultCode(),\n                                response.getData());\n                    }\n                });\n            }\n        }\n    }\n\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n        IntentResult response = new IntentResult(requestCode, resultCode, data);\n        intentResult.add(response);\n    }\n\n    public void setIntentResultListener(IntentResultListener l) {\n        //if the activity is waiting for result don't override the intent listener\n        if(waitingForResult){\n            return;\n        }\n        this.intentResultListener = l;\n        if (l != null && l != defaultResultListener) {\n            waitingForResult = true;\n        }\n    }\n\n    public void setDefaultIntentResultListener(IntentResultListener l) {\n        this.defaultResultListener = l;\n    }\n\n    public void restoreIntentResultListener() {\n        waitingForResult = false;\n        setIntentResultListener(defaultResultListener);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        Bundle extra = intent.getExtras();\n        if(extra != null && extra.containsKey(\"WaitForResult\") && !extra.getBoolean(\"WaitForResult\")){\n            waitingForResult = false;            \n        }else{\n            waitingForResult = true;\n        }\n        intentResult = new Vector();\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void startActivity(Intent intent) {\n        Bundle extra = intent.getExtras();\n        if(extra != null && extra.containsKey(\"WaitForResult\") && !extra.getBoolean(\"WaitForResult\")){\n            waitingForResult = false;            \n        }else{\n            waitingForResult = true;\n        }\n        if (InPlaceEditView.isEditing()) {\n            AndroidImplementation.stopEditing(true);\n        }\n        super.startActivity(intent);\n    }\n\n    public boolean isWaitingForResult() {\n        return waitingForResult;\n    }\n\n    protected void setWaitingForResult(boolean waitingForResult) {\n        this.waitingForResult = waitingForResult;\n    }\n\n    public boolean isBackground() {\n        return background;\n    }\n\n    public void registerForPush(String key) {\n        Intent registrationIntent = new Intent(\"com.google.android.c2dm.intent.REGISTER\");\n        registrationIntent.setPackage(\"com.google.android.gms\");\n        registrationIntent.putExtra(\"app\", AndroidImplementation.getBroadcastPendingIntent(this, 0, new Intent())); // boilerplate\n        registrationIntent.putExtra(\"sender\", key);\n        startService(registrationIntent);\n    }\n\n    public void stopReceivingPush() {\n        Intent unregIntent = new Intent(\"com.google.android.c2dm.intent.UNREGISTER\");\n        unregIntent.setPackage(\"com.google.android.gms\");\n        unregIntent.putExtra(\"app\", AndroidImplementation.getBroadcastPendingIntent(this, 0, new Intent()));\n        startService(unregIntent);\n    }\n\n    public void lockScreen() {\n        unlockScreen();\n        try {\n            android.os.PowerManager pm = (android.os.PowerManager) getSystemService(android.content.Context.POWER_SERVICE);\n            wakeLock = pm.newWakeLock(android.os.PowerManager.SCREEN_BRIGHT_WAKE_LOCK | android.os.PowerManager.ACQUIRE_CAUSES_WAKEUP | android.os.PowerManager.ON_AFTER_RELEASE, \"Codename One\");\n        } catch (Exception excp) {\n            excp.printStackTrace();\n        }\n        if (wakeLock != null) {\n            wakeLock.acquire();\n        }\n    }\n\n    public void unlockScreen() {\n        if (wakeLock != null && wakeLock.isHeld()) {\n            wakeLock.release();\n            wakeLock = null;\n        }\n    }\n\n    public String getBase64EncodedPublicKey() {\n        String key = Display.getInstance().getProperty(\"android.licenseKey\", \"\");        \n        return key;\n    }\n\n\n\n    String getPayload() {\n        return \"\";\n    }\n\n\n\n\n\n\n\n    public boolean isConsumable(String item) {\n        if (getBillingSupport() != null) {\n            return getBillingSupport().isConsumable(item);\n        }\n        return false;\n    }\n\n    Product[] getProducts(String[] skus){\n        if (getBillingSupport() != null) {\n            return getBillingSupport().getProducts(skus, false);\n        }\n        return new Product[0];\n    }\n    \n\n    \n\n\n    public void setRequestForPermission(boolean requestForPermission) {\n        this.requestForPermission = requestForPermission;\n    }\n\n    public void setWaitingForPermissionResult(boolean waitingForPermissionResult) {\n        this.waitingForPermissionResult = waitingForPermissionResult;\n    }\n\n    public boolean isWaitingForPermissionResult() {\n        return waitingForPermissionResult;\n    }\n\n    public boolean isRequestForPermission() {\n        return requestForPermission;\n    }\n\n    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n        if(grantResults != null || grantResults.length == 0) {\n            requestForPermission = false;\n            return;\n        }\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            Log.i(\"Codename One\", \"PERMISSION_GRANTED\");\n        } else {\n            // Permission Denied\n            Toast.makeText(this, \"Permission is denied\", Toast.LENGTH_SHORT).show();\n        }\n        requestForPermission = false;\n    }\n    \n    public boolean hasUI(){\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Codename One designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *  \n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n * \n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n * \n * Please contact Codename One through http://www.codenameone.com/ if you \n * need additional information or have any questions.\n */\npackage com.codename1.impl.android;\n\nimport android.app.Activity;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.os.IBinder;\nimport com.codename1.push.PushCallback;\nimport com.codename1.ui.Display;\n\n/**\n * This class implements a push notification fallback service for applications that require\n * push notification support but don't have Android Market installed\n *\n * @author Shai Almog\n */\npublic abstract class PushNotificationService extends Service implements PushCallback {\n\n    private java.util.Map<String,String> properties = new java.util.HashMap<String,String>();\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n    \n    @Override\n    public void onCreate() {\n    }\n    \n    private String getProperty(String propertyName, String defaultValue) {\n        String val = properties.get(propertyName);\n        if (val == null) {\n            return defaultValue;\n        }\n        return val;\n    }\n    \n    public void setProperty(String propertyName, String val) {\n        properties.put(propertyName, val);\n        \n    }\n    \n    public static void startServiceIfRequired(Class service, Context ctx) {\n        if(!AndroidImplementation.hasAndroidMarket(ctx)) {\n            SharedPreferences sh = ctx.getSharedPreferences(\"C2DMNeeded\", Context.MODE_PRIVATE);\n            if(sh.getBoolean(\"C2DMNeeded\", false)) {\n                Intent i = new Intent();\n                i.setAction(service.getClass().getName());\n                ctx.startService(i);\n            }\n        }\n    }\n    \n    public static void forceStartService(String service, Context ctx) {\n        if(!AndroidImplementation.hasAndroidMarket(ctx)) {\n            SharedPreferences sh = ctx.getSharedPreferences(\"C2DMNeeded\", Context.MODE_PRIVATE);\n            Editor editor = sh.edit();\n            editor.putBoolean(\"C2DMNeeded\", true);\n            editor.commit();\n            Intent i = new Intent();\n            i.setAction(service);\n            ctx.startService(i);\n        }\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        AndroidImplementation.registerPolling();\n        return START_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        AndroidImplementation.stopPollingLoop();\n    }\n    \n    public abstract PushCallback getPushCallbackInstance();\n    public abstract Class getStubClass();\n\n\n    @Override\n    public void push(final String value) {\n        final PushCallback callback = getPushCallbackInstance();\n        if(callback != null) {\n            Display.getInstance().callSerially(new Runnable() {\n                public void run() {\n                    callback.push(value);\n                }\n            });\n        } else {\n            NotificationManager nm = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);\n            Intent newIntent = new Intent(this, getStubClass());\n            PendingIntent contentIntent = AndroidImplementation.createPendingIntent(this, 0, newIntent);\n\n\n\n            Notification.Builder builder = new Notification.Builder(this)\n                    .setContentIntent(contentIntent)\n                    .setSmallIcon(android.R.drawable.stat_notify_sync)\n                    .setTicker(value)\n                    .setAutoCancel(true)\n                    .setWhen(System.currentTimeMillis())\n                    .setContentTitle(value)\n\n                    .setDefaults(Notification.DEFAULT_ALL);\n\n\n\n\n            // The following section is commented out so that builds against SDKs below 26\n            // won't fail.\n            /*<SDK26>\n            if(android.os.Build.VERSION.SDK_INT >= 21){\n                builder.setCategory(\"Notification\");\n            }\n            if (android.os.Build.VERSION.SDK_INT >= 26) {\n                NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n                String id = getProperty(\"android.NotificationChannel.id\", \"cn1-channel\");\n\n                CharSequence name = getProperty(\"android.NotificationChannel.name\", \"Notifications\");\n\n                String description = getProperty(\"android.NotificationChannel.description\", \"Remote notifications\");\n\n                int importance = Integer.parseInt(getProperty(\"android.NotificationChannel.importance\", \"\"+NotificationManager.IMPORTANCE_HIGH));\n\n                android.app.NotificationChannel mChannel = new android.app.NotificationChannel(id, name,importance);\n\n                mChannel.setDescription(description);\n\n                mChannel.enableLights(Boolean.parseBoolean(getProperty(\"android.NotificationChannel.enableLights\", \"true\")));\n\n                mChannel.setLightColor(Integer.parseInt(getProperty(\"android.NotificationChannel.lightColor\", \"\"+android.graphics.Color.RED)));\n\n                mChannel.enableVibration(Boolean.parseBoolean(getProperty(\"android.NotificationChannel.enableVibration\", \"false\")));\n                String vibrationPatternStr = getProperty(\"android.NotificationChannel.vibrationPattern\", null);\n                if (vibrationPatternStr != null) {\n                    String[] parts = vibrationPatternStr.split(\",\");\n                    int len = parts.length;\n                    long[] pattern = new long[len];\n                    for (int i=0; i<len; i++) {\n                        pattern[i] = Long.parseLong(parts[i].trim());\n                    }\n                    mChannel.setVibrationPattern(pattern);\n                }\n\n\n\n                mNotificationManager.createNotificationChannel(mChannel);\n                System.out.println(\"Setting push channel to \"+id);\n                builder.setChannelId(id);\n            }\n            </SDK26>*/\n\n            Notification notif = builder.build();\n            int notifId = getNotifyId();//(int)System.currentTimeMillis();\n\n            //notif.extras.putInt(\"notificationId\", notifId);\n            nm.notify(notifId, notif);\n        }\n    }\n\n    static int getNotifyId() {\n        return 1;\n    }\n\n    static void cancelNotification(Context context) {\n        NotificationManager nm = (NotificationManager) context.getSystemService(Activity.NOTIFICATION_SERVICE);\n        nm.cancel(getNotifyId());\n    }\n\n    @Override\n    public void registeredForPush(String deviceId) {\n    }\n\n    @Override\n    public void pushRegistrationError(String error, int errorCode) {\n    }\n}\n", "/*\r\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Codename One designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *\r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n *\r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n *\r\n * Please contact Codename One through http://www.codenameone.com/ if you\r\n * need additional information or have any questions.\r\n */\r\npackage com.codename1.location;\r\n\r\nimport android.Manifest;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.net.Uri;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.Looper;\r\nimport android.os.Parcel;\r\nimport android.os.Parcelable;\r\n\r\nimport android.support.annotation.NonNull;\r\nimport android.support.annotation.RequiresApi;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport com.codename1.impl.android.AndroidImplementation;\r\nimport com.codename1.impl.android.AndroidNativeUtil;\r\nimport com.codename1.impl.android.LifecycleListener;\r\nimport com.codename1.impl.android.PlayServices;\r\nimport com.codename1.io.Log;\r\nimport com.codename1.ui.Display;\r\nimport com.google.android.gms.common.ConnectionResult;\r\nimport com.google.android.gms.common.api.GoogleApiClient;\r\nimport com.google.android.gms.location.*;\r\nimport com.google.android.gms.location.Geofence;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.tasks.OnFailureListener;\r\nimport com.google.android.gms.tasks.OnSuccessListener;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n *\r\n * @author Chen\r\n */\r\npublic class AndroidLocationPlayServiceManager extends com.codename1.location.LocationManager implements\r\n        GoogleApiClient.ConnectionCallbacks,\r\n        GoogleApiClient.OnConnectionFailedListener,\r\n        com.google.android.gms.location.LocationListener,\r\n        LifecycleListener {\r\n\r\n\r\n\r\n    static class ParcelableUtil {\r\n        public static byte[] marshall(Parcelable parceable) {\r\n            Parcel parcel = Parcel.obtain();\r\n            parceable.writeToParcel(parcel, 0);\r\n            byte[] bytes = parcel.marshall();\r\n            parcel.recycle();\r\n            return bytes;\r\n        }\r\n\r\n        public static Parcel unmarshall(byte[] bytes) {\r\n            Parcel parcel = Parcel.obtain();\r\n            parcel.unmarshall(bytes, 0, bytes.length);\r\n            parcel.setDataPosition(0); // This is extremely important!\r\n            return parcel;\r\n        }\r\n\r\n        public static <T> T unmarshall(byte[] bytes, Parcelable.Creator<T> creator) {\r\n            Parcel parcel = unmarshall(bytes);\r\n            T result = creator.createFromParcel(parcel);\r\n            parcel.recycle();\r\n            return result;\r\n        }\r\n    }\r\n\r\n    public final LocationCallback callback = new LocationCallback() {\r\n        public void onLocationResult(LocationResult var1) {\r\n            AndroidLocationPlayServiceManager.this.onLocationChanged(var1.getLastLocation());\r\n        }\r\n\r\n        public void onLocationAvailability(LocationAvailability var1) {\r\n\r\n        }\r\n    };\r\n\r\n    public static AndroidLocationPlayServiceManager inMemoryBackgroundLocationListener;\r\n\r\n    private GoogleApiClient mGoogleApiClient;\r\n    private GeofencingClient geofencingClient;\r\n\r\n    private LocationRequest locationRequest;\r\n\r\n    private static AndroidLocationPlayServiceManager instance = new AndroidLocationPlayServiceManager();\r\n\r\n    public AndroidLocationPlayServiceManager() {\r\n    }\r\n\r\n    public static AndroidLocationPlayServiceManager getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    @Override\r\n    public Location getCurrentLocation() throws IOException {\r\n        Location l = getLastKnownLocation();\r\n        if (l == null) {\r\n            throw new IOException(\"cannot retrieve location try later\");\r\n        }\r\n        return l;\r\n    }\r\n\r\n    @Override\r\n    public Location getLastKnownLocation() {\r\n        while (!getmGoogleApiClient().isConnected()) {\r\n            try {\r\n                Thread.sleep(300);\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        //android.location.Location location = LocationServices.FusedLocationApi.getLastLocation(getmGoogleApiClient());\r\n        android.location.Location location = PlayServices.getInstance().getLastKnownLocation(getmGoogleApiClient());\r\n        if (location != null) {\r\n            return AndroidLocationManager.convert(location);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    protected void bindListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        LocationRequest r = locationRequest;\r\n\r\n                        com.codename1.location.LocationRequest request = getRequest();\r\n                        if (request != null) {\r\n                            LocationRequest lr = LocationRequest.create();\r\n                            if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_HIGH_ACCUARCY) {\r\n                                lr.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n                            } else if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_MEDIUM_ACCUARCY) {\r\n                                lr.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);\r\n                            } else {\r\n                                lr.setPriority(LocationRequest.PRIORITY_LOW_POWER);\r\n                            }\r\n                            lr.setInterval(request.getInterval());\r\n                            r = lr;\r\n                        }\r\n                        if (AndroidImplementation.getActivity() == null) {\r\n                            // we are in the background\r\n                            // Sometimes using regular locations in the background causes a crash\r\n                            // so we need to use the pending intent version.\r\n                            Context context = AndroidNativeUtil.getContext();\r\n\r\n                            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n                            //there is an bug that causes this to not to workhttps://code.google.com/p/android/issues/detail?id=81812\r\n                            //intent.putExtra(\"backgroundClass\", getBackgroundLocationListener().getName());\r\n                            //an ugly workaround to the putExtra bug \r\n                            if (bgListenerClass != null) {\r\n                                intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n                            }\r\n                            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\r\n                                    intent);\r\n                            inMemoryBackgroundLocationListener = AndroidLocationPlayServiceManager.this;\r\n\r\n\r\n                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, pendingIntent);\r\n                            requestLocationUpdates(context, r, pendingIntent);\r\n                        } else {\r\n                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, AndroidLocationPlayServiceManager.this);\r\n                            requestLocationUpdates(AndroidNativeUtil.getContext(), r, AndroidLocationPlayServiceManager.this);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    private void requestLocationUpdates(Context context, LocationRequest req, PendingIntent pendingIntent) {\r\n        PlayServices.getInstance().requestLocationUpdates(getmGoogleApiClient(), context, req, pendingIntent);\r\n    }\r\n\r\n\r\n    private PendingIntent createBackgroundPendingIntent() {\r\n        return createBackgroundPendingIntent(false);\r\n    }\r\n\r\n    private PendingIntent createBackgroundPendingIntent(boolean forceService) {\r\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return null;\r\n        }\r\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\r\n            PendingIntent pendingIntent = AndroidImplementation.getBroadcastPendingIntent(context, 0, intent);\r\n            return pendingIntent;\r\n        } else {\r\n\r\n\r\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\r\n            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\r\n                    intent);\r\n            return pendingIntent;\r\n        }\r\n    }\r\n\r\n    static android.location.Location extractLocationFromIntent(Intent intent) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            LocationResult locationResult = LocationResult.extractResult(intent);\r\n            if (locationResult == null) {\r\n                return null;\r\n            }\r\n            return locationResult.getLastLocation();\r\n        } else {\r\n            return intent.getParcelableExtra(FusedLocationProviderApi.KEY_LOCATION_CHANGED);\r\n        }\r\n    }\r\n\r\n    private void requestLocationUpdates(Context context, LocationRequest req, AndroidLocationPlayServiceManager mgr) {\r\n        PlayServices.getInstance().requestLocationUpdates(getmGoogleApiClient(), context, req, mgr);\r\n    }\r\n\r\n    private void removeLocationUpdates(Context context, AndroidLocationPlayServiceManager mgr) {\r\n        PlayServices.getInstance().removeLocationUpdates(getmGoogleApiClient(), context, mgr);\r\n    }\r\n\r\n    private void removeLocationUpdates(Context context, PendingIntent pendingIntent) {\r\n        PlayServices.getInstance().removeLocationUpdates(getmGoogleApiClient(), context, pendingIntent);\r\n    }\r\n\r\n    @Override\r\n    protected void clearListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //mGoogleApiClient must be connected\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        if (inMemoryBackgroundLocationListener != null) {\r\n                            Context context = AndroidNativeUtil.getContext();\r\n                            Intent intent = new Intent(context, BackgroundLocationHandler.class);\r\n                            if (bgListenerClass != null) {\r\n                                intent.putExtra(\"backgroundClass\", bgListenerClass.getName());\r\n                            }\r\n                            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\r\n                                    intent);\r\n\r\n                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), pendingIntent);\r\n                            removeLocationUpdates(context, pendingIntent);\r\n                            inMemoryBackgroundLocationListener = null;\r\n                        } else {\r\n                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), AndroidLocationPlayServiceManager.this);\r\n                            removeLocationUpdates(AndroidNativeUtil.getContext(), AndroidLocationPlayServiceManager.this);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    protected void bindBackgroundListener() {\r\n        if (!checkBackgroundLocationPermission()) {\r\n            return;\r\n        }\r\n\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        //don't be too aggressive for location updates in the background\r\n                        LocationRequest req = LocationRequest.create();\r\n                        setupBackgroundLocationRequest(req);\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n                        PendingIntent pendingIntent = createBackgroundPendingIntent();\r\n                        requestLocationUpdates(context, req, pendingIntent);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    private void setupBackgroundLocationRequest(LocationRequest req) {\r\n        Display d = Display.getInstance();\r\n        String priorityStr = d.getProperty(\"android.backgroundLocation.priority\", \"PRIORITY_BALANCED_POWER_ACCURACY\");\r\n        String fastestIntervalStr = d.getProperty(\"android.backgroundLocation.fastestInterval\", \"5000\");\r\n        String intervalStr = d.getProperty(\"android.backgroundLocation.interval\", \"10000\");\r\n        String smallestDisplacementStr = d.getProperty(\"android.backgroundLocation.smallestDisplacement\", \"50\");\r\n\r\n        int priority = LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY;\r\n        if (\"PRIORITY_HIGH_ACCURACY\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_HIGH_ACCURACY;\r\n        } else if (\"PRIORITY_LOW_POWER\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_LOW_POWER;\r\n        } else if (\"PRIORITY_NO_POWER\".equals(priorityStr)) {\r\n            priority = LocationRequest.PRIORITY_NO_POWER;\r\n        }\r\n\r\n        long interval = Long.parseLong(intervalStr);\r\n        long fastestInterval = Long.parseLong(fastestIntervalStr);\r\n        int smallestDisplacement = Integer.parseInt(smallestDisplacementStr);\r\n\r\n        req.setPriority(priority)\r\n                .setFastestInterval(fastestInterval)\r\n                .setInterval(interval)\r\n                .setSmallestDisplacement(smallestDisplacement);\r\n    }\r\n\r\n    @Override\r\n    protected void clearBackgroundListener() {\r\n        final Class bgListenerClass = getBackgroundLocationListener();\r\n        if (bgListenerClass == null) {\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //mGoogleApiClient must be connected\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n                        PendingIntent pendingIntent = createBackgroundPendingIntent();\r\n                        removeLocationUpdates(context, pendingIntent);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    @Override\r\n    public void onLocationChanged(final android.location.Location loc) {\r\n        synchronized (this) {\r\n            final com.codename1.location.LocationListener l = getLocationListener();\r\n            if (l != null) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        Location lastLocation = AndroidLocationManager.convert(loc);\r\n                        l.locationUpdated(lastLocation);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onConnected(Bundle bundle) {\r\n        locationRequest = LocationRequest.create();\r\n        locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n        locationRequest.setInterval(1000); // Update location every second\r\n\r\n        setLocationManagerStatus(AVAILABLE);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionSuspended(int i) {\r\n        setLocationManagerStatus(TEMPORARILY_UNAVAILABLE);\r\n    }\r\n\r\n    @Override\r\n    public void onConnectionFailed(ConnectionResult cr) {\r\n        setLocationManagerStatus(OUT_OF_SERVICE);\r\n    }\r\n\r\n\r\n    private void setLocationManagerStatus(final int status) {\r\n\r\n        int current = getStatus();\r\n        if (current != status) {\r\n            setStatus(status);\r\n            synchronized (this) {\r\n                Display.getInstance().callSerially(new Runnable() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        com.codename1.location.LocationListener l = getLocationListener();\r\n                        if (l != null) {\r\n                            l.providerStateChanged(status);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private PendingIntent geofencePendingIntent;\r\n\r\n    private PendingIntent createGeofencePendingIntent(Class geofenceListenerClass, com.codename1.location.Geofence gf, boolean forceService) {\r\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n\r\n\r\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            if (geofencePendingIntent != null) {\r\n                return geofencePendingIntent;\r\n            }\r\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\r\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_GEOFENCE_TRANSITIONS);\r\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + geofenceListenerClass.getName()));\r\n            //intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_GEOFENCE_TRANSITIONS);\r\n            geofencePendingIntent = AndroidImplementation.getBroadcastPendingIntent(AndroidNativeUtil.getContext().getApplicationContext(), 0, intent);\r\n            return geofencePendingIntent;\r\n        } else {\r\n\r\n            Intent intent = new Intent(context, GeofenceHandler.class);\r\n            intent.putExtra(\"geofenceClass\", geofenceListenerClass.getName());\r\n            intent.putExtra(\"geofenceID\", gf.getId());\r\n            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\r\n                    intent);\r\n\r\n\r\n            return pendingIntent;\r\n        }\r\n    }\r\n\r\n    @RequiresApi(api = 29)\r\n    private boolean checkBackgroundLocationPermission() {\r\n        if (!AndroidNativeUtil.checkForPermission(\"android.permission.ACCESS_BACKGROUND_LOCATION\", \"This is required to get the location\")) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void addGeoFencing(final Class GeofenceListenerClass, final com.codename1.location.Geofence gf) {\r\n        //Display.getInstance().scheduleBackgroundTask(new Runnable() {\r\n        boolean fineLocationAllowed = AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get location\");\r\n        if (fineLocationAllowed && android.os.Build.VERSION.SDK_INT >= 29) {\r\n\r\n            if (!checkBackgroundLocationPermission()) {\r\n                return;\r\n            }\r\n\r\n        } else if (!fineLocationAllowed) {\r\n            fineLocationAllowed = AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"This is required to get the location\");\r\n        }\r\n        if (!fineLocationAllowed) {\r\n            Log.e(new RuntimeException(\"Permission denied for geofence\"));\r\n            return;\r\n        }\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                //com.codename1.io.Log.p(\"PLACES add \"+gf.getId()+\" 1\");\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                //com.codename1.io.Log.p(\"PLACES add \"+gf.getId()+\" 2\");\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n                        Context context = AndroidNativeUtil.getContext().getApplicationContext();\r\n\r\n                        PendingIntent pendingIntent = createGeofencePendingIntent(GeofenceListenerClass, gf, false);\r\n                        final ArrayList<Geofence> geofences = new ArrayList<Geofence>();\r\n                        geofences.add(new Geofence.Builder()\r\n                                .setRequestId(gf.getId())\r\n                                .setCircularRegion(gf.getLoc().getLatitude(), gf.getLoc().getLongitude(), gf.getRadius())\r\n                                .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER\r\n                                        | Geofence.GEOFENCE_TRANSITION_EXIT)\r\n                                .setExpirationDuration(gf.getExpiration() > 0 ? gf.getExpiration() : Geofence.NEVER_EXPIRE)\r\n                                .build());\r\n\r\n                        GeofencingRequest.Builder builder = new GeofencingRequest.Builder();\r\n                        builder.setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER);\r\n                        builder.addGeofences(geofences);\r\n\r\n                        if (!AndroidNativeUtil.checkForPermission(Manifest.permission.ACCESS_FINE_LOCATION, \"Fine location permission required\")) {\r\n                            // TODO: Consider calling\r\n                            //    ActivityCompat#requestPermissions\r\n                            // here to request the missing permissions, and then overriding\r\n                            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                            //                                          int[] grantResults)\r\n                            // to handle the case where the user grants the permission. See the documentation\r\n                            // for ActivityCompat#requestPermissions for more details.\r\n                            System.out.println(\"No permission\");\r\n                            return;\r\n                        }\r\n                        geofencingClient = geofencingClient == null ? LocationServices.getGeofencingClient(AndroidNativeUtil.getContext().getApplicationContext()) :\r\n                                geofencingClient;\r\n                        geofencingClient.addGeofences(builder.build(), pendingIntent)\r\n                                .addOnSuccessListener(AndroidNativeUtil.getActivity(), new OnSuccessListener<Void>() {\r\n                                    @Override\r\n                                    public void onSuccess(Void aVoid) {\r\n                                        // Geofences added\r\n                                        // ...\r\n\r\n                                        //com.codename1.io.Log.p(\"Geofence added successfully \" + geofences);\r\n                                    }\r\n                                })\r\n                                .addOnFailureListener(AndroidNativeUtil.getActivity(), new OnFailureListener() {\r\n                                    @Override\r\n                                    public void onFailure(@NonNull Exception e) {\r\n                                        // Failed to add geofences\r\n                                        // ...\r\n                                        com.codename1.io.Log.e(e);\r\n                                    }\r\n                                });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    /**\r\n     * Stop tracking a Geofence if isGeofenceSupported() returns false this\r\n     * method does nothing\r\n     *\r\n     * @param id a Geofence id to stop tracking\r\n     */\r\n    public void removeGeoFencing(final String id) {\r\n        //Display.getInstance().scheduleBackgroundTask(new Runnable() {\r\n        Thread t = new Thread(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                //wait until the client is connected, otherwise the call to\r\n                //requestLocationUpdates will fail\r\n                //com.codename1.io.Log.p(\"PLACES remove \"+id);\r\n                while (!getmGoogleApiClient().isConnected()) {\r\n                    try {\r\n                        Thread.sleep(300);\r\n                    } catch (Exception ex) {\r\n                    }\r\n                }\r\n                //com.codename1.io.Log.p(\"PLACES remove \"+id+\" 2\");\r\n                Handler mHandler = new Handler(Looper.getMainLooper());\r\n                mHandler.post(new Runnable() {\r\n\r\n                    public void run() {\r\n\r\n                        ArrayList<String> ids = new ArrayList<String>();\r\n                        ids.add(id);\r\n                        geofencingClient = geofencingClient == null ? LocationServices.getGeofencingClient(AndroidNativeUtil.getContext().getApplicationContext()) :\r\n                                geofencingClient;\r\n                        geofencingClient.removeGeofences(ids);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);\r\n        t.start();\r\n    }\r\n\r\n    /**\r\n     * LifeCycle methods\r\n     *\r\n     */\r\n    @Override\r\n    public void onCreate(Bundle savedInstanceState) {\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        getmGoogleApiClient(); // This should initialize it if it isn't already.\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {\r\n            mGoogleApiClient.disconnect();\r\n        }\r\n        if (mGoogleApiClient != null) {\r\n            mGoogleApiClient = null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onSaveInstanceState(Bundle b) {\r\n    }\r\n\r\n    @Override\r\n    public void onLowMemory() {\r\n    }\r\n\r\n    @Override\r\n    public boolean isGPSDetectionSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isBackgroundLocationSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isGeofenceSupported() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isGPSEnabled() {\r\n        Context context = AndroidNativeUtil.getContext();\r\n        android.location.LocationManager locationManager = (android.location.LocationManager) context.getSystemService(Context.LOCATION_SERVICE);\r\n        return locationManager.isProviderEnabled(android.location.LocationManager.GPS_PROVIDER);\r\n    }\r\n\r\n    /**\r\n     * @return the mGoogleApiClient\r\n     */\r\n    private GoogleApiClient getmGoogleApiClient() {\r\n        if (mGoogleApiClient == null) {\r\n            mGoogleApiClient = new GoogleApiClient.Builder(AndroidNativeUtil.getContext())\r\n                    .addApi(LocationServices.API)\r\n                    .addConnectionCallbacks(this)\r\n                    .addOnConnectionFailedListener(this)\r\n                    .build();\r\n            if (!mGoogleApiClient.isConnected()) {\r\n                mGoogleApiClient.connect();\r\n            }\r\n        }\r\n\r\n        return mGoogleApiClient;\r\n    }\r\n\r\n    /**\r\n     * @param mGoogleApiClient the mGoogleApiClient to set\r\n     */\r\n    private void setmGoogleApiClient(GoogleApiClient mGoogleApiClient) {\r\n        this.mGoogleApiClient = mGoogleApiClient;\r\n    }\r\n\r\n}", "/*\n * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Codename One designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *  \n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n * \n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n * \n * Please contact Codename One through http://www.codenameone.com/ if you \n * need additional information or have any questions.\n */\npackage com.codename1.media;\n\n\nimport android.app.Notification;\nimport android.app.NotificationChannel;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.os.Build;\n\nimport android.os.Bundle;\nimport android.os.ResultReceiver;\n//import android.support.annotation.NonNull;\n//import android.support.annotation.Nullable;\nimport android.support.v4.app.NotificationManagerCompat;\nimport android.support.v4.media.MediaBrowserCompat;\nimport android.support.v4.media.MediaBrowserServiceCompat;\nimport android.support.v4.media.MediaMetadataCompat;\nimport android.support.v4.app.NotificationCompat;\nimport android.support.v4.media.app.NotificationCompat.MediaStyle;\nimport android.support.v4.media.session.MediaButtonReceiver;\nimport android.support.v4.media.session.MediaSessionCompat;\nimport android.support.v4.media.session.PlaybackStateCompat;\n\nimport android.text.TextUtils;\n\nimport com.codename1.impl.android.AndroidImplementation;\nimport com.codename1.ui.Display;\n\n\nimport java.util.List;\n\n/**\n * A service used for communicating with the remote control (on the lock screen) for background\n * media.\n * @author shannah\n */\n\npublic class BackgroundAudioService extends MediaBrowserServiceCompat implements MediaPlayer.OnCompletionListener, AudioManager.OnAudioFocusChangeListener  {\n\n    public static final String COMMAND_EXAMPLE = \"command_example\";\n    private static final String TAG_FOREGROUND_SERVICE = \"FOREGROUND_SERVICE\";\n    private static BackgroundAudioService instance;\n    public static BackgroundAudioService getInstance() {\n        return instance;\n    }\n\n\n    //private MediaPlayer mMediaPlayer;\n    private MediaSessionCompat mMediaSessionCompat;\n\n    private BroadcastReceiver mNoisyReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            //if( mMediaPlayer != null && mMediaPlayer.isPlaying() ) {\n            if( RemoteControlCallback.isPlaying() ) {\n                RemoteControlCallback.pause();\n                initMediaSession();\n                showPausedNotification();\n            }\n        }\n    };\n\n\n\n    private MediaSessionCompat.Callback mMediaSessionCallback = new MediaSessionCompat.Callback() {\n\n        @Override\n        public boolean onMediaButtonEvent(Intent mediaButtonEvent) {\n            return super.onMediaButtonEvent(mediaButtonEvent);\n        }\n\n        @Override\n        public void onPlay() {\n            //super.onPlay();\n            if( !successfullyRetrievedAudioFocus() ) {\n                return;\n            }\n\n            mMediaSessionCompat.setActive(true);\n            setMediaPlaybackState(PlaybackStateCompat.STATE_PLAYING);\n\n\n            //mMediaPlayer.start();\n            RemoteControlCallback.play();\n            initMediaSessionMetadata();\n            showPlayingNotification();\n        }\n\n        @Override\n        public void onPause() {\n            //super.onPause();\n\n            if( RemoteControlCallback.isPlaying()) {\n                //mMediaPlayer.pause();\n                RemoteControlCallback.pause();\n                setMediaPlaybackState(PlaybackStateCompat.STATE_PAUSED);\n                showPausedNotification();\n            }\n        }\n\n        @Override\n        public void onPlayFromMediaId(String mediaId, Bundle extras) {\n            super.onPlayFromMediaId(mediaId, extras);\n        }\n\n        @Override\n        public void onFastForward() {\n            super.onFastForward();\n            RemoteControlCallback.fastForward();\n        }\n\n        @Override\n        public void onRewind() {\n            super.onRewind();\n            RemoteControlCallback.rewind();\n        }\n\n        @Override\n        public void onSkipToNext() {\n            super.onSkipToNext();\n            RemoteControlCallback.skipToNext();\n        }\n\n        @Override\n        public void onSkipToPrevious() {\n            super.onSkipToPrevious();\n            RemoteControlCallback.skipToPrevious();\n        }\n\n        @Override\n        public void onStop() {\n            super.onStop();\n            RemoteControlCallback.stop();\n            initMediaSessionMetadata();\n            showPausedNotification();\n        }\n        \n\n\n        @Override\n        public void onCommand(String command, Bundle extras, ResultReceiver cb) {\n            super.onCommand(command, extras, cb);\n            if( COMMAND_EXAMPLE.equalsIgnoreCase(command) ) {\n                //Custom command here\n            }\n        }\n\n        @Override\n        public void onSeekTo(long pos) {\n            super.onSeekTo(pos);\n            RemoteControlCallback.seekTo(pos);\n        }\n\n    };\n\n    @Override\n    public void onCreate() {\n        instance = this;\n        super.onCreate();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);\n        if( builder != null ) {\n            startForeground(1, builder.build());\n        }\n        //initMediaPlayer();\n        initMediaSession();\n        initNoisyReceiver();\n    }\n\n    private void initNoisyReceiver() {\n        //Handles headphones coming unplugged. cannot be done through a manifest receiver\n        IntentFilter filter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);\n        registerReceiver(mNoisyReceiver, filter);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n        audioManager.abandonAudioFocus(this);\n        unregisterReceiver(mNoisyReceiver);\n        mMediaSessionCompat.release();\n        NotificationManagerCompat.from(this).cancel(1);\n        stopForeground(true);\n    }\n\n   \n\n    void showPlayingNotification() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n        NotificationCompat.Builder builder = MediaStyleHelper.from(BackgroundAudioService.this, mMediaSessionCompat);\n        if( builder == null ) {\n            return;\n        }\n\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_previous, \"Prev\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_pause, \"Pause\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_PLAY_PAUSE)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_next, \"Next\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_NEXT)));\n\n\n\n        builder.setStyle(new MediaStyle()\n                .setShowActionsInCompactView(0, 1, 2)\n                .setShowCancelButton(true)\n                .setCancelButtonIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(\n                        this, PlaybackStateCompat.ACTION_STOP))\n                .setMediaSession(mMediaSessionCompat.getSessionToken()));\n        builder.setSmallIcon(android.R.drawable.stat_notify_sync);\n        Notification notification = builder.build();\n\n        NotificationManagerCompat.from(BackgroundAudioService.this).notify(1, notification);\n    }\n\n    void showPausedNotification() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            createChannel();\n        }\n        NotificationCompat.Builder builder = MediaStyleHelper.from(this, mMediaSessionCompat);\n        if( builder == null ) {\n            return;\n        }\n\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_previous, \"Prev\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_play, \"Play\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_PLAY_PAUSE)));\n        builder.addAction(new NotificationCompat.Action(android.R.drawable.ic_media_next, \"Next\", MediaButtonReceiver.buildMediaButtonPendingIntent(this, PlaybackStateCompat.ACTION_SKIP_TO_NEXT)));\n\n\n        builder.setStyle(new MediaStyle().setShowActionsInCompactView(0, 1, 2).setMediaSession(mMediaSessionCompat.getSessionToken()));\n        builder.setSmallIcon(android.R.drawable.stat_notify_sync);\n        Notification notification = builder.build();\n\n        NotificationManagerCompat.from(this).notify(1, notification);\n    }\n\n\n    private void initMediaSession() {\n        ComponentName mediaButtonReceiver = new ComponentName(getApplicationContext(), MediaButtonReceiver.class);\n        mMediaSessionCompat = new MediaSessionCompat(getApplicationContext(), \"Tag\", mediaButtonReceiver, null);\n\n        mMediaSessionCompat.setCallback(mMediaSessionCallback);\n        mMediaSessionCompat.setFlags( MediaSessionCompat.FLAG_HANDLES_QUEUE_COMMANDS | MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS );\n\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        mediaButtonIntent.setClass(this, MediaButtonReceiver.class);\n        PendingIntent pendingIntent = AndroidImplementation.getBroadcastPendingIntent(this, 0, mediaButtonIntent);\n        mMediaSessionCompat.setMediaButtonReceiver(pendingIntent);\n\n        setSessionToken(mMediaSessionCompat.getSessionToken());\n    }\n\n    private void setMediaPlaybackState(int state) {\n        PlaybackStateCompat.Builder playbackstateBuilder = new PlaybackStateCompat.Builder();\n        if( state == PlaybackStateCompat.STATE_PLAYING ) {\n            playbackstateBuilder.setActions(PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PAUSE | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS);\n        } else {\n            playbackstateBuilder.setActions(PlaybackStateCompat.ACTION_PLAY_PAUSE | PlaybackStateCompat.ACTION_PLAY | PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS);\n        }\n        playbackstateBuilder.setState(state, PlaybackStateCompat.PLAYBACK_POSITION_UNKNOWN, 0);\n        mMediaSessionCompat.setPlaybackState(playbackstateBuilder.build());\n    }\n\n    void initMediaSessionMetadata() {\n        MediaMetadataCompat.Builder metadataBuilder = new MediaMetadataCompat.Builder();\n        //Notification icon in card\n        MediaMetaData md = RemoteControlCallback.getMetaData();\n        if (md == null) {\n            \n            return;\n        }\n        if (md.getDisplayIcon() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, i);\n        }\n        if (md.getAlbumArt() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, i);\n        }\n\n        //lock screen icon for pre lollipop\n        if (md.getArt() != null) {\n            Bitmap i = (Bitmap)md.getDisplayIcon().getImage();\n            metadataBuilder.putBitmap(MediaMetadataCompat.METADATA_KEY_ART, i);\n        }\n        \n        metadataBuilder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE, md.getTitle());\n        metadataBuilder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_SUBTITLE, md.getSubtitle());\n        metadataBuilder.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, md.getTrackNumber());\n        metadataBuilder.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, md.getNumTracks());\n\n        mMediaSessionCompat.setMetadata(metadataBuilder.build());\n    }\n\n    private boolean successfullyRetrievedAudioFocus() {\n        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n\n        int result = audioManager.requestAudioFocus(this,\n                AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);\n\n        return result == AudioManager.AUDIOFOCUS_GAIN;\n    }\n\n\n    //Not important for general audio service, required for class\n    //@Nullable\n    @Override\n    public BrowserRoot onGetRoot( String clientPackageName, int clientUid,  Bundle rootHints) {\n        if(TextUtils.equals(clientPackageName, getPackageName())) {\n            return new BrowserRoot(Display.getInstance().getProperty(\"AppName\", \"CodenameOne\"), null);\n        }\n\n        return null;\n    }\n\n    //Not important for general audio service, required for class\n    @Override\n    public void onLoadChildren(String parentId, Result<List<MediaBrowserCompat.MediaItem>> result) {\n        result.sendResult(null);\n    }\n\n    @Override\n    public void onAudioFocusChange(int focusChange) {\n        switch( focusChange ) {\n            case AudioManager.AUDIOFOCUS_LOSS: {\n                if( RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.stop();\n                    initMediaSessionMetadata();\n                    showPausedNotification();\n                }\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: {\n                RemoteControlCallback.pause();\n                initMediaSessionMetadata();\n                showPausedNotification();\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: {\n                if( RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.setVolume(0.3f, 0.3f);\n                }\n                break;\n            }\n            case AudioManager.AUDIOFOCUS_GAIN: {\n                \n                if( !RemoteControlCallback.isPlaying() ) {\n                    RemoteControlCallback.play();\n                    initMediaSessionMetadata();\n                    showPlayingNotification();\n                }\n                RemoteControlCallback.setVolume(1.0f, 1.0f);\n                \n                break;\n            }\n        }\n    }\n\n    @Override\n    public void onCompletion(MediaPlayer mediaPlayer) {\n        \n        /*\n        if( mediaPlayer != null ) {\n            mMediaPlayer.release();\n        }\n*/\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        MediaButtonReceiver.handleIntent(mMediaSessionCompat, intent);\n        return super.onStartCommand(intent, flags, startId);\n    }\n    \n    static final String CHANNEL_ID = \"media_playback_channel\";\n\n    @android.support.annotation.RequiresApi(Build.VERSION_CODES.O)\n    private  void createChannel() {\n        createChannelStatic(this);\n    }\n\n\n\n    @android.support.annotation.RequiresApi(Build.VERSION_CODES.O)\n    static void createChannelStatic(Context ctx) {\n        NotificationManager\n                mNotificationManager =\n                (NotificationManager) ctx\n                        .getSystemService(Context.NOTIFICATION_SERVICE);\n        // The id of the channel.\n        String id = CHANNEL_ID;\n        // The user-visible name of the channel.\n        CharSequence name = \"Media playback\";\n        // The user-visible description of the channel.\n        String description = \"Media playback controls\";\n        int importance = NotificationManager.IMPORTANCE_LOW;\n        NotificationChannel mChannel = new NotificationChannel(id, name, importance);\n        // Configure the notification channel.\n        mChannel.setDescription(description);\n        mChannel.setShowBadge(false);\n        mChannel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);\n        mNotificationManager.createNotificationChannel(mChannel);\n    }\n}"], "filenames": ["Ports/Android/src/com/codename1/impl/android/AndroidImplementation.java", "Ports/Android/src/com/codename1/impl/android/CodenameOneActivity.java", "Ports/Android/src/com/codename1/impl/android/PushNotificationService.java", "Ports/Android/src/com/codename1/location/AndroidLocationPlayServiceManager.java", "Ports/Android/src/com/codename1/media/BackgroundAudioService.java"], "buggy_code_start_loc": [778, 431, 106, 192, 55], "buggy_code_end_loc": [10466, 440, 120, 494, 283], "fixing_code_start_loc": [778, 431, 106, 192, 56], "fixing_code_end_loc": [10494, 440, 121, 490, 281], "type": "CWE-668", "message": "A vulnerability was found in CodenameOne 7.0.70. It has been classified as problematic. Affected is an unknown function. The manipulation leads to use of implicit intent for sensitive communication. It is possible to launch the attack remotely. Upgrading to version 7.0.71 is able to address this issue. The name of the patch is dad49c9ef26a598619fc48d2697151a02987d478. It is recommended to upgrade the affected component. VDB-220470 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4903", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-10T15:15:11.717", "lastModified": "2023-02-16T21:25:34.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in CodenameOne 7.0.70. It has been classified as problematic. Affected is an unknown function. The manipulation leads to use of implicit intent for sensitive communication. It is possible to launch the attack remotely. Upgrading to version 7.0.71 is able to address this issue. The name of the patch is dad49c9ef26a598619fc48d2697151a02987d478. It is recommended to upgrade the affected component. VDB-220470 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-927"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:codenameone:codename_one:7.0.70:*:*:*:*:*:*:*", "matchCriteriaId": "701DEA65-7129-4877-B7E3-2CF2B3295648"}]}]}], "references": [{"url": "https://github.com/codenameone/CodenameOne/commit/dad49c9ef26a598619fc48d2697151a02987d478", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/codenameone/CodenameOne/issues/3583", "source": "cna@vuldb.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/codenameone/CodenameOne/releases/tag/7.0.71", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220470", "source": "cna@vuldb.com", "tags": ["Broken Link"]}, {"url": "https://vuldb.com/?id.220470", "source": "cna@vuldb.com", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/codenameone/CodenameOne/commit/dad49c9ef26a598619fc48d2697151a02987d478"}}