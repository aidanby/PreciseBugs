{"buggy_code": ["/*\n * usbmidi.c - ALSA USB MIDI driver\n *\n * Copyright (c) 2002-2009 Clemens Ladisch\n * All rights reserved.\n *\n * Based on the OSS usb-midi driver by NAGANO Daisuke,\n *          NetBSD's umidi driver by Takuya SHIOZAKI,\n *          the \"USB Device Class Definition for MIDI Devices\" by Roland\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed and/or modified under the\n * terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/usb/audio.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/rawmidi.h>\n#include <sound/asequencer.h>\n#include \"usbaudio.h\"\n#include \"midi.h\"\n#include \"power.h\"\n#include \"helper.h\"\n\n/*\n * define this to log all USB packets\n */\n/* #define DUMP_PACKETS */\n\n/*\n * how long to wait after some USB errors, so that hub_wq can disconnect() us\n * without too many spurious errors\n */\n#define ERROR_DELAY_JIFFIES (HZ / 10)\n\n#define OUTPUT_URBS 7\n#define INPUT_URBS 7\n\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"USB Audio/MIDI helper module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n\nstruct usb_ms_header_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDescriptorSubtype;\n\t__u8  bcdMSC[2];\n\t__le16 wTotalLength;\n} __attribute__ ((packed));\n\nstruct usb_ms_endpoint_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDescriptorSubtype;\n\t__u8  bNumEmbMIDIJack;\n\t__u8  baAssocJackID[0];\n} __attribute__ ((packed));\n\nstruct snd_usb_midi_in_endpoint;\nstruct snd_usb_midi_out_endpoint;\nstruct snd_usb_midi_endpoint;\n\nstruct usb_protocol_ops {\n\tvoid (*input)(struct snd_usb_midi_in_endpoint*, uint8_t*, int);\n\tvoid (*output)(struct snd_usb_midi_out_endpoint *ep, struct urb *urb);\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t);\n\tvoid (*init_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n\tvoid (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n};\n\nstruct snd_usb_midi {\n\tstruct usb_device *dev;\n\tstruct snd_card *card;\n\tstruct usb_interface *iface;\n\tconst struct snd_usb_audio_quirk *quirk;\n\tstruct snd_rawmidi *rmidi;\n\tconst struct usb_protocol_ops *usb_protocol_ops;\n\tstruct list_head list;\n\tstruct timer_list error_timer;\n\tspinlock_t disc_lock;\n\tstruct rw_semaphore disc_rwsem;\n\tstruct mutex mutex;\n\tu32 usb_id;\n\tint next_midi_device;\n\n\tstruct snd_usb_midi_endpoint {\n\t\tstruct snd_usb_midi_out_endpoint *out;\n\t\tstruct snd_usb_midi_in_endpoint *in;\n\t} endpoints[MIDI_MAX_ENDPOINTS];\n\tunsigned long input_triggered;\n\tunsigned int opened[2];\n\tunsigned char disconnected;\n\tunsigned char input_running;\n\n\tstruct snd_kcontrol *roland_load_ctl;\n};\n\nstruct snd_usb_midi_out_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct out_urb_context {\n\t\tstruct urb *urb;\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t} urbs[OUTPUT_URBS];\n\tunsigned int active_urbs;\n\tunsigned int drain_urbs;\n\tint max_transfer;\t\t/* size of urb buffer */\n\tstruct tasklet_struct tasklet;\n\tunsigned int next_urb;\n\tspinlock_t buffer_lock;\n\n\tstruct usbmidi_out_port {\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tint active;\n\t\tuint8_t cable;\t\t/* cable number << 4 */\n\t\tuint8_t state;\n#define STATE_UNKNOWN\t0\n#define STATE_1PARAM\t1\n#define STATE_2PARAM_1\t2\n#define STATE_2PARAM_2\t3\n#define STATE_SYSEX_0\t4\n#define STATE_SYSEX_1\t5\n#define STATE_SYSEX_2\t6\n\t\tuint8_t data[2];\n\t} ports[0x10];\n\tint current_port;\n\n\twait_queue_head_t drain_wait;\n};\n\nstruct snd_usb_midi_in_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct urb *urbs[INPUT_URBS];\n\tstruct usbmidi_in_port {\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tu8 running_status_length;\n\t} ports[0x10];\n\tu8 seen_f5;\n\tbool in_sysex;\n\tu8 last_cin;\n\tu8 error_resubmit;\n\tint current_port;\n};\n\nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep);\n\nstatic const uint8_t snd_usbmidi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n/*\n * Submits the URB, with error handling.\n */\nstatic int snd_usbmidi_submit_urb(struct urb *urb, gfp_t flags)\n{\n\tint err = usb_submit_urb(urb, flags);\n\tif (err < 0 && err != -ENODEV)\n\t\tdev_err(&urb->dev->dev, \"usb_submit_urb: %d\\n\", err);\n\treturn err;\n}\n\n/*\n * Error handling for URB completion functions.\n */\nstatic int snd_usbmidi_urb_error(const struct urb *urb)\n{\n\tswitch (urb->status) {\n\t/* manually unlinked, or device gone */\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\tcase -ENODEV:\n\t\treturn -ENODEV;\n\t/* errors that might occur during unplugging */\n\tcase -EPROTO:\n\tcase -ETIME:\n\tcase -EILSEQ:\n\t\treturn -EIO;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"urb status %d\\n\", urb->status);\n\t\treturn 0; /* continue */\n\t}\n}\n\n/*\n * Receives a chunk of MIDI data.\n */\nstatic void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   int portidx, uint8_t *data, int length)\n{\n\tstruct usbmidi_in_port *port = &ep->ports[portidx];\n\n\tif (!port->substream) {\n\t\tdev_dbg(&ep->umidi->dev->dev, \"unexpected port %d!\\n\", portidx);\n\t\treturn;\n\t}\n\tif (!test_bit(port->substream->number, &ep->umidi->input_triggered))\n\t\treturn;\n\tsnd_rawmidi_receive(port->substream, data, length);\n}\n\n#ifdef DUMP_PACKETS\nstatic void dump_urb(const char *type, const u8 *data, int length)\n{\n\tsnd_printk(KERN_DEBUG \"%s packet: [\", type);\n\tfor (; length > 0; ++data, --length)\n\t\tprintk(\" %02x\", *data);\n\tprintk(\" ]\\n\");\n}\n#else\n#define dump_urb(type, data, length) /* nothing */\n#endif\n\n/*\n * Processes the data read from the device.\n */\nstatic void snd_usbmidi_in_urb_complete(struct urb *urb)\n{\n\tstruct snd_usb_midi_in_endpoint *ep = urb->context;\n\n\tif (urb->status == 0) {\n\t\tdump_urb(\"received\", urb->transfer_buffer, urb->actual_length);\n\t\tep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,\n\t\t\t\t\t\t   urb->actual_length);\n\t} else {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV) {\n\t\t\t\tep->error_resubmit = 1;\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\turb->dev = ep->umidi->dev;\n\tsnd_usbmidi_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void snd_usbmidi_out_urb_complete(struct urb *urb)\n{\n\tstruct out_urb_context *context = urb->context;\n\tstruct snd_usb_midi_out_endpoint *ep = context->ep;\n\tunsigned int urb_index;\n\n\tspin_lock(&ep->buffer_lock);\n\turb_index = context - ep->urbs;\n\tep->active_urbs &= ~(1 << urb_index);\n\tif (unlikely(ep->drain_urbs)) {\n\t\tep->drain_urbs &= ~(1 << urb_index);\n\t\twake_up(&ep->drain_wait);\n\t}\n\tspin_unlock(&ep->buffer_lock);\n\tif (urb->status < 0) {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\treturn;\n\t\t}\n\t}\n\tsnd_usbmidi_do_output(ep);\n}\n\n/*\n * This is called when some data should be transferred to the device\n * (from one or more substreams).\n */\nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int urb_index;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->buffer_lock, flags);\n\tif (ep->umidi->disconnected) {\n\t\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n\t\treturn;\n\t}\n\n\turb_index = ep->next_urb;\n\tfor (;;) {\n\t\tif (!(ep->active_urbs & (1 << urb_index))) {\n\t\t\turb = ep->urbs[urb_index].urb;\n\t\t\turb->transfer_buffer_length = 0;\n\t\t\tep->umidi->usb_protocol_ops->output(ep, urb);\n\t\t\tif (urb->transfer_buffer_length == 0)\n\t\t\t\tbreak;\n\n\t\t\tdump_urb(\"sending\", urb->transfer_buffer,\n\t\t\t\t urb->transfer_buffer_length);\n\t\t\turb->dev = ep->umidi->dev;\n\t\t\tif (snd_usbmidi_submit_urb(urb, GFP_ATOMIC) < 0)\n\t\t\t\tbreak;\n\t\t\tep->active_urbs |= 1 << urb_index;\n\t\t}\n\t\tif (++urb_index >= OUTPUT_URBS)\n\t\t\turb_index = 0;\n\t\tif (urb_index == ep->next_urb)\n\t\t\tbreak;\n\t}\n\tep->next_urb = urb_index;\n\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n}\n\nstatic void snd_usbmidi_out_tasklet(unsigned long data)\n{\n\tstruct snd_usb_midi_out_endpoint *ep =\n\t\t(struct snd_usb_midi_out_endpoint *) data;\n\n\tsnd_usbmidi_do_output(ep);\n}\n\n/* called after transfers had been interrupted due to some USB error */\nstatic void snd_usbmidi_error_timer(unsigned long data)\n{\n\tstruct snd_usb_midi *umidi = (struct snd_usb_midi *)data;\n\tunsigned int i, j;\n\n\tspin_lock(&umidi->disc_lock);\n\tif (umidi->disconnected) {\n\t\tspin_unlock(&umidi->disc_lock);\n\t\treturn;\n\t}\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_in_endpoint *in = umidi->endpoints[i].in;\n\t\tif (in && in->error_resubmit) {\n\t\t\tin->error_resubmit = 0;\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j) {\n\t\t\t\tif (atomic_read(&in->urbs[j]->use_count))\n\t\t\t\t\tcontinue;\n\t\t\t\tin->urbs[j]->dev = umidi->dev;\n\t\t\t\tsnd_usbmidi_submit_urb(in->urbs[j], GFP_ATOMIC);\n\t\t\t}\n\t\t}\n\t\tif (umidi->endpoints[i].out)\n\t\t\tsnd_usbmidi_do_output(umidi->endpoints[i].out);\n\t}\n\tspin_unlock(&umidi->disc_lock);\n}\n\n/* helper function to send static data that may not DMA-able */\nstatic int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t const void *data, int len)\n{\n\tint err = 0;\n\tvoid *buf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tdump_urb(\"sending\", buf, len);\n\tif (ep->urbs[0].urb)\n\t\terr = usb_bulk_msg(ep->umidi->dev, ep->urbs[0].urb->pipe,\n\t\t\t\t   buf, len, NULL, 250);\n\tkfree(buf);\n\treturn err;\n}\n\n/*\n * Standard USB MIDI protocol: see the spec.\n * Midiman protocol: like the standard protocol, but the control byte is the\n * fourth byte in each packet, and uses length instead of CIN.\n */\n\nstatic void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tint length = snd_usbmidi_cin_length[buffer[i] & 0x0f];\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\nstatic void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t      uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i + 3] != 0) {\n\t\t\tint port = buffer[i + 3] >> 4;\n\t\t\tint length = buffer[i + 3] & 3;\n\t\t\tsnd_usbmidi_input_data(ep, port, &buffer[i], length);\n\t\t}\n}\n\n/*\n * Buggy M-Audio device: running status on input results in a packet that has\n * the data bytes but not the status byte and that is marked with CIN 4.\n */\nstatic void snd_usbmidi_maudio_broken_running_status_input(\n\t\t\t\t\tstruct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t\tuint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tu8 cin = buffer[i] & 0x0f;\n\t\t\tstruct usbmidi_in_port *port = &ep->ports[cable];\n\t\t\tint length;\n\n\t\t\tlength = snd_usbmidi_cin_length[cin];\n\t\t\tif (cin == 0xf && buffer[i + 1] >= 0xf8)\n\t\t\t\t; /* realtime msg: no running status change */\n\t\t\telse if (cin >= 0x8 && cin <= 0xe)\n\t\t\t\t/* channel msg */\n\t\t\t\tport->running_status_length = length - 1;\n\t\t\telse if (cin == 0x4 &&\n\t\t\t\t port->running_status_length != 0 &&\n\t\t\t\t buffer[i + 1] < 0x80)\n\t\t\t\t/* CIN 4 that is not a SysEx */\n\t\t\t\tlength = port->running_status_length;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * All other msgs cannot begin running status.\n\t\t\t\t * (A channel msg sent as two or three CIN 0xF\n\t\t\t\t * packets could in theory, but this device\n\t\t\t\t * doesn't use this format.)\n\t\t\t\t */\n\t\t\t\tport->running_status_length = 0;\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\n/*\n * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4\n * but the previously seen CIN, but still with three data bytes.\n */\nstatic void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tunsigned int i, cin, length;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4) {\n\t\tif (buffer[i] == 0 && i > 0)\n\t\t\tbreak;\n\t\tcin = buffer[i] & 0x0f;\n\t\tif (ep->in_sysex &&\n\t\t    cin == ep->last_cin &&\n\t\t    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)\n\t\t\tcin = 0x4;\n#if 0\n\t\tif (buffer[i + 1] == 0x90) {\n\t\t\t/*\n\t\t\t * Either a corrupted running status or a real note-on\n\t\t\t * message; impossible to detect reliably.\n\t\t\t */\n\t\t}\n#endif\n\t\tlength = snd_usbmidi_cin_length[cin];\n\t\tsnd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);\n\t\tep->in_sysex = cin == 0x4;\n\t\tif (!ep->in_sysex)\n\t\t\tep->last_cin = cin;\n\t}\n}\n\n/*\n * CME protocol: like the standard protocol, but SysEx commands are sent as a\n * single USB packet preceded by a 0x0F byte.\n */\nstatic void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || (buffer[0] & 0x0f) != 0x0f)\n\t\tsnd_usbmidi_standard_input(ep, buffer, buffer_length);\n\telse\n\t\tsnd_usbmidi_input_data(ep, buffer[0] >> 4,\n\t\t\t\t       &buffer[1], buffer_length - 1);\n}\n\n/*\n * Adds one USB MIDI packet to the output buffer.\n */\nstatic void snd_usbmidi_output_standard_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t       uint8_t p1, uint8_t p2,\n\t\t\t\t\t       uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p0;\n\tbuf[1] = p1;\n\tbuf[2] = p2;\n\tbuf[3] = p3;\n\turb->transfer_buffer_length += 4;\n}\n\n/*\n * Adds one Midiman packet to the output buffer.\n */\nstatic void snd_usbmidi_output_midiman_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t      uint8_t p1, uint8_t p2,\n\t\t\t\t\t      uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p1;\n\tbuf[1] = p2;\n\tbuf[2] = p3;\n\tbuf[3] = (p0 & 0xf0) | snd_usbmidi_cin_length[p0 & 0x0f];\n\turb->transfer_buffer_length += 4;\n}\n\n/*\n * Converts MIDI commands to USB MIDI packets.\n */\nstatic void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port,\n\t\t\t\t      uint8_t b, struct urb *urb)\n{\n\tuint8_t p0 = port->cable;\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t) =\n\t\tport->ep->umidi->usb_protocol_ops->output_packet;\n\n\tif (b >= 0xf8) {\n\t\toutput_packet(urb, p0 | 0x0f, b, 0, 0);\n\t} else if (b >= 0xf0) {\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\toutput_packet(urb, p0 | 0x05, 0xf6, 0, 0);\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf7:\n\t\t\tswitch (port->state) {\n\t\t\tcase STATE_SYSEX_0:\n\t\t\t\toutput_packet(urb, p0 | 0x05, 0xf7, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_1:\n\t\t\t\toutput_packet(urb, p0 | 0x06, port->data[0],\n\t\t\t\t\t      0xf7, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_2:\n\t\t\t\toutput_packet(urb, p0 | 0x07, port->data[0],\n\t\t\t\t\t      port->data[1], 0xf7);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else if (b >= 0x80) {\n\t\tport->data[0] = b;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tport->state = STATE_1PARAM;\n\t\telse\n\t\t\tport->state = STATE_2PARAM_1;\n\t} else { /* b < 0x80 */\n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x02;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], b, 0);\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t\tport->state = STATE_2PARAM_1;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x03;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], port->data[1], b);\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\toutput_packet(urb, p0 | 0x04, port->data[0],\n\t\t\t\t      port->data[1], b);\n\t\t\tport->state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tint p;\n\n\t/* FIXME: lower-numbered ports can starve higher-numbered ports */\n\tfor (p = 0; p < 0x10; ++p) {\n\t\tstruct usbmidi_out_port *port = &ep->ports[p];\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\twhile (urb->transfer_buffer_length + 3 < ep->max_transfer) {\n\t\t\tuint8_t b;\n\t\t\tif (snd_rawmidi_transmit(port->substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnd_usbmidi_transmit_byte(port, b, urb);\n\t\t}\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_standard_ops = {\n\t.input = snd_usbmidi_standard_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_midiman_ops = {\n\t.input = snd_usbmidi_midiman_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_midiman_packet,\n};\n\nstatic const\nstruct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {\n\t.input = snd_usbmidi_maudio_broken_running_status_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_cme_ops = {\n\t.input = snd_usbmidi_cme_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {\n\t.input = ch345_broken_sysex_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\n/*\n * AKAI MPD16 protocol:\n *\n * For control port (endpoint 1):\n * ==============================\n * One or more chunks consisting of first byte of (0x10 | msg_len) and then a\n * SysEx message (msg_len=9 bytes long).\n *\n * For data port (endpoint 2):\n * ===========================\n * One or more chunks consisting of first byte of (0x20 | msg_len) and then a\n * MIDI message (msg_len bytes long)\n *\n * Messages sent: Active Sense, Note On, Poly Pressure, Control Change.\n */\nstatic void snd_usbmidi_akai_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tunsigned int pos = 0;\n\tunsigned int len = (unsigned int)buffer_length;\n\twhile (pos < len) {\n\t\tunsigned int port = (buffer[pos] >> 4) - 1;\n\t\tunsigned int msg_len = buffer[pos] & 0x0f;\n\t\tpos++;\n\t\tif (pos + msg_len <= len && port < 2)\n\t\t\tsnd_usbmidi_input_data(ep, 0, &buffer[pos], msg_len);\n\t\tpos += msg_len;\n\t}\n}\n\n#define MAX_AKAI_SYSEX_LEN 9\n\nstatic void snd_usbmidi_akai_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t    struct urb *urb)\n{\n\tuint8_t *msg;\n\tint pos, end, count, buf_end;\n\tuint8_t tmp[MAX_AKAI_SYSEX_LEN];\n\tstruct snd_rawmidi_substream *substream = ep->ports[0].substream;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\n\tmsg = urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf_end = ep->max_transfer - MAX_AKAI_SYSEX_LEN - 1;\n\n\t/* only try adding more data when there's space for at least 1 SysEx */\n\twhile (urb->transfer_buffer_length < buf_end) {\n\t\tcount = snd_rawmidi_transmit_peek(substream,\n\t\t\t\t\t\t  tmp, MAX_AKAI_SYSEX_LEN);\n\t\tif (!count) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t/* try to skip non-SysEx data */\n\t\tfor (pos = 0; pos < count && tmp[pos] != 0xF0; pos++)\n\t\t\t;\n\n\t\tif (pos > 0) {\n\t\t\tsnd_rawmidi_transmit_ack(substream, pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* look for the start or end marker */\n\t\tfor (end = 1; end < count && tmp[end] < 0xF0; end++)\n\t\t\t;\n\n\t\t/* next SysEx started before the end of current one */\n\t\tif (end < count && tmp[end] == 0xF0) {\n\t\t\t/* it's incomplete - drop it */\n\t\t\tsnd_rawmidi_transmit_ack(substream, end);\n\t\t\tcontinue;\n\t\t}\n\t\t/* SysEx complete */\n\t\tif (end < count && tmp[end] == 0xF7) {\n\t\t\t/* queue it, ack it, and get the next one */\n\t\t\tcount = end + 1;\n\t\t\tmsg[0] = 0x10 | count;\n\t\t\tmemcpy(&msg[1], tmp, count);\n\t\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t\t\turb->transfer_buffer_length += count + 1;\n\t\t\tmsg += count + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* less than 9 bytes and no end byte - wait for more */\n\t\tif (count < MAX_AKAI_SYSEX_LEN) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t/* 9 bytes and no end marker in sight - malformed, skip it */\n\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_akai_ops = {\n\t.input = snd_usbmidi_akai_input,\n\t.output = snd_usbmidi_akai_output,\n};\n\n/*\n * Novation USB MIDI protocol: number of data bytes is in the first byte\n * (when receiving) (+1!) or in the second byte (when sending); data begins\n * at the third byte.\n */\n\nstatic void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || !buffer[0] || buffer_length < buffer[0] + 1)\n\t\treturn;\n\tsnd_usbmidi_input_data(ep, 0, &buffer[2], buffer[0] - 1);\n}\n\nstatic void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tuint8_t *transfer_buffer;\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\ttransfer_buffer = urb->transfer_buffer;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     &transfer_buffer[2],\n\t\t\t\t     ep->max_transfer - 2);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\ttransfer_buffer[0] = 0;\n\ttransfer_buffer[1] = count;\n\turb->transfer_buffer_length = 2 + count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_novation_ops = {\n\t.input = snd_usbmidi_novation_input,\n\t.output = snd_usbmidi_novation_output,\n};\n\n/*\n * \"raw\" protocol: just move raw MIDI bytes from/to the endpoint\n */\n\nstatic void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t   struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     ep->max_transfer);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\turb->transfer_buffer_length = count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_raw_ops = {\n\t.input = snd_usbmidi_raw_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\n/*\n * FTDI protocol: raw MIDI bytes, but input packets have two modem status bytes.\n */\n\nstatic void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length > 2)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_ftdi_ops = {\n\t.input = snd_usbmidi_ftdi_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\nstatic void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length != 9)\n\t\treturn;\n\tbuffer_length = 8;\n\twhile (buffer_length && buffer[buffer_length - 1] == 0xFD)\n\t\tbuffer_length--;\n\tif (buffer_length)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tswitch (snd_usb_get_speed(ep->umidi->dev)) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tcount = 1;\n\t\tbreak;\n\tdefault:\n\t\tcount = 2;\n\t}\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     count);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\n\tmemset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);\n\turb->transfer_buffer_length = ep->max_transfer;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_122l_ops = {\n\t.input = snd_usbmidi_us122l_input,\n\t.output = snd_usbmidi_us122l_output,\n};\n\n/*\n * Emagic USB MIDI protocol: raw MIDI with \"F5 xx\" port switching.\n */\n\nstatic void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 init_data[] = {\n\t\t/* initialization magic: \"get version\" */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x0b,\t\t\t/* version number request */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x00,\t\t\t/* EEPROM, box 0 */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n\t/* while we're at it, pour on more magic */\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n}\n\nstatic void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 finish_data[] = {\n\t\t/* switch to patch mode with last preset */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x10,\t\t\t/* patch switch command */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x7f,\t\t\t/* to all boxes */\n\t\t0x40,\t\t\t/* last preset in EEPROM */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, finish_data, sizeof(finish_data));\n}\n\nstatic void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\t/* FF indicates end of valid data */\n\tfor (i = 0; i < buffer_length; ++i)\n\t\tif (buffer[i] == 0xff) {\n\t\t\tbuffer_length = i;\n\t\t\tbreak;\n\t\t}\n\n\t/* handle F5 at end of last buffer */\n\tif (ep->seen_f5)\n\t\tgoto switch_port;\n\n\twhile (buffer_length > 0) {\n\t\t/* determine size of data until next F5 */\n\t\tfor (i = 0; i < buffer_length; ++i)\n\t\t\tif (buffer[i] == 0xf5)\n\t\t\t\tbreak;\n\t\tsnd_usbmidi_input_data(ep, ep->current_port, buffer, i);\n\t\tbuffer += i;\n\t\tbuffer_length -= i;\n\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\t/* assert(buffer[0] == 0xf5); */\n\t\tep->seen_f5 = 1;\n\t\t++buffer;\n\t\t--buffer_length;\n\n\tswitch_port:\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\tif (buffer[0] < 0x80) {\n\t\t\tep->current_port = (buffer[0] - 1) & 15;\n\t\t\t++buffer;\n\t\t\t--buffer_length;\n\t\t}\n\t\tep->seen_f5 = 0;\n\t}\n}\n\nstatic void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint port0 = ep->current_port;\n\tuint8_t *buf = urb->transfer_buffer;\n\tint buf_free = ep->max_transfer;\n\tint length, i;\n\n\tfor (i = 0; i < 0x10; ++i) {\n\t\t/* round-robin, starting at the last current port */\n\t\tint portnum = (port0 + i) & 15;\n\t\tstruct usbmidi_out_port *port = &ep->ports[portnum];\n\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\tif (snd_rawmidi_transmit_peek(port->substream, buf, 1) != 1) {\n\t\t\tport->active = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (portnum != ep->current_port) {\n\t\t\tif (buf_free < 2)\n\t\t\t\tbreak;\n\t\t\tep->current_port = portnum;\n\t\t\tbuf[0] = 0xf5;\n\t\t\tbuf[1] = (portnum + 1) & 15;\n\t\t\tbuf += 2;\n\t\t\tbuf_free -= 2;\n\t\t}\n\n\t\tif (buf_free < 1)\n\t\t\tbreak;\n\t\tlength = snd_rawmidi_transmit(port->substream, buf, buf_free);\n\t\tif (length > 0) {\n\t\t\tbuf += length;\n\t\t\tbuf_free -= length;\n\t\t\tif (buf_free < 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (buf_free < ep->max_transfer && buf_free > 0) {\n\t\t*buf = 0xff;\n\t\t--buf_free;\n\t}\n\turb->transfer_buffer_length = ep->max_transfer - buf_free;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_emagic_ops = {\n\t.input = snd_usbmidi_emagic_input,\n\t.output = snd_usbmidi_emagic_output,\n\t.init_out_endpoint = snd_usbmidi_emagic_init_out,\n\t.finish_out_endpoint = snd_usbmidi_emagic_finish_out,\n};\n\n\nstatic void update_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tint is_light_load;\n\n\tintf = umidi->iface;\n\tis_light_load = intf->cur_altsetting != intf->altsetting;\n\tif (umidi->roland_load_ctl->private_value == is_light_load)\n\t\treturn;\n\thostif = &intf->altsetting[umidi->roland_load_ctl->private_value];\n\tintfd = get_iface_desc(hostif);\n\tsnd_usbmidi_input_stop(&umidi->list);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\tsnd_usbmidi_input_start(&umidi->list);\n}\n\nstatic int substream_open(struct snd_rawmidi_substream *substream, int dir,\n\t\t\t  int open)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct snd_kcontrol *ctl;\n\n\tdown_read(&umidi->disc_rwsem);\n\tif (umidi->disconnected) {\n\t\tup_read(&umidi->disc_rwsem);\n\t\treturn open ? -ENODEV : 0;\n\t}\n\n\tmutex_lock(&umidi->mutex);\n\tif (open) {\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access |=\n\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t\tupdate_roland_altsetting(umidi);\n\t\t\t}\n\t\t}\n\t\tumidi->opened[dir]++;\n\t\tif (umidi->opened[1])\n\t\t\tsnd_usbmidi_input_start(&umidi->list);\n\t} else {\n\t\tumidi->opened[dir]--;\n\t\tif (!umidi->opened[1])\n\t\t\tsnd_usbmidi_input_stop(&umidi->list);\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access &=\n\t\t\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&umidi->mutex);\n\tup_read(&umidi->disc_rwsem);\n\treturn 0;\n}\n\nstatic int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct usbmidi_out_port *port = NULL;\n\tint i, j;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tif (umidi->endpoints[i].out)\n\t\t\tfor (j = 0; j < 0x10; ++j)\n\t\t\t\tif (umidi->endpoints[i].out->ports[j].substream == substream) {\n\t\t\t\t\tport = &umidi->endpoints[i].out->ports[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\tif (!port) {\n\t\tsnd_BUG();\n\t\treturn -ENXIO;\n\t}\n\n\tsubstream->runtime->private_data = port;\n\tport->state = STATE_UNKNOWN;\n\treturn substream_open(substream, 0, 1);\n}\n\nstatic int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 0, 0);\n}\n\nstatic void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t       int up)\n{\n\tstruct usbmidi_out_port *port =\n\t\t(struct usbmidi_out_port *)substream->runtime->private_data;\n\n\tport->active = up;\n\tif (up) {\n\t\tif (port->ep->umidi->disconnected) {\n\t\t\t/* gobble up remaining bytes to prevent wait in\n\t\t\t * snd_rawmidi_drain_output */\n\t\t\twhile (!snd_rawmidi_transmit_empty(substream))\n\t\t\t\tsnd_rawmidi_transmit_ack(substream, 1);\n\t\t\treturn;\n\t\t}\n\t\ttasklet_schedule(&port->ep->tasklet);\n\t}\n}\n\nstatic void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct usbmidi_out_port *port = substream->runtime->private_data;\n\tstruct snd_usb_midi_out_endpoint *ep = port->ep;\n\tunsigned int drain_urbs;\n\tDEFINE_WAIT(wait);\n\tlong timeout = msecs_to_jiffies(50);\n\n\tif (ep->umidi->disconnected)\n\t\treturn;\n\t/*\n\t * The substream buffer is empty, but some data might still be in the\n\t * currently active URBs, so we have to wait for those to complete.\n\t */\n\tspin_lock_irq(&ep->buffer_lock);\n\tdrain_urbs = ep->active_urbs;\n\tif (drain_urbs) {\n\t\tep->drain_urbs |= drain_urbs;\n\t\tdo {\n\t\t\tprepare_to_wait(&ep->drain_wait, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ep->buffer_lock);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tspin_lock_irq(&ep->buffer_lock);\n\t\t\tdrain_urbs &= ep->drain_urbs;\n\t\t} while (drain_urbs && timeout);\n\t\tfinish_wait(&ep->drain_wait, &wait);\n\t}\n\tspin_unlock_irq(&ep->buffer_lock);\n}\n\nstatic int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 1);\n}\n\nstatic int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 0);\n}\n\nstatic void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int up)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\n\tif (up)\n\t\tset_bit(substream->number, &umidi->input_triggered);\n\telse\n\t\tclear_bit(substream->number, &umidi->input_triggered);\n}\n\nstatic struct snd_rawmidi_ops snd_usbmidi_output_ops = {\n\t.open = snd_usbmidi_output_open,\n\t.close = snd_usbmidi_output_close,\n\t.trigger = snd_usbmidi_output_trigger,\n\t.drain = snd_usbmidi_output_drain,\n};\n\nstatic struct snd_rawmidi_ops snd_usbmidi_input_ops = {\n\t.open = snd_usbmidi_input_open,\n\t.close = snd_usbmidi_input_close,\n\t.trigger = snd_usbmidi_input_trigger\n};\n\nstatic void free_urb_and_buffer(struct snd_usb_midi *umidi, struct urb *urb,\n\t\t\t\tunsigned int buffer_length)\n{\n\tusb_free_coherent(umidi->dev, buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\n/*\n * Frees an input endpoint.\n * May be called when ep hasn't been initialized completely.\n */\nstatic void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < INPUT_URBS; ++i)\n\t\tif (ep->urbs[i])\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i],\n\t\t\t\t\t    ep->urbs[i]->transfer_buffer_length);\n\tkfree(ep);\n}\n\n/*\n * Creates an input endpoint.\n */\nstatic int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t  struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t  struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_in_endpoint *ep;\n\tvoid *buffer;\n\tunsigned int pipe;\n\tint length;\n\tunsigned int i;\n\n\trep->in = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tep->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i]) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (ep_info->in_interval)\n\t\tpipe = usb_rcvintpipe(umidi->dev, ep_info->in_ep);\n\telse\n\t\tpipe = usb_rcvbulkpipe(umidi->dev, ep_info->in_ep);\n\tlength = usb_maxpacket(umidi->dev, pipe, 0);\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev, length, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i]->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ep_info->in_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t pipe, buffer, length,\n\t\t\t\t\t snd_usbmidi_in_urb_complete,\n\t\t\t\t\t ep, ep_info->in_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t  pipe, buffer, length,\n\t\t\t\t\t  snd_usbmidi_in_urb_complete, ep);\n\t\tep->urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\trep->in = ep;\n\treturn 0;\n}\n\n/*\n * Frees an output endpoint.\n * May be called when ep hasn't been initialized completely.\n */\nstatic void snd_usbmidi_out_endpoint_clear(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i)\n\t\tif (ep->urbs[i].urb) {\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i].urb,\n\t\t\t\t\t    ep->max_transfer);\n\t\t\tep->urbs[i].urb = NULL;\n\t\t}\n}\n\nstatic void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep)\n{\n\tsnd_usbmidi_out_endpoint_clear(ep);\n\tkfree(ep);\n}\n\n/*\n * Creates an output endpoint, and initializes output ports.\n */\nstatic int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t   struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t   struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_out_endpoint *ep;\n\tunsigned int i;\n\tunsigned int pipe;\n\tvoid *buffer;\n\n\trep->out = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tep->urbs[i].urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i].urb) {\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tep->urbs[i].ep = ep;\n\t}\n\tif (ep_info->out_interval)\n\t\tpipe = usb_sndintpipe(umidi->dev, ep_info->out_ep);\n\telse\n\t\tpipe = usb_sndbulkpipe(umidi->dev, ep_info->out_ep);\n\tswitch (umidi->usb_id) {\n\tdefault:\n\t\tep->max_transfer = usb_maxpacket(umidi->dev, pipe, 1);\n\t\tbreak;\n\t\t/*\n\t\t * Various chips declare a packet size larger than 4 bytes, but\n\t\t * do not actually work with larger packets:\n\t\t */\n\tcase USB_ID(0x0a67, 0x5011): /* Medeli DD305 */\n\tcase USB_ID(0x0a92, 0x1020): /* ESI M4U */\n\tcase USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */\n\tcase USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */\n\tcase USB_ID(0x15ca, 0x1806): /* Textech USB Midi Cable */\n\tcase USB_ID(0x1a86, 0x752d): /* QinHeng CH345 \"USB2.0-MIDI\" */\n\tcase USB_ID(0xfc08, 0x0101): /* Unknown vendor Cable */\n\t\tep->max_transfer = 4;\n\t\tbreak;\n\t\t/*\n\t\t * Some devices only work with 9 bytes packet size:\n\t\t */\n\tcase USB_ID(0x0644, 0x800E): /* Tascam US-122L */\n\tcase USB_ID(0x0644, 0x800F): /* Tascam US-144 */\n\t\tep->max_transfer = 9;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev,\n\t\t\t\t\t    ep->max_transfer, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i].urb->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ep_info->out_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t pipe, buffer, ep->max_transfer,\n\t\t\t\t\t snd_usbmidi_out_urb_complete,\n\t\t\t\t\t &ep->urbs[i], ep_info->out_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t  pipe, buffer, ep->max_transfer,\n\t\t\t\t\t  snd_usbmidi_out_urb_complete,\n\t\t\t\t\t  &ep->urbs[i]);\n\t\tep->urbs[i].urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\tspin_lock_init(&ep->buffer_lock);\n\ttasklet_init(&ep->tasklet, snd_usbmidi_out_tasklet, (unsigned long)ep);\n\tinit_waitqueue_head(&ep->drain_wait);\n\n\tfor (i = 0; i < 0x10; ++i)\n\t\tif (ep_info->out_cables & (1 << i)) {\n\t\t\tep->ports[i].ep = ep;\n\t\t\tep->ports[i].cable = i << 4;\n\t\t}\n\n\tif (umidi->usb_protocol_ops->init_out_endpoint)\n\t\tumidi->usb_protocol_ops->init_out_endpoint(ep);\n\n\trep->out = ep;\n\treturn 0;\n}\n\n/*\n * Frees everything.\n */\nstatic void snd_usbmidi_free(struct snd_usb_midi *umidi)\n{\n\tint i;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep->out);\n\t\tif (ep->in)\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t}\n\tmutex_destroy(&umidi->mutex);\n\tkfree(umidi);\n}\n\n/*\n * Unlinks all URBs (must be done before the usb_device is deleted).\n */\nvoid snd_usbmidi_disconnect(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\t/*\n\t * an URB's completion handler may start the timer and\n\t * a timer may submit an URB. To reliably break the cycle\n\t * a flag under lock must be used\n\t */\n\tdown_write(&umidi->disc_rwsem);\n\tspin_lock_irq(&umidi->disc_lock);\n\tumidi->disconnected = 1;\n\tspin_unlock_irq(&umidi->disc_lock);\n\tup_write(&umidi->disc_rwsem);\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\ttasklet_kill(&ep->out->tasklet);\n\t\tif (ep->out) {\n\t\t\tfor (j = 0; j < OUTPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->out->urbs[j].urb);\n\t\t\tif (umidi->usb_protocol_ops->finish_out_endpoint)\n\t\t\t\tumidi->usb_protocol_ops->finish_out_endpoint(ep->out);\n\t\t\tep->out->active_urbs = 0;\n\t\t\tif (ep->out->drain_urbs) {\n\t\t\t\tep->out->drain_urbs = 0;\n\t\t\t\twake_up(&ep->out->drain_wait);\n\t\t\t}\n\t\t}\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t\t/* free endpoints here; later call can result in Oops */\n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_clear(ep->out);\n\t\tif (ep->in) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t\t\tep->in = NULL;\n\t\t}\n\t}\n\tdel_timer_sync(&umidi->error_timer);\n}\nEXPORT_SYMBOL(snd_usbmidi_disconnect);\n\nstatic void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tsnd_usbmidi_free(umidi);\n}\n\nstatic struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t\t\tint stream,\n\t\t\t\t\t\t\t\tint number)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\tlist_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams,\n\t\t\t    list) {\n\t\tif (substream->number == number)\n\t\t\treturn substream;\n\t}\n\treturn NULL;\n}\n\n/*\n * This list specifies names for ports that do not fit into the standard\n * \"(product) MIDI (n)\" schema because they aren't external MIDI ports,\n * such as internal control or synthesizer ports.\n */\nstatic struct port_info {\n\tu32 id;\n\tshort int port;\n\tshort int voices;\n\tconst char *name;\n\tunsigned int seq_flags;\n} snd_usbmidi_port_info[] = {\n#define PORT_INFO(vendor, product, num, name_, voices_, flags) \\\n\t{ .id = USB_ID(vendor, product), \\\n\t  .port = num, .voices = voices_, \\\n\t  .name = name_, .seq_flags = flags }\n#define EXTERNAL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_PORT)\n#define CONTROL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE)\n#define GM_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define ROLAND_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define SOUNDCANVAS_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_MT32 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n\t/* Yamaha MOTIF XF */\n\tGM_SYNTH_PORT(0x0499, 0x105c, 0, \"%s Tone Generator\", 128),\n\tCONTROL_PORT(0x0499, 0x105c, 1, \"%s Remote Control\"),\n\tEXTERNAL_PORT(0x0499, 0x105c, 2, \"%s Thru\"),\n\tCONTROL_PORT(0x0499, 0x105c, 3, \"%s Editor\"),\n\t/* Roland UA-100 */\n\tCONTROL_PORT(0x0582, 0x0000, 2, \"%s Control\"),\n\t/* Roland SC-8850 */\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 0, \"%s Part A\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 1, \"%s Part B\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 2, \"%s Part C\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 3, \"%s Part D\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0003, 4, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0003, 5, \"%s MIDI 2\"),\n\t/* Roland U-8 */\n\tEXTERNAL_PORT(0x0582, 0x0004, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0004, 1, \"%s Control\"),\n\t/* Roland SC-8820 */\n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0007, 2, \"%s MIDI\"),\n\t/* Roland SK-500 */\n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000b, 2, \"%s MIDI\"),\n\t/* Roland SC-D70 */\n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000c, 2, \"%s MIDI\"),\n\t/* Edirol UM-880 */\n\tCONTROL_PORT(0x0582, 0x0014, 8, \"%s Control\"),\n\t/* Edirol SD-90 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0016, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0016, 3, \"%s MIDI 2\"),\n\t/* Edirol UM-550 */\n\tCONTROL_PORT(0x0582, 0x0023, 5, \"%s Control\"),\n\t/* Edirol SD-20 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 0, \"%s Part A\", 64),\n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0027, 2, \"%s MIDI\"),\n\t/* Edirol SD-80 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0029, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0029, 3, \"%s MIDI 2\"),\n\t/* Edirol UA-700 */\n\tEXTERNAL_PORT(0x0582, 0x002b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x002b, 1, \"%s Control\"),\n\t/* Roland VariOS */\n\tEXTERNAL_PORT(0x0582, 0x002f, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 1, \"%s External MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 2, \"%s Sync\"),\n\t/* Edirol PCR */\n\tEXTERNAL_PORT(0x0582, 0x0033, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 2, \"%s 2\"),\n\t/* BOSS GS-10 */\n\tEXTERNAL_PORT(0x0582, 0x003b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x003b, 1, \"%s Control\"),\n\t/* Edirol UA-1000 */\n\tEXTERNAL_PORT(0x0582, 0x0044, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0044, 1, \"%s Control\"),\n\t/* Edirol UR-80 */\n\tEXTERNAL_PORT(0x0582, 0x0048, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 2, \"%s 2\"),\n\t/* Edirol PCR-A */\n\tEXTERNAL_PORT(0x0582, 0x004d, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 2, \"%s 2\"),\n\t/* BOSS GT-PRO */\n\tCONTROL_PORT(0x0582, 0x0089, 0, \"%s Control\"),\n\t/* Edirol UM-3EX */\n\tCONTROL_PORT(0x0582, 0x009a, 3, \"%s Control\"),\n\t/* Roland VG-99 */\n\tCONTROL_PORT(0x0582, 0x00b2, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x00b2, 1, \"%s MIDI\"),\n\t/* Cakewalk Sonar V-Studio 100 */\n\tEXTERNAL_PORT(0x0582, 0x00eb, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x00eb, 1, \"%s Control\"),\n\t/* Roland VB-99 */\n\tCONTROL_PORT(0x0582, 0x0102, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0102, 1, \"%s MIDI\"),\n\t/* Roland A-PRO */\n\tEXTERNAL_PORT(0x0582, 0x010f, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x010f, 1, \"%s 1\"),\n\tCONTROL_PORT(0x0582, 0x010f, 2, \"%s 2\"),\n\t/* Roland SD-50 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0114, 0, \"%s Synth\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0114, 1, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0114, 2, \"%s Control\"),\n\t/* Roland OCTA-CAPTURE */\n\tEXTERNAL_PORT(0x0582, 0x0120, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0120, 1, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0121, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0121, 1, \"%s Control\"),\n\t/* Roland SPD-SX */\n\tCONTROL_PORT(0x0582, 0x0145, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0145, 1, \"%s MIDI\"),\n\t/* Roland A-Series */\n\tCONTROL_PORT(0x0582, 0x0156, 0, \"%s Keyboard\"),\n\tEXTERNAL_PORT(0x0582, 0x0156, 1, \"%s MIDI\"),\n\t/* Roland INTEGRA-7 */\n\tROLAND_SYNTH_PORT(0x0582, 0x015b, 0, \"%s Synth\", 128),\n\tCONTROL_PORT(0x0582, 0x015b, 1, \"%s Control\"),\n\t/* M-Audio MidiSport 8x8 */\n\tCONTROL_PORT(0x0763, 0x1031, 8, \"%s Control\"),\n\tCONTROL_PORT(0x0763, 0x1033, 8, \"%s Control\"),\n\t/* MOTU Fastlane */\n\tEXTERNAL_PORT(0x07fd, 0x0001, 0, \"%s MIDI A\"),\n\tEXTERNAL_PORT(0x07fd, 0x0001, 1, \"%s MIDI B\"),\n\t/* Emagic Unitor8/AMT8/MT4 */\n\tEXTERNAL_PORT(0x086a, 0x0001, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0002, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0003, 4, \"%s Broadcast\"),\n\t/* Akai MPD16 */\n\tCONTROL_PORT(0x09e8, 0x0062, 0, \"%s Control\"),\n\tPORT_INFO(0x09e8, 0x0062, 1, \"%s MIDI\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE),\n\t/* Access Music Virus TI */\n\tEXTERNAL_PORT(0x133e, 0x0815, 0, \"%s MIDI\"),\n\tPORT_INFO(0x133e, 0x0815, 1, \"%s Synth\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\tSNDRV_SEQ_PORT_TYPE_SYNTHESIZER),\n};\n\nstatic struct port_info *find_port_info(struct snd_usb_midi *umidi, int number)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_usbmidi_port_info); ++i) {\n\t\tif (snd_usbmidi_port_info[i].id == umidi->usb_id &&\n\t\t    snd_usbmidi_port_info[i].port == number)\n\t\t\treturn &snd_usbmidi_port_info[i];\n\t}\n\treturn NULL;\n}\n\nstatic void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi, int number,\n\t\t\t\t      struct snd_seq_port_info *seq_port_info)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tstruct port_info *port_info;\n\n\t/* TODO: read port flags from descriptors */\n\tport_info = find_port_info(umidi, number);\n\tif (port_info) {\n\t\tseq_port_info->type = port_info->seq_flags;\n\t\tseq_port_info->midi_voices = port_info->voices;\n\t}\n}\n\nstatic void snd_usbmidi_init_substream(struct snd_usb_midi *umidi,\n\t\t\t\t       int stream, int number,\n\t\t\t\t       struct snd_rawmidi_substream **rsubstream)\n{\n\tstruct port_info *port_info;\n\tconst char *name_format;\n\n\tstruct snd_rawmidi_substream *substream =\n\t\tsnd_usbmidi_find_substream(umidi, stream, number);\n\tif (!substream) {\n\t\tdev_err(&umidi->dev->dev, \"substream %d:%d not found\\n\", stream,\n\t\t\tnumber);\n\t\treturn;\n\t}\n\n\t/* TODO: read port name from jack descriptor */\n\tport_info = find_port_info(umidi, number);\n\tname_format = port_info ? port_info->name : \"%s MIDI %d\";\n\tsnprintf(substream->name, sizeof(substream->name),\n\t\t name_format, umidi->card->shortname, number + 1);\n\n\t*rsubstream = substream;\n}\n\n/*\n * Creates the endpoints and their ports.\n */\nstatic int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint i, j, err;\n\tint out_ports = 0, in_ports = 0;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_cables) {\n\t\t\terr = snd_usbmidi_out_endpoint_create(umidi,\n\t\t\t\t\t\t\t      &endpoints[i],\n\t\t\t\t\t\t\t      &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (endpoints[i].in_cables) {\n\t\t\terr = snd_usbmidi_in_endpoint_create(umidi,\n\t\t\t\t\t\t\t     &endpoints[i],\n\t\t\t\t\t\t\t     &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (j = 0; j < 0x10; ++j) {\n\t\t\tif (endpoints[i].out_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t\t   out_ports,\n\t\t\t\t\t\t\t   &umidi->endpoints[i].out->ports[j].substream);\n\t\t\t\t++out_ports;\n\t\t\t}\n\t\t\tif (endpoints[i].in_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t\t   in_ports,\n\t\t\t\t\t\t\t   &umidi->endpoints[i].in->ports[j].substream);\n\t\t\t\t++in_ports;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(&umidi->dev->dev, \"created %d output and %d input ports\\n\",\n\t\t    out_ports, in_ports);\n\treturn 0;\n}\n\n/*\n * Returns MIDIStreaming device capabilities.\n */\nstatic int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi,\n\t\t\t\t   struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_ms_header_descriptor *ms_header;\n\tstruct usb_host_endpoint *hostep;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_ms_endpoint_descriptor *ms_ep;\n\tint i, epidx;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENXIO;\n\thostif = &intf->altsetting[0];\n\tintfd = get_iface_desc(hostif);\n\tms_header = (struct usb_ms_header_descriptor *)hostif->extra;\n\tif (hostif->extralen >= 7 &&\n\t    ms_header->bLength >= 7 &&\n\t    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t    ms_header->bDescriptorSubtype == UAC_HEADER)\n\t\tdev_dbg(&umidi->dev->dev, \"MIDIStreaming version %02x.%02x\\n\",\n\t\t\t    ms_header->bcdMSC[1], ms_header->bcdMSC[0]);\n\telse\n\t\tdev_warn(&umidi->dev->dev,\n\t\t\t \"MIDIStreaming interface descriptor not found\\n\");\n\n\tepidx = 0;\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\thostep = &hostif->endpoint[i];\n\t\tep = get_ep_desc(hostep);\n\t\tif (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))\n\t\t\tcontinue;\n\t\tms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;\n\t\tif (hostep->extralen < 4 ||\n\t\t    ms_ep->bLength < 4 ||\n\t\t    ms_ep->bDescriptorType != USB_DT_CS_ENDPOINT ||\n\t\t    ms_ep->bDescriptorSubtype != UAC_MS_GENERAL)\n\t\t\tcontinue;\n\t\tif (usb_endpoint_dir_out(ep)) {\n\t\t\tif (endpoints[epidx].out_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].out_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].out_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\t/*\n\t\t\t\t * Low speed bulk transfers don't exist, so\n\t\t\t\t * force interrupt transfers for devices like\n\t\t\t\t * ESI MIDI Mate that try to use them anyway.\n\t\t\t\t */\n\t\t\t\tendpoints[epidx].out_interval = 1;\n\t\t\tendpoints[epidx].out_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t} else {\n\t\t\tif (endpoints[epidx].in_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].in_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].in_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\tendpoints[epidx].in_interval = 1;\n\t\t\tendpoints[epidx].in_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int roland_load_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"High Load\", \"Light Load\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int roland_load_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tvalue->value.enumerated.item[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int roland_load_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_usb_midi *umidi = kcontrol->private_data;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&umidi->mutex);\n\tchanged = value->value.enumerated.item[0] != kcontrol->private_value;\n\tif (changed)\n\t\tkcontrol->private_value = value->value.enumerated.item[0];\n\tmutex_unlock(&umidi->mutex);\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new roland_load_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"MIDI Input Mode\",\n\t.info = roland_load_info,\n\t.get = roland_load_get,\n\t.put = roland_load_put,\n\t.private_value = 1,\n};\n\n/*\n * On Roland devices, use the second alternate setting to be able to use\n * the interrupt input endpoint.\n */\nstatic void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting != 2)\n\t\treturn;\n\n\thostif = &intf->altsetting[1];\n\tintfd = get_iface_desc(hostif);\n       /* If either or both of the endpoints support interrupt transfer,\n        * then use the alternate setting\n        */\n\tif (intfd->bNumEndpoints != 2 ||\n\t    !((get_endpoint(hostif, 0)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT ||\n\t      (get_endpoint(hostif, 1)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))\n\t\treturn;\n\n\tdev_dbg(&umidi->dev->dev, \"switching to altsetting %d with int ep\\n\",\n\t\t    intfd->bAlternateSetting);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\n\tumidi->roland_load_ctl = snd_ctl_new1(&roland_load_ctl, umidi);\n\tif (snd_ctl_add(umidi->card, umidi->roland_load_ctl) < 0)\n\t\tumidi->roland_load_ctl = NULL;\n}\n\n/*\n * Try to find any usable endpoints in the interface.\n */\nstatic int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint,\n\t\t\t\t\tint max_endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint i, out_eps = 0, in_eps = 0;\n\n\tif (USB_ID_VENDOR(umidi->usb_id) == 0x0582)\n\t\tsnd_usbmidi_switch_roland_altsetting(umidi);\n\n\tif (endpoint[0].out_ep || endpoint[0].in_ep)\n\t\treturn 0;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting < 1)\n\t\treturn -ENOENT;\n\thostif = intf->cur_altsetting;\n\tintfd = get_iface_desc(hostif);\n\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\tepd = get_endpoint(hostif, i);\n\t\tif (!usb_endpoint_xfer_bulk(epd) &&\n\t\t    !usb_endpoint_xfer_int(epd))\n\t\t\tcontinue;\n\t\tif (out_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_out(epd)) {\n\t\t\tendpoint[out_eps].out_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[out_eps].out_interval = epd->bInterval;\n\t\t\t++out_eps;\n\t\t}\n\t\tif (in_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_in(epd)) {\n\t\t\tendpoint[in_eps].in_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[in_eps].in_interval = epd->bInterval;\n\t\t\t++in_eps;\n\t\t}\n\t}\n\treturn (out_eps || in_eps) ? 0 : -ENOENT;\n}\n\n/*\n * Detects the endpoints for one-port-per-endpoint protocols.\n */\nstatic int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint err, i;\n\n\terr = snd_usbmidi_detect_endpoints(umidi, endpoints, MIDI_MAX_ENDPOINTS);\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_ep)\n\t\t\tendpoints[i].out_cables = 0x0001;\n\t\tif (endpoints[i].in_ep)\n\t\t\tendpoints[i].in_cables = 0x0001;\n\t}\n\treturn err;\n}\n\n/*\n * Detects the endpoints and ports of Yamaha devices.\n */\nstatic int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tuint8_t *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\tif (intfd->bNumEndpoints < 1)\n\t\treturn -ENOENT;\n\n\t/*\n\t * For each port there is one MIDI_IN/OUT_JACK descriptor, not\n\t * necessarily with any useful contents.  So simply count 'em.\n\t */\n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[1] == USB_DT_CS_INTERFACE) {\n\t\t\tif (cs_desc[2] == UAC_MIDI_IN_JACK)\n\t\t\t\tendpoint->in_cables =\n\t\t\t\t\t(endpoint->in_cables << 1) | 1;\n\t\t\telse if (cs_desc[2] == UAC_MIDI_OUT_JACK)\n\t\t\t\tendpoint->out_cables =\n\t\t\t\t\t(endpoint->out_cables << 1) | 1;\n\t\t}\n\t}\n\tif (!endpoint->in_cables && !endpoint->out_cables)\n\t\treturn -ENOENT;\n\n\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n}\n\n/*\n * Detects the endpoints and ports of Roland devices.\n */\nstatic int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tu8 *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\t/*\n\t * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,\n\t * some have standard class descriptors, or both kinds, or neither.\n\t */\n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[0] >= 6 &&\n\t\t    cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t    cs_desc[2] == 0xf1 &&\n\t\t    cs_desc[3] == 0x02) {\n\t\t\tendpoint->in_cables  = (1 << cs_desc[4]) - 1;\n\t\t\tendpoint->out_cables = (1 << cs_desc[5]) - 1;\n\t\t\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n\t\t} else if (cs_desc[0] >= 7 &&\n\t\t\t   cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t\t   cs_desc[2] == UAC_HEADER) {\n\t\t\treturn snd_usbmidi_get_ms_info(umidi, endpoint);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n/*\n * Creates the endpoints and their ports for Midiman devices.\n */\nstatic int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,\n\t\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct snd_usb_midi_endpoint_info ep_info;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint cable, err;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\t/*\n\t * The various MidiSport devices have more or less random endpoint\n\t * numbers, so we have to identify the endpoints by their index in\n\t * the descriptor array, like the driver for that other OS does.\n\t *\n\t * There is one interrupt input endpoint for all input ports, one\n\t * bulk output endpoint for even-numbered ports, and one for odd-\n\t * numbered ports.  Both bulk output endpoints have corresponding\n\t * input bulk endpoints (at indices 1 and 3) which aren't used.\n\t */\n\tif (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {\n\t\tdev_dbg(&umidi->dev->dev, \"not enough endpoints\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tepd = get_endpoint(hostif, 0);\n\tif (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[0] isn't interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\tepd = get_endpoint(hostif, 2);\n\tif (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[2] isn't bulk output\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (endpoint->out_cables > 0x0001) {\n\t\tepd = get_endpoint(hostif, 4);\n\t\tif (!usb_endpoint_dir_out(epd) ||\n\t\t    !usb_endpoint_xfer_bulk(epd)) {\n\t\t\tdev_dbg(&umidi->dev->dev,\n\t\t\t\t\"endpoint[4] isn't bulk output\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.out_interval = 0;\n\tep_info.out_cables = endpoint->out_cables & 0x5555;\n\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t      &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.in_interval = get_endpoint(hostif, 0)->bInterval;\n\tep_info.in_cables = endpoint->in_cables;\n\terr = snd_usbmidi_in_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t     &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (endpoint->out_cables > 0x0001) {\n\t\tep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tep_info.out_cables = endpoint->out_cables & 0xaaaa;\n\t\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t\t      &umidi->endpoints[1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (cable = 0; cable < 0x10; ++cable) {\n\t\tif (endpoint->out_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[cable & 1].out->ports[cable].substream);\n\t\tif (endpoint->in_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[0].in->ports[cable].substream);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_global_ops snd_usbmidi_ops = {\n\t.get_port_info = snd_usbmidi_get_port_info,\n};\n\nstatic int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,\n\t\t\t\t      int out_ports, int in_ports)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(umidi->card, \"USB MIDI\",\n\t\t\t      umidi->next_midi_device++,\n\t\t\t      out_ports, in_ports, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, umidi->card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->ops = &snd_usbmidi_ops;\n\trmidi->private_data = umidi;\n\trmidi->private_free = snd_usbmidi_rawmidi_free;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_usbmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_usbmidi_input_ops);\n\n\tumidi->rmidi = rmidi;\n\treturn 0;\n}\n\n/*\n * Temporarily stop input.\n */\nvoid snd_usbmidi_input_stop(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (!umidi->input_running)\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t}\n\tumidi->input_running = 0;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_stop);\n\nstatic void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\n\tif (!ep)\n\t\treturn;\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tstruct urb *urb = ep->urbs[i];\n\t\turb->dev = ep->umidi->dev;\n\t\tsnd_usbmidi_submit_urb(urb, GFP_KERNEL);\n\t}\n}\n\n/*\n * Resume input after a call to snd_usbmidi_input_stop().\n */\nvoid snd_usbmidi_input_start(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tint i;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (umidi->input_running || !umidi->opened[1])\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tsnd_usbmidi_input_start_ep(umidi->endpoints[i].in);\n\tumidi->input_running = 1;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_start);\n\n/*\n * Prepare for suspend. Typically called from the USB suspend callback.\n */\nvoid snd_usbmidi_suspend(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_stop(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_suspend);\n\n/*\n * Resume. Typically called from the USB resume callback.\n */\nvoid snd_usbmidi_resume(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_start(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_resume);\n\n/*\n * Creates and registers everything needed for a MIDI streaming interface.\n */\nint snd_usbmidi_create(struct snd_card *card,\n\t\t       struct usb_interface *iface,\n\t\t       struct list_head *midi_list,\n\t\t       const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_usb_midi *umidi;\n\tstruct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];\n\tint out_ports, in_ports;\n\tint i, err;\n\n\tumidi = kzalloc(sizeof(*umidi), GFP_KERNEL);\n\tif (!umidi)\n\t\treturn -ENOMEM;\n\tumidi->dev = interface_to_usbdev(iface);\n\tumidi->card = card;\n\tumidi->iface = iface;\n\tumidi->quirk = quirk;\n\tumidi->usb_protocol_ops = &snd_usbmidi_standard_ops;\n\tspin_lock_init(&umidi->disc_lock);\n\tinit_rwsem(&umidi->disc_rwsem);\n\tmutex_init(&umidi->mutex);\n\tumidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),\n\t\t\t       le16_to_cpu(umidi->dev->descriptor.idProduct));\n\tsetup_timer(&umidi->error_timer, snd_usbmidi_error_timer,\n\t\t    (unsigned long)umidi);\n\n\t/* detect the endpoint(s) to use */\n\tmemset(endpoints, 0, sizeof(endpoints));\n\tswitch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {\n\tcase QUIRK_MIDI_STANDARD_INTERFACE:\n\t\terr = snd_usbmidi_get_ms_info(umidi, endpoints);\n\t\tif (umidi->usb_id == USB_ID(0x0763, 0x0150)) /* M-Audio Uno */\n\t\t\tumidi->usb_protocol_ops =\n\t\t\t\t&snd_usbmidi_maudio_broken_running_status_ops;\n\t\tbreak;\n\tcase QUIRK_MIDI_US122L:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_122l_ops;\n\t\t/* fall through */\n\tcase QUIRK_MIDI_FIXED_ENDPOINT:\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_YAMAHA:\n\t\terr = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_ROLAND:\n\t\terr = snd_usbmidi_detect_roland(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_MIDIMAN:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_NOVATION:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_novation_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_RAW_BYTES:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_raw_ops;\n\t\t/*\n\t\t * Interface 1 contains isochronous endpoints, but with the same\n\t\t * numbers as in interface 0.  Since it is interface 1 that the\n\t\t * USB core has most recently seen, these descriptors are now\n\t\t * associated with the endpoint numbers.  This will foul up our\n\t\t * attempts to submit bulk/interrupt URBs to the endpoints in\n\t\t * interface 0, so we have to make sure that the USB core looks\n\t\t * again at interface 0 by calling usb_set_interface() on it.\n\t\t */\n\t\tif (umidi->usb_id == USB_ID(0x07fd, 0x0001)) /* MOTU Fastlane */\n\t\t\tusb_set_interface(umidi->dev, 0, 0);\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_EMAGIC:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_emagic_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_CME:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_cme_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_AKAI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_akai_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\t/* endpoint 1 is input-only */\n\t\tendpoints[1].out_cables = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_FTDI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops;\n\n\t\t/* set baud rate to 31250 (48 MHz / 16 / 96) */\n\t\terr = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0),\n\t\t\t\t      3, 0x40, 0x60, 0, NULL, 0, 1000);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_CH345:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&umidi->dev->dev, \"invalid quirk type %d\\n\",\n\t\t\tquirk->type);\n\t\terr = -ENXIO;\n\t\tbreak;\n\t}\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create rawmidi device */\n\tout_ports = 0;\n\tin_ports = 0;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tout_ports += hweight16(endpoints[i].out_cables);\n\t\tin_ports += hweight16(endpoints[i].in_cables);\n\t}\n\terr = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create endpoint/port structures */\n\tif (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)\n\t\terr = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);\n\telse\n\t\terr = snd_usbmidi_create_endpoints(umidi, endpoints);\n\tif (err < 0) {\n\t\tsnd_usbmidi_free(umidi);\n\t\treturn err;\n\t}\n\n\tusb_autopm_get_interface_no_resume(umidi->iface);\n\n\tlist_add_tail(&umidi->list, midi_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_usbmidi_create);\n"], "fixing_code": ["/*\n * usbmidi.c - ALSA USB MIDI driver\n *\n * Copyright (c) 2002-2009 Clemens Ladisch\n * All rights reserved.\n *\n * Based on the OSS usb-midi driver by NAGANO Daisuke,\n *          NetBSD's umidi driver by Takuya SHIOZAKI,\n *          the \"USB Device Class Definition for MIDI Devices\" by Roland\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions, and the following disclaimer,\n *    without modification.\n * 2. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed and/or modified under the\n * terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/usb/audio.h>\n#include <linux/module.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/rawmidi.h>\n#include <sound/asequencer.h>\n#include \"usbaudio.h\"\n#include \"midi.h\"\n#include \"power.h\"\n#include \"helper.h\"\n\n/*\n * define this to log all USB packets\n */\n/* #define DUMP_PACKETS */\n\n/*\n * how long to wait after some USB errors, so that hub_wq can disconnect() us\n * without too many spurious errors\n */\n#define ERROR_DELAY_JIFFIES (HZ / 10)\n\n#define OUTPUT_URBS 7\n#define INPUT_URBS 7\n\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"USB Audio/MIDI helper module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n\nstruct usb_ms_header_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDescriptorSubtype;\n\t__u8  bcdMSC[2];\n\t__le16 wTotalLength;\n} __attribute__ ((packed));\n\nstruct usb_ms_endpoint_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDescriptorSubtype;\n\t__u8  bNumEmbMIDIJack;\n\t__u8  baAssocJackID[0];\n} __attribute__ ((packed));\n\nstruct snd_usb_midi_in_endpoint;\nstruct snd_usb_midi_out_endpoint;\nstruct snd_usb_midi_endpoint;\n\nstruct usb_protocol_ops {\n\tvoid (*input)(struct snd_usb_midi_in_endpoint*, uint8_t*, int);\n\tvoid (*output)(struct snd_usb_midi_out_endpoint *ep, struct urb *urb);\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t);\n\tvoid (*init_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n\tvoid (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint *);\n};\n\nstruct snd_usb_midi {\n\tstruct usb_device *dev;\n\tstruct snd_card *card;\n\tstruct usb_interface *iface;\n\tconst struct snd_usb_audio_quirk *quirk;\n\tstruct snd_rawmidi *rmidi;\n\tconst struct usb_protocol_ops *usb_protocol_ops;\n\tstruct list_head list;\n\tstruct timer_list error_timer;\n\tspinlock_t disc_lock;\n\tstruct rw_semaphore disc_rwsem;\n\tstruct mutex mutex;\n\tu32 usb_id;\n\tint next_midi_device;\n\n\tstruct snd_usb_midi_endpoint {\n\t\tstruct snd_usb_midi_out_endpoint *out;\n\t\tstruct snd_usb_midi_in_endpoint *in;\n\t} endpoints[MIDI_MAX_ENDPOINTS];\n\tunsigned long input_triggered;\n\tunsigned int opened[2];\n\tunsigned char disconnected;\n\tunsigned char input_running;\n\n\tstruct snd_kcontrol *roland_load_ctl;\n};\n\nstruct snd_usb_midi_out_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct out_urb_context {\n\t\tstruct urb *urb;\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t} urbs[OUTPUT_URBS];\n\tunsigned int active_urbs;\n\tunsigned int drain_urbs;\n\tint max_transfer;\t\t/* size of urb buffer */\n\tstruct tasklet_struct tasklet;\n\tunsigned int next_urb;\n\tspinlock_t buffer_lock;\n\n\tstruct usbmidi_out_port {\n\t\tstruct snd_usb_midi_out_endpoint *ep;\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tint active;\n\t\tuint8_t cable;\t\t/* cable number << 4 */\n\t\tuint8_t state;\n#define STATE_UNKNOWN\t0\n#define STATE_1PARAM\t1\n#define STATE_2PARAM_1\t2\n#define STATE_2PARAM_2\t3\n#define STATE_SYSEX_0\t4\n#define STATE_SYSEX_1\t5\n#define STATE_SYSEX_2\t6\n\t\tuint8_t data[2];\n\t} ports[0x10];\n\tint current_port;\n\n\twait_queue_head_t drain_wait;\n};\n\nstruct snd_usb_midi_in_endpoint {\n\tstruct snd_usb_midi *umidi;\n\tstruct urb *urbs[INPUT_URBS];\n\tstruct usbmidi_in_port {\n\t\tstruct snd_rawmidi_substream *substream;\n\t\tu8 running_status_length;\n\t} ports[0x10];\n\tu8 seen_f5;\n\tbool in_sysex;\n\tu8 last_cin;\n\tu8 error_resubmit;\n\tint current_port;\n};\n\nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep);\n\nstatic const uint8_t snd_usbmidi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n/*\n * Submits the URB, with error handling.\n */\nstatic int snd_usbmidi_submit_urb(struct urb *urb, gfp_t flags)\n{\n\tint err = usb_submit_urb(urb, flags);\n\tif (err < 0 && err != -ENODEV)\n\t\tdev_err(&urb->dev->dev, \"usb_submit_urb: %d\\n\", err);\n\treturn err;\n}\n\n/*\n * Error handling for URB completion functions.\n */\nstatic int snd_usbmidi_urb_error(const struct urb *urb)\n{\n\tswitch (urb->status) {\n\t/* manually unlinked, or device gone */\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\tcase -ENODEV:\n\t\treturn -ENODEV;\n\t/* errors that might occur during unplugging */\n\tcase -EPROTO:\n\tcase -ETIME:\n\tcase -EILSEQ:\n\t\treturn -EIO;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"urb status %d\\n\", urb->status);\n\t\treturn 0; /* continue */\n\t}\n}\n\n/*\n * Receives a chunk of MIDI data.\n */\nstatic void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   int portidx, uint8_t *data, int length)\n{\n\tstruct usbmidi_in_port *port = &ep->ports[portidx];\n\n\tif (!port->substream) {\n\t\tdev_dbg(&ep->umidi->dev->dev, \"unexpected port %d!\\n\", portidx);\n\t\treturn;\n\t}\n\tif (!test_bit(port->substream->number, &ep->umidi->input_triggered))\n\t\treturn;\n\tsnd_rawmidi_receive(port->substream, data, length);\n}\n\n#ifdef DUMP_PACKETS\nstatic void dump_urb(const char *type, const u8 *data, int length)\n{\n\tsnd_printk(KERN_DEBUG \"%s packet: [\", type);\n\tfor (; length > 0; ++data, --length)\n\t\tprintk(\" %02x\", *data);\n\tprintk(\" ]\\n\");\n}\n#else\n#define dump_urb(type, data, length) /* nothing */\n#endif\n\n/*\n * Processes the data read from the device.\n */\nstatic void snd_usbmidi_in_urb_complete(struct urb *urb)\n{\n\tstruct snd_usb_midi_in_endpoint *ep = urb->context;\n\n\tif (urb->status == 0) {\n\t\tdump_urb(\"received\", urb->transfer_buffer, urb->actual_length);\n\t\tep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,\n\t\t\t\t\t\t   urb->actual_length);\n\t} else {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV) {\n\t\t\t\tep->error_resubmit = 1;\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\turb->dev = ep->umidi->dev;\n\tsnd_usbmidi_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void snd_usbmidi_out_urb_complete(struct urb *urb)\n{\n\tstruct out_urb_context *context = urb->context;\n\tstruct snd_usb_midi_out_endpoint *ep = context->ep;\n\tunsigned int urb_index;\n\n\tspin_lock(&ep->buffer_lock);\n\turb_index = context - ep->urbs;\n\tep->active_urbs &= ~(1 << urb_index);\n\tif (unlikely(ep->drain_urbs)) {\n\t\tep->drain_urbs &= ~(1 << urb_index);\n\t\twake_up(&ep->drain_wait);\n\t}\n\tspin_unlock(&ep->buffer_lock);\n\tif (urb->status < 0) {\n\t\tint err = snd_usbmidi_urb_error(urb);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tmod_timer(&ep->umidi->error_timer,\n\t\t\t\t\t  jiffies + ERROR_DELAY_JIFFIES);\n\t\t\treturn;\n\t\t}\n\t}\n\tsnd_usbmidi_do_output(ep);\n}\n\n/*\n * This is called when some data should be transferred to the device\n * (from one or more substreams).\n */\nstatic void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int urb_index;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->buffer_lock, flags);\n\tif (ep->umidi->disconnected) {\n\t\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n\t\treturn;\n\t}\n\n\turb_index = ep->next_urb;\n\tfor (;;) {\n\t\tif (!(ep->active_urbs & (1 << urb_index))) {\n\t\t\turb = ep->urbs[urb_index].urb;\n\t\t\turb->transfer_buffer_length = 0;\n\t\t\tep->umidi->usb_protocol_ops->output(ep, urb);\n\t\t\tif (urb->transfer_buffer_length == 0)\n\t\t\t\tbreak;\n\n\t\t\tdump_urb(\"sending\", urb->transfer_buffer,\n\t\t\t\t urb->transfer_buffer_length);\n\t\t\turb->dev = ep->umidi->dev;\n\t\t\tif (snd_usbmidi_submit_urb(urb, GFP_ATOMIC) < 0)\n\t\t\t\tbreak;\n\t\t\tep->active_urbs |= 1 << urb_index;\n\t\t}\n\t\tif (++urb_index >= OUTPUT_URBS)\n\t\t\turb_index = 0;\n\t\tif (urb_index == ep->next_urb)\n\t\t\tbreak;\n\t}\n\tep->next_urb = urb_index;\n\tspin_unlock_irqrestore(&ep->buffer_lock, flags);\n}\n\nstatic void snd_usbmidi_out_tasklet(unsigned long data)\n{\n\tstruct snd_usb_midi_out_endpoint *ep =\n\t\t(struct snd_usb_midi_out_endpoint *) data;\n\n\tsnd_usbmidi_do_output(ep);\n}\n\n/* called after transfers had been interrupted due to some USB error */\nstatic void snd_usbmidi_error_timer(unsigned long data)\n{\n\tstruct snd_usb_midi *umidi = (struct snd_usb_midi *)data;\n\tunsigned int i, j;\n\n\tspin_lock(&umidi->disc_lock);\n\tif (umidi->disconnected) {\n\t\tspin_unlock(&umidi->disc_lock);\n\t\treturn;\n\t}\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_in_endpoint *in = umidi->endpoints[i].in;\n\t\tif (in && in->error_resubmit) {\n\t\t\tin->error_resubmit = 0;\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j) {\n\t\t\t\tif (atomic_read(&in->urbs[j]->use_count))\n\t\t\t\t\tcontinue;\n\t\t\t\tin->urbs[j]->dev = umidi->dev;\n\t\t\t\tsnd_usbmidi_submit_urb(in->urbs[j], GFP_ATOMIC);\n\t\t\t}\n\t\t}\n\t\tif (umidi->endpoints[i].out)\n\t\t\tsnd_usbmidi_do_output(umidi->endpoints[i].out);\n\t}\n\tspin_unlock(&umidi->disc_lock);\n}\n\n/* helper function to send static data that may not DMA-able */\nstatic int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t const void *data, int len)\n{\n\tint err = 0;\n\tvoid *buf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tdump_urb(\"sending\", buf, len);\n\tif (ep->urbs[0].urb)\n\t\terr = usb_bulk_msg(ep->umidi->dev, ep->urbs[0].urb->pipe,\n\t\t\t\t   buf, len, NULL, 250);\n\tkfree(buf);\n\treturn err;\n}\n\n/*\n * Standard USB MIDI protocol: see the spec.\n * Midiman protocol: like the standard protocol, but the control byte is the\n * fourth byte in each packet, and uses length instead of CIN.\n */\n\nstatic void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tint length = snd_usbmidi_cin_length[buffer[i] & 0x0f];\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\nstatic void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t      uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i + 3] != 0) {\n\t\t\tint port = buffer[i + 3] >> 4;\n\t\t\tint length = buffer[i + 3] & 3;\n\t\t\tsnd_usbmidi_input_data(ep, port, &buffer[i], length);\n\t\t}\n}\n\n/*\n * Buggy M-Audio device: running status on input results in a packet that has\n * the data bytes but not the status byte and that is marked with CIN 4.\n */\nstatic void snd_usbmidi_maudio_broken_running_status_input(\n\t\t\t\t\tstruct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t\tuint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i] != 0) {\n\t\t\tint cable = buffer[i] >> 4;\n\t\t\tu8 cin = buffer[i] & 0x0f;\n\t\t\tstruct usbmidi_in_port *port = &ep->ports[cable];\n\t\t\tint length;\n\n\t\t\tlength = snd_usbmidi_cin_length[cin];\n\t\t\tif (cin == 0xf && buffer[i + 1] >= 0xf8)\n\t\t\t\t; /* realtime msg: no running status change */\n\t\t\telse if (cin >= 0x8 && cin <= 0xe)\n\t\t\t\t/* channel msg */\n\t\t\t\tport->running_status_length = length - 1;\n\t\t\telse if (cin == 0x4 &&\n\t\t\t\t port->running_status_length != 0 &&\n\t\t\t\t buffer[i + 1] < 0x80)\n\t\t\t\t/* CIN 4 that is not a SysEx */\n\t\t\t\tlength = port->running_status_length;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * All other msgs cannot begin running status.\n\t\t\t\t * (A channel msg sent as two or three CIN 0xF\n\t\t\t\t * packets could in theory, but this device\n\t\t\t\t * doesn't use this format.)\n\t\t\t\t */\n\t\t\t\tport->running_status_length = 0;\n\t\t\tsnd_usbmidi_input_data(ep, cable, &buffer[i + 1],\n\t\t\t\t\t       length);\n\t\t}\n}\n\n/*\n * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4\n * but the previously seen CIN, but still with three data bytes.\n */\nstatic void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tunsigned int i, cin, length;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4) {\n\t\tif (buffer[i] == 0 && i > 0)\n\t\t\tbreak;\n\t\tcin = buffer[i] & 0x0f;\n\t\tif (ep->in_sysex &&\n\t\t    cin == ep->last_cin &&\n\t\t    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)\n\t\t\tcin = 0x4;\n#if 0\n\t\tif (buffer[i + 1] == 0x90) {\n\t\t\t/*\n\t\t\t * Either a corrupted running status or a real note-on\n\t\t\t * message; impossible to detect reliably.\n\t\t\t */\n\t\t}\n#endif\n\t\tlength = snd_usbmidi_cin_length[cin];\n\t\tsnd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);\n\t\tep->in_sysex = cin == 0x4;\n\t\tif (!ep->in_sysex)\n\t\t\tep->last_cin = cin;\n\t}\n}\n\n/*\n * CME protocol: like the standard protocol, but SysEx commands are sent as a\n * single USB packet preceded by a 0x0F byte.\n */\nstatic void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || (buffer[0] & 0x0f) != 0x0f)\n\t\tsnd_usbmidi_standard_input(ep, buffer, buffer_length);\n\telse\n\t\tsnd_usbmidi_input_data(ep, buffer[0] >> 4,\n\t\t\t\t       &buffer[1], buffer_length - 1);\n}\n\n/*\n * Adds one USB MIDI packet to the output buffer.\n */\nstatic void snd_usbmidi_output_standard_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t       uint8_t p1, uint8_t p2,\n\t\t\t\t\t       uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p0;\n\tbuf[1] = p1;\n\tbuf[2] = p2;\n\tbuf[3] = p3;\n\turb->transfer_buffer_length += 4;\n}\n\n/*\n * Adds one Midiman packet to the output buffer.\n */\nstatic void snd_usbmidi_output_midiman_packet(struct urb *urb, uint8_t p0,\n\t\t\t\t\t      uint8_t p1, uint8_t p2,\n\t\t\t\t\t      uint8_t p3)\n{\n\n\tuint8_t *buf =\n\t\t(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf[0] = p1;\n\tbuf[1] = p2;\n\tbuf[2] = p3;\n\tbuf[3] = (p0 & 0xf0) | snd_usbmidi_cin_length[p0 & 0x0f];\n\turb->transfer_buffer_length += 4;\n}\n\n/*\n * Converts MIDI commands to USB MIDI packets.\n */\nstatic void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port,\n\t\t\t\t      uint8_t b, struct urb *urb)\n{\n\tuint8_t p0 = port->cable;\n\tvoid (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t) =\n\t\tport->ep->umidi->usb_protocol_ops->output_packet;\n\n\tif (b >= 0xf8) {\n\t\toutput_packet(urb, p0 | 0x0f, b, 0, 0);\n\t} else if (b >= 0xf0) {\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\toutput_packet(urb, p0 | 0x05, 0xf6, 0, 0);\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase 0xf7:\n\t\t\tswitch (port->state) {\n\t\t\tcase STATE_SYSEX_0:\n\t\t\t\toutput_packet(urb, p0 | 0x05, 0xf7, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_1:\n\t\t\t\toutput_packet(urb, p0 | 0x06, port->data[0],\n\t\t\t\t\t      0xf7, 0);\n\t\t\t\tbreak;\n\t\t\tcase STATE_SYSEX_2:\n\t\t\t\toutput_packet(urb, p0 | 0x07, port->data[0],\n\t\t\t\t\t      port->data[1], 0xf7);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport->state = STATE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else if (b >= 0x80) {\n\t\tport->data[0] = b;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tport->state = STATE_1PARAM;\n\t\telse\n\t\t\tport->state = STATE_2PARAM_1;\n\t} else { /* b < 0x80 */\n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x02;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], b, 0);\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0) {\n\t\t\t\tp0 |= port->data[0] >> 4;\n\t\t\t\tport->state = STATE_2PARAM_1;\n\t\t\t} else {\n\t\t\t\tp0 |= 0x03;\n\t\t\t\tport->state = STATE_UNKNOWN;\n\t\t\t}\n\t\t\toutput_packet(urb, p0, port->data[0], port->data[1], b);\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tport->state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tport->state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\toutput_packet(urb, p0 | 0x04, port->data[0],\n\t\t\t\t      port->data[1], b);\n\t\t\tport->state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tint p;\n\n\t/* FIXME: lower-numbered ports can starve higher-numbered ports */\n\tfor (p = 0; p < 0x10; ++p) {\n\t\tstruct usbmidi_out_port *port = &ep->ports[p];\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\twhile (urb->transfer_buffer_length + 3 < ep->max_transfer) {\n\t\t\tuint8_t b;\n\t\t\tif (snd_rawmidi_transmit(port->substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnd_usbmidi_transmit_byte(port, b, urb);\n\t\t}\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_standard_ops = {\n\t.input = snd_usbmidi_standard_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_midiman_ops = {\n\t.input = snd_usbmidi_midiman_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_midiman_packet,\n};\n\nstatic const\nstruct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {\n\t.input = snd_usbmidi_maudio_broken_running_status_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_cme_ops = {\n\t.input = snd_usbmidi_cme_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\nstatic const struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {\n\t.input = ch345_broken_sysex_input,\n\t.output = snd_usbmidi_standard_output,\n\t.output_packet = snd_usbmidi_output_standard_packet,\n};\n\n/*\n * AKAI MPD16 protocol:\n *\n * For control port (endpoint 1):\n * ==============================\n * One or more chunks consisting of first byte of (0x10 | msg_len) and then a\n * SysEx message (msg_len=9 bytes long).\n *\n * For data port (endpoint 2):\n * ===========================\n * One or more chunks consisting of first byte of (0x20 | msg_len) and then a\n * MIDI message (msg_len bytes long)\n *\n * Messages sent: Active Sense, Note On, Poly Pressure, Control Change.\n */\nstatic void snd_usbmidi_akai_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tunsigned int pos = 0;\n\tunsigned int len = (unsigned int)buffer_length;\n\twhile (pos < len) {\n\t\tunsigned int port = (buffer[pos] >> 4) - 1;\n\t\tunsigned int msg_len = buffer[pos] & 0x0f;\n\t\tpos++;\n\t\tif (pos + msg_len <= len && port < 2)\n\t\t\tsnd_usbmidi_input_data(ep, 0, &buffer[pos], msg_len);\n\t\tpos += msg_len;\n\t}\n}\n\n#define MAX_AKAI_SYSEX_LEN 9\n\nstatic void snd_usbmidi_akai_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t    struct urb *urb)\n{\n\tuint8_t *msg;\n\tint pos, end, count, buf_end;\n\tuint8_t tmp[MAX_AKAI_SYSEX_LEN];\n\tstruct snd_rawmidi_substream *substream = ep->ports[0].substream;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\n\tmsg = urb->transfer_buffer + urb->transfer_buffer_length;\n\tbuf_end = ep->max_transfer - MAX_AKAI_SYSEX_LEN - 1;\n\n\t/* only try adding more data when there's space for at least 1 SysEx */\n\twhile (urb->transfer_buffer_length < buf_end) {\n\t\tcount = snd_rawmidi_transmit_peek(substream,\n\t\t\t\t\t\t  tmp, MAX_AKAI_SYSEX_LEN);\n\t\tif (!count) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t/* try to skip non-SysEx data */\n\t\tfor (pos = 0; pos < count && tmp[pos] != 0xF0; pos++)\n\t\t\t;\n\n\t\tif (pos > 0) {\n\t\t\tsnd_rawmidi_transmit_ack(substream, pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* look for the start or end marker */\n\t\tfor (end = 1; end < count && tmp[end] < 0xF0; end++)\n\t\t\t;\n\n\t\t/* next SysEx started before the end of current one */\n\t\tif (end < count && tmp[end] == 0xF0) {\n\t\t\t/* it's incomplete - drop it */\n\t\t\tsnd_rawmidi_transmit_ack(substream, end);\n\t\t\tcontinue;\n\t\t}\n\t\t/* SysEx complete */\n\t\tif (end < count && tmp[end] == 0xF7) {\n\t\t\t/* queue it, ack it, and get the next one */\n\t\t\tcount = end + 1;\n\t\t\tmsg[0] = 0x10 | count;\n\t\t\tmemcpy(&msg[1], tmp, count);\n\t\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t\t\turb->transfer_buffer_length += count + 1;\n\t\t\tmsg += count + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* less than 9 bytes and no end byte - wait for more */\n\t\tif (count < MAX_AKAI_SYSEX_LEN) {\n\t\t\tep->ports[0].active = 0;\n\t\t\treturn;\n\t\t}\n\t\t/* 9 bytes and no end marker in sight - malformed, skip it */\n\t\tsnd_rawmidi_transmit_ack(substream, count);\n\t}\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_akai_ops = {\n\t.input = snd_usbmidi_akai_input,\n\t.output = snd_usbmidi_akai_output,\n};\n\n/*\n * Novation USB MIDI protocol: number of data bytes is in the first byte\n * (when receiving) (+1!) or in the second byte (when sending); data begins\n * at the third byte.\n */\n\nstatic void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t       uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length < 2 || !buffer[0] || buffer_length < buffer[0] + 1)\n\t\treturn;\n\tsnd_usbmidi_input_data(ep, 0, &buffer[2], buffer[0] - 1);\n}\n\nstatic void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t\tstruct urb *urb)\n{\n\tuint8_t *transfer_buffer;\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\ttransfer_buffer = urb->transfer_buffer;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     &transfer_buffer[2],\n\t\t\t\t     ep->max_transfer - 2);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\ttransfer_buffer[0] = 0;\n\ttransfer_buffer[1] = count;\n\turb->transfer_buffer_length = 2 + count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_novation_ops = {\n\t.input = snd_usbmidi_novation_input,\n\t.output = snd_usbmidi_novation_output,\n};\n\n/*\n * \"raw\" protocol: just move raw MIDI bytes from/to the endpoint\n */\n\nstatic void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t  uint8_t *buffer, int buffer_length)\n{\n\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t   struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     ep->max_transfer);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\turb->transfer_buffer_length = count;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_raw_ops = {\n\t.input = snd_usbmidi_raw_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\n/*\n * FTDI protocol: raw MIDI bytes, but input packets have two modem status bytes.\n */\n\nstatic void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t   uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length > 2)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_ftdi_ops = {\n\t.input = snd_usbmidi_ftdi_input,\n\t.output = snd_usbmidi_raw_output,\n};\n\nstatic void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tif (buffer_length != 9)\n\t\treturn;\n\tbuffer_length = 8;\n\twhile (buffer_length && buffer[buffer_length - 1] == 0xFD)\n\t\tbuffer_length--;\n\tif (buffer_length)\n\t\tsnd_usbmidi_input_data(ep, 0, buffer, buffer_length);\n}\n\nstatic void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint count;\n\n\tif (!ep->ports[0].active)\n\t\treturn;\n\tswitch (snd_usb_get_speed(ep->umidi->dev)) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tcount = 1;\n\t\tbreak;\n\tdefault:\n\t\tcount = 2;\n\t}\n\tcount = snd_rawmidi_transmit(ep->ports[0].substream,\n\t\t\t\t     urb->transfer_buffer,\n\t\t\t\t     count);\n\tif (count < 1) {\n\t\tep->ports[0].active = 0;\n\t\treturn;\n\t}\n\n\tmemset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);\n\turb->transfer_buffer_length = ep->max_transfer;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_122l_ops = {\n\t.input = snd_usbmidi_us122l_input,\n\t.output = snd_usbmidi_us122l_output,\n};\n\n/*\n * Emagic USB MIDI protocol: raw MIDI with \"F5 xx\" port switching.\n */\n\nstatic void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 init_data[] = {\n\t\t/* initialization magic: \"get version\" */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x0b,\t\t\t/* version number request */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x00,\t\t\t/* EEPROM, box 0 */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n\t/* while we're at it, pour on more magic */\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n}\n\nstatic void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 finish_data[] = {\n\t\t/* switch to patch mode with last preset */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x10,\t\t\t/* patch switch command */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x7f,\t\t\t/* to all boxes */\n\t\t0x40,\t\t\t/* last preset in EEPROM */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, finish_data, sizeof(finish_data));\n}\n\nstatic void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t     uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\t/* FF indicates end of valid data */\n\tfor (i = 0; i < buffer_length; ++i)\n\t\tif (buffer[i] == 0xff) {\n\t\t\tbuffer_length = i;\n\t\t\tbreak;\n\t\t}\n\n\t/* handle F5 at end of last buffer */\n\tif (ep->seen_f5)\n\t\tgoto switch_port;\n\n\twhile (buffer_length > 0) {\n\t\t/* determine size of data until next F5 */\n\t\tfor (i = 0; i < buffer_length; ++i)\n\t\t\tif (buffer[i] == 0xf5)\n\t\t\t\tbreak;\n\t\tsnd_usbmidi_input_data(ep, ep->current_port, buffer, i);\n\t\tbuffer += i;\n\t\tbuffer_length -= i;\n\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\t/* assert(buffer[0] == 0xf5); */\n\t\tep->seen_f5 = 1;\n\t\t++buffer;\n\t\t--buffer_length;\n\n\tswitch_port:\n\t\tif (buffer_length <= 0)\n\t\t\tbreak;\n\t\tif (buffer[0] < 0x80) {\n\t\t\tep->current_port = (buffer[0] - 1) & 15;\n\t\t\t++buffer;\n\t\t\t--buffer_length;\n\t\t}\n\t\tep->seen_f5 = 0;\n\t}\n}\n\nstatic void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep,\n\t\t\t\t      struct urb *urb)\n{\n\tint port0 = ep->current_port;\n\tuint8_t *buf = urb->transfer_buffer;\n\tint buf_free = ep->max_transfer;\n\tint length, i;\n\n\tfor (i = 0; i < 0x10; ++i) {\n\t\t/* round-robin, starting at the last current port */\n\t\tint portnum = (port0 + i) & 15;\n\t\tstruct usbmidi_out_port *port = &ep->ports[portnum];\n\n\t\tif (!port->active)\n\t\t\tcontinue;\n\t\tif (snd_rawmidi_transmit_peek(port->substream, buf, 1) != 1) {\n\t\t\tport->active = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (portnum != ep->current_port) {\n\t\t\tif (buf_free < 2)\n\t\t\t\tbreak;\n\t\t\tep->current_port = portnum;\n\t\t\tbuf[0] = 0xf5;\n\t\t\tbuf[1] = (portnum + 1) & 15;\n\t\t\tbuf += 2;\n\t\t\tbuf_free -= 2;\n\t\t}\n\n\t\tif (buf_free < 1)\n\t\t\tbreak;\n\t\tlength = snd_rawmidi_transmit(port->substream, buf, buf_free);\n\t\tif (length > 0) {\n\t\t\tbuf += length;\n\t\t\tbuf_free -= length;\n\t\t\tif (buf_free < 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (buf_free < ep->max_transfer && buf_free > 0) {\n\t\t*buf = 0xff;\n\t\t--buf_free;\n\t}\n\turb->transfer_buffer_length = ep->max_transfer - buf_free;\n}\n\nstatic const struct usb_protocol_ops snd_usbmidi_emagic_ops = {\n\t.input = snd_usbmidi_emagic_input,\n\t.output = snd_usbmidi_emagic_output,\n\t.init_out_endpoint = snd_usbmidi_emagic_init_out,\n\t.finish_out_endpoint = snd_usbmidi_emagic_finish_out,\n};\n\n\nstatic void update_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tint is_light_load;\n\n\tintf = umidi->iface;\n\tis_light_load = intf->cur_altsetting != intf->altsetting;\n\tif (umidi->roland_load_ctl->private_value == is_light_load)\n\t\treturn;\n\thostif = &intf->altsetting[umidi->roland_load_ctl->private_value];\n\tintfd = get_iface_desc(hostif);\n\tsnd_usbmidi_input_stop(&umidi->list);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\tsnd_usbmidi_input_start(&umidi->list);\n}\n\nstatic int substream_open(struct snd_rawmidi_substream *substream, int dir,\n\t\t\t  int open)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct snd_kcontrol *ctl;\n\n\tdown_read(&umidi->disc_rwsem);\n\tif (umidi->disconnected) {\n\t\tup_read(&umidi->disc_rwsem);\n\t\treturn open ? -ENODEV : 0;\n\t}\n\n\tmutex_lock(&umidi->mutex);\n\tif (open) {\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access |=\n\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t\tupdate_roland_altsetting(umidi);\n\t\t\t}\n\t\t}\n\t\tumidi->opened[dir]++;\n\t\tif (umidi->opened[1])\n\t\t\tsnd_usbmidi_input_start(&umidi->list);\n\t} else {\n\t\tumidi->opened[dir]--;\n\t\tif (!umidi->opened[1])\n\t\t\tsnd_usbmidi_input_stop(&umidi->list);\n\t\tif (!umidi->opened[0] && !umidi->opened[1]) {\n\t\t\tif (umidi->roland_load_ctl) {\n\t\t\t\tctl = umidi->roland_load_ctl;\n\t\t\t\tctl->vd[0].access &=\n\t\t\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(umidi->card,\n\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&umidi->mutex);\n\tup_read(&umidi->disc_rwsem);\n\treturn 0;\n}\n\nstatic int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\tstruct usbmidi_out_port *port = NULL;\n\tint i, j;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tif (umidi->endpoints[i].out)\n\t\t\tfor (j = 0; j < 0x10; ++j)\n\t\t\t\tif (umidi->endpoints[i].out->ports[j].substream == substream) {\n\t\t\t\t\tport = &umidi->endpoints[i].out->ports[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\tif (!port) {\n\t\tsnd_BUG();\n\t\treturn -ENXIO;\n\t}\n\n\tsubstream->runtime->private_data = port;\n\tport->state = STATE_UNKNOWN;\n\treturn substream_open(substream, 0, 1);\n}\n\nstatic int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 0, 0);\n}\n\nstatic void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t       int up)\n{\n\tstruct usbmidi_out_port *port =\n\t\t(struct usbmidi_out_port *)substream->runtime->private_data;\n\n\tport->active = up;\n\tif (up) {\n\t\tif (port->ep->umidi->disconnected) {\n\t\t\t/* gobble up remaining bytes to prevent wait in\n\t\t\t * snd_rawmidi_drain_output */\n\t\t\twhile (!snd_rawmidi_transmit_empty(substream))\n\t\t\t\tsnd_rawmidi_transmit_ack(substream, 1);\n\t\t\treturn;\n\t\t}\n\t\ttasklet_schedule(&port->ep->tasklet);\n\t}\n}\n\nstatic void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)\n{\n\tstruct usbmidi_out_port *port = substream->runtime->private_data;\n\tstruct snd_usb_midi_out_endpoint *ep = port->ep;\n\tunsigned int drain_urbs;\n\tDEFINE_WAIT(wait);\n\tlong timeout = msecs_to_jiffies(50);\n\n\tif (ep->umidi->disconnected)\n\t\treturn;\n\t/*\n\t * The substream buffer is empty, but some data might still be in the\n\t * currently active URBs, so we have to wait for those to complete.\n\t */\n\tspin_lock_irq(&ep->buffer_lock);\n\tdrain_urbs = ep->active_urbs;\n\tif (drain_urbs) {\n\t\tep->drain_urbs |= drain_urbs;\n\t\tdo {\n\t\t\tprepare_to_wait(&ep->drain_wait, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ep->buffer_lock);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tspin_lock_irq(&ep->buffer_lock);\n\t\t\tdrain_urbs &= ep->drain_urbs;\n\t\t} while (drain_urbs && timeout);\n\t\tfinish_wait(&ep->drain_wait, &wait);\n\t}\n\tspin_unlock_irq(&ep->buffer_lock);\n}\n\nstatic int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 1);\n}\n\nstatic int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)\n{\n\treturn substream_open(substream, 1, 0);\n}\n\nstatic void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int up)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\n\tif (up)\n\t\tset_bit(substream->number, &umidi->input_triggered);\n\telse\n\t\tclear_bit(substream->number, &umidi->input_triggered);\n}\n\nstatic struct snd_rawmidi_ops snd_usbmidi_output_ops = {\n\t.open = snd_usbmidi_output_open,\n\t.close = snd_usbmidi_output_close,\n\t.trigger = snd_usbmidi_output_trigger,\n\t.drain = snd_usbmidi_output_drain,\n};\n\nstatic struct snd_rawmidi_ops snd_usbmidi_input_ops = {\n\t.open = snd_usbmidi_input_open,\n\t.close = snd_usbmidi_input_close,\n\t.trigger = snd_usbmidi_input_trigger\n};\n\nstatic void free_urb_and_buffer(struct snd_usb_midi *umidi, struct urb *urb,\n\t\t\t\tunsigned int buffer_length)\n{\n\tusb_free_coherent(umidi->dev, buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\n/*\n * Frees an input endpoint.\n * May be called when ep hasn't been initialized completely.\n */\nstatic void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < INPUT_URBS; ++i)\n\t\tif (ep->urbs[i])\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i],\n\t\t\t\t\t    ep->urbs[i]->transfer_buffer_length);\n\tkfree(ep);\n}\n\n/*\n * Creates an input endpoint.\n */\nstatic int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t  struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t  struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_in_endpoint *ep;\n\tvoid *buffer;\n\tunsigned int pipe;\n\tint length;\n\tunsigned int i;\n\n\trep->in = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tep->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i]) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (ep_info->in_interval)\n\t\tpipe = usb_rcvintpipe(umidi->dev, ep_info->in_ep);\n\telse\n\t\tpipe = usb_rcvbulkpipe(umidi->dev, ep_info->in_ep);\n\tlength = usb_maxpacket(umidi->dev, pipe, 0);\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev, length, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i]->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ep_info->in_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t pipe, buffer, length,\n\t\t\t\t\t snd_usbmidi_in_urb_complete,\n\t\t\t\t\t ep, ep_info->in_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i], umidi->dev,\n\t\t\t\t\t  pipe, buffer, length,\n\t\t\t\t\t  snd_usbmidi_in_urb_complete, ep);\n\t\tep->urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\trep->in = ep;\n\treturn 0;\n}\n\n/*\n * Frees an output endpoint.\n * May be called when ep hasn't been initialized completely.\n */\nstatic void snd_usbmidi_out_endpoint_clear(struct snd_usb_midi_out_endpoint *ep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i)\n\t\tif (ep->urbs[i].urb) {\n\t\t\tfree_urb_and_buffer(ep->umidi, ep->urbs[i].urb,\n\t\t\t\t\t    ep->max_transfer);\n\t\t\tep->urbs[i].urb = NULL;\n\t\t}\n}\n\nstatic void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep)\n{\n\tsnd_usbmidi_out_endpoint_clear(ep);\n\tkfree(ep);\n}\n\n/*\n * Creates an output endpoint, and initializes output ports.\n */\nstatic int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,\n\t\t\t\t\t   struct snd_usb_midi_endpoint_info *ep_info,\n\t\t\t\t\t   struct snd_usb_midi_endpoint *rep)\n{\n\tstruct snd_usb_midi_out_endpoint *ep;\n\tunsigned int i;\n\tunsigned int pipe;\n\tvoid *buffer;\n\n\trep->out = NULL;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\tep->umidi = umidi;\n\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tep->urbs[i].urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ep->urbs[i].urb) {\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tep->urbs[i].ep = ep;\n\t}\n\tif (ep_info->out_interval)\n\t\tpipe = usb_sndintpipe(umidi->dev, ep_info->out_ep);\n\telse\n\t\tpipe = usb_sndbulkpipe(umidi->dev, ep_info->out_ep);\n\tswitch (umidi->usb_id) {\n\tdefault:\n\t\tep->max_transfer = usb_maxpacket(umidi->dev, pipe, 1);\n\t\tbreak;\n\t\t/*\n\t\t * Various chips declare a packet size larger than 4 bytes, but\n\t\t * do not actually work with larger packets:\n\t\t */\n\tcase USB_ID(0x0a67, 0x5011): /* Medeli DD305 */\n\tcase USB_ID(0x0a92, 0x1020): /* ESI M4U */\n\tcase USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */\n\tcase USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */\n\tcase USB_ID(0x15ca, 0x1806): /* Textech USB Midi Cable */\n\tcase USB_ID(0x1a86, 0x752d): /* QinHeng CH345 \"USB2.0-MIDI\" */\n\tcase USB_ID(0xfc08, 0x0101): /* Unknown vendor Cable */\n\t\tep->max_transfer = 4;\n\t\tbreak;\n\t\t/*\n\t\t * Some devices only work with 9 bytes packet size:\n\t\t */\n\tcase USB_ID(0x0644, 0x800E): /* Tascam US-122L */\n\tcase USB_ID(0x0644, 0x800F): /* Tascam US-144 */\n\t\tep->max_transfer = 9;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < OUTPUT_URBS; ++i) {\n\t\tbuffer = usb_alloc_coherent(umidi->dev,\n\t\t\t\t\t    ep->max_transfer, GFP_KERNEL,\n\t\t\t\t\t    &ep->urbs[i].urb->transfer_dma);\n\t\tif (!buffer) {\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ep_info->out_interval)\n\t\t\tusb_fill_int_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t pipe, buffer, ep->max_transfer,\n\t\t\t\t\t snd_usbmidi_out_urb_complete,\n\t\t\t\t\t &ep->urbs[i], ep_info->out_interval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(ep->urbs[i].urb, umidi->dev,\n\t\t\t\t\t  pipe, buffer, ep->max_transfer,\n\t\t\t\t\t  snd_usbmidi_out_urb_complete,\n\t\t\t\t\t  &ep->urbs[i]);\n\t\tep->urbs[i].urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\tspin_lock_init(&ep->buffer_lock);\n\ttasklet_init(&ep->tasklet, snd_usbmidi_out_tasklet, (unsigned long)ep);\n\tinit_waitqueue_head(&ep->drain_wait);\n\n\tfor (i = 0; i < 0x10; ++i)\n\t\tif (ep_info->out_cables & (1 << i)) {\n\t\t\tep->ports[i].ep = ep;\n\t\t\tep->ports[i].cable = i << 4;\n\t\t}\n\n\tif (umidi->usb_protocol_ops->init_out_endpoint)\n\t\tumidi->usb_protocol_ops->init_out_endpoint(ep);\n\n\trep->out = ep;\n\treturn 0;\n}\n\n/*\n * Frees everything.\n */\nstatic void snd_usbmidi_free(struct snd_usb_midi *umidi)\n{\n\tint i;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_delete(ep->out);\n\t\tif (ep->in)\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t}\n\tmutex_destroy(&umidi->mutex);\n\tkfree(umidi);\n}\n\n/*\n * Unlinks all URBs (must be done before the usb_device is deleted).\n */\nvoid snd_usbmidi_disconnect(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\t/*\n\t * an URB's completion handler may start the timer and\n\t * a timer may submit an URB. To reliably break the cycle\n\t * a flag under lock must be used\n\t */\n\tdown_write(&umidi->disc_rwsem);\n\tspin_lock_irq(&umidi->disc_lock);\n\tumidi->disconnected = 1;\n\tspin_unlock_irq(&umidi->disc_lock);\n\tup_write(&umidi->disc_rwsem);\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->out)\n\t\t\ttasklet_kill(&ep->out->tasklet);\n\t\tif (ep->out) {\n\t\t\tfor (j = 0; j < OUTPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->out->urbs[j].urb);\n\t\t\tif (umidi->usb_protocol_ops->finish_out_endpoint)\n\t\t\t\tumidi->usb_protocol_ops->finish_out_endpoint(ep->out);\n\t\t\tep->out->active_urbs = 0;\n\t\t\tif (ep->out->drain_urbs) {\n\t\t\t\tep->out->drain_urbs = 0;\n\t\t\t\twake_up(&ep->out->drain_wait);\n\t\t\t}\n\t\t}\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t\t/* free endpoints here; later call can result in Oops */\n\t\tif (ep->out)\n\t\t\tsnd_usbmidi_out_endpoint_clear(ep->out);\n\t\tif (ep->in) {\n\t\t\tsnd_usbmidi_in_endpoint_delete(ep->in);\n\t\t\tep->in = NULL;\n\t\t}\n\t}\n\tdel_timer_sync(&umidi->error_timer);\n}\nEXPORT_SYMBOL(snd_usbmidi_disconnect);\n\nstatic void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tsnd_usbmidi_free(umidi);\n}\n\nstatic struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t\t\tint stream,\n\t\t\t\t\t\t\t\tint number)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\tlist_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams,\n\t\t\t    list) {\n\t\tif (substream->number == number)\n\t\t\treturn substream;\n\t}\n\treturn NULL;\n}\n\n/*\n * This list specifies names for ports that do not fit into the standard\n * \"(product) MIDI (n)\" schema because they aren't external MIDI ports,\n * such as internal control or synthesizer ports.\n */\nstatic struct port_info {\n\tu32 id;\n\tshort int port;\n\tshort int voices;\n\tconst char *name;\n\tunsigned int seq_flags;\n} snd_usbmidi_port_info[] = {\n#define PORT_INFO(vendor, product, num, name_, voices_, flags) \\\n\t{ .id = USB_ID(vendor, product), \\\n\t  .port = num, .voices = voices_, \\\n\t  .name = name_, .seq_flags = flags }\n#define EXTERNAL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_PORT)\n#define CONTROL_PORT(vendor, product, num, name) \\\n\tPORT_INFO(vendor, product, num, name, 0, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE)\n#define GM_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define ROLAND_SYNTH_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n#define SOUNDCANVAS_PORT(vendor, product, num, name, voices) \\\n\tPORT_INFO(vendor, product, num, name, voices, \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_MT32 | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE | \\\n\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)\n\t/* Yamaha MOTIF XF */\n\tGM_SYNTH_PORT(0x0499, 0x105c, 0, \"%s Tone Generator\", 128),\n\tCONTROL_PORT(0x0499, 0x105c, 1, \"%s Remote Control\"),\n\tEXTERNAL_PORT(0x0499, 0x105c, 2, \"%s Thru\"),\n\tCONTROL_PORT(0x0499, 0x105c, 3, \"%s Editor\"),\n\t/* Roland UA-100 */\n\tCONTROL_PORT(0x0582, 0x0000, 2, \"%s Control\"),\n\t/* Roland SC-8850 */\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 0, \"%s Part A\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 1, \"%s Part B\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 2, \"%s Part C\", 128),\n\tSOUNDCANVAS_PORT(0x0582, 0x0003, 3, \"%s Part D\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0003, 4, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0003, 5, \"%s MIDI 2\"),\n\t/* Roland U-8 */\n\tEXTERNAL_PORT(0x0582, 0x0004, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0004, 1, \"%s Control\"),\n\t/* Roland SC-8820 */\n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x0007, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0007, 2, \"%s MIDI\"),\n\t/* Roland SK-500 */\n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000b, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000b, 2, \"%s MIDI\"),\n\t/* Roland SC-D70 */\n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 0, \"%s Part A\", 64),\n\tSOUNDCANVAS_PORT(0x0582, 0x000c, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x000c, 2, \"%s MIDI\"),\n\t/* Edirol UM-880 */\n\tCONTROL_PORT(0x0582, 0x0014, 8, \"%s Control\"),\n\t/* Edirol SD-90 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0016, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0016, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0016, 3, \"%s MIDI 2\"),\n\t/* Edirol UM-550 */\n\tCONTROL_PORT(0x0582, 0x0023, 5, \"%s Control\"),\n\t/* Edirol SD-20 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 0, \"%s Part A\", 64),\n\tROLAND_SYNTH_PORT(0x0582, 0x0027, 1, \"%s Part B\", 64),\n\tEXTERNAL_PORT(0x0582, 0x0027, 2, \"%s MIDI\"),\n\t/* Edirol SD-80 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 0, \"%s Part A\", 128),\n\tROLAND_SYNTH_PORT(0x0582, 0x0029, 1, \"%s Part B\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0029, 2, \"%s MIDI 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0029, 3, \"%s MIDI 2\"),\n\t/* Edirol UA-700 */\n\tEXTERNAL_PORT(0x0582, 0x002b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x002b, 1, \"%s Control\"),\n\t/* Roland VariOS */\n\tEXTERNAL_PORT(0x0582, 0x002f, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 1, \"%s External MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x002f, 2, \"%s Sync\"),\n\t/* Edirol PCR */\n\tEXTERNAL_PORT(0x0582, 0x0033, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0033, 2, \"%s 2\"),\n\t/* BOSS GS-10 */\n\tEXTERNAL_PORT(0x0582, 0x003b, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x003b, 1, \"%s Control\"),\n\t/* Edirol UA-1000 */\n\tEXTERNAL_PORT(0x0582, 0x0044, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0044, 1, \"%s Control\"),\n\t/* Edirol UR-80 */\n\tEXTERNAL_PORT(0x0582, 0x0048, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x0048, 2, \"%s 2\"),\n\t/* Edirol PCR-A */\n\tEXTERNAL_PORT(0x0582, 0x004d, 0, \"%s MIDI\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 1, \"%s 1\"),\n\tEXTERNAL_PORT(0x0582, 0x004d, 2, \"%s 2\"),\n\t/* BOSS GT-PRO */\n\tCONTROL_PORT(0x0582, 0x0089, 0, \"%s Control\"),\n\t/* Edirol UM-3EX */\n\tCONTROL_PORT(0x0582, 0x009a, 3, \"%s Control\"),\n\t/* Roland VG-99 */\n\tCONTROL_PORT(0x0582, 0x00b2, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x00b2, 1, \"%s MIDI\"),\n\t/* Cakewalk Sonar V-Studio 100 */\n\tEXTERNAL_PORT(0x0582, 0x00eb, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x00eb, 1, \"%s Control\"),\n\t/* Roland VB-99 */\n\tCONTROL_PORT(0x0582, 0x0102, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0102, 1, \"%s MIDI\"),\n\t/* Roland A-PRO */\n\tEXTERNAL_PORT(0x0582, 0x010f, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x010f, 1, \"%s 1\"),\n\tCONTROL_PORT(0x0582, 0x010f, 2, \"%s 2\"),\n\t/* Roland SD-50 */\n\tROLAND_SYNTH_PORT(0x0582, 0x0114, 0, \"%s Synth\", 128),\n\tEXTERNAL_PORT(0x0582, 0x0114, 1, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0114, 2, \"%s Control\"),\n\t/* Roland OCTA-CAPTURE */\n\tEXTERNAL_PORT(0x0582, 0x0120, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0120, 1, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0121, 0, \"%s MIDI\"),\n\tCONTROL_PORT(0x0582, 0x0121, 1, \"%s Control\"),\n\t/* Roland SPD-SX */\n\tCONTROL_PORT(0x0582, 0x0145, 0, \"%s Control\"),\n\tEXTERNAL_PORT(0x0582, 0x0145, 1, \"%s MIDI\"),\n\t/* Roland A-Series */\n\tCONTROL_PORT(0x0582, 0x0156, 0, \"%s Keyboard\"),\n\tEXTERNAL_PORT(0x0582, 0x0156, 1, \"%s MIDI\"),\n\t/* Roland INTEGRA-7 */\n\tROLAND_SYNTH_PORT(0x0582, 0x015b, 0, \"%s Synth\", 128),\n\tCONTROL_PORT(0x0582, 0x015b, 1, \"%s Control\"),\n\t/* M-Audio MidiSport 8x8 */\n\tCONTROL_PORT(0x0763, 0x1031, 8, \"%s Control\"),\n\tCONTROL_PORT(0x0763, 0x1033, 8, \"%s Control\"),\n\t/* MOTU Fastlane */\n\tEXTERNAL_PORT(0x07fd, 0x0001, 0, \"%s MIDI A\"),\n\tEXTERNAL_PORT(0x07fd, 0x0001, 1, \"%s MIDI B\"),\n\t/* Emagic Unitor8/AMT8/MT4 */\n\tEXTERNAL_PORT(0x086a, 0x0001, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0002, 8, \"%s Broadcast\"),\n\tEXTERNAL_PORT(0x086a, 0x0003, 4, \"%s Broadcast\"),\n\t/* Akai MPD16 */\n\tCONTROL_PORT(0x09e8, 0x0062, 0, \"%s Control\"),\n\tPORT_INFO(0x09e8, 0x0062, 1, \"%s MIDI\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE),\n\t/* Access Music Virus TI */\n\tEXTERNAL_PORT(0x133e, 0x0815, 0, \"%s MIDI\"),\n\tPORT_INFO(0x133e, 0x0815, 1, \"%s Synth\", 0,\n\t\tSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\tSNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\tSNDRV_SEQ_PORT_TYPE_SYNTHESIZER),\n};\n\nstatic struct port_info *find_port_info(struct snd_usb_midi *umidi, int number)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_usbmidi_port_info); ++i) {\n\t\tif (snd_usbmidi_port_info[i].id == umidi->usb_id &&\n\t\t    snd_usbmidi_port_info[i].port == number)\n\t\t\treturn &snd_usbmidi_port_info[i];\n\t}\n\treturn NULL;\n}\n\nstatic void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi, int number,\n\t\t\t\t      struct snd_seq_port_info *seq_port_info)\n{\n\tstruct snd_usb_midi *umidi = rmidi->private_data;\n\tstruct port_info *port_info;\n\n\t/* TODO: read port flags from descriptors */\n\tport_info = find_port_info(umidi, number);\n\tif (port_info) {\n\t\tseq_port_info->type = port_info->seq_flags;\n\t\tseq_port_info->midi_voices = port_info->voices;\n\t}\n}\n\nstatic void snd_usbmidi_init_substream(struct snd_usb_midi *umidi,\n\t\t\t\t       int stream, int number,\n\t\t\t\t       struct snd_rawmidi_substream **rsubstream)\n{\n\tstruct port_info *port_info;\n\tconst char *name_format;\n\n\tstruct snd_rawmidi_substream *substream =\n\t\tsnd_usbmidi_find_substream(umidi, stream, number);\n\tif (!substream) {\n\t\tdev_err(&umidi->dev->dev, \"substream %d:%d not found\\n\", stream,\n\t\t\tnumber);\n\t\treturn;\n\t}\n\n\t/* TODO: read port name from jack descriptor */\n\tport_info = find_port_info(umidi, number);\n\tname_format = port_info ? port_info->name : \"%s MIDI %d\";\n\tsnprintf(substream->name, sizeof(substream->name),\n\t\t name_format, umidi->card->shortname, number + 1);\n\n\t*rsubstream = substream;\n}\n\n/*\n * Creates the endpoints and their ports.\n */\nstatic int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint i, j, err;\n\tint out_ports = 0, in_ports = 0;\n\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_cables) {\n\t\t\terr = snd_usbmidi_out_endpoint_create(umidi,\n\t\t\t\t\t\t\t      &endpoints[i],\n\t\t\t\t\t\t\t      &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (endpoints[i].in_cables) {\n\t\t\terr = snd_usbmidi_in_endpoint_create(umidi,\n\t\t\t\t\t\t\t     &endpoints[i],\n\t\t\t\t\t\t\t     &umidi->endpoints[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (j = 0; j < 0x10; ++j) {\n\t\t\tif (endpoints[i].out_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t\t   out_ports,\n\t\t\t\t\t\t\t   &umidi->endpoints[i].out->ports[j].substream);\n\t\t\t\t++out_ports;\n\t\t\t}\n\t\t\tif (endpoints[i].in_cables & (1 << j)) {\n\t\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t\t   in_ports,\n\t\t\t\t\t\t\t   &umidi->endpoints[i].in->ports[j].substream);\n\t\t\t\t++in_ports;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(&umidi->dev->dev, \"created %d output and %d input ports\\n\",\n\t\t    out_ports, in_ports);\n\treturn 0;\n}\n\n/*\n * Returns MIDIStreaming device capabilities.\n */\nstatic int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi,\n\t\t\t\t   struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_ms_header_descriptor *ms_header;\n\tstruct usb_host_endpoint *hostep;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_ms_endpoint_descriptor *ms_ep;\n\tint i, epidx;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENXIO;\n\thostif = &intf->altsetting[0];\n\tintfd = get_iface_desc(hostif);\n\tms_header = (struct usb_ms_header_descriptor *)hostif->extra;\n\tif (hostif->extralen >= 7 &&\n\t    ms_header->bLength >= 7 &&\n\t    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t    ms_header->bDescriptorSubtype == UAC_HEADER)\n\t\tdev_dbg(&umidi->dev->dev, \"MIDIStreaming version %02x.%02x\\n\",\n\t\t\t    ms_header->bcdMSC[1], ms_header->bcdMSC[0]);\n\telse\n\t\tdev_warn(&umidi->dev->dev,\n\t\t\t \"MIDIStreaming interface descriptor not found\\n\");\n\n\tepidx = 0;\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\thostep = &hostif->endpoint[i];\n\t\tep = get_ep_desc(hostep);\n\t\tif (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))\n\t\t\tcontinue;\n\t\tms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;\n\t\tif (hostep->extralen < 4 ||\n\t\t    ms_ep->bLength < 4 ||\n\t\t    ms_ep->bDescriptorType != USB_DT_CS_ENDPOINT ||\n\t\t    ms_ep->bDescriptorSubtype != UAC_MS_GENERAL)\n\t\t\tcontinue;\n\t\tif (usb_endpoint_dir_out(ep)) {\n\t\t\tif (endpoints[epidx].out_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].out_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].out_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\t/*\n\t\t\t\t * Low speed bulk transfers don't exist, so\n\t\t\t\t * force interrupt transfers for devices like\n\t\t\t\t * ESI MIDI Mate that try to use them anyway.\n\t\t\t\t */\n\t\t\t\tendpoints[epidx].out_interval = 1;\n\t\t\tendpoints[epidx].out_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t} else {\n\t\t\tif (endpoints[epidx].in_ep) {\n\t\t\t\tif (++epidx >= MIDI_MAX_ENDPOINTS) {\n\t\t\t\t\tdev_warn(&umidi->dev->dev,\n\t\t\t\t\t\t \"too many endpoints\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tendpoints[epidx].in_ep = usb_endpoint_num(ep);\n\t\t\tif (usb_endpoint_xfer_int(ep))\n\t\t\t\tendpoints[epidx].in_interval = ep->bInterval;\n\t\t\telse if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)\n\t\t\t\tendpoints[epidx].in_interval = 1;\n\t\t\tendpoints[epidx].in_cables =\n\t\t\t\t(1 << ms_ep->bNumEmbMIDIJack) - 1;\n\t\t\tdev_dbg(&umidi->dev->dev, \"EP %02X: %d jack(s)\\n\",\n\t\t\t\tep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int roland_load_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"High Load\", \"Light Load\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int roland_load_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tvalue->value.enumerated.item[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int roland_load_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_usb_midi *umidi = kcontrol->private_data;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&umidi->mutex);\n\tchanged = value->value.enumerated.item[0] != kcontrol->private_value;\n\tif (changed)\n\t\tkcontrol->private_value = value->value.enumerated.item[0];\n\tmutex_unlock(&umidi->mutex);\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new roland_load_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"MIDI Input Mode\",\n\t.info = roland_load_info,\n\t.get = roland_load_get,\n\t.put = roland_load_put,\n\t.private_value = 1,\n};\n\n/*\n * On Roland devices, use the second alternate setting to be able to use\n * the interrupt input endpoint.\n */\nstatic void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting != 2)\n\t\treturn;\n\n\thostif = &intf->altsetting[1];\n\tintfd = get_iface_desc(hostif);\n       /* If either or both of the endpoints support interrupt transfer,\n        * then use the alternate setting\n        */\n\tif (intfd->bNumEndpoints != 2 ||\n\t    !((get_endpoint(hostif, 0)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT ||\n\t      (get_endpoint(hostif, 1)->bmAttributes &\n\t       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))\n\t\treturn;\n\n\tdev_dbg(&umidi->dev->dev, \"switching to altsetting %d with int ep\\n\",\n\t\t    intfd->bAlternateSetting);\n\tusb_set_interface(umidi->dev, intfd->bInterfaceNumber,\n\t\t\t  intfd->bAlternateSetting);\n\n\tumidi->roland_load_ctl = snd_ctl_new1(&roland_load_ctl, umidi);\n\tif (snd_ctl_add(umidi->card, umidi->roland_load_ctl) < 0)\n\t\tumidi->roland_load_ctl = NULL;\n}\n\n/*\n * Try to find any usable endpoints in the interface.\n */\nstatic int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint,\n\t\t\t\t\tint max_endpoints)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint i, out_eps = 0, in_eps = 0;\n\n\tif (USB_ID_VENDOR(umidi->usb_id) == 0x0582)\n\t\tsnd_usbmidi_switch_roland_altsetting(umidi);\n\n\tif (endpoint[0].out_ep || endpoint[0].in_ep)\n\t\treturn 0;\n\n\tintf = umidi->iface;\n\tif (!intf || intf->num_altsetting < 1)\n\t\treturn -ENOENT;\n\thostif = intf->cur_altsetting;\n\tintfd = get_iface_desc(hostif);\n\n\tfor (i = 0; i < intfd->bNumEndpoints; ++i) {\n\t\tepd = get_endpoint(hostif, i);\n\t\tif (!usb_endpoint_xfer_bulk(epd) &&\n\t\t    !usb_endpoint_xfer_int(epd))\n\t\t\tcontinue;\n\t\tif (out_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_out(epd)) {\n\t\t\tendpoint[out_eps].out_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[out_eps].out_interval = epd->bInterval;\n\t\t\t++out_eps;\n\t\t}\n\t\tif (in_eps < max_endpoints &&\n\t\t    usb_endpoint_dir_in(epd)) {\n\t\t\tendpoint[in_eps].in_ep = usb_endpoint_num(epd);\n\t\t\tif (usb_endpoint_xfer_int(epd))\n\t\t\t\tendpoint[in_eps].in_interval = epd->bInterval;\n\t\t\t++in_eps;\n\t\t}\n\t}\n\treturn (out_eps || in_eps) ? 0 : -ENOENT;\n}\n\n/*\n * Detects the endpoints for one-port-per-endpoint protocols.\n */\nstatic int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi,\n\t\t\t\t\t\t struct snd_usb_midi_endpoint_info *endpoints)\n{\n\tint err, i;\n\n\terr = snd_usbmidi_detect_endpoints(umidi, endpoints, MIDI_MAX_ENDPOINTS);\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tif (endpoints[i].out_ep)\n\t\t\tendpoints[i].out_cables = 0x0001;\n\t\tif (endpoints[i].in_ep)\n\t\t\tendpoints[i].in_cables = 0x0001;\n\t}\n\treturn err;\n}\n\n/*\n * Detects the endpoints and ports of Yamaha devices.\n */\nstatic int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tuint8_t *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\tif (intfd->bNumEndpoints < 1)\n\t\treturn -ENOENT;\n\n\t/*\n\t * For each port there is one MIDI_IN/OUT_JACK descriptor, not\n\t * necessarily with any useful contents.  So simply count 'em.\n\t */\n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[1] == USB_DT_CS_INTERFACE) {\n\t\t\tif (cs_desc[2] == UAC_MIDI_IN_JACK)\n\t\t\t\tendpoint->in_cables =\n\t\t\t\t\t(endpoint->in_cables << 1) | 1;\n\t\t\telse if (cs_desc[2] == UAC_MIDI_OUT_JACK)\n\t\t\t\tendpoint->out_cables =\n\t\t\t\t\t(endpoint->out_cables << 1) | 1;\n\t\t}\n\t}\n\tif (!endpoint->in_cables && !endpoint->out_cables)\n\t\treturn -ENOENT;\n\n\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n}\n\n/*\n * Detects the endpoints and ports of Roland devices.\n */\nstatic int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tu8 *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\t/*\n\t * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,\n\t * some have standard class descriptors, or both kinds, or neither.\n\t */\n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[0] >= 6 &&\n\t\t    cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t    cs_desc[2] == 0xf1 &&\n\t\t    cs_desc[3] == 0x02) {\n\t\t\tendpoint->in_cables  = (1 << cs_desc[4]) - 1;\n\t\t\tendpoint->out_cables = (1 << cs_desc[5]) - 1;\n\t\t\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n\t\t} else if (cs_desc[0] >= 7 &&\n\t\t\t   cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t\t   cs_desc[2] == UAC_HEADER) {\n\t\t\treturn snd_usbmidi_get_ms_info(umidi, endpoint);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n/*\n * Creates the endpoints and their ports for Midiman devices.\n */\nstatic int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,\n\t\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct snd_usb_midi_endpoint_info ep_info;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint cable, err;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\t/*\n\t * The various MidiSport devices have more or less random endpoint\n\t * numbers, so we have to identify the endpoints by their index in\n\t * the descriptor array, like the driver for that other OS does.\n\t *\n\t * There is one interrupt input endpoint for all input ports, one\n\t * bulk output endpoint for even-numbered ports, and one for odd-\n\t * numbered ports.  Both bulk output endpoints have corresponding\n\t * input bulk endpoints (at indices 1 and 3) which aren't used.\n\t */\n\tif (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {\n\t\tdev_dbg(&umidi->dev->dev, \"not enough endpoints\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tepd = get_endpoint(hostif, 0);\n\tif (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[0] isn't interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\tepd = get_endpoint(hostif, 2);\n\tif (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[2] isn't bulk output\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (endpoint->out_cables > 0x0001) {\n\t\tepd = get_endpoint(hostif, 4);\n\t\tif (!usb_endpoint_dir_out(epd) ||\n\t\t    !usb_endpoint_xfer_bulk(epd)) {\n\t\t\tdev_dbg(&umidi->dev->dev,\n\t\t\t\t\"endpoint[4] isn't bulk output\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.out_interval = 0;\n\tep_info.out_cables = endpoint->out_cables & 0x5555;\n\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t      &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.in_interval = get_endpoint(hostif, 0)->bInterval;\n\tep_info.in_cables = endpoint->in_cables;\n\terr = snd_usbmidi_in_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t     &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (endpoint->out_cables > 0x0001) {\n\t\tep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tep_info.out_cables = endpoint->out_cables & 0xaaaa;\n\t\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t\t      &umidi->endpoints[1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (cable = 0; cable < 0x10; ++cable) {\n\t\tif (endpoint->out_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[cable & 1].out->ports[cable].substream);\n\t\tif (endpoint->in_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[0].in->ports[cable].substream);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_global_ops snd_usbmidi_ops = {\n\t.get_port_info = snd_usbmidi_get_port_info,\n};\n\nstatic int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,\n\t\t\t\t      int out_ports, int in_ports)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(umidi->card, \"USB MIDI\",\n\t\t\t      umidi->next_midi_device++,\n\t\t\t      out_ports, in_ports, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, umidi->card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->ops = &snd_usbmidi_ops;\n\trmidi->private_data = umidi;\n\trmidi->private_free = snd_usbmidi_rawmidi_free;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_usbmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_usbmidi_input_ops);\n\n\tumidi->rmidi = rmidi;\n\treturn 0;\n}\n\n/*\n * Temporarily stop input.\n */\nvoid snd_usbmidi_input_stop(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tunsigned int i, j;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (!umidi->input_running)\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tstruct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];\n\t\tif (ep->in)\n\t\t\tfor (j = 0; j < INPUT_URBS; ++j)\n\t\t\t\tusb_kill_urb(ep->in->urbs[j]);\n\t}\n\tumidi->input_running = 0;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_stop);\n\nstatic void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep)\n{\n\tunsigned int i;\n\n\tif (!ep)\n\t\treturn;\n\tfor (i = 0; i < INPUT_URBS; ++i) {\n\t\tstruct urb *urb = ep->urbs[i];\n\t\turb->dev = ep->umidi->dev;\n\t\tsnd_usbmidi_submit_urb(urb, GFP_KERNEL);\n\t}\n}\n\n/*\n * Resume input after a call to snd_usbmidi_input_stop().\n */\nvoid snd_usbmidi_input_start(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\tint i;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tif (umidi->input_running || !umidi->opened[1])\n\t\treturn;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)\n\t\tsnd_usbmidi_input_start_ep(umidi->endpoints[i].in);\n\tumidi->input_running = 1;\n}\nEXPORT_SYMBOL(snd_usbmidi_input_start);\n\n/*\n * Prepare for suspend. Typically called from the USB suspend callback.\n */\nvoid snd_usbmidi_suspend(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_stop(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_suspend);\n\n/*\n * Resume. Typically called from the USB resume callback.\n */\nvoid snd_usbmidi_resume(struct list_head *p)\n{\n\tstruct snd_usb_midi *umidi;\n\n\tumidi = list_entry(p, struct snd_usb_midi, list);\n\tmutex_lock(&umidi->mutex);\n\tsnd_usbmidi_input_start(p);\n\tmutex_unlock(&umidi->mutex);\n}\nEXPORT_SYMBOL(snd_usbmidi_resume);\n\n/*\n * Creates and registers everything needed for a MIDI streaming interface.\n */\nint snd_usbmidi_create(struct snd_card *card,\n\t\t       struct usb_interface *iface,\n\t\t       struct list_head *midi_list,\n\t\t       const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_usb_midi *umidi;\n\tstruct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];\n\tint out_ports, in_ports;\n\tint i, err;\n\n\tumidi = kzalloc(sizeof(*umidi), GFP_KERNEL);\n\tif (!umidi)\n\t\treturn -ENOMEM;\n\tumidi->dev = interface_to_usbdev(iface);\n\tumidi->card = card;\n\tumidi->iface = iface;\n\tumidi->quirk = quirk;\n\tumidi->usb_protocol_ops = &snd_usbmidi_standard_ops;\n\tspin_lock_init(&umidi->disc_lock);\n\tinit_rwsem(&umidi->disc_rwsem);\n\tmutex_init(&umidi->mutex);\n\tumidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),\n\t\t\t       le16_to_cpu(umidi->dev->descriptor.idProduct));\n\tsetup_timer(&umidi->error_timer, snd_usbmidi_error_timer,\n\t\t    (unsigned long)umidi);\n\n\t/* detect the endpoint(s) to use */\n\tmemset(endpoints, 0, sizeof(endpoints));\n\tswitch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {\n\tcase QUIRK_MIDI_STANDARD_INTERFACE:\n\t\terr = snd_usbmidi_get_ms_info(umidi, endpoints);\n\t\tif (umidi->usb_id == USB_ID(0x0763, 0x0150)) /* M-Audio Uno */\n\t\t\tumidi->usb_protocol_ops =\n\t\t\t\t&snd_usbmidi_maudio_broken_running_status_ops;\n\t\tbreak;\n\tcase QUIRK_MIDI_US122L:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_122l_ops;\n\t\t/* fall through */\n\tcase QUIRK_MIDI_FIXED_ENDPOINT:\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_YAMAHA:\n\t\terr = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_ROLAND:\n\t\terr = snd_usbmidi_detect_roland(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_MIDIMAN:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_NOVATION:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_novation_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_RAW_BYTES:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_raw_ops;\n\t\t/*\n\t\t * Interface 1 contains isochronous endpoints, but with the same\n\t\t * numbers as in interface 0.  Since it is interface 1 that the\n\t\t * USB core has most recently seen, these descriptors are now\n\t\t * associated with the endpoint numbers.  This will foul up our\n\t\t * attempts to submit bulk/interrupt URBs to the endpoints in\n\t\t * interface 0, so we have to make sure that the USB core looks\n\t\t * again at interface 0 by calling usb_set_interface() on it.\n\t\t */\n\t\tif (umidi->usb_id == USB_ID(0x07fd, 0x0001)) /* MOTU Fastlane */\n\t\t\tusb_set_interface(umidi->dev, 0, 0);\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_EMAGIC:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_emagic_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_CME:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_cme_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_AKAI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_akai_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\t/* endpoint 1 is input-only */\n\t\tendpoints[1].out_cables = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_FTDI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops;\n\n\t\t/* set baud rate to 31250 (48 MHz / 16 / 96) */\n\t\terr = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0),\n\t\t\t\t      3, 0x40, 0x60, 0, NULL, 0, 1000);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_CH345:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&umidi->dev->dev, \"invalid quirk type %d\\n\",\n\t\t\tquirk->type);\n\t\terr = -ENXIO;\n\t\tbreak;\n\t}\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create rawmidi device */\n\tout_ports = 0;\n\tin_ports = 0;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tout_ports += hweight16(endpoints[i].out_cables);\n\t\tin_ports += hweight16(endpoints[i].in_cables);\n\t}\n\terr = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create endpoint/port structures */\n\tif (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)\n\t\terr = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);\n\telse\n\t\terr = snd_usbmidi_create_endpoints(umidi, endpoints);\n\tif (err < 0) {\n\t\treturn err;\n\t}\n\n\tusb_autopm_get_interface_no_resume(umidi->iface);\n\n\tlist_add_tail(&umidi->list, midi_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_usbmidi_create);\n"], "filenames": ["sound/usb/midi.c"], "buggy_code_start_loc": [2458], "buggy_code_end_loc": [2459], "fixing_code_start_loc": [2457], "fixing_code_end_loc": [2457], "type": "NVD-CWE-Other", "message": "Double free vulnerability in the snd_usbmidi_create function in sound/usb/midi.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (panic) or possibly have unspecified other impact via vectors involving an invalid USB descriptor.", "other": {"cve": {"id": "CVE-2016-2384", "sourceIdentifier": "security@debian.org", "published": "2016-04-27T17:59:11.927", "lastModified": "2018-01-05T02:30:38.243", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/415.html\">CWE-415: Double Free</a>", "descriptions": [{"lang": "en", "value": "Double free vulnerability in the snd_usbmidi_create function in sound/usb/midi.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (panic) or possibly have unspecified other impact via vectors involving an invalid USB descriptor."}, {"lang": "es", "value": "Vulnerabilidad de liberaci\u00f3n doble en la funci\u00f3n snd_usbmidi_create en sound/usb/midi.c en el kernel de Linux en versiones anteriores a 4.5 permite a atacantes f\u00edsicamente pr\u00f3ximos causar una denegaci\u00f3n de servicio (p\u00e1nico) o posiblemente tener otro impacto no especificado a trav\u00e9s de vectores que implican un descriptor USB inv\u00e1lido."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.8", "matchCriteriaId": "3E43C27F-72D6-4615-8337-67245A069FFD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "5AB3CAA1-C20C-4A86-841E-EC0858164D7D"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=07d86ca93db7e5cdf4743564d98292042ec21af7", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00015.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00019.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00025.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00026.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00027.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00028.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00029.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00030.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00031.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00032.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00033.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00034.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00036.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00037.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00005.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0817.html", "source": "security@debian.org"}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "security@debian.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/02/14/2", "source": "security@debian.org"}, {"url": "http://www.securityfocus.com/bid/83256", "source": "security@debian.org"}, {"url": "http://www.securitytracker.com/id/1035072", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2928-1", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2928-2", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-1", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2929-2", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-1", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-2", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2930-3", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2931-1", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-2932-1", "source": "security@debian.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1308444", "source": "security@debian.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/xairy/kernel-exploits/tree/master/CVE-2016-2384", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7"}}