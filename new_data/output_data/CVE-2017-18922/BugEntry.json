{"buggy_code": ["/*\n * websockets.c - deal with WebSockets clients.\n *\n * This code should be independent of any changes in the RFB protocol. It is\n * an additional handshake and framing of normal sockets:\n *   http://www.whatwg.org/specs/web-socket-protocol/\n *\n */\n\n/*\n *  Copyright (C) 2010 Joel Martin\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#endif\n\n#include <rfb/rfb.h>\n/* errno */\n#include <errno.h>\n\n#ifndef _MSC_VER\n#include <resolv.h> /* __b64_ntop */\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_ENDIAN_H\n#include <endian.h>\n#elif LIBVNCSERVER_HAVE_SYS_ENDIAN_H\n#include <sys/endian.h>\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#include <string.h>\n#if LIBVNCSERVER_UNISTD_H\n#include <unistd.h>\n#endif\n#include \"rfb/rfbconfig.h\"\n#include \"rfbssl.h\"\n#include \"rfbcrypto.h\"\n\n#if defined(__APPLE__)\n\n#include <libkern/OSByteOrder.h>\n#define WS_NTOH64(n) OSSwapBigToHostInt64(n)\n#define WS_NTOH32(n) OSSwapBigToHostInt32(n)\n#define WS_NTOH16(n) OSSwapBigToHostInt16(n)\n#define WS_HTON64(n) OSSwapHostToBigInt64(n)\n#define WS_HTON16(n) OSSwapHostToBigInt16(n)\n\n#else\n\n#define WS_NTOH64(n) htobe64(n)\n#define WS_NTOH32(n) htobe32(n)\n#define WS_NTOH16(n) htobe16(n)\n#define WS_HTON64(n) htobe64(n)\n#define WS_HTON16(n) htobe16(n)\n\n#endif\n\n#define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)\n#define WSHLENMAX 14  /* 2 + sizeof(uint64_t) + sizeof(uint32_t) */\n\nenum {\n  WEBSOCKETS_VERSION_HIXIE,\n  WEBSOCKETS_VERSION_HYBI\n};\n\n#if 0\n#include <sys/syscall.h>\nstatic int gettid() {\n    return (int)syscall(SYS_gettid);\n}\n#endif\n\ntypedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);\ntypedef int (*wsDecodeFunc)(rfbClientPtr cl, char *dst, int len);\n\ntypedef struct ws_ctx_s {\n    char codeBufDecode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n\tchar codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n\tchar readbuf[8192];\n    int readbufstart;\n    int readbuflen;\n    int dblen;\n    char carryBuf[3];                      /* For base64 carry-over */\n    int carrylen;\n    int version;\n    int base64;\n    wsEncodeFunc encode;\n    wsDecodeFunc decode;\n} ws_ctx_t;\n\ntypedef union ws_mask_s {\n  char c[4];\n  uint32_t u;\n} ws_mask_t;\n\n/* XXX: The union and the structs do not need to be named.\n *      We are working around a bug present in GCC < 4.6 which prevented\n *      it from recognizing anonymous structs and unions.\n *      See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4784\n */\ntypedef struct \n#if __GNUC__\n__attribute__ ((__packed__)) \n#endif\nws_header_s {\n  unsigned char b0;\n  unsigned char b1;\n  union {\n    struct \n#if __GNUC__\n    __attribute__ ((__packed__)) \n#endif\n           {\n      uint16_t l16;\n      ws_mask_t m16;\n    } s16;\n    struct\n#if __GNUC__\n__attribute__ ((__packed__)) \n#endif\n           {\n      uint64_t l64;\n      ws_mask_t m64;\n    } s64;\n    ws_mask_t m;\n  } u;\n} ws_header_t;\n\nenum\n{\n    WS_OPCODE_CONTINUATION = 0x0,\n    WS_OPCODE_TEXT_FRAME,\n    WS_OPCODE_BINARY_FRAME,\n    WS_OPCODE_CLOSE = 0x8,\n    WS_OPCODE_PING,\n    WS_OPCODE_PONG\n};\n\n#define FLASH_POLICY_RESPONSE \"<cross-domain-policy><allow-access-from domain=\\\"*\\\" to-ports=\\\"*\\\" /></cross-domain-policy>\\n\"\n#define SZ_FLASH_POLICY_RESPONSE 93\n\n/*\n * draft-ietf-hybi-thewebsocketprotocol-10\n * 5.2.2. Sending the Server's Opening Handshake\n */\n#define GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n#define SERVER_HANDSHAKE_HIXIE \"HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n\\\nUpgrade: WebSocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\n%sWebSocket-Origin: %s\\r\\n\\\n%sWebSocket-Location: %s://%s%s\\r\\n\\\n%sWebSocket-Protocol: %s\\r\\n\\\n\\r\\n%s\"\n\n#define SERVER_HANDSHAKE_HYBI \"HTTP/1.1 101 Switching Protocols\\r\\n\\\nUpgrade: websocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\nSec-WebSocket-Accept: %s\\r\\n\\\nSec-WebSocket-Protocol: %s\\r\\n\\\n\\r\\n\"\n\n#define SERVER_HANDSHAKE_HYBI_NO_PROTOCOL \"HTTP/1.1 101 Switching Protocols\\r\\n\\\nUpgrade: websocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\nSec-WebSocket-Accept: %s\\r\\n\\\n\\r\\n\"\n\n#define WEBSOCKETS_CLIENT_CONNECT_WAIT_MS 100\n#define WEBSOCKETS_CLIENT_SEND_WAIT_MS 100\n#define WEBSOCKETS_MAX_HANDSHAKE_LEN 4096\n\n#if defined(__linux__) && defined(NEED_TIMEVAL)\nstruct timeval\n{\n   long int tv_sec,tv_usec;\n}\n;\n#endif\n\nstatic rfbBool webSocketsHandshake(rfbClientPtr cl, char *scheme);\nvoid webSocketsGenMd5(char * target, char *key1, char *key2, char *key3);\n\nstatic int webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst);\nstatic int webSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst);\nstatic int webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len);\nstatic int webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len);\n\nstatic int\nmin (int a, int b) {\n    return a < b ? a : b;\n}\n\nstatic void webSocketsGenSha1Key(char *target, int size, char *key)\n{\n    struct iovec iov[2];\n    unsigned char hash[20];\n\n    iov[0].iov_base = key;\n    iov[0].iov_len = strlen(key);\n    iov[1].iov_base = GUID;\n    iov[1].iov_len = sizeof(GUID) - 1;\n    digestsha1(iov, 2, hash);\n    if (-1 == b64_ntop(hash, sizeof(hash), target, size))\n\trfbErr(\"b64_ntop failed\\n\");\n}\n\n/*\n * rfbWebSocketsHandshake is called to handle new WebSockets connections\n */\n\nrfbBool\nwebSocketsCheck (rfbClientPtr cl)\n{\n    char bbuf[4], *scheme;\n    int ret;\n\n    ret = rfbPeekExactTimeout(cl, bbuf, 4,\n                                   WEBSOCKETS_CLIENT_CONNECT_WAIT_MS);\n    if ((ret < 0) && (errno == ETIMEDOUT)) {\n      rfbLog(\"Normal socket connection\\n\");\n      return TRUE;\n    } else if (ret <= 0) {\n      rfbErr(\"webSocketsHandshake: unknown connection error\\n\");\n      return FALSE;\n    }\n\n    if (strncmp(bbuf, \"<\", 1) == 0) {\n        rfbLog(\"Got Flash policy request, sending response\\n\");\n        if (rfbWriteExact(cl, FLASH_POLICY_RESPONSE,\n                          SZ_FLASH_POLICY_RESPONSE) < 0) {\n            rfbErr(\"webSocketsHandshake: failed sending Flash policy response\");\n        }\n        return FALSE;\n    } else if (strncmp(bbuf, \"\\x16\", 1) == 0 || strncmp(bbuf, \"\\x80\", 1) == 0) {\n        rfbLog(\"Got TLS/SSL WebSockets connection\\n\");\n        if (-1 == rfbssl_init(cl)) {\n\t  rfbErr(\"webSocketsHandshake: rfbssl_init failed\\n\");\n\t  return FALSE;\n\t}\n\tret = rfbPeekExactTimeout(cl, bbuf, 4, WEBSOCKETS_CLIENT_CONNECT_WAIT_MS);\n        scheme = \"wss\";\n    } else {\n        scheme = \"ws\";\n    }\n\n    if (strncmp(bbuf, \"GET \", 4) != 0) {\n      rfbErr(\"webSocketsHandshake: invalid client header\\n\");\n      return FALSE;\n    }\n\n    rfbLog(\"Got '%s' WebSockets handshake\\n\", scheme);\n\n    if (!webSocketsHandshake(cl, scheme)) {\n        return FALSE;\n    }\n    /* Start WebSockets framing */\n    return TRUE;\n}\n\nstatic rfbBool\nwebSocketsHandshake(rfbClientPtr cl, char *scheme)\n{\n    char *buf, *response, *line;\n    int n, linestart = 0, len = 0, llen, base64 = TRUE;\n    char prefix[5], trailer[17];\n    char *path = NULL, *host = NULL, *origin = NULL, *protocol = NULL;\n    char *key1 = NULL, *key2 = NULL, *key3 = NULL;\n    char *sec_ws_origin = NULL;\n    char *sec_ws_key = NULL;\n    char sec_ws_version = 0;\n    ws_ctx_t *wsctx = NULL;\n\n    buf = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);\n    if (!buf) {\n        rfbLogPerror(\"webSocketsHandshake: malloc\");\n        return FALSE;\n    }\n    response = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);\n    if (!response) {\n        free(buf);\n        rfbLogPerror(\"webSocketsHandshake: malloc\");\n        return FALSE;\n    }\n\n    while (len < WEBSOCKETS_MAX_HANDSHAKE_LEN-1) {\n        if ((n = rfbReadExactTimeout(cl, buf+len, 1,\n                                     WEBSOCKETS_CLIENT_SEND_WAIT_MS)) <= 0) {\n            if ((n < 0) && (errno == ETIMEDOUT)) {\n                break;\n            }\n            if (n == 0)\n                rfbLog(\"webSocketsHandshake: client gone\\n\");\n            else\n                rfbLogPerror(\"webSocketsHandshake: read\");\n            free(response);\n            free(buf);\n            return FALSE;\n        }\n\n        len += 1;\n        llen = len - linestart;\n        if (((llen >= 2)) && (buf[len-1] == '\\n')) {\n            line = buf+linestart;\n            if ((llen == 2) && (strncmp(\"\\r\\n\", line, 2) == 0)) {\n                if (key1 && key2) {\n                    if ((n = rfbReadExact(cl, buf+len, 8)) <= 0) {\n                        if ((n < 0) && (errno == ETIMEDOUT)) {\n                            break;\n                        }\n                        if (n == 0)\n                            rfbLog(\"webSocketsHandshake: client gone\\n\");\n                        else\n                            rfbLogPerror(\"webSocketsHandshake: read\");\n                        free(response);\n                        free(buf);\n                        return FALSE;\n                    }\n                    rfbLog(\"Got key3\\n\");\n                    key3 = buf+len;\n                    len += 8;\n                } else {\n                    buf[len] = '\\0';\n                }\n                break;\n            } else if ((llen >= 16) && ((strncmp(\"GET \", line, min(llen,4))) == 0)) {\n                /* 16 = 4 (\"GET \") + 1 (\"/.*\") + 11 (\" HTTP/1.1\\r\\n\") */\n                path = line+4;\n                buf[len-11] = '\\0'; /* Trim trailing \" HTTP/1.1\\r\\n\" */\n                cl->wspath = strdup(path);\n                /* rfbLog(\"Got path: %s\\n\", path); */\n            } else if ((strncasecmp(\"host: \", line, min(llen,6))) == 0) {\n                host = line+6;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got host: %s\\n\", host); */\n            } else if ((strncasecmp(\"origin: \", line, min(llen,8))) == 0) {\n                origin = line+8;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got origin: %s\\n\", origin); */\n            } else if ((strncasecmp(\"sec-websocket-key1: \", line, min(llen,20))) == 0) {\n                key1 = line+20;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got key1: %s\\n\", key1); */\n            } else if ((strncasecmp(\"sec-websocket-key2: \", line, min(llen,20))) == 0) {\n                key2 = line+20;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got key2: %s\\n\", key2); */\n            /* HyBI */\n\n\t    } else if ((strncasecmp(\"sec-websocket-protocol: \", line, min(llen,24))) == 0) {\n                protocol = line+24;\n                buf[len-2] = '\\0';\n                rfbLog(\"Got protocol: %s\\n\", protocol);\n            } else if ((strncasecmp(\"sec-websocket-origin: \", line, min(llen,22))) == 0) {\n\t\tsec_ws_origin = line+22;\n                buf[len-2] = '\\0';\n            } else if ((strncasecmp(\"sec-websocket-key: \", line, min(llen,19))) == 0) {\n\t\tsec_ws_key = line+19;\n                buf[len-2] = '\\0';\n            } else if ((strncasecmp(\"sec-websocket-version: \", line, min(llen,23))) == 0) {\n\t\tsec_ws_version = strtol(line+23, NULL, 10);\n                buf[len-2] = '\\0';\n\t    }\n\n            linestart = len;\n        }\n    }\n\n    if (!(path && host && (origin || sec_ws_origin))) {\n        rfbErr(\"webSocketsHandshake: incomplete client handshake\\n\");\n        free(response);\n        free(buf);\n        return FALSE;\n    }\n\n    if ((protocol) && (strstr(protocol, \"binary\"))) {\n        if (! sec_ws_version) {\n            rfbErr(\"webSocketsHandshake: 'binary' protocol not supported with Hixie\\n\");\n            free(response);\n            free(buf);\n            return FALSE;\n        }\n        rfbLog(\"  - webSocketsHandshake: using binary/raw encoding\\n\");\n        base64 = FALSE;\n        protocol = \"binary\";\n    } else {\n        rfbLog(\"  - webSocketsHandshake: using base64 encoding\\n\");\n        base64 = TRUE;\n        if ((protocol) && (strstr(protocol, \"base64\"))) {\n            protocol = \"base64\";\n        } else {\n            protocol = \"\";\n        }\n    }\n\n    /*\n     * Generate the WebSockets server response based on the the headers sent\n     * by the client.\n     */\n\n    if (sec_ws_version) {\n\tchar accept[B64LEN(SHA1_HASH_SIZE) + 1];\n\trfbLog(\"  - WebSockets client version hybi-%02d\\n\", sec_ws_version);\n\twebSocketsGenSha1Key(accept, sizeof(accept), sec_ws_key);\n        if(strlen(protocol) > 0)\n            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n\t                   SERVER_HANDSHAKE_HYBI, accept, protocol);\n        else\n            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n                           SERVER_HANDSHAKE_HYBI_NO_PROTOCOL, accept);\n    } else {\n\t/* older hixie handshake, this could be removed if\n\t * a final standard is established */\n\tif (!(key1 && key2 && key3)) {\n\t    rfbLog(\"  - WebSockets client version hixie-75\\n\");\n\t    prefix[0] = '\\0';\n\t    trailer[0] = '\\0';\n\t} else {\n\t    rfbLog(\"  - WebSockets client version hixie-76\\n\");\n\t    snprintf(prefix, 5, \"Sec-\");\n\t    webSocketsGenMd5(trailer, key1, key2, key3);\n\t}\n\tlen = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n\t\t SERVER_HANDSHAKE_HIXIE, prefix, origin, prefix, scheme,\n\t\t host, path, prefix, protocol, trailer);\n    }\n\n    if (rfbWriteExact(cl, response, len) < 0) {\n        rfbErr(\"webSocketsHandshake: failed sending WebSockets response\\n\");\n        free(response);\n        free(buf);\n        return FALSE;\n    }\n    /* rfbLog(\"webSocketsHandshake: %s\\n\", response); */\n    free(response);\n    free(buf);\n\n\n    wsctx = calloc(1, sizeof(ws_ctx_t));\n    if (sec_ws_version) {\n\twsctx->version = WEBSOCKETS_VERSION_HYBI;\n\twsctx->encode = webSocketsEncodeHybi;\n\twsctx->decode = webSocketsDecodeHybi;\n    } else {\n\twsctx->version = WEBSOCKETS_VERSION_HIXIE;\n\twsctx->encode = webSocketsEncodeHixie;\n\twsctx->decode = webSocketsDecodeHixie;\n    }\n    wsctx->base64 = base64;\n    cl->wsctx = (wsCtx *)wsctx;\n    return TRUE;\n}\n \nvoid\nwebSocketsGenMd5(char * target, char *key1, char *key2, char *key3)\n{\n    unsigned int i, spaces1 = 0, spaces2 = 0;\n    unsigned long num1 = 0, num2 = 0;\n    unsigned char buf[17];\n    struct iovec iov[1];\n\n    for (i=0; i < strlen(key1); i++) {\n        if (key1[i] == ' ') {\n            spaces1 += 1;\n        }\n        if ((key1[i] >= 48) && (key1[i] <= 57)) {\n            num1 = num1 * 10 + (key1[i] - 48);\n        }\n    }\n    num1 = num1 / spaces1;\n\n    for (i=0; i < strlen(key2); i++) {\n        if (key2[i] == ' ') {\n            spaces2 += 1;\n        }\n        if ((key2[i] >= 48) && (key2[i] <= 57)) {\n            num2 = num2 * 10 + (key2[i] - 48);\n        }\n    }\n    num2 = num2 / spaces2;\n\n    /* Pack it big-endian */\n    buf[0] = (num1 & 0xff000000) >> 24;\n    buf[1] = (num1 & 0xff0000) >> 16;\n    buf[2] = (num1 & 0xff00) >> 8;\n    buf[3] =  num1 & 0xff;\n\n    buf[4] = (num2 & 0xff000000) >> 24;\n    buf[5] = (num2 & 0xff0000) >> 16;\n    buf[6] = (num2 & 0xff00) >> 8;\n    buf[7] =  num2 & 0xff;\n\n    strncpy((char *)buf+8, key3, 8);\n    buf[16] = '\\0';\n\n    iov[0].iov_base = buf;\n    iov[0].iov_len = 16;\n    digestmd5(iov, 1, target);\n    target[16] = '\\0';\n\n    return;\n}\n\nstatic int\nwebSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    int sz = 0;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    wsctx->codeBufEncode[sz++] = '\\x00';\n    len = b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode+sz, sizeof(wsctx->codeBufEncode) - (sz + 1));\n    if (len < 0) {\n        return len;\n    }\n    sz += len;\n\n    wsctx->codeBufEncode[sz++] = '\\xff';\n    *dst = wsctx->codeBufEncode;\n    return sz;\n}\n\nstatic int\nws_read(rfbClientPtr cl, char *buf, int len)\n{\n    int n;\n    if (cl->sslctx) {\n\tn = rfbssl_read(cl, buf, len);\n    } else {\n\tn = read(cl->sock, buf, len);\n    }\n    return n;\n}\n\nstatic int\nws_peek(rfbClientPtr cl, char *buf, int len)\n{\n    int n;\n    if (cl->sslctx) {\n\tn = rfbssl_peek(cl, buf, len);\n    } else {\n\twhile (-1 == (n = recv(cl->sock, buf, len, MSG_PEEK))) {\n\t    if (errno != EAGAIN)\n\t\tbreak;\n\t}\n    }\n    return n;\n}\n\nstatic int\nwebSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len)\n{\n    int retlen = 0, n, i, avail, modlen, needlen;\n    char *buf, *end = NULL;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    buf = wsctx->codeBufDecode;\n\n    n = ws_peek(cl, buf, len*2+2);\n\n    if (n <= 0) {\n        /* save errno because rfbErr() will tamper it */\n        int olderrno = errno;\n        rfbErr(\"%s: peek (%d) %m\\n\", __func__, errno);\n        errno = olderrno;\n        return n;\n    }\n\n\n    /* Base64 encoded WebSockets stream */\n\n    if (buf[0] == '\\xff') {\n        i = ws_read(cl, buf, 1); /* Consume marker */\n        buf++;\n        n--;\n    }\n    if (n == 0) {\n        errno = EAGAIN;\n        return -1;\n    }\n    if (buf[0] == '\\x00') {\n        i = ws_read(cl, buf, 1); /* Consume marker */\n        buf++;\n        n--;\n    }\n    if (n == 0) {\n        errno = EAGAIN;\n        return -1;\n    }\n\n    /* end = memchr(buf, '\\xff', len*2+2); */\n    end = memchr(buf, '\\xff', n);\n    if (!end) {\n        end = buf + n;\n    }\n    avail = end - buf;\n\n    len -= wsctx->carrylen;\n\n    /* Determine how much base64 data we need */\n    modlen = len + (len+2)/3;\n    needlen = modlen;\n    if (needlen % 4) {\n        needlen += 4 - (needlen % 4);\n    }\n\n    if (needlen > avail) {\n        /* rfbLog(\"Waiting for more base64 data\\n\"); */\n        errno = EAGAIN;\n        return -1;\n    }\n\n    /* Any carryover from previous decode */\n    for (i=0; i < wsctx->carrylen; i++) {\n        /* rfbLog(\"Adding carryover %d\\n\", wsctx->carryBuf[i]); */\n        dst[i] = wsctx->carryBuf[i];\n        retlen += 1;\n    }\n\n    /* Decode the rest of what we need */\n    buf[needlen] = '\\x00';  /* Replace end marker with end of string */\n    /* rfbLog(\"buf: %s\\n\", buf); */\n    n = b64_pton(buf, (unsigned char *)dst+retlen, 2+len);\n    if (n < len) {\n        rfbErr(\"Base64 decode error\\n\");\n        errno = EIO;\n        return -1;\n    }\n    retlen += n;\n\n    /* Consume the data from socket */\n    i = ws_read(cl, buf, needlen);\n\n    wsctx->carrylen = n - len;\n    retlen -= wsctx->carrylen;\n    for (i=0; i < wsctx->carrylen; i++) {\n        /* rfbLog(\"Saving carryover %d\\n\", dst[retlen + i]); */\n        wsctx->carryBuf[i] = dst[retlen + i];\n    }\n\n    /* rfbLog(\"<< webSocketsDecode, retlen: %d\\n\", retlen); */\n    return retlen;\n}\n\nstatic int\nwebSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)\n{\n    char *buf, *payload;\n    uint32_t *payload32;\n    int ret = -1, result = -1;\n    int total = 0;\n    ws_mask_t mask;\n    ws_header_t *header;\n    int i;\n    unsigned char opcode;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    int flength, fhlen;\n    /* int fin; */ /* not used atm */ \n\n    /* rfbLog(\" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\\n\", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */\n\n    if (wsctx->readbuflen) {\n      /* simply return what we have */\n      if (wsctx->readbuflen > len) {\n\tmemcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);\n\tresult = len;\n\twsctx->readbuflen -= len;\n\twsctx->readbufstart += len;\n      } else {\n\tmemcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);\n\tresult = wsctx->readbuflen;\n\twsctx->readbuflen = 0;\n\twsctx->readbufstart = 0;\n      }\n      goto spor;\n    }\n\n    buf = wsctx->codeBufDecode;\n    header = (ws_header_t *)wsctx->codeBufDecode;\n\n    ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);\n\n    if (ret < 2) {\n        /* save errno because rfbErr() will tamper it */\n        if (-1 == ret) {\n            int olderrno = errno;\n            rfbErr(\"%s: peek; %m\\n\", __func__);\n            errno = olderrno;\n        } else if (0 == ret) {\n            result = 0;\n        } else {\n            errno = EAGAIN;\n        }\n        goto spor;\n    }\n\n    opcode = header->b0 & 0x0f;\n    /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */\n    flength = header->b1 & 0x7f;\n\n    /*\n     * 4.3. Client-to-Server Masking\n     *\n     * The client MUST mask all frames sent to the server.  A server MUST\n     * close the connection upon receiving a frame with the MASK bit set to 0.\n    **/\n    if (!(header->b1 & 0x80)) {\n\trfbErr(\"%s: got frame without mask\\n\", __func__, ret);\n\terrno = EIO;\n\tgoto spor;\n    }\n\n    if (flength < 126) {\n\tfhlen = 2;\n\tmask = header->u.m;\n    } else if (flength == 126 && 4 <= ret) {\n\tflength = WS_NTOH16(header->u.s16.l16);\n\tfhlen = 4;\n\tmask = header->u.s16.m16;\n    } else if (flength == 127 && 10 <= ret) {\n\tflength = WS_NTOH64(header->u.s64.l64);\n\tfhlen = 10;\n\tmask = header->u.s64.m64;\n    } else {\n      /* Incomplete frame header */\n      rfbErr(\"%s: incomplete frame header\\n\", __func__, ret);\n      errno = EIO;\n      goto spor;\n    }\n\n    /* absolute length of frame */\n    total = fhlen + flength + 4;\n    payload = buf + fhlen + 4; /* header length + mask */\n\n    if (-1 == (ret = ws_read(cl, buf, total))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %m\", __func__);\n      errno = olderrno;\n      return ret;\n    } else if (ret < total) {\n      /* GT TODO: hmm? */\n      rfbLog(\"%s: read; got partial data\\n\", __func__);\n    } else {\n      buf[ret] = '\\0';\n    }\n\n    /* process 1 frame (32 bit op) */\n    payload32 = (uint32_t *)payload;\n    for (i = 0; i < flength / 4; i++) {\n\tpayload32[i] ^= mask.u;\n    }\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < flength; i++) {\n\tpayload[i] ^= mask.c[i % 4];\n    }\n\n    switch (opcode) {\n      case WS_OPCODE_CLOSE:\n\trfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)payload)[0]));\n\terrno = ECONNRESET;\n\tbreak;\n      case WS_OPCODE_TEXT_FRAME:\n\tif (-1 == (flength = b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {\n\t  rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);\n\t  break;\n\t}\n\tpayload = wsctx->codeBufDecode;\n\t/* fall through */\n      case WS_OPCODE_BINARY_FRAME:\n\tif (flength > len) {\n\t  memcpy(wsctx->readbuf, payload + len, flength - len);\n\t  wsctx->readbufstart = 0;\n\t  wsctx->readbuflen = flength - len;\n\t  flength = len;\n\t}\n\tmemcpy(dst, payload, flength);\n\tresult = flength;\n\tbreak;\n      default:\n\trfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)opcode, header->b0, header->b1);\n    }\n\n    /* single point of return, if someone has questions :-) */\nspor:\n    /* rfbLog(\"%s: ret: %d/%d\\n\", __func__, result, len); */\n    return result;\n}\n\nstatic int\nwebSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    int blen, ret = -1, sz = 0;\n    unsigned char opcode = '\\0'; /* TODO: option! */\n    ws_header_t *header;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n\n    /* Optional opcode:\n     *   0x0 - continuation\n     *   0x1 - text frame (base64 encode buf)\n     *   0x2 - binary frame (use raw buf)\n     *   0x8 - connection close\n     *   0x9 - ping\n     *   0xA - pong\n    **/\n    if (!len) {\n\t  /* nothing to encode */\n\t  return 0;\n    }\n\n    header = (ws_header_t *)wsctx->codeBufEncode;\n\n    if (wsctx->base64) {\n\topcode = WS_OPCODE_TEXT_FRAME;\n\t/* calculate the resulting size */\n\tblen = B64LEN(len);\n    } else {\n\topcode = WS_OPCODE_BINARY_FRAME;\n\tblen = len;\n    }\n\n    header->b0 = 0x80 | (opcode & 0x0f);\n    if (blen <= 125) {\n      header->b1 = (uint8_t)blen;\n      sz = 2;\n    } else if (blen <= 65536) {\n      header->b1 = 0x7e;\n      header->u.s16.l16 = WS_HTON16((uint16_t)blen);\n      sz = 4;\n    } else {\n      header->b1 = 0x7f;\n      header->u.s64.l64 = WS_HTON64(blen);\n      sz = 10;\n    }\n\n    if (wsctx->base64) {\n        if (-1 == (ret = b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode + sz, sizeof(wsctx->codeBufEncode) - sz))) {\n\t  rfbErr(\"%s: Base 64 encode failed\\n\", __func__);\n\t} else {\n\t  if (ret != blen)\n\t    rfbErr(\"%s: Base 64 encode; something weird happened\\n\", __func__);\n\t  ret += sz;\n\t}\n    } else {\n      memcpy(wsctx->codeBufEncode + sz, src, len);\n      ret =  sz + len;\n    }\n\n    *dst = wsctx->codeBufEncode;\n\n    return ret;\n}\n\nint\nwebSocketsEncode(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    return ((ws_ctx_t *)cl->wsctx)->encode(cl, src, len, dst);\n}\n\nint\nwebSocketsDecode(rfbClientPtr cl, char *dst, int len)\n{\n    return ((ws_ctx_t *)cl->wsctx)->decode(cl, dst, len);\n}\n\n\n/* returns TRUE if client sent a close frame or a single 'end of frame'\n * marker was received, FALSE otherwise\n *\n * Note: This is a Hixie-only hack!\n **/\nrfbBool\nwebSocketCheckDisconnect(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    /* With Base64 encoding we need at least 4 bytes */\n    char peekbuf[4];\n    int n;\n\n    if (wsctx->version == WEBSOCKETS_VERSION_HYBI)\n\treturn FALSE;\n\n    if (cl->sslctx)\n\tn = rfbssl_peek(cl, peekbuf, 4);\n    else\n\tn = recv(cl->sock, peekbuf, 4, MSG_PEEK);\n\n    if (n <= 0) {\n\tif (n != 0)\n\t    rfbErr(\"%s: peek; %m\", __func__);\n\trfbCloseClient(cl);\n\treturn TRUE;\n    }\n\n    if (peekbuf[0] == '\\xff') {\n\tint doclose = 0;\n\t/* Make sure we don't miss a client disconnect on an end frame\n\t * marker. Because we use a peek buffer in some cases it is not\n\t * applicable to wait for more data per select(). */\n\tswitch (n) {\n\t    case 3:\n\t\tif (peekbuf[1] == '\\xff' && peekbuf[2] == '\\x00')\n\t\t    doclose = 1;\n\t\tbreak;\n\t    case 2:\n\t\tif (peekbuf[1] == '\\x00')\n\t\t    doclose = 1;\n\t\tbreak;\n\t    default:\n\t\treturn FALSE;\n\t}\n\n\tif (cl->sslctx)\n\t    n = rfbssl_read(cl, peekbuf, n);\n\telse\n\t    n = read(cl->sock, peekbuf, n);\n\n\tif (doclose) {\n\t    rfbErr(\"%s: websocket close frame received\\n\", __func__);\n\t    rfbCloseClient(cl);\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/* returns TRUE if there is data waiting to be read in our internal buffer\n * or if is there any pending data in the buffer of the SSL implementation\n */\nrfbBool\nwebSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}\n"], "fixing_code": ["/*\n * websockets.c - deal with WebSockets clients.\n *\n * This code should be independent of any changes in the RFB protocol. It is\n * an additional handshake and framing of normal sockets:\n *   http://www.whatwg.org/specs/web-socket-protocol/\n *\n */\n\n/*\n *  Copyright (C) 2010 Joel Martin\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#endif\n\n#include <rfb/rfb.h>\n/* errno */\n#include <errno.h>\n\n#ifndef _MSC_VER\n#include <resolv.h> /* __b64_ntop */\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_ENDIAN_H\n#include <endian.h>\n#elif LIBVNCSERVER_HAVE_SYS_ENDIAN_H\n#include <sys/endian.h>\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#include <string.h>\n#if LIBVNCSERVER_UNISTD_H\n#include <unistd.h>\n#endif\n#include \"rfb/rfbconfig.h\"\n#include \"rfbssl.h\"\n#include \"rfbcrypto.h\"\n\n#if defined(__APPLE__)\n\n#include <libkern/OSByteOrder.h>\n#define WS_NTOH64(n) OSSwapBigToHostInt64(n)\n#define WS_NTOH32(n) OSSwapBigToHostInt32(n)\n#define WS_NTOH16(n) OSSwapBigToHostInt16(n)\n#define WS_HTON64(n) OSSwapHostToBigInt64(n)\n#define WS_HTON16(n) OSSwapHostToBigInt16(n)\n\n#else\n\n#define WS_NTOH64(n) htobe64(n)\n#define WS_NTOH32(n) htobe32(n)\n#define WS_NTOH16(n) htobe16(n)\n#define WS_HTON64(n) htobe64(n)\n#define WS_HTON16(n) htobe16(n)\n\n#endif\n\n#define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)\n#define WSHLENMAX 14  /* 2 + sizeof(uint64_t) + sizeof(uint32_t) */\n#define WS_HYBI_MASK_LEN 4\n\n#define ARRAYSIZE(a) ((sizeof(a) / sizeof((a[0]))) / (size_t)(!(sizeof(a) % sizeof((a[0])))))\n\nenum {\n  WEBSOCKETS_VERSION_HIXIE,\n  WEBSOCKETS_VERSION_HYBI\n};\n\n#if 0\n#include <sys/syscall.h>\nstatic int gettid() {\n    return (int)syscall(SYS_gettid);\n}\n#endif\n\ntypedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);\ntypedef int (*wsDecodeFunc)(rfbClientPtr cl, char *dst, int len);\n\n\nenum {\n  /* header not yet received completely */\n  WS_HYBI_STATE_HEADER_PENDING,\n  /* data available */\n  WS_HYBI_STATE_DATA_AVAILABLE,\n  WS_HYBI_STATE_DATA_NEEDED,\n  /* received a complete frame */\n  WS_HYBI_STATE_FRAME_COMPLETE,\n  /* received part of a 'close' frame */\n  WS_HYBI_STATE_CLOSE_REASON_PENDING,\n  /* */\n  WS_HYBI_STATE_ERR\n};\n\ntypedef union ws_mask_s {\n  char c[4];\n  uint32_t u;\n} ws_mask_t;\n\n/* XXX: The union and the structs do not need to be named.\n *      We are working around a bug present in GCC < 4.6 which prevented\n *      it from recognizing anonymous structs and unions.\n *      See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4784\n */\ntypedef struct \n#if __GNUC__\n__attribute__ ((__packed__)) \n#endif\nws_header_s {\n  unsigned char b0;\n  unsigned char b1;\n  union {\n    struct \n#if __GNUC__\n    __attribute__ ((__packed__)) \n#endif\n           {\n      uint16_t l16;\n      ws_mask_t m16;\n    } s16;\n    struct\n#if __GNUC__\n__attribute__ ((__packed__)) \n#endif\n           {\n      uint64_t l64;\n      ws_mask_t m64;\n    } s64;\n    ws_mask_t m;\n  } u;\n} ws_header_t;\n\ntypedef struct ws_header_data_s {\n  ws_header_t *data;\n  /** bytes read */\n  int nRead;\n  /** mask value */\n  ws_mask_t mask;\n  /** length of frame header including payload len, but without mask */\n  int headerLen;\n  /** length of the payload data */\n  int payloadLen;\n  /** opcode */\n  unsigned char opcode;\n} ws_header_data_t;\n\ntypedef struct ws_ctx_s {\n    char codeBufDecode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n    char codeBufEncode[B64LEN(UPDATE_BUF_SIZE) + WSHLENMAX]; /* base64 + maximum frame header length */\n    char *writePos;\n    unsigned char *readPos;\n    int readlen;\n    int hybiDecodeState;\n    char carryBuf[3];                      /* For base64 carry-over */\n    int carrylen;\n    int version;\n    int base64;\n    ws_header_data_t header;\n    int nReadRaw;\n    int nToRead;\n    wsEncodeFunc encode;\n    wsDecodeFunc decode;\n} ws_ctx_t;\n\nenum\n{\n    WS_OPCODE_CONTINUATION = 0x0,\n    WS_OPCODE_TEXT_FRAME,\n    WS_OPCODE_BINARY_FRAME,\n    WS_OPCODE_CLOSE = 0x8,\n    WS_OPCODE_PING,\n    WS_OPCODE_PONG\n};\n\n#define FLASH_POLICY_RESPONSE \"<cross-domain-policy><allow-access-from domain=\\\"*\\\" to-ports=\\\"*\\\" /></cross-domain-policy>\\n\"\n#define SZ_FLASH_POLICY_RESPONSE 93\n\n/*\n * draft-ietf-hybi-thewebsocketprotocol-10\n * 5.2.2. Sending the Server's Opening Handshake\n */\n#define GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n#define SERVER_HANDSHAKE_HIXIE \"HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n\\\nUpgrade: WebSocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\n%sWebSocket-Origin: %s\\r\\n\\\n%sWebSocket-Location: %s://%s%s\\r\\n\\\n%sWebSocket-Protocol: %s\\r\\n\\\n\\r\\n%s\"\n\n#define SERVER_HANDSHAKE_HYBI \"HTTP/1.1 101 Switching Protocols\\r\\n\\\nUpgrade: websocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\nSec-WebSocket-Accept: %s\\r\\n\\\nSec-WebSocket-Protocol: %s\\r\\n\\\n\\r\\n\"\n\n#define SERVER_HANDSHAKE_HYBI_NO_PROTOCOL \"HTTP/1.1 101 Switching Protocols\\r\\n\\\nUpgrade: websocket\\r\\n\\\nConnection: Upgrade\\r\\n\\\nSec-WebSocket-Accept: %s\\r\\n\\\n\\r\\n\"\n\n#define WEBSOCKETS_CLIENT_CONNECT_WAIT_MS 100\n#define WEBSOCKETS_CLIENT_SEND_WAIT_MS 100\n#define WEBSOCKETS_MAX_HANDSHAKE_LEN 4096\n\n#if defined(__linux__) && defined(NEED_TIMEVAL)\nstruct timeval\n{\n   long int tv_sec,tv_usec;\n}\n;\n#endif\n\nstatic rfbBool webSocketsHandshake(rfbClientPtr cl, char *scheme);\nvoid webSocketsGenMd5(char * target, char *key1, char *key2, char *key3);\n\nstatic int webSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst);\nstatic int webSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst);\nstatic int webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len);\nstatic int webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len);\n\nstatic void hybiDecodeCleanup(ws_ctx_t *wsctx);\n\nstatic int\nmin (int a, int b) {\n    return a < b ? a : b;\n}\n\nstatic void webSocketsGenSha1Key(char *target, int size, char *key)\n{\n    struct iovec iov[2];\n    unsigned char hash[20];\n\n    iov[0].iov_base = key;\n    iov[0].iov_len = strlen(key);\n    iov[1].iov_base = GUID;\n    iov[1].iov_len = sizeof(GUID) - 1;\n    digestsha1(iov, 2, hash);\n    if (-1 == b64_ntop(hash, sizeof(hash), target, size))\n\trfbErr(\"b64_ntop failed\\n\");\n}\n\n/*\n * rfbWebSocketsHandshake is called to handle new WebSockets connections\n */\n\nrfbBool\nwebSocketsCheck (rfbClientPtr cl)\n{\n    char bbuf[4], *scheme;\n    int ret;\n\n    ret = rfbPeekExactTimeout(cl, bbuf, 4,\n                                   WEBSOCKETS_CLIENT_CONNECT_WAIT_MS);\n    if ((ret < 0) && (errno == ETIMEDOUT)) {\n      rfbLog(\"Normal socket connection\\n\");\n      return TRUE;\n    } else if (ret <= 0) {\n      rfbErr(\"webSocketsHandshake: unknown connection error\\n\");\n      return FALSE;\n    }\n\n    if (strncmp(bbuf, \"<\", 1) == 0) {\n        rfbLog(\"Got Flash policy request, sending response\\n\");\n        if (rfbWriteExact(cl, FLASH_POLICY_RESPONSE,\n                          SZ_FLASH_POLICY_RESPONSE) < 0) {\n            rfbErr(\"webSocketsHandshake: failed sending Flash policy response\");\n        }\n        return FALSE;\n    } else if (strncmp(bbuf, \"\\x16\", 1) == 0 || strncmp(bbuf, \"\\x80\", 1) == 0) {\n        rfbLog(\"Got TLS/SSL WebSockets connection\\n\");\n        if (-1 == rfbssl_init(cl)) {\n\t  rfbErr(\"webSocketsHandshake: rfbssl_init failed\\n\");\n\t  return FALSE;\n\t}\n\tret = rfbPeekExactTimeout(cl, bbuf, 4, WEBSOCKETS_CLIENT_CONNECT_WAIT_MS);\n        scheme = \"wss\";\n    } else {\n        scheme = \"ws\";\n    }\n\n    if (strncmp(bbuf, \"GET \", 4) != 0) {\n      rfbErr(\"webSocketsHandshake: invalid client header\\n\");\n      return FALSE;\n    }\n\n    rfbLog(\"Got '%s' WebSockets handshake\\n\", scheme);\n\n    if (!webSocketsHandshake(cl, scheme)) {\n        return FALSE;\n    }\n    /* Start WebSockets framing */\n    return TRUE;\n}\n\nstatic rfbBool\nwebSocketsHandshake(rfbClientPtr cl, char *scheme)\n{\n    char *buf, *response, *line;\n    int n, linestart = 0, len = 0, llen, base64 = TRUE;\n    char prefix[5], trailer[17];\n    char *path = NULL, *host = NULL, *origin = NULL, *protocol = NULL;\n    char *key1 = NULL, *key2 = NULL, *key3 = NULL;\n    char *sec_ws_origin = NULL;\n    char *sec_ws_key = NULL;\n    char sec_ws_version = 0;\n    ws_ctx_t *wsctx = NULL;\n\n    buf = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);\n    if (!buf) {\n        rfbLogPerror(\"webSocketsHandshake: malloc\");\n        return FALSE;\n    }\n    response = (char *) malloc(WEBSOCKETS_MAX_HANDSHAKE_LEN);\n    if (!response) {\n        free(buf);\n        rfbLogPerror(\"webSocketsHandshake: malloc\");\n        return FALSE;\n    }\n\n    while (len < WEBSOCKETS_MAX_HANDSHAKE_LEN-1) {\n        if ((n = rfbReadExactTimeout(cl, buf+len, 1,\n                                     WEBSOCKETS_CLIENT_SEND_WAIT_MS)) <= 0) {\n            if ((n < 0) && (errno == ETIMEDOUT)) {\n                break;\n            }\n            if (n == 0)\n                rfbLog(\"webSocketsHandshake: client gone\\n\");\n            else\n                rfbLogPerror(\"webSocketsHandshake: read\");\n            free(response);\n            free(buf);\n            return FALSE;\n        }\n\n        len += 1;\n        llen = len - linestart;\n        if (((llen >= 2)) && (buf[len-1] == '\\n')) {\n            line = buf+linestart;\n            if ((llen == 2) && (strncmp(\"\\r\\n\", line, 2) == 0)) {\n                if (key1 && key2) {\n                    if ((n = rfbReadExact(cl, buf+len, 8)) <= 0) {\n                        if ((n < 0) && (errno == ETIMEDOUT)) {\n                            break;\n                        }\n                        if (n == 0)\n                            rfbLog(\"webSocketsHandshake: client gone\\n\");\n                        else\n                            rfbLogPerror(\"webSocketsHandshake: read\");\n                        free(response);\n                        free(buf);\n                        return FALSE;\n                    }\n                    rfbLog(\"Got key3\\n\");\n                    key3 = buf+len;\n                    len += 8;\n                } else {\n                    buf[len] = '\\0';\n                }\n                break;\n            } else if ((llen >= 16) && ((strncmp(\"GET \", line, min(llen,4))) == 0)) {\n                /* 16 = 4 (\"GET \") + 1 (\"/.*\") + 11 (\" HTTP/1.1\\r\\n\") */\n                path = line+4;\n                buf[len-11] = '\\0'; /* Trim trailing \" HTTP/1.1\\r\\n\" */\n                cl->wspath = strdup(path);\n                /* rfbLog(\"Got path: %s\\n\", path); */\n            } else if ((strncasecmp(\"host: \", line, min(llen,6))) == 0) {\n                host = line+6;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got host: %s\\n\", host); */\n            } else if ((strncasecmp(\"origin: \", line, min(llen,8))) == 0) {\n                origin = line+8;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got origin: %s\\n\", origin); */\n            } else if ((strncasecmp(\"sec-websocket-key1: \", line, min(llen,20))) == 0) {\n                key1 = line+20;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got key1: %s\\n\", key1); */\n            } else if ((strncasecmp(\"sec-websocket-key2: \", line, min(llen,20))) == 0) {\n                key2 = line+20;\n                buf[len-2] = '\\0';\n                /* rfbLog(\"Got key2: %s\\n\", key2); */\n            /* HyBI */\n\n\t    } else if ((strncasecmp(\"sec-websocket-protocol: \", line, min(llen,24))) == 0) {\n                protocol = line+24;\n                buf[len-2] = '\\0';\n                rfbLog(\"Got protocol: %s\\n\", protocol);\n            } else if ((strncasecmp(\"sec-websocket-origin: \", line, min(llen,22))) == 0) {\n\t\tsec_ws_origin = line+22;\n                buf[len-2] = '\\0';\n            } else if ((strncasecmp(\"sec-websocket-key: \", line, min(llen,19))) == 0) {\n\t\tsec_ws_key = line+19;\n                buf[len-2] = '\\0';\n            } else if ((strncasecmp(\"sec-websocket-version: \", line, min(llen,23))) == 0) {\n\t\tsec_ws_version = strtol(line+23, NULL, 10);\n                buf[len-2] = '\\0';\n\t    }\n\n            linestart = len;\n        }\n    }\n\n    if (!(path && host && (origin || sec_ws_origin))) {\n        rfbErr(\"webSocketsHandshake: incomplete client handshake\\n\");\n        free(response);\n        free(buf);\n        return FALSE;\n    }\n\n    if ((protocol) && (strstr(protocol, \"binary\"))) {\n        if (! sec_ws_version) {\n            rfbErr(\"webSocketsHandshake: 'binary' protocol not supported with Hixie\\n\");\n            free(response);\n            free(buf);\n            return FALSE;\n        }\n        rfbLog(\"  - webSocketsHandshake: using binary/raw encoding\\n\");\n        base64 = FALSE;\n        protocol = \"binary\";\n    } else {\n        rfbLog(\"  - webSocketsHandshake: using base64 encoding\\n\");\n        base64 = TRUE;\n        if ((protocol) && (strstr(protocol, \"base64\"))) {\n            protocol = \"base64\";\n        } else {\n            protocol = \"\";\n        }\n    }\n\n    /*\n     * Generate the WebSockets server response based on the the headers sent\n     * by the client.\n     */\n\n    if (sec_ws_version) {\n\tchar accept[B64LEN(SHA1_HASH_SIZE) + 1];\n\trfbLog(\"  - WebSockets client version hybi-%02d\\n\", sec_ws_version);\n\twebSocketsGenSha1Key(accept, sizeof(accept), sec_ws_key);\n        if(strlen(protocol) > 0)\n            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n\t                   SERVER_HANDSHAKE_HYBI, accept, protocol);\n        else\n            len = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n                           SERVER_HANDSHAKE_HYBI_NO_PROTOCOL, accept);\n    } else {\n\t/* older hixie handshake, this could be removed if\n\t * a final standard is established */\n\tif (!(key1 && key2 && key3)) {\n\t    rfbLog(\"  - WebSockets client version hixie-75\\n\");\n\t    prefix[0] = '\\0';\n\t    trailer[0] = '\\0';\n\t} else {\n\t    rfbLog(\"  - WebSockets client version hixie-76\\n\");\n\t    snprintf(prefix, 5, \"Sec-\");\n\t    webSocketsGenMd5(trailer, key1, key2, key3);\n\t}\n\tlen = snprintf(response, WEBSOCKETS_MAX_HANDSHAKE_LEN,\n\t\t SERVER_HANDSHAKE_HIXIE, prefix, origin, prefix, scheme,\n\t\t host, path, prefix, protocol, trailer);\n    }\n\n    if (rfbWriteExact(cl, response, len) < 0) {\n        rfbErr(\"webSocketsHandshake: failed sending WebSockets response\\n\");\n        free(response);\n        free(buf);\n        return FALSE;\n    }\n    /* rfbLog(\"webSocketsHandshake: %s\\n\", response); */\n    free(response);\n    free(buf);\n\n\n    wsctx = calloc(1, sizeof(ws_ctx_t));\n    if (sec_ws_version) {\n\twsctx->version = WEBSOCKETS_VERSION_HYBI;\n\twsctx->encode = webSocketsEncodeHybi;\n\twsctx->decode = webSocketsDecodeHybi;\n    } else {\n\twsctx->version = WEBSOCKETS_VERSION_HIXIE;\n\twsctx->encode = webSocketsEncodeHixie;\n\twsctx->decode = webSocketsDecodeHixie;\n    }\n    wsctx->base64 = base64;\n    hybiDecodeCleanup(wsctx);\n    cl->wsctx = (wsCtx *)wsctx;\n    return TRUE;\n}\n\nvoid\nwebSocketsGenMd5(char * target, char *key1, char *key2, char *key3)\n{\n    unsigned int i, spaces1 = 0, spaces2 = 0;\n    unsigned long num1 = 0, num2 = 0;\n    unsigned char buf[17];\n    struct iovec iov[1];\n\n    for (i=0; i < strlen(key1); i++) {\n        if (key1[i] == ' ') {\n            spaces1 += 1;\n        }\n        if ((key1[i] >= 48) && (key1[i] <= 57)) {\n            num1 = num1 * 10 + (key1[i] - 48);\n        }\n    }\n    num1 = num1 / spaces1;\n\n    for (i=0; i < strlen(key2); i++) {\n        if (key2[i] == ' ') {\n            spaces2 += 1;\n        }\n        if ((key2[i] >= 48) && (key2[i] <= 57)) {\n            num2 = num2 * 10 + (key2[i] - 48);\n        }\n    }\n    num2 = num2 / spaces2;\n\n    /* Pack it big-endian */\n    buf[0] = (num1 & 0xff000000) >> 24;\n    buf[1] = (num1 & 0xff0000) >> 16;\n    buf[2] = (num1 & 0xff00) >> 8;\n    buf[3] =  num1 & 0xff;\n\n    buf[4] = (num2 & 0xff000000) >> 24;\n    buf[5] = (num2 & 0xff0000) >> 16;\n    buf[6] = (num2 & 0xff00) >> 8;\n    buf[7] =  num2 & 0xff;\n\n    strncpy((char *)buf+8, key3, 8);\n    buf[16] = '\\0';\n\n    iov[0].iov_base = buf;\n    iov[0].iov_len = 16;\n    digestmd5(iov, 1, target);\n    target[16] = '\\0';\n\n    return;\n}\n\nstatic int\nwebSocketsEncodeHixie(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    int sz = 0;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    wsctx->codeBufEncode[sz++] = '\\x00';\n    len = b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode+sz, sizeof(wsctx->codeBufEncode) - (sz + 1));\n    if (len < 0) {\n        return len;\n    }\n    sz += len;\n\n    wsctx->codeBufEncode[sz++] = '\\xff';\n    *dst = wsctx->codeBufEncode;\n    return sz;\n}\n\nstatic int\nws_read(rfbClientPtr cl, char *buf, int len)\n{\n    int n;\n    if (cl->sslctx) {\n\tn = rfbssl_read(cl, buf, len);\n    } else {\n\tn = read(cl->sock, buf, len);\n    }\n    return n;\n}\n\nstatic int\nws_peek(rfbClientPtr cl, char *buf, int len)\n{\n    int n;\n    if (cl->sslctx) {\n\tn = rfbssl_peek(cl, buf, len);\n    } else {\n\twhile (-1 == (n = recv(cl->sock, buf, len, MSG_PEEK))) {\n\t    if (errno != EAGAIN)\n\t\tbreak;\n\t}\n    }\n    return n;\n}\n\nstatic int\nwebSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len)\n{\n    int retlen = 0, n, i, avail, modlen, needlen;\n    char *buf, *end = NULL;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    buf = wsctx->codeBufDecode;\n\n    n = ws_peek(cl, buf, len*2+2);\n\n    if (n <= 0) {\n        /* save errno because rfbErr() will tamper it */\n        int olderrno = errno;\n        rfbErr(\"%s: peek (%d) %m\\n\", __func__, errno);\n        errno = olderrno;\n        return n;\n    }\n\n\n    /* Base64 encoded WebSockets stream */\n\n    if (buf[0] == '\\xff') {\n        i = ws_read(cl, buf, 1); /* Consume marker */\n        buf++;\n        n--;\n    }\n    if (n == 0) {\n        errno = EAGAIN;\n        return -1;\n    }\n    if (buf[0] == '\\x00') {\n        i = ws_read(cl, buf, 1); /* Consume marker */\n        buf++;\n        n--;\n    }\n    if (n == 0) {\n        errno = EAGAIN;\n        return -1;\n    }\n\n    /* end = memchr(buf, '\\xff', len*2+2); */\n    end = memchr(buf, '\\xff', n);\n    if (!end) {\n        end = buf + n;\n    }\n    avail = end - buf;\n\n    len -= wsctx->carrylen;\n\n    /* Determine how much base64 data we need */\n    modlen = len + (len+2)/3;\n    needlen = modlen;\n    if (needlen % 4) {\n        needlen += 4 - (needlen % 4);\n    }\n\n    if (needlen > avail) {\n        /* rfbLog(\"Waiting for more base64 data\\n\"); */\n        errno = EAGAIN;\n        return -1;\n    }\n\n    /* Any carryover from previous decode */\n    for (i=0; i < wsctx->carrylen; i++) {\n        /* rfbLog(\"Adding carryover %d\\n\", wsctx->carryBuf[i]); */\n        dst[i] = wsctx->carryBuf[i];\n        retlen += 1;\n    }\n\n    /* Decode the rest of what we need */\n    buf[needlen] = '\\x00';  /* Replace end marker with end of string */\n    /* rfbLog(\"buf: %s\\n\", buf); */\n    n = b64_pton(buf, (unsigned char *)dst+retlen, 2+len);\n    if (n < len) {\n        rfbErr(\"Base64 decode error\\n\");\n        errno = EIO;\n        return -1;\n    }\n    retlen += n;\n\n    /* Consume the data from socket */\n    i = ws_read(cl, buf, needlen);\n\n    wsctx->carrylen = n - len;\n    retlen -= wsctx->carrylen;\n    for (i=0; i < wsctx->carrylen; i++) {\n        /* rfbLog(\"Saving carryover %d\\n\", dst[retlen + i]); */\n        wsctx->carryBuf[i] = dst[retlen + i];\n    }\n\n    /* rfbLog(\"<< webSocketsDecode, retlen: %d\\n\", retlen); */\n    return retlen;\n}\n\nstatic int\nhybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->nToRead - wsctx->nReadRaw;\n}\n\nstatic void\nhybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}\n\n/**\n * Return payload data that has been decoded/unmasked from\n * a websocket frame.\n *\n * @param[out]     dst destination buffer\n * @param[in]      len bytes to copy to destination buffer\n * @param[in,out]  wsctx internal state of decoding procedure\n * @param[out]     number of bytes actually written to dst buffer\n * @return next hybi decoding state\n */\nstatic int\nhybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n\n  /* if we have something already decoded copy and return */\n  if (wsctx->readlen > 0) {\n    /* simply return what we have */\n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}\n\n/**\n * Read an RFC 6455 websocket frame (IETF hybi working group).\n *\n * Internal state is updated according to bytes received and the\n * decoding of header information.\n *\n * @param[in]   cl client ptr with ptr to raw socket and ws_ctx_t ptr\n * @param[out]  sockRet emulated recv return value\n * @return next hybi decoding state; WS_HYBI_STATE_HEADER_PENDING indicates\n *         that the header was not received completely.\n */\nstatic int\nhybiReadHeader(rfbClientPtr cl, int *sockRet)\n{\n  int ret;\n  ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n  char *headerDst = wsctx->codeBufDecode + wsctx->nReadRaw;\n  int n = WSHLENMAX - wsctx->nReadRaw;\n\n  rfbLog(\"header_read to %p with len=%d\\n\", headerDst, n);\n  ret = ws_read(cl, headerDst, n);\n  rfbLog(\"read %d bytes from socket\\n\", ret);\n  if (ret <= 0) {\n    if (-1 == ret) {\n      /* save errno because rfbErr() will tamper it */\n      int olderrno = errno;\n      rfbErr(\"%s: peek; %m\\n\", __func__);\n      errno = olderrno;\n      *sockRet = -1;\n    } else {\n      *sockRet = 0;\n    }\n    return WS_HYBI_STATE_ERR;\n  }\n\n  wsctx->nReadRaw += ret;\n  if (wsctx->nReadRaw < 2) {\n    /* cannot decode header with less than two bytes */\n    errno = EAGAIN;\n    *sockRet = -1;\n    return WS_HYBI_STATE_HEADER_PENDING;\n  }\n\n  /* first two header bytes received; interpret header data and get rest */\n  wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;\n\n  wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;\n\n  /* fin = (header->b0 & 0x80) >> 7; */ /* not used atm */\n  wsctx->header.payloadLen = wsctx->header.data->b1 & 0x7f;\n  rfbLog(\"first header bytes received; opcode=%d lenbyte=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen);\n\n  /*\n   * 4.3. Client-to-Server Masking\n   *\n   * The client MUST mask all frames sent to the server.  A server MUST\n   * close the connection upon receiving a frame with the MASK bit set to 0.\n  **/\n  if (!(wsctx->header.data->b1 & 0x80)) {\n    rfbErr(\"%s: got frame without mask ret=%d\\n\", __func__, ret);\n    errno = EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  if (wsctx->header.payloadLen < 126 && wsctx->nReadRaw >= 6) {\n    wsctx->header.headerLen = 2 + WS_HYBI_MASK_LEN;\n    wsctx->header.mask = wsctx->header.data->u.m;\n  } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->nReadRaw) {\n    wsctx->header.headerLen = 4 + WS_HYBI_MASK_LEN;\n    wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);\n    wsctx->header.mask = wsctx->header.data->u.s16.m16;\n  } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->nReadRaw) {\n    wsctx->header.headerLen = 10 + WS_HYBI_MASK_LEN;\n    wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);\n    wsctx->header.mask = wsctx->header.data->u.s64.m64;\n  } else {\n    /* Incomplete frame header, try again */\n    rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);\n    errno = EAGAIN;\n    *sockRet = -1;\n    return WS_HYBI_STATE_HEADER_PENDING;\n  }\n\n  /* absolute length of frame */\n  wsctx->nToRead = wsctx->header.headerLen + wsctx->header.payloadLen;\n\n  /* set payload pointer just after header */\n  wsctx->writePos = wsctx->codeBufDecode + wsctx->nReadRaw;\n\n  wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);\n\n  rfbLog(\"header complete: state=%d flen=%d writeTo=%p\\n\", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos);\n\n  return WS_HYBI_STATE_DATA_NEEDED;\n}\n\nstatic int\nhybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}\n\nstatic char *\nhybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}\n\n\n/**\n * Read the remaining payload bytes from associated raw socket.\n *\n *  - try to read remaining bytes from socket\n *  - unmask all multiples of 4\n *  - if frame incomplete but some bytes are left, these are copied to\n *      the carry buffer\n *  - if opcode is TEXT: Base64-decode all unmasked received bytes\n *  - set state for reading decoded data\n *  - reset write position to begin of buffer (+ header)\n *      --> before we retrieve more data we let the caller clear all bytes\n *          from the reception buffer\n *  - execute return data routine\n *\n *  Sets errno corresponding to what it gets from the underlying\n *  socket or EIO if some internal sanity check fails.\n *\n *  @param[in]  cl client ptr with raw socket reference\n *  @param[out] dst  destination buffer\n *  @param[in]  len  size of destination buffer\n *  @param[out] sockRet emulated recv return value\n *  @return next hybi decode state\n */\nstatic int\nhybiReadAndDecode(rfbClientPtr cl, char *dst, int len, int *sockRet)\n{\n  int n;\n  int i;\n  int toReturn;\n  int toDecode;\n  int bufsize;\n  int nextRead;\n  unsigned char *data;\n  uint32_t *data32;\n  ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n  /* if data was carried over, copy to start of buffer */\n  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n  wsctx->writePos += wsctx->carrylen;\n\n  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n  if (hybiRemaining(wsctx) > bufsize) {\n    nextRead = bufsize;\n  } else {\n    nextRead = hybiRemaining(wsctx);\n  }\n\n  rfbLog(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d\\n)\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n\n  if (wsctx->nReadRaw < wsctx->nToRead) {\n    /* decode more data */\n    if (-1 == (n = ws_read(cl, wsctx->writePos, nextRead))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %m\", __func__);\n      errno = olderrno;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    } else if (n == 0) {\n      *sockRet = 0;\n      return WS_HYBI_STATE_ERR;\n    }\n    wsctx->nReadRaw += n;\n    rfbLog(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadRaw);\n  } else {\n    n = 0;\n  }\n\n  wsctx->writePos += n;\n\n  if (wsctx->nReadRaw >= wsctx->nToRead) {\n    if (wsctx->nReadRaw > wsctx->nToRead) {\n      rfbErr(\"%s: internal error, read past websocket frame\", __func__);\n      errno=EIO;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    }\n  }\n\n  toDecode = wsctx->writePos - hybiPayloadStart(wsctx);\n  rfbLog(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n  if (toDecode < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n    errno=EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n  data = (unsigned char *)hybiPayloadStart(wsctx);\n  data32= (uint32_t *)data;\n\n  for (i = 0; i < (toDecode >> 2); i++) {\n    data32[i] ^= wsctx->header.mask.u;\n  }\n  rfbLog(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n\n  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < toDecode; i++) {\n      data[i] ^= wsctx->header.mask.c[i % 4];\n    }\n\n    /* all data is here, no carrying */\n    wsctx->carrylen = 0;\n  } else {\n    /* carry over remaining, non-multiple-of-four bytes */\n    wsctx->carrylen = toDecode - (i * 4);\n    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n      *sockRet = -1;\n      errno = EIO;\n      return WS_HYBI_STATE_ERR;\n    }\n    rfbLog(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n  }\n\n  toReturn = toDecode - wsctx->carrylen;\n\n  switch (wsctx->header.opcode) {\n    case WS_OPCODE_CLOSE:\n\n      /* this data is not returned as payload data */\n      if (hybiWsFrameComplete(wsctx)) {\n        rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)data)[0]));\n        errno = ECONNRESET;\n        *sockRet = -1;\n        return WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        rfbErr(\"%s: close reason with long frame not supported\", __func__);\n        errno = EIO;\n        *sockRet = -1;\n        return WS_HYBI_STATE_ERR;\n      }\n      break;\n    case WS_OPCODE_TEXT_FRAME:\n      data[toReturn] = '\\0';\n      rfbLog(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n      if (-1 == (wsctx->readlen = b64_pton((char *)data, data, bufsize))) {\n        rfbErr(\"Base64 decode error in %s; data=%p bufsize=%d\", __func__, data, bufsize);\n        rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);\n      }\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    case WS_OPCODE_BINARY_FRAME:\n      wsctx->readlen = toReturn;\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n  }\n  wsctx->readPos = data;\n\n  return hybiReturnData(dst, len, wsctx, sockRet);\n}\n\n/**\n * Read function for websocket-socket emulation.\n *\n *    0                   1                   2                   3\n *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *   +-+-+-+-+-------+-+-------------+-------------------------------+\n *   |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n *   |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n *   |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n *   | |1|2|3|       |K|             |                               |\n *   +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n *   |     Extended payload length continued, if payload len == 127  |\n *   + - - - - - - - - - - - - - - - +-------------------------------+\n *   |                               |Masking-key, if MASK set to 1  |\n *   +-------------------------------+-------------------------------+\n *   | Masking-key (continued)       |          Payload Data         |\n *   +-------------------------------- - - - - - - - - - - - - - - - +\n *   :                     Payload Data continued ...                :\n *   + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n *   |                     Payload Data continued ...                |\n *   +---------------------------------------------------------------+\n *\n * Using the decode buffer, this function:\n *  - reads the complete header from the underlying socket\n *  - reads any remaining data bytes\n *  - unmasks the payload data using the provided mask\n *  - decodes Base64 encoded text data\n *  - copies len bytes of decoded payload data into dst\n *\n * Emulates a read call on a socket.\n */\nstatic int\nwebSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)\n{\n    int result = -1;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    /* int fin; */ /* not used atm */\n\n    /* rfbLog(\" <== %s[%d]: %d cl: %p, wsctx: %p-%p (%d)\\n\", __func__, gettid(), len, cl, wsctx, (char *)wsctx + sizeof(ws_ctx_t), sizeof(ws_ctx_t)); */\n    rfbLog(\"%s_enter: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writeTo=%p \"\n                      \"state=%d toRead=%d remaining=%d \"\n                      \" nReadRaw=%d carrylen=%d carryBuf=%p\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),\n                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf);\n\n    switch (wsctx->hybiDecodeState){\n      case WS_HYBI_STATE_HEADER_PENDING:\n        wsctx->hybiDecodeState = hybiReadHeader(cl, &result);\n        if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n          goto spor;\n        }\n        if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {\n\n          /* when header is complete, try to read some more data */\n          wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n        }\n        break;\n      case WS_HYBI_STATE_DATA_AVAILABLE:\n        wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);\n        break;\n      case WS_HYBI_STATE_DATA_NEEDED:\n        wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n        break;\n      case WS_HYBI_STATE_CLOSE_REASON_PENDING:\n        wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);\n        break;\n      default:\n        /* invalid state */\n        rfbErr(\"%s: called with invalid state %d\\n\", wsctx->hybiDecodeState);\n        result = -1;\n        errno = EIO;\n        wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;\n    }\n\n    /* single point of return, if someone has questions :-) */\nspor:\n    /* rfbLog(\"%s: ret: %d/%d\\n\", __func__, result, len); */\n    if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n      rfbLog(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);\n      /* frame finished, cleanup state */\n      hybiDecodeCleanup(wsctx);\n    } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {\n      hybiDecodeCleanup(wsctx);\n    }\n    rfbLog(\"%s_exit: len=%d; \"\n                      \"CTX: readlen=%d readPos=%p \"\n                      \"writePos=%p \"\n                      \"state=%d toRead=%d remaining=%d \"\n                      \"nRead=%d carrylen=%d carryBuf=%p \"\n                      \"result=%d\\n\",\n                      __func__, len,\n                      wsctx->readlen, wsctx->readPos,\n                      wsctx->writePos,\n                      wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),\n                      wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf,\n                      result);\n    return result;\n}\n\nstatic int\nwebSocketsEncodeHybi(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    int blen, ret = -1, sz = 0;\n    unsigned char opcode = '\\0'; /* TODO: option! */\n    ws_header_t *header;\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n\n    /* Optional opcode:\n     *   0x0 - continuation\n     *   0x1 - text frame (base64 encode buf)\n     *   0x2 - binary frame (use raw buf)\n     *   0x8 - connection close\n     *   0x9 - ping\n     *   0xA - pong\n    **/\n    if (!len) {\n\t  /* nothing to encode */\n\t  return 0;\n    }\n\n    header = (ws_header_t *)wsctx->codeBufEncode;\n\n    if (wsctx->base64) {\n\topcode = WS_OPCODE_TEXT_FRAME;\n\t/* calculate the resulting size */\n\tblen = B64LEN(len);\n    } else {\n\topcode = WS_OPCODE_BINARY_FRAME;\n\tblen = len;\n    }\n\n    header->b0 = 0x80 | (opcode & 0x0f);\n    if (blen <= 125) {\n      header->b1 = (uint8_t)blen;\n      sz = 2;\n    } else if (blen <= 65536) {\n      header->b1 = 0x7e;\n      header->u.s16.l16 = WS_HTON16((uint16_t)blen);\n      sz = 4;\n    } else {\n      header->b1 = 0x7f;\n      header->u.s64.l64 = WS_HTON64(blen);\n      sz = 10;\n    }\n\n    if (wsctx->base64) {\n        if (-1 == (ret = b64_ntop((unsigned char *)src, len, wsctx->codeBufEncode + sz, sizeof(wsctx->codeBufEncode) - sz))) {\n\t  rfbErr(\"%s: Base 64 encode failed\\n\", __func__);\n\t} else {\n\t  if (ret != blen)\n\t    rfbErr(\"%s: Base 64 encode; something weird happened\\n\", __func__);\n\t  ret += sz;\n\t}\n    } else {\n      memcpy(wsctx->codeBufEncode + sz, src, len);\n      ret =  sz + len;\n    }\n\n    *dst = wsctx->codeBufEncode;\n\n    return ret;\n}\n\nint\nwebSocketsEncode(rfbClientPtr cl, const char *src, int len, char **dst)\n{\n    return ((ws_ctx_t *)cl->wsctx)->encode(cl, src, len, dst);\n}\n\nint\nwebSocketsDecode(rfbClientPtr cl, char *dst, int len)\n{\n    return ((ws_ctx_t *)cl->wsctx)->decode(cl, dst, len);\n}\n\n\n/* returns TRUE if client sent a close frame or a single 'end of frame'\n * marker was received, FALSE otherwise\n *\n * Note: This is a Hixie-only hack!\n **/\nrfbBool\nwebSocketCheckDisconnect(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    /* With Base64 encoding we need at least 4 bytes */\n    char peekbuf[4];\n    int n;\n\n    if (wsctx->version == WEBSOCKETS_VERSION_HYBI)\n\treturn FALSE;\n\n    if (cl->sslctx)\n\tn = rfbssl_peek(cl, peekbuf, 4);\n    else\n\tn = recv(cl->sock, peekbuf, 4, MSG_PEEK);\n\n    if (n <= 0) {\n\tif (n != 0)\n\t    rfbErr(\"%s: peek; %m\", __func__);\n\trfbCloseClient(cl);\n\treturn TRUE;\n    }\n\n    if (peekbuf[0] == '\\xff') {\n\tint doclose = 0;\n\t/* Make sure we don't miss a client disconnect on an end frame\n\t * marker. Because we use a peek buffer in some cases it is not\n\t * applicable to wait for more data per select(). */\n\tswitch (n) {\n\t    case 3:\n\t\tif (peekbuf[1] == '\\xff' && peekbuf[2] == '\\x00')\n\t\t    doclose = 1;\n\t\tbreak;\n\t    case 2:\n\t\tif (peekbuf[1] == '\\x00')\n\t\t    doclose = 1;\n\t\tbreak;\n\t    default:\n\t\treturn FALSE;\n\t}\n\n\tif (cl->sslctx)\n\t    n = rfbssl_read(cl, peekbuf, n);\n\telse\n\t    n = read(cl->sock, peekbuf, n);\n\n\tif (doclose) {\n\t    rfbErr(\"%s: websocket close frame received\\n\", __func__);\n\t    rfbCloseClient(cl);\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/* returns TRUE if there is data waiting to be read in our internal buffer\n * or if is there any pending data in the buffer of the SSL implementation\n */\nrfbBool\nwebSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    if (wsctx && wsctx->readlen)\n      return TRUE;\n\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}\n"], "filenames": ["libvncserver/websockets.c"], "buggy_code_start_loc": [79], "buggy_code_end_loc": [955], "fixing_code_start_loc": [80], "fixing_code_end_loc": [1286], "type": "CWE-787", "message": "It was discovered that websockets.c in LibVNCServer prior to 0.9.12 did not properly decode certain WebSocket frames. A malicious attacker could exploit this by sending specially crafted WebSocket frames to a server, causing a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2017-18922", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-30T11:15:10.380", "lastModified": "2022-04-01T18:08:12.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "It was discovered that websockets.c in LibVNCServer prior to 0.9.12 did not properly decode certain WebSocket frames. A malicious attacker could exploit this by sending specially crafted WebSocket frames to a server, causing a heap-based buffer overflow."}, {"lang": "es", "value": "Se detect\u00f3 que el archivo websockets.c en LibVNCServer versiones anteriores a 0.9.12, no decodificaba apropiadamente determinados tramas de WebSocket. Un atacante malicioso podr\u00eda explotar esto mediante el env\u00edo de tramas de WebSocket especialmente dise\u00f1adas hacia un servidor, causando un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvncserver_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.12", "matchCriteriaId": "8A3F7478-C54D-43A6-85A5-5AB59D446D75"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00028.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/06/30/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1852356", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/aac95a9dcf4bbba87b76c72706c3221a842ca433", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4F6FUH4EFK4NAP6GT4TQRTBKWIRCZLIY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NVP7TJVYJDXDFRHVQ3ENEN3H354QPXEZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4407-1/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/06/30/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/aac95a9dcf4bbba87b76c72706c3221a842ca433"}}