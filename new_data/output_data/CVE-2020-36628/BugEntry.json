{"buggy_code": ["package com.calsignlabs.apde.build.dag;\n\nimport com.calsignlabs.apde.R;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * Supports the following combination of in types, out types, and zip methods:\n *  - FILE FILE COPY\n *  - FILE STREAM COPY\n *  - STREAM FILE COPY\n *  - STREAM STREAM COPY\n *  - STREAM FOLDER EXTRACT\n *  - FILE FOLDER EXTRACT\n *  - FOLDER STREAM COMPRESS\n *  - FOLDER FILE COMPRESS\n *\n *  Note that ASSET for input is equivalent to STREAM.\n */\npublic class CopyBuildTask extends BuildTask {\n\tprivate static final int BUFFER_SIZE = 8192;\n\t\n\tprivate static final int NONE     = 0x00000000;\n\tprivate static final int FILE     = 0x00000001;\n\tprivate static final int FOLDER   = 0x00000002;\n\tprivate static final int STREAM   = 0x00000004;\n\t\n\tprivate static final int COPY     = 0x00000100;\n\tprivate static final int EXTRACT  = 0x00000200;\n\tprivate static final int COMPRESS = 0x00000400;\n\t\n\tprivate int inputType, outputType;\n\tprivate Getter<File> inputFile, outputFile;\n\tprivate Getter<InputStream> inputStreamGetter;\n\tprivate Getter<OutputStream> outputStreamGetter;\n\tprivate int zipMethod;\n\t\n\tprivate boolean vacuousSuccess = false;\n\t\n\tpublic CopyBuildTask(BuildTask... deps) {\n\t\tsuper(deps);\n\t\tinputType = NONE;\n\t\toutputType = NONE;\n\t\tzipMethod = COPY;\n\t}\n\t\n\t// TODO add support for functional folder copies\n\tpublic CopyBuildTask inFile(Getter<File> in) {\n\t\tinputType = FILE;\n\t\tinputFile = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inFolder(Getter<File> in) {\n\t\tinputType = FOLDER;\n\t\tinputFile = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inStream(Getter<InputStream> in) {\n\t\tinputType = STREAM;\n\t\tinputStreamGetter = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inAsset(String assetsPath) {\n\t\tsetName(\"copy asset: \" + assetsPath);\n\t\t\n\t\treturn inStream(context -> {\n\t\t\ttry {\n\t\t\t\treturn context.getResources().getAssets().open(assetsPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic CopyBuildTask outFile(Getter<File> out, boolean detectChange) {\n\t\toutputType = FILE;\n\t\toutputFile = out;\n\t\tif (detectChange && (inputType == FILE || inputType == STREAM)) {\n\t\t\tpopulateStreamsForFiles();\n\t\t\torChangeNoticer((new ChecksumChangeNoticer()).sourceDestStream(inputStreamGetter, fis(out)));\n\t\t}\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask outFile(Getter<File> out) {\n\t\treturn outFile(out, true);\n\t}\n\t\n\tpublic CopyBuildTask outFolder(Getter<File> out) {\n\t\toutputType = FOLDER;\n\t\toutputFile = out;\n\t\t// It's better to just do diffs on the source\n//\t\tif (inputType == FOLDER) {\n//\t\t\torChangeNoticer((new ChecksumChangeNoticer()).sourceDestFile(inputFile, out));\n//\t\t}\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask outStream(Getter<OutputStream> out) {\n\t\toutputType = STREAM;\n\t\toutputStreamGetter = out;\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask extract() {\n\t\tzipMethod = EXTRACT;\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask compress() {\n\t\tzipMethod = COMPRESS;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Default success if the file to copy doesn't exist\n\t *\n\t * @param vacuousSuccess\n\t * @return\n\t */\n\tpublic CopyBuildTask setVacuousSuccess(boolean vacuousSuccess) {\n\t\tthis.vacuousSuccess = vacuousSuccess;\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic CharSequence getTitle() {\n\t\treturn getBuildContext().getResources().getString(R.string.build_copying);\n\t}\n\t\n\t@Override\n\tpublic void run() throws InterruptedException {\n\t\tswitch (inputType | outputType << 4 | zipMethod) {\n\t\t\tcase FILE | FILE << 4 | COPY:\n\t\t\tcase FILE | STREAM << 4 | COPY:\n\t\t\tcase STREAM | FILE << 4 | COPY:\n\t\t\tcase STREAM | STREAM << 4 | COPY:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tstreamCopy();\n\t\t\t\tbreak;\n\t\t\tcase FOLDER | FOLDER << 4 | COPY:\n\t\t\t\tfolderCopy();\n\t\t\t\tbreak;\n\t\t\tcase STREAM | FOLDER << 4 | EXTRACT:\n\t\t\tcase FILE | FOLDER << 4 | EXTRACT:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tzipExtract();\n\t\t\t\tbreak;\n\t\t\tcase FOLDER | STREAM << 4 | COMPRESS:\n\t\t\tcase FOLDER | FILE << 4 | COMPRESS:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tzipCompress();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Invalid copy task parameters: \" + inputType + \", \" + outputType + \", \" + zipMethod);\n\t\t}\n\t}\n\t\n\tprivate void populateStreamsForFiles() {\n\t\t// We convert files into streams so that we can use the same method for interchangeably\n\t\t// copying streams and files.\n\t\t\n\t\tif (inputStreamGetter == null) {\n\t\t\tinputStreamGetter = fis(inputFile);\n\t\t}\n\t\t\n\t\tif (outputStreamGetter == null) {\n\t\t\toutputStreamGetter = fos(outputFile);\n\t\t}\n\t}\n\t\n\tprivate void streamCopy() {\n\t\tfinish(handleStreamCopy(inputStreamGetter.get(getBuildContext()), outputStreamGetter.get(getBuildContext())));\n\t}\n\t\n\tprivate void folderCopy() {\n\t\tfinish(copyFolder(inputFile.get(getBuildContext()), outputFile.get(getBuildContext()), vacuousSuccess));\n\t}\n\t\n\tprivate void zipExtract() {\n\t\tfinish(handleExtract(inputStreamGetter.get(getBuildContext()), outputFile.get(getBuildContext())));\n\t}\n\t\n\tprivate void zipCompress() {\n\t\tfinish(handleCompress(inputFile.get(getBuildContext()), outputStreamGetter.get(getBuildContext())));\n\t}\n\t\n\tprivate static boolean handleStreamCopy(InputStream in, OutputStream out) {\n\t\treturn handleStreamCopy(in, out, true, true);\n\t}\n\t\n\tprivate static boolean handleStreamCopy(InputStream inputStream, OutputStream outputStream, boolean closeIn, boolean closeOut) {\n\t\ttry {\n\t\t\tcopyStream(inputStream, outputStream);\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (closeIn && inputStream != null) inputStream.close();\n\t\t\t\tif (closeOut && outputStream != null) outputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void copyStream(InputStream inputStream, OutputStream outputStream) throws IOException {\n\t\tbyte[] buf = new byte[BUFFER_SIZE];\n\t\tint len;\n\t\twhile (-1 != (len = inputStream.read(buf))) {\n\t\t\toutputStream.write(buf, 0, len);\n\t\t}\n\t}\n\t\n\tprivate static boolean copyFolder(File source, File target, boolean vacuousSuccess) {\n\t\tif (!source.exists()) return vacuousSuccess;\n\t\tif (source.equals(target)) return false;\n\t\tif (!target.exists() && !target.mkdirs()) return false;\n\t\t\n\t\ttry {\n\t\t\tfor (String file : source.list()) {\n\t\t\t\tFile sourceFile = new File(source, file);\n\t\t\t\tFile targetFile = new File(target, file);\n\t\t\t\tif (sourceFile.isDirectory()) {\n\t\t\t\t\tif (!copyFolder(sourceFile, targetFile, vacuousSuccess)) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!handleStreamCopy(new FileInputStream(sourceFile), new FileOutputStream(targetFile)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean handleExtract(InputStream inputStream, File folder) {\n\t\tif (folder.exists() && !folder.isDirectory()) return false;\n\t\tif (!folder.exists() && !folder.mkdirs()) return false;\n\t\t\n\t\tZipInputStream zipIn = null;\n\t\t\n\t\ttry {\n\t\t\tzipIn = new ZipInputStream(inputStream);\n\t\t\t\n\t\t\tZipEntry zipEntry;\n\t\t\twhile ((zipEntry = zipIn.getNextEntry()) != null) {\n\t\t\t\tFile file = new File(folder, zipEntry.getName());\n\t\t\t\t\n\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\tif (!file.exists() && !file.mkdirs()) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) return false;\n\t\t\t\t\tif (!handleStreamCopy(zipIn, new FileOutputStream(file), false, true)) return false;\n\t\t\t\t\tzipIn.closeEntry();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zipIn != null) {\n\t\t\t\t\tzipIn.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static boolean handleCompress(File folder, OutputStream outputStream) {\n\t\tZipOutputStream out = null;\n\t\t\n\t\ttry {\n\t\t\tList<File> files = new ArrayList<>();\n\t\t\tbuildFileList(files, folder);\n\t\t\t\n\t\t\tString absPath = folder.getAbsolutePath();\n\t\t\tint folderLength = absPath.endsWith(\"/\") ? absPath.length() : absPath.length() + 1;\n\t\t\t\n\t\t\tout = new ZipOutputStream(new BufferedOutputStream(outputStream));\n\t\t\t\n\t\t\tfor (File file : files) {\n\t\t\t\tZipEntry entry = new ZipEntry(file.getAbsolutePath().substring(folderLength));\n\t\t\t\tout.putNextEntry(entry);\n\t\t\t\tif (!handleStreamCopy(new FileInputStream(file), out, true, false)) return false;\n\t\t\t\tout.closeEntry();\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (out != null) {\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e2) {\n\t\t\t\te2.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void buildFileList(List<File> ret, File dir) {\n\t\tif (dir != null && dir.exists()) {\n\t\t\tif (dir.isDirectory()) {\n\t\t\t\tfor (File file : dir.listFiles()) {\n\t\t\t\t\tbuildFileList(ret, file);\n\t\t\t\t}\n\t\t\t} else if (dir.isFile()) {\n\t\t\t\tret.add(dir);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static Getter<InputStream> fis(Getter<File> file) {\n\t\treturn context -> {\n\t\t\ttry {\n\t\t\t\treturn new FileInputStream(file.get(context));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tprivate static Getter<OutputStream> fos(Getter<File> file) {\n\t\treturn context -> {\n\t\t\ttry {\n\t\t\t\treturn new FileOutputStream(file.get(context));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n}\n", "// Top-level build file where you can add configuration options common to all sub-projects/modules.\nbuildscript {\n    repositories {\n        jcenter()\n        google()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.6.2'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n"], "fixing_code": ["package com.calsignlabs.apde.build.dag;\n\nimport com.calsignlabs.apde.R;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * Supports the following combination of in types, out types, and zip methods:\n *  - FILE FILE COPY\n *  - FILE STREAM COPY\n *  - STREAM FILE COPY\n *  - STREAM STREAM COPY\n *  - STREAM FOLDER EXTRACT\n *  - FILE FOLDER EXTRACT\n *  - FOLDER STREAM COMPRESS\n *  - FOLDER FILE COMPRESS\n *\n *  Note that ASSET for input is equivalent to STREAM.\n */\npublic class CopyBuildTask extends BuildTask {\n\tprivate static final int BUFFER_SIZE = 8192;\n\t\n\tprivate static final int NONE     = 0x00000000;\n\tprivate static final int FILE     = 0x00000001;\n\tprivate static final int FOLDER   = 0x00000002;\n\tprivate static final int STREAM   = 0x00000004;\n\t\n\tprivate static final int COPY     = 0x00000100;\n\tprivate static final int EXTRACT  = 0x00000200;\n\tprivate static final int COMPRESS = 0x00000400;\n\t\n\tprivate int inputType, outputType;\n\tprivate Getter<File> inputFile, outputFile;\n\tprivate Getter<InputStream> inputStreamGetter;\n\tprivate Getter<OutputStream> outputStreamGetter;\n\tprivate int zipMethod;\n\t\n\tprivate boolean vacuousSuccess = false;\n\t\n\tpublic CopyBuildTask(BuildTask... deps) {\n\t\tsuper(deps);\n\t\tinputType = NONE;\n\t\toutputType = NONE;\n\t\tzipMethod = COPY;\n\t}\n\t\n\t// TODO add support for functional folder copies\n\tpublic CopyBuildTask inFile(Getter<File> in) {\n\t\tinputType = FILE;\n\t\tinputFile = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inFolder(Getter<File> in) {\n\t\tinputType = FOLDER;\n\t\tinputFile = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inStream(Getter<InputStream> in) {\n\t\tinputType = STREAM;\n\t\tinputStreamGetter = in;\n\t\torGetterChangeNoticer(in);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask inAsset(String assetsPath) {\n\t\tsetName(\"copy asset: \" + assetsPath);\n\t\t\n\t\treturn inStream(context -> {\n\t\t\ttry {\n\t\t\t\treturn context.getResources().getAssets().open(assetsPath);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic CopyBuildTask outFile(Getter<File> out, boolean detectChange) {\n\t\toutputType = FILE;\n\t\toutputFile = out;\n\t\tif (detectChange && (inputType == FILE || inputType == STREAM)) {\n\t\t\tpopulateStreamsForFiles();\n\t\t\torChangeNoticer((new ChecksumChangeNoticer()).sourceDestStream(inputStreamGetter, fis(out)));\n\t\t}\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask outFile(Getter<File> out) {\n\t\treturn outFile(out, true);\n\t}\n\t\n\tpublic CopyBuildTask outFolder(Getter<File> out) {\n\t\toutputType = FOLDER;\n\t\toutputFile = out;\n\t\t// It's better to just do diffs on the source\n//\t\tif (inputType == FOLDER) {\n//\t\t\torChangeNoticer((new ChecksumChangeNoticer()).sourceDestFile(inputFile, out));\n//\t\t}\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask outStream(Getter<OutputStream> out) {\n\t\toutputType = STREAM;\n\t\toutputStreamGetter = out;\n\t\torGetterChangeNoticer(out);\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask extract() {\n\t\tzipMethod = EXTRACT;\n\t\treturn this;\n\t}\n\t\n\tpublic CopyBuildTask compress() {\n\t\tzipMethod = COMPRESS;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Default success if the file to copy doesn't exist\n\t *\n\t * @param vacuousSuccess\n\t * @return\n\t */\n\tpublic CopyBuildTask setVacuousSuccess(boolean vacuousSuccess) {\n\t\tthis.vacuousSuccess = vacuousSuccess;\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic CharSequence getTitle() {\n\t\treturn getBuildContext().getResources().getString(R.string.build_copying);\n\t}\n\t\n\t@Override\n\tpublic void run() throws InterruptedException {\n\t\tswitch (inputType | outputType << 4 | zipMethod) {\n\t\t\tcase FILE | FILE << 4 | COPY:\n\t\t\tcase FILE | STREAM << 4 | COPY:\n\t\t\tcase STREAM | FILE << 4 | COPY:\n\t\t\tcase STREAM | STREAM << 4 | COPY:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tstreamCopy();\n\t\t\t\tbreak;\n\t\t\tcase FOLDER | FOLDER << 4 | COPY:\n\t\t\t\tfolderCopy();\n\t\t\t\tbreak;\n\t\t\tcase STREAM | FOLDER << 4 | EXTRACT:\n\t\t\tcase FILE | FOLDER << 4 | EXTRACT:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tzipExtract();\n\t\t\t\tbreak;\n\t\t\tcase FOLDER | STREAM << 4 | COMPRESS:\n\t\t\tcase FOLDER | FILE << 4 | COMPRESS:\n\t\t\t\tpopulateStreamsForFiles();\n\t\t\t\tzipCompress();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Invalid copy task parameters: \" + inputType + \", \" + outputType + \", \" + zipMethod);\n\t\t}\n\t}\n\t\n\tprivate void populateStreamsForFiles() {\n\t\t// We convert files into streams so that we can use the same method for interchangeably\n\t\t// copying streams and files.\n\t\t\n\t\tif (inputStreamGetter == null) {\n\t\t\tinputStreamGetter = fis(inputFile);\n\t\t}\n\t\t\n\t\tif (outputStreamGetter == null) {\n\t\t\toutputStreamGetter = fos(outputFile);\n\t\t}\n\t}\n\t\n\tprivate void streamCopy() {\n\t\tfinish(handleStreamCopy(inputStreamGetter.get(getBuildContext()), outputStreamGetter.get(getBuildContext())));\n\t}\n\t\n\tprivate void folderCopy() {\n\t\tfinish(copyFolder(inputFile.get(getBuildContext()), outputFile.get(getBuildContext()), vacuousSuccess));\n\t}\n\t\n\tprivate void zipExtract() {\n\t\tfinish(handleExtract(inputStreamGetter.get(getBuildContext()), outputFile.get(getBuildContext())));\n\t}\n\t\n\tprivate void zipCompress() {\n\t\tfinish(handleCompress(inputFile.get(getBuildContext()), outputStreamGetter.get(getBuildContext())));\n\t}\n\t\n\tprivate static boolean handleStreamCopy(InputStream in, OutputStream out) {\n\t\treturn handleStreamCopy(in, out, true, true);\n\t}\n\t\n\tprivate static boolean handleStreamCopy(InputStream inputStream, OutputStream outputStream, boolean closeIn, boolean closeOut) {\n\t\ttry {\n\t\t\tcopyStream(inputStream, outputStream);\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (closeIn && inputStream != null) inputStream.close();\n\t\t\t\tif (closeOut && outputStream != null) outputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void copyStream(InputStream inputStream, OutputStream outputStream) throws IOException {\n\t\tbyte[] buf = new byte[BUFFER_SIZE];\n\t\tint len;\n\t\twhile (-1 != (len = inputStream.read(buf))) {\n\t\t\toutputStream.write(buf, 0, len);\n\t\t}\n\t}\n\t\n\tprivate static boolean copyFolder(File source, File target, boolean vacuousSuccess) {\n\t\tif (!source.exists()) return vacuousSuccess;\n\t\tif (source.equals(target)) return false;\n\t\tif (!target.exists() && !target.mkdirs()) return false;\n\t\t\n\t\ttry {\n\t\t\tfor (String file : source.list()) {\n\t\t\t\tFile sourceFile = new File(source, file);\n\t\t\t\tFile targetFile = new File(target, file);\n\t\t\t\tif (sourceFile.isDirectory()) {\n\t\t\t\t\tif (!copyFolder(sourceFile, targetFile, vacuousSuccess)) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!handleStreamCopy(new FileInputStream(sourceFile), new FileOutputStream(targetFile)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean handleExtract(InputStream inputStream, File folder) {\n\t\tif (folder.exists() && !folder.isDirectory()) return false;\n\t\tif (!folder.exists() && !folder.mkdirs()) return false;\n\t\t\n\t\tZipInputStream zipIn = null;\n\t\t\n\t\ttry {\n\t\t\tzipIn = new ZipInputStream(inputStream);\n\t\t\t\n\t\t\tZipEntry zipEntry;\n\t\t\twhile ((zipEntry = zipIn.getNextEntry()) != null) {\n\t\t\t\tFile file = new File(folder, zipEntry.getName());\n\t\t\t\tif (file.getCanonicalPath().startsWith(folder.getCanonicalPath())) {\n\t\t\t\t\tSystem.err.println(\"Aborted zip! Attempted zip path traversal attack extracting to: \" + folder.getAbsolutePath());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\tif (!file.exists() && !file.mkdirs()) return false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) return false;\n\t\t\t\t\tif (!handleStreamCopy(zipIn, new FileOutputStream(file), false, true)) return false;\n\t\t\t\t\tzipIn.closeEntry();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zipIn != null) {\n\t\t\t\t\tzipIn.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static boolean handleCompress(File folder, OutputStream outputStream) {\n\t\tZipOutputStream out = null;\n\t\t\n\t\ttry {\n\t\t\tList<File> files = new ArrayList<>();\n\t\t\tbuildFileList(files, folder);\n\t\t\t\n\t\t\tString absPath = folder.getAbsolutePath();\n\t\t\tint folderLength = absPath.endsWith(\"/\") ? absPath.length() : absPath.length() + 1;\n\t\t\t\n\t\t\tout = new ZipOutputStream(new BufferedOutputStream(outputStream));\n\t\t\t\n\t\t\tfor (File file : files) {\n\t\t\t\tZipEntry entry = new ZipEntry(file.getAbsolutePath().substring(folderLength));\n\t\t\t\tout.putNextEntry(entry);\n\t\t\t\tif (!handleStreamCopy(new FileInputStream(file), out, true, false)) return false;\n\t\t\t\tout.closeEntry();\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (out != null) {\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e2) {\n\t\t\t\te2.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void buildFileList(List<File> ret, File dir) {\n\t\tif (dir != null && dir.exists()) {\n\t\t\tif (dir.isDirectory()) {\n\t\t\t\tfor (File file : dir.listFiles()) {\n\t\t\t\t\tbuildFileList(ret, file);\n\t\t\t\t}\n\t\t\t} else if (dir.isFile()) {\n\t\t\t\tret.add(dir);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static Getter<InputStream> fis(Getter<File> file) {\n\t\treturn context -> {\n\t\t\ttry {\n\t\t\t\treturn new FileInputStream(file.get(context));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tprivate static Getter<OutputStream> fos(Getter<File> file) {\n\t\treturn context -> {\n\t\t\ttry {\n\t\t\t\treturn new FileOutputStream(file.get(context));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n}\n", "// Top-level build file where you can add configuration options common to all sub-projects/modules.\nbuildscript {\n    repositories {\n        jcenter()\n        google()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.6.3'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n"], "filenames": ["APDE/src/main/java/com/calsignlabs/apde/build/dag/CopyBuildTask.java", "build.gradle"], "buggy_code_start_loc": [273, 8], "buggy_code_end_loc": [273, 9], "fixing_code_start_loc": [274, 8], "fixing_code_end_loc": [278, 9], "type": "CWE-22", "message": "A vulnerability classified as critical has been found in Calsign APDE. This affects the function handleExtract of the file APDE/src/main/java/com/calsignlabs/apde/build/dag/CopyBuildTask.java of the component ZIP File Handler. The manipulation leads to path traversal. Upgrading to version 0.5.2-pre2-alpha is able to address this issue. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216747.", "other": {"cve": {"id": "CVE-2020-36628", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-25T11:15:10.763", "lastModified": "2023-01-05T14:54:28.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in Calsign APDE. This affects the function handleExtract of the file APDE/src/main/java/com/calsignlabs/apde/build/dag/CopyBuildTask.java of the component ZIP File Handler. The manipulation leads to path traversal. Upgrading to version 0.5.2-pre2-alpha is able to address this issue. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216747."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:android_processing_development_environment_project:android_processing_development_environment:*:*:*:*:*:android:*:*", "versionEndExcluding": "0.5.2", "matchCriteriaId": "69E22EA1-7C82-4F29-8BC0-A642B063CBDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:android_processing_development_environment_project:android_processing_development_environment:0.5.2:pre1_alpha:*:*:*:android:*:*", "matchCriteriaId": "E8315D57-8F8F-431C-A74B-5523BA512004"}]}]}], "references": [{"url": "https://github.com/Calsign/APDE/commit/c6d64cbe465348c1bfd211122d89e3117afadecf", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Calsign/APDE/releases/tag/v0.5.2-pre2-alpha", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216747", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Calsign/APDE/commit/c6d64cbe465348c1bfd211122d89e3117afadecf"}}