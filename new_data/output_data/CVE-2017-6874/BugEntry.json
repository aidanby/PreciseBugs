{"buggy_code": ["#ifndef _LINUX_USER_NAMESPACE_H\n#define _LINUX_USER_NAMESPACE_H\n\n#include <linux/kref.h>\n#include <linux/nsproxy.h>\n#include <linux/ns_common.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/rwsem.h>\n#include <linux/sysctl.h>\n#include <linux/err.h>\n\n#define UID_GID_MAP_MAX_EXTENTS 5\n\nstruct uid_gid_map {\t/* 64 bytes -- 1 cache line */\n\tu32 nr_extents;\n\tstruct uid_gid_extent {\n\t\tu32 first;\n\t\tu32 lower_first;\n\t\tu32 count;\n\t} extent[UID_GID_MAP_MAX_EXTENTS];\n};\n\n#define USERNS_SETGROUPS_ALLOWED 1UL\n\n#define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED\n\nstruct ucounts;\n\nenum ucount_type {\n\tUCOUNT_USER_NAMESPACES,\n\tUCOUNT_PID_NAMESPACES,\n\tUCOUNT_UTS_NAMESPACES,\n\tUCOUNT_IPC_NAMESPACES,\n\tUCOUNT_NET_NAMESPACES,\n\tUCOUNT_MNT_NAMESPACES,\n\tUCOUNT_CGROUP_NAMESPACES,\n#ifdef CONFIG_INOTIFY_USER\n\tUCOUNT_INOTIFY_INSTANCES,\n\tUCOUNT_INOTIFY_WATCHES,\n#endif\n\tUCOUNT_COUNTS,\n};\n\nstruct user_namespace {\n\tstruct uid_gid_map\tuid_map;\n\tstruct uid_gid_map\tgid_map;\n\tstruct uid_gid_map\tprojid_map;\n\tatomic_t\t\tcount;\n\tstruct user_namespace\t*parent;\n\tint\t\t\tlevel;\n\tkuid_t\t\t\towner;\n\tkgid_t\t\t\tgroup;\n\tstruct ns_common\tns;\n\tunsigned long\t\tflags;\n\n\t/* Register of per-UID persistent keyrings for this namespace */\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tstruct key\t\t*persistent_keyring_register;\n\tstruct rw_semaphore\tpersistent_keyring_register_sem;\n#endif\n\tstruct work_struct\twork;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_set\tset;\n\tstruct ctl_table_header *sysctls;\n#endif\n\tstruct ucounts\t\t*ucounts;\n\tint ucount_max[UCOUNT_COUNTS];\n};\n\nstruct ucounts {\n\tstruct hlist_node node;\n\tstruct user_namespace *ns;\n\tkuid_t uid;\n\tatomic_t count;\n\tatomic_t ucount[UCOUNT_COUNTS];\n};\n\nextern struct user_namespace init_user_ns;\n\nbool setup_userns_sysctls(struct user_namespace *ns);\nvoid retire_userns_sysctls(struct user_namespace *ns);\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid, enum ucount_type type);\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type);\n\n#ifdef CONFIG_USER_NS\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\tif (ns)\n\t\tatomic_inc(&ns->count);\n\treturn ns;\n}\n\nextern int create_user_ns(struct cred *new);\nextern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);\nextern void __put_user_ns(struct user_namespace *ns);\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\t__put_user_ns(ns);\n}\n\nstruct seq_operations;\nextern const struct seq_operations proc_uid_seq_operations;\nextern const struct seq_operations proc_gid_seq_operations;\nextern const struct seq_operations proc_projid_seq_operations;\nextern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);\nextern int proc_setgroups_show(struct seq_file *m, void *v);\nextern bool userns_may_setgroups(const struct user_namespace *ns);\nextern bool current_in_userns(const struct user_namespace *target_ns);\n\nstruct ns_common *ns_get_owner(struct ns_common *ns);\n#else\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\treturn &init_user_ns;\n}\n\nstatic inline int create_user_ns(struct cred *new)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int unshare_userns(unsigned long unshare_flags,\n\t\t\t\t struct cred **new_cred)\n{\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n}\n\nstatic inline bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\treturn true;\n}\n\nstatic inline bool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn true;\n}\n\nstatic inline struct ns_common *ns_get_owner(struct ns_common *ns)\n{\n\treturn ERR_PTR(-EPERM);\n}\n#endif\n\n#endif /* _LINUX_USER_H */\n", "/*\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation, version 2 of the\n *  License.\n */\n\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/hash.h>\n#include <linux/user_namespace.h>\n\n#define UCOUNTS_HASHTABLE_BITS 10\nstatic struct hlist_head ucounts_hashtable[(1 << UCOUNTS_HASHTABLE_BITS)];\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\n#define ucounts_hashfn(ns, uid)\t\t\t\t\t\t\\\n\thash_long((unsigned long)__kuid_val(uid) + (unsigned long)(ns), \\\n\t\t  UCOUNTS_HASHTABLE_BITS)\n#define ucounts_hashentry(ns, uid)\t\\\n\t(ucounts_hashtable + ucounts_hashfn(ns, uid))\n\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}\n\nstatic int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}\n\nstatic struct ctl_table_root set_root = {\n\t.lookup = set_lookup,\n\t.permissions = set_permissions,\n};\n\nstatic int zero = 0;\nstatic int int_max = INT_MAX;\n#define UCOUNT_ENTRY(name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.procname\t= name,\t\t\t\\\n\t\t.maxlen\t\t= sizeof(int),\t\t\\\n\t\t.mode\t\t= 0644,\t\t\t\\\n\t\t.proc_handler\t= proc_dointvec_minmax,\t\\\n\t\t.extra1\t\t= &zero,\t\t\\\n\t\t.extra2\t\t= &int_max,\t\t\\\n\t}\nstatic struct ctl_table user_table[] = {\n\tUCOUNT_ENTRY(\"max_user_namespaces\"),\n\tUCOUNT_ENTRY(\"max_pid_namespaces\"),\n\tUCOUNT_ENTRY(\"max_uts_namespaces\"),\n\tUCOUNT_ENTRY(\"max_ipc_namespaces\"),\n\tUCOUNT_ENTRY(\"max_net_namespaces\"),\n\tUCOUNT_ENTRY(\"max_mnt_namespaces\"),\n\tUCOUNT_ENTRY(\"max_cgroup_namespaces\"),\n#ifdef CONFIG_INOTIFY_USER\n\tUCOUNT_ENTRY(\"max_inotify_instances\"),\n\tUCOUNT_ENTRY(\"max_inotify_watches\"),\n#endif\n\t{ }\n};\n#endif /* CONFIG_SYSCTL */\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nvoid retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}\n\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}\n\nstatic void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}\n\nstatic inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}\n\nstatic __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\treturn 0;\n}\nsubsys_initcall(user_namespace_sysctl_init);\n"], "fixing_code": ["#ifndef _LINUX_USER_NAMESPACE_H\n#define _LINUX_USER_NAMESPACE_H\n\n#include <linux/kref.h>\n#include <linux/nsproxy.h>\n#include <linux/ns_common.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/rwsem.h>\n#include <linux/sysctl.h>\n#include <linux/err.h>\n\n#define UID_GID_MAP_MAX_EXTENTS 5\n\nstruct uid_gid_map {\t/* 64 bytes -- 1 cache line */\n\tu32 nr_extents;\n\tstruct uid_gid_extent {\n\t\tu32 first;\n\t\tu32 lower_first;\n\t\tu32 count;\n\t} extent[UID_GID_MAP_MAX_EXTENTS];\n};\n\n#define USERNS_SETGROUPS_ALLOWED 1UL\n\n#define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED\n\nstruct ucounts;\n\nenum ucount_type {\n\tUCOUNT_USER_NAMESPACES,\n\tUCOUNT_PID_NAMESPACES,\n\tUCOUNT_UTS_NAMESPACES,\n\tUCOUNT_IPC_NAMESPACES,\n\tUCOUNT_NET_NAMESPACES,\n\tUCOUNT_MNT_NAMESPACES,\n\tUCOUNT_CGROUP_NAMESPACES,\n#ifdef CONFIG_INOTIFY_USER\n\tUCOUNT_INOTIFY_INSTANCES,\n\tUCOUNT_INOTIFY_WATCHES,\n#endif\n\tUCOUNT_COUNTS,\n};\n\nstruct user_namespace {\n\tstruct uid_gid_map\tuid_map;\n\tstruct uid_gid_map\tgid_map;\n\tstruct uid_gid_map\tprojid_map;\n\tatomic_t\t\tcount;\n\tstruct user_namespace\t*parent;\n\tint\t\t\tlevel;\n\tkuid_t\t\t\towner;\n\tkgid_t\t\t\tgroup;\n\tstruct ns_common\tns;\n\tunsigned long\t\tflags;\n\n\t/* Register of per-UID persistent keyrings for this namespace */\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tstruct key\t\t*persistent_keyring_register;\n\tstruct rw_semaphore\tpersistent_keyring_register_sem;\n#endif\n\tstruct work_struct\twork;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table_set\tset;\n\tstruct ctl_table_header *sysctls;\n#endif\n\tstruct ucounts\t\t*ucounts;\n\tint ucount_max[UCOUNT_COUNTS];\n};\n\nstruct ucounts {\n\tstruct hlist_node node;\n\tstruct user_namespace *ns;\n\tkuid_t uid;\n\tint count;\n\tatomic_t ucount[UCOUNT_COUNTS];\n};\n\nextern struct user_namespace init_user_ns;\n\nbool setup_userns_sysctls(struct user_namespace *ns);\nvoid retire_userns_sysctls(struct user_namespace *ns);\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid, enum ucount_type type);\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type);\n\n#ifdef CONFIG_USER_NS\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\tif (ns)\n\t\tatomic_inc(&ns->count);\n\treturn ns;\n}\n\nextern int create_user_ns(struct cred *new);\nextern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);\nextern void __put_user_ns(struct user_namespace *ns);\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n\tif (ns && atomic_dec_and_test(&ns->count))\n\t\t__put_user_ns(ns);\n}\n\nstruct seq_operations;\nextern const struct seq_operations proc_uid_seq_operations;\nextern const struct seq_operations proc_gid_seq_operations;\nextern const struct seq_operations proc_projid_seq_operations;\nextern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);\nextern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);\nextern int proc_setgroups_show(struct seq_file *m, void *v);\nextern bool userns_may_setgroups(const struct user_namespace *ns);\nextern bool current_in_userns(const struct user_namespace *target_ns);\n\nstruct ns_common *ns_get_owner(struct ns_common *ns);\n#else\n\nstatic inline struct user_namespace *get_user_ns(struct user_namespace *ns)\n{\n\treturn &init_user_ns;\n}\n\nstatic inline int create_user_ns(struct cred *new)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int unshare_userns(unsigned long unshare_flags,\n\t\t\t\t struct cred **new_cred)\n{\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline void put_user_ns(struct user_namespace *ns)\n{\n}\n\nstatic inline bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\treturn true;\n}\n\nstatic inline bool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn true;\n}\n\nstatic inline struct ns_common *ns_get_owner(struct ns_common *ns)\n{\n\treturn ERR_PTR(-EPERM);\n}\n#endif\n\n#endif /* _LINUX_USER_H */\n", "/*\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation, version 2 of the\n *  License.\n */\n\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/hash.h>\n#include <linux/user_namespace.h>\n\n#define UCOUNTS_HASHTABLE_BITS 10\nstatic struct hlist_head ucounts_hashtable[(1 << UCOUNTS_HASHTABLE_BITS)];\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\n#define ucounts_hashfn(ns, uid)\t\t\t\t\t\t\\\n\thash_long((unsigned long)__kuid_val(uid) + (unsigned long)(ns), \\\n\t\t  UCOUNTS_HASHTABLE_BITS)\n#define ucounts_hashentry(ns, uid)\t\\\n\t(ucounts_hashtable + ucounts_hashfn(ns, uid))\n\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table_set *\nset_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current_user_ns()->set == set;\n}\n\nstatic int set_permissions(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table)\n{\n\tstruct user_namespace *user_ns =\n\t\tcontainer_of(head->set, struct user_namespace, set);\n\tint mode;\n\n\t/* Allow users with CAP_SYS_RESOURCE unrestrained access */\n\tif (ns_capable(user_ns, CAP_SYS_RESOURCE))\n\t\tmode = (table->mode & S_IRWXU) >> 6;\n\telse\n\t/* Allow all others at most read-only access */\n\t\tmode = table->mode & S_IROTH;\n\treturn (mode << 6) | (mode << 3) | mode;\n}\n\nstatic struct ctl_table_root set_root = {\n\t.lookup = set_lookup,\n\t.permissions = set_permissions,\n};\n\nstatic int zero = 0;\nstatic int int_max = INT_MAX;\n#define UCOUNT_ENTRY(name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.procname\t= name,\t\t\t\\\n\t\t.maxlen\t\t= sizeof(int),\t\t\\\n\t\t.mode\t\t= 0644,\t\t\t\\\n\t\t.proc_handler\t= proc_dointvec_minmax,\t\\\n\t\t.extra1\t\t= &zero,\t\t\\\n\t\t.extra2\t\t= &int_max,\t\t\\\n\t}\nstatic struct ctl_table user_table[] = {\n\tUCOUNT_ENTRY(\"max_user_namespaces\"),\n\tUCOUNT_ENTRY(\"max_pid_namespaces\"),\n\tUCOUNT_ENTRY(\"max_uts_namespaces\"),\n\tUCOUNT_ENTRY(\"max_ipc_namespaces\"),\n\tUCOUNT_ENTRY(\"max_net_namespaces\"),\n\tUCOUNT_ENTRY(\"max_mnt_namespaces\"),\n\tUCOUNT_ENTRY(\"max_cgroup_namespaces\"),\n#ifdef CONFIG_INOTIFY_USER\n\tUCOUNT_ENTRY(\"max_inotify_instances\"),\n\tUCOUNT_ENTRY(\"max_inotify_watches\"),\n#endif\n\t{ }\n};\n#endif /* CONFIG_SYSCTL */\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nvoid retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}\n\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct ucounts *ucounts;\n\n\thlist_for_each_entry(ucounts, hashent, node) {\n\t\tif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\n\t\t\treturn ucounts;\n\t}\n\treturn NULL;\n}\n\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}\n\nstatic void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}\n\nstatic inline bool atomic_inc_below(atomic_t *v, int u)\n{\n\tint c, old;\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tif (unlikely(c >= u))\n\t\t\treturn false;\n\t\told = atomic_cmpxchg(v, c, c+1);\n\t\tif (likely(old == c))\n\t\t\treturn true;\n\t\tc = old;\n\t}\n}\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}\n\nstatic __init int user_namespace_sysctl_init(void)\n{\n#ifdef CONFIG_SYSCTL\n\tstatic struct ctl_table_header *user_header;\n\tstatic struct ctl_table empty[1];\n\t/*\n\t * It is necessary to register the user directory in the\n\t * default set so that registrations in the child sets work\n\t * properly.\n\t */\n\tuser_header = register_sysctl(\"user\", empty);\n\tkmemleak_ignore(user_header);\n\tBUG_ON(!user_header);\n\tBUG_ON(!setup_userns_sysctls(&init_user_ns));\n#endif\n\treturn 0;\n}\nsubsys_initcall(user_namespace_sysctl_init);\n"], "filenames": ["include/linux/user_namespace.h", "kernel/ucount.c"], "buggy_code_start_loc": [75, 147], "buggy_code_end_loc": [76, 175], "fixing_code_start_loc": [75, 147], "fixing_code_end_loc": [76, 179], "type": "CWE-362", "message": "Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.", "other": {"cve": {"id": "CVE-2017-6874", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-14T09:59:00.393", "lastModified": "2017-03-16T01:59:02.433", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts."}, {"lang": "es", "value": "Condici\u00f3n de carrera en kernel/ucount.c en el kernel de Linux hasta la versi\u00f3n 4.10.2 permite a usuarios locales provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n y ca\u00edda del sistema) o tener otro posible impacto no especificado a trav\u00e9s de llamadas al sistema manipuladas que aprovechan cierto decremento de comportamiento que causa una interacci\u00f3n incorrecta entre put_ucounts y get_ucounts."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.2", "matchCriteriaId": "4BD29732-F6B5-409C-9E75-4CECE1E543A4"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=040757f738e13caaa9c5078bca79aa97e11dde88", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96856", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88"}}