{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nconst BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[] = { DSTBLT_ORDER_FIELD_BYTES,\n\t                                               PATBLT_ORDER_FIELD_BYTES,\n\t                                               SCRBLT_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               LINE_TO_ORDER_FIELD_BYTES,\n\t                                               OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               SAVE_BITMAP_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               MEMBLT_ORDER_FIELD_BYTES,\n\t                                               MEM3BLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_DSTBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_PATBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_SCRBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               FAST_INDEX_ORDER_FIELD_BYTES,\n\t                                               POLYGON_SC_ORDER_FIELD_BYTES,\n\t                                               POLYGON_CB_ORDER_FIELD_BYTES,\n\t                                               POLYLINE_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               FAST_GLYPH_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_SC_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_CB_ORDER_FIELD_BYTES,\n\t                                               GLYPH_INDEX_ORDER_FIELD_BYTES };\n\n#define PRIMARY_DRAWING_ORDER_COUNT (ARRAYSIZE(PRIMARY_DRAWING_ORDER_FIELD_BYTES))\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32 number)\n{\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t\tnumber = 45;\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tBYTE* phold;\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tphold = Stream_Pointer(s);\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (Stream_GetRemainingLength(s) < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t}\n\n\t\tStream_SetPointer(s, phold + fastGlyph->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, BYTE bpp)\n{\n\tint index;\n\tint x, y, k;\n\tBYTE byte = 0;\n\tBYTE* palette;\n\tint bytesPerPixel;\n\tpalette = Stream_Pointer(s) + 16;\n\tbytesPerPixel = ((bpp + 1) / 8);\n\n\tif (Stream_GetRemainingLength(s) < 16) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\toutput[((y * 8 + x) * bytesPerPixel) + k] = palette[(index * bytesPerPixel) + k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat > ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tnext = Stream_Pointer(s) + ((INT16)orderLength) + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nconst BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[] = { DSTBLT_ORDER_FIELD_BYTES,\n\t                                               PATBLT_ORDER_FIELD_BYTES,\n\t                                               SCRBLT_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               LINE_TO_ORDER_FIELD_BYTES,\n\t                                               OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               SAVE_BITMAP_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               MEMBLT_ORDER_FIELD_BYTES,\n\t                                               MEM3BLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_DSTBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_PATBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_SCRBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               FAST_INDEX_ORDER_FIELD_BYTES,\n\t                                               POLYGON_SC_ORDER_FIELD_BYTES,\n\t                                               POLYGON_CB_ORDER_FIELD_BYTES,\n\t                                               POLYLINE_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               FAST_GLYPH_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_SC_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_CB_ORDER_FIELD_BYTES,\n\t                                               GLYPH_INDEX_ORDER_FIELD_BYTES };\n\n#define PRIMARY_DRAWING_ORDER_COUNT (ARRAYSIZE(PRIMARY_DRAWING_ORDER_FIELD_BYTES))\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32 number)\n{\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t\tnumber = 45;\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tBYTE* phold;\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tphold = Stream_Pointer(s);\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (Stream_GetRemainingLength(s) < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t}\n\n\t\tStream_SetPointer(s, phold + fastGlyph->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, BYTE bpp)\n{\n\tint index;\n\tint x, y, k;\n\tBYTE byte = 0;\n\tBYTE* palette;\n\tint bytesPerPixel;\n\tpalette = Stream_Pointer(s) + 16;\n\tbytesPerPixel = ((bpp + 1) / 8);\n\n\tif (Stream_GetRemainingLength(s) < 16) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\toutput[((y * 8 + x) * bytesPerPixel) + k] = palette[(index * bytesPerPixel) + k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat > ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tnext = Stream_Pointer(s) + ((INT16)orderLength) + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n"], "filenames": ["libfreerdp/core/orders.c"], "buggy_code_start_loc": [2164], "buggy_code_end_loc": [2165], "fixing_code_start_loc": [2164], "fixing_code_end_loc": [2165], "type": "CWE-415", "message": "In FreeRDP greater than 1.2 and before 2.0.0, a double free in update_read_cache_bitmap_v3_order crashes the client application if corrupted data from a manipulated server is parsed. This has been patched in 2.0.0.", "other": {"cve": {"id": "CVE-2020-11044", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T19:15:11.720", "lastModified": "2022-07-01T17:21:14.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP greater than 1.2 and before 2.0.0, a double free in update_read_cache_bitmap_v3_order crashes the client application if corrupted data from a manipulated server is parsed. This has been patched in 2.0.0."}, {"lang": "es", "value": "En FreeRDP versiones superiores a 1.2 y versiones anteriores a 2.0.0, una doble liberaci\u00f3n en update_read_cache_bitmap_v3_order bloquea la aplicaci\u00f3n del cliente si los datos corruptos son analizados desde un servidor manipulado. Esto ha sido parcheado en la versi\u00f3n 2.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-415"}, {"lang": "en", "value": "CWE-672"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.2.0", "versionEndExcluding": "2.0.0", "matchCriteriaId": "D678CADD-67F7-4293-9771-33B33AEC1D4F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/issues/6013", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-cgqh-p732-6x2w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8"}}