{"buggy_code": ["/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <stdio.h>\n\n#include <jose/b64.h>\n#include <jose/jwk.h>\n#include <jose/jws.h>\n\n#include \"keys.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n/* Default hash to use with JWK thumbprints (S256 = SHA-256). */\n#define DEFAULT_THP_HASH \"S256\"\n\nstatic const char**\nsupported_hashes(void)\n{\n    /* TODO: check if jose has a way to export the hash algorithms it\n     * supports. */\n    static const char* hashes[] = {\"S1\", \"S224\", \"S256\", \"S384\", \"S512\", NULL};\n    return hashes;\n}\n\nstatic int\nis_hash(const char* alg)\n{\n    if (!alg) {\n        return 0;\n    }\n\n    const char** algs = supported_hashes();\n    for (size_t a = 0; algs[a]; a++) {\n        if (strcmp(alg, algs[a]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic json_t*\njwk_generate(const char* alg)\n{\n    json_auto_t* jalg = json_pack(\"{s:s}\", \"alg\", alg);\n    if (!jalg) {\n        fprintf(stderr, \"Error packing JSON with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    if (!jose_jwk_gen(NULL, jalg)) {\n        fprintf(stderr, \"Error generating JWK with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    return json_incref(jalg);\n}\n\nstatic char*\njwk_thumbprint(const json_t* jwk, const char* alg)\n{\n    size_t elen = 0;\n    size_t dlen = 0;\n\n    if (!jwk) {\n        fprintf(stderr, \"Invalid JWK\\n\");\n        return NULL;\n    }\n\n    if (!alg || !is_hash(alg)) {\n        fprintf(stderr, \"Invalid hash algorithm (%s)\\n\", alg);\n        return NULL;\n    }\n\n    dlen = jose_jwk_thp_buf(NULL, NULL, alg, NULL, 0);\n    if (dlen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining hash size for %s\\n\", alg);\n        return NULL;\n    }\n\n    elen = jose_b64_enc_buf(NULL, dlen, NULL, 0);\n    if (elen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining encoded size for %s\\n\", alg);\n        return NULL;\n    }\n\n    uint8_t dec[dlen];\n    char enc[elen];\n\n    if (!jose_jwk_thp_buf(NULL, jwk, alg, dec, sizeof(dec))) {\n        fprintf(stderr, \"Error making thumbprint\\n\");\n        return NULL;\n    }\n\n    if (jose_b64_enc_buf(dec, dlen, enc, sizeof(enc)) != elen) {\n        fprintf(stderr, \"Error encoding data Base64\\n\");\n        return NULL;\n    }\n\n    return strndup(enc, elen);\n}\n\nvoid\nfree_tang_keys_info(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return;\n    }\n\n    json_t* to_free[] = {tki->m_keys, tki->m_rotated_keys,\n                         tki->m_payload, tki->m_sign\n    };\n    size_t len = sizeof(to_free) / sizeof(to_free[0]);\n\n    for (size_t i = 0; i < len; i++) {\n        if (to_free[i] == NULL) {\n            continue;\n        }\n        json_decref(to_free[i]);\n    }\n    free(tki);\n}\n\nvoid\ncleanup_tang_keys_info(struct tang_keys_info** tki)\n{\n    if (!tki || !*tki) {\n        return;\n    }\n    free_tang_keys_info(*tki);\n    *tki = NULL;\n}\n\nstatic struct tang_keys_info*\nnew_tang_keys_info(void)\n{\n    struct tang_keys_info* tki = calloc(1, sizeof(*tki));\n    if (!tki) {\n        return NULL;\n    }\n\n    tki->m_keys = json_array();\n    tki->m_rotated_keys = json_array();\n    tki->m_payload = json_array();\n    tki->m_sign = json_array();\n\n    if (!tki->m_keys || !tki->m_rotated_keys ||\n        !tki->m_payload || !tki->m_sign) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    tki->m_keys_count = 0;\n    return tki;\n}\n\nstatic int\njwk_valid_for(const json_t* jwk, const char* use)\n{\n    if (!jwk || !use) {\n        return 0;\n    }\n    return jose_jwk_prm(NULL, jwk, false, use);\n}\n\nstatic int\njwk_valid_for_signing_and_verifying(const json_t* jwk)\n{\n    const char* uses[] = {\"sign\", \"verify\", NULL};\n    int ret = 1;\n    for (int i = 0; uses[i]; i++) {\n        if (!jwk_valid_for(jwk, uses[i])) {\n            ret = 0;\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic int\njwk_valid_for_signing(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"sign\");\n}\n\nstatic int\njwk_valid_for_deriving_keys(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"deriveKey\");\n}\n\nstatic void\ncleanup_str(char** str)\n{\n    if (!str || !*str) {\n        return;\n    }\n    free(*str);\n    *str = NULL;\n}\n\nstatic json_t*\njwk_sign(const json_t* to_sign, const json_t* sig_keys)\n{\n    if (!sig_keys || !json_is_array(sig_keys) || !json_is_array(to_sign)) {\n        return NULL;\n    }\n\n    json_auto_t* to_sign_copy = json_deep_copy(to_sign);\n    if (!jose_jwk_pub(NULL, to_sign_copy)) {\n        fprintf(stderr, \"Error removing private material from data to sign\\n\");\n        return NULL;\n    }\n\n    json_auto_t* payload = json_pack(\"{s:O}\", \"keys\", to_sign_copy);\n    json_auto_t* sig_template = json_pack(\"{s:{s:s}}\",\n                                          \"protected\", \"cty\", \"jwk-set+json\");\n\n    __attribute__ ((__cleanup__(cleanup_str))) char* data_to_sign = json_dumps(payload, 0);\n    json_auto_t* jws = json_pack(\"{s:o}\", \"payload\",\n                                 jose_b64_enc(data_to_sign, strlen(data_to_sign)));\n\n    if (!jose_jws_sig(NULL, jws, sig_template, sig_keys)) {\n        fprintf(stderr, \"Error trying to jose_jws_sign\\n\");\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\nstatic json_t*\nfind_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic int\nprepare_payload_and_sign(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return 0;\n    }\n\n    size_t idx;\n    json_t* jwk;\n    json_array_foreach(tki->m_keys, idx, jwk) {\n        if (jwk_valid_for_signing_and_verifying(jwk)) {\n            if (json_array_append(tki->m_sign, jwk) == -1) {\n                continue;\n            }\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        } else if (jwk_valid_for_deriving_keys(jwk)) {\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        }\n    }\n    if (json_array_size(tki->m_sign) == 0 || json_array_size(tki->m_payload) == 0) {\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic struct tang_keys_info*\nload_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = new_tang_keys_info();\n    if (!tki) {\n        return NULL;\n    }\n\n    struct dirent* d;\n    DIR* dir = opendir(jwkdir);\n    if (!dir) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", jwkdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            json_auto_t* json = json_load_file(filepath, 0, NULL);\n            if (!json) {\n                fprintf(stderr, \"Invalid JSON file (%s); skipping\\n\", filepath);\n                continue;\n            }\n\n            json_t* arr = tki->m_keys;\n            if (d->d_name[0] == '.') {\n                arr = tki->m_rotated_keys;\n                tki->m_rotated_keys_count++;\n            } else {\n                tki->m_keys_count++;\n            }\n\n            if (json_array_append(arr, json) == -1) {\n                fprintf(stderr, \"Unable to append JSON (%s) to array; skipping\\n\", d->d_name);\n                continue;\n            }\n        }\n    }\n    closedir(dir);\n    return tki;\n}\n\nstruct tang_keys_info*\nread_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = load_keys(jwkdir);\n    if (!tki) {\n        return NULL;\n    }\n\n    if (tki->m_keys_count == 0) {\n        /* Let's attempt to create a new pair of keys. */\n        free_tang_keys_info(tki);\n        if (!create_new_keys(jwkdir)) {\n            return NULL;\n        }\n        tki = load_keys(jwkdir);\n    }\n\n    if (!prepare_payload_and_sign(tki)) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    return tki;\n}\n\njson_t*\nfind_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}\n\njson_t*\nfind_jwk(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki || !thp) {\n        return NULL;\n    }\n    return find_by_thp(tki, thp);\n}\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n. helpers\n\nsanity_check\n\ntrap 'on_exit' EXIT\nexport TMP=`mktemp -d`\nmkdir -p $TMP/db\n\ntangd-keygen $TMP/db sig exc\n# Make sure keys generated by tangd-keygen have proper permissions.\nvalid_key_perm \"${TMP}/db/sig.jwk\"\nvalid_key_perm \"${TMP}/db/exc.jwk\"\n\njose jwk gen -i '{\"alg\": \"ES512\"}' -o $TMP/db/.sig.jwk\njose jwk gen -i '{\"alg\": \"ES512\"}' -o $TMP/db/.oth.jwk\n\nexport PORT=$(random_port)\nstart_server \"${PORT}\"\nexport PID=$!\nsleep 0.5\n\n# Make sure requests on the root fail\n! fetch /\n\n# The request should fail (404) for non-signature key IDs\n! fetch /adv/`jose jwk thp -i $TMP/db/exc.jwk`\n! fetch /adv/`jose jwk thp -a S512 -i $TMP/db/exc.jwk`\n\n# The default advertisement fetch should succeed and pass verification\nfetch /adv\nfetch /adv | ver $TMP/db/sig.jwk\nfetch /adv/ | ver $TMP/db/sig.jwk\n\n# Fetching by any thumbprint should work\nfetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/sig.jwk\nfetch /adv/`jose jwk thp -a S512 -i $TMP/db/sig.jwk` | ver $TMP/db/sig.jwk\n\n# Requesting an adv by an advertised key ID should't be signed by hidden keys\n! fetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/.sig.jwk\n! fetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/.oth.jwk\n\n# Verify that the default advertisement is not signed with hidden signature keys\n! fetch /adv/ | ver $TMP/db/.oth.jwk\n! fetch /adv/ | ver $TMP/db/.sig.jwk\n\n# A private key advertisement is signed by all advertised keys and the requested private key\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/sig.jwk\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/.sig.jwk\n! fetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/.oth.jwk\n\n# Verify that the advertisements contain the cty parameter\nfetch /adv | jose fmt -j- -Og protected -SyOg cty -Sq \"jwk-set+json\" -E\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` \\\n    | jose fmt -j- -Og signatures -A \\\n               -g 0 -Og protected -SyOg cty -Sq \"jwk-set+json\" -EUUUUU \\\n               -g 1 -Og protected -SyOg cty -Sq \"jwk-set+json\" -EUUUUU\n\nTHP_DEFAULT_HASH=S256     # SHA-256.\ntest \"$(tang-show-keys $PORT)\" = \"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" -i $TMP/db/sig.jwk)\"\n\n# Check that new keys will be created if none exist.\nrm -rf \"${TMP}/db\" && mkdir -p \"${TMP}/db\"\nfetch /adv\n\n# Now let's make sure the new keys were named using our default thumbprint\n# hash and then rotate them and check if we still create new keys.\ncd \"${TMP}/db\"\nfor k in *.jwk; do\n    # Check for the key name (SHA-256).\n    test \"${k}\" = \"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" -i \"${k}\")\".jwk\n    # Rotate the key.\n    mv -f -- \"${k}\" \".${k}\"\ndone\ncd -\nfetch /adv\n\n# Lets's now test with multiple pairs of keys.\nfor i in 1 2 3 4 5 6 7 8 9; do\n    tangd-keygen \"${TMP}\"/db other-sig-${i} other-exc-${i}\n    # Make sure the requested keys exist and are valid.\n    validate_sig \"${TMP}/db/other-sig-${i}.jwk\"\n    validate_exc \"${TMP}/db/other-exc-${i}.jwk\"\n\n    # Make sure keys generated by tangd-keygen have proper permissions.\n    valid_key_perm \"${TMP}/db/other-sig-${i}.jwk\"\n    valid_key_perm \"${TMP}/db/other-exc-${i}.jwk\"\ndone\n\n# Verify the advertisement is correct.\nvalidate \"$(fetch /adv)\"\n\n# And make sure we can fetch an adv by its thumbprint.\nfor jwk in \"${TMP}\"/db/other-sig-*.jwk; do\n    for alg in $(jose alg -k hash); do\n        fetch /adv/\"$(jose jwk thp -a \"${alg}\" -i \"${jwk}\")\" | ver \"${jwk}\"\n    done\ndone\n\n# Now let's test keys rotation.\ntangd-rotate-keys -d \"${TMP}/db\"\nfor i in 1 2 3 4 5 6 7 8 9; do\n    # Make sure keys were excluded from advertisement.\n    validate_sig \"${TMP}/db/.other-sig-${i}.jwk\"\n    validate_exc \"${TMP}/db/.other-exc-${i}.jwk\"\ndone\n\n# And test also that we have valid keys after rotation.\nthp=\nfor jwk in \"${TMP}\"/db/*.jwk; do\n    validate_sig \"${jwk}\" && thp=\"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" \\\n                                    -i \"${jwk}\")\"\n\n    # Make sure keys generated by tangd-rotate-keys have proper permissions.\n    valid_key_perm \"${jwk}\"\ndone\n[ -z \"${thp}\" ] && die \"There should be valid keys after rotation\"\ntest \"$(tang-show-keys $PORT)\" = \"${thp}\"\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nfetch() {\n    curl -sfg \"http://127.0.0.1:${PORT}${1}\"\n}\n\nver() {\n    jose jws ver -i- -k \"${1}\"\n}\n\nrandom_port() {\n    if [ -n \"${TANG_BSD}\" ]; then\n        jot -r 1 1024 65536\n    else\n        shuf -i 1024-65536 -n 1\n    fi\n}\n\nstart_server() {\n    \"${SOCAT}\" TCP-LISTEN:\"${1}\",bind=127.0.0.1,fork SYSTEM:\"${VALGRIND} tangd ${TMP}/db\" &\n}\n\non_exit() {\n    if [ \"$PID\" ]; then kill \"${PID}\"; wait \"${PID}\" || true; fi\n    [ -d \"${TMP}\" ] && rm -rf \"${TMP}\"\n}\n\nvalidate() {\n    if ! _jwks=\"$(jose fmt --json=\"${1}\" -Og payload -SyOg keys \\\n                 -AUo- 2>/dev/null)\"; then\n        echo \"Advertisement is malformed\" >&2\n        exit 1\n    fi\n    _ver=\"$(printf '%s' \"${_jwks}\" | jose jwk use -i- -r -u verify -o-)\"\n    if ! printf '%s' \"${_ver}\" | jose jws ver -i \"${1}\" -k- -a; then\n        echo \"Advertisement is missing signatures\" >&2\n        exit 1\n    fi\n}\n\nvalidate_sig() {\n    jose fmt --json \"${1}\" --output=- | jose jwk use --input=- --required \\\n        --use verify 2>/dev/null\n}\n\nvalidate_exc() {\n    jose fmt --json \"${1}\" --output=- | jose jwk use --input=- --required \\\n        --use deriveKey 2>/dev/null\n}\n\nsanity_check() {\n    # Skip test if socat is not available.\n    [ -n \"${SOCAT}\" ] || exit 77\n}\n\ndie() {\n    echo \"${1}\" >&2\n    exit 1\n}\n\nvalid_key_perm() {\n    if [ -n \"${TANG_BSD}\" ]; then\n        _perm=\"$(stat -f %Lp \"${1}\")\"\n    else\n        _perm=\"$(stat -c %a \"${1}\")\"\n    fi\n    [ \"${_perm}\" = \"440\" ]\n}\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n. helpers\n\nsanity_check\n\ntrap 'on_exit' EXIT\nexport TMP=`mktemp -d`\nmkdir -p $TMP/db\n\n# Generate the server keys\ntangd-keygen $TMP/db sig exc\n# Make sure keys generated by tangd-keygen have proper permissions.\nvalid_key_perm \"${TMP}/db/sig.jwk\"\nvalid_key_perm \"${TMP}/db/exc.jwk\"\n\n# Generate the client keys\nexc_kid=`jose jwk thp -i $TMP/db/exc.jwk`\ntmp=`jose fmt -j $TMP/db/exc.jwk -Od x -d y -d d -o-`\njose jwk gen -i \"$tmp\" -o $TMP/exc.jwk\njose jwk pub -i $TMP/exc.jwk -o $TMP/exc.pub.jwk\n\n# Start the server\nexport PORT=$(random_port)\nstart_server \"${PORT}\"\nexport PID=$!\nsleep 0.5\n\n# Make sure that GET fails\n! curl -sf http://127.0.0.1:$PORT/rec\n! curl -sf http://127.0.0.1:$PORT/rec/\n\n# Make a recovery request (NOTE: this is insecure! Don't do this in real code!)\ngood=`jose jwk exc -i '{\"alg\":\"ECMR\",\"key_ops\":[\"deriveKey\"]}' -l $TMP/exc.jwk -r $TMP/db/exc.jwk`\ntest=`curl -sf -X POST \\\n           -H \"Content-Type: application/jwk+json\" \\\n           --data-binary @- \\\n           http://127.0.0.1:$PORT/rec/${exc_kid} < $TMP/exc.pub.jwk`\n[ \"$good\" = \"$test\" ]\n", "/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keys.c\"\n#include \"test-util.h\"\n\nconst char* jwkdir = \"@testjwkdir@\";\n\nstruct thp_result {\n    const char* thp;\n    int valid;\n};\n\nstruct test_result_int {\n    const char* data;\n    int expected;\n};\n\nstatic void\nverify_keys_permissions(const char* targetdir)\n{\n    struct stat st;\n    struct dirent* d;\n    DIR* dir = opendir(targetdir);\n    ASSERT(dir);\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", targetdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            ASSERT(stat(filepath, &st) == 0);\n\n            ASSERT_WITH_MSG(st.st_mode & (S_IRUSR | S_IRGRP), \"key = %s, missing perm (0%o)\", filepath, (S_IRUSR | S_IRGRP));\n            int unexpected_perms[] = {\n                S_ISUID, /* 04000 set-user-ID */\n                S_ISGID, /* 02000 set-group-ID */\n                S_IWUSR, /* 00200 write by owner */\n                S_IXUSR, /* 00100 execute/search by owner */\n                S_IWGRP, /* 00020 write by group */\n                S_IXGRP, /* 00010 execute/search by group */\n                S_IROTH, /* 00004 read by others */\n                S_IWOTH, /* 00002 write by others */\n                S_IXOTH, /* 00001 execute/search by others */\n                0\n            };\n            for (int i = 0; unexpected_perms[i] != 0; i++) {\n                ASSERT_WITH_MSG((st.st_mode & unexpected_perms[i]) == 0, \"key = %s, i = %d, unexpected perm (0%o)\", filepath, i, unexpected_perms[i]);\n            }\n\n        }\n    }\n    closedir(dir);\n}\n\nstatic void\ntest_create_new_keys(void)\n{\n   __attribute__((cleanup(cleanup_str))) char* newdir = create_tempdir();\n    ASSERT(newdir);\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(newdir);\n    ASSERT(tki);\n    ASSERT(tki->m_keys_count == 2);\n\n    /* Make sure keys have proper permissions. */\n    verify_keys_permissions(newdir);\n\n    remove_tempdir(newdir);\n}\n\n\nstatic void\ntest_is_hash(void)\n{\n    const struct test_result_int test_data[] = {\n        {NULL, 0},\n        {\"\", 0},\n        {\"ES512\", 0},\n        {\"ECMR\", 0},\n        {\"foobar\", 0},\n        {\"{\", 0},\n        {\"[}\", 0},\n        {\"[]\", 0},\n        {\"S1\", 1},\n        {\"S224\", 1},\n        {\"S256\", 1},\n        {\"S384\", 1},\n        {\"S512\", 1},\n        {\"S42\", 0}\n    };\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        int ret = is_hash(test_data[i].data);\n        ASSERT_WITH_MSG(ret == test_data[i].expected, \"i = %d, alg = %s\", i, test_data[i].data);\n    };\n\n}\n\nstatic void\ntest_jwk_generate(void)\n{\n    const struct test_result_int test_data[] = {\n        {NULL, 0},\n        {\"\", 0},\n        {\"ES512\", 1},\n        {\"ECMR\", 1},\n        {\"foobar\", 0},\n        {\"{\", 0},\n        {\"[}\", 0},\n        {\"[]\", 0}\n    };\n\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* jwk = jwk_generate(test_data[i].data);\n        ASSERT_WITH_MSG(!!jwk == test_data[i].expected, \"i = %d, alg = %s\", i, test_data[i].data);\n    };\n}\n\nstatic void\ntest_find_jws(void)\n{\n    const struct thp_result test_data[] = {\n        {\"00BUQM4A7NYxbOrBR9QDfkzGVGj3k57Fs4jCbJxcLYAgRFHu5B7jtbL97x1T7stQ\", 1},\n        {\"dd5qbN1lQ6UWdZszbfx2oIcH34ShklzFL1SUQg\", 1},\n        {\"dOZkUtZ_gLDUP53GIlyAxHMNuyrk8vdY-XXND32GccqNbT_MKpqGC-13-GNEye48\", 1},\n        {\"DZrlBQvfvlwPQlvH_IieBdc_KpesEramLygVL_rFr7g\", 1},\n        {\"FL_Zt5fFadUL4syeMMpUnss8aKdCrPGFy3102JGR3EE\", 1},\n        {\"qgmqJSo6AEEuVQY7zVlklqdTMqY\", 1},\n        {\"r4E2wG1u_YyKUo0N0rIK7jJF5Xg\", 1},\n        {\"ugJ4Ula-YABQIiJ-0g3B_jpFpF2nl3W-DNpfLdXArhTusV0QCcd1vtgDeGHEPzpm7jEsyC7VYYSSOkZicK22mw\", 1},\n        {\"up0Z4fRhpd4O5QwBaMCXDTlrvxCmZacU0MD8kw\", 1},\n        {\"vllHS-M0aQFCo2yUCcAahMU4TAtXACyeuRf-zbmmTPBg7V0Pb-RRFGo5C6MnpzdirK8B3ORLOsN8RyXClvtjxA\", 1},\n        {NULL, 1},\n        {\"a\", 0},\n        {\"foo\", 0},\n        {\"bar\", 0},\n        {\"XXXXXXXXXXXXXXXXXX\", 0}\n    };\n\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* jws = find_jws(tki, test_data[i].thp);\n        ASSERT_WITH_MSG(!!jws == test_data[i].valid, \"i = %d, thp = %s\", i, test_data[i].thp);\n    }\n\n    /* Passing NULL to find_jws should return the default advertisement */\n    json_auto_t* adv = find_jws(tki, NULL);\n    ASSERT(adv);\n\n\n    /*\n     * The default set of signing keys are the signing keys that are not\n     * rotated. The payload is made of deriving keys that are also not\n     * rotated. The default advertisement should be signed by this set of\n     * default signing keys.\n     */\n    ASSERT(jose_jws_ver(NULL, adv, NULL, tki->m_sign, 1));\n\n    /* find_jws should be able to respond to thumbprints of keys using any\n     * of jose supported hash algorithms. */\n    const char** hashes = supported_hashes();\n    size_t idx;\n    json_t* jwk;\n\n    /* Let's put together all the keys, including rotated ones. */\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    ASSERT(keys);\n    ASSERT(json_array_extend(keys, tki->m_rotated_keys) == 0);\n    ASSERT(json_array_size(keys) == (size_t)(tki->m_keys_count + tki->m_rotated_keys_count));\n\n    for (int i = 0; hashes[i]; i++) {\n        json_array_foreach(keys, idx, jwk) {\n            if (!jwk_valid_for_signing(jwk)) {\n                continue;\n            }\n            __attribute__((cleanup(cleanup_str))) char* thp = jwk_thumbprint(jwk, hashes[i]);\n            ASSERT_WITH_MSG(thp, \"i = %d, hash = %s, key idx = %d\", i, hashes[i], idx);\n            json_auto_t* jws = find_jws(tki, thp);\n            ASSERT_WITH_MSG(jws, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n\n            /* Signing keys should sign the payload, in addition to the\n             * default set of signing keys. */\n            json_auto_t* sign = json_deep_copy(tki->m_sign);\n            ASSERT_WITH_MSG(sign, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n            ASSERT_WITH_MSG(json_array_append(sign, jwk) == 0, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n            ASSERT_WITH_MSG(jose_jws_ver(NULL, jws, NULL, sign, 1), \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n        }\n    }\n}\n\nstatic void\ntest_find_jwk(void)\n{\n    const struct thp_result test_data[] = {\n        {\"1HdF3XKRSsuZdkpXNurBPoL_pvxdvCOlHuhB4DP-4xWFqbZ51zo29kR4fSiT3BGy9UrHVJ26JMBLOA1vKq3lxA\", 1},\n        {\"9U8qgy_YjyY6Isuq6QuiKEiYZgNJShcGgJx5FJzCu6m3N6zFaIPy_HDkxkVqAZ9E\", 1},\n        {\"-bWkGaJi0Zdvxaj4DCp28umLcRA\", 1},\n        {\"Cy73glFjs6B6RU7wy6vWxAc-2bJy5VJOT9LyK80eKgZ8k27wXZ-3rjsuNU5tua_yHWtluyoSYtjoKXfI0E8ESw\", 1},\n        {\"kfjbqx_b3BsgPC87HwlOWL9daGMMHBzxcFLClw\", 1},\n        {\"L4xg2tZXTEVbsK39bzOZM1jGWn3HtOxF5gh6F9YVf5Q\", 1},\n        {\"LsVAV2ig5LlfstM8TRSf-c7IAkLpNYbIysNuRCVlxocRCGqAh6-f9PklM4nU4N-J\", 1},\n        {\"OkAcDxYHNlo7-tul8OubYuWXB8CPEhAkcacCmhTclMU\", 1},\n        {\"uZ0s8YTXcGcuWduWWBSiR2OjOVg\", 1},\n        {\"WEpfFyeoNKkE2-TosN_bP-gd9UgRvQCZpVasZQ\", 1},\n        {NULL, 0},\n        {\"a\", 0},\n        {\"foo\", 0},\n        {\"bar\", 0},\n        {\"XXXXXXXXXXXXXXXXXX\", 0},\n    };\n\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* tjwk = find_jwk(tki, test_data[i].thp);\n        ASSERT_WITH_MSG(!!tjwk == test_data[i].valid, \"i = %d, thp = %s\", i, test_data[i].thp);\n    }\n    /* Passing NULL to find_jwk should fail */\n    json_auto_t* bad_jwk = find_jwk(tki, NULL);\n    ASSERT(bad_jwk == NULL);\n\n    /* find_jwk should be able to respond to thumbprints of keys using any\n     * of jose supported hash algorithms. */\n    const char** hashes = supported_hashes();\n    size_t idx;\n    json_t* jwk;\n\n    /* Let's put together all the keys, including rotated ones. */\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    ASSERT(keys);\n    ASSERT(json_array_extend(keys, tki->m_rotated_keys) == 0);\n    ASSERT(json_array_size(keys) == (size_t)(tki->m_keys_count + tki->m_rotated_keys_count));\n\n    for (int i = 0; hashes[i]; i++) {\n        json_array_foreach(keys, idx, jwk) {\n            if (!jwk_valid_for_deriving_keys(jwk)) {\n                continue;\n            }\n            __attribute__((cleanup(cleanup_str))) char* thp = jwk_thumbprint(jwk, hashes[i]);\n            json_auto_t* tjwk = find_jwk(tki, thp);\n            ASSERT_WITH_MSG(tjwk, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n        }\n    }\n}\n\nstatic void\ntest_read_keys(void)\n{\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n    ASSERT(tki);\n\n    /*\n     * Keys in tests/keys:\n     * - .uZ0s8YTXcGcuWduWWBSiR2OjOVg.jwk\n     * - .r4E2wG1u_YyKUo0N0rIK7jJF5Xg.jwk\n     * - qgmqJSo6AEEuVQY7zVlklqdTMqY.jwk\n     * - -bWkGaJi0Zdvxaj4DCp28umLcRA.jwk\n     */\n    ASSERT(tki->m_keys_count == 2);\n    ASSERT(tki->m_rotated_keys_count == 2);\n    ASSERT(json_array_size(tki->m_keys) == 2);\n    ASSERT(json_array_size(tki->m_rotated_keys) == 2);\n\n    const char* invalid_jwkdir = \"foobar\";\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki2 = read_keys(invalid_jwkdir);\n    ASSERT(tki2 == NULL);\n}\n\nstatic void\nrun_tests(void)\n{\n    test_read_keys();\n    test_find_jwk();\n    test_find_jws();\n    test_jwk_generate();\n    test_is_hash();\n    test_create_new_keys();\n}\n\nint main(int argc, char** argv)\n{\n    run_tests();\n    return 0;\n}\n"], "fixing_code": ["/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <stdio.h>\n\n#include <jose/b64.h>\n#include <jose/jwk.h>\n#include <jose/jws.h>\n\n#include \"keys.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n/* Default hash to use with JWK thumbprints (S256 = SHA-256). */\n#define DEFAULT_THP_HASH \"S256\"\n\nstatic const char**\nsupported_hashes(void)\n{\n    /* TODO: check if jose has a way to export the hash algorithms it\n     * supports. */\n    static const char* hashes[] = {\"S1\", \"S224\", \"S256\", \"S384\", \"S512\", NULL};\n    return hashes;\n}\n\nstatic int\nis_hash(const char* alg)\n{\n    if (!alg) {\n        return 0;\n    }\n\n    const char** algs = supported_hashes();\n    for (size_t a = 0; algs[a]; a++) {\n        if (strcmp(alg, algs[a]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic json_t*\njwk_generate(const char* alg)\n{\n    json_auto_t* jalg = json_pack(\"{s:s}\", \"alg\", alg);\n    if (!jalg) {\n        fprintf(stderr, \"Error packing JSON with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    if (!jose_jwk_gen(NULL, jalg)) {\n        fprintf(stderr, \"Error generating JWK with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    return json_incref(jalg);\n}\n\nstatic char*\njwk_thumbprint(const json_t* jwk, const char* alg)\n{\n    size_t elen = 0;\n    size_t dlen = 0;\n\n    if (!jwk) {\n        fprintf(stderr, \"Invalid JWK\\n\");\n        return NULL;\n    }\n\n    if (!alg || !is_hash(alg)) {\n        fprintf(stderr, \"Invalid hash algorithm (%s)\\n\", alg);\n        return NULL;\n    }\n\n    dlen = jose_jwk_thp_buf(NULL, NULL, alg, NULL, 0);\n    if (dlen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining hash size for %s\\n\", alg);\n        return NULL;\n    }\n\n    elen = jose_b64_enc_buf(NULL, dlen, NULL, 0);\n    if (elen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining encoded size for %s\\n\", alg);\n        return NULL;\n    }\n\n    uint8_t dec[dlen];\n    char enc[elen];\n\n    if (!jose_jwk_thp_buf(NULL, jwk, alg, dec, sizeof(dec))) {\n        fprintf(stderr, \"Error making thumbprint\\n\");\n        return NULL;\n    }\n\n    if (jose_b64_enc_buf(dec, dlen, enc, sizeof(enc)) != elen) {\n        fprintf(stderr, \"Error encoding data Base64\\n\");\n        return NULL;\n    }\n\n    return strndup(enc, elen);\n}\n\nvoid\nfree_tang_keys_info(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return;\n    }\n\n    json_t* to_free[] = {tki->m_keys, tki->m_rotated_keys,\n                         tki->m_payload, tki->m_sign\n    };\n    size_t len = sizeof(to_free) / sizeof(to_free[0]);\n\n    for (size_t i = 0; i < len; i++) {\n        if (to_free[i] == NULL) {\n            continue;\n        }\n        json_decref(to_free[i]);\n    }\n    free(tki);\n}\n\nvoid\ncleanup_tang_keys_info(struct tang_keys_info** tki)\n{\n    if (!tki || !*tki) {\n        return;\n    }\n    free_tang_keys_info(*tki);\n    *tki = NULL;\n}\n\nstatic struct tang_keys_info*\nnew_tang_keys_info(void)\n{\n    struct tang_keys_info* tki = calloc(1, sizeof(*tki));\n    if (!tki) {\n        return NULL;\n    }\n\n    tki->m_keys = json_array();\n    tki->m_rotated_keys = json_array();\n    tki->m_payload = json_array();\n    tki->m_sign = json_array();\n\n    if (!tki->m_keys || !tki->m_rotated_keys ||\n        !tki->m_payload || !tki->m_sign) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    tki->m_keys_count = 0;\n    return tki;\n}\n\nstatic int\njwk_valid_for(const json_t* jwk, const char* use)\n{\n    if (!jwk || !use) {\n        return 0;\n    }\n    return jose_jwk_prm(NULL, jwk, false, use);\n}\n\nstatic int\njwk_valid_for_signing_and_verifying(const json_t* jwk)\n{\n    const char* uses[] = {\"sign\", \"verify\", NULL};\n    int ret = 1;\n    for (int i = 0; uses[i]; i++) {\n        if (!jwk_valid_for(jwk, uses[i])) {\n            ret = 0;\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic int\njwk_valid_for_signing(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"sign\");\n}\n\nstatic int\njwk_valid_for_deriving_keys(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"deriveKey\");\n}\n\nstatic void\ncleanup_str(char** str)\n{\n    if (!str || !*str) {\n        return;\n    }\n    free(*str);\n    *str = NULL;\n}\n\nstatic json_t*\njwk_sign(const json_t* to_sign, const json_t* sig_keys)\n{\n    if (!sig_keys || !json_is_array(sig_keys) || !json_is_array(to_sign)) {\n        return NULL;\n    }\n\n    json_auto_t* to_sign_copy = json_deep_copy(to_sign);\n    if (!jose_jwk_pub(NULL, to_sign_copy)) {\n        fprintf(stderr, \"Error removing private material from data to sign\\n\");\n        return NULL;\n    }\n\n    json_auto_t* payload = json_pack(\"{s:O}\", \"keys\", to_sign_copy);\n    json_auto_t* sig_template = json_pack(\"{s:{s:s}}\",\n                                          \"protected\", \"cty\", \"jwk-set+json\");\n\n    __attribute__ ((__cleanup__(cleanup_str))) char* data_to_sign = json_dumps(payload, 0);\n    json_auto_t* jws = json_pack(\"{s:o}\", \"payload\",\n                                 jose_b64_enc(data_to_sign, strlen(data_to_sign)));\n\n    if (!jose_jws_sig(NULL, jws, sig_template, sig_keys)) {\n        fprintf(stderr, \"Error trying to jose_jws_sign\\n\");\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\nstatic json_t*\nfind_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            return json_incref(jwk);\n        }\n    }\n    return NULL;\n}\n\nstatic int\nprepare_payload_and_sign(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return 0;\n    }\n\n    size_t idx;\n    json_t* jwk;\n    json_array_foreach(tki->m_keys, idx, jwk) {\n        if (jwk_valid_for_signing_and_verifying(jwk)) {\n            if (json_array_append(tki->m_sign, jwk) == -1) {\n                continue;\n            }\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        } else if (jwk_valid_for_deriving_keys(jwk)) {\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        }\n    }\n    if (json_array_size(tki->m_sign) == 0 || json_array_size(tki->m_payload) == 0) {\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic struct tang_keys_info*\nload_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = new_tang_keys_info();\n    if (!tki) {\n        return NULL;\n    }\n\n    struct dirent* d;\n    DIR* dir = opendir(jwkdir);\n    if (!dir) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", jwkdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            json_auto_t* json = json_load_file(filepath, 0, NULL);\n            if (!json) {\n                fprintf(stderr, \"Invalid JSON file (%s); skipping\\n\", filepath);\n                continue;\n            }\n\n            json_t* arr = tki->m_keys;\n            if (d->d_name[0] == '.') {\n                arr = tki->m_rotated_keys;\n                tki->m_rotated_keys_count++;\n            } else {\n                tki->m_keys_count++;\n            }\n\n            if (json_array_append(arr, json) == -1) {\n                fprintf(stderr, \"Unable to append JSON (%s) to array; skipping\\n\", d->d_name);\n                continue;\n            }\n        }\n    }\n    closedir(dir);\n    return tki;\n}\n\nstruct tang_keys_info*\nread_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = load_keys(jwkdir);\n    if (!tki) {\n        return NULL;\n    }\n\n    if (tki->m_keys_count == 0) {\n        /* Let's attempt to create a new pair of keys. */\n        free_tang_keys_info(tki);\n        if (!create_new_keys(jwkdir)) {\n            return NULL;\n        }\n        tki = load_keys(jwkdir);\n    }\n\n    if (!prepare_payload_and_sign(tki)) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    return tki;\n}\n\njson_t*\nfind_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n\n    json_auto_t* jwk = find_by_thp(tki, thp);\n    if (!jwk_valid_for_signing(jwk)) {\n        return NULL;\n    }\n\n    json_auto_t* sign = json_deep_copy(tki->m_sign);\n    if (json_array_append(sign, jwk) == -1) {\n        return NULL;\n    }\n    json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n    if (!jws) {\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\njson_t*\nfind_jwk(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki || !thp) {\n        return NULL;\n    }\n    return find_by_thp(tki, thp);\n}\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n. helpers\n\nsanity_check\n\ntrap 'on_exit' EXIT\nexport TMP=`mktemp -d`\nmkdir -p $TMP/db\n\ntangd-keygen $TMP/db sig exc\n# Make sure keys generated by tangd-keygen have proper permissions.\nvalid_key_perm \"${TMP}/db/sig.jwk\"\nvalid_key_perm \"${TMP}/db/exc.jwk\"\n\njose jwk gen -i '{\"alg\": \"ES512\"}' -o $TMP/db/.sig.jwk\njose jwk gen -i '{\"alg\": \"ES512\"}' -o $TMP/db/.oth.jwk\n\nexport PORT=$(random_port)\nstart_server \"${PORT}\"\nexport PID=$!\nsleep 0.5\n\n# Make sure requests on the root fail\nfetch / && expected_fail\n\n# The request should fail (404) for non-signature key IDs\nfetch /adv/`jose jwk thp -i $TMP/db/exc.jwk` && expected_fail\nfetch /adv/`jose jwk thp -a S512 -i $TMP/db/exc.jwk` && expected_fail\n\n# The default advertisement fetch should succeed and pass verification\nfetch /adv\nfetch /adv | ver $TMP/db/sig.jwk\nfetch /adv/ | ver $TMP/db/sig.jwk\n\n# Fetching by any thumbprint should work\nfetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/sig.jwk\nfetch /adv/`jose jwk thp -a S512 -i $TMP/db/sig.jwk` | ver $TMP/db/sig.jwk\n\n# Requesting an adv by an advertised key ID should't be signed by hidden keys\nfetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/.sig.jwk && expected_fail\nfetch /adv/`jose jwk thp -i $TMP/db/sig.jwk` | ver $TMP/db/.oth.jwk && expected_fail\n\n# Verify that the default advertisement is not signed with hidden signature keys\nfetch /adv/ | ver $TMP/db/.oth.jwk && expected_fail\nfetch /adv/ | ver $TMP/db/.sig.jwk && expected_fail\n\n# A private key advertisement is signed by all advertised keys and the requested private key\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/sig.jwk\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/.sig.jwk\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` | ver $TMP/db/.oth.jwk && expected_fail\n\n# Verify that the advertisements contain the cty parameter\nfetch /adv | jose fmt -j- -Og protected -SyOg cty -Sq \"jwk-set+json\" -E\nfetch /adv/`jose jwk thp -i $TMP/db/.sig.jwk` \\\n    | jose fmt -j- -Og signatures -A \\\n               -g 0 -Og protected -SyOg cty -Sq \"jwk-set+json\" -EUUUUU \\\n               -g 1 -Og protected -SyOg cty -Sq \"jwk-set+json\" -EUUUUU\n\nTHP_DEFAULT_HASH=S256     # SHA-256.\ntest \"$(tang-show-keys $PORT)\" = \"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" -i $TMP/db/sig.jwk)\"\n\n# Check that new keys will be created if none exist.\nrm -rf \"${TMP}/db\" && mkdir -p \"${TMP}/db\"\nfetch /adv\n\n# Now let's make sure the new keys were named using our default thumbprint\n# hash and then rotate them and check if we still create new keys.\ncd \"${TMP}/db\"\nfor k in *.jwk; do\n    # Check for the key name (SHA-256).\n    test \"${k}\" = \"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" -i \"${k}\")\".jwk\n    # Rotate the key.\n    mv -f -- \"${k}\" \".${k}\"\ndone\ncd -\nfetch /adv\n\n# Lets's now test with multiple pairs of keys.\nfor i in 1 2 3 4 5 6 7 8 9; do\n    tangd-keygen \"${TMP}\"/db other-sig-${i} other-exc-${i}\n    # Make sure the requested keys exist and are valid.\n    validate_sig \"${TMP}/db/other-sig-${i}.jwk\"\n    validate_exc \"${TMP}/db/other-exc-${i}.jwk\"\n\n    # Make sure keys generated by tangd-keygen have proper permissions.\n    valid_key_perm \"${TMP}/db/other-sig-${i}.jwk\"\n    valid_key_perm \"${TMP}/db/other-exc-${i}.jwk\"\ndone\n\n# Verify the advertisement is correct.\nvalidate \"$(fetch /adv)\"\n\n# And make sure we can fetch an adv by its thumbprint.\nfor jwk in \"${TMP}\"/db/other-sig-*.jwk; do\n    for alg in $(jose alg -k hash); do\n        fetch /adv/\"$(jose jwk thp -a \"${alg}\" -i \"${jwk}\")\" | ver \"${jwk}\"\n    done\ndone\n\n# Now let's test keys rotation.\ntangd-rotate-keys -d \"${TMP}/db\"\nfor i in 1 2 3 4 5 6 7 8 9; do\n    # Make sure keys were excluded from advertisement.\n    validate_sig \"${TMP}/db/.other-sig-${i}.jwk\"\n    validate_exc \"${TMP}/db/.other-exc-${i}.jwk\"\ndone\n\n# And test also that we have valid keys after rotation.\nthp=\nfor jwk in \"${TMP}\"/db/*.jwk; do\n    validate_sig \"${jwk}\" && thp=\"$(jose jwk thp -a \"${THP_DEFAULT_HASH}\" \\\n                                    -i \"${jwk}\")\"\n\n    # Make sure keys generated by tangd-rotate-keys have proper permissions.\n    valid_key_perm \"${jwk}\"\ndone\n[ -z \"${thp}\" ] && die \"There should be valid keys after rotation\"\ntest \"$(tang-show-keys $PORT)\" = \"${thp}\"\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nfetch() {\n    curl -sfg \"http://127.0.0.1:${PORT}${1}\"\n}\n\nver() {\n    jose jws ver -i- -k \"${1}\"\n}\n\nrandom_port() {\n    if [ -n \"${TANG_BSD}\" ]; then\n        jot -r 1 1024 65536\n    else\n        shuf -i 1024-65536 -n 1\n    fi\n}\n\nstart_server() {\n    \"${SOCAT}\" TCP-LISTEN:\"${1}\",bind=127.0.0.1,fork SYSTEM:\"${VALGRIND} tangd ${TMP}/db\" &\n}\n\non_exit() {\n    if [ \"$PID\" ]; then kill \"${PID}\"; wait \"${PID}\" || true; fi\n    [ -d \"${TMP}\" ] && rm -rf \"${TMP}\"\n}\n\nvalidate() {\n    if ! _jwks=\"$(jose fmt --json=\"${1}\" -Og payload -SyOg keys \\\n                 -AUo- 2>/dev/null)\"; then\n        echo \"Advertisement is malformed\" >&2\n        exit 1\n    fi\n    _ver=\"$(printf '%s' \"${_jwks}\" | jose jwk use -i- -r -u verify -o-)\"\n    if ! printf '%s' \"${_ver}\" | jose jws ver -i \"${1}\" -k- -a; then\n        echo \"Advertisement is missing signatures\" >&2\n        exit 1\n    fi\n}\n\nvalidate_sig() {\n    jose fmt --json \"${1}\" --output=- | jose jwk use --input=- --required \\\n        --use verify 2>/dev/null\n}\n\nvalidate_exc() {\n    jose fmt --json \"${1}\" --output=- | jose jwk use --input=- --required \\\n        --use deriveKey 2>/dev/null\n}\n\nsanity_check() {\n    # Skip test if socat is not available.\n    [ -n \"${SOCAT}\" ] || exit 77\n}\n\ndie() {\n    echo \"${1}\" >&2\n    exit 1\n}\n\nvalid_key_perm() {\n    if [ -n \"${TANG_BSD}\" ]; then\n        _perm=\"$(stat -f %Lp \"${1}\")\"\n    else\n        _perm=\"$(stat -c %a \"${1}\")\"\n    fi\n    [ \"${_perm}\" = \"440\" ]\n}\n\nexpected_fail () {\n    echo \"Test was expected to fail\" >&2\n    exit 1\n}\n", "#!/bin/sh -ex\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n. helpers\n\nsanity_check\n\ntrap 'on_exit' EXIT\nexport TMP=`mktemp -d`\nmkdir -p $TMP/db\n\n# Generate the server keys\ntangd-keygen $TMP/db sig exc\n# Make sure keys generated by tangd-keygen have proper permissions.\nvalid_key_perm \"${TMP}/db/sig.jwk\"\nvalid_key_perm \"${TMP}/db/exc.jwk\"\n\n# Generate the client keys\nexc_kid=`jose jwk thp -i $TMP/db/exc.jwk`\ntmp=`jose fmt -j $TMP/db/exc.jwk -Od x -d y -d d -o-`\njose jwk gen -i \"$tmp\" -o $TMP/exc.jwk\njose jwk pub -i $TMP/exc.jwk -o $TMP/exc.pub.jwk\n\n# Start the server\nexport PORT=$(random_port)\nstart_server \"${PORT}\"\nexport PID=$!\nsleep 0.5\n\n# Make sure that GET fails\ncurl -sf http://127.0.0.1:$PORT/rec && expected_fail\ncurl -sf http://127.0.0.1:$PORT/rec/ && expected_fail\n\n# Make a recovery request (NOTE: this is insecure! Don't do this in real code!)\ngood=`jose jwk exc -i '{\"alg\":\"ECMR\",\"key_ops\":[\"deriveKey\"]}' -l $TMP/exc.jwk -r $TMP/db/exc.jwk`\ntest=`curl -sf -X POST \\\n           -H \"Content-Type: application/jwk+json\" \\\n           --data-binary @- \\\n           http://127.0.0.1:$PORT/rec/${exc_kid} < $TMP/exc.pub.jwk`\n[ \"$good\" = \"$test\" ]\n", "/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keys.c\"\n#include \"test-util.h\"\n\nconst char* jwkdir = \"@testjwkdir@\";\n\nstruct thp_result {\n    const char* thp;\n    int valid;\n};\n\nstruct test_result_int {\n    const char* data;\n    int expected;\n};\n\nstatic void\nverify_keys_permissions(const char* targetdir)\n{\n    struct stat st;\n    struct dirent* d;\n    DIR* dir = opendir(targetdir);\n    ASSERT(dir);\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", targetdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            ASSERT(stat(filepath, &st) == 0);\n\n            ASSERT_WITH_MSG(st.st_mode & (S_IRUSR | S_IRGRP), \"key = %s, missing perm (0%o)\", filepath, (S_IRUSR | S_IRGRP));\n            int unexpected_perms[] = {\n                S_ISUID, /* 04000 set-user-ID */\n                S_ISGID, /* 02000 set-group-ID */\n                S_IWUSR, /* 00200 write by owner */\n                S_IXUSR, /* 00100 execute/search by owner */\n                S_IWGRP, /* 00020 write by group */\n                S_IXGRP, /* 00010 execute/search by group */\n                S_IROTH, /* 00004 read by others */\n                S_IWOTH, /* 00002 write by others */\n                S_IXOTH, /* 00001 execute/search by others */\n                0\n            };\n            for (int i = 0; unexpected_perms[i] != 0; i++) {\n                ASSERT_WITH_MSG((st.st_mode & unexpected_perms[i]) == 0, \"key = %s, i = %d, unexpected perm (0%o)\", filepath, i, unexpected_perms[i]);\n            }\n\n        }\n    }\n    closedir(dir);\n}\n\nstatic void\ntest_create_new_keys(void)\n{\n   __attribute__((cleanup(cleanup_str))) char* newdir = create_tempdir();\n    ASSERT(newdir);\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(newdir);\n    ASSERT(tki);\n    ASSERT(tki->m_keys_count == 2);\n\n    /* Make sure keys have proper permissions. */\n    verify_keys_permissions(newdir);\n\n    remove_tempdir(newdir);\n}\n\n\nstatic void\ntest_is_hash(void)\n{\n    const struct test_result_int test_data[] = {\n        {NULL, 0},\n        {\"\", 0},\n        {\"ES512\", 0},\n        {\"ECMR\", 0},\n        {\"foobar\", 0},\n        {\"{\", 0},\n        {\"[}\", 0},\n        {\"[]\", 0},\n        {\"S1\", 1},\n        {\"S224\", 1},\n        {\"S256\", 1},\n        {\"S384\", 1},\n        {\"S512\", 1},\n        {\"S42\", 0}\n    };\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        int ret = is_hash(test_data[i].data);\n        ASSERT_WITH_MSG(ret == test_data[i].expected, \"i = %d, alg = %s\", i, test_data[i].data);\n    };\n\n}\n\nstatic void\ntest_jwk_generate(void)\n{\n    const struct test_result_int test_data[] = {\n        {NULL, 0},\n        {\"\", 0},\n        {\"ES512\", 1},\n        {\"ECMR\", 1},\n        {\"foobar\", 0},\n        {\"{\", 0},\n        {\"[}\", 0},\n        {\"[]\", 0}\n    };\n\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* jwk = jwk_generate(test_data[i].data);\n        ASSERT_WITH_MSG(!!jwk == test_data[i].expected, \"i = %d, alg = %s\", i, test_data[i].data);\n    };\n}\n\nstatic void\ntest_find_jws(void)\n{\n    const struct thp_result test_data[] = {\n        {\"00BUQM4A7NYxbOrBR9QDfkzGVGj3k57Fs4jCbJxcLYAgRFHu5B7jtbL97x1T7stQ\", 1},\n        {\"dd5qbN1lQ6UWdZszbfx2oIcH34ShklzFL1SUQg\", 1},\n        {\"dOZkUtZ_gLDUP53GIlyAxHMNuyrk8vdY-XXND32GccqNbT_MKpqGC-13-GNEye48\", 1},\n        {\"DZrlBQvfvlwPQlvH_IieBdc_KpesEramLygVL_rFr7g\", 1},\n        {\"FL_Zt5fFadUL4syeMMpUnss8aKdCrPGFy3102JGR3EE\", 1},\n        {\"qgmqJSo6AEEuVQY7zVlklqdTMqY\", 1},\n        {\"r4E2wG1u_YyKUo0N0rIK7jJF5Xg\", 1},\n        {\"ugJ4Ula-YABQIiJ-0g3B_jpFpF2nl3W-DNpfLdXArhTusV0QCcd1vtgDeGHEPzpm7jEsyC7VYYSSOkZicK22mw\", 1},\n        {\"up0Z4fRhpd4O5QwBaMCXDTlrvxCmZacU0MD8kw\", 1},\n        {\"vllHS-M0aQFCo2yUCcAahMU4TAtXACyeuRf-zbmmTPBg7V0Pb-RRFGo5C6MnpzdirK8B3ORLOsN8RyXClvtjxA\", 1},\n        {\"-bWkGaJi0Zdvxaj4DCp28umLcRA\", 0},\n        {\"WEpfFyeoNKkE2-TosN_bP-gd9UgRvQCZpVasZQ\", 0},\n        {\"L4xg2tZXTEVbsK39bzOZM1jGWn3HtOxF5gh6F9YVf5Q\", 0},\n        {\"9U8qgy_YjyY6Isuq6QuiKEiYZgNJShcGgJx5FJzCu6m3N6zFaIPy_HDkxkVqAZ9E\", 0},\n        {\"Cy73glFjs6B6RU7wy6vWxAc-2bJy5VJOT9LyK80eKgZ8k27wXZ-3rjsuNU5tua_yHWtluyoSYtjoKXfI0E8ESw\", 0},\n        {NULL, 1},\n        {\"a\", 0},\n        {\"foo\", 0},\n        {\"bar\", 0},\n        {\"XXXXXXXXXXXXXXXXXX\", 0}\n    };\n\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* jws = find_jws(tki, test_data[i].thp);\n        ASSERT_WITH_MSG(!!jws == test_data[i].valid, \"i = %d, thp = %s\", i, test_data[i].thp);\n    }\n\n    /* Passing NULL to find_jws should return the default advertisement */\n    json_auto_t* adv = find_jws(tki, NULL);\n    ASSERT(adv);\n\n\n    /*\n     * The default set of signing keys are the signing keys that are not\n     * rotated. The payload is made of deriving keys that are also not\n     * rotated. The default advertisement should be signed by this set of\n     * default signing keys.\n     */\n    ASSERT(jose_jws_ver(NULL, adv, NULL, tki->m_sign, 1));\n\n    /* find_jws should be able to respond to thumbprints of keys using any\n     * of jose supported hash algorithms. */\n    const char** hashes = supported_hashes();\n    size_t idx;\n    json_t* jwk;\n\n    /* Let's put together all the keys, including rotated ones. */\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    ASSERT(keys);\n    ASSERT(json_array_extend(keys, tki->m_rotated_keys) == 0);\n    ASSERT(json_array_size(keys) == (size_t)(tki->m_keys_count + tki->m_rotated_keys_count));\n\n    for (int i = 0; hashes[i]; i++) {\n        json_array_foreach(keys, idx, jwk) {\n            if (!jwk_valid_for_signing(jwk)) {\n                continue;\n            }\n            __attribute__((cleanup(cleanup_str))) char* thp = jwk_thumbprint(jwk, hashes[i]);\n            ASSERT_WITH_MSG(thp, \"i = %d, hash = %s, key idx = %d\", i, hashes[i], idx);\n            json_auto_t* jws = find_jws(tki, thp);\n            ASSERT_WITH_MSG(jws, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n\n            /* Signing keys should sign the payload, in addition to the\n             * default set of signing keys. */\n            json_auto_t* sign = json_deep_copy(tki->m_sign);\n            ASSERT_WITH_MSG(sign, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n            ASSERT_WITH_MSG(json_array_append(sign, jwk) == 0, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n            ASSERT_WITH_MSG(jose_jws_ver(NULL, jws, NULL, sign, 1), \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n        }\n    }\n}\n\nstatic void\ntest_find_jwk(void)\n{\n    const struct thp_result test_data[] = {\n        {\"1HdF3XKRSsuZdkpXNurBPoL_pvxdvCOlHuhB4DP-4xWFqbZ51zo29kR4fSiT3BGy9UrHVJ26JMBLOA1vKq3lxA\", 1},\n        {\"9U8qgy_YjyY6Isuq6QuiKEiYZgNJShcGgJx5FJzCu6m3N6zFaIPy_HDkxkVqAZ9E\", 1},\n        {\"-bWkGaJi0Zdvxaj4DCp28umLcRA\", 1},\n        {\"Cy73glFjs6B6RU7wy6vWxAc-2bJy5VJOT9LyK80eKgZ8k27wXZ-3rjsuNU5tua_yHWtluyoSYtjoKXfI0E8ESw\", 1},\n        {\"kfjbqx_b3BsgPC87HwlOWL9daGMMHBzxcFLClw\", 1},\n        {\"L4xg2tZXTEVbsK39bzOZM1jGWn3HtOxF5gh6F9YVf5Q\", 1},\n        {\"LsVAV2ig5LlfstM8TRSf-c7IAkLpNYbIysNuRCVlxocRCGqAh6-f9PklM4nU4N-J\", 1},\n        {\"OkAcDxYHNlo7-tul8OubYuWXB8CPEhAkcacCmhTclMU\", 1},\n        {\"uZ0s8YTXcGcuWduWWBSiR2OjOVg\", 1},\n        {\"WEpfFyeoNKkE2-TosN_bP-gd9UgRvQCZpVasZQ\", 1},\n        {NULL, 0},\n        {\"a\", 0},\n        {\"foo\", 0},\n        {\"bar\", 0},\n        {\"XXXXXXXXXXXXXXXXXX\", 0},\n    };\n\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n\n    for (int i = 0, len = ARRAY_COUNT(test_data); i < len; i++) {\n        json_auto_t* tjwk = find_jwk(tki, test_data[i].thp);\n        ASSERT_WITH_MSG(!!tjwk == test_data[i].valid, \"i = %d, thp = %s\", i, test_data[i].thp);\n    }\n    /* Passing NULL to find_jwk should fail */\n    json_auto_t* bad_jwk = find_jwk(tki, NULL);\n    ASSERT(bad_jwk == NULL);\n\n    /* find_jwk should be able to respond to thumbprints of keys using any\n     * of jose supported hash algorithms. */\n    const char** hashes = supported_hashes();\n    size_t idx;\n    json_t* jwk;\n\n    /* Let's put together all the keys, including rotated ones. */\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    ASSERT(keys);\n    ASSERT(json_array_extend(keys, tki->m_rotated_keys) == 0);\n    ASSERT(json_array_size(keys) == (size_t)(tki->m_keys_count + tki->m_rotated_keys_count));\n\n    for (int i = 0; hashes[i]; i++) {\n        json_array_foreach(keys, idx, jwk) {\n            if (!jwk_valid_for_deriving_keys(jwk)) {\n                continue;\n            }\n            __attribute__((cleanup(cleanup_str))) char* thp = jwk_thumbprint(jwk, hashes[i]);\n            json_auto_t* tjwk = find_jwk(tki, thp);\n            ASSERT_WITH_MSG(tjwk, \"i = %d, hash = %s, key idx = %d, thp = %s\", i, hashes[i], idx, thp);\n        }\n    }\n}\n\nstatic void\ntest_read_keys(void)\n{\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki = read_keys(jwkdir);\n    ASSERT(tki);\n\n    /*\n     * Keys in tests/keys:\n     * - .uZ0s8YTXcGcuWduWWBSiR2OjOVg.jwk\n     * - .r4E2wG1u_YyKUo0N0rIK7jJF5Xg.jwk\n     * - qgmqJSo6AEEuVQY7zVlklqdTMqY.jwk\n     * - -bWkGaJi0Zdvxaj4DCp28umLcRA.jwk\n     */\n    ASSERT(tki->m_keys_count == 2);\n    ASSERT(tki->m_rotated_keys_count == 2);\n    ASSERT(json_array_size(tki->m_keys) == 2);\n    ASSERT(json_array_size(tki->m_rotated_keys) == 2);\n\n    const char* invalid_jwkdir = \"foobar\";\n    __attribute__((cleanup(cleanup_tang_keys_info))) struct tang_keys_info* tki2 = read_keys(invalid_jwkdir);\n    ASSERT(tki2 == NULL);\n}\n\nstatic void\nrun_tests(void)\n{\n    test_read_keys();\n    test_find_jwk();\n    test_find_jws();\n    test_jwk_generate();\n    test_is_hash();\n    test_create_new_keys();\n}\n\nint main(int argc, char** argv)\n{\n    run_tests();\n    return 0;\n}\n"], "filenames": ["src/keys.c", "tests/adv", "tests/helpers", "tests/rec", "tests/test-keys.c.in"], "buggy_code_start_loc": [270, 43, 86, 48, 160], "buggy_code_end_loc": [449, 70, 86, 50, 160], "fixing_code_start_loc": [270, 43, 87, 48, 161], "fixing_code_end_loc": [450, 70, 92, 50, 166], "type": "NVD-CWE-noinfo", "message": "A flaw exists in tang, a network-based cryptographic binding server, which could result in leak of private keys.", "other": {"cve": {"id": "CVE-2021-4076", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T23:15:09.187", "lastModified": "2022-03-09T19:45:09.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw exists in tang, a network-based cryptographic binding server, which could result in leak of private keys."}, {"lang": "es", "value": "Se presenta un fallo en tang, un servidor de enlace criptogr\u00e1fico basado en la red, que podr\u00eda dar lugar a un filtrado de claves privadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tang_project:tang:*:*:*:*:*:*:*:*", "versionStartIncluding": "8", "versionEndExcluding": "11", "matchCriteriaId": "84478939-29D8-4E40-BAC5-08C884428C49"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2029814", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/latchset/tang/commit/e82459fda10f0630c3414ed2afbc6320bb9ea7c9", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/latchset/tang/pull/81", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/latchset/tang/commit/e82459fda10f0630c3414ed2afbc6320bb9ea7c9"}}