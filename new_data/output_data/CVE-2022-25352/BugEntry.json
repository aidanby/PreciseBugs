{"buggy_code": ["function isObject (o, allowArray) {\n  return o && 'object' === typeof o && (allowArray || !Array.isArray(o))\n}\n\nfunction isBasic (b) {\n  return 'string' === typeof b || 'number' === typeof b\n}\n\nfunction get (obj, path, dft) {\n  if(!isObject(obj, true)) return dft\n  if(isBasic(path)) return obj[path]\n  for(var i = 0; i < path.length; i++) {\n    if(null == (obj = obj[path[i]])) return dft\n  }\n  return obj\n}\n\nfunction isNonNegativeInteger (i) {\n  return Number.isInteger(i) && i >= 0\n}\n\nfunction set (obj, path, value) {\n  if(!obj) throw new Error('libnested.set: first arg must be an object')\n  if(isBasic(path)) return obj[path] = value\n  for(var i = 0; i < path.length; i++)\n    if(i === path.length - 1)\n      obj[path[i]] = value\n    else if(null == obj[path[i]])\n      obj = (obj[path[i]] = isNonNegativeInteger(path[i+1]) ? [] : {})\n    else if (!(isPrototypePolluted(path[i])))\n      obj = obj[path[i]]\n  return value\n}\n\nfunction each (obj, iter, includeArrays, path) {\n  path = path || []\n  //handle array separately, so that arrays can have integer keys\n  if(Array.isArray(obj)) {\n    if(!includeArrays) return false\n    for(var k = 0; k < obj.length; k++) {\n      //loop content is duplicated, so that return works\n      var v = obj[k]\n      if(isObject(v, includeArrays)) {\n        if(false === each(v, iter, includeArrays, path.concat(k)))\n          return false\n      } else {\n        if(false === iter(v, path.concat(k))) return false\n      }\n    }\n  }\n  else {\n    for(var k in obj) {\n      //loop content is duplicated, so that return works\n      var v = obj[k]\n      if(isObject(v, includeArrays)) {\n        if(false === each(v, iter, includeArrays, path.concat(k)))\n          return false\n      } else {\n        if(false === iter(v, path.concat(k))) return false\n      }\n    }\n  }\n  return true\n}\n\nfunction map (obj, iter, out, includeArrays) {\n  var out = out || Array.isArray(obj) ? [] : {}\n  each(obj, function (val, path) {\n    set(out, path, iter(val, path))\n  }, includeArrays)\n  return out\n}\n\nfunction paths (obj, incluedArrays) {\n  var out = []\n  each(obj, function (_, path) {\n    out.push(path)\n  }, incluedArrays)\n  return out\n}\n\nfunction id (e) { return e }\n\n//note, cyclic objects are not supported.\n//will cause an stack overflow.\nfunction clone (obj) {\n  if(!isObject(obj, true)) return obj\n  var _obj\n  _obj = Array.isArray(obj) ? [] : {}\n  for(var k in obj) _obj[k] = clone(obj[k])\n  return _obj\n}\n\nfunction isPrototypePolluted(key) {\n  return ['__proto__', 'constructor', 'prototype'].includes(key)\n}\n\nexports.get = get\nexports.set = set\nexports.each = each\nexports.map = map\nexports.paths = paths\nexports.clone = clone\nexports.copy = clone\n", "\nvar tape = require('tape')\nvar R = require('./')\n\ntape('paths', function (t) {\n\n  t.deepEqual(\n    R.get({foo: true, bar: false}, 'foo'),\n    true\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, 'bar'),\n    false\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, ['foo']),\n    true\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, ['bar']),\n    false\n  )\n\n  t.deepEqual(\n    R.get(null, ['bar']),\n    undefined\n  )\n\n\n  t.deepEqual(\n    R.paths({foo: {bar: true}, baz: 2}),\n    [\n      ['foo', 'bar'],\n      ['baz']\n    ]\n  )\n  t.deepEqual(\n    R.paths({}),\n    []\n  )\n\n  var deep = {foo: {bar: true}, baz: 2, blurg: {fop: {hif: []}}}\n\n  t.deepEqual(\n    R.paths(deep),\n    [\n      ['foo', 'bar'],\n      ['baz'],\n      ['blurg', 'fop', 'hif']\n    ]\n  )\n\n  var o = {}\n  R.each(deep, function (v, path) {\n    t.equal(R.get(deep, path), v)\n    R.set(o, path, v)\n  })\n\n  t.deepEqual(o, deep)\n\n  t.deepEqual(R.map(deep, function (v) { return v }), deep)\n\n  var first\n  t.equal(R.each(deep, function (_, path) {\n    if(path.length === 2) {\n      first = path\n      return false\n    }\n  }), false)\n\n  t.deepEqual(first, ['foo', 'bar'])\n\n  var _a = [1,2,3]\n  var a = R.set(deep, ['rom', 'pan'], _a)\n  t.equal(a, _a)\n\n\n\n  var a = R.set(deep, 'zak', 53)\n  var a = R.set(deep, ['rom', 'pan', 2], 30)\n\n  t.deepEqual(\n    deep,\n    {\n      foo: {bar: true},\n      baz: 2,\n      blurg: {fop: {hif: []}},\n      rom: {pan: [1,2,30]},\n      zak: 53\n    }\n  )\n\n  t.deepEqual(\n    deep,\n    R.clone(deep)\n  )\n\n  t.notEqual(\n    deep,\n    R.clone(deep)\n  )\n\n\n  t.end()\n\n})\n\ntape('include arrays', function (t) {\n  var deep = {foo: {bar: true}, baz: 2, blurg: {fop: {hif: [1,2,3]}}}\n\n  t.deepEqual(\n    R.paths(deep, true),\n    [\n      ['foo', 'bar'],\n      ['baz'],\n      ['blurg', 'fop', 'hif', 0],\n      ['blurg', 'fop', 'hif', 1],\n      ['blurg', 'fop', 'hif', 2]\n    ]\n  )\n\n  var o = {}\n  R.set(o, ['hello', 0, 'okay'], true),\n  t.deepEqual(\n    o,\n    {hello: [{okay: true}]}\n  )\n\n  t.end()\n})\n\ntape('set', function (t) {\n  var o = {}\n  R.set(o, ['foo', 0], true)\n  t.deepEqual(o, {foo: [true]})\n  R.set(o, ['foo', 1], false)\n  t.deepEqual(o, {foo: [true, false]})\n  t.ok(Array.isArray(o.foo), 'created an array in the right place')\n  t.end()\n})\n\ntape('clone does not leave an array reference', function (t) {\n  var a = {foo: [1]}\n  t.deepEqual(R.clone(a), a)\n  t.notEqual(a.foo, R.clone(a).foo)\n  var b = {foo: [{}], bar: {}}\n  t.deepEqual(R.clone(b), b)\n  t.notEqual(b.foo, R.clone(b).foo)\n  t.notEqual(b.foo[0], R.clone(b).foo[0])\n  t.notEqual(b.bar, R.clone(b).bar)\n\n  t.end()\n})\n"], "fixing_code": ["function isObject (o, allowArray) {\n  return o && 'object' === typeof o && (allowArray || !Array.isArray(o))\n}\n\nfunction isBasic (b) {\n  return 'string' === typeof b || 'number' === typeof b\n}\n\nfunction get (obj, path, dft) {\n  if(!isObject(obj, true)) return dft\n  if(isBasic(path)) return obj[path]\n  for(var i = 0; i < path.length; i++) {\n    if(null == (obj = obj[path[i]])) return dft\n  }\n  return obj\n}\n\nfunction isNonNegativeInteger (i) {\n  return Number.isInteger(i) && i >= 0\n}\n\nfunction set (obj, path, value) {\n  if(!obj) throw new Error('libnested.set: first arg must be an object')\n  if(isBasic(path)) return obj[path] = value\n  for(var i = 0; i < path.length; i++) {\n    if (isPrototypePolluted(path[i]))\n      continue\n\n    if(i === path.length - 1)\n      obj[path[i]] = value\n    else if(null == obj[path[i]])\n      obj = (obj[path[i]] = isNonNegativeInteger(path[i+1]) ? [] : {})\n    else\n      obj = obj[path[i]]\n  }\n  return value\n}\n\nfunction each (obj, iter, includeArrays, path) {\n  path = path || []\n  //handle array separately, so that arrays can have integer keys\n  if(Array.isArray(obj)) {\n    if(!includeArrays) return false\n    for(var k = 0; k < obj.length; k++) {\n      //loop content is duplicated, so that return works\n      var v = obj[k]\n      if(isObject(v, includeArrays)) {\n        if(false === each(v, iter, includeArrays, path.concat(k)))\n          return false\n      } else {\n        if(false === iter(v, path.concat(k))) return false\n      }\n    }\n  }\n  else {\n    for(var k in obj) {\n      //loop content is duplicated, so that return works\n      var v = obj[k]\n      if(isObject(v, includeArrays)) {\n        if(false === each(v, iter, includeArrays, path.concat(k)))\n          return false\n      } else {\n        if(false === iter(v, path.concat(k))) return false\n      }\n    }\n  }\n  return true\n}\n\nfunction map (obj, iter, out, includeArrays) {\n  var out = out || Array.isArray(obj) ? [] : {}\n  each(obj, function (val, path) {\n    set(out, path, iter(val, path))\n  }, includeArrays)\n  return out\n}\n\nfunction paths (obj, incluedArrays) {\n  var out = []\n  each(obj, function (_, path) {\n    out.push(path)\n  }, incluedArrays)\n  return out\n}\n\nfunction id (e) { return e }\n\n//note, cyclic objects are not supported.\n//will cause an stack overflow.\nfunction clone (obj) {\n  if(!isObject(obj, true)) return obj\n  var _obj\n  _obj = Array.isArray(obj) ? [] : {}\n  for(var k in obj) _obj[k] = clone(obj[k])\n  return _obj\n}\n\nfunction isPrototypePolluted(key) {\n  return ['__proto__', 'constructor', 'prototype'].includes(key.toString())\n}\n\nexports.get = get\nexports.set = set\nexports.each = each\nexports.map = map\nexports.paths = paths\nexports.clone = clone\nexports.copy = clone\n", "\nvar tape = require('tape')\nvar R = require('./')\n\ntape('paths', function (t) {\n\n  t.deepEqual(\n    R.get({foo: true, bar: false}, 'foo'),\n    true\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, 'bar'),\n    false\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, ['foo']),\n    true\n  )\n  t.deepEqual(\n    R.get({foo: true, bar: false}, ['bar']),\n    false\n  )\n\n  t.deepEqual(\n    R.get(null, ['bar']),\n    undefined\n  )\n\n\n  t.deepEqual(\n    R.paths({foo: {bar: true}, baz: 2}),\n    [\n      ['foo', 'bar'],\n      ['baz']\n    ]\n  )\n  t.deepEqual(\n    R.paths({}),\n    []\n  )\n\n  var deep = {foo: {bar: true}, baz: 2, blurg: {fop: {hif: []}}}\n\n  t.deepEqual(\n    R.paths(deep),\n    [\n      ['foo', 'bar'],\n      ['baz'],\n      ['blurg', 'fop', 'hif']\n    ]\n  )\n\n  var o = {}\n  R.each(deep, function (v, path) {\n    t.equal(R.get(deep, path), v)\n    R.set(o, path, v)\n  })\n\n  t.deepEqual(o, deep)\n\n  t.deepEqual(R.map(deep, function (v) { return v }), deep)\n\n  var first\n  t.equal(R.each(deep, function (_, path) {\n    if(path.length === 2) {\n      first = path\n      return false\n    }\n  }), false)\n\n  t.deepEqual(first, ['foo', 'bar'])\n\n  var _a = [1,2,3]\n  var a = R.set(deep, ['rom', 'pan'], _a)\n  t.equal(a, _a)\n\n\n\n  var a = R.set(deep, 'zak', 53)\n  var a = R.set(deep, ['rom', 'pan', 2], 30)\n\n  t.deepEqual(\n    deep,\n    {\n      foo: {bar: true},\n      baz: 2,\n      blurg: {fop: {hif: []}},\n      rom: {pan: [1,2,30]},\n      zak: 53\n    }\n  )\n\n  t.deepEqual(\n    deep,\n    R.clone(deep)\n  )\n\n  t.notEqual(\n    deep,\n    R.clone(deep)\n  )\n\n\n  t.end()\n\n})\n\ntape('include arrays', function (t) {\n  var deep = {foo: {bar: true}, baz: 2, blurg: {fop: {hif: [1,2,3]}}}\n\n  t.deepEqual(\n    R.paths(deep, true),\n    [\n      ['foo', 'bar'],\n      ['baz'],\n      ['blurg', 'fop', 'hif', 0],\n      ['blurg', 'fop', 'hif', 1],\n      ['blurg', 'fop', 'hif', 2]\n    ]\n  )\n\n  var o = {}\n  R.set(o, ['hello', 0, 'okay'], true),\n  t.deepEqual(\n    o,\n    {hello: [{okay: true}]}\n  )\n\n  t.end()\n})\n\ntape('set', function (t) {\n  var o = {}\n  R.set(o, ['foo', 0], true)\n  t.deepEqual(o, {foo: [true]})\n  R.set(o, ['foo', 1], false)\n  t.deepEqual(o, {foo: [true, false]})\n  t.ok(Array.isArray(o.foo), 'created an array in the right place')\n  t.end()\n})\n\ntape('clone does not leave an array reference', function (t) {\n  var a = {foo: [1]}\n  t.deepEqual(R.clone(a), a)\n  t.notEqual(a.foo, R.clone(a).foo)\n  var b = {foo: [{}], bar: {}}\n  t.deepEqual(R.clone(b), b)\n  t.notEqual(b.foo, R.clone(b).foo)\n  t.notEqual(b.foo[0], R.clone(b).foo[0])\n  t.notEqual(b.bar, R.clone(b).bar)\n\n  t.end()\n})\n\ntape('prototype pollution', function (t) {\n  t.notEqual({}.polluted, 'yes')\n  R.set({}, ['__proto__','polluted'], 'yes');\n  t.notEqual({}.polluted, 'yes')\n  R.set({}, [['__proto__'], 'polluted'], 'yes')\n  t.notEqual({}.polluted, 'yes')\n  R.set({}, [['constructor', 'prototype'], 'polluted'], 'yes')\n  t.notEqual({}.polluted, 'yes')\n  t.end()\n})\n"], "filenames": ["index.js", "test.js"], "buggy_code_start_loc": [25, 153], "buggy_code_end_loc": [96, 153], "fixing_code_start_loc": [25, 154], "fixing_code_end_loc": [100, 165], "type": "CWE-1321", "message": "The package libnested before 1.5.2 are vulnerable to Prototype Pollution via the set function in index.js. **Note:** This vulnerability derives from an incomplete fix for [CVE-2020-28283](https://security.snyk.io/vuln/SNYK-JS-LIBNESTED-1054930)", "other": {"cve": {"id": "CVE-2022-25352", "sourceIdentifier": "report@snyk.io", "published": "2022-03-17T12:15:08.190", "lastModified": "2022-03-24T02:12:27.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package libnested before 1.5.2 are vulnerable to Prototype Pollution via the set function in index.js. **Note:** This vulnerability derives from an incomplete fix for [CVE-2020-28283](https://security.snyk.io/vuln/SNYK-JS-LIBNESTED-1054930)"}, {"lang": "es", "value": "El paquete libnested versiones anteriores a 1.5.2, es vulnerable a una Contaminaci\u00f3n de Prototipos por medio de la funci\u00f3n set en el archivo index.js. **Nota:** Esta vulnerabilidad deriva de una correcci\u00f3n incompleta de [CVE-2020-28283](https://security.snyk.io/vuln/SNYK-JS-LIBNESTED-1054930)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libnested_project:libnested:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.5.2", "matchCriteriaId": "76354230-C896-46BA-8BD4-80610A0835F8"}]}]}], "references": [{"url": "https://github.com/dominictarr/libnested/blob/master/index.js%23L22", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/dominictarr/libnested/commit/c1129865d75fbe52b5a4f755ad3110ca5420f2e1", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-LIBNESTED-2342117", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dominictarr/libnested/commit/c1129865d75fbe52b5a4f755ad3110ca5420f2e1"}}