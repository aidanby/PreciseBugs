{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * Copyright (c) 2013, Google Inc.\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2006\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n */\n\n#define LOG_CATEGORY LOGC_BOOT\n\n#ifdef USE_HOSTCC\n#include \"mkimage.h\"\n#include <time.h>\n#include <linux/libfdt.h>\n#include <u-boot/crc.h>\n#else\n#include <linux/compiler.h>\n#include <common.h>\n#include <errno.h>\n#include <log.h>\n#include <mapmem.h>\n#include <asm/io.h>\n#include <malloc.h>\n#include <asm/global_data.h>\nDECLARE_GLOBAL_DATA_PTR;\n#endif /* !USE_HOSTCC*/\n\n#include <bootm.h>\n#include <image.h>\n#include <bootstage.h>\n#include <linux/kconfig.h>\n#include <u-boot/crc.h>\n#include <u-boot/md5.h>\n#include <u-boot/sha1.h>\n#include <u-boot/sha256.h>\n#include <u-boot/sha512.h>\n\n/*****************************************************************************/\n/* New uImage format routines */\n/*****************************************************************************/\n#ifndef USE_HOSTCC\nstatic int fit_parse_spec(const char *spec, char sepc, ulong addr_curr,\n\t\tulong *addr, const char **name)\n{\n\tconst char *sep;\n\n\t*addr = addr_curr;\n\t*name = NULL;\n\n\tsep = strchr(spec, sepc);\n\tif (sep) {\n\t\tif (sep - spec > 0)\n\t\t\t*addr = simple_strtoul(spec, NULL, 16);\n\n\t\t*name = sep + 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_parse_conf - parse FIT configuration spec\n * @spec: input string, containing configuration spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * configuration\n * @conf_name double pointer to a char, will hold pointer to a configuration\n * unit name\n *\n * fit_parse_conf() expects configuration spec in the form of [<addr>]#<conf>,\n * where <addr> is a FIT image address that contains configuration\n * with a <conf> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid configuration string,\n *     addr and conf_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_conf(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **conf_name)\n{\n\treturn fit_parse_spec(spec, '#', addr_curr, addr, conf_name);\n}\n\n/**\n * fit_parse_subimage - parse FIT subimage spec\n * @spec: input string, containing subimage spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * subimage\n * @image_name: double pointer to a char, will hold pointer to a subimage name\n *\n * fit_parse_subimage() expects subimage spec in the form of\n * [<addr>]:<subimage>, where <addr> is a FIT image address that contains\n * subimage with a <subimg> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid subimage string,\n *     addr and image_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_subimage(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **image_name)\n{\n\treturn fit_parse_spec(spec, ':', addr_curr, addr, image_name);\n}\n#endif /* !USE_HOSTCC */\n\n#ifdef USE_HOSTCC\n/* Host tools use these implementations for Cipher and Signature support */\nstatic void *host_blob;\n\nvoid image_set_host_blob(void *blob)\n{\n\thost_blob = blob;\n}\n\nvoid *image_get_host_blob(void)\n{\n\treturn host_blob;\n}\n#endif /* USE_HOSTCC */\n\nstatic void fit_get_debug(const void *fit, int noffset,\n\t\tchar *prop_name, int err)\n{\n\tdebug(\"Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\\n\",\n\t      prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL),\n\t      fdt_strerror(err));\n}\n\n/**\n * fit_get_subimage_count - get component (sub-image) count\n * @fit: pointer to the FIT format image header\n * @images_noffset: offset of images node\n *\n * returns:\n *     number of image components\n */\nint fit_get_subimage_count(const void *fit, int images_noffset)\n{\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n#if CONFIG_IS_ENABLED(FIT_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT)\n/**\n * fit_image_print_data() - prints out the hash node details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash node\n * @p: pointer to prefix string\n * @type: Type of information to print (\"hash\" or \"sign\")\n *\n * fit_image_print_data() lists properties for the processed hash node\n *\n * This function avoid using puts() since it prints a newline on the host\n * but does not in U-Boot.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_data(const void *fit, int noffset, const char *p,\n\t\t\t\t const char *type)\n{\n\tconst char *keyname;\n\tuint8_t *value;\n\tint value_len;\n\tchar *algo;\n\tconst char *padding;\n\tbool required;\n\tint ret, i;\n\n\tdebug(\"%s  %s node:    '%s'\\n\", p, type,\n\t      fit_get_name(fit, noffset, NULL));\n\tprintf(\"%s  %s algo:    \", p, type);\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\tprintf(\"invalid/unsupported\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s\", algo);\n\tkeyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);\n\trequired = fdt_getprop(fit, noffset, FIT_KEY_REQUIRED, NULL) != NULL;\n\tif (keyname)\n\t\tprintf(\":%s\", keyname);\n\tif (required)\n\t\tprintf(\" (required)\");\n\tprintf(\"\\n\");\n\n\tpadding = fdt_getprop(fit, noffset, \"padding\", NULL);\n\tif (padding)\n\t\tprintf(\"%s  %s padding: %s\\n\", p, type, padding);\n\n\tret = fit_image_hash_get_value(fit, noffset, &value,\n\t\t\t\t       &value_len);\n\tprintf(\"%s  %s value:   \", p, type);\n\tif (ret) {\n\t\tprintf(\"unavailable\\n\");\n\t} else {\n\t\tfor (i = 0; i < value_len; i++)\n\t\t\tprintf(\"%02x\", value[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tdebug(\"%s  %s len:     %d\\n\", p, type, value_len);\n\n\t/* Signatures have a time stamp */\n\tif (IMAGE_ENABLE_TIMESTAMP && keyname) {\n\t\ttime_t timestamp;\n\n\t\tprintf(\"%s  Timestamp:    \", p);\n\t\tif (fit_get_timestamp(fit, noffset, &timestamp))\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n}\n\n/**\n * fit_image_print_verification_data() - prints out the hash/signature details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash or signature node\n * @p: pointer to prefix string\n *\n * This lists properties for the processed hash node\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_verification_data(const void *fit, int noffset,\n\t\t\t\t\t      const char *p)\n{\n\tconst char *name;\n\n\t/*\n\t * Check subnode name, must be equal to \"hash\" or \"signature\".\n\t * Multiple hash/signature nodes require unique unit node\n\t * names, e.g. hash-1, hash-2, signature-1, signature-2, etc.\n\t */\n\tname = fit_get_name(fit, noffset, NULL);\n\tif (!strncmp(name, FIT_HASH_NODENAME, strlen(FIT_HASH_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Hash\");\n\t} else if (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Sign\");\n\t}\n}\n\n/**\n * fit_conf_print - prints out the FIT configuration details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the configuration node\n * @p: pointer to prefix string\n *\n * fit_conf_print() lists all mandatory properties for the processed\n * configuration node.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_conf_print(const void *fit, int noffset, const char *p)\n{\n\tchar *desc;\n\tconst char *uname;\n\tint ret;\n\tint fdt_index, loadables_index;\n\tint ndepth;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tuname = fdt_getprop(fit, noffset, FIT_KERNEL_PROP, NULL);\n\tprintf(\"%s  Kernel:       \", p);\n\tif (!uname)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", uname);\n\n\t/* Optional properties */\n\tuname = fdt_getprop(fit, noffset, FIT_RAMDISK_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Init Ramdisk: %s\\n\", p, uname);\n\n\tuname = fdt_getprop(fit, noffset, FIT_FIRMWARE_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Firmware:     %s\\n\", p, uname);\n\n\tfor (fdt_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_FDT_PROP,\n\t\t\t\t\tfdt_index, NULL), uname;\n\t     fdt_index++) {\n\t\tif (fdt_index == 0)\n\t\t\tprintf(\"%s  FDT:          \", p);\n\t\telse\n\t\t\tprintf(\"%s                \", p);\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\tuname = fdt_getprop(fit, noffset, FIT_FPGA_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  FPGA:         %s\\n\", p, uname);\n\n\t/* Print out all of the specified loadables */\n\tfor (loadables_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_LOADABLE_PROP,\n\t\t\t\t\tloadables_index, NULL), uname;\n\t     loadables_index++) {\n\t\tif (loadables_index == 0) {\n\t\t\tprintf(\"%s  Loadables:    \", p);\n\t\t} else {\n\t\t\tprintf(\"%s                \", p);\n\t\t}\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\t/* Process all hash subnodes of the component configuration node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component configuration node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_print_contents - prints out the contents of the FIT format image\n * @fit: pointer to the FIT format image header\n * @p: pointer to prefix string\n *\n * fit_print_contents() formats a multi line FIT image contents description.\n * The routine prints out FIT image properties (root node level) followed by\n * the details of each component image.\n *\n * returns:\n *     no returned results\n */\nvoid fit_print_contents(const void *fit)\n{\n\tchar *desc;\n\tchar *uname;\n\tint images_noffset;\n\tint confs_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\tint ret;\n\tconst char *p;\n\ttime_t timestamp;\n\n\t/* Indent string is defined in header image.h */\n\tp = IMAGE_INDENT_STRING;\n\n\t/* Root node properties */\n\tret = fit_get_desc(fit, 0, &desc);\n\tprintf(\"%sFIT description: \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%sCreated:         \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn;\n\t}\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"%s Image %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_image_print(fit, noffset, p);\n\t\t}\n\t}\n\n\t/* Find configurations parent node offset */\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't get configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn;\n\t}\n\n\t/* get default configuration unit name from default property */\n\tuname = (char *)fdt_getprop(fit, noffset, FIT_DEFAULT_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s Default Configuration: '%s'\\n\", p, uname);\n\n\t/* Process its subnodes, print out configurations details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the configurations parent node,\n\t\t\t * i.e. configuration node.\n\t\t\t */\n\t\t\tprintf(\"%s Configuration %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_conf_print(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_image_print - prints out the FIT component image details\n * @fit: pointer to the FIT format image header\n * @image_noffset: offset of the component image node\n * @p: pointer to prefix string\n *\n * fit_image_print() lists all mandatory properties for the processed component\n * image. If present, hash nodes are printed out as well. Load\n * address for images of type firmware is also printed out. Since the load\n * address is not mandatory for firmware images, it will be output as\n * \"unavailable\" when not present.\n *\n * returns:\n *     no returned results\n */\nvoid fit_image_print(const void *fit, int image_noffset, const char *p)\n{\n\tchar *desc;\n\tuint8_t type, arch, os, comp;\n\tsize_t size;\n\tulong load, entry;\n\tconst void *data;\n\tint noffset;\n\tint ndepth;\n\tint ret;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, image_noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\ttime_t timestamp;\n\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%s  Created:      \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\tfit_image_get_type(fit, image_noffset, &type);\n\tprintf(\"%s  Type:         %s\\n\", p, genimg_get_type_name(type));\n\n\tfit_image_get_comp(fit, image_noffset, &comp);\n\tprintf(\"%s  Compression:  %s\\n\", p, genimg_get_comp_name(comp));\n\n\tret = fit_image_get_data_and_size(fit, image_noffset, &data, &size);\n\n\tif (!host_build()) {\n\t\tprintf(\"%s  Data Start:   \", p);\n\t\tif (ret) {\n\t\t\tprintf(\"unavailable\\n\");\n\t\t} else {\n\t\t\tvoid *vdata = (void *)data;\n\n\t\t\tprintf(\"0x%08lx\\n\", (ulong)map_to_sysmem(vdata));\n\t\t}\n\t}\n\n\tprintf(\"%s  Data Size:    \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tgenimg_print_size(size);\n\n\t/* Remaining, type dependent properties */\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||\n\t    (type == IH_TYPE_FLATDT)) {\n\t\tfit_image_get_arch(fit, image_noffset, &arch);\n\t\tprintf(\"%s  Architecture: %s\\n\", p, genimg_get_arch_name(arch));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FIRMWARE)) {\n\t\tfit_image_get_os(fit, image_noffset, &os);\n\t\tprintf(\"%s  OS:           %s\\n\", p, genimg_get_os_name(os));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_FIRMWARE) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FPGA)) {\n\t\tret = fit_image_get_load(fit, image_noffset, &load);\n\t\tprintf(\"%s  Load Address: \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", load);\n\t}\n\n\t/* optional load address for FDT */\n\tif (type == IH_TYPE_FLATDT && !fit_image_get_load(fit, image_noffset, &load))\n\t\tprintf(\"%s  Load Address: 0x%08lx\\n\", p, load);\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK)) {\n\t\tret = fit_image_get_entry(fit, image_noffset, &entry);\n\t\tprintf(\"%s  Entry Point:  \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", entry);\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, image_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component image node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n#else\nvoid fit_print_contents(const void *fit) { }\nvoid fit_image_print(const void *fit, int image_noffset, const char *p) { }\n#endif /* CONFIG_IS_ENABLED(FIR_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT) */\n\n/**\n * fit_get_desc - get node description property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @desc: double pointer to the char, will hold pointer to the description\n *\n * fit_get_desc() reads description property from a given node, if\n * description is found pointer to it is returned in third call argument.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_get_desc(const void *fit, int noffset, char **desc)\n{\n\tint len;\n\n\t*desc = (char *)fdt_getprop(fit, noffset, FIT_DESC_PROP, &len);\n\tif (*desc == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DESC_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_get_timestamp - get node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: pointer to the time_t, will hold read timestamp\n *\n * fit_get_timestamp() reads timestamp property from given node, if timestamp\n * is found and has a correct size its value is returned in third call\n * argument.\n *\n * returns:\n *     0, on success\n *     -1, on property read failure\n *     -2, on wrong timestamp size\n */\nint fit_get_timestamp(const void *fit, int noffset, time_t *timestamp)\n{\n\tint len;\n\tconst void *data;\n\n\tdata = fdt_getprop(fit, noffset, FIT_TIMESTAMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TIMESTAMP_PROP, len);\n\t\treturn -1;\n\t}\n\tif (len != sizeof(uint32_t)) {\n\t\tdebug(\"FIT timestamp with incorrect size of (%u)\\n\", len);\n\t\treturn -2;\n\t}\n\n\t*timestamp = uimage_to_cpu(*((uint32_t *)data));\n\treturn 0;\n}\n\n/**\n * fit_image_get_node - get node offset for component image of a given unit name\n * @fit: pointer to the FIT format image header\n * @image_uname: component image node unit name\n *\n * fit_image_get_node() finds a component image (within the '/images'\n * node) of a provided unit name. If image is found its node offset is\n * returned to the caller.\n *\n * returns:\n *     image node offset when found (>=0)\n *     negative number on failure (FDT_ERR_* code)\n */\nint fit_image_get_node(const void *fit, const char *image_uname)\n{\n\tint noffset, images_noffset;\n\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tdebug(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t      FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn images_noffset;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, images_noffset, image_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for image unit name: '%s' (%s)\\n\",\n\t\t      image_uname, fdt_strerror(noffset));\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_image_get_os - get os id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: pointer to the uint8_t, will hold os numeric id\n *\n * fit_image_get_os() finds os property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_os(const void *fit, int noffset, uint8_t *os)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get OS name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_OS_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_OS_PROP, len);\n\t\t*os = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate OS name to id */\n\t*os = genimg_get_os_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_arch - get arch id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: pointer to the uint8_t, will hold arch numeric id\n *\n * fit_image_get_arch() finds arch property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_arch(const void *fit, int noffset, uint8_t *arch)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get architecture name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_ARCH_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ARCH_PROP, len);\n\t\t*arch = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate architecture name to id */\n\t*arch = genimg_get_arch_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_type - get type id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: pointer to the uint8_t, will hold type numeric id\n *\n * fit_image_get_type() finds type property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_type(const void *fit, int noffset, uint8_t *type)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get image type name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_TYPE_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TYPE_PROP, len);\n\t\t*type = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate image type name to id */\n\t*type = genimg_get_type_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_comp - get comp id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: pointer to the uint8_t, will hold comp numeric id\n *\n * fit_image_get_comp() finds comp property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get compression name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_COMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_COMP_PROP, len);\n\t\t*comp = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate compression name to id */\n\t*comp = genimg_get_comp_id(data);\n\treturn 0;\n}\n\nstatic int fit_image_get_address(const void *fit, int noffset, char *name,\n\t\t\t  ulong *load)\n{\n\tint len, cell_len;\n\tconst fdt32_t *cell;\n\tuint64_t load64 = 0;\n\n\tcell = fdt_getprop(fit, noffset, name, &len);\n\tif (cell == NULL) {\n\t\tfit_get_debug(fit, noffset, name, len);\n\t\treturn -1;\n\t}\n\n\tcell_len = len >> 2;\n\t/* Use load64 to avoid compiling warning for 32-bit target */\n\twhile (cell_len--) {\n\t\tload64 = (load64 << 32) | uimage_to_cpu(*cell);\n\t\tcell++;\n\t}\n\n\tif (len > sizeof(ulong) && (uint32_t)(load64 >> 32)) {\n\t\tprintf(\"Unsupported %s address size\\n\", name);\n\t\treturn -1;\n\t}\n\n\t*load = (ulong)load64;\n\n\treturn 0;\n}\n/**\n * fit_image_get_load() - get load addr property for given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @load: pointer to the uint32_t, will hold load address\n *\n * fit_image_get_load() finds load address property in a given component\n * image node. If the property is found, its value is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_load(const void *fit, int noffset, ulong *load)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_LOAD_PROP, load);\n}\n\n/**\n * fit_image_get_entry() - get entry point address property\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @entry: pointer to the uint32_t, will hold entry point address\n *\n * This gets the entry point address property for a given component image\n * node.\n *\n * fit_image_get_entry() finds entry point address property in a given\n * component image node.  If the property is found, its value is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_entry(const void *fit, int noffset, ulong *entry)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_ENTRY_PROP, entry);\n}\n\n/**\n * fit_image_get_data - get data property and its size for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data() finds data property in a given component image node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_data(const void *fit, int noffset,\n\t\tconst void **data, size_t *size)\n{\n\tint len;\n\n\t*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);\n\tif (*data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DATA_PROP, len);\n\t\t*size = 0;\n\t\treturn -1;\n\t}\n\n\t*size = len;\n\treturn 0;\n}\n\n/**\n * Get 'data-offset' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_offset: holds the data-offset property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_OFFSET_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_offset = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-position' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_position: holds the data-position property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_position(const void *fit, int noffset,\n\t\t\t\tint *data_position)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_position = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size(const void *fit, int noffset, int *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_SIZE_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size-unciphered' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size_unciphered(const void *fit, int noffset,\n\t\t\t\t       size_t *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, \"data-size-unciphered\", NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = (size_t)fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * fit_image_get_data_and_size - get data and its size including\n *\t\t\t\t both embedded and external data\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data_and_size() finds data and its size including\n * both embedded and external data. If the property is found\n * its data start address and size are returned to the caller.\n *\n * returns:\n *     0, on success\n *     otherwise, on failure\n */\nint fit_image_get_data_and_size(const void *fit, int noffset,\n\t\t\t\tconst void **data, size_t *size)\n{\n\tbool external_data = false;\n\tint offset;\n\tint len;\n\tint ret;\n\n\tif (!fit_image_get_data_position(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t} else if (!fit_image_get_data_offset(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t\t/*\n\t\t * For FIT with external data, figure out where\n\t\t * the external images start. This is the base\n\t\t * for the data-offset properties in each image.\n\t\t */\n\t\toffset += ((fdt_totalsize(fit) + 3) & ~3);\n\t}\n\n\tif (external_data) {\n\t\tdebug(\"External Data\\n\");\n\t\tret = fit_image_get_data_size(fit, noffset, &len);\n\t\tif (!ret) {\n\t\t\t*data = fit + offset;\n\t\t\t*size = len;\n\t\t}\n\t} else {\n\t\tret = fit_image_get_data(fit, noffset, data, size);\n\t}\n\n\treturn ret;\n}\n\n/**\n * fit_image_hash_get_algo - get hash algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.\n * If the property is found its data start address is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (*algo == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_value - get hash value and length\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @value: double pointer to uint8_t, will hold address of a hash value data\n * @value_len: pointer to an int, will hold hash data length\n *\n * fit_image_hash_get_value() finds hash value property in a given hash node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_value(const void *fit, int noffset, uint8_t **value,\n\t\t\t\tint *value_len)\n{\n\tint len;\n\n\t*value = (uint8_t *)fdt_getprop(fit, noffset, FIT_VALUE_PROP, &len);\n\tif (*value == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_VALUE_PROP, len);\n\t\t*value_len = 0;\n\t\treturn -1;\n\t}\n\n\t*value_len = len;\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_ignore - get hash ignore flag\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @ignore: pointer to an int, will hold hash ignore flag\n *\n * fit_image_hash_get_ignore() finds hash ignore property in a given hash node.\n * If the property is found and non-zero, the hash algorithm is not verified by\n * u-boot automatically.\n *\n * returns:\n *     0, on ignore not found\n *     value, on ignore found\n */\nstatic int fit_image_hash_get_ignore(const void *fit, int noffset, int *ignore)\n{\n\tint len;\n\tint *value;\n\n\tvalue = (int *)fdt_getprop(fit, noffset, FIT_IGNORE_PROP, &len);\n\tif (value == NULL || len != sizeof(int))\n\t\t*ignore = 0;\n\telse\n\t\t*ignore = *value;\n\n\treturn 0;\n}\n\n/**\n * fit_image_cipher_get_algo - get cipher algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: cipher node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_cipher_get_algo() finds cipher algorithm property in a given\n * cipher node. If the property is found its data start address is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_cipher_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (!*algo) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nulong fit_get_end(const void *fit)\n{\n\treturn map_to_sysmem((void *)(fit + fdt_totalsize(fit)));\n}\n\n/**\n * fit_set_timestamp - set node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: timestamp value to be set\n *\n * fit_set_timestamp() attempts to set timestamp property in the requested\n * node and returns operation status to the caller.\n *\n * returns:\n *     0, on success\n *     -ENOSPC if no space in device tree, -1 for other error\n */\nint fit_set_timestamp(void *fit, int noffset, time_t timestamp)\n{\n\tuint32_t t;\n\tint ret;\n\n\tt = cpu_to_uimage(timestamp);\n\tret = fdt_setprop(fit, noffset, FIT_TIMESTAMP_PROP, &t,\n\t\t\t\tsizeof(uint32_t));\n\tif (ret) {\n\t\tdebug(\"Can't set '%s' property for '%s' node (%s)\\n\",\n\t\t      FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL),\n\t\t      fdt_strerror(ret));\n\t\treturn ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * calculate_hash - calculate and return hash for provided input data\n * @data: pointer to the input data\n * @data_len: data length\n * @algo: requested hash algorithm\n * @value: pointer to the char, will hold hash value data (caller must\n * allocate enough free space)\n * value_len: length of the calculated hash\n *\n * calculate_hash() computes input data hash according to the requested\n * algorithm.\n * Resulting hash value is placed in caller provided 'value' buffer, length\n * of the calculated hash is returned via value_len pointer argument.\n *\n * returns:\n *     0, on success\n *    -1, when algo is unsupported\n */\nint calculate_hash(const void *data, int data_len, const char *algo,\n\t\t\tuint8_t *value, int *value_len)\n{\n\tif (IMAGE_ENABLE_CRC32 && strcmp(algo, \"crc32\") == 0) {\n\t\t*((uint32_t *)value) = crc32_wd(0, data, data_len,\n\t\t\t\t\t\t\tCHUNKSZ_CRC32);\n\t\t*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));\n\t\t*value_len = 4;\n\t} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, \"sha1\") == 0) {\n\t\tsha1_csum_wd((unsigned char *)data, data_len,\n\t\t\t     (unsigned char *)value, CHUNKSZ_SHA1);\n\t\t*value_len = 20;\n\t} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, \"sha256\") == 0) {\n\t\tsha256_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA256);\n\t\t*value_len = SHA256_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA384 && strcmp(algo, \"sha384\") == 0) {\n\t\tsha384_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA384);\n\t\t*value_len = SHA384_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA512 && strcmp(algo, \"sha512\") == 0) {\n\t\tsha512_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA512);\n\t\t*value_len = SHA512_SUM_LEN;\n\t} else if (IMAGE_ENABLE_MD5 && strcmp(algo, \"md5\") == 0) {\n\t\tmd5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);\n\t\t*value_len = 16;\n\t} else {\n\t\tdebug(\"Unsupported hash alogrithm\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int fit_image_check_hash(const void *fit, int noffset, const void *data,\n\t\t\t\tsize_t size, char **err_msgp)\n{\n\tuint8_t value[FIT_MAX_HASH_LEN];\n\tint value_len;\n\tchar *algo;\n\tuint8_t *fit_value;\n\tint fit_value_len;\n\tint ignore;\n\n\t*err_msgp = NULL;\n\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\t*err_msgp = \"Can't get hash algo property\";\n\t\treturn -1;\n\t}\n\tprintf(\"%s\", algo);\n\n\tif (IMAGE_ENABLE_IGNORE) {\n\t\tfit_image_hash_get_ignore(fit, noffset, &ignore);\n\t\tif (ignore) {\n\t\t\tprintf(\"-skipped \");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fit_image_hash_get_value(fit, noffset, &fit_value,\n\t\t\t\t     &fit_value_len)) {\n\t\t*err_msgp = \"Can't get hash value property\";\n\t\treturn -1;\n\t}\n\n\tif (calculate_hash(data, size, algo, value, &value_len)) {\n\t\t*err_msgp = \"Unsupported hash algorithm\";\n\t\treturn -1;\n\t}\n\n\tif (value_len != fit_value_len) {\n\t\t*err_msgp = \"Bad hash value len\";\n\t\treturn -1;\n\t} else if (memcmp(value, fit_value, value_len) != 0) {\n\t\t*err_msgp = \"Bad hash value\";\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint fit_image_verify_with_data(const void *fit, int image_noffset,\n\t\t\t       const void *data, size_t size)\n{\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tint verify_all = 1;\n\tint ret;\n\n\t/* Verify all required signatures */\n\tif (FIT_IMAGE_ENABLE_VERIFY &&\n\t    fit_image_verify_required_sigs(fit, image_noffset, data, size,\n\t\t\t\t\t   gd_fdt_blob(), &verify_all)) {\n\t\terr_msg = \"Unable to verify required signature\";\n\t\tgoto error;\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\n\t\t/*\n\t\t * Check subnode name, must be equal to \"hash\".\n\t\t * Multiple hash nodes require unique unit node\n\t\t * names, e.g. hash-1, hash-2, etc.\n\t\t */\n\t\tif (!strncmp(name, FIT_HASH_NODENAME,\n\t\t\t     strlen(FIT_HASH_NODENAME))) {\n\t\t\tif (fit_image_check_hash(fit, noffset, data, size,\n\t\t\t\t\t\t &err_msg))\n\t\t\t\tgoto error;\n\t\t\tputs(\"+ \");\n\t\t} else if (FIT_IMAGE_ENABLE_VERIFY && verify_all &&\n\t\t\t\t!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t\tsize, -1, &err_msg);\n\n\t\t\t/*\n\t\t\t * Show an indication on failure, but do not return\n\t\t\t * an error. Only keys marked 'required' can cause\n\t\t\t * an image validation failure. See the call to\n\t\t\t * fit_image_verify_required_sigs() above.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tputs(\"- \");\n\t\t\telse\n\t\t\t\tputs(\"+ \");\n\t\t}\n\t}\n\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\n\treturn 1;\n\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_image_verify - verify data integrity\n * @fit: pointer to the FIT format image header\n * @image_noffset: component image node offset\n *\n * fit_image_verify() goes over component image hash nodes,\n * re-calculates each data hash and compares with the value stored in hash\n * node.\n *\n * returns:\n *     1, if all hashes are valid\n *     0, otherwise (or on error)\n */\nint fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t */\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_all_image_verify - verify data integrity for all images\n * @fit: pointer to the FIT format image header\n *\n * fit_all_image_verify() goes over all images in the FIT and\n * for every images checks if all it's hashes are valid.\n *\n * returns:\n *     1, if all hashes of all images are valid\n *     0, otherwise (or on error)\n */\nint fit_all_image_verify(const void *fit)\n{\n\tint images_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count;\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn 0;\n\t}\n\n\t/* Process all image subnodes, check hashes for each */\n\tprintf(\"## Checking hash(es) for FIT Image at %08lx ...\\n\",\n\t       (ulong)fit);\n\tfor (ndepth = 0, count = 0,\n\t     noffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"   Hash(es) for Image %u (%s): \", count,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\t\t\tcount++;\n\n\t\t\tif (!fit_image_verify(fit, noffset))\n\t\t\t\treturn 0;\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int fit_image_uncipher(const void *fit, int image_noffset,\n\t\t\t      void **data, size_t *size)\n{\n\tint cipher_noffset, ret;\n\tvoid *dst;\n\tsize_t size_dst;\n\n\tcipher_noffset = fdt_subnode_offset(fit, image_noffset,\n\t\t\t\t\t    FIT_CIPHER_NODENAME);\n\tif (cipher_noffset < 0)\n\t\treturn 0;\n\n\tret = fit_image_decrypt_data(fit, image_noffset, cipher_noffset,\n\t\t\t\t     *data, *size, &dst, &size_dst);\n\tif (ret)\n\t\tgoto out;\n\n\t*data = dst;\n\t*size = size_dst;\n\n out:\n\treturn ret;\n}\n\n/**\n * fit_image_check_os - check whether image node is of a given os type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: requested image os\n *\n * fit_image_check_os() reads image os property and compares its numeric\n * id with the requested os. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given os type\n *     0 otherwise (or on error)\n */\nint fit_image_check_os(const void *fit, int noffset, uint8_t os)\n{\n\tuint8_t image_os;\n\n\tif (fit_image_get_os(fit, noffset, &image_os))\n\t\treturn 0;\n\treturn (os == image_os);\n}\n\n/**\n * fit_image_check_arch - check whether image node is of a given arch\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: requested imagearch\n *\n * fit_image_check_arch() reads image arch property and compares its numeric\n * id with the requested arch. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given arch\n *     0 otherwise (or on error)\n */\nint fit_image_check_arch(const void *fit, int noffset, uint8_t arch)\n{\n\tuint8_t image_arch;\n\tint aarch32_support = 0;\n\n\tif (IS_ENABLED(CONFIG_ARM64_SUPPORT_AARCH32))\n\t\taarch32_support = 1;\n\n\tif (fit_image_get_arch(fit, noffset, &image_arch))\n\t\treturn 0;\n\treturn (arch == image_arch) ||\n\t\t(arch == IH_ARCH_I386 && image_arch == IH_ARCH_X86_64) ||\n\t\t(arch == IH_ARCH_ARM64 && image_arch == IH_ARCH_ARM &&\n\t\t aarch32_support);\n}\n\n/**\n * fit_image_check_type - check whether image node is of a given type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: requested image type\n *\n * fit_image_check_type() reads image type property and compares its numeric\n * id with the requested type. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given type\n *     0 otherwise (or on error)\n */\nint fit_image_check_type(const void *fit, int noffset, uint8_t type)\n{\n\tuint8_t image_type;\n\n\tif (fit_image_get_type(fit, noffset, &image_type))\n\t\treturn 0;\n\treturn (type == image_type);\n}\n\n/**\n * fit_image_check_comp - check whether image node uses given compression\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: requested image compression type\n *\n * fit_image_check_comp() reads image compression property and compares its\n * numeric id with the requested compression type. Comparison result is\n * returned to the caller.\n *\n * returns:\n *     1 if image uses requested compression\n *     0 otherwise (or on error)\n */\nint fit_image_check_comp(const void *fit, int noffset, uint8_t comp)\n{\n\tuint8_t image_comp;\n\n\tif (fit_image_get_comp(fit, noffset, &image_comp))\n\t\treturn 0;\n\treturn (comp == image_comp);\n}\n\nint fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\n\t/* A FIT image must be a valid FDT */\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\t/*\n\t\t * If we are not given the size, make do wtih calculating it.\n\t\t * This is not as secure, so we should consider a flag to\n\t\t * control this.\n\t\t */\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* mandatory / node 'description' property */\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\t/* mandatory / node 'timestamp' property */\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t/* mandatory subimages parent '/images' node */\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_conf_find_compat\n * @fit: pointer to the FIT format image header\n * @fdt: pointer to the device tree to compare against\n *\n * fit_conf_find_compat() attempts to find the configuration whose fdt is the\n * most compatible with the passed in device tree.\n *\n * Example:\n *\n * / o image-tree\n *   |-o images\n *   | |-o fdt-1\n *   | |-o fdt-2\n *   |\n *   |-o configurations\n *     |-o config-1\n *     | |-fdt = fdt-1\n *     |\n *     |-o config-2\n *       |-fdt = fdt-2\n *\n * / o U-Boot fdt\n *   |-compatible = \"foo,bar\", \"bim,bam\"\n *\n * / o kernel fdt1\n *   |-compatible = \"foo,bar\",\n *\n * / o kernel fdt2\n *   |-compatible = \"bim,bam\", \"baz,biz\"\n *\n * Configuration 1 would be picked because the first string in U-Boot's\n * compatible list, \"foo,bar\", matches a compatible string in the root of fdt1.\n * \"bim,bam\" in fdt2 matches the second string which isn't as good as fdt1.\n *\n * As an optimization, the compatible property from the FDT's root node can be\n * copied into the configuration node in the FIT image. This is required to\n * match configurations with compressed FDTs.\n *\n * returns:\n *     offset to the configuration to use if one was found\n *     -1 otherwise\n */\nint fit_conf_find_compat(const void *fit, const void *fdt)\n{\n\tint ndepth = 0;\n\tint noffset, confs_noffset, images_noffset;\n\tconst void *fdt_compat;\n\tint fdt_compat_len;\n\tint best_match_offset = 0;\n\tint best_match_pos = 0;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (confs_noffset < 0 || images_noffset < 0) {\n\t\tdebug(\"Can't find configurations or images nodes.\\n\");\n\t\treturn -1;\n\t}\n\n\tfdt_compat = fdt_getprop(fdt, 0, \"compatible\", &fdt_compat_len);\n\tif (!fdt_compat) {\n\t\tdebug(\"Fdt for comparison has no \\\"compatible\\\" property.\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Loop over the configurations in the FIT image.\n\t */\n\tfor (noffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tconst void *fdt;\n\t\tconst char *kfdt_name;\n\t\tint kfdt_noffset, compat_noffset;\n\t\tconst char *cur_fdt_compat;\n\t\tint len;\n\t\tsize_t sz;\n\t\tint i;\n\n\t\tif (ndepth > 1)\n\t\t\tcontinue;\n\n\t\t/* If there's a compat property in the config node, use that. */\n\t\tif (fdt_getprop(fit, noffset, \"compatible\", NULL)) {\n\t\t\tfdt = fit;\t\t  /* search in FIT image */\n\t\t\tcompat_noffset = noffset; /* search under config node */\n\t\t} else {\t/* Otherwise extract it from the kernel FDT. */\n\t\t\tkfdt_name = fdt_getprop(fit, noffset, \"fdt\", &len);\n\t\t\tif (!kfdt_name) {\n\t\t\t\tdebug(\"No fdt property found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkfdt_noffset = fdt_subnode_offset(fit, images_noffset,\n\t\t\t\t\t\t\t  kfdt_name);\n\t\t\tif (kfdt_noffset < 0) {\n\t\t\t\tdebug(\"No image node named \\\"%s\\\" found.\\n\",\n\t\t\t\t      kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fit_image_check_comp(fit, kfdt_noffset,\n\t\t\t\t\t\t  IH_COMP_NONE)) {\n\t\t\t\tdebug(\"Can't extract compat from \\\"%s\\\" \"\n\t\t\t\t      \"(compressed)\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* search in this config's kernel FDT */\n\t\t\tif (fit_image_get_data(fit, kfdt_noffset, &fdt, &sz)) {\n\t\t\t\tdebug(\"Failed to get fdt \\\"%s\\\".\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcompat_noffset = 0;  /* search kFDT under root node */\n\t\t}\n\n\t\tlen = fdt_compat_len;\n\t\tcur_fdt_compat = fdt_compat;\n\t\t/*\n\t\t * Look for a match for each U-Boot compatibility string in\n\t\t * turn in the compat string property.\n\t\t */\n\t\tfor (i = 0; len > 0 &&\n\t\t     (!best_match_offset || best_match_pos > i); i++) {\n\t\t\tint cur_len = strlen(cur_fdt_compat) + 1;\n\n\t\t\tif (!fdt_node_check_compatible(fdt, compat_noffset,\n\t\t\t\t\t\t       cur_fdt_compat)) {\n\t\t\t\tbest_match_offset = noffset;\n\t\t\t\tbest_match_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= cur_len;\n\t\t\tcur_fdt_compat += cur_len;\n\t\t}\n\t}\n\tif (!best_match_offset) {\n\t\tdebug(\"No match found.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn best_match_offset;\n}\n\nint fit_conf_get_node(const void *fit, const char *conf_uname)\n{\n\tint noffset, confs_noffset;\n\tint len;\n\tconst char *s;\n\tchar *conf_uname_copy = NULL;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't find configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn confs_noffset;\n\t}\n\n\tif (conf_uname == NULL) {\n\t\t/* get configuration unit name from the default property */\n\t\tdebug(\"No configuration specified, trying default...\\n\");\n\t\tif (!host_build() && IS_ENABLED(CONFIG_MULTI_DTB_FIT)) {\n\t\t\tnoffset = fit_find_config_node(fit);\n\t\t\tif (noffset < 0)\n\t\t\t\treturn noffset;\n\t\t\tconf_uname = fdt_get_name(fit, noffset, NULL);\n\t\t} else {\n\t\t\tconf_uname = (char *)fdt_getprop(fit, confs_noffset,\n\t\t\t\t\t\t\t FIT_DEFAULT_PROP, &len);\n\t\t\tif (conf_uname == NULL) {\n\t\t\t\tfit_get_debug(fit, confs_noffset, FIT_DEFAULT_PROP,\n\t\t\t\t\t      len);\n\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\t\tdebug(\"Found default configuration: '%s'\\n\", conf_uname);\n\t}\n\n\ts = strchr(conf_uname, '#');\n\tif (s) {\n\t\tlen = s - conf_uname;\n\t\tconf_uname_copy = malloc(len + 1);\n\t\tif (!conf_uname_copy) {\n\t\t\tdebug(\"Can't allocate uname copy: '%s'\\n\",\n\t\t\t\t\tconf_uname);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(conf_uname_copy, conf_uname, len);\n\t\tconf_uname_copy[len] = '\\0';\n\t\tconf_uname = conf_uname_copy;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, confs_noffset, conf_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for configuration unit name: '%s' (%s)\\n\",\n\t\t      conf_uname, fdt_strerror(noffset));\n\t}\n\n\tif (conf_uname_copy)\n\t\tfree(conf_uname_copy);\n\n\treturn noffset;\n}\n\nint fit_conf_get_prop_node_count(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fdt_stringlist_count(fit, noffset, prop_name);\n}\n\nint fit_conf_get_prop_node_index(const void *fit, int noffset,\n\t\tconst char *prop_name, int index)\n{\n\tconst char *uname;\n\tint len;\n\n\t/* get kernel image unit name from configuration kernel property */\n\tuname = fdt_stringlist_get(fit, noffset, prop_name, index, &len);\n\tif (uname == NULL)\n\t\treturn len;\n\n\treturn fit_image_get_node(fit, uname);\n}\n\nint fit_conf_get_prop_node(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fit_conf_get_prop_node_index(fit, noffset, prop_name, 0);\n}\n\nstatic int fit_image_select(const void *fit, int rd_noffset, int verify)\n{\n\tfit_image_print(fit, rd_noffset, \"   \");\n\n\tif (verify) {\n\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\tif (!fit_image_verify(fit, rd_noffset)) {\n\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\treturn 0;\n}\n\nint fit_get_node_from_config(bootm_headers_t *images, const char *prop_name,\n\t\t\tulong addr)\n{\n\tint cfg_noffset;\n\tvoid *fit_hdr;\n\tint noffset;\n\n\tdebug(\"*  %s: using config '%s' from image at 0x%08lx\\n\",\n\t      prop_name, images->fit_uname_cfg, addr);\n\n\t/* Check whether configuration has this property defined */\n\tfit_hdr = map_sysmem(addr, 0);\n\tcfg_noffset = fit_conf_get_node(fit_hdr, images->fit_uname_cfg);\n\tif (cfg_noffset < 0) {\n\t\tdebug(\"*  %s: no such config\\n\", prop_name);\n\t\treturn -EINVAL;\n\t}\n\n\tnoffset = fit_conf_get_prop_node(fit_hdr, cfg_noffset, prop_name);\n\tif (noffset < 0) {\n\t\tdebug(\"*  %s: no '%s' in config\\n\", prop_name, prop_name);\n\t\treturn -ENOENT;\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_get_image_type_property() - get property name for IH_TYPE_...\n *\n * @return the properly name where we expect to find the image in the\n * config node\n */\nstatic const char *fit_get_image_type_property(int type)\n{\n\t/*\n\t * This is sort-of available in the uimage_type[] table in image.c\n\t * but we don't have access to the short name, and \"fdt\" is different\n\t * anyway. So let's just keep it here.\n\t */\n\tswitch (type) {\n\tcase IH_TYPE_FLATDT:\n\t\treturn FIT_FDT_PROP;\n\tcase IH_TYPE_KERNEL:\n\t\treturn FIT_KERNEL_PROP;\n\tcase IH_TYPE_RAMDISK:\n\t\treturn FIT_RAMDISK_PROP;\n\tcase IH_TYPE_X86_SETUP:\n\t\treturn FIT_SETUP_PROP;\n\tcase IH_TYPE_LOADABLE:\n\t\treturn FIT_LOADABLE_PROP;\n\tcase IH_TYPE_FPGA:\n\t\treturn FIT_FPGA_PROP;\n\tcase IH_TYPE_STANDALONE:\n\t\treturn FIT_STANDALONE_PROP;\n\t}\n\n\treturn \"unknown\";\n}\n\nint fit_image_load(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, int image_type, int bootstage_id,\n\t\t   enum fit_load_op load_op, ulong *datap, ulong *lenp)\n{\n\tint cfg_noffset, noffset;\n\tconst char *fit_uname;\n\tconst char *fit_uname_config;\n\tconst char *fit_base_uname_config;\n\tconst void *fit;\n\tvoid *buf;\n\tvoid *loadbuf;\n\tsize_t size;\n\tint type_ok, os_ok;\n\tulong load, load_end, data, len;\n\tuint8_t os, comp;\n#ifndef USE_HOSTCC\n\tuint8_t os_arch;\n#endif\n\tconst char *prop_name;\n\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tif (fit_check_format(fit, IMAGE_SIZE_INVAL)) {\n\t\tprintf(\"Bad FIT %s image format!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn -ENOEXEC;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL\n\t\t * fit_conf_get_node() will try to find default config node\n\t\t */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\tif (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) {\n\t\t\tcfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob());\n\t\t} else {\n\t\t\tcfg_noffset = fit_conf_get_node(fit,\n\t\t\t\t\t\t\tfit_uname_config);\n\t\t}\n\t\tif (cfg_noffset < 0) {\n\t\t\tputs(\"Could not find configuration node\\n\");\n\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tfit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);\n\t\tprintf(\"   Using '%s' configuration\\n\", fit_base_uname_config);\n\t\t/* Remember this config */\n\t\tif (image_type == IH_TYPE_KERNEL)\n\t\t\timages->fit_uname_cfg = fit_base_uname_config;\n\n\t\tif (FIT_IMAGE_ENABLE_VERIFY && images->verify) {\n\t\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\t\tif (fit_config_verify(fit, cfg_noffset)) {\n\t\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_HASH);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tputs(\"OK\\n\");\n\t\t}\n\n\t\tbootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);\n\n\t\tnoffset = fit_conf_get_prop_node(fit, cfg_noffset,\n\t\t\t\t\t\t prop_name);\n\t\tfit_uname = fit_get_name(fit, noffset, NULL);\n\t}\n\tif (noffset < 0) {\n\t\tprintf(\"Could not find subimage node type '%s'\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);\n\t\treturn -ENOENT;\n\t}\n\n\tprintf(\"   Trying '%s' %s subimage\\n\", fit_uname, prop_name);\n\n\tret = fit_image_select(fit, noffset, images->verify);\n\tif (ret) {\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH);\n\t\treturn ret;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\tif (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) {\n\t\tif (!fit_image_check_target_arch(fit, noffset)) {\n\t\t\tputs(\"Unsupported Architecture\\n\");\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifndef USE_HOSTCC\n\tfit_image_get_arch(fit, noffset, &os_arch);\n\timages->os.arch = os_arch;\n#endif\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\ttype_ok = fit_image_check_type(fit, noffset, image_type) ||\n\t\t  fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) ||\n\t\t  (image_type == IH_TYPE_KERNEL &&\n\t\t   fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD));\n\n\tos_ok = image_type == IH_TYPE_FLATDT ||\n\t\timage_type == IH_TYPE_FPGA ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_LINUX) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_OPENRTOS) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_EFI) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_VXWORKS);\n\n\t/*\n\t * If either of the checks fail, we should report an error, but\n\t * if the image type is coming from the \"loadables\" field, we\n\t * don't care what it is\n\t */\n\tif ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) {\n\t\tfit_image_get_os(fit, noffset, &os);\n\t\tprintf(\"No %s %s %s Image\\n\",\n\t\t       genimg_get_os_name(os),\n\t\t       genimg_get_arch_name(arch),\n\t\t       genimg_get_type_name(image_type));\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\t\treturn -EIO;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK);\n\n\t/* get image data address and length */\n\tif (fit_image_get_data_and_size(fit, noffset,\n\t\t\t\t\t(const void **)&buf, &size)) {\n\t\tprintf(\"Could not find %s subimage data!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);\n\t\treturn -ENOENT;\n\t}\n\n\t/* Decrypt data before uncompress/move */\n\tif (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {\n\t\tputs(\"   Decrypting Data ... \");\n\t\tif (fit_image_uncipher(fit, noffset, &buf, &size)) {\n\t\t\tputs(\"Error\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\t/* perform any post-processing on the image data */\n\tif (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS))\n\t\tboard_fit_image_post_process(&buf, &size);\n\n\tlen = (ulong)size;\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK);\n\n\tdata = map_to_sysmem(buf);\n\tload = data;\n\tif (load_op == FIT_LOAD_IGNORED) {\n\t\t/* Don't load */\n\t} else if (fit_image_get_load(fit, noffset, &load)) {\n\t\tif (load_op == FIT_LOAD_REQUIRED) {\n\t\t\tprintf(\"Can't get %s subimage load address!\\n\",\n\t\t\t       prop_name);\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\t\t\treturn -EBADF;\n\t\t}\n\t} else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) {\n\t\tulong image_start, image_end;\n\n\t\t/*\n\t\t * move image data to the load address,\n\t\t * make sure we don't overwrite initial image\n\t\t */\n\t\timage_start = addr;\n\t\timage_end = addr + fit_get_size(fit);\n\n\t\tload_end = load + len;\n\t\tif (image_type != IH_TYPE_KERNEL &&\n\t\t    load < image_end && load_end > image_start) {\n\t\t\tprintf(\"Error: %s overwritten\\n\", prop_name);\n\t\t\treturn -EXDEV;\n\t\t}\n\n\t\tprintf(\"   Loading %s from 0x%08lx to 0x%08lx\\n\",\n\t\t       prop_name, data, load);\n\t} else {\n\t\tload = data;\t/* No load address specified */\n\t}\n\n\tcomp = IH_COMP_NONE;\n\tloadbuf = buf;\n\t/* Kernel images get decompressed later in bootm_load_os(). */\n\tif (!fit_image_get_comp(fit, noffset, &comp) &&\n\t    comp != IH_COMP_NONE &&\n\t    !(image_type == IH_TYPE_KERNEL ||\n\t      image_type == IH_TYPE_KERNEL_NOLOAD ||\n\t      image_type == IH_TYPE_RAMDISK)) {\n\t\tulong max_decomp_len = len * 20;\n\t\tif (load == data) {\n\t\t\tloadbuf = malloc(max_decomp_len);\n\t\t\tload = map_to_sysmem(loadbuf);\n\t\t} else {\n\t\t\tloadbuf = map_sysmem(load, max_decomp_len);\n\t\t}\n\t\tif (image_decomp(comp, load, data, image_type,\n\t\t\t\tloadbuf, buf, len, max_decomp_len, &load_end)) {\n\t\t\tprintf(\"Error decompressing %s\\n\", prop_name);\n\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t\tlen = load_end - load;\n\t} else if (load != data) {\n\t\tloadbuf = map_sysmem(load, len);\n\t\tmemcpy(loadbuf, buf, len);\n\t}\n\n\tif (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE)\n\t\tputs(\"WARNING: 'compression' nodes for ramdisks are deprecated,\"\n\t\t     \" please fix your .its file!\\n\");\n\n\t/* verify that image data is a proper FDT blob */\n\tif (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) {\n\t\tputs(\"Subimage data is not a FDT\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\n\t*datap = load;\n\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = (char *)fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = (char *)(fit_uname_config ? :\n\t\t\t\t\t      fit_base_uname_config);\n\n\treturn noffset;\n}\n\nint boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,\n\t\t\tulong *setup_start, ulong *setup_len)\n{\n\tint noffset;\n\tulong addr;\n\tulong len;\n\tint ret;\n\n\taddr = map_to_sysmem(images->fit_hdr_os);\n\tnoffset = fit_get_node_from_config(images, FIT_SETUP_PROP, addr);\n\tif (noffset < 0)\n\t\treturn noffset;\n\n\tret = fit_image_load(images, addr, NULL, NULL, arch,\n\t\t\t     IH_TYPE_X86_SETUP, BOOTSTAGE_ID_FIT_SETUP_START,\n\t\t\t     FIT_LOAD_REQUIRED, setup_start, &len);\n\n\treturn ret;\n}\n\n#ifndef USE_HOSTCC\nint boot_get_fdt_fit(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, ulong *datap, ulong *lenp)\n{\n\tint fdt_noffset, cfg_noffset, count;\n\tconst void *fit;\n\tconst char *fit_uname = NULL;\n\tconst char *fit_uname_config = NULL;\n\tchar *fit_uname_config_copy = NULL;\n\tchar *next_config = NULL;\n\tulong load, len;\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\tulong image_start, image_end;\n\tulong ovload, ovlen;\n\tconst char *uconfig;\n\tconst char *uname;\n\tvoid *base, *ov;\n\tint i, err, noffset, ov_noffset;\n#endif\n\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\n\tif (fit_uname_configp && *fit_uname_configp) {\n\t\tfit_uname_config_copy = strdup(*fit_uname_configp);\n\t\tif (!fit_uname_config_copy)\n\t\t\treturn -ENOMEM;\n\n\t\tnext_config = strchr(fit_uname_config_copy, '#');\n\t\tif (next_config)\n\t\t\t*next_config++ = '\\0';\n\t\tif (next_config - 1 > fit_uname_config_copy)\n\t\t\tfit_uname_config = fit_uname_config_copy;\n\t}\n\n\tfdt_noffset = fit_image_load(images,\n\t\taddr, &fit_uname, &fit_uname_config,\n\t\tarch, IH_TYPE_FLATDT,\n\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\tFIT_LOAD_OPTIONAL, &load, &len);\n\n\tif (fdt_noffset < 0)\n\t\tgoto out;\n\n\tdebug(\"fit_uname=%s, fit_uname_config=%s\\n\",\n\t\t\tfit_uname ? fit_uname : \"<NULL>\",\n\t\t\tfit_uname_config ? fit_uname_config : \"<NULL>\");\n\n\tfit = map_sysmem(addr, 0);\n\n\tcfg_noffset = fit_conf_get_node(fit, fit_uname_config);\n\n\t/* single blob, or error just return as well */\n\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset, FIT_FDT_PROP);\n\tif (count <= 1 && !next_config)\n\t\tgoto out;\n\n\t/* we need to apply overlays */\n\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\timage_start = addr;\n\timage_end = addr + fit_get_size(fit);\n\t/* verify that relocation took place by load address not being in fit */\n\tif (load >= image_start && load < image_end) {\n\t\t/* check is simplified; fit load checks for overlaps */\n\t\tprintf(\"Overlayed FDT requires relocation\\n\");\n\t\tfdt_noffset = -EBADF;\n\t\tgoto out;\n\t}\n\n\tbase = map_sysmem(load, len);\n\n\t/* apply extra configs in FIT first, followed by args */\n\tfor (i = 1; ; i++) {\n\t\tif (i < count) {\n\t\t\tnoffset = fit_conf_get_prop_node_index(fit, cfg_noffset,\n\t\t\t\t\t\t\t       FIT_FDT_PROP, i);\n\t\t\tuname = fit_get_name(fit, noffset, NULL);\n\t\t\tuconfig = NULL;\n\t\t} else {\n\t\t\tif (!next_config)\n\t\t\t\tbreak;\n\t\t\tuconfig = next_config;\n\t\t\tnext_config = strchr(next_config, '#');\n\t\t\tif (next_config)\n\t\t\t\t*next_config++ = '\\0';\n\t\t\tuname = NULL;\n\n\t\t\t/*\n\t\t\t * fit_image_load() would load the first FDT from the\n\t\t\t * extra config only when uconfig is specified.\n\t\t\t * Check if the extra config contains multiple FDTs and\n\t\t\t * if so, load them.\n\t\t\t */\n\t\t\tcfg_noffset = fit_conf_get_node(fit, uconfig);\n\n\t\t\ti = 0;\n\t\t\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset,\n\t\t\t\t\t\t\t     FIT_FDT_PROP);\n\t\t}\n\n\t\tdebug(\"%d: using uname=%s uconfig=%s\\n\", i, uname, uconfig);\n\n\t\tov_noffset = fit_image_load(images,\n\t\t\taddr, &uname, &uconfig,\n\t\t\tarch, IH_TYPE_FLATDT,\n\t\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\t\tFIT_LOAD_REQUIRED, &ovload, &ovlen);\n\t\tif (ov_noffset < 0) {\n\t\t\tprintf(\"load of %s failed\\n\", uname);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%s loaded at 0x%08lx len=0x%08lx\\n\",\n\t\t\t\tuname, ovload, ovlen);\n\t\tov = map_sysmem(ovload, ovlen);\n\n\t\tbase = map_sysmem(load, len + ovlen);\n\t\terr = fdt_open_into(base, base, len + ovlen);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed on fdt_open_into\\n\");\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\t/* the verbose method prints out messages on error */\n\t\terr = fdt_overlay_apply_verbose(base, ov);\n\t\tif (err < 0) {\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\tfdt_pack(base);\n\t\tlen = fdt_totalsize(base);\n\t}\n#else\n\tprintf(\"config with overlays but CONFIG_OF_LIBFDT_OVERLAY not set\\n\");\n\tfdt_noffset = -EBADF;\n#endif\n\nout:\n\tif (datap)\n\t\t*datap = load;\n\tif (lenp)\n\t\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = fit_uname_config;\n\n\tif (fit_uname_config_copy)\n\t\tfree(fit_uname_config_copy);\n\treturn fdt_noffset;\n}\n#endif\n", "# SPDX-License-Identifier:\tGPL-2.0+\n# Copyright (c) 2016, Google Inc.\n#\n# U-Boot Verified Boot Test\n\n\"\"\"\nThis tests verified boot in the following ways:\n\nFor image verification:\n- Create FIT (unsigned) with mkimage\n- Check that verification shows that no keys are verified\n- Sign image\n- Check that verification shows that a key is now verified\n\nFor configuration verification:\n- Corrupt signature and check for failure\n- Create FIT (with unsigned configuration) with mkimage\n- Check that image verification works\n- Sign the FIT and mark the key as 'required' for verification\n- Check that image verification works\n- Corrupt the signature\n- Check that image verification no-longer works\n\nTests run with both SHA1 and SHA256 hashing.\n\"\"\"\n\nimport shutil\nimport struct\nimport pytest\nimport u_boot_utils as util\nimport vboot_forge\nimport vboot_evil\n\n# Only run the full suite on a few combinations, since it doesn't add any more\n# test coverage.\nTESTDATA = [\n    ['sha1', '', None, False, True],\n    ['sha1', '', '-E -p 0x10000', False, False],\n    ['sha1', '-pss', None, False, False],\n    ['sha1', '-pss', '-E -p 0x10000', False, False],\n    ['sha256', '', None, False, False],\n    ['sha256', '', '-E -p 0x10000', False, False],\n    ['sha256', '-pss', None, False, False],\n    ['sha256', '-pss', '-E -p 0x10000', False, False],\n    ['sha256', '-pss', None, True, False],\n    ['sha256', '-pss', '-E -p 0x10000', True, True],\n]\n\n@pytest.mark.boardspec('sandbox')\n@pytest.mark.buildconfigspec('fit_signature')\n@pytest.mark.requiredtool('dtc')\n@pytest.mark.requiredtool('fdtget')\n@pytest.mark.requiredtool('fdtput')\n@pytest.mark.requiredtool('openssl')\n@pytest.mark.parametrize(\"sha_algo,padding,sign_options,required,full_test\",\n                         TESTDATA)\ndef test_vboot(u_boot_console, sha_algo, padding, sign_options, required,\n               full_test):\n    \"\"\"Test verified boot signing with mkimage and verification with 'bootm'.\n\n    This works using sandbox only as it needs to update the device tree used\n    by U-Boot to hold public keys from the signing process.\n\n    The SHA1 and SHA256 tests are combined into a single test since the\n    key-generation process is quite slow and we want to avoid doing it twice.\n    \"\"\"\n    def dtc(dts):\n        \"\"\"Run the device tree compiler to compile a .dts file\n\n        The output file will be the same as the input file but with a .dtb\n        extension.\n\n        Args:\n            dts: Device tree file to compile.\n        \"\"\"\n        dtb = dts.replace('.dts', '.dtb')\n        util.run_and_log(cons, 'dtc %s %s%s -O dtb '\n                         '-o %s%s' % (dtc_args, datadir, dts, tmpdir, dtb))\n\n    def run_bootm(sha_algo, test_type, expect_string, boots, fit=None):\n        \"\"\"Run a 'bootm' command U-Boot.\n\n        This always starts a fresh U-Boot instance since the device tree may\n        contain a new public key.\n\n        Args:\n            test_type: A string identifying the test type.\n            expect_string: A string which is expected in the output.\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            boots: A boolean that is True if Linux should boot and False if\n                    we are expected to not boot\n            fit: FIT filename to load and verify\n        \"\"\"\n        if not fit:\n            fit = '%stest.fit' % tmpdir\n        cons.restart_uboot()\n        with cons.log.section('Verified boot %s %s' % (sha_algo, test_type)):\n            output = cons.run_command_list(\n                ['host load hostfs - 100 %s' % fit,\n                 'fdt addr 100',\n                 'bootm 100'])\n        assert expect_string in ''.join(output)\n        if boots:\n            assert 'sandbox: continuing, as we cannot run' in ''.join(output)\n        else:\n            assert('sandbox: continuing, as we cannot run'\n                   not in ''.join(output))\n\n    def make_fit(its):\n        \"\"\"Make a new FIT from the .its source file.\n\n        This runs 'mkimage -f' to create a new FIT.\n\n        Args:\n            its: Filename containing .its source.\n        \"\"\"\n        util.run_and_log(cons, [mkimage, '-D', dtc_args, '-f',\n                                '%s%s' % (datadir, its), fit])\n\n    def sign_fit(sha_algo, options):\n        \"\"\"Sign the FIT\n\n        Signs the FIT and writes the signature into it. It also writes the\n        public key into the dtb.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            options: Options to provide to mkimage.\n        \"\"\"\n        args = [mkimage, '-F', '-k', tmpdir, '-K', dtb, '-r', fit]\n        if options:\n            args += options.split(' ')\n        cons.log.action('%s: Sign images' % sha_algo)\n        util.run_and_log(cons, args)\n\n    def sign_fit_norequire(sha_algo, options):\n        \"\"\"Sign the FIT\n\n        Signs the FIT and writes the signature into it. It also writes the\n        public key into the dtb. It does not mark key as 'required' in dtb.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            options: Options to provide to mkimage.\n        \"\"\"\n        args = [mkimage, '-F', '-k', tmpdir, '-K', dtb, fit]\n        if options:\n            args += options.split(' ')\n        cons.log.action('%s: Sign images' % sha_algo)\n        util.run_and_log(cons, args)\n\n    def replace_fit_totalsize(size):\n        \"\"\"Replace FIT header's totalsize with something greater.\n\n        The totalsize must be less than or equal to FIT_SIGNATURE_MAX_SIZE.\n        If the size is greater, the signature verification should return false.\n\n        Args:\n            size: The new totalsize of the header\n\n        Returns:\n            prev_size: The previous totalsize read from the header\n        \"\"\"\n        total_size = 0\n        with open(fit, 'r+b') as handle:\n            handle.seek(4)\n            total_size = handle.read(4)\n            handle.seek(4)\n            handle.write(struct.pack(\">I\", size))\n        return struct.unpack(\">I\", total_size)[0]\n\n    def create_rsa_pair(name):\n        \"\"\"Generate a new RSA key paid and certificate\n\n        Args:\n            name: Name of of the key (e.g. 'dev')\n        \"\"\"\n        public_exponent = 65537\n        util.run_and_log(cons, 'openssl genpkey -algorithm RSA -out %s%s.key '\n                     '-pkeyopt rsa_keygen_bits:2048 '\n                     '-pkeyopt rsa_keygen_pubexp:%d' %\n                     (tmpdir, name, public_exponent))\n\n        # Create a certificate containing the public key\n        util.run_and_log(cons, 'openssl req -batch -new -x509 -key %s%s.key '\n                         '-out %s%s.crt' % (tmpdir, name, tmpdir, name))\n\n    def test_with_algo(sha_algo, padding, sign_options):\n        \"\"\"Test verified boot with the given hash algorithm.\n\n        This is the main part of the test code. The same procedure is followed\n        for both hashing algorithms.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            padding: Either '' or '-pss', to select the padding to use for the\n                    rsa signature algorithm.\n            sign_options: Options to mkimage when signing a fit image.\n        \"\"\"\n        # Compile our device tree files for kernel and U-Boot. These are\n        # regenerated here since mkimage will modify them (by adding a\n        # public key) below.\n        dtc('sandbox-kernel.dts')\n        dtc('sandbox-u-boot.dts')\n\n        # Build the FIT, but don't sign anything yet\n        cons.log.action('%s: Test FIT with signed images' % sha_algo)\n        make_fit('sign-images-%s%s.its' % (sha_algo, padding))\n        run_bootm(sha_algo, 'unsigned images', 'dev-', True)\n\n        # Sign images with our dev keys\n        sign_fit(sha_algo, sign_options)\n        run_bootm(sha_algo, 'signed images', 'dev+', True)\n\n        # Create a fresh .dtb without the public keys\n        dtc('sandbox-u-boot.dts')\n\n        cons.log.action('%s: Test FIT with signed configuration' % sha_algo)\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        run_bootm(sha_algo, 'unsigned config', '%s+ OK' % sha_algo, True)\n\n        # Sign images with our dev keys\n        sign_fit(sha_algo, sign_options)\n        run_bootm(sha_algo, 'signed config', 'dev+', True)\n\n        cons.log.action('%s: Check signed config on the host' % sha_algo)\n\n        util.run_and_log(cons, [fit_check_sign, '-f', fit, '-k', dtb])\n\n        if full_test:\n            # Make sure that U-Boot checks that the config is in the list of hashed\n            # nodes. If it isn't, a security bypass is possible.\n            ffit = '%stest.forged.fit' % tmpdir\n            shutil.copyfile(fit, ffit)\n            with open(ffit, 'rb') as fd:\n                root, strblock = vboot_forge.read_fdt(fd)\n            root, strblock = vboot_forge.manipulate(root, strblock)\n            with open(ffit, 'w+b') as fd:\n                vboot_forge.write_fdt(root, strblock, fd)\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', ffit, '-k', dtb],\n                1, 'Failed to verify required signature')\n\n            run_bootm(sha_algo, 'forged config', 'Bad Data Hash', False, ffit)\n\n            # Try adding an evil root node. This should be detected.\n            efit = '%stest.evilf.fit' % tmpdir\n            shutil.copyfile(fit, efit)\n            vboot_evil.add_evil_node(fit, efit, evil_kernel, 'fakeroot')\n\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', efit, '-k', dtb],\n                1, 'Failed to verify required signature')\n            run_bootm(sha_algo, 'evil fakeroot', 'Bad FIT kernel image format',\n                      False, efit)\n\n            # Try adding an @ to the kernel node name. This should be detected.\n            efit = '%stest.evilk.fit' % tmpdir\n            shutil.copyfile(fit, efit)\n            vboot_evil.add_evil_node(fit, efit, evil_kernel, 'kernel@')\n\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', efit, '-k', dtb],\n                1, 'Node name contains @')\n            run_bootm(sha_algo, 'evil kernel@', 'Bad Data Hash', False, efit)\n\n        # Create a new properly signed fit and replace header bytes\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n        bcfg = u_boot_console.config.buildconfig\n        max_size = int(bcfg.get('config_fit_signature_max_size', 0x10000000), 0)\n        existing_size = replace_fit_totalsize(max_size + 1)\n        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash',\n                  False)\n        cons.log.action('%s: Check overflowed FIT header totalsize' % sha_algo)\n\n        # Replace with existing header bytes\n        replace_fit_totalsize(existing_size)\n        run_bootm(sha_algo, 'signed config', 'dev+', True)\n        cons.log.action('%s: Check default FIT header totalsize' % sha_algo)\n\n        # Increment the first byte of the signature, which should cause failure\n        sig = util.run_and_log(cons, 'fdtget -t bx %s %s value' %\n                               (fit, sig_node))\n        byte_list = sig.split()\n        byte = int(byte_list[0], 16)\n        byte_list[0] = '%x' % (byte + 1)\n        sig = ' '.join(byte_list)\n        util.run_and_log(cons, 'fdtput -t bx %s %s value %s' %\n                         (fit, sig_node, sig))\n\n        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash',\n                  False)\n\n        cons.log.action('%s: Check bad config on the host' % sha_algo)\n        util.run_and_log_expect_exception(\n            cons, [fit_check_sign, '-f', fit, '-k', dtb],\n            1, 'Failed to verify required signature')\n\n    def test_required_key(sha_algo, padding, sign_options):\n        \"\"\"Test verified boot with the given hash algorithm.\n\n        This function tests if U-Boot rejects an image when a required key isn't\n        used to sign a FIT.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to use\n            padding: Either '' or '-pss', to select the padding to use for the\n                    rsa signature algorithm.\n            sign_options: Options to mkimage when signing a fit image.\n        \"\"\"\n        # Compile our device tree files for kernel and U-Boot. These are\n        # regenerated here since mkimage will modify them (by adding a\n        # public key) below.\n        dtc('sandbox-kernel.dts')\n        dtc('sandbox-u-boot.dts')\n\n        cons.log.action('%s: Test FIT with configs images' % sha_algo)\n\n        # Build the FIT with prod key (keys required) and sign it. This puts the\n        # signature into sandbox-u-boot.dtb, marked 'required'\n        make_fit('sign-configs-%s%s-prod.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n\n        # Build the FIT with dev key (keys NOT required). This adds the\n        # signature into sandbox-u-boot.dtb, NOT marked 'required'.\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit_norequire(sha_algo, sign_options)\n\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Only the prod key is set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit_norequire() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should not be accepted by\n        # U-Boot because the prod key is required.\n        run_bootm(sha_algo, 'required key', '', False)\n\n        # Build the FIT with dev key (keys required) and sign it. This puts the\n        # signature into sandbox-u-boot.dtb, marked 'required'.\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n\n        # Set the required-mode policy to \"any\".\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Both the dev and prod key are set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should be accepted by\n        # U-Boot because the dev key is required and policy is \"any\" required key.\n        util.run_and_log(cons, 'fdtput -t s %s /signature required-mode any' %\n                         (dtb))\n        run_bootm(sha_algo, 'multi required key', 'dev+', True)\n\n        # Set the required-mode policy to \"all\".\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Both the dev and prod key are set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should not be accepted by\n        # U-Boot because the prod key is required and policy is \"all\" required key\n        util.run_and_log(cons, 'fdtput -t s %s /signature required-mode all' %\n                         (dtb))\n        run_bootm(sha_algo, 'multi required key', '', False)\n\n    cons = u_boot_console\n    tmpdir = cons.config.result_dir + '/'\n    datadir = cons.config.source_dir + '/test/py/tests/vboot/'\n    fit = '%stest.fit' % tmpdir\n    mkimage = cons.config.build_dir + '/tools/mkimage'\n    fit_check_sign = cons.config.build_dir + '/tools/fit_check_sign'\n    dtc_args = '-I dts -O dtb -i %s' % tmpdir\n    dtb = '%ssandbox-u-boot.dtb' % tmpdir\n    sig_node = '/configurations/conf-1/signature'\n\n    create_rsa_pair('dev')\n    create_rsa_pair('prod')\n\n    # Create a number kernel image with zeroes\n    with open('%stest-kernel.bin' % tmpdir, 'wb') as fd:\n        fd.write(500 * b'\\0')\n\n    # Create a second kernel image with ones\n    evil_kernel = '%stest-kernel1.bin' % tmpdir\n    with open(evil_kernel, 'wb') as fd:\n        fd.write(500 * b'\\x01')\n\n    try:\n        # We need to use our own device tree file. Remember to restore it\n        # afterwards.\n        old_dtb = cons.config.dtb\n        cons.config.dtb = dtb\n        if required:\n            test_required_key(sha_algo, padding, sign_options)\n        else:\n            test_with_algo(sha_algo, padding, sign_options)\n    finally:\n        # Go back to the original U-Boot with the correct dtb.\n        cons.config.dtb = old_dtb\n        cons.restart_uboot()\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * Copyright (c) 2013, Google Inc.\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2006\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n */\n\n#define LOG_CATEGORY LOGC_BOOT\n\n#ifdef USE_HOSTCC\n#include \"mkimage.h\"\n#include <time.h>\n#include <linux/libfdt.h>\n#include <u-boot/crc.h>\n#else\n#include <linux/compiler.h>\n#include <common.h>\n#include <errno.h>\n#include <log.h>\n#include <mapmem.h>\n#include <asm/io.h>\n#include <malloc.h>\n#include <asm/global_data.h>\nDECLARE_GLOBAL_DATA_PTR;\n#endif /* !USE_HOSTCC*/\n\n#include <bootm.h>\n#include <image.h>\n#include <bootstage.h>\n#include <linux/kconfig.h>\n#include <u-boot/crc.h>\n#include <u-boot/md5.h>\n#include <u-boot/sha1.h>\n#include <u-boot/sha256.h>\n#include <u-boot/sha512.h>\n\n/*****************************************************************************/\n/* New uImage format routines */\n/*****************************************************************************/\n#ifndef USE_HOSTCC\nstatic int fit_parse_spec(const char *spec, char sepc, ulong addr_curr,\n\t\tulong *addr, const char **name)\n{\n\tconst char *sep;\n\n\t*addr = addr_curr;\n\t*name = NULL;\n\n\tsep = strchr(spec, sepc);\n\tif (sep) {\n\t\tif (sep - spec > 0)\n\t\t\t*addr = simple_strtoul(spec, NULL, 16);\n\n\t\t*name = sep + 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_parse_conf - parse FIT configuration spec\n * @spec: input string, containing configuration spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * configuration\n * @conf_name double pointer to a char, will hold pointer to a configuration\n * unit name\n *\n * fit_parse_conf() expects configuration spec in the form of [<addr>]#<conf>,\n * where <addr> is a FIT image address that contains configuration\n * with a <conf> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid configuration string,\n *     addr and conf_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_conf(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **conf_name)\n{\n\treturn fit_parse_spec(spec, '#', addr_curr, addr, conf_name);\n}\n\n/**\n * fit_parse_subimage - parse FIT subimage spec\n * @spec: input string, containing subimage spec\n * @add_curr: current image address (to be used as a possible default)\n * @addr: pointer to a ulong variable, will hold FIT image address of a given\n * subimage\n * @image_name: double pointer to a char, will hold pointer to a subimage name\n *\n * fit_parse_subimage() expects subimage spec in the form of\n * [<addr>]:<subimage>, where <addr> is a FIT image address that contains\n * subimage with a <subimg> unit name.\n *\n * Address part is optional, and if omitted default add_curr will\n * be used instead.\n *\n * returns:\n *     1 if spec is a valid subimage string,\n *     addr and image_name are set accordingly\n *     0 otherwise\n */\nint fit_parse_subimage(const char *spec, ulong addr_curr,\n\t\tulong *addr, const char **image_name)\n{\n\treturn fit_parse_spec(spec, ':', addr_curr, addr, image_name);\n}\n#endif /* !USE_HOSTCC */\n\n#ifdef USE_HOSTCC\n/* Host tools use these implementations for Cipher and Signature support */\nstatic void *host_blob;\n\nvoid image_set_host_blob(void *blob)\n{\n\thost_blob = blob;\n}\n\nvoid *image_get_host_blob(void)\n{\n\treturn host_blob;\n}\n#endif /* USE_HOSTCC */\n\nstatic void fit_get_debug(const void *fit, int noffset,\n\t\tchar *prop_name, int err)\n{\n\tdebug(\"Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\\n\",\n\t      prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL),\n\t      fdt_strerror(err));\n}\n\n/**\n * fit_get_subimage_count - get component (sub-image) count\n * @fit: pointer to the FIT format image header\n * @images_noffset: offset of images node\n *\n * returns:\n *     number of image components\n */\nint fit_get_subimage_count(const void *fit, int images_noffset)\n{\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n#if CONFIG_IS_ENABLED(FIT_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT)\n/**\n * fit_image_print_data() - prints out the hash node details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash node\n * @p: pointer to prefix string\n * @type: Type of information to print (\"hash\" or \"sign\")\n *\n * fit_image_print_data() lists properties for the processed hash node\n *\n * This function avoid using puts() since it prints a newline on the host\n * but does not in U-Boot.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_data(const void *fit, int noffset, const char *p,\n\t\t\t\t const char *type)\n{\n\tconst char *keyname;\n\tuint8_t *value;\n\tint value_len;\n\tchar *algo;\n\tconst char *padding;\n\tbool required;\n\tint ret, i;\n\n\tdebug(\"%s  %s node:    '%s'\\n\", p, type,\n\t      fit_get_name(fit, noffset, NULL));\n\tprintf(\"%s  %s algo:    \", p, type);\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\tprintf(\"invalid/unsupported\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s\", algo);\n\tkeyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);\n\trequired = fdt_getprop(fit, noffset, FIT_KEY_REQUIRED, NULL) != NULL;\n\tif (keyname)\n\t\tprintf(\":%s\", keyname);\n\tif (required)\n\t\tprintf(\" (required)\");\n\tprintf(\"\\n\");\n\n\tpadding = fdt_getprop(fit, noffset, \"padding\", NULL);\n\tif (padding)\n\t\tprintf(\"%s  %s padding: %s\\n\", p, type, padding);\n\n\tret = fit_image_hash_get_value(fit, noffset, &value,\n\t\t\t\t       &value_len);\n\tprintf(\"%s  %s value:   \", p, type);\n\tif (ret) {\n\t\tprintf(\"unavailable\\n\");\n\t} else {\n\t\tfor (i = 0; i < value_len; i++)\n\t\t\tprintf(\"%02x\", value[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tdebug(\"%s  %s len:     %d\\n\", p, type, value_len);\n\n\t/* Signatures have a time stamp */\n\tif (IMAGE_ENABLE_TIMESTAMP && keyname) {\n\t\ttime_t timestamp;\n\n\t\tprintf(\"%s  Timestamp:    \", p);\n\t\tif (fit_get_timestamp(fit, noffset, &timestamp))\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n}\n\n/**\n * fit_image_print_verification_data() - prints out the hash/signature details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the hash or signature node\n * @p: pointer to prefix string\n *\n * This lists properties for the processed hash node\n *\n * returns:\n *     no returned results\n */\nstatic void fit_image_print_verification_data(const void *fit, int noffset,\n\t\t\t\t\t      const char *p)\n{\n\tconst char *name;\n\n\t/*\n\t * Check subnode name, must be equal to \"hash\" or \"signature\".\n\t * Multiple hash/signature nodes require unique unit node\n\t * names, e.g. hash-1, hash-2, signature-1, signature-2, etc.\n\t */\n\tname = fit_get_name(fit, noffset, NULL);\n\tif (!strncmp(name, FIT_HASH_NODENAME, strlen(FIT_HASH_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Hash\");\n\t} else if (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\tfit_image_print_data(fit, noffset, p, \"Sign\");\n\t}\n}\n\n/**\n * fit_conf_print - prints out the FIT configuration details\n * @fit: pointer to the FIT format image header\n * @noffset: offset of the configuration node\n * @p: pointer to prefix string\n *\n * fit_conf_print() lists all mandatory properties for the processed\n * configuration node.\n *\n * returns:\n *     no returned results\n */\nstatic void fit_conf_print(const void *fit, int noffset, const char *p)\n{\n\tchar *desc;\n\tconst char *uname;\n\tint ret;\n\tint fdt_index, loadables_index;\n\tint ndepth;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tuname = fdt_getprop(fit, noffset, FIT_KERNEL_PROP, NULL);\n\tprintf(\"%s  Kernel:       \", p);\n\tif (!uname)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", uname);\n\n\t/* Optional properties */\n\tuname = fdt_getprop(fit, noffset, FIT_RAMDISK_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Init Ramdisk: %s\\n\", p, uname);\n\n\tuname = fdt_getprop(fit, noffset, FIT_FIRMWARE_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  Firmware:     %s\\n\", p, uname);\n\n\tfor (fdt_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_FDT_PROP,\n\t\t\t\t\tfdt_index, NULL), uname;\n\t     fdt_index++) {\n\t\tif (fdt_index == 0)\n\t\t\tprintf(\"%s  FDT:          \", p);\n\t\telse\n\t\t\tprintf(\"%s                \", p);\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\tuname = fdt_getprop(fit, noffset, FIT_FPGA_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s  FPGA:         %s\\n\", p, uname);\n\n\t/* Print out all of the specified loadables */\n\tfor (loadables_index = 0;\n\t     uname = fdt_stringlist_get(fit, noffset, FIT_LOADABLE_PROP,\n\t\t\t\t\tloadables_index, NULL), uname;\n\t     loadables_index++) {\n\t\tif (loadables_index == 0) {\n\t\t\tprintf(\"%s  Loadables:    \", p);\n\t\t} else {\n\t\t\tprintf(\"%s                \", p);\n\t\t}\n\t\tprintf(\"%s\\n\", uname);\n\t}\n\n\t/* Process all hash subnodes of the component configuration node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component configuration node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_print_contents - prints out the contents of the FIT format image\n * @fit: pointer to the FIT format image header\n * @p: pointer to prefix string\n *\n * fit_print_contents() formats a multi line FIT image contents description.\n * The routine prints out FIT image properties (root node level) followed by\n * the details of each component image.\n *\n * returns:\n *     no returned results\n */\nvoid fit_print_contents(const void *fit)\n{\n\tchar *desc;\n\tchar *uname;\n\tint images_noffset;\n\tint confs_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count = 0;\n\tint ret;\n\tconst char *p;\n\ttime_t timestamp;\n\n\t/* Indent string is defined in header image.h */\n\tp = IMAGE_INDENT_STRING;\n\n\t/* Root node properties */\n\tret = fit_get_desc(fit, 0, &desc);\n\tprintf(\"%sFIT description: \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%sCreated:         \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn;\n\t}\n\n\t/* Process its subnodes, print out component images details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"%s Image %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_image_print(fit, noffset, p);\n\t\t}\n\t}\n\n\t/* Find configurations parent node offset */\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't get configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn;\n\t}\n\n\t/* get default configuration unit name from default property */\n\tuname = (char *)fdt_getprop(fit, noffset, FIT_DEFAULT_PROP, NULL);\n\tif (uname)\n\t\tprintf(\"%s Default Configuration: '%s'\\n\", p, uname);\n\n\t/* Process its subnodes, print out configurations details */\n\tfor (ndepth = 0, count = 0,\n\t\tnoffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the configurations parent node,\n\t\t\t * i.e. configuration node.\n\t\t\t */\n\t\t\tprintf(\"%s Configuration %u (%s)\\n\", p, count++,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\n\t\t\tfit_conf_print(fit, noffset, p);\n\t\t}\n\t}\n}\n\n/**\n * fit_image_print - prints out the FIT component image details\n * @fit: pointer to the FIT format image header\n * @image_noffset: offset of the component image node\n * @p: pointer to prefix string\n *\n * fit_image_print() lists all mandatory properties for the processed component\n * image. If present, hash nodes are printed out as well. Load\n * address for images of type firmware is also printed out. Since the load\n * address is not mandatory for firmware images, it will be output as\n * \"unavailable\" when not present.\n *\n * returns:\n *     no returned results\n */\nvoid fit_image_print(const void *fit, int image_noffset, const char *p)\n{\n\tchar *desc;\n\tuint8_t type, arch, os, comp;\n\tsize_t size;\n\tulong load, entry;\n\tconst void *data;\n\tint noffset;\n\tint ndepth;\n\tint ret;\n\n\t/* Mandatory properties */\n\tret = fit_get_desc(fit, image_noffset, &desc);\n\tprintf(\"%s  Description:  \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tprintf(\"%s\\n\", desc);\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\ttime_t timestamp;\n\n\t\tret = fit_get_timestamp(fit, 0, &timestamp);\n\t\tprintf(\"%s  Created:      \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tgenimg_print_time(timestamp);\n\t}\n\n\tfit_image_get_type(fit, image_noffset, &type);\n\tprintf(\"%s  Type:         %s\\n\", p, genimg_get_type_name(type));\n\n\tfit_image_get_comp(fit, image_noffset, &comp);\n\tprintf(\"%s  Compression:  %s\\n\", p, genimg_get_comp_name(comp));\n\n\tret = fit_image_get_data_and_size(fit, image_noffset, &data, &size);\n\n\tif (!host_build()) {\n\t\tprintf(\"%s  Data Start:   \", p);\n\t\tif (ret) {\n\t\t\tprintf(\"unavailable\\n\");\n\t\t} else {\n\t\t\tvoid *vdata = (void *)data;\n\n\t\t\tprintf(\"0x%08lx\\n\", (ulong)map_to_sysmem(vdata));\n\t\t}\n\t}\n\n\tprintf(\"%s  Data Size:    \", p);\n\tif (ret)\n\t\tprintf(\"unavailable\\n\");\n\telse\n\t\tgenimg_print_size(size);\n\n\t/* Remaining, type dependent properties */\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||\n\t    (type == IH_TYPE_FLATDT)) {\n\t\tfit_image_get_arch(fit, image_noffset, &arch);\n\t\tprintf(\"%s  Architecture: %s\\n\", p, genimg_get_arch_name(arch));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FIRMWARE)) {\n\t\tfit_image_get_os(fit, image_noffset, &os);\n\t\tprintf(\"%s  OS:           %s\\n\", p, genimg_get_os_name(os));\n\t}\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_FIRMWARE) || (type == IH_TYPE_RAMDISK) ||\n\t    (type == IH_TYPE_FPGA)) {\n\t\tret = fit_image_get_load(fit, image_noffset, &load);\n\t\tprintf(\"%s  Load Address: \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", load);\n\t}\n\n\t/* optional load address for FDT */\n\tif (type == IH_TYPE_FLATDT && !fit_image_get_load(fit, image_noffset, &load))\n\t\tprintf(\"%s  Load Address: 0x%08lx\\n\", p, load);\n\n\tif ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||\n\t    (type == IH_TYPE_RAMDISK)) {\n\t\tret = fit_image_get_entry(fit, image_noffset, &entry);\n\t\tprintf(\"%s  Entry Point:  \", p);\n\t\tif (ret)\n\t\t\tprintf(\"unavailable\\n\");\n\t\telse\n\t\t\tprintf(\"0x%08lx\\n\", entry);\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfor (ndepth = 0, noffset = fdt_next_node(fit, image_noffset, &ndepth);\n\t     (noffset >= 0) && (ndepth > 0);\n\t     noffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/* Direct child node of the component image node */\n\t\t\tfit_image_print_verification_data(fit, noffset, p);\n\t\t}\n\t}\n}\n#else\nvoid fit_print_contents(const void *fit) { }\nvoid fit_image_print(const void *fit, int image_noffset, const char *p) { }\n#endif /* CONFIG_IS_ENABLED(FIR_PRINT) || CONFIG_IS_ENABLED(SPL_FIT_PRINT) */\n\n/**\n * fit_get_desc - get node description property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @desc: double pointer to the char, will hold pointer to the description\n *\n * fit_get_desc() reads description property from a given node, if\n * description is found pointer to it is returned in third call argument.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_get_desc(const void *fit, int noffset, char **desc)\n{\n\tint len;\n\n\t*desc = (char *)fdt_getprop(fit, noffset, FIT_DESC_PROP, &len);\n\tif (*desc == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DESC_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_get_timestamp - get node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: pointer to the time_t, will hold read timestamp\n *\n * fit_get_timestamp() reads timestamp property from given node, if timestamp\n * is found and has a correct size its value is returned in third call\n * argument.\n *\n * returns:\n *     0, on success\n *     -1, on property read failure\n *     -2, on wrong timestamp size\n */\nint fit_get_timestamp(const void *fit, int noffset, time_t *timestamp)\n{\n\tint len;\n\tconst void *data;\n\n\tdata = fdt_getprop(fit, noffset, FIT_TIMESTAMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TIMESTAMP_PROP, len);\n\t\treturn -1;\n\t}\n\tif (len != sizeof(uint32_t)) {\n\t\tdebug(\"FIT timestamp with incorrect size of (%u)\\n\", len);\n\t\treturn -2;\n\t}\n\n\t*timestamp = uimage_to_cpu(*((uint32_t *)data));\n\treturn 0;\n}\n\n/**\n * fit_image_get_node - get node offset for component image of a given unit name\n * @fit: pointer to the FIT format image header\n * @image_uname: component image node unit name\n *\n * fit_image_get_node() finds a component image (within the '/images'\n * node) of a provided unit name. If image is found its node offset is\n * returned to the caller.\n *\n * returns:\n *     image node offset when found (>=0)\n *     negative number on failure (FDT_ERR_* code)\n */\nint fit_image_get_node(const void *fit, const char *image_uname)\n{\n\tint noffset, images_noffset;\n\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tdebug(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t      FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn images_noffset;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, images_noffset, image_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for image unit name: '%s' (%s)\\n\",\n\t\t      image_uname, fdt_strerror(noffset));\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_image_get_os - get os id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: pointer to the uint8_t, will hold os numeric id\n *\n * fit_image_get_os() finds os property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_os(const void *fit, int noffset, uint8_t *os)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get OS name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_OS_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_OS_PROP, len);\n\t\t*os = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate OS name to id */\n\t*os = genimg_get_os_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_arch - get arch id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: pointer to the uint8_t, will hold arch numeric id\n *\n * fit_image_get_arch() finds arch property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_arch(const void *fit, int noffset, uint8_t *arch)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get architecture name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_ARCH_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ARCH_PROP, len);\n\t\t*arch = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate architecture name to id */\n\t*arch = genimg_get_arch_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_type - get type id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: pointer to the uint8_t, will hold type numeric id\n *\n * fit_image_get_type() finds type property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_type(const void *fit, int noffset, uint8_t *type)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get image type name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_TYPE_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_TYPE_PROP, len);\n\t\t*type = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate image type name to id */\n\t*type = genimg_get_type_id(data);\n\treturn 0;\n}\n\n/**\n * fit_image_get_comp - get comp id for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: pointer to the uint8_t, will hold comp numeric id\n *\n * fit_image_get_comp() finds comp property in a given component image node.\n * If the property is found, its (string) value is translated to the numeric\n * id which is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)\n{\n\tint len;\n\tconst void *data;\n\n\t/* Get compression name from property data */\n\tdata = fdt_getprop(fit, noffset, FIT_COMP_PROP, &len);\n\tif (data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_COMP_PROP, len);\n\t\t*comp = -1;\n\t\treturn -1;\n\t}\n\n\t/* Translate compression name to id */\n\t*comp = genimg_get_comp_id(data);\n\treturn 0;\n}\n\nstatic int fit_image_get_address(const void *fit, int noffset, char *name,\n\t\t\t  ulong *load)\n{\n\tint len, cell_len;\n\tconst fdt32_t *cell;\n\tuint64_t load64 = 0;\n\n\tcell = fdt_getprop(fit, noffset, name, &len);\n\tif (cell == NULL) {\n\t\tfit_get_debug(fit, noffset, name, len);\n\t\treturn -1;\n\t}\n\n\tcell_len = len >> 2;\n\t/* Use load64 to avoid compiling warning for 32-bit target */\n\twhile (cell_len--) {\n\t\tload64 = (load64 << 32) | uimage_to_cpu(*cell);\n\t\tcell++;\n\t}\n\n\tif (len > sizeof(ulong) && (uint32_t)(load64 >> 32)) {\n\t\tprintf(\"Unsupported %s address size\\n\", name);\n\t\treturn -1;\n\t}\n\n\t*load = (ulong)load64;\n\n\treturn 0;\n}\n/**\n * fit_image_get_load() - get load addr property for given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @load: pointer to the uint32_t, will hold load address\n *\n * fit_image_get_load() finds load address property in a given component\n * image node. If the property is found, its value is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_load(const void *fit, int noffset, ulong *load)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_LOAD_PROP, load);\n}\n\n/**\n * fit_image_get_entry() - get entry point address property\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @entry: pointer to the uint32_t, will hold entry point address\n *\n * This gets the entry point address property for a given component image\n * node.\n *\n * fit_image_get_entry() finds entry point address property in a given\n * component image node.  If the property is found, its value is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_entry(const void *fit, int noffset, ulong *entry)\n{\n\treturn fit_image_get_address(fit, noffset, FIT_ENTRY_PROP, entry);\n}\n\n/**\n * fit_image_get_data - get data property and its size for a given component image node\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data() finds data property in a given component image node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_get_data(const void *fit, int noffset,\n\t\tconst void **data, size_t *size)\n{\n\tint len;\n\n\t*data = fdt_getprop(fit, noffset, FIT_DATA_PROP, &len);\n\tif (*data == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_DATA_PROP, len);\n\t\t*size = 0;\n\t\treturn -1;\n\t}\n\n\t*size = len;\n\treturn 0;\n}\n\n/**\n * Get 'data-offset' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_offset: holds the data-offset property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_offset(const void *fit, int noffset, int *data_offset)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_OFFSET_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_offset = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-position' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_position: holds the data-position property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_position(const void *fit, int noffset,\n\t\t\t\tint *data_position)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_POSITION_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_position = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size(const void *fit, int noffset, int *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, FIT_DATA_SIZE_PROP, NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * Get 'data-size-unciphered' property from a given image node.\n *\n * @fit: pointer to the FIT image header\n * @noffset: component image node offset\n * @data_size: holds the data-size property\n *\n * returns:\n *     0, on success\n *     -ENOENT if the property could not be found\n */\nint fit_image_get_data_size_unciphered(const void *fit, int noffset,\n\t\t\t\t       size_t *data_size)\n{\n\tconst fdt32_t *val;\n\n\tval = fdt_getprop(fit, noffset, \"data-size-unciphered\", NULL);\n\tif (!val)\n\t\treturn -ENOENT;\n\n\t*data_size = (size_t)fdt32_to_cpu(*val);\n\n\treturn 0;\n}\n\n/**\n * fit_image_get_data_and_size - get data and its size including\n *\t\t\t\t both embedded and external data\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @data: double pointer to void, will hold data property's data address\n * @size: pointer to size_t, will hold data property's data size\n *\n * fit_image_get_data_and_size() finds data and its size including\n * both embedded and external data. If the property is found\n * its data start address and size are returned to the caller.\n *\n * returns:\n *     0, on success\n *     otherwise, on failure\n */\nint fit_image_get_data_and_size(const void *fit, int noffset,\n\t\t\t\tconst void **data, size_t *size)\n{\n\tbool external_data = false;\n\tint offset;\n\tint len;\n\tint ret;\n\n\tif (!fit_image_get_data_position(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t} else if (!fit_image_get_data_offset(fit, noffset, &offset)) {\n\t\texternal_data = true;\n\t\t/*\n\t\t * For FIT with external data, figure out where\n\t\t * the external images start. This is the base\n\t\t * for the data-offset properties in each image.\n\t\t */\n\t\toffset += ((fdt_totalsize(fit) + 3) & ~3);\n\t}\n\n\tif (external_data) {\n\t\tdebug(\"External Data\\n\");\n\t\tret = fit_image_get_data_size(fit, noffset, &len);\n\t\tif (!ret) {\n\t\t\t*data = fit + offset;\n\t\t\t*size = len;\n\t\t}\n\t} else {\n\t\tret = fit_image_get_data(fit, noffset, data, size);\n\t}\n\n\treturn ret;\n}\n\n/**\n * fit_image_hash_get_algo - get hash algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.\n * If the property is found its data start address is returned to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (*algo == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_value - get hash value and length\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @value: double pointer to uint8_t, will hold address of a hash value data\n * @value_len: pointer to an int, will hold hash data length\n *\n * fit_image_hash_get_value() finds hash value property in a given hash node.\n * If the property is found its data start address and size are returned to\n * the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_hash_get_value(const void *fit, int noffset, uint8_t **value,\n\t\t\t\tint *value_len)\n{\n\tint len;\n\n\t*value = (uint8_t *)fdt_getprop(fit, noffset, FIT_VALUE_PROP, &len);\n\tif (*value == NULL) {\n\t\tfit_get_debug(fit, noffset, FIT_VALUE_PROP, len);\n\t\t*value_len = 0;\n\t\treturn -1;\n\t}\n\n\t*value_len = len;\n\treturn 0;\n}\n\n/**\n * fit_image_hash_get_ignore - get hash ignore flag\n * @fit: pointer to the FIT format image header\n * @noffset: hash node offset\n * @ignore: pointer to an int, will hold hash ignore flag\n *\n * fit_image_hash_get_ignore() finds hash ignore property in a given hash node.\n * If the property is found and non-zero, the hash algorithm is not verified by\n * u-boot automatically.\n *\n * returns:\n *     0, on ignore not found\n *     value, on ignore found\n */\nstatic int fit_image_hash_get_ignore(const void *fit, int noffset, int *ignore)\n{\n\tint len;\n\tint *value;\n\n\tvalue = (int *)fdt_getprop(fit, noffset, FIT_IGNORE_PROP, &len);\n\tif (value == NULL || len != sizeof(int))\n\t\t*ignore = 0;\n\telse\n\t\t*ignore = *value;\n\n\treturn 0;\n}\n\n/**\n * fit_image_cipher_get_algo - get cipher algorithm name\n * @fit: pointer to the FIT format image header\n * @noffset: cipher node offset\n * @algo: double pointer to char, will hold pointer to the algorithm name\n *\n * fit_image_cipher_get_algo() finds cipher algorithm property in a given\n * cipher node. If the property is found its data start address is returned\n * to the caller.\n *\n * returns:\n *     0, on success\n *     -1, on failure\n */\nint fit_image_cipher_get_algo(const void *fit, int noffset, char **algo)\n{\n\tint len;\n\n\t*algo = (char *)fdt_getprop(fit, noffset, FIT_ALGO_PROP, &len);\n\tif (!*algo) {\n\t\tfit_get_debug(fit, noffset, FIT_ALGO_PROP, len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nulong fit_get_end(const void *fit)\n{\n\treturn map_to_sysmem((void *)(fit + fdt_totalsize(fit)));\n}\n\n/**\n * fit_set_timestamp - set node timestamp property\n * @fit: pointer to the FIT format image header\n * @noffset: node offset\n * @timestamp: timestamp value to be set\n *\n * fit_set_timestamp() attempts to set timestamp property in the requested\n * node and returns operation status to the caller.\n *\n * returns:\n *     0, on success\n *     -ENOSPC if no space in device tree, -1 for other error\n */\nint fit_set_timestamp(void *fit, int noffset, time_t timestamp)\n{\n\tuint32_t t;\n\tint ret;\n\n\tt = cpu_to_uimage(timestamp);\n\tret = fdt_setprop(fit, noffset, FIT_TIMESTAMP_PROP, &t,\n\t\t\t\tsizeof(uint32_t));\n\tif (ret) {\n\t\tdebug(\"Can't set '%s' property for '%s' node (%s)\\n\",\n\t\t      FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL),\n\t\t      fdt_strerror(ret));\n\t\treturn ret == -FDT_ERR_NOSPACE ? -ENOSPC : -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * calculate_hash - calculate and return hash for provided input data\n * @data: pointer to the input data\n * @data_len: data length\n * @algo: requested hash algorithm\n * @value: pointer to the char, will hold hash value data (caller must\n * allocate enough free space)\n * value_len: length of the calculated hash\n *\n * calculate_hash() computes input data hash according to the requested\n * algorithm.\n * Resulting hash value is placed in caller provided 'value' buffer, length\n * of the calculated hash is returned via value_len pointer argument.\n *\n * returns:\n *     0, on success\n *    -1, when algo is unsupported\n */\nint calculate_hash(const void *data, int data_len, const char *algo,\n\t\t\tuint8_t *value, int *value_len)\n{\n\tif (IMAGE_ENABLE_CRC32 && strcmp(algo, \"crc32\") == 0) {\n\t\t*((uint32_t *)value) = crc32_wd(0, data, data_len,\n\t\t\t\t\t\t\tCHUNKSZ_CRC32);\n\t\t*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));\n\t\t*value_len = 4;\n\t} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, \"sha1\") == 0) {\n\t\tsha1_csum_wd((unsigned char *)data, data_len,\n\t\t\t     (unsigned char *)value, CHUNKSZ_SHA1);\n\t\t*value_len = 20;\n\t} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, \"sha256\") == 0) {\n\t\tsha256_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA256);\n\t\t*value_len = SHA256_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA384 && strcmp(algo, \"sha384\") == 0) {\n\t\tsha384_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA384);\n\t\t*value_len = SHA384_SUM_LEN;\n\t} else if (IMAGE_ENABLE_SHA512 && strcmp(algo, \"sha512\") == 0) {\n\t\tsha512_csum_wd((unsigned char *)data, data_len,\n\t\t\t       (unsigned char *)value, CHUNKSZ_SHA512);\n\t\t*value_len = SHA512_SUM_LEN;\n\t} else if (IMAGE_ENABLE_MD5 && strcmp(algo, \"md5\") == 0) {\n\t\tmd5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);\n\t\t*value_len = 16;\n\t} else {\n\t\tdebug(\"Unsupported hash alogrithm\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int fit_image_check_hash(const void *fit, int noffset, const void *data,\n\t\t\t\tsize_t size, char **err_msgp)\n{\n\tuint8_t value[FIT_MAX_HASH_LEN];\n\tint value_len;\n\tchar *algo;\n\tuint8_t *fit_value;\n\tint fit_value_len;\n\tint ignore;\n\n\t*err_msgp = NULL;\n\n\tif (fit_image_hash_get_algo(fit, noffset, &algo)) {\n\t\t*err_msgp = \"Can't get hash algo property\";\n\t\treturn -1;\n\t}\n\tprintf(\"%s\", algo);\n\n\tif (IMAGE_ENABLE_IGNORE) {\n\t\tfit_image_hash_get_ignore(fit, noffset, &ignore);\n\t\tif (ignore) {\n\t\t\tprintf(\"-skipped \");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fit_image_hash_get_value(fit, noffset, &fit_value,\n\t\t\t\t     &fit_value_len)) {\n\t\t*err_msgp = \"Can't get hash value property\";\n\t\treturn -1;\n\t}\n\n\tif (calculate_hash(data, size, algo, value, &value_len)) {\n\t\t*err_msgp = \"Unsupported hash algorithm\";\n\t\treturn -1;\n\t}\n\n\tif (value_len != fit_value_len) {\n\t\t*err_msgp = \"Bad hash value len\";\n\t\treturn -1;\n\t} else if (memcmp(value, fit_value, value_len) != 0) {\n\t\t*err_msgp = \"Bad hash value\";\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint fit_image_verify_with_data(const void *fit, int image_noffset,\n\t\t\t       const void *data, size_t size)\n{\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tint verify_all = 1;\n\tint ret;\n\n\t/* Verify all required signatures */\n\tif (FIT_IMAGE_ENABLE_VERIFY &&\n\t    fit_image_verify_required_sigs(fit, image_noffset, data, size,\n\t\t\t\t\t   gd_fdt_blob(), &verify_all)) {\n\t\terr_msg = \"Unable to verify required signature\";\n\t\tgoto error;\n\t}\n\n\t/* Process all hash subnodes of the component image node */\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\n\t\t/*\n\t\t * Check subnode name, must be equal to \"hash\".\n\t\t * Multiple hash nodes require unique unit node\n\t\t * names, e.g. hash-1, hash-2, etc.\n\t\t */\n\t\tif (!strncmp(name, FIT_HASH_NODENAME,\n\t\t\t     strlen(FIT_HASH_NODENAME))) {\n\t\t\tif (fit_image_check_hash(fit, noffset, data, size,\n\t\t\t\t\t\t &err_msg))\n\t\t\t\tgoto error;\n\t\t\tputs(\"+ \");\n\t\t} else if (FIT_IMAGE_ENABLE_VERIFY && verify_all &&\n\t\t\t\t!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t\t\tstrlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t\tsize, -1, &err_msg);\n\n\t\t\t/*\n\t\t\t * Show an indication on failure, but do not return\n\t\t\t * an error. Only keys marked 'required' can cause\n\t\t\t * an image validation failure. See the call to\n\t\t\t * fit_image_verify_required_sigs() above.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tputs(\"- \");\n\t\t\telse\n\t\t\t\tputs(\"+ \");\n\t\t}\n\t}\n\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\n\treturn 1;\n\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_image_verify - verify data integrity\n * @fit: pointer to the FIT format image header\n * @image_noffset: component image node offset\n *\n * fit_image_verify() goes over component image hash nodes,\n * re-calculates each data hash and compares with the value stored in hash\n * node.\n *\n * returns:\n *     1, if all hashes are valid\n *     0, otherwise (or on error)\n */\nint fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t */\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}\n\n/**\n * fit_all_image_verify - verify data integrity for all images\n * @fit: pointer to the FIT format image header\n *\n * fit_all_image_verify() goes over all images in the FIT and\n * for every images checks if all it's hashes are valid.\n *\n * returns:\n *     1, if all hashes of all images are valid\n *     0, otherwise (or on error)\n */\nint fit_all_image_verify(const void *fit)\n{\n\tint images_noffset;\n\tint noffset;\n\tint ndepth;\n\tint count;\n\n\t/* Find images parent node offset */\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (images_noffset < 0) {\n\t\tprintf(\"Can't find images parent node '%s' (%s)\\n\",\n\t\t       FIT_IMAGES_PATH, fdt_strerror(images_noffset));\n\t\treturn 0;\n\t}\n\n\t/* Process all image subnodes, check hashes for each */\n\tprintf(\"## Checking hash(es) for FIT Image at %08lx ...\\n\",\n\t       (ulong)fit);\n\tfor (ndepth = 0, count = 0,\n\t     noffset = fdt_next_node(fit, images_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tif (ndepth == 1) {\n\t\t\t/*\n\t\t\t * Direct child node of the images parent node,\n\t\t\t * i.e. component image node.\n\t\t\t */\n\t\t\tprintf(\"   Hash(es) for Image %u (%s): \", count,\n\t\t\t       fit_get_name(fit, noffset, NULL));\n\t\t\tcount++;\n\n\t\t\tif (!fit_image_verify(fit, noffset))\n\t\t\t\treturn 0;\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int fit_image_uncipher(const void *fit, int image_noffset,\n\t\t\t      void **data, size_t *size)\n{\n\tint cipher_noffset, ret;\n\tvoid *dst;\n\tsize_t size_dst;\n\n\tcipher_noffset = fdt_subnode_offset(fit, image_noffset,\n\t\t\t\t\t    FIT_CIPHER_NODENAME);\n\tif (cipher_noffset < 0)\n\t\treturn 0;\n\n\tret = fit_image_decrypt_data(fit, image_noffset, cipher_noffset,\n\t\t\t\t     *data, *size, &dst, &size_dst);\n\tif (ret)\n\t\tgoto out;\n\n\t*data = dst;\n\t*size = size_dst;\n\n out:\n\treturn ret;\n}\n\n/**\n * fit_image_check_os - check whether image node is of a given os type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @os: requested image os\n *\n * fit_image_check_os() reads image os property and compares its numeric\n * id with the requested os. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given os type\n *     0 otherwise (or on error)\n */\nint fit_image_check_os(const void *fit, int noffset, uint8_t os)\n{\n\tuint8_t image_os;\n\n\tif (fit_image_get_os(fit, noffset, &image_os))\n\t\treturn 0;\n\treturn (os == image_os);\n}\n\n/**\n * fit_image_check_arch - check whether image node is of a given arch\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @arch: requested imagearch\n *\n * fit_image_check_arch() reads image arch property and compares its numeric\n * id with the requested arch. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given arch\n *     0 otherwise (or on error)\n */\nint fit_image_check_arch(const void *fit, int noffset, uint8_t arch)\n{\n\tuint8_t image_arch;\n\tint aarch32_support = 0;\n\n\tif (IS_ENABLED(CONFIG_ARM64_SUPPORT_AARCH32))\n\t\taarch32_support = 1;\n\n\tif (fit_image_get_arch(fit, noffset, &image_arch))\n\t\treturn 0;\n\treturn (arch == image_arch) ||\n\t\t(arch == IH_ARCH_I386 && image_arch == IH_ARCH_X86_64) ||\n\t\t(arch == IH_ARCH_ARM64 && image_arch == IH_ARCH_ARM &&\n\t\t aarch32_support);\n}\n\n/**\n * fit_image_check_type - check whether image node is of a given type\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @type: requested image type\n *\n * fit_image_check_type() reads image type property and compares its numeric\n * id with the requested type. Comparison result is returned to the caller.\n *\n * returns:\n *     1 if image is of given type\n *     0 otherwise (or on error)\n */\nint fit_image_check_type(const void *fit, int noffset, uint8_t type)\n{\n\tuint8_t image_type;\n\n\tif (fit_image_get_type(fit, noffset, &image_type))\n\t\treturn 0;\n\treturn (type == image_type);\n}\n\n/**\n * fit_image_check_comp - check whether image node uses given compression\n * @fit: pointer to the FIT format image header\n * @noffset: component image node offset\n * @comp: requested image compression type\n *\n * fit_image_check_comp() reads image compression property and compares its\n * numeric id with the requested compression type. Comparison result is\n * returned to the caller.\n *\n * returns:\n *     1 if image uses requested compression\n *     0 otherwise (or on error)\n */\nint fit_image_check_comp(const void *fit, int noffset, uint8_t comp)\n{\n\tuint8_t image_comp;\n\n\tif (fit_image_get_comp(fit, noffset, &image_comp))\n\t\treturn 0;\n\treturn (comp == image_comp);\n}\n\n/**\n * fdt_check_no_at() - Check for nodes whose names contain '@'\n *\n * This checks the parent node and all subnodes recursively\n *\n * @fit: FIT to check\n * @parent: Parent node to check\n * @return 0 if OK, -EADDRNOTAVAIL is a node has a name containing '@'\n */\nstatic int fdt_check_no_at(const void *fit, int parent)\n{\n\tconst char *name;\n\tint node;\n\tint ret;\n\n\tname = fdt_get_name(fit, parent, NULL);\n\tif (!name || strchr(name, '@'))\n\t\treturn -EADDRNOTAVAIL;\n\n\tfdt_for_each_subnode(node, fit, parent) {\n\t\tret = fdt_check_no_at(fit, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\n\t/* A FIT image must be a valid FDT */\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\t/*\n\t\t * If we are not given the size, make do wtih calculating it.\n\t\t * This is not as secure, so we should consider a flag to\n\t\t * control this.\n\t\t */\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\n\t\t/*\n\t\t * U-Boot stopped using unit addressed in 2017. Since libfdt\n\t\t * can match nodes ignoring any unit address, signature\n\t\t * verification can see the wrong node if one is inserted with\n\t\t * the same name as a valid node but with a unit address\n\t\t * attached. Protect against this by disallowing unit addresses.\n\t\t */\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* mandatory / node 'description' property */\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\t/* mandatory / node 'timestamp' property */\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t/* mandatory subimages parent '/images' node */\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n/**\n * fit_conf_find_compat\n * @fit: pointer to the FIT format image header\n * @fdt: pointer to the device tree to compare against\n *\n * fit_conf_find_compat() attempts to find the configuration whose fdt is the\n * most compatible with the passed in device tree.\n *\n * Example:\n *\n * / o image-tree\n *   |-o images\n *   | |-o fdt-1\n *   | |-o fdt-2\n *   |\n *   |-o configurations\n *     |-o config-1\n *     | |-fdt = fdt-1\n *     |\n *     |-o config-2\n *       |-fdt = fdt-2\n *\n * / o U-Boot fdt\n *   |-compatible = \"foo,bar\", \"bim,bam\"\n *\n * / o kernel fdt1\n *   |-compatible = \"foo,bar\",\n *\n * / o kernel fdt2\n *   |-compatible = \"bim,bam\", \"baz,biz\"\n *\n * Configuration 1 would be picked because the first string in U-Boot's\n * compatible list, \"foo,bar\", matches a compatible string in the root of fdt1.\n * \"bim,bam\" in fdt2 matches the second string which isn't as good as fdt1.\n *\n * As an optimization, the compatible property from the FDT's root node can be\n * copied into the configuration node in the FIT image. This is required to\n * match configurations with compressed FDTs.\n *\n * returns:\n *     offset to the configuration to use if one was found\n *     -1 otherwise\n */\nint fit_conf_find_compat(const void *fit, const void *fdt)\n{\n\tint ndepth = 0;\n\tint noffset, confs_noffset, images_noffset;\n\tconst void *fdt_compat;\n\tint fdt_compat_len;\n\tint best_match_offset = 0;\n\tint best_match_pos = 0;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\timages_noffset = fdt_path_offset(fit, FIT_IMAGES_PATH);\n\tif (confs_noffset < 0 || images_noffset < 0) {\n\t\tdebug(\"Can't find configurations or images nodes.\\n\");\n\t\treturn -1;\n\t}\n\n\tfdt_compat = fdt_getprop(fdt, 0, \"compatible\", &fdt_compat_len);\n\tif (!fdt_compat) {\n\t\tdebug(\"Fdt for comparison has no \\\"compatible\\\" property.\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Loop over the configurations in the FIT image.\n\t */\n\tfor (noffset = fdt_next_node(fit, confs_noffset, &ndepth);\n\t\t\t(noffset >= 0) && (ndepth > 0);\n\t\t\tnoffset = fdt_next_node(fit, noffset, &ndepth)) {\n\t\tconst void *fdt;\n\t\tconst char *kfdt_name;\n\t\tint kfdt_noffset, compat_noffset;\n\t\tconst char *cur_fdt_compat;\n\t\tint len;\n\t\tsize_t sz;\n\t\tint i;\n\n\t\tif (ndepth > 1)\n\t\t\tcontinue;\n\n\t\t/* If there's a compat property in the config node, use that. */\n\t\tif (fdt_getprop(fit, noffset, \"compatible\", NULL)) {\n\t\t\tfdt = fit;\t\t  /* search in FIT image */\n\t\t\tcompat_noffset = noffset; /* search under config node */\n\t\t} else {\t/* Otherwise extract it from the kernel FDT. */\n\t\t\tkfdt_name = fdt_getprop(fit, noffset, \"fdt\", &len);\n\t\t\tif (!kfdt_name) {\n\t\t\t\tdebug(\"No fdt property found.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkfdt_noffset = fdt_subnode_offset(fit, images_noffset,\n\t\t\t\t\t\t\t  kfdt_name);\n\t\t\tif (kfdt_noffset < 0) {\n\t\t\t\tdebug(\"No image node named \\\"%s\\\" found.\\n\",\n\t\t\t\t      kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fit_image_check_comp(fit, kfdt_noffset,\n\t\t\t\t\t\t  IH_COMP_NONE)) {\n\t\t\t\tdebug(\"Can't extract compat from \\\"%s\\\" \"\n\t\t\t\t      \"(compressed)\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* search in this config's kernel FDT */\n\t\t\tif (fit_image_get_data(fit, kfdt_noffset, &fdt, &sz)) {\n\t\t\t\tdebug(\"Failed to get fdt \\\"%s\\\".\\n\", kfdt_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcompat_noffset = 0;  /* search kFDT under root node */\n\t\t}\n\n\t\tlen = fdt_compat_len;\n\t\tcur_fdt_compat = fdt_compat;\n\t\t/*\n\t\t * Look for a match for each U-Boot compatibility string in\n\t\t * turn in the compat string property.\n\t\t */\n\t\tfor (i = 0; len > 0 &&\n\t\t     (!best_match_offset || best_match_pos > i); i++) {\n\t\t\tint cur_len = strlen(cur_fdt_compat) + 1;\n\n\t\t\tif (!fdt_node_check_compatible(fdt, compat_noffset,\n\t\t\t\t\t\t       cur_fdt_compat)) {\n\t\t\t\tbest_match_offset = noffset;\n\t\t\t\tbest_match_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= cur_len;\n\t\t\tcur_fdt_compat += cur_len;\n\t\t}\n\t}\n\tif (!best_match_offset) {\n\t\tdebug(\"No match found.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn best_match_offset;\n}\n\nint fit_conf_get_node(const void *fit, const char *conf_uname)\n{\n\tint noffset, confs_noffset;\n\tint len;\n\tconst char *s;\n\tchar *conf_uname_copy = NULL;\n\n\tconfs_noffset = fdt_path_offset(fit, FIT_CONFS_PATH);\n\tif (confs_noffset < 0) {\n\t\tdebug(\"Can't find configurations parent node '%s' (%s)\\n\",\n\t\t      FIT_CONFS_PATH, fdt_strerror(confs_noffset));\n\t\treturn confs_noffset;\n\t}\n\n\tif (conf_uname == NULL) {\n\t\t/* get configuration unit name from the default property */\n\t\tdebug(\"No configuration specified, trying default...\\n\");\n\t\tif (!host_build() && IS_ENABLED(CONFIG_MULTI_DTB_FIT)) {\n\t\t\tnoffset = fit_find_config_node(fit);\n\t\t\tif (noffset < 0)\n\t\t\t\treturn noffset;\n\t\t\tconf_uname = fdt_get_name(fit, noffset, NULL);\n\t\t} else {\n\t\t\tconf_uname = (char *)fdt_getprop(fit, confs_noffset,\n\t\t\t\t\t\t\t FIT_DEFAULT_PROP, &len);\n\t\t\tif (conf_uname == NULL) {\n\t\t\t\tfit_get_debug(fit, confs_noffset, FIT_DEFAULT_PROP,\n\t\t\t\t\t      len);\n\t\t\t\treturn len;\n\t\t\t}\n\t\t}\n\t\tdebug(\"Found default configuration: '%s'\\n\", conf_uname);\n\t}\n\n\ts = strchr(conf_uname, '#');\n\tif (s) {\n\t\tlen = s - conf_uname;\n\t\tconf_uname_copy = malloc(len + 1);\n\t\tif (!conf_uname_copy) {\n\t\t\tdebug(\"Can't allocate uname copy: '%s'\\n\",\n\t\t\t\t\tconf_uname);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(conf_uname_copy, conf_uname, len);\n\t\tconf_uname_copy[len] = '\\0';\n\t\tconf_uname = conf_uname_copy;\n\t}\n\n\tnoffset = fdt_subnode_offset(fit, confs_noffset, conf_uname);\n\tif (noffset < 0) {\n\t\tdebug(\"Can't get node offset for configuration unit name: '%s' (%s)\\n\",\n\t\t      conf_uname, fdt_strerror(noffset));\n\t}\n\n\tif (conf_uname_copy)\n\t\tfree(conf_uname_copy);\n\n\treturn noffset;\n}\n\nint fit_conf_get_prop_node_count(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fdt_stringlist_count(fit, noffset, prop_name);\n}\n\nint fit_conf_get_prop_node_index(const void *fit, int noffset,\n\t\tconst char *prop_name, int index)\n{\n\tconst char *uname;\n\tint len;\n\n\t/* get kernel image unit name from configuration kernel property */\n\tuname = fdt_stringlist_get(fit, noffset, prop_name, index, &len);\n\tif (uname == NULL)\n\t\treturn len;\n\n\treturn fit_image_get_node(fit, uname);\n}\n\nint fit_conf_get_prop_node(const void *fit, int noffset,\n\t\tconst char *prop_name)\n{\n\treturn fit_conf_get_prop_node_index(fit, noffset, prop_name, 0);\n}\n\nstatic int fit_image_select(const void *fit, int rd_noffset, int verify)\n{\n\tfit_image_print(fit, rd_noffset, \"   \");\n\n\tif (verify) {\n\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\tif (!fit_image_verify(fit, rd_noffset)) {\n\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\treturn 0;\n}\n\nint fit_get_node_from_config(bootm_headers_t *images, const char *prop_name,\n\t\t\tulong addr)\n{\n\tint cfg_noffset;\n\tvoid *fit_hdr;\n\tint noffset;\n\n\tdebug(\"*  %s: using config '%s' from image at 0x%08lx\\n\",\n\t      prop_name, images->fit_uname_cfg, addr);\n\n\t/* Check whether configuration has this property defined */\n\tfit_hdr = map_sysmem(addr, 0);\n\tcfg_noffset = fit_conf_get_node(fit_hdr, images->fit_uname_cfg);\n\tif (cfg_noffset < 0) {\n\t\tdebug(\"*  %s: no such config\\n\", prop_name);\n\t\treturn -EINVAL;\n\t}\n\n\tnoffset = fit_conf_get_prop_node(fit_hdr, cfg_noffset, prop_name);\n\tif (noffset < 0) {\n\t\tdebug(\"*  %s: no '%s' in config\\n\", prop_name, prop_name);\n\t\treturn -ENOENT;\n\t}\n\n\treturn noffset;\n}\n\n/**\n * fit_get_image_type_property() - get property name for IH_TYPE_...\n *\n * @return the properly name where we expect to find the image in the\n * config node\n */\nstatic const char *fit_get_image_type_property(int type)\n{\n\t/*\n\t * This is sort-of available in the uimage_type[] table in image.c\n\t * but we don't have access to the short name, and \"fdt\" is different\n\t * anyway. So let's just keep it here.\n\t */\n\tswitch (type) {\n\tcase IH_TYPE_FLATDT:\n\t\treturn FIT_FDT_PROP;\n\tcase IH_TYPE_KERNEL:\n\t\treturn FIT_KERNEL_PROP;\n\tcase IH_TYPE_RAMDISK:\n\t\treturn FIT_RAMDISK_PROP;\n\tcase IH_TYPE_X86_SETUP:\n\t\treturn FIT_SETUP_PROP;\n\tcase IH_TYPE_LOADABLE:\n\t\treturn FIT_LOADABLE_PROP;\n\tcase IH_TYPE_FPGA:\n\t\treturn FIT_FPGA_PROP;\n\tcase IH_TYPE_STANDALONE:\n\t\treturn FIT_STANDALONE_PROP;\n\t}\n\n\treturn \"unknown\";\n}\n\nint fit_image_load(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, int image_type, int bootstage_id,\n\t\t   enum fit_load_op load_op, ulong *datap, ulong *lenp)\n{\n\tint cfg_noffset, noffset;\n\tconst char *fit_uname;\n\tconst char *fit_uname_config;\n\tconst char *fit_base_uname_config;\n\tconst void *fit;\n\tvoid *buf;\n\tvoid *loadbuf;\n\tsize_t size;\n\tint type_ok, os_ok;\n\tulong load, load_end, data, len;\n\tuint8_t os, comp;\n#ifndef USE_HOSTCC\n\tuint8_t os_arch;\n#endif\n\tconst char *prop_name;\n\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tret = fit_check_format(fit, IMAGE_SIZE_INVAL);\n\tif (ret) {\n\t\tprintf(\"Bad FIT %s image format! (err=%d)\\n\", prop_name, ret);\n\t\tif (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL)\n\t\t\tprintf(\"Signature checking prevents use of unit addresses (@) in nodes\\n\");\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn ret;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL\n\t\t * fit_conf_get_node() will try to find default config node\n\t\t */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\tif (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) {\n\t\t\tcfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob());\n\t\t} else {\n\t\t\tcfg_noffset = fit_conf_get_node(fit,\n\t\t\t\t\t\t\tfit_uname_config);\n\t\t}\n\t\tif (cfg_noffset < 0) {\n\t\t\tputs(\"Could not find configuration node\\n\");\n\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_NO_UNIT_NAME);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tfit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);\n\t\tprintf(\"   Using '%s' configuration\\n\", fit_base_uname_config);\n\t\t/* Remember this config */\n\t\tif (image_type == IH_TYPE_KERNEL)\n\t\t\timages->fit_uname_cfg = fit_base_uname_config;\n\n\t\tif (FIT_IMAGE_ENABLE_VERIFY && images->verify) {\n\t\t\tputs(\"   Verifying Hash Integrity ... \");\n\t\t\tif (fit_config_verify(fit, cfg_noffset)) {\n\t\t\t\tputs(\"Bad Data Hash\\n\");\n\t\t\t\tbootstage_error(bootstage_id +\n\t\t\t\t\tBOOTSTAGE_SUB_HASH);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tputs(\"OK\\n\");\n\t\t}\n\n\t\tbootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);\n\n\t\tnoffset = fit_conf_get_prop_node(fit, cfg_noffset,\n\t\t\t\t\t\t prop_name);\n\t\tfit_uname = fit_get_name(fit, noffset, NULL);\n\t}\n\tif (noffset < 0) {\n\t\tprintf(\"Could not find subimage node type '%s'\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);\n\t\treturn -ENOENT;\n\t}\n\n\tprintf(\"   Trying '%s' %s subimage\\n\", fit_uname, prop_name);\n\n\tret = fit_image_select(fit, noffset, images->verify);\n\tif (ret) {\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH);\n\t\treturn ret;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\tif (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) {\n\t\tif (!fit_image_check_target_arch(fit, noffset)) {\n\t\t\tputs(\"Unsupported Architecture\\n\");\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifndef USE_HOSTCC\n\tfit_image_get_arch(fit, noffset, &os_arch);\n\timages->os.arch = os_arch;\n#endif\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\ttype_ok = fit_image_check_type(fit, noffset, image_type) ||\n\t\t  fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) ||\n\t\t  (image_type == IH_TYPE_KERNEL &&\n\t\t   fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD));\n\n\tos_ok = image_type == IH_TYPE_FLATDT ||\n\t\timage_type == IH_TYPE_FPGA ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_LINUX) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_OPENRTOS) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_EFI) ||\n\t\tfit_image_check_os(fit, noffset, IH_OS_VXWORKS);\n\n\t/*\n\t * If either of the checks fail, we should report an error, but\n\t * if the image type is coming from the \"loadables\" field, we\n\t * don't care what it is\n\t */\n\tif ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) {\n\t\tfit_image_get_os(fit, noffset, &os);\n\t\tprintf(\"No %s %s %s Image\\n\",\n\t\t       genimg_get_os_name(os),\n\t\t       genimg_get_arch_name(arch),\n\t\t       genimg_get_type_name(image_type));\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);\n\t\treturn -EIO;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK);\n\n\t/* get image data address and length */\n\tif (fit_image_get_data_and_size(fit, noffset,\n\t\t\t\t\t(const void **)&buf, &size)) {\n\t\tprintf(\"Could not find %s subimage data!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);\n\t\treturn -ENOENT;\n\t}\n\n\t/* Decrypt data before uncompress/move */\n\tif (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {\n\t\tputs(\"   Decrypting Data ... \");\n\t\tif (fit_image_uncipher(fit, noffset, &buf, &size)) {\n\t\t\tputs(\"Error\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tputs(\"OK\\n\");\n\t}\n\n\t/* perform any post-processing on the image data */\n\tif (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS))\n\t\tboard_fit_image_post_process(&buf, &size);\n\n\tlen = (ulong)size;\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK);\n\n\tdata = map_to_sysmem(buf);\n\tload = data;\n\tif (load_op == FIT_LOAD_IGNORED) {\n\t\t/* Don't load */\n\t} else if (fit_image_get_load(fit, noffset, &load)) {\n\t\tif (load_op == FIT_LOAD_REQUIRED) {\n\t\t\tprintf(\"Can't get %s subimage load address!\\n\",\n\t\t\t       prop_name);\n\t\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\t\t\treturn -EBADF;\n\t\t}\n\t} else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) {\n\t\tulong image_start, image_end;\n\n\t\t/*\n\t\t * move image data to the load address,\n\t\t * make sure we don't overwrite initial image\n\t\t */\n\t\timage_start = addr;\n\t\timage_end = addr + fit_get_size(fit);\n\n\t\tload_end = load + len;\n\t\tif (image_type != IH_TYPE_KERNEL &&\n\t\t    load < image_end && load_end > image_start) {\n\t\t\tprintf(\"Error: %s overwritten\\n\", prop_name);\n\t\t\treturn -EXDEV;\n\t\t}\n\n\t\tprintf(\"   Loading %s from 0x%08lx to 0x%08lx\\n\",\n\t\t       prop_name, data, load);\n\t} else {\n\t\tload = data;\t/* No load address specified */\n\t}\n\n\tcomp = IH_COMP_NONE;\n\tloadbuf = buf;\n\t/* Kernel images get decompressed later in bootm_load_os(). */\n\tif (!fit_image_get_comp(fit, noffset, &comp) &&\n\t    comp != IH_COMP_NONE &&\n\t    !(image_type == IH_TYPE_KERNEL ||\n\t      image_type == IH_TYPE_KERNEL_NOLOAD ||\n\t      image_type == IH_TYPE_RAMDISK)) {\n\t\tulong max_decomp_len = len * 20;\n\t\tif (load == data) {\n\t\t\tloadbuf = malloc(max_decomp_len);\n\t\t\tload = map_to_sysmem(loadbuf);\n\t\t} else {\n\t\t\tloadbuf = map_sysmem(load, max_decomp_len);\n\t\t}\n\t\tif (image_decomp(comp, load, data, image_type,\n\t\t\t\tloadbuf, buf, len, max_decomp_len, &load_end)) {\n\t\t\tprintf(\"Error decompressing %s\\n\", prop_name);\n\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t\tlen = load_end - load;\n\t} else if (load != data) {\n\t\tloadbuf = map_sysmem(load, len);\n\t\tmemcpy(loadbuf, buf, len);\n\t}\n\n\tif (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE)\n\t\tputs(\"WARNING: 'compression' nodes for ramdisks are deprecated,\"\n\t\t     \" please fix your .its file!\\n\");\n\n\t/* verify that image data is a proper FDT blob */\n\tif (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) {\n\t\tputs(\"Subimage data is not a FDT\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD);\n\n\t*datap = load;\n\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = (char *)fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = (char *)(fit_uname_config ? :\n\t\t\t\t\t      fit_base_uname_config);\n\n\treturn noffset;\n}\n\nint boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,\n\t\t\tulong *setup_start, ulong *setup_len)\n{\n\tint noffset;\n\tulong addr;\n\tulong len;\n\tint ret;\n\n\taddr = map_to_sysmem(images->fit_hdr_os);\n\tnoffset = fit_get_node_from_config(images, FIT_SETUP_PROP, addr);\n\tif (noffset < 0)\n\t\treturn noffset;\n\n\tret = fit_image_load(images, addr, NULL, NULL, arch,\n\t\t\t     IH_TYPE_X86_SETUP, BOOTSTAGE_ID_FIT_SETUP_START,\n\t\t\t     FIT_LOAD_REQUIRED, setup_start, &len);\n\n\treturn ret;\n}\n\n#ifndef USE_HOSTCC\nint boot_get_fdt_fit(bootm_headers_t *images, ulong addr,\n\t\t   const char **fit_unamep, const char **fit_uname_configp,\n\t\t   int arch, ulong *datap, ulong *lenp)\n{\n\tint fdt_noffset, cfg_noffset, count;\n\tconst void *fit;\n\tconst char *fit_uname = NULL;\n\tconst char *fit_uname_config = NULL;\n\tchar *fit_uname_config_copy = NULL;\n\tchar *next_config = NULL;\n\tulong load, len;\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\tulong image_start, image_end;\n\tulong ovload, ovlen;\n\tconst char *uconfig;\n\tconst char *uname;\n\tvoid *base, *ov;\n\tint i, err, noffset, ov_noffset;\n#endif\n\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\n\tif (fit_uname_configp && *fit_uname_configp) {\n\t\tfit_uname_config_copy = strdup(*fit_uname_configp);\n\t\tif (!fit_uname_config_copy)\n\t\t\treturn -ENOMEM;\n\n\t\tnext_config = strchr(fit_uname_config_copy, '#');\n\t\tif (next_config)\n\t\t\t*next_config++ = '\\0';\n\t\tif (next_config - 1 > fit_uname_config_copy)\n\t\t\tfit_uname_config = fit_uname_config_copy;\n\t}\n\n\tfdt_noffset = fit_image_load(images,\n\t\taddr, &fit_uname, &fit_uname_config,\n\t\tarch, IH_TYPE_FLATDT,\n\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\tFIT_LOAD_OPTIONAL, &load, &len);\n\n\tif (fdt_noffset < 0)\n\t\tgoto out;\n\n\tdebug(\"fit_uname=%s, fit_uname_config=%s\\n\",\n\t\t\tfit_uname ? fit_uname : \"<NULL>\",\n\t\t\tfit_uname_config ? fit_uname_config : \"<NULL>\");\n\n\tfit = map_sysmem(addr, 0);\n\n\tcfg_noffset = fit_conf_get_node(fit, fit_uname_config);\n\n\t/* single blob, or error just return as well */\n\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset, FIT_FDT_PROP);\n\tif (count <= 1 && !next_config)\n\t\tgoto out;\n\n\t/* we need to apply overlays */\n\n#ifdef CONFIG_OF_LIBFDT_OVERLAY\n\timage_start = addr;\n\timage_end = addr + fit_get_size(fit);\n\t/* verify that relocation took place by load address not being in fit */\n\tif (load >= image_start && load < image_end) {\n\t\t/* check is simplified; fit load checks for overlaps */\n\t\tprintf(\"Overlayed FDT requires relocation\\n\");\n\t\tfdt_noffset = -EBADF;\n\t\tgoto out;\n\t}\n\n\tbase = map_sysmem(load, len);\n\n\t/* apply extra configs in FIT first, followed by args */\n\tfor (i = 1; ; i++) {\n\t\tif (i < count) {\n\t\t\tnoffset = fit_conf_get_prop_node_index(fit, cfg_noffset,\n\t\t\t\t\t\t\t       FIT_FDT_PROP, i);\n\t\t\tuname = fit_get_name(fit, noffset, NULL);\n\t\t\tuconfig = NULL;\n\t\t} else {\n\t\t\tif (!next_config)\n\t\t\t\tbreak;\n\t\t\tuconfig = next_config;\n\t\t\tnext_config = strchr(next_config, '#');\n\t\t\tif (next_config)\n\t\t\t\t*next_config++ = '\\0';\n\t\t\tuname = NULL;\n\n\t\t\t/*\n\t\t\t * fit_image_load() would load the first FDT from the\n\t\t\t * extra config only when uconfig is specified.\n\t\t\t * Check if the extra config contains multiple FDTs and\n\t\t\t * if so, load them.\n\t\t\t */\n\t\t\tcfg_noffset = fit_conf_get_node(fit, uconfig);\n\n\t\t\ti = 0;\n\t\t\tcount = fit_conf_get_prop_node_count(fit, cfg_noffset,\n\t\t\t\t\t\t\t     FIT_FDT_PROP);\n\t\t}\n\n\t\tdebug(\"%d: using uname=%s uconfig=%s\\n\", i, uname, uconfig);\n\n\t\tov_noffset = fit_image_load(images,\n\t\t\taddr, &uname, &uconfig,\n\t\t\tarch, IH_TYPE_FLATDT,\n\t\t\tBOOTSTAGE_ID_FIT_FDT_START,\n\t\t\tFIT_LOAD_REQUIRED, &ovload, &ovlen);\n\t\tif (ov_noffset < 0) {\n\t\t\tprintf(\"load of %s failed\\n\", uname);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%s loaded at 0x%08lx len=0x%08lx\\n\",\n\t\t\t\tuname, ovload, ovlen);\n\t\tov = map_sysmem(ovload, ovlen);\n\n\t\tbase = map_sysmem(load, len + ovlen);\n\t\terr = fdt_open_into(base, base, len + ovlen);\n\t\tif (err < 0) {\n\t\t\tprintf(\"failed on fdt_open_into\\n\");\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\t/* the verbose method prints out messages on error */\n\t\terr = fdt_overlay_apply_verbose(base, ov);\n\t\tif (err < 0) {\n\t\t\tfdt_noffset = err;\n\t\t\tgoto out;\n\t\t}\n\t\tfdt_pack(base);\n\t\tlen = fdt_totalsize(base);\n\t}\n#else\n\tprintf(\"config with overlays but CONFIG_OF_LIBFDT_OVERLAY not set\\n\");\n\tfdt_noffset = -EBADF;\n#endif\n\nout:\n\tif (datap)\n\t\t*datap = load;\n\tif (lenp)\n\t\t*lenp = len;\n\tif (fit_unamep)\n\t\t*fit_unamep = fit_uname;\n\tif (fit_uname_configp)\n\t\t*fit_uname_configp = fit_uname_config;\n\n\tif (fit_uname_config_copy)\n\t\tfree(fit_uname_config_copy);\n\treturn fdt_noffset;\n}\n#endif\n", "# SPDX-License-Identifier:\tGPL-2.0+\n# Copyright (c) 2016, Google Inc.\n#\n# U-Boot Verified Boot Test\n\n\"\"\"\nThis tests verified boot in the following ways:\n\nFor image verification:\n- Create FIT (unsigned) with mkimage\n- Check that verification shows that no keys are verified\n- Sign image\n- Check that verification shows that a key is now verified\n\nFor configuration verification:\n- Corrupt signature and check for failure\n- Create FIT (with unsigned configuration) with mkimage\n- Check that image verification works\n- Sign the FIT and mark the key as 'required' for verification\n- Check that image verification works\n- Corrupt the signature\n- Check that image verification no-longer works\n\nTests run with both SHA1 and SHA256 hashing.\n\"\"\"\n\nimport shutil\nimport struct\nimport pytest\nimport u_boot_utils as util\nimport vboot_forge\nimport vboot_evil\n\n# Only run the full suite on a few combinations, since it doesn't add any more\n# test coverage.\nTESTDATA = [\n    ['sha1', '', None, False, True],\n    ['sha1', '', '-E -p 0x10000', False, False],\n    ['sha1', '-pss', None, False, False],\n    ['sha1', '-pss', '-E -p 0x10000', False, False],\n    ['sha256', '', None, False, False],\n    ['sha256', '', '-E -p 0x10000', False, False],\n    ['sha256', '-pss', None, False, False],\n    ['sha256', '-pss', '-E -p 0x10000', False, False],\n    ['sha256', '-pss', None, True, False],\n    ['sha256', '-pss', '-E -p 0x10000', True, True],\n]\n\n@pytest.mark.boardspec('sandbox')\n@pytest.mark.buildconfigspec('fit_signature')\n@pytest.mark.requiredtool('dtc')\n@pytest.mark.requiredtool('fdtget')\n@pytest.mark.requiredtool('fdtput')\n@pytest.mark.requiredtool('openssl')\n@pytest.mark.parametrize(\"sha_algo,padding,sign_options,required,full_test\",\n                         TESTDATA)\ndef test_vboot(u_boot_console, sha_algo, padding, sign_options, required,\n               full_test):\n    \"\"\"Test verified boot signing with mkimage and verification with 'bootm'.\n\n    This works using sandbox only as it needs to update the device tree used\n    by U-Boot to hold public keys from the signing process.\n\n    The SHA1 and SHA256 tests are combined into a single test since the\n    key-generation process is quite slow and we want to avoid doing it twice.\n    \"\"\"\n    def dtc(dts):\n        \"\"\"Run the device tree compiler to compile a .dts file\n\n        The output file will be the same as the input file but with a .dtb\n        extension.\n\n        Args:\n            dts: Device tree file to compile.\n        \"\"\"\n        dtb = dts.replace('.dts', '.dtb')\n        util.run_and_log(cons, 'dtc %s %s%s -O dtb '\n                         '-o %s%s' % (dtc_args, datadir, dts, tmpdir, dtb))\n\n    def run_bootm(sha_algo, test_type, expect_string, boots, fit=None):\n        \"\"\"Run a 'bootm' command U-Boot.\n\n        This always starts a fresh U-Boot instance since the device tree may\n        contain a new public key.\n\n        Args:\n            test_type: A string identifying the test type.\n            expect_string: A string which is expected in the output.\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            boots: A boolean that is True if Linux should boot and False if\n                    we are expected to not boot\n            fit: FIT filename to load and verify\n        \"\"\"\n        if not fit:\n            fit = '%stest.fit' % tmpdir\n        cons.restart_uboot()\n        with cons.log.section('Verified boot %s %s' % (sha_algo, test_type)):\n            output = cons.run_command_list(\n                ['host load hostfs - 100 %s' % fit,\n                 'fdt addr 100',\n                 'bootm 100'])\n        assert expect_string in ''.join(output)\n        if boots:\n            assert 'sandbox: continuing, as we cannot run' in ''.join(output)\n        else:\n            assert('sandbox: continuing, as we cannot run'\n                   not in ''.join(output))\n\n    def make_fit(its):\n        \"\"\"Make a new FIT from the .its source file.\n\n        This runs 'mkimage -f' to create a new FIT.\n\n        Args:\n            its: Filename containing .its source.\n        \"\"\"\n        util.run_and_log(cons, [mkimage, '-D', dtc_args, '-f',\n                                '%s%s' % (datadir, its), fit])\n\n    def sign_fit(sha_algo, options):\n        \"\"\"Sign the FIT\n\n        Signs the FIT and writes the signature into it. It also writes the\n        public key into the dtb.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            options: Options to provide to mkimage.\n        \"\"\"\n        args = [mkimage, '-F', '-k', tmpdir, '-K', dtb, '-r', fit]\n        if options:\n            args += options.split(' ')\n        cons.log.action('%s: Sign images' % sha_algo)\n        util.run_and_log(cons, args)\n\n    def sign_fit_norequire(sha_algo, options):\n        \"\"\"Sign the FIT\n\n        Signs the FIT and writes the signature into it. It also writes the\n        public key into the dtb. It does not mark key as 'required' in dtb.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            options: Options to provide to mkimage.\n        \"\"\"\n        args = [mkimage, '-F', '-k', tmpdir, '-K', dtb, fit]\n        if options:\n            args += options.split(' ')\n        cons.log.action('%s: Sign images' % sha_algo)\n        util.run_and_log(cons, args)\n\n    def replace_fit_totalsize(size):\n        \"\"\"Replace FIT header's totalsize with something greater.\n\n        The totalsize must be less than or equal to FIT_SIGNATURE_MAX_SIZE.\n        If the size is greater, the signature verification should return false.\n\n        Args:\n            size: The new totalsize of the header\n\n        Returns:\n            prev_size: The previous totalsize read from the header\n        \"\"\"\n        total_size = 0\n        with open(fit, 'r+b') as handle:\n            handle.seek(4)\n            total_size = handle.read(4)\n            handle.seek(4)\n            handle.write(struct.pack(\">I\", size))\n        return struct.unpack(\">I\", total_size)[0]\n\n    def create_rsa_pair(name):\n        \"\"\"Generate a new RSA key paid and certificate\n\n        Args:\n            name: Name of of the key (e.g. 'dev')\n        \"\"\"\n        public_exponent = 65537\n        util.run_and_log(cons, 'openssl genpkey -algorithm RSA -out %s%s.key '\n                     '-pkeyopt rsa_keygen_bits:2048 '\n                     '-pkeyopt rsa_keygen_pubexp:%d' %\n                     (tmpdir, name, public_exponent))\n\n        # Create a certificate containing the public key\n        util.run_and_log(cons, 'openssl req -batch -new -x509 -key %s%s.key '\n                         '-out %s%s.crt' % (tmpdir, name, tmpdir, name))\n\n    def test_with_algo(sha_algo, padding, sign_options):\n        \"\"\"Test verified boot with the given hash algorithm.\n\n        This is the main part of the test code. The same procedure is followed\n        for both hashing algorithms.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to\n                    use.\n            padding: Either '' or '-pss', to select the padding to use for the\n                    rsa signature algorithm.\n            sign_options: Options to mkimage when signing a fit image.\n        \"\"\"\n        # Compile our device tree files for kernel and U-Boot. These are\n        # regenerated here since mkimage will modify them (by adding a\n        # public key) below.\n        dtc('sandbox-kernel.dts')\n        dtc('sandbox-u-boot.dts')\n\n        # Build the FIT, but don't sign anything yet\n        cons.log.action('%s: Test FIT with signed images' % sha_algo)\n        make_fit('sign-images-%s%s.its' % (sha_algo, padding))\n        run_bootm(sha_algo, 'unsigned images', 'dev-', True)\n\n        # Sign images with our dev keys\n        sign_fit(sha_algo, sign_options)\n        run_bootm(sha_algo, 'signed images', 'dev+', True)\n\n        # Create a fresh .dtb without the public keys\n        dtc('sandbox-u-boot.dts')\n\n        cons.log.action('%s: Test FIT with signed configuration' % sha_algo)\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        run_bootm(sha_algo, 'unsigned config', '%s+ OK' % sha_algo, True)\n\n        # Sign images with our dev keys\n        sign_fit(sha_algo, sign_options)\n        run_bootm(sha_algo, 'signed config', 'dev+', True)\n\n        cons.log.action('%s: Check signed config on the host' % sha_algo)\n\n        util.run_and_log(cons, [fit_check_sign, '-f', fit, '-k', dtb])\n\n        if full_test:\n            # Make sure that U-Boot checks that the config is in the list of\n            # hashed nodes. If it isn't, a security bypass is possible.\n            ffit = '%stest.forged.fit' % tmpdir\n            shutil.copyfile(fit, ffit)\n            with open(ffit, 'rb') as fd:\n                root, strblock = vboot_forge.read_fdt(fd)\n            root, strblock = vboot_forge.manipulate(root, strblock)\n            with open(ffit, 'w+b') as fd:\n                vboot_forge.write_fdt(root, strblock, fd)\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', ffit, '-k', dtb],\n                1, 'Failed to verify required signature')\n\n            run_bootm(sha_algo, 'forged config', 'Bad Data Hash', False, ffit)\n\n            # Try adding an evil root node. This should be detected.\n            efit = '%stest.evilf.fit' % tmpdir\n            shutil.copyfile(fit, efit)\n            vboot_evil.add_evil_node(fit, efit, evil_kernel, 'fakeroot')\n\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', efit, '-k', dtb],\n                1, 'Failed to verify required signature')\n            run_bootm(sha_algo, 'evil fakeroot', 'Bad FIT kernel image format',\n                      False, efit)\n\n            # Try adding an @ to the kernel node name. This should be detected.\n            efit = '%stest.evilk.fit' % tmpdir\n            shutil.copyfile(fit, efit)\n            vboot_evil.add_evil_node(fit, efit, evil_kernel, 'kernel@')\n\n            msg = 'Signature checking prevents use of unit addresses (@) in nodes'\n            util.run_and_log_expect_exception(\n                cons, [fit_check_sign, '-f', efit, '-k', dtb],\n                1, msg)\n            run_bootm(sha_algo, 'evil kernel@', msg, False, efit)\n\n        # Create a new properly signed fit and replace header bytes\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n        bcfg = u_boot_console.config.buildconfig\n        max_size = int(bcfg.get('config_fit_signature_max_size', 0x10000000), 0)\n        existing_size = replace_fit_totalsize(max_size + 1)\n        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash',\n                  False)\n        cons.log.action('%s: Check overflowed FIT header totalsize' % sha_algo)\n\n        # Replace with existing header bytes\n        replace_fit_totalsize(existing_size)\n        run_bootm(sha_algo, 'signed config', 'dev+', True)\n        cons.log.action('%s: Check default FIT header totalsize' % sha_algo)\n\n        # Increment the first byte of the signature, which should cause failure\n        sig = util.run_and_log(cons, 'fdtget -t bx %s %s value' %\n                               (fit, sig_node))\n        byte_list = sig.split()\n        byte = int(byte_list[0], 16)\n        byte_list[0] = '%x' % (byte + 1)\n        sig = ' '.join(byte_list)\n        util.run_and_log(cons, 'fdtput -t bx %s %s value %s' %\n                         (fit, sig_node, sig))\n\n        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash',\n                  False)\n\n        cons.log.action('%s: Check bad config on the host' % sha_algo)\n        util.run_and_log_expect_exception(\n            cons, [fit_check_sign, '-f', fit, '-k', dtb],\n            1, 'Failed to verify required signature')\n\n    def test_required_key(sha_algo, padding, sign_options):\n        \"\"\"Test verified boot with the given hash algorithm.\n\n        This function tests if U-Boot rejects an image when a required key isn't\n        used to sign a FIT.\n\n        Args:\n            sha_algo: Either 'sha1' or 'sha256', to select the algorithm to use\n            padding: Either '' or '-pss', to select the padding to use for the\n                    rsa signature algorithm.\n            sign_options: Options to mkimage when signing a fit image.\n        \"\"\"\n        # Compile our device tree files for kernel and U-Boot. These are\n        # regenerated here since mkimage will modify them (by adding a\n        # public key) below.\n        dtc('sandbox-kernel.dts')\n        dtc('sandbox-u-boot.dts')\n\n        cons.log.action('%s: Test FIT with configs images' % sha_algo)\n\n        # Build the FIT with prod key (keys required) and sign it. This puts the\n        # signature into sandbox-u-boot.dtb, marked 'required'\n        make_fit('sign-configs-%s%s-prod.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n\n        # Build the FIT with dev key (keys NOT required). This adds the\n        # signature into sandbox-u-boot.dtb, NOT marked 'required'.\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit_norequire(sha_algo, sign_options)\n\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Only the prod key is set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit_norequire() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should not be accepted by\n        # U-Boot because the prod key is required.\n        run_bootm(sha_algo, 'required key', '', False)\n\n        # Build the FIT with dev key (keys required) and sign it. This puts the\n        # signature into sandbox-u-boot.dtb, marked 'required'.\n        make_fit('sign-configs-%s%s.its' % (sha_algo, padding))\n        sign_fit(sha_algo, sign_options)\n\n        # Set the required-mode policy to \"any\".\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Both the dev and prod key are set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should be accepted by\n        # U-Boot because the dev key is required and policy is \"any\" required key.\n        util.run_and_log(cons, 'fdtput -t s %s /signature required-mode any' %\n                         (dtb))\n        run_bootm(sha_algo, 'multi required key', 'dev+', True)\n\n        # Set the required-mode policy to \"all\".\n        # So now sandbox-u-boot.dtb two signatures, for the prod and dev keys.\n        # Both the dev and prod key are set as 'required'. But FIT we just built has\n        # a dev signature only (sign_fit() overwrites the FIT).\n        # Try to boot the FIT with dev key. This FIT should not be accepted by\n        # U-Boot because the prod key is required and policy is \"all\" required key\n        util.run_and_log(cons, 'fdtput -t s %s /signature required-mode all' %\n                         (dtb))\n        run_bootm(sha_algo, 'multi required key', '', False)\n\n    cons = u_boot_console\n    tmpdir = cons.config.result_dir + '/'\n    datadir = cons.config.source_dir + '/test/py/tests/vboot/'\n    fit = '%stest.fit' % tmpdir\n    mkimage = cons.config.build_dir + '/tools/mkimage'\n    fit_check_sign = cons.config.build_dir + '/tools/fit_check_sign'\n    dtc_args = '-I dts -O dtb -i %s' % tmpdir\n    dtb = '%ssandbox-u-boot.dtb' % tmpdir\n    sig_node = '/configurations/conf-1/signature'\n\n    create_rsa_pair('dev')\n    create_rsa_pair('prod')\n\n    # Create a number kernel image with zeroes\n    with open('%stest-kernel.bin' % tmpdir, 'wb') as fd:\n        fd.write(500 * b'\\0')\n\n    # Create a second kernel image with ones\n    evil_kernel = '%stest-kernel1.bin' % tmpdir\n    with open(evil_kernel, 'wb') as fd:\n        fd.write(500 * b'\\x01')\n\n    try:\n        # We need to use our own device tree file. Remember to restore it\n        # afterwards.\n        old_dtb = cons.config.dtb\n        cons.config.dtb = dtb\n        if required:\n            test_required_key(sha_algo, padding, sign_options)\n        else:\n            test_with_algo(sha_algo, padding, sign_options)\n    finally:\n        # Go back to the original U-Boot with the correct dtb.\n        cons.config.dtb = old_dtb\n        cons.restart_uboot()\n"], "filenames": ["common/image-fit.c", "test/py/tests/test_vboot.py"], "buggy_code_start_loc": [1570, 235], "buggy_code_end_loc": [1962, 270], "fixing_code_start_loc": [1571, 235], "fixing_code_end_loc": [2010, 271], "type": "NVD-CWE-noinfo", "message": "The boot loader in Das U-Boot before 2021.04-rc2 mishandles use of unit addresses in a FIT.", "other": {"cve": {"id": "CVE-2021-27138", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-17T23:15:13.717", "lastModified": "2021-02-24T00:35:07.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The boot loader in Das U-Boot before 2021.04-rc2 mishandles use of unit addresses in a FIT."}, {"lang": "es", "value": "El cargador de arranque en Das U-Boot versiones anteriores a 2021.04-rc2, maneja inapropiadamente el uso de direcciones de unidad en un FIT"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2021.01", "matchCriteriaId": "A5899D85-92F8-4CB2-879B-E75488D8471C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2021.04:rc1:*:*:*:*:*:*", "matchCriteriaId": "E7B5BAFE-DC47-41E2-94D9-15A7DC1E3E28"}]}]}], "references": [{"url": "https://github.com/u-boot/u-boot/commit/3f04db891a353f4b127ed57279279f851c6b4917", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/u-boot/u-boot/commit/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/u-boot/u-boot/commit/b6f4c757959f8850e1299a77c8e5713da78e8ec0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/u-boot/u-boot/commit/3f04db891a353f4b127ed57279279f851c6b4917"}}