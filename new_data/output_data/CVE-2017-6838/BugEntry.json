{"buggy_code": ["/*\n\tAudio File Library\n\n\tCopyright (C) 1998, 2011-2012, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis program is free software; you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation; either version 2 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith this program; if not, write to the Free Software Foundation, Inc.,\n\t51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n/*\n\tsfconvert is a program which can convert various parameters of\n\tsound files.\n*/\n\n#include \"config.h\"\n\n#ifdef __USE_SGI_HEADERS__\n#include <dmedia/audiofile.h>\n#else\n#include <audiofile.h>\n#endif\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"printinfo.h\"\n\nvoid printversion (void);\nvoid printusage (void);\nvoid usageerror (void);\nbool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid);\n\nint main (int argc, char **argv)\n{\n\tif (argc == 2)\n\t{\n\t\tif (!strcmp(argv[1], \"--version\") || !strcmp(argv[1], \"-v\"))\n\t\t{\n\t\t\tprintversion();\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\n\t\tif (!strcmp(argv[1], \"--help\") || !strcmp(argv[1], \"-h\"))\n\t\t{\n\t\t\tprintusage();\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t}\n\n\tif (argc < 3)\n\t\tusageerror();\n\n\tconst char *inFileName = argv[1];\n\tconst char *outFileName = argv[2];\n\n\tint outFileFormat = AF_FILE_UNKNOWN;\n\tint outSampleFormat = -1, outSampleWidth = -1, outChannelCount = -1;\n\tint outCompression = AF_COMPRESSION_NONE;\n\tdouble outMaxAmp = 1.0;\n\n\tint i = 3;\n\n\twhile (i < argc)\n\t{\n\t\tif (!strcmp(argv[i], \"format\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+1], \"aiff\"))\n\t\t\t\toutFileFormat = AF_FILE_AIFF;\n\t\t\telse if (!strcmp(argv[i+1], \"aifc\"))\n\t\t\t\toutFileFormat = AF_FILE_AIFFC;\n\t\t\telse if (!strcmp(argv[i+1], \"wave\"))\n\t\t\t\toutFileFormat = AF_FILE_WAVE;\n\t\t\telse if (!strcmp(argv[i+1], \"next\"))\n\t\t\t\toutFileFormat = AF_FILE_NEXTSND;\n\t\t\telse if (!strcmp(argv[i+1], \"bics\"))\n\t\t\t\toutFileFormat = AF_FILE_BICSF;\n\t\t\telse if (!strcmp(argv[i+1], \"smp\"))\n\t\t\t\toutFileFormat = AF_FILE_SAMPLEVISION;\n\t\t\telse if (!strcmp(argv[i+1], \"voc\"))\n\t\t\t\toutFileFormat = AF_FILE_VOC;\n\t\t\telse if (!strcmp(argv[i+1], \"nist\"))\n\t\t\t\toutFileFormat = AF_FILE_NIST_SPHERE;\n\t\t\telse if (!strcmp(argv[i+1], \"caf\"))\n\t\t\t\toutFileFormat = AF_FILE_CAF;\n\t\t\telse if (!strcmp(argv[i+1], \"flac\"))\n\t\t\t\toutFileFormat = AF_FILE_FLAC;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"sfconvert: Unknown format %s.\\n\", argv[i+1]);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"channels\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutChannelCount = atoi(argv[i+1]);\n\t\t\tif (outChannelCount < 1)\n\t\t\t\tusageerror();\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"float\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutSampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\toutSampleWidth = 32;\n\t\t\toutMaxAmp = atof(argv[i+1]);\n\n\t\t\t// outMaxAmp is currently unused.\n\t\t\t(void) outMaxAmp;\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"integer\"))\n\t\t{\n\t\t\tif (i + 2 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutSampleWidth = atoi(argv[i+1]);\n\t\t\tif (outSampleWidth < 1 || outSampleWidth > 32)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+2], \"2scomp\"))\n\t\t\t\toutSampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\telse if (!strcmp(argv[i+2], \"unsigned\"))\n\t\t\t\toutSampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\tusageerror();\n\n\t\t\t// Increment for arguments.\n\t\t\ti += 2;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"compression\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+1], \"none\"))\n\t\t\t\toutCompression = AF_COMPRESSION_NONE;\n\t\t\telse if (!strcmp(argv[i+1], \"ulaw\"))\n\t\t\t\toutCompression = AF_COMPRESSION_G711_ULAW;\n\t\t\telse if (!strcmp(argv[i+1], \"alaw\"))\n\t\t\t\toutCompression = AF_COMPRESSION_G711_ALAW;\n\t\t\telse if (!strcmp(argv[i+1], \"ima\"))\n\t\t\t\toutCompression = AF_COMPRESSION_IMA;\n\t\t\telse if (!strcmp(argv[i+1], \"msadpcm\"))\n\t\t\t\toutCompression = AF_COMPRESSION_MS_ADPCM;\n\t\t\telse if (!strcmp(argv[i+1], \"flac\"))\n\t\t\t\toutCompression = AF_COMPRESSION_FLAC;\n\t\t\telse if (!strcmp(argv[i+1], \"alac\"))\n\t\t\t\toutCompression = AF_COMPRESSION_ALAC;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"sfconvert: Unknown compression format %s.\\n\", argv[i+1]);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Unrecognized command %s\\n\", argv[i]);\n\t\t}\n\n\t\ti++;\n\t}\n\n\tAFfilehandle inFile = afOpenFile(inFileName, \"r\", AF_NULL_FILESETUP);\n\tif (!inFile)\n\t{\n\t\tprintf(\"Could not open file '%s' for reading.\\n\", inFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Get audio format parameters from input file.\n\tint fileFormat = afGetFileFormat(inFile, NULL);\n\tint channelCount = afGetChannels(inFile, AF_DEFAULT_TRACK);\n\tdouble sampleRate = afGetRate(inFile, AF_DEFAULT_TRACK);\n\tint sampleFormat, sampleWidth;\n\tafGetSampleFormat(inFile, AF_DEFAULT_TRACK, &sampleFormat, &sampleWidth);\n\n\t// Initialize output audio format parameters.\n\tAFfilesetup outFileSetup = afNewFileSetup();\n\n\tif (outFileFormat == -1)\n\t\toutFileFormat = fileFormat;\n\n\tif (outSampleFormat == -1 || outSampleWidth == -1)\n\t{\n\t\toutSampleFormat = sampleFormat;\n\t\toutSampleWidth = sampleWidth;\n\t}\n\n\tif (outChannelCount == -1)\n\t\toutChannelCount = channelCount;\n\n\tafInitFileFormat(outFileSetup, outFileFormat);\n\tafInitCompression(outFileSetup, AF_DEFAULT_TRACK, outCompression);\n\tafInitSampleFormat(outFileSetup, AF_DEFAULT_TRACK, outSampleFormat,\n\t\toutSampleWidth);\n\tafInitChannels(outFileSetup, AF_DEFAULT_TRACK, outChannelCount);\n\tafInitRate(outFileSetup, AF_DEFAULT_TRACK, sampleRate);\n\n\tAFfilehandle outFile = afOpenFile(outFileName, \"w\", outFileSetup);\n\tif (!outFile)\n\t{\n\t\tprintf(\"Could not open file '%s' for writing.\\n\", outFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tafFreeFileSetup(outFileSetup);\n\n\t/*\n\t\tSet the output file's virtual audio format parameters\n\t\tto match the audio format parameters of the input file.\n\t*/\n\tafSetVirtualChannels(outFile, AF_DEFAULT_TRACK, channelCount);\n\tafSetVirtualSampleFormat(outFile, AF_DEFAULT_TRACK, sampleFormat,\n\t\tsampleWidth);\n\n\tbool success = copyaudiodata(inFile, outFile, AF_DEFAULT_TRACK);\n\n\tafCloseFile(inFile);\n\tafCloseFile(outFile);\n\n\tif (!success)\n\t{\n\t\tunlink(outFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tprintfileinfo(inFileName);\n\tputchar('\\n');\n\tprintfileinfo(outFileName);\n\n\treturn EXIT_SUCCESS;\n}\n\nvoid printusage (void)\n{\n\tprintf(\"usage: sfconvert infile outfile [ options ... ] [ output keywords ... ]\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Where keywords specify format of input or output soundfile:\\n\");\n\tprintf(\"    format f       file format f (see below)\\n\");\n\tprintf(\"    compression c  compression format c (see below)\\n\");\n\tprintf(\"    byteorder e    endian (e is big or little)\\n\");\n\tprintf(\"    channels n     n-channel file (1 or 2)\\n\");\n\tprintf(\"    integer n s    n-bit integer file, where s is one of\\n\");\n\tprintf(\"                       2scomp: 2's complement signed data\\n\");\n\tprintf(\"                       unsigned: unsigned data\\n\");\n\tprintf(\"    float m        floating point file, maxamp m (usually 1.0)\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Currently supported file formats are:\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"    aiff    Audio Interchange File Format\\n\");\n\tprintf(\"    aifc    AIFF-C File Format\\n\");\n\tprintf(\"    next    NeXT/Sun Format\\n\");\n\tprintf(\"    wave    MS RIFF WAVE Format\\n\");\n\tprintf(\"    bics    Berkeley/IRCAM/CARL Sound File Format\\n\");\n\tprintf(\"    smp     Sample Vision Format\\n\");\n\tprintf(\"    voc     Creative Voice File\\n\");\n\tprintf(\"    nist    NIST SPHERE Format\\n\");\n\tprintf(\"    caf     Core Audio Format\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Currently supported compression formats are:\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"    ulaw    G.711 u-law\\n\");\n\tprintf(\"    alaw    G.711 A-law\\n\");\n\tprintf(\"    ima     IMA ADPCM\\n\");\n\tprintf(\"    msadpcm MS ADPCM\\n\");\n\tprintf(\"    flac    FLAC\\n\");\n\tprintf(\"    alac    Apple Lossless Audio Codec\\n\");\n\tprintf(\"\\n\");\n}\n\nvoid usageerror (void)\n{\n\tprintusage();\n\texit(EXIT_FAILURE);\n}\n\nvoid printversion (void)\n{\n\tprintf(\"sfconvert: Audio File Library version %s\\n\", VERSION);\n}\n\n/*\n\tCopy audio data from one file to another.  This function\n\tassumes that the virtual sample formats of the two files\n\tmatch.\n*/\nbool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}\n"], "fixing_code": ["/*\n\tAudio File Library\n\n\tCopyright (C) 1998, 2011-2012, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis program is free software; you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation; either version 2 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith this program; if not, write to the Free Software Foundation, Inc.,\n\t51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n/*\n\tsfconvert is a program which can convert various parameters of\n\tsound files.\n*/\n\n#include \"config.h\"\n\n#ifdef __USE_SGI_HEADERS__\n#include <dmedia/audiofile.h>\n#else\n#include <audiofile.h>\n#endif\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"printinfo.h\"\n\nvoid printversion (void);\nvoid printusage (void);\nvoid usageerror (void);\nbool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid);\n\nint firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}\n\n#ifndef __has_builtin\n#define __has_builtin(x) 0\n#endif\n\nint multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}\n\nint main (int argc, char **argv)\n{\n\tif (argc == 2)\n\t{\n\t\tif (!strcmp(argv[1], \"--version\") || !strcmp(argv[1], \"-v\"))\n\t\t{\n\t\t\tprintversion();\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\n\t\tif (!strcmp(argv[1], \"--help\") || !strcmp(argv[1], \"-h\"))\n\t\t{\n\t\t\tprintusage();\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t}\n\n\tif (argc < 3)\n\t\tusageerror();\n\n\tconst char *inFileName = argv[1];\n\tconst char *outFileName = argv[2];\n\n\tint outFileFormat = AF_FILE_UNKNOWN;\n\tint outSampleFormat = -1, outSampleWidth = -1, outChannelCount = -1;\n\tint outCompression = AF_COMPRESSION_NONE;\n\tdouble outMaxAmp = 1.0;\n\n\tint i = 3;\n\n\twhile (i < argc)\n\t{\n\t\tif (!strcmp(argv[i], \"format\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+1], \"aiff\"))\n\t\t\t\toutFileFormat = AF_FILE_AIFF;\n\t\t\telse if (!strcmp(argv[i+1], \"aifc\"))\n\t\t\t\toutFileFormat = AF_FILE_AIFFC;\n\t\t\telse if (!strcmp(argv[i+1], \"wave\"))\n\t\t\t\toutFileFormat = AF_FILE_WAVE;\n\t\t\telse if (!strcmp(argv[i+1], \"next\"))\n\t\t\t\toutFileFormat = AF_FILE_NEXTSND;\n\t\t\telse if (!strcmp(argv[i+1], \"bics\"))\n\t\t\t\toutFileFormat = AF_FILE_BICSF;\n\t\t\telse if (!strcmp(argv[i+1], \"smp\"))\n\t\t\t\toutFileFormat = AF_FILE_SAMPLEVISION;\n\t\t\telse if (!strcmp(argv[i+1], \"voc\"))\n\t\t\t\toutFileFormat = AF_FILE_VOC;\n\t\t\telse if (!strcmp(argv[i+1], \"nist\"))\n\t\t\t\toutFileFormat = AF_FILE_NIST_SPHERE;\n\t\t\telse if (!strcmp(argv[i+1], \"caf\"))\n\t\t\t\toutFileFormat = AF_FILE_CAF;\n\t\t\telse if (!strcmp(argv[i+1], \"flac\"))\n\t\t\t\toutFileFormat = AF_FILE_FLAC;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"sfconvert: Unknown format %s.\\n\", argv[i+1]);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"channels\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutChannelCount = atoi(argv[i+1]);\n\t\t\tif (outChannelCount < 1)\n\t\t\t\tusageerror();\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"float\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutSampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\toutSampleWidth = 32;\n\t\t\toutMaxAmp = atof(argv[i+1]);\n\n\t\t\t// outMaxAmp is currently unused.\n\t\t\t(void) outMaxAmp;\n\n\t\t\t// Increment for argument.\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"integer\"))\n\t\t{\n\t\t\tif (i + 2 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\toutSampleWidth = atoi(argv[i+1]);\n\t\t\tif (outSampleWidth < 1 || outSampleWidth > 32)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+2], \"2scomp\"))\n\t\t\t\toutSampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\telse if (!strcmp(argv[i+2], \"unsigned\"))\n\t\t\t\toutSampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\tusageerror();\n\n\t\t\t// Increment for arguments.\n\t\t\ti += 2;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"compression\"))\n\t\t{\n\t\t\tif (i + 1 >= argc)\n\t\t\t\tusageerror();\n\n\t\t\tif (!strcmp(argv[i+1], \"none\"))\n\t\t\t\toutCompression = AF_COMPRESSION_NONE;\n\t\t\telse if (!strcmp(argv[i+1], \"ulaw\"))\n\t\t\t\toutCompression = AF_COMPRESSION_G711_ULAW;\n\t\t\telse if (!strcmp(argv[i+1], \"alaw\"))\n\t\t\t\toutCompression = AF_COMPRESSION_G711_ALAW;\n\t\t\telse if (!strcmp(argv[i+1], \"ima\"))\n\t\t\t\toutCompression = AF_COMPRESSION_IMA;\n\t\t\telse if (!strcmp(argv[i+1], \"msadpcm\"))\n\t\t\t\toutCompression = AF_COMPRESSION_MS_ADPCM;\n\t\t\telse if (!strcmp(argv[i+1], \"flac\"))\n\t\t\t\toutCompression = AF_COMPRESSION_FLAC;\n\t\t\telse if (!strcmp(argv[i+1], \"alac\"))\n\t\t\t\toutCompression = AF_COMPRESSION_ALAC;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"sfconvert: Unknown compression format %s.\\n\", argv[i+1]);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Unrecognized command %s\\n\", argv[i]);\n\t\t}\n\n\t\ti++;\n\t}\n\n\tAFfilehandle inFile = afOpenFile(inFileName, \"r\", AF_NULL_FILESETUP);\n\tif (!inFile)\n\t{\n\t\tprintf(\"Could not open file '%s' for reading.\\n\", inFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Get audio format parameters from input file.\n\tint fileFormat = afGetFileFormat(inFile, NULL);\n\tint channelCount = afGetChannels(inFile, AF_DEFAULT_TRACK);\n\tdouble sampleRate = afGetRate(inFile, AF_DEFAULT_TRACK);\n\tint sampleFormat, sampleWidth;\n\tafGetSampleFormat(inFile, AF_DEFAULT_TRACK, &sampleFormat, &sampleWidth);\n\n\t// Initialize output audio format parameters.\n\tAFfilesetup outFileSetup = afNewFileSetup();\n\n\tif (outFileFormat == -1)\n\t\toutFileFormat = fileFormat;\n\n\tif (outSampleFormat == -1 || outSampleWidth == -1)\n\t{\n\t\toutSampleFormat = sampleFormat;\n\t\toutSampleWidth = sampleWidth;\n\t}\n\n\tif (outChannelCount == -1)\n\t\toutChannelCount = channelCount;\n\n\tafInitFileFormat(outFileSetup, outFileFormat);\n\tafInitCompression(outFileSetup, AF_DEFAULT_TRACK, outCompression);\n\tafInitSampleFormat(outFileSetup, AF_DEFAULT_TRACK, outSampleFormat,\n\t\toutSampleWidth);\n\tafInitChannels(outFileSetup, AF_DEFAULT_TRACK, outChannelCount);\n\tafInitRate(outFileSetup, AF_DEFAULT_TRACK, sampleRate);\n\n\tAFfilehandle outFile = afOpenFile(outFileName, \"w\", outFileSetup);\n\tif (!outFile)\n\t{\n\t\tprintf(\"Could not open file '%s' for writing.\\n\", outFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tafFreeFileSetup(outFileSetup);\n\n\t/*\n\t\tSet the output file's virtual audio format parameters\n\t\tto match the audio format parameters of the input file.\n\t*/\n\tafSetVirtualChannels(outFile, AF_DEFAULT_TRACK, channelCount);\n\tafSetVirtualSampleFormat(outFile, AF_DEFAULT_TRACK, sampleFormat,\n\t\tsampleWidth);\n\n\tbool success = copyaudiodata(inFile, outFile, AF_DEFAULT_TRACK);\n\n\tafCloseFile(inFile);\n\tafCloseFile(outFile);\n\n\tif (!success)\n\t{\n\t\tunlink(outFileName);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tprintfileinfo(inFileName);\n\tputchar('\\n');\n\tprintfileinfo(outFileName);\n\n\treturn EXIT_SUCCESS;\n}\n\nvoid printusage (void)\n{\n\tprintf(\"usage: sfconvert infile outfile [ options ... ] [ output keywords ... ]\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Where keywords specify format of input or output soundfile:\\n\");\n\tprintf(\"    format f       file format f (see below)\\n\");\n\tprintf(\"    compression c  compression format c (see below)\\n\");\n\tprintf(\"    byteorder e    endian (e is big or little)\\n\");\n\tprintf(\"    channels n     n-channel file (1 or 2)\\n\");\n\tprintf(\"    integer n s    n-bit integer file, where s is one of\\n\");\n\tprintf(\"                       2scomp: 2's complement signed data\\n\");\n\tprintf(\"                       unsigned: unsigned data\\n\");\n\tprintf(\"    float m        floating point file, maxamp m (usually 1.0)\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Currently supported file formats are:\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"    aiff    Audio Interchange File Format\\n\");\n\tprintf(\"    aifc    AIFF-C File Format\\n\");\n\tprintf(\"    next    NeXT/Sun Format\\n\");\n\tprintf(\"    wave    MS RIFF WAVE Format\\n\");\n\tprintf(\"    bics    Berkeley/IRCAM/CARL Sound File Format\\n\");\n\tprintf(\"    smp     Sample Vision Format\\n\");\n\tprintf(\"    voc     Creative Voice File\\n\");\n\tprintf(\"    nist    NIST SPHERE Format\\n\");\n\tprintf(\"    caf     Core Audio Format\\n\");\n\tprintf(\"\\n\");\n\n\tprintf(\"Currently supported compression formats are:\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"    ulaw    G.711 u-law\\n\");\n\tprintf(\"    alaw    G.711 A-law\\n\");\n\tprintf(\"    ima     IMA ADPCM\\n\");\n\tprintf(\"    msadpcm MS ADPCM\\n\");\n\tprintf(\"    flac    FLAC\\n\");\n\tprintf(\"    alac    Apple Lossless Audio Codec\\n\");\n\tprintf(\"\\n\");\n}\n\nvoid usageerror (void)\n{\n\tprintusage();\n\texit(EXIT_FAILURE);\n}\n\nvoid printversion (void)\n{\n\tprintf(\"sfconvert: Audio File Library version %s\\n\", VERSION);\n}\n\n/*\n\tCopy audio data from one file to another.  This function\n\tassumes that the virtual sample formats of the two files\n\tmatch.\n*/\nbool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tint kBufferFrameCount = 65536;\n\tint bufferSize;\n\twhile (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))\n\t\tkBufferFrameCount /= 2;\n\tvoid *buffer = malloc(bufferSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}\n"], "filenames": ["sfcommands/sfconvert.c"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [328], "fixing_code_start_loc": [47], "fixing_code_end_loc": [358], "type": "CWE-190", "message": "Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.", "other": {"cve": {"id": "CVE-2017-6838", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-20T16:59:03.000", "lastModified": "2017-11-04T01:29:49.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file."}, {"lang": "es", "value": "Desbordamiento de entero en sfcommy s/sfconvert.c en Audio File Library (tambi\u00e9n conocido como audiofile) 0.3.6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "3C7E74B2-432B-4CCD-873F-AA7E012D8C7F"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3814", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/03/13/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://blogs.gentoo.org/ago/2017/02/20/audiofile-multiple-ubsan-crashes/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpruett/audiofile/issues/41", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c"}}