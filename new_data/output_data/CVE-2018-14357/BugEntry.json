{"buggy_code": ["/**\n * @file\n * IMAP login authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005,2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_login IMAP login authentication method\n *\n * IMAP login authentication method\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n\n/**\n * imap_auth_login - Plain LOGIN support\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n *\n * @note Gmail documents one string but use another, so we support both.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",     \"IMAP4rev1\",     \"STATUS\",      \"ACL\",\n  \"NAMESPACE\", \"AUTH=CRAM-MD5\", \"AUTH=GSSAPI\", \"AUTH=ANONYMOUS\",\n  \"STARTTLS\",  \"LOGINDISABLED\", \"IDLE\",        \"SASL-IR\",\n  \"ENABLE\",    \"X-GM-EXT-1\",    \"X-GM-EXT1\",   NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param idata Server data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapData *idata)\n{\n  if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param idata IMAP data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapData *idata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = idata->cmds + idata->nextcmd;\n  idata->nextcmd = (idata->nextcmd + 1) % idata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", idata->seqno++);\n  if (idata->seqno > 9999)\n    idata->seqno = 0;\n\n  cmd->state = IMAP_CMD_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Server flags, e.g. #IMAP_CMD_POLL\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));\n\n    if (rc < 0 && rc != -2)\n      return rc;\n  }\n\n  struct ImapCommand *cmd = cmd_new(idata);\n  if (!cmd)\n    return IMAP_CMD_BAD;\n\n  if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_CMD_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapData is in fatal state, do what we can\n * @param idata Server data\n */\nstatic void cmd_handle_fatal(struct ImapData *idata)\n{\n  idata->status = IMAP_FATAL;\n\n  if ((idata->state >= IMAP_SELECTED) && (idata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(idata->ctx);\n    mutt_socket_close(idata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), idata->conn->account.login,\n               idata->conn->account.host);\n    idata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(idata);\n  if (!idata->recovering)\n  {\n    idata->recovering = true;\n    if (imap_conn_find(&idata->conn->account, 0))\n      mutt_clear_error();\n    idata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Command flags, e.g. #IMAP_CMD_QUEUE\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_start(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(idata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (idata->cmdbuf->dptr == idata->cmdbuf->data)\n    return IMAP_CMD_BAD;\n\n  rc = mutt_socket_send_d(idata->conn, idata->cmdbuf->data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  idata->cmdbuf->dptr = idata->cmdbuf->data;\n\n  /* unidle when command queue is flushed */\n  if (idata->state == IMAP_IDLE)\n    idata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_CMD_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_strncasecmp(\"OK\", s, 2) == 0)\n    return IMAP_CMD_OK;\n  if (mutt_str_strncasecmp(\"NO\", s, 2) == 0)\n    return IMAP_CMD_NO;\n\n  return IMAP_CMD_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param idata Server data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark idata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapData *idata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling EXPUNGE\\n\");\n\n  if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > idata->max_msn)\n    return;\n\n  h = idata->msn_index[exp_msn - 1];\n  if (h)\n  {\n    /* imap_expunge_mailbox() will rewrite h->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    h->index = INT_MAX;\n    HEADER_DATA(h)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)\n  {\n    h = idata->msn_index[cur];\n    if (h)\n      HEADER_DATA(h)->msn--;\n    idata->msn_index[cur - 1] = h;\n  }\n\n  idata->msn_index[idata->max_msn - 1] = NULL;\n  idata->max_msn--;\n\n  idata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapData\n * @param idata Server data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapData *idata, char *s)\n{\n  unsigned int msn, uid;\n  struct Header *h = NULL;\n  int server_changes = 0;\n\n  mutt_debug(3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0 || msn < 1 || msn > idata->max_msn)\n  {\n    mutt_debug(3, \"#1 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  h = idata->msn_index[msn - 1];\n  if (!h || !h->active)\n  {\n    mutt_debug(3, \"#2 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  mutt_debug(2, \"Message UID %u updated\\n\", HEADER_DATA(h)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      imap_set_flags(idata, h, s, &server_changes);\n      if (server_changes)\n      {\n        /* If server flags could conflict with neomutt's flags, reopen the mailbox. */\n        if (h->changed)\n          idata->reopen |= IMAP_EXPUNGE_PENDING;\n        else\n          idata->check_status = IMAP_FLAGS_PENDING;\n      }\n      return;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(2, \"Illegal UID.  Skipping update.\\n\");\n        return;\n      }\n      if (uid != HEADER_DATA(h)->uid)\n      {\n        mutt_debug(2, \"FETCH UID vs MSN mismatch.  Skipping update.\\n\");\n        return;\n      }\n      s = imap_next_word(s);\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(2, \"Only handle FLAGS updates\\n\");\n      return;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param idata Server data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapData *idata, char *s)\n{\n  mutt_debug(3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&idata->capstr);\n  idata->capstr = mutt_str_strdup(s);\n\n  memset(idata->capabilities, 0, sizeof(idata->capabilities));\n\n  while (*s)\n  {\n    for (int i = 0; i < CAPMAX; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        mutt_bit_set(idata->capabilities, i);\n        mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapData *idata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb;\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n    list = (struct ImapList *) idata->cmddata;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_strncasecmp(s, \"\\\\NoSelect\", 9) == 0)\n      list->noselect = true;\n    else if (mutt_str_strncasecmp(s, \"\\\\NoInferiors\", 12) == 0)\n      list->noinferiors = true;\n    /* See draft-gahrns-imap-child-mailbox-?? */\n    else if (mutt_str_strncasecmp(s, \"\\\\HasNoChildren\", 14) == 0)\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (mutt_str_strncasecmp(s, \"NIL\", 3) != 0)\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    list->name = idata->buf;\n  }\n  else\n  {\n    imap_unmunge_mbox_name(idata, s);\n    list->name = s;\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    idata->delim = list->delim;\n    mutt_debug(3, \"Root delimiter: %c\\n\", idata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param idata Server data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_ADMIN);\n        break;\n      case 'e':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      case 'i':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n        break;\n      case 'k':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        break;\n      case 'l':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n        break;\n      case 'p':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n        break;\n      case 'r':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n        break;\n      case 's':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n        break;\n      case 't':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        break;\n      case 'w':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n        break;\n      case 'x':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n      case 'd':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      default:\n        mutt_debug(1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * cmd_parse_search - store SEARCH response for later use\n * @param idata Server data\n * @param s     Command string with search results\n */\nstatic void cmd_parse_search(struct ImapData *idata, const char *s)\n{\n  unsigned int uid;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling SEARCH\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if (mutt_str_atoui(s, &uid) < 0)\n      continue;\n    h = (struct Header *) mutt_hash_int_find(idata->uid_hash, uid);\n    if (h)\n      h->matched = true;\n  }\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param idata Server data\n * @param s     Command string with status info\n *\n * first cut: just do buffy update. Later we may wish to cache all mailbox\n * information, even that not desired by buffy\n */\nstatic void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param idata Server data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||\n        (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))\n    {\n      idata->unicode = 1;\n    }\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapData *idata)\n{\n  unsigned int count = 0;\n  char *s = imap_next_word(idata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (mutt_str_strncasecmp(\"EXISTS\", s, 6) == 0)\n    {\n      mutt_debug(2, \"Handling EXISTS\\n\");\n\n      /* new mail arrived */\n      if (mutt_str_atoui(pn, &count) < 0)\n      {\n        mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);\n      }\n\n      if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n        mutt_debug(1, \"Message count is out of sync\\n\");\n        return 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n        mutt_debug(3, \"superfluous EXISTS message.\\n\");\n      else\n      {\n        if (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mailbox, count);\n          idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n        idata->new_mail_count = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge(idata, pn);\n    else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch(idata, pn);\n  }\n  else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability(idata, s);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)\n    cmd_parse_capability(idata, pn);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)\n    cmd_parse_capability(idata, imap_next_word(pn));\n  else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)\n    cmd_parse_list(idata, s);\n  else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub(idata, s);\n  else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights(idata, s);\n  else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)\n    cmd_parse_search(idata, s);\n  else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)\n    cmd_parse_status(idata, s);\n  else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled(idata, s);\n  else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)\n  {\n    mutt_debug(2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(idata);\n\n    return -1;\n  }\n  else if (ImapServernoise && (mutt_str_strncasecmp(\"NO\", s, 2) == 0))\n  {\n    mutt_debug(2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 3);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param idata  Server data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr)\n{\n  return cmd_start(idata, cmdstr, 0);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapData *idata)\n{\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return IMAP_CMD_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == idata->blen)\n    {\n      mutt_mem_realloc(&idata->buf, idata->blen + IMAP_CMD_BUFSIZE);\n      idata->blen = idata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(3, \"grew buffer to %u bytes\\n\", idata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln(idata->buf + len, idata->blen - len, idata->conn);\n    if (c <= 0)\n    {\n      mutt_debug(1, \"Error reading server response.\\n\");\n      cmd_handle_fatal(idata);\n      return IMAP_CMD_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == idata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((idata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&idata->buf, IMAP_CMD_BUFSIZE);\n    idata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(3, \"shrank buffer to %u bytes\\n\", idata->blen);\n  }\n\n  idata->lastread = time(NULL);\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if (((mutt_str_strncmp(idata->buf, \"* \", 2) == 0) ||\n       (mutt_str_strncmp(imap_next_word(idata->buf), \"OK [\", 4) == 0)) &&\n      cmd_handle_untagged(idata))\n  {\n    return IMAP_CMD_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (idata->buf[0] == '+')\n    return IMAP_CMD_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an idata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_CMD_OK;\n  c = idata->lastcmd;\n  do\n  {\n    cmd = &idata->cmds[c];\n    if (cmd->state == IMAP_CMD_NEW)\n    {\n      if (mutt_str_strncmp(idata->buf, cmd->seq, SEQLEN) == 0)\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          idata->lastcmd = (idata->lastcmd + 1) % idata->cmdslots;\n        }\n        cmd->state = cmd_status(idata->buf);\n        /* bogus - we don't know which command result to return here. Caller\n         * should provide a tag. */\n        rc = cmd->state;\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % idata->cmdslots;\n  } while (c != idata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_CMD_CONTINUE;\n  else\n  {\n    mutt_debug(3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(idata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return (cmd_status(s) == IMAP_CMD_OK);\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param idata Server data\n * @retval ptr Extra command information (pointer into idata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapData *idata)\n{\n  static const char *notrailer = \"\";\n  const char *s = idata->buf;\n\n  if (!s)\n  {\n    mutt_debug(2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || ((mutt_str_strncasecmp(s, \"OK\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))\n  {\n    mutt_debug(2, \"not a command completion: %s\\n\", idata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param idata  IMAP data\n * @param cmdstr Command to execute\n * @param flags  Flags (see below)\n * @retval  0 Success\n * @retval -1 Failure\n * @retval -2 OK Failure\n *\n * Also, handle untagged responses.\n *\n * Flags:\n * * IMAP_CMD_FAIL_OK: the calling procedure can handle failure.\n *       This is used for checking for a mailbox on append and login\n * * IMAP_CMD_PASS: command contains a password. Suppress logging.\n * * IMAP_CMD_QUEUE: only queue command, do not execute.\n * * IMAP_CMD_POLL: poll the socket for a response before running imap_cmd_step.\n */\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  rc = cmd_start(idata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&\n      (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(1);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  mutt_sig_allow_interrupt(0);\n\n  if (rc == IMAP_CMD_NO && (flags & IMAP_CMD_FAIL_OK))\n    return -2;\n\n  if (rc != IMAP_CMD_OK)\n  {\n    if ((flags & IMAP_CMD_FAIL_OK) && idata->status != IMAP_FATAL)\n      return -2;\n\n    mutt_debug(1, \"command failed: %s\\n\", idata->buf);\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param idata Server data\n *\n * Attempts to perform cleanup (eg fetch new mail if detected, do expunge).\n * Called automatically by imap_cmd_step(), but may be called at any time.\n * Called by imap_check_mailbox() just before the index is refreshed, for\n * instance.\n */\nvoid imap_cmd_finish(struct ImapData *idata)\n{\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return;\n  }\n\n  if (!(idata->state >= IMAP_SELECTED) || idata->ctx->closing)\n    return;\n\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    unsigned int count = idata->new_mail_count;\n\n    if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n        (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)\n    {\n      /* read new mail messages */\n      mutt_debug(2, \"Fetching new mail\\n\");\n      /* check_status: curs_main uses imap_check_mailbox to detect\n       *   whether the index needs updating */\n      idata->check_status = IMAP_NEWMAIL_PENDING;\n      imap_read_headers(idata, idata->max_msn + 1, count);\n    }\n    else if (idata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(idata);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))\n        idata->check_status = IMAP_EXPUNGE_PENDING;\n      idata->reopen &=\n          ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n  }\n\n  idata->status = false;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nint imap_cmd_idle(struct ImapData *idata)\n{\n  int rc;\n\n  if (cmd_start(idata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if ((ImapPollTimeout > 0) && (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    idata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_printf(idata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_CMD_OK;\n  }\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n", "/**\n * @file\n * IMAP network mailbox\n *\n * @authors\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_imap IMAP network mailbox\n *\n * Support for IMAP4rev1, with the occasional nod to IMAP 4.\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"imap.h\"\n#include \"auth.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"pattern.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"tags.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * check_capabilities - Make sure we can log in to this server\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int check_capabilities(struct ImapData *idata)\n{\n  if (imap_exec(idata, \"CAPABILITY\", 0) != 0)\n  {\n    imap_error(\"check_capabilities\", idata->buf);\n    return -1;\n  }\n\n  if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||\n        mutt_bit_isset(idata->capabilities, IMAP4REV1)))\n  {\n    mutt_error(\n        _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * get_flags - Make a simple list out of a FLAGS response\n * @param hflags List to store flags\n * @param s      String containing flags\n * @retval ptr End of the flags\n * @retval ptr NULL Failure\n *\n * return stream following FLAGS response\n */\nstatic char *get_flags(struct ListHead *hflags, char *s)\n{\n  /* sanity-check string */\n  if (mutt_str_strncasecmp(\"FLAGS\", s, 5) != 0)\n  {\n    mutt_debug(1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  /* update caller's flags handle */\n  while (*s && *s != ')')\n  {\n    s++;\n    SKIPWS(s);\n    const char *flag_word = s;\n    while (*s && (*s != ')') && !ISSPACE(*s))\n      s++;\n    const char ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_list_insert_tail(hflags, mutt_str_strdup(flag_word));\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    mutt_debug(1, \"Unterminated FLAGS response: %s\\n\", s);\n    mutt_list_free(hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\n/**\n * set_flag - append str to flags if we currently have permission according to aclbit\n * @param[in]  idata  Server data\n * @param[in]  aclbit Permissions, e.g. #MUTT_ACL_WRITE\n * @param[in]  flag   Does the email have the flag set?\n * @param[in]  str    Server flag name\n * @param[out] flags  Buffer for server command\n * @param[in]  flsize Length of buffer\n */\nstatic void set_flag(struct ImapData *idata, int aclbit, int flag,\n                     const char *str, char *flags, size_t flsize)\n{\n  if (mutt_bit_isset(idata->ctx->rights, aclbit))\n    if (flag && imap_has_flag(&idata->flags, str))\n      mutt_str_strcat(flags, flsize, str);\n}\n\n/**\n * make_msg_set - Make a message set\n * @param[in]  idata   Server data\n * @param[in]  buf     Buffer to store message set\n * @param[in]  flag    Flags to match, e.g. #MUTT_DELETED\n * @param[in]  changed Matched messages that have been altered\n * @param[in]  invert  Flag matches should be inverted\n * @param[out] pos     Cursor used for multiple calls to this function\n * @retval num Messages in the set\n *\n * @note Headers must be in SORT_ORDER. See imap_exec_msgset() for args.\n * Pos is an opaque pointer a la strtok(). It should be 0 at first call.\n */\nstatic int make_msg_set(struct ImapData *idata, struct Buffer *buf, int flag,\n                        bool changed, bool invert, int *pos)\n{\n  int count = 0;             /* number of messages in message set */\n  unsigned int setstart = 0; /* start of current message range */\n  int n;\n  bool started = false;\n  struct Header **hdrs = idata->ctx->hdrs;\n\n  for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)\n  {\n    bool match = false; /* whether current message matches flag condition */\n    /* don't include pending expunged messages */\n    if (hdrs[n]->active)\n    {\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)\n            match = invert ^ hdrs[n]->deleted;\n          break;\n        case MUTT_FLAG:\n          if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)\n            match = invert ^ hdrs[n]->flagged;\n          break;\n        case MUTT_OLD:\n          if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)\n            match = invert ^ hdrs[n]->old;\n          break;\n        case MUTT_READ:\n          if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)\n            match = invert ^ hdrs[n]->read;\n          break;\n        case MUTT_REPLIED:\n          if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)\n            match = invert ^ hdrs[n]->replied;\n          break;\n        case MUTT_TAG:\n          if (hdrs[n]->tagged)\n            match = true;\n          break;\n        case MUTT_TRASH:\n          if (hdrs[n]->deleted && !hdrs[n]->purge)\n            match = true;\n          break;\n      }\n    }\n\n    if (match && (!changed || hdrs[n]->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = HEADER_DATA(hdrs[n])->uid;\n        if (!started)\n        {\n          mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);\n          started = true;\n        }\n        else\n          mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);\n      }\n      /* tie up if the last message also matches */\n      else if (n == idata->ctx->msgcount - 1)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))\n    {\n      if (HEADER_DATA(hdrs[n - 1])->uid > setstart)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/**\n * compare_flags_for_copy - Compare local flags against the server\n * @param h Header of email\n * @retval true  Flags have changed\n * @retval false Flags match cached server flags\n *\n * The comparison of flags EXCLUDES the deleted flag.\n */\nstatic bool compare_flags_for_copy(struct Header *h)\n{\n  struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;\n\n  if (h->read != hd->read)\n    return true;\n  if (h->old != hd->old)\n    return true;\n  if (h->flagged != hd->flagged)\n    return true;\n  if (h->replied != hd->replied)\n    return true;\n\n  return false;\n}\n\n/**\n * sync_helper - Sync flag changes to the server\n * @param idata Server data\n * @param right ACL, e.g. #MUTT_ACL_DELETE\n * @param flag  Mutt flag, e.g. MUTT_DELETED\n * @param name  Name of server flag\n * @retval >=0 Success, number of messages\n * @retval  -1 Failure\n */\nstatic int sync_helper(struct ImapData *idata, int right, int flag, const char *name)\n{\n  int count = 0;\n  int rc;\n  char buf[LONG_STRING];\n\n  if (!idata->ctx)\n    return -1;\n\n  if (!mutt_bit_isset(idata->ctx->rights, right))\n    return 0;\n\n  if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/**\n * get_mailbox - Split mailbox URI\n * @param path   Mailbox URI\n * @param hidata Server data\n * @param buf    Buffer to store mailbox name\n * @param blen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Split up a mailbox URI.  The connection info is stored in the ImapData and\n * the mailbox name is stored in buf.\n */\nstatic int get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)\n{\n  struct ImapMbox mx;\n\n  if (imap_parse_path(path, &mx))\n  {\n    mutt_debug(1, \"Error parsing %s\\n\", path);\n    return -1;\n  }\n  if (!(*hidata = imap_conn_find(&(mx.account), ImapPassive ? MUTT_IMAP_CONN_NONEW : 0)) ||\n      (*hidata)->state < IMAP_AUTHENTICATED)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path(*hidata, mx.mbox, buf, blen);\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", blen);\n  FREE(&mx.mbox);\n\n  return 0;\n}\n\n/**\n * do_search - Perform a search of messages\n * @param search  List of pattern to match\n * @param allpats Must all patterns match?\n * @retval num Number of patterns search that should be done server-side\n *\n * Count the number of patterns that can be done by the server (are full-text).\n */\nstatic int do_search(const struct Pattern *search, int allpats)\n{\n  int rc = 0;\n  const struct Pattern *pat = NULL;\n\n  for (pat = search; pat; pat = pat->next)\n  {\n    switch (pat->op)\n    {\n      case MUTT_BODY:\n      case MUTT_HEADER:\n      case MUTT_WHOLE_MSG:\n        if (pat->stringmatch)\n          rc++;\n        break;\n      case MUTT_SERVERSEARCH:\n        rc++;\n        break;\n      default:\n        if (pat->child && do_search(pat->child, 1))\n          rc++;\n    }\n\n    if (!allpats)\n      break;\n  }\n\n  return rc;\n}\n\n/**\n * compile_search - Convert NeoMutt pattern to IMAP search\n * @param ctx Context\n * @param pat Pattern to convert\n * @param buf Buffer for result\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Convert neomutt Pattern to IMAP SEARCH command containing only elements\n * that require full-text search (neomutt already has what it needs for most\n * match types, and does a better job (eg server doesn't support regexes).\n */\nstatic int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * longest_common_prefix - Find longest prefix common to two strings\n * @param dest  Destination buffer\n * @param src   Source buffer\n * @param start Starting offset into string\n * @param dlen  Destination buffer length\n * @retval num Length of the common string\n *\n * Trim dest to the length of the longest prefix it shares with src.\n */\nstatic size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while (pos < dlen && dest[pos] && dest[pos] == src[pos])\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/**\n * complete_hosts - Look for completion matches for mailboxes\n * @param buf Partial mailbox name to complete\n * @param buflen  Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * look for IMAP URLs to complete from defined mailboxes. Could be extended to\n * complete over open connections and account/folder hooks too.\n */\nstatic int complete_hosts(char *buf, size_t buflen)\n{\n  struct Buffy *mailbox = NULL;\n  struct Connection *conn = NULL;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_str_strlen(buf);\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mutt_str_strncmp(buf, mailbox->path, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, mailbox->path, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, mailbox->path, matchlen, buflen);\n    }\n  }\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    struct Url url;\n    char urlstr[LONG_STRING];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl(&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_tostring(&url, urlstr, sizeof(urlstr), 0);\n    if (mutt_str_strncmp(buf, urlstr, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, urlstr, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, urlstr, matchlen, buflen);\n    }\n  }\n\n  return rc;\n}\n\n/**\n * imap_access - Check permissions on an IMAP mailbox\n * @param path Mailbox path\n * @retval  0 Success\n * @retval <0 Failure\n *\n * TODO: ACL checks. Right now we assume if it exists we can mess with it.\n */\nint imap_access(const char *path)\n{\n  struct ImapData *idata = NULL;\n  struct ImapMbox mx;\n  char buf[LONG_STRING];\n  char mailbox[LONG_STRING];\n  char mbox[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx))\n    return -1;\n\n  idata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n\n  /* we may already be in the folder we're checking */\n  if (mutt_str_strcmp(idata->mailbox, mx.mbox) == 0)\n  {\n    FREE(&mx.mbox);\n    return 0;\n  }\n  FREE(&mx.mbox);\n\n  if (imap_mboxcache_get(idata, mailbox, 0))\n  {\n    mutt_debug(3, \"found %s in cache\\n\", mailbox);\n    return 0;\n  }\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n\n  if (mutt_bit_isset(idata->capabilities, IMAP4REV1))\n    snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);\n  else if (mutt_bit_isset(idata->capabilities, STATUS))\n    snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);\n  else\n  {\n    mutt_debug(2, \"STATUS not supported?\\n\");\n    return -1;\n  }\n\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);\n  if (rc < 0)\n  {\n    mutt_debug(1, \"Can't check STATUS of %s\\n\", mbox);\n    return rc;\n  }\n\n  return 0;\n}\n\n/**\n * imap_create_mailbox - Create a new mailbox\n * @param idata   Server data\n * @param mailbox Mailbox to create\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_create_mailbox(struct ImapData *idata, char *mailbox)\n{\n  char buf[LONG_STRING], mbox[LONG_STRING];\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n  snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n  {\n    mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_rename_mailbox - Rename a mailbox\n * @param idata   Server data\n * @param mx      Existing mailbox\n * @param newname New name for mailbox\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)\n{\n  char oldmbox[LONG_STRING];\n  char newmbox[LONG_STRING];\n  char buf[LONG_STRING];\n\n  imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);\n  imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);\n\n  snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_delete_mailbox - Delete a mailbox\n * @param ctx Context\n * @param mx  Mailbox to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)\n{\n  char buf[PATH_MAX], mbox[PATH_MAX];\n  struct ImapData *idata = NULL;\n\n  if (!ctx || !ctx->data)\n  {\n    idata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);\n    if (!idata)\n    {\n      FREE(&mx->mbox);\n      return -1;\n    }\n  }\n  else\n  {\n    idata = ctx->data;\n  }\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);\n  snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_logout_all - close all open connections\n *\n * Quick and dirty until we can make sure we've got all the context we need.\n */\nvoid imap_logout_all(void)\n{\n  struct ConnectionList *head = mutt_socket_head();\n  struct Connection *np, *tmp;\n  TAILQ_FOREACH_SAFE(np, head, entries, tmp)\n  {\n    if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)\n    {\n      TAILQ_REMOVE(head, np, entries);\n      mutt_message(_(\"Closing connection to %s...\"), np->account.host);\n      imap_logout((struct ImapData **) (void *) &np->data);\n      mutt_clear_error();\n      mutt_socket_free(np);\n    }\n  }\n}\n\n/**\n * imap_read_literal - Read bytes bytes from server into file\n * @param fp    File handle for email file\n * @param idata Server data\n * @param bytes Number of bytes to read\n * @param pbar  Progress bar\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Not explicitly buffered, relies on FILE buffering.\n *\n * @note Strips `\\r` from `\\r\\n`.\n *       Apparently even literals use `\\r\\n`-terminated strings ?!\n */\nint imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes,\n                      struct Progress *pbar)\n{\n  char c;\n  bool r = false;\n  struct Buffer *buf = NULL;\n\n  if (DebugLevel >= IMAP_LOG_LTRL)\n    buf = mutt_buffer_alloc(bytes + 10);\n\n  mutt_debug(2, \"reading %ld bytes\\n\", bytes);\n\n  for (unsigned long pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar(idata->conn, &c) != 1)\n    {\n      mutt_debug(1, \"error during read, %ld bytes read\\n\", pos);\n      idata->status = IMAP_FATAL;\n\n      mutt_buffer_free(&buf);\n      return -1;\n    }\n\n    if (r && c != '\\n')\n      fputc('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = true;\n      continue;\n    }\n    else\n      r = false;\n\n    fputc(c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update(pbar, pos, -1);\n    if (DebugLevel >= IMAP_LOG_LTRL)\n      mutt_buffer_addch(buf, c);\n  }\n\n  if (DebugLevel >= IMAP_LOG_LTRL)\n  {\n    mutt_debug(IMAP_LOG_LTRL, \"\\n%s\", buf->data);\n    mutt_buffer_free(&buf);\n  }\n  return 0;\n}\n\n/**\n * imap_expunge_mailbox - Purge messages from the server\n * @param idata Server data\n *\n * Purge IMAP portion of expunged messages from the context. Must not be done\n * while something has a handle on any headers (eg inside pager or editor).\n * That is, check IMAP_REOPEN_ALLOW.\n */\nvoid imap_expunge_mailbox(struct ImapData *idata)\n{\n  struct Header *h = NULL;\n  int cacheno;\n  short old_sort;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n#endif\n\n  old_sort = Sort;\n  Sort = SORT_ORDER;\n  mutt_sort_headers(idata->ctx, 0);\n\n  for (int i = 0; i < idata->ctx->msgcount; i++)\n  {\n    h = idata->ctx->hdrs[i];\n\n    if (h->index == INT_MAX)\n    {\n      mutt_debug(2, \"Expunging message UID %u.\\n\", HEADER_DATA(h)->uid);\n\n      h->active = false;\n      idata->ctx->size -= h->content->length;\n\n      imap_cache_del(idata, h);\n#ifdef USE_HCACHE\n      imap_hcache_del(idata, HEADER_DATA(h)->uid);\n#endif\n\n      /* free cached body from disk, if necessary */\n      cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n      if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&\n          idata->cache[cacheno].path)\n      {\n        unlink(idata->cache[cacheno].path);\n        FREE(&idata->cache[cacheno].path);\n      }\n\n      mutt_hash_int_delete(idata->uid_hash, HEADER_DATA(h)->uid, h);\n\n      imap_free_header_data((struct ImapHeaderData **) &h->data);\n    }\n    else\n    {\n      h->index = i;\n      /* NeoMutt has several places where it turns off h->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The mx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.\n       */\n      h->active = true;\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(idata);\n#endif\n\n  /* We may be called on to expunge at any time. We can't rely on the caller\n   * to always know to rethread */\n  mx_update_tables(idata->ctx, false);\n  Sort = old_sort;\n  mutt_sort_headers(idata->ctx, 1);\n}\n\n/**\n * imap_conn_find - Find an open IMAP connection\n * @param account Account to search\n * @param flags   Flags, e.g. #MUTT_IMAP_CONN_NONEW\n * @retval ptr  Matching connection\n * @retval NULL Failure\n *\n * Find an open IMAP connection matching account, or open a new one if none can\n * be found.\n */\nstruct ImapData *imap_conn_find(const struct Account *account, int flags)\n{\n  struct Connection *conn = NULL;\n  struct Account *creds = NULL;\n  struct ImapData *idata = NULL;\n  bool new = false;\n\n  while ((conn = mutt_conn_find(conn, account)))\n  {\n    if (!creds)\n      creds = &conn->account;\n    else\n      memcpy(&conn->account, creds, sizeof(struct Account));\n\n    idata = conn->data;\n    if (flags & MUTT_IMAP_CONN_NONEW)\n    {\n      if (!idata)\n      {\n        /* This should only happen if we've come to the end of the list */\n        mutt_socket_free(conn);\n        return NULL;\n      }\n      else if (idata->state < IMAP_AUTHENTICATED)\n        continue;\n    }\n    if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)\n      continue;\n    if (idata && idata->status == IMAP_FATAL)\n      continue;\n    break;\n  }\n  if (!conn)\n    return NULL; /* this happens when the initial connection fails */\n\n  if (!idata)\n  {\n    /* The current connection is a new connection */\n    idata = imap_new_idata();\n    if (!idata)\n    {\n      mutt_socket_free(conn);\n      return NULL;\n    }\n\n    conn->data = idata;\n    idata->conn = conn;\n    new = true;\n  }\n\n  if (idata->state == IMAP_DISCONNECTED)\n    imap_open_connection(idata);\n  if (idata->state == IMAP_CONNECTED)\n  {\n    if (imap_authenticate(idata) == IMAP_AUTH_SUCCESS)\n    {\n      idata->state = IMAP_AUTHENTICATED;\n      FREE(&idata->capstr);\n      new = true;\n      if (idata->conn->ssf)\n        mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);\n    }\n    else\n      mutt_account_unsetpass(&idata->conn->account);\n  }\n  if (new && idata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);\n    /* enable RFC6855, if the server supports that */\n    if (mutt_bit_isset(idata->capabilities, ENABLE))\n      imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n    /* get root delimiter, '/' as default */\n    idata->delim = '/';\n    imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n  }\n\n  return idata;\n}\n\n/**\n * imap_open_connection - Open an IMAP connection\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_open_connection(struct ImapData *idata)\n{\n  char buf[LONG_STRING];\n\n  if (mutt_socket_open(idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection(idata);\n    return -1;\n  }\n\n  if (mutt_str_strncasecmp(\"* OK\", idata->buf, 4) == 0)\n  {\n    if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&\n        check_capabilities(idata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (SslForceTls || mutt_bit_isset(idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (SslForceTls)\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption(SslStarttls,\n                                      _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (rc == MUTT_YES)\n      {\n        rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);\n        if (rc == -1)\n          goto bail;\n        if (rc != -2)\n        {\n          if (mutt_ssl_starttls(idata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(idata, \"CAPABILITY\", 0))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (SslForceTls && !idata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(idata) != 0)\n      goto bail;\n    FREE(&idata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(idata);\n#endif\nbail:\n  FREE(&idata->capstr);\n  return -1;\n}\n\n/**\n * imap_close_connection - Close an IMAP connection\n * @param idata Server data\n */\nvoid imap_close_connection(struct ImapData *idata)\n{\n  if (idata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close(idata->conn);\n    idata->state = IMAP_DISCONNECTED;\n  }\n  idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;\n  memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);\n}\n\n/**\n * imap_logout - Gracefully log out of server\n * @param idata Server data\n */\nvoid imap_logout(struct ImapData **idata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  (*idata)->status = IMAP_BYE;\n  imap_cmd_start(*idata, \"LOGOUT\");\n  if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)\n  {\n    while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)\n      ;\n  }\n\n  mutt_socket_close((*idata)->conn);\n  imap_free_idata(idata);\n}\n\n/**\n * imap_has_flag - Does the flag exist in the list\n * @param flag_list List of server flags\n * @param flag      Flag to find\n * @retval true Flag exists\n *\n * Do a caseless comparison of the flag against a flag list, return true if\n * found or flag list has '\\*'.\n */\nbool imap_has_flag(struct ListHead *flag_list, const char *flag)\n{\n  if (STAILQ_EMPTY(flag_list))\n    return false;\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, flag_list, entries)\n  {\n    if (mutt_str_strncasecmp(np->data, flag, strlen(np->data)) == 0)\n      return true;\n\n    if (mutt_str_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * imap_exec_msgset - Prepare commands for all messages matching conditions\n * @param idata   ImapData containing context containing header set\n * @param pre     prefix commands\n * @param post    postfix commands\n * @param flag    flag type on which to filter, e.g. MUTT_REPLIED\n * @param changed include only changed messages in message set\n * @param invert  invert sense of flag, eg MUTT_READ matches unread messages\n * @retval num Matched messages\n * @retval -1  Failure\n *\n * pre/post: commands are of the form \"%s %s %s %s\", tag, pre, message set, post\n * Prepares commands for all messages matching conditions\n * (must be flushed with imap_exec)\n */\nint imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,\n                     int flag, int changed, int invert)\n{\n  struct Header **hdrs = NULL;\n  short oldsort;\n  int pos;\n  int rc;\n  int count = 0;\n\n  struct Buffer *cmd = mutt_buffer_new();\n\n  /* We make a copy of the headers just in case resorting doesn't give\n   exactly the original order (duplicate messages?), because other parts of\n   the ctx are tied to the header order. This may be overkill. */\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = idata->ctx->hdrs;\n    idata->ctx->hdrs = mutt_mem_malloc(idata->ctx->msgcount * sizeof(struct Header *));\n    memcpy(idata->ctx->hdrs, hdrs, idata->ctx->msgcount * sizeof(struct Header *));\n\n    Sort = SORT_ORDER;\n    qsort(idata->ctx->hdrs, idata->ctx->msgcount, sizeof(struct Header *),\n          mutt_get_sort_func(SORT_ORDER));\n  }\n\n  pos = 0;\n\n  do\n  {\n    cmd->dptr = cmd->data;\n    mutt_buffer_printf(cmd, \"%s \", pre);\n    rc = make_msg_set(idata, cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_printf(cmd, \" %s\", post);\n      if (imap_exec(idata, cmd->data, IMAP_CMD_QUEUE))\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  } while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_free(&cmd);\n  if (oldsort != Sort)\n  {\n    Sort = oldsort;\n    FREE(&idata->ctx->hdrs);\n    idata->ctx->hdrs = hdrs;\n  }\n\n  return rc;\n}\n\n/**\n * imap_sync_message_for_copy - Update server to reflect the flags of a single message\n * @param[in]  idata        Server data\n * @param[in]  hdr          Header of the email\n * @param[in]  cmd          Buffer for the command string\n * @param[out] err_continue Did the user force a continue?\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n *\n * @note This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy(struct ImapData *idata, struct Header *hdr,\n                               struct Buffer *cmd, int *err_continue)\n{\n  char flags[LONG_STRING];\n  char *tags;\n  char uid[11];\n\n  if (!compare_flags_for_copy(hdr))\n  {\n    if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n      hdr->changed = false;\n    return 0;\n  }\n\n  snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(hdr)->uid);\n  cmd->dptr = cmd->data;\n  mutt_buffer_addstr(cmd, \"UID STORE \");\n  mutt_buffer_addstr(cmd, uid);\n\n  flags[0] = '\\0';\n\n  set_flag(idata, MUTT_ACL_SEEN, hdr->read, \"\\\\Seen \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->old, \"Old \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->flagged, \"\\\\Flagged \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->replied, \"\\\\Answered \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_DELETE, HEADER_DATA(hdr)->deleted, \"\\\\Deleted \",\n           flags, sizeof(flags));\n\n  if (mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))\n  {\n    /* restore system flags */\n    if (HEADER_DATA(hdr)->flags_system)\n      mutt_str_strcat(flags, sizeof(flags), HEADER_DATA(hdr)->flags_system);\n    /* set custom flags */\n    tags = driver_tags_get_with_hidden(&hdr->tags);\n    if (tags)\n    {\n      mutt_str_strcat(flags, sizeof(flags), tags);\n      FREE(&tags);\n    }\n  }\n\n  mutt_str_remove_trailing_ws(flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (!*flags)\n  {\n    set_flag(idata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_DELETE, !HEADER_DATA(hdr)->deleted, \"\\\\Deleted \",\n             flags, sizeof(flags));\n\n    /* erase custom flags */\n    if (mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) && HEADER_DATA(hdr)->flags_remote)\n      mutt_str_strcat(flags, sizeof(flags), HEADER_DATA(hdr)->flags_remote);\n\n    mutt_str_remove_trailing_ws(flags);\n\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr(cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr(cmd, flags);\n  mutt_buffer_addstr(cmd, \")\");\n\n  /* dumb hack for bad UW-IMAP 4.7 servers spurious FLAGS updates */\n  hdr->active = false;\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec(idata, cmd->data, 0) != 0) && err_continue &&\n      (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue(\"imap_sync_message: STORE failed\", idata->buf);\n    if (*err_continue != MUTT_YES)\n    {\n      hdr->active = true;\n      return -1;\n    }\n  }\n\n  /* server have now the updated flags */\n  FREE(&HEADER_DATA(hdr)->flags_remote);\n  HEADER_DATA(hdr)->flags_remote = driver_tags_get_with_hidden(&hdr->tags);\n\n  hdr->active = true;\n  if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n    hdr->changed = false;\n\n  return 0;\n}\n\n/**\n * imap_check_mailbox - use the NOOP or IDLE command to poll for new mail\n * @param ctx   Context\n * @param force Don't wait\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval 0               no change\n * @retval -1              error\n */\nint imap_check_mailbox(struct Context *ctx, int force)\n{\n  return imap_check(ctx->data, force);\n}\n\n/**\n * imap_check - Check for new mail\n * @param idata Server data\n * @param force Force a refresh\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nint imap_check(struct ImapData *idata, int force)\n{\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  int result = 0;\n\n  /* try IDLE first, unless force is set */\n  if (!force && ImapIdle && mutt_bit_isset(idata->capabilities, IDLE) &&\n      (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))\n  {\n    if (imap_cmd_idle(idata) < 0)\n      return -1;\n  }\n  if (idata->state == IMAP_IDLE)\n  {\n    while ((result = mutt_socket_poll(idata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n      {\n        mutt_debug(1, \"Error reading IDLE response\\n\");\n        return -1;\n      }\n    }\n    if (result < 0)\n    {\n      mutt_debug(1, \"Poll failed, disabling IDLE\\n\");\n      mutt_bit_unset(idata->capabilities, IDLE);\n    }\n  }\n\n  if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&\n      imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)\n  {\n    return -1;\n  }\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish(idata);\n\n  if (idata->check_status & IMAP_EXPUNGE_PENDING)\n    result = MUTT_REOPENED;\n  else if (idata->check_status & IMAP_NEWMAIL_PENDING)\n    result = MUTT_NEW_MAIL;\n  else if (idata->check_status & IMAP_FLAGS_PENDING)\n    result = MUTT_FLAGS;\n\n  idata->check_status = 0;\n\n  return result;\n}\n\n/**\n * imap_buffy_check - Check for new mail in subscribed folders\n * @param check_stats Check for message stats too\n * @retval num Number of mailboxes with new mail\n * @retval 0   Failure\n *\n * Given a list of mailboxes rather than called once for each so that it can\n * batch the commands and save on round trips.\n */\nint imap_buffy_check(int check_stats)\n{\n  struct ImapData *idata = NULL;\n  struct ImapData *lastdata = NULL;\n  struct Buffy *mailbox = NULL;\n  char name[LONG_STRING];\n  char command[LONG_STRING];\n  char munged[LONG_STRING];\n  int buffies = 0;\n\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    /* Init newly-added mailboxes */\n    if (!mailbox->magic)\n    {\n      if (mx_is_imap(mailbox->path))\n        mailbox->magic = MUTT_IMAP;\n    }\n\n    if (mailbox->magic != MUTT_IMAP)\n      continue;\n\n    if (get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n     * IDLEd elsewhere.\n     * idata->mailbox may be NULL for connections other than the current\n     * mailbox's, and shouldn't expand to INBOX in that case. #3216. */\n    if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&\n        !mutt_bit_isset(idata->capabilities, STATUS))\n    {\n      mutt_debug(2, \"Server doesn't support STATUS\\n\");\n      continue;\n    }\n\n    if (lastdata && idata != lastdata)\n    {\n      /* Send commands to previous server. Sorting the buffy list\n       * may prevent some infelicitous interleavings */\n      if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)\n        mutt_debug(1, \"#1 Error polling mailboxes\\n\");\n\n      lastdata = NULL;\n    }\n\n    if (!lastdata)\n      lastdata = idata;\n\n    imap_munge_mbox_name(idata, munged, sizeof(munged), name);\n    if (check_stats)\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);\n    }\n    else\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);\n    }\n\n    if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)\n    {\n      mutt_debug(1, \"Error queueing command\\n\");\n      return 0;\n    }\n  }\n\n  if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))\n  {\n    mutt_debug(1, \"#2 Error polling mailboxes\\n\");\n    return 0;\n  }\n\n  /* collect results */\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mailbox->magic == MUTT_IMAP && mailbox->new)\n      buffies++;\n  }\n\n  return buffies;\n}\n\n/**\n * imap_status - Get the status of a mailbox\n * @param path  Path of mailbox\n * @param queue true if the command should be queued for the next call\n * @retval -1  Error\n * @retval >=0 Count of messages in mailbox\n *\n * If queue is true, the command will be sent now and be expected to have been\n * run on the next call (for pipelining the postponed count).\n */\nint imap_status(char *path, int queue)\n{\n  static int queued = 0;\n\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  struct ImapStatus *status = NULL;\n\n  if (get_mailbox(path, &idata, buf, sizeof(buf)) < 0)\n    return -1;\n\n  /* We are in the folder we're polling - just return the mailbox count.\n   *\n   * Note that imap_mxcmp() converts NULL to \"INBOX\", so we need to\n   * make sure the idata really is open to a folder. */\n  if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))\n    return idata->ctx->msgcount;\n  else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||\n           mutt_bit_isset(idata->capabilities, STATUS))\n  {\n    imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n    snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");\n    imap_unmunge_mbox_name(idata, mbox);\n  }\n  else\n  {\n    /* Server does not support STATUS, and this is not the current mailbox.\n     * There is no lightweight way to check recent arrivals */\n    return -1;\n  }\n\n  if (queue)\n  {\n    imap_exec(idata, buf, IMAP_CMD_QUEUE);\n    queued = 1;\n    return 0;\n  }\n  else if (!queued)\n    imap_exec(idata, buf, 0);\n\n  queued = 0;\n  status = imap_mboxcache_get(idata, mbox, 0);\n  if (status)\n    return status->messages;\n\n  return 0;\n}\n\n/**\n * imap_mboxcache_get - Open an hcache for a mailbox\n * @param idata  Server data\n * @param mbox   Mailbox to cache\n * @param create Should it be created if it doesn't exist?\n * @retval ptr  Stats of cached mailbox\n * @retval ptr  Stats of new cache entry\n * @retval NULL Not in cache and create is false\n *\n * return cached mailbox stats or NULL if create is 0\n */\nstruct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create)\n{\n  struct ImapStatus *status = NULL;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n  void *uidvalidity = NULL;\n  void *uidnext = NULL;\n#endif\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, &idata->mboxcache, entries)\n  {\n    status = (struct ImapStatus *) np->data;\n\n    if (imap_mxcmp(mbox, status->name) == 0)\n      return status;\n  }\n  status = NULL;\n\n  /* lame */\n  if (create)\n  {\n    struct ImapStatus *scache = mutt_mem_calloc(1, sizeof(struct ImapStatus));\n    scache->name = (char *) mbox;\n    mutt_list_insert_tail(&idata->mboxcache, (char *) scache);\n    status = imap_mboxcache_get(idata, mbox, 0);\n    status->name = mutt_str_strdup(mbox);\n  }\n\n#ifdef USE_HCACHE\n  hc = imap_hcache_open(idata, mbox);\n  if (hc)\n  {\n    uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);\n    uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);\n    if (uidvalidity)\n    {\n      if (!status)\n      {\n        mutt_hcache_free(hc, &uidvalidity);\n        mutt_hcache_free(hc, &uidnext);\n        mutt_hcache_close(hc);\n        return imap_mboxcache_get(idata, mbox, 1);\n      }\n      status->uidvalidity = *(unsigned int *) uidvalidity;\n      status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;\n      mutt_debug(3, \"hcache uidvalidity %u, uidnext %u\\n\", status->uidvalidity,\n                 status->uidnext);\n    }\n    mutt_hcache_free(hc, &uidvalidity);\n    mutt_hcache_free(hc, &uidnext);\n    mutt_hcache_close(hc);\n  }\n#endif\n\n  return status;\n}\n\n/**\n * imap_mboxcache_free - Free the cached ImapStatus\n * @param idata Server data\n */\nvoid imap_mboxcache_free(struct ImapData *idata)\n{\n  struct ImapStatus *status = NULL;\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, &idata->mboxcache, entries)\n  {\n    status = (struct ImapStatus *) np->data;\n    FREE(&status->name);\n  }\n\n  mutt_list_free(&idata->mboxcache);\n}\n\n/**\n * imap_search - Find a matching mailbox\n * @param ctx Context\n * @param pat Pattern to match\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_search(struct Context *ctx, const struct Pattern *pat)\n{\n  struct Buffer buf;\n  struct ImapData *idata = ctx->data;\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->matched = false;\n\n  if (do_search(pat, 1) == 0)\n    return 0;\n\n  mutt_buffer_init(&buf);\n  mutt_buffer_addstr(&buf, \"UID SEARCH \");\n  if (compile_search(ctx, pat, &buf) < 0)\n  {\n    FREE(&buf.data);\n    return -1;\n  }\n  if (imap_exec(idata, buf.data, 0) < 0)\n  {\n    FREE(&buf.data);\n    return -1;\n  }\n\n  FREE(&buf.data);\n  return 0;\n}\n\n/**\n * imap_subscribe - Subscribe to a mailbox\n * @param path      Mailbox path\n * @param subscribe True: subscribe, false: unsubscribe\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_complete - Try to complete an IMAP folder path\n * @param buf Buffer for result\n * @param buflen Length of buffer\n * @param path Partial mailbox name to complete\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given a partial IMAP folder path, return a string which adds as much to the\n * path as is unique\n */\nint imap_complete(char *buf, size_t buflen, char *path)\n{\n  struct ImapData *idata = NULL;\n  char list[LONG_STRING];\n  char tmp[LONG_STRING];\n  struct ImapList listresp;\n  char completion[LONG_STRING];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  struct ImapMbox mx;\n  int rc;\n\n  if (imap_parse_path(path, &mx))\n  {\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* don't open a new socket just for completion. Instead complete over\n   * known mailboxes/hooks/etc */\n  idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* reformat path for IMAP list, and append wildcard */\n  /* don't use INBOX in place of \"\" */\n  if (mx.mbox && mx.mbox[0])\n    imap_fix_path(idata, mx.mbox, list, sizeof(list));\n  else\n    list[0] = '\\0';\n\n  /* fire off command */\n  snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\", ImapListSubscribed ? \"LSUB\" : \"LIST\", list);\n\n  imap_cmd_start(idata, tmp);\n\n  /* and see what the results are */\n  mutt_str_strfcpy(completion, NONULL(mx.mbox), sizeof(completion));\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step(idata);\n\n    if (rc == IMAP_CMD_CONTINUE && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        mutt_str_strfcpy(completion, listresp.name, sizeof(completion));\n        matchlen = strlen(completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n  idata->cmddata = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path(buf, buflen, &mx, completion);\n    mutt_pretty_mailbox(buf, buflen);\n\n    FREE(&mx.mbox);\n    return 0;\n  }\n\n  return -1;\n}\n\n/**\n * imap_fast_trash - Use server COPY command to copy deleted messages to trash\n * @param ctx  Context\n * @param dest Mailbox to move to\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_fast_trash(struct Context *ctx, char *dest)\n{\n  char mbox[LONG_STRING];\n  char mmbox[LONG_STRING];\n  char prompt[LONG_STRING];\n  int rc;\n  struct ImapMbox mx;\n  bool triedcreate = false;\n  struct Buffer *sync_cmd = NULL;\n  int err_continue = MUTT_NO;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(dest, &mx))\n  {\n    mutt_debug(1, \"bad destination %s\\n\", dest);\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)\n  {\n    mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->path);\n    return 1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n  if (!*mbox)\n    mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));\n  imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);\n\n  sync_cmd = mutt_buffer_new();\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&\n        ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)\n    {\n      rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        mutt_debug(1, \"could not sync\\n\");\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);\n    if (!rc)\n    {\n      mutt_debug(1, \"No messages to trash\\n\");\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      mutt_debug(1, \"could not queue copy\\n\");\n      goto out;\n    }\n    else\n    {\n      mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                   rc, mbox);\n    }\n\n    /* let's get it on */\n    rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)\n        break;\n      mutt_debug(3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);\n      if (Confirmcreate && mutt_yesorno(prompt, 1) != MUTT_YES)\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(idata, mbox) < 0)\n        break;\n      triedcreate = true;\n    }\n  } while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error(\"imap_fast_trash\", idata->buf);\n    goto out;\n  }\n\n  rc = 0;\n\nout:\n  mutt_buffer_free(&sync_cmd);\n  FREE(&mx.mbox);\n\n  return (rc < 0) ? -1 : rc;\n}\n\n/**\n * imap_mbox_open - Implements MxOps::mbox_open()\n */\nstatic int imap_mbox_open(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  struct ImapStatus *status = NULL;\n  char buf[PATH_MAX];\n  char bufout[PATH_MAX];\n  int count = 0;\n  struct ImapMbox mx, pmx;\n  int rc;\n\n  if (imap_parse_path(ctx->path, &mx))\n  {\n    mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);\n    return -1;\n  }\n\n  /* we require a connection which isn't currently in IMAP_SELECTED state */\n  idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);\n  if (!idata)\n    goto fail_noidata;\n  if (idata->state < IMAP_AUTHENTICATED)\n    goto fail;\n\n  /* once again the context is new */\n  ctx->data = idata;\n\n  /* Clean up path and replace the one in the ctx */\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  FREE(&(idata->mailbox));\n  idata->mailbox = mutt_str_strdup(buf);\n  imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);\n\n  FREE(&(ctx->path));\n  FREE(&(ctx->realpath));\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  idata->ctx = ctx;\n\n  /* clear mailbox status */\n  idata->status = false;\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n  idata->new_mail_count = 0;\n  idata->max_msn = 0;\n\n  mutt_message(_(\"Selecting %s...\"), idata->mailbox);\n  imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);\n\n  /* pipeline ACL test */\n  if (mutt_bit_isset(idata->capabilities, ACL))\n  {\n    snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);\n    imap_exec(idata, bufout, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n  }\n  /* pipeline the postponed count if possible */\n  pmx.mbox = NULL;\n  if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&\n      mutt_account_match(&pmx.account, &mx.account))\n  {\n    imap_status(Postponed, 1);\n  }\n  FREE(&pmx.mbox);\n\n  if (ImapCheckSubscribed)\n    imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n  snprintf(bufout, sizeof(bufout), \"%s %s\", ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);\n\n  idata->state = IMAP_SELECTED;\n\n  imap_cmd_start(idata, bufout);\n\n  status = imap_mboxcache_get(idata, idata->mailbox, 1);\n\n  do\n  {\n    char *pc = NULL;\n\n    rc = imap_cmd_step(idata);\n    if (rc != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0)\n    {\n      /* don't override PERMANENTFLAGS */\n      if (STAILQ_EMPTY(&idata->flags))\n      {\n        mutt_debug(3, \"Getting mailbox FLAGS\\n\");\n        pc = get_flags(&idata->flags, pc);\n        if (!pc)\n          goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (mutt_str_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");\n      /* safe to call on NULL */\n      mutt_list_free(&idata->flags);\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      pc = get_flags(&(idata->flags), pc);\n      if (!pc)\n        goto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (mutt_str_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &idata->uid_validity) < 0)\n        goto fail;\n      status->uidvalidity = idata->uid_validity;\n    }\n    else if (mutt_str_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &idata->uidnext) < 0)\n        goto fail;\n      status->uidnext = idata->uidnext;\n    }\n    else\n    {\n      pc = imap_next_word(pc);\n      if (mutt_str_strncasecmp(\"EXISTS\", pc, 6) == 0)\n      {\n        count = idata->new_mail_count;\n        idata->new_mail_count = 0;\n      }\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_NO)\n  {\n    char *s = imap_next_word(idata->buf); /* skip seq */\n    s = imap_next_word(s);                /* Skip response */\n    mutt_error(\"%s\", s);\n    goto fail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if ((mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&\n      !mutt_bit_isset(idata->capabilities, ACL))\n  {\n    mutt_debug(2, \"Mailbox is read-only.\\n\");\n    ctx->readonly = true;\n  }\n\n  /* dump the mailbox flags we've found */\n  if (DebugLevel > 2)\n  {\n    if (STAILQ_EMPTY(&idata->flags))\n      mutt_debug(3, \"No folder flags found\\n\");\n    else\n    {\n      struct ListNode *np;\n      struct Buffer flag_buffer;\n      mutt_buffer_init(&flag_buffer);\n      mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");\n      STAILQ_FOREACH(np, &idata->flags, entries)\n      {\n        mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);\n      }\n      mutt_debug(3, \"%s\\n\", flag_buffer.data);\n      FREE(&flag_buffer.data);\n    }\n  }\n\n  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))\n  {\n    ctx->readonly = true;\n  }\n\n  ctx->hdrmax = count;\n  ctx->hdrs = mutt_mem_calloc(count, sizeof(struct Header *));\n  ctx->v2r = mutt_mem_calloc(count, sizeof(int));\n  ctx->msgcount = 0;\n\n  if (count && (imap_read_headers(idata, 1, count) < 0))\n  {\n    mutt_error(_(\"Error opening mailbox\"));\n    goto fail;\n  }\n\n  mutt_debug(2, \"msgcount is %d\\n\", ctx->msgcount);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  if (idata->state == IMAP_SELECTED)\n    idata->state = IMAP_AUTHENTICATED;\nfail_noidata:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_mbox_open_append - Implements MxOps::mbox_open_append()\n */\nstatic int imap_mbox_open_append(struct Context *ctx, int flags)\n{\n  struct ImapData *idata = NULL;\n  char mailbox[PATH_MAX];\n  struct ImapMbox mx;\n  int rc;\n\n  if (imap_parse_path(ctx->path, &mx))\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  ctx->data = idata;\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n  FREE(&mx.mbox);\n\n  rc = imap_access(ctx->path);\n  if (rc == 0)\n    return 0;\n\n  if (rc == -1)\n    return -1;\n\n  char buf[PATH_MAX + 64];\n  snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);\n  if (Confirmcreate && mutt_yesorno(buf, 1) != MUTT_YES)\n    return -1;\n\n  if (imap_create_mailbox(idata, mailbox) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_close - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int imap_mbox_close(struct Context *ctx)\n{\n  struct ImapData *idata = ctx->data;\n  /* Check to see if the mailbox is actually open */\n  if (!idata)\n    return 0;\n\n  /* imap_mbox_open_append() borrows the struct ImapData temporarily,\n   * just for the connection, but does not set idata->ctx to the\n   * open-append ctx.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up idata.  Otherwise, we don't want to\n   * touch idata - it's still being used.\n   */\n  if (ctx == idata->ctx)\n  {\n    if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)\n    {\n      /* mx_mbox_close won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (!ctx->deleted)\n        imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);\n      idata->state = IMAP_AUTHENTICATED;\n    }\n\n    idata->reopen &= IMAP_REOPEN_ALLOW;\n    FREE(&(idata->mailbox));\n    mutt_list_free(&idata->flags);\n    idata->ctx = NULL;\n\n    mutt_hash_destroy(&idata->uid_hash);\n    FREE(&idata->msn_index);\n    idata->msn_index_size = 0;\n    idata->max_msn = 0;\n\n    for (int i = 0; i < IMAP_CACHE_LEN; i++)\n    {\n      if (idata->cache[i].path)\n      {\n        unlink(idata->cache[i].path);\n        FREE(&idata->cache[i].path);\n      }\n    }\n\n    mutt_bcache_close(&idata->bcache);\n  }\n\n  /* free IMAP part of headers */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* mailbox may not have fully loaded */\n    if (ctx->hdrs[i] && ctx->hdrs[i]->data)\n      imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));\n  }\n\n  return 0;\n}\n\n/**\n * imap_msg_open_new - Implements MxOps::msg_open_new()\n */\nstatic int imap_msg_open_new(struct Context *ctx, struct Message *msg, struct Header *hdr)\n{\n  char tmp[PATH_MAX];\n\n  mutt_mktemp(tmp, sizeof(tmp));\n  msg->fp = mutt_file_fopen(tmp, \"w\");\n  if (!msg->fp)\n  {\n    mutt_perror(tmp);\n    return -1;\n  }\n  msg->path = mutt_str_strdup(tmp);\n  return 0;\n}\n\n/**\n * imap_mbox_check - Implements MxOps::mbox_check()\n * @param ctx        Context\n * @param index_hint Remember our place in the index\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nstatic int imap_mbox_check(struct Context *ctx, int *index_hint)\n{\n  int rc;\n  (void) index_hint;\n\n  imap_allow_reopen(ctx);\n  rc = imap_check(ctx->data, 0);\n  imap_disallow_reopen(ctx);\n\n  return rc;\n}\n\n/**\n * imap_sync_mailbox - Sync all the changes to the server\n * @param ctx     Context\n * @param expunge 0 or 1 - do expunge?\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_sync_mailbox(struct Context *ctx, int expunge)\n{\n  struct Context *appendctx = NULL;\n  struct Header *h = NULL;\n  struct Header **hdrs = NULL;\n  int oldsort;\n  int rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (idata->state < IMAP_SELECTED)\n  {\n    mutt_debug(2, \"no mailbox selected\\n\");\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen(ctx);\n\n  rc = imap_check(idata, 0);\n  if (rc != 0)\n    return rc;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                          MUTT_DELETED, 1, 0);\n    if (rc < 0)\n    {\n      mutt_error(_(\"Expunge failed\"));\n      goto out;\n    }\n\n    if (rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (int i = 0; i < ctx->msgcount; i++)\n        if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)\n          ctx->hdrs[i]->active = false;\n      mutt_message(ngettext(\"Marking %d message deleted...\",\n                            \"Marking %d messages deleted...\", rc),\n                   rc);\n    }\n  }\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    h = ctx->hdrs[i];\n\n    if (h->deleted)\n    {\n      imap_cache_del(idata, h);\n#ifdef USE_HCACHE\n      imap_hcache_del(idata, HEADER_DATA(h)->uid);\n#endif\n    }\n\n    if (h->active && h->changed)\n    {\n#ifdef USE_HCACHE\n      imap_hcache_put(idata, h);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||\n          h->attach_del || h->xlabel_changed)\n      {\n        /* L10N: The plural is choosen by the last %d, i.e. the total number */\n        mutt_message(ngettext(\"Saving changed message... [%d/%d]\",\n                              \"Saving changed messages... [%d/%d]\", ctx->msgcount),\n                     i + 1, ctx->msgcount);\n        if (!appendctx)\n          appendctx = mx_mbox_open(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);\n        if (!appendctx)\n          mutt_debug(1, \"Error opening mailbox in append mode\\n\");\n        else\n          mutt_save_message_ctx(h, 1, 0, 0, appendctx);\n        h->xlabel_changed = false;\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(idata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset */\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = ctx->hdrs;\n    ctx->hdrs = mutt_mem_malloc(ctx->msgcount * sizeof(struct Header *));\n    memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));\n\n    Sort = SORT_ORDER;\n    qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));\n  }\n\n  rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if (oldsort != Sort)\n  {\n    Sort = oldsort;\n    FREE(&ctx->hdrs);\n    ctx->hdrs = hdrs;\n  }\n\n  /* Flush the queued flags if any were changed in sync_helper. */\n  if (rc > 0)\n    if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (ctx->closing)\n    {\n      if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)\n      {\n        rc = 0;\n        idata->state = IMAP_AUTHENTICATED;\n        goto out;\n      }\n    }\n    else\n      mutt_error(_(\"Error saving flags\"));\n    rc = -1;\n    goto out;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;\n    HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;\n    HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;\n    HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;\n    HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;\n    ctx->hdrs[i]->changed = false;\n  }\n  ctx->changed = false;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    mutt_message(_(\"Expunging messages from server...\"));\n    /* Set expunge bit so we don't get spurious reopened messages */\n    idata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec(idata, \"EXPUNGE\", 0) != 0)\n    {\n      idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);\n      rc = -1;\n      goto out;\n    }\n    idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && ctx->closing)\n  {\n    imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);\n    idata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (MessageCacheClean)\n    imap_cache_clean(idata);\n\n  rc = 0;\n\nout:\n  if (appendctx)\n  {\n    mx_fastclose_mailbox(appendctx);\n    FREE(&appendctx);\n  }\n  return rc;\n}\n\n/**\n * imap_tags_edit - Implements MxOps::tags_edit()\n */\nstatic int imap_tags_edit(struct Context *ctx, const char *tags, char *buf, size_t buflen)\n{\n  char *new = NULL;\n  char *checker = NULL;\n  struct ImapData *idata = (struct ImapData *) ctx->data;\n\n  /* Check for \\* flags capability */\n  if (!imap_has_flag(&idata->flags, NULL))\n  {\n    mutt_error(_(\"IMAP server doesn't support custom flags\"));\n    return -1;\n  }\n\n  *buf = '\\0';\n  if (tags)\n    strncpy(buf, tags, buflen);\n\n  if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)\n    return -1;\n\n  /* each keyword must be atom defined by rfc822 as:\n   *\n   * atom           = 1*<any CHAR except specials, SPACE and CTLs>\n   * CHAR           = ( 0.-127. )\n   * specials       = \"(\" / \")\" / \"<\" / \">\" / \"@\"\n   *                  / \",\" / \";\" / \":\" / \"\\\" / <\">\n   *                  / \".\" / \"[\" / \"]\"\n   * SPACE          = ( 32. )\n   * CTLS           = ( 0.-31., 127.)\n   *\n   * And must be separated by one space.\n   */\n\n  new = buf;\n  checker = buf;\n  SKIPWS(checker);\n  while (*checker != '\\0')\n  {\n    if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator\n        *checker == 40 ||                   // (\n        *checker == 41 ||                   // )\n        *checker == 60 ||                   // <\n        *checker == 62 ||                   // >\n        *checker == 64 ||                   // @\n        *checker == 44 ||                   // ,\n        *checker == 59 ||                   // ;\n        *checker == 58 ||                   // :\n        *checker == 92 ||                   // backslash\n        *checker == 34 ||                   // \"\n        *checker == 46 ||                   // .\n        *checker == 91 ||                   // [\n        *checker == 93)                     // ]\n    {\n      mutt_error(_(\"Invalid IMAP flags\"));\n      return 0;\n    }\n\n    /* Skip duplicate space */\n    while (*checker == ' ' && *(checker + 1) == ' ')\n      checker++;\n\n    /* copy char to new and go the next one */\n    *new ++ = *checker++;\n  }\n  *new = '\\0';\n  new = buf; /* rewind */\n  mutt_str_remove_trailing_ws(new);\n\n  if (mutt_str_strcmp(tags, buf) == 0)\n    return 0;\n  return 1;\n}\n\n/**\n * imap_tags_commit - Implements MxOps::tags_commit()\n *\n * This method update the server flags on the server by\n * removing the last know custom flags of a header\n * and adds the local flags\n *\n * If everything success we push the local flags to the\n * last know custom flags (flags_remote).\n *\n * Also this method check that each flags is support by the server\n * first and remove unsupported one.\n */\nstatic int imap_tags_commit(struct Context *ctx, struct Header *hdr, char *buf)\n{\n  struct Buffer *cmd = NULL;\n  char uid[11];\n\n  struct ImapData *idata = ctx->data;\n\n  if (*buf == '\\0')\n    buf = NULL;\n\n  if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))\n    return 0;\n\n  snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(hdr)->uid);\n\n  /* Remove old custom flags */\n  if (HEADER_DATA(hdr)->flags_remote)\n  {\n    cmd = mutt_buffer_new();\n    if (!cmd)\n    {\n      mutt_debug(1, \"unable to allocate buffer\\n\");\n      return -1;\n    }\n    cmd->dptr = cmd->data;\n    mutt_buffer_addstr(cmd, \"UID STORE \");\n    mutt_buffer_addstr(cmd, uid);\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n    mutt_buffer_addstr(cmd, HEADER_DATA(hdr)->flags_remote);\n    mutt_buffer_addstr(cmd, \")\");\n\n    /* Should we return here, or we are fine and we could\n     * continue to add new flags *\n     */\n    if (imap_exec(idata, cmd->data, 0) != 0)\n    {\n      mutt_buffer_free(&cmd);\n      return -1;\n    }\n\n    mutt_buffer_free(&cmd);\n  }\n\n  /* Add new custom flags */\n  if (buf)\n  {\n    cmd = mutt_buffer_new();\n    if (!cmd)\n    {\n      mutt_debug(1, \"fail to remove old flags\\n\");\n      return -1;\n    }\n    cmd->dptr = cmd->data;\n    mutt_buffer_addstr(cmd, \"UID STORE \");\n    mutt_buffer_addstr(cmd, uid);\n    mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");\n    mutt_buffer_addstr(cmd, buf);\n    mutt_buffer_addstr(cmd, \")\");\n\n    if (imap_exec(idata, cmd->data, 0) != 0)\n    {\n      mutt_debug(1, \"fail to add new flags\\n\");\n      mutt_buffer_free(&cmd);\n      return -1;\n    }\n\n    mutt_buffer_free(&cmd);\n  }\n\n  /* We are good sync them */\n  mutt_debug(1, \"NEW TAGS: %d\\n\", buf);\n  driver_tags_replace(&hdr->tags, buf);\n  FREE(&HEADER_DATA(hdr)->flags_remote);\n  HEADER_DATA(hdr)->flags_remote = driver_tags_get_with_hidden(&hdr->tags);\n  return 0;\n}\n\n// clang-format off\n/**\n * struct mx_imap_ops - Mailbox callback functions for IMAP mailboxes\n */\nstruct MxOps mx_imap_ops = {\n  .mbox_open        = imap_mbox_open,\n  .mbox_open_append = imap_mbox_open_append,\n  .mbox_check       = imap_mbox_check,\n  .mbox_sync        = NULL, /* imap syncing is handled by imap_sync_mailbox */\n  .mbox_close       = imap_mbox_close,\n  .msg_open         = imap_msg_open,\n  .msg_open_new     = imap_msg_open_new,\n  .msg_commit       = imap_msg_commit,\n  .msg_close        = imap_msg_close,\n  .tags_edit        = imap_tags_edit,\n  .tags_commit      = imap_tags_commit,\n};\n// clang-format on\n", "/**\n * @file\n * Shared constants/structs that are private to IMAP\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _IMAP_PRIVATE_H\n#define _IMAP_PRIVATE_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <time.h>\n#include \"mutt/list.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct Account;\nstruct Buffer;\nstruct Context;\nstruct Header;\nstruct ImapHeaderData;\nstruct ImapMbox;\nstruct Message;\nstruct Progress;\n\n/* -- symbols -- */\n#define IMAP_PORT 143\n#define IMAP_SSL_PORT 993\n\n/* logging levels */\n#define IMAP_LOG_CMD  2\n#define IMAP_LOG_LTRL 4\n#define IMAP_LOG_PASS 5\n\n/* IMAP command responses. Used in ImapCommand.state too */\n#define IMAP_CMD_OK       0  /**< `<tag> OK ...` */\n#define IMAP_CMD_BAD      -1 /**< `<tag> BAD ...` */\n#define IMAP_CMD_NO       -2 /**< `<tag> NO ...` */\n#define IMAP_CMD_CONTINUE 1  /**< `* ...` */\n#define IMAP_CMD_RESPOND  2  /**< `+` */\n#define IMAP_CMD_NEW      3  /**< ImapCommand.state additions */\n\n/* number of entries in the hash table */\n#define IMAP_CACHE_LEN 10\n\n#define SEQLEN 5\n/* maximum length of command lines before they must be split (for\n * lazy servers) */\n#define IMAP_MAX_CMDLEN 1024\n\n#define IMAP_REOPEN_ALLOW     (1 << 0)\n#define IMAP_EXPUNGE_EXPECTED (1 << 1)\n#define IMAP_EXPUNGE_PENDING  (1 << 2)\n#define IMAP_NEWMAIL_PENDING  (1 << 3)\n#define IMAP_FLAGS_PENDING    (1 << 4)\n\n/* imap_exec flags (see imap_exec) */\n#define IMAP_CMD_FAIL_OK (1 << 0)\n#define IMAP_CMD_PASS    (1 << 1)\n#define IMAP_CMD_QUEUE   (1 << 2)\n#define IMAP_CMD_POLL    (1 << 3)\n\n/* length of \"DD-MMM-YYYY HH:MM:SS +ZZzz\" (null-terminated) */\n#define IMAP_DATELEN 27\n\n/**\n * enum ImapFlags - IMAP server responses\n */\nenum ImapFlags\n{\n  IMAP_FATAL = 1,\n  IMAP_BYE\n};\n\n/**\n * enum ImapState - IMAP connection state\n */\nenum ImapState\n{\n  /* States */\n  IMAP_DISCONNECTED = 0,\n  IMAP_CONNECTED,\n  IMAP_AUTHENTICATED,\n  IMAP_SELECTED,\n\n  /* and pseudo-states */\n  IMAP_IDLE\n};\n\n/**\n * enum ImapNamespace - IMAP namespace types\n */\nenum ImapNamespace\n{\n  IMAP_NS_PERSONAL = 0,\n  IMAP_NS_OTHER,\n  IMAP_NS_SHARED\n};\n\n/**\n * enum ImapCaps - Capabilities we are interested in\n *\n * @note This must be kept in the same order as Capabilities.\n */\nenum ImapCaps\n{\n  IMAP4 = 0,\n  IMAP4REV1,\n  STATUS,\n  ACL,           /**< RFC2086: IMAP4 ACL extension */\n  NAMESPACE,     /**< RFC2342: IMAP4 Namespace */\n  ACRAM_MD5,     /**< RFC2195: CRAM-MD5 authentication */\n  AGSSAPI,       /**< RFC1731: GSSAPI authentication */\n  AUTH_ANON,     /**< AUTH=ANONYMOUS */\n  STARTTLS,      /**< RFC2595: STARTTLS */\n  LOGINDISABLED, /**<           LOGINDISABLED */\n  IDLE,          /**< RFC2177: IDLE */\n  SASL_IR,       /**< SASL initial response draft */\n  ENABLE,        /**< RFC5161 */\n  X_GM_EXT1,     /**< https://developers.google.com/gmail/imap/imap-extensions */\n  X_GM_ALT1 = X_GM_EXT1, /**< Alternative capability string */\n\n  CAPMAX\n};\n\n/* imap_conn_find flags */\n#define MUTT_IMAP_CONN_NONEW    (1 << 0)\n#define MUTT_IMAP_CONN_NOSELECT (1 << 1)\n\n/**\n * struct ImapCache - IMAP-specific message cache\n */\nstruct ImapCache\n{\n  unsigned int uid;\n  char *path;\n};\n\n/**\n * struct ImapStatus - Status of an IMAP mailbox\n */\nstruct ImapStatus\n{\n  char *name;\n\n  unsigned int messages;\n  unsigned int recent;\n  unsigned int uidnext;\n  unsigned int uidvalidity;\n  unsigned int unseen;\n};\n\n/**\n * struct ImapList - Items in an IMAP browser\n */\nstruct ImapList\n{\n  char *name;\n  char delim;\n  bool noselect;\n  bool noinferiors;\n};\n\n/**\n * struct ImapCommand - IMAP command structure\n */\nstruct ImapCommand\n{\n  char seq[SEQLEN + 1];\n  int state;\n};\n\n/**\n * enum ImapCommandType - IMAP command type\n */\nenum ImapCommandType\n{\n  IMAP_CT_NONE = 0,\n  IMAP_CT_LIST,\n  IMAP_CT_STATUS\n};\n\n/**\n * struct ImapData - IMAP-specific server data\n *\n * This data is specific to a Connection to an IMAP server\n */\nstruct ImapData\n{\n  struct Connection *conn;\n  bool recovering;\n  unsigned char state;\n  unsigned char status;\n  /* let me explain capstr: SASL needs the capability string (not bits).\n   * we have 3 options:\n   *   1. rerun CAPABILITY inside SASL function.\n   *   2. build appropriate CAPABILITY string by reverse-engineering from bits.\n   *   3. keep a copy until after authentication.\n   * I've chosen (3) for now. (2) might not be too bad, but it involves\n   * tracking all possible capabilities. bah. (1) I don't like because\n   * it's just no fun to get the same information twice */\n  char *capstr;\n  unsigned char capabilities[(CAPMAX + 7) / 8];\n  unsigned int seqno;\n  time_t lastread; /**< last time we read a command for the server */\n  char *buf;\n  size_t blen;\n\n  /* If nonzero, we can send UTF-8, and the server will use UTF8 rather\n   * than mUTF7 */\n  int unicode;\n\n  /* if set, the response parser will store results for complicated commands\n   * here. */\n  enum ImapCommandType cmdtype;\n  void *cmddata;\n\n  /* command queue */\n  struct ImapCommand *cmds;\n  int cmdslots;\n  int nextcmd;\n  int lastcmd;\n  struct Buffer *cmdbuf;\n\n  /* cache ImapStatus of visited mailboxes */\n  struct ListHead mboxcache;\n\n  /* The following data is all specific to the currently SELECTED mbox */\n  char delim;\n  struct Context *ctx;\n  char *mailbox;\n  unsigned short check_status;\n  unsigned char reopen;\n  unsigned int new_mail_count; /**< Set when EXISTS notifies of new mail */\n  struct ImapCache cache[IMAP_CACHE_LEN];\n  struct Hash *uid_hash;\n  unsigned int uid_validity;\n  unsigned int uidnext;\n  struct Header **msn_index;   /**< look up headers by (MSN-1) */\n  size_t msn_index_size;       /**< allocation size */\n  unsigned int max_msn;        /**< the largest MSN fetched so far */\n  struct BodyCache *bcache;\n\n  /* all folder flags - system AND custom flags */\n  struct ListHead flags;\n#ifdef USE_HCACHE\n  header_cache_t *hcache;\n#endif\n};\n\n/* -- private IMAP functions -- */\n/* imap.c */\nint imap_check(struct ImapData *idata, int force);\nint imap_create_mailbox(struct ImapData *idata, char *mailbox);\nint imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname);\nstruct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create);\nvoid imap_mboxcache_free(struct ImapData *idata);\nint imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,\n                     int flag, int changed, int invert);\nint imap_open_connection(struct ImapData *idata);\nvoid imap_close_connection(struct ImapData *idata);\nstruct ImapData *imap_conn_find(const struct Account *account, int flags);\nint imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes, struct Progress *pbar);\nvoid imap_expunge_mailbox(struct ImapData *idata);\nvoid imap_logout(struct ImapData **idata);\nint imap_sync_message_for_copy(struct ImapData *idata, struct Header *hdr, struct Buffer *cmd, int *err_continue);\nbool imap_has_flag(struct ListHead *flag_list, const char *flag);\n\n/* auth.c */\nint imap_authenticate(struct ImapData *idata);\n\n/* command.c */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr);\nint imap_cmd_step(struct ImapData *idata);\nvoid imap_cmd_finish(struct ImapData *idata);\nbool imap_code(const char *s);\nconst char *imap_cmd_trailer(struct ImapData *idata);\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags);\nint imap_cmd_idle(struct ImapData *idata);\n\n/* message.c */\nvoid imap_free_header_data(struct ImapHeaderData **data);\nint imap_read_headers(struct ImapData *idata, unsigned int msn_begin, unsigned int msn_end);\nchar *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes);\nint imap_cache_del(struct ImapData *idata, struct Header *h);\nint imap_cache_clean(struct ImapData *idata);\nint imap_append_message(struct Context *ctx, struct Message *msg);\n\nint imap_msg_open(struct Context *ctx, struct Message *msg, int msgno);\nint imap_msg_close(struct Context *ctx, struct Message *msg);\nint imap_msg_commit(struct Context *ctx, struct Message *msg);\n\n/* util.c */\n#ifdef USE_HCACHE\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path);\nvoid imap_hcache_close(struct ImapData *idata);\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid);\nint imap_hcache_put(struct ImapData *idata, struct Header *h);\nint imap_hcache_del(struct ImapData *idata, unsigned int uid);\n#endif\n\nint imap_continue(const char *msg, const char *resp);\nvoid imap_error(const char *where, const char *msg);\nstruct ImapData *imap_new_idata(void);\nvoid imap_free_idata(struct ImapData **idata);\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen);\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen);\nint imap_get_literal_count(const char *buf, unsigned int *bytes);\nchar *imap_get_qualifier(char *buf);\nint imap_mxcmp(const char *mx1, const char *mx2);\nchar *imap_next_word(char *s);\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\nvoid imap_quote_string(char *dest, size_t dlen, const char *src);\nvoid imap_unquote_string(char *s);\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s);\nint imap_account_match(const struct Account *a1, const struct Account *a2);\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim);\n\n/* utf7.c */\nvoid imap_utf_encode(struct ImapData *idata, char **s);\nvoid imap_utf_decode(struct ImapData *idata, char **s);\nvoid imap_allow_reopen(struct Context *ctx);\nvoid imap_disallow_reopen(struct Context *ctx);\n\n#ifdef USE_HCACHE\n#define imap_hcache_keylen mutt_str_strlen\n#endif /* USE_HCACHE */\n\n#endif /* _IMAP_PRIVATE_H */\n", "/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * imap_expand_path - Canonicalise an IMAP path\n * @param path Buffer containing path\n * @param len  Buffer length\n * @retval  0 Success\n * @retval -1 Error\n *\n * IMAP implementation of mutt_expand_path. Rewrite an IMAP path in canonical\n * and absolute form.  The buffer is rewritten in place with the canonical IMAP\n * path.\n *\n * Function can fail if imap_parse_path() or url_tostring() fail,\n * of if the buffer isn't large enough.\n */\nint imap_expand_path(char *path, size_t len)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  struct Url url;\n  char fixedpath[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx) < 0)\n    return -1;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  mutt_account_tourl(&mx.account, &url);\n  imap_fix_path(idata, mx.mbox, fixedpath, sizeof(fixedpath));\n  url.path = fixedpath;\n\n  rc = url_tostring(&url, path, len, U_DECODE_PASSWD);\n  FREE(&mx.mbox);\n\n  return rc;\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param output Buffer for the result\n * @param mbox   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n * @param delim  Path delimiter\n */\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim)\n{\n  int n;\n\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != output)\n    mutt_str_strfcpy(output, mbox, olen);\n\n  n = mutt_str_strlen(output);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If output[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then output looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If output == '/', then n-- => n == 0, so the loop ends\n   * immediately\n   */\n  for (n--; n >= 0 && output[n] != delim; n--)\n    ;\n\n  /* We stopped before the beginning. There is a trailing\n   * slash.\n   */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    output[n] = '\\0';\n  }\n  else\n  {\n    output[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param output Buffer for the result\n * @param path   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n *\n * Provided an imap path, returns in output the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(char *output, const char *path, size_t olen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mbox, mbox, sizeof(mbox), idata->delim);\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(output, olen, &mx, mbox);\n  FREE(&mx.mbox);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n    return;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n    return;\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &mx, mbox);\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_hcache_namer - Generate a filename for the header cache\n * @param path Path for the header cache file\n * @param dest Buffer for result\n * @param dlen Length of buffer\n * @retval num Chars written to dest\n */\nstatic int imap_hcache_namer(const char *path, char *dest, size_t dlen)\n{\n  return snprintf(dest, dlen, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param idata Server data\n * @param path  Path to the header cache\n * @retval ptr HeaderCache\n * @retval NULL Failure\n */\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param idata Server data\n */\nvoid imap_hcache_close(struct ImapData *idata)\n{\n  if (!idata->hcache)\n    return;\n\n  mutt_hcache_close(idata->hcache);\n  idata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param idata Server data\n * @param uid   UID to find\n * @retval ptr Email Header\n * @retval NULL Failure\n */\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n  void *uv = NULL;\n  struct Header *h = NULL;\n\n  if (!idata->hcache)\n    return NULL;\n\n  sprintf(key, \"/%u\", uid);\n  uv = mutt_hcache_fetch(idata->hcache, key, imap_hcache_keylen(key));\n  if (uv)\n  {\n    if (*(unsigned int *) uv == idata->uid_validity)\n      h = mutt_hcache_restore(uv);\n    else\n      mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);\n    mutt_hcache_free(idata->hcache, &uv);\n  }\n\n  return h;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param idata Server data\n * @param h     Email Header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapData *idata, struct Header *h)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", HEADER_DATA(h)->uid);\n  return mutt_hcache_store(idata->hcache, key, imap_hcache_keylen(key), h, idata->uid_validity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param idata Server data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete(idata->hcache, key, imap_hcache_keylen(key));\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into name,host,port\n * @param path Mailbox path to parse\n * @param mx   An IMAP mailbox\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.  mx.mbox is malloc'd, caller must free it\n */\nint imap_parse_path(const char *path, struct ImapMbox *mx)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n  struct servent *service = NULL;\n  struct Url url;\n  char *c = NULL;\n\n  if (!ImapPort)\n  {\n    service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n  if (!ImapsPort)\n  {\n    service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  memset(&mx->account, 0, sizeof(mx->account));\n  mx->account.port = ImapPort;\n  mx->account.type = MUTT_ACCT_TYPE_IMAP;\n\n  c = mutt_str_strdup(path);\n  url_parse(&url, c);\n  if (url.scheme == U_IMAP || url.scheme == U_IMAPS)\n  {\n    if (mutt_account_fromurl(&mx->account, &url) < 0 || !*mx->account.host)\n    {\n      url_free(&url);\n      FREE(&c);\n      return -1;\n    }\n\n    mx->mbox = mutt_str_strdup(url.path);\n\n    if (url.scheme == U_IMAPS)\n      mx->account.flags |= MUTT_ACCT_SSL;\n\n    url_free(&url);\n    FREE(&c);\n  }\n  /* old PINE-compatibility code */\n  else\n  {\n    url_free(&url);\n    FREE(&c);\n    char tmp[128];\n    if (sscanf(path, \"{%127[^}]}\", tmp) != 1)\n      return -1;\n\n    c = strchr(path, '}');\n    if (!c)\n      return -1;\n    else\n    {\n      /* walk past closing '}' */\n      mx->mbox = mutt_str_strdup(c + 1);\n    }\n\n    c = strrchr(tmp, '@');\n    if (c)\n    {\n      *c = '\\0';\n      mutt_str_strfcpy(mx->account.user, tmp, sizeof(mx->account.user));\n      mutt_str_strfcpy(tmp, c + 1, sizeof(tmp));\n      mx->account.flags |= MUTT_ACCT_USER;\n    }\n\n    const int n = sscanf(tmp, \"%127[^:/]%127s\", mx->account.host, tmp);\n    if (n < 1)\n    {\n      mutt_debug(1, \"NULL host in %s\\n\", path);\n      FREE(&mx->mbox);\n      return -1;\n    }\n\n    if (n > 1)\n    {\n      if (sscanf(tmp, \":%hu%127s\", &(mx->account.port), tmp) >= 1)\n        mx->account.flags |= MUTT_ACCT_PORT;\n      if (sscanf(tmp, \"/%s\", tmp) == 1)\n      {\n        if (mutt_str_strncmp(tmp, \"ssl\", 3) == 0)\n          mx->account.flags |= MUTT_ACCT_SSL;\n        else\n        {\n          mutt_debug(1, \"Unknown connection type in %s\\n\", path);\n          FREE(&mx->mbox);\n          return -1;\n        }\n      }\n    }\n  }\n\n  if ((mx->account.flags & MUTT_ACCT_SSL) && !(mx->account.flags & MUTT_ACCT_PORT))\n    mx->account.port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || !*mx1)\n    mx1 = \"INBOX\";\n  if (!mx2 || !*mx2)\n    mx2 = \"INBOX\";\n  if ((mutt_str_strcasecmp(mx1, \"INBOX\") == 0) &&\n      (mutt_str_strcasecmp(mx2, \"INBOX\") == 0))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path(NULL, mx1, b1, strlen(mx1) + 1);\n  imap_fix_path(NULL, mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_strcmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path Mailbox name to be tidied\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path)\n{\n  struct ImapMbox home, target;\n  struct Url url;\n  char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n\n  if (imap_parse_path(path, &target) < 0)\n    return;\n\n  tlen = mutt_str_strlen(target.mbox);\n  /* check whether we can do '=' substitution */\n  if (mx_is_imap(Folder) && !imap_parse_path(Folder, &home))\n  {\n    hlen = mutt_str_strlen(home.mbox);\n    if (tlen && mutt_account_match(&home.account, &target.account) &&\n        (mutt_str_strncmp(home.mbox, target.mbox, hlen) == 0))\n    {\n      if (hlen == 0)\n        home_match = true;\n      else if (ImapDelimChars)\n      {\n        for (delim = ImapDelimChars; *delim != '\\0'; delim++)\n          if (target.mbox[hlen] == *delim)\n            home_match = true;\n      }\n    }\n    FREE(&home.mbox);\n  }\n\n  /* do the '=' substitution */\n  if (home_match)\n  {\n    *path++ = '=';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target.mbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n  }\n  else\n  {\n    mutt_account_tourl(&target.account, &url);\n    url.path = target.mbox;\n    /* FIXME: That hard-coded constant is bogus. But we need the actual\n     *   size of the buffer from mutt_pretty_mailbox. And these pretty\n     *   operations usually shrink the result. Still... */\n    url_tostring(&url, path, 1024, 0);\n  }\n\n  FREE(&target.mbox);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval num Result: #MUTT_YES, #MUTT_NO, #MUTT_ABORT\n */\nint imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), 0);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\\n\", where, msg);\n}\n\n/**\n * imap_new_idata - Allocate and initialise a new ImapData structure\n * @retval NULL Failure (no mem)\n * @retval ptr New ImapData\n */\nstruct ImapData *imap_new_idata(void)\n{\n  struct ImapData *idata = mutt_mem_calloc(1, sizeof(struct ImapData));\n\n  idata->cmdbuf = mutt_buffer_new();\n  idata->cmdslots = ImapPipelineDepth + 2;\n  idata->cmds = mutt_mem_calloc(idata->cmdslots, sizeof(*idata->cmds));\n\n  STAILQ_INIT(&idata->flags);\n  STAILQ_INIT(&idata->mboxcache);\n\n  return idata;\n}\n\n/**\n * imap_free_idata - Release and clear storage in an ImapData structure\n * @param idata Server data\n */\nvoid imap_free_idata(struct ImapData **idata)\n{\n  if (!idata)\n    return;\n\n  FREE(&(*idata)->capstr);\n  mutt_list_free(&(*idata)->flags);\n  imap_mboxcache_free(*idata);\n  mutt_buffer_free(&(*idata)->cmdbuf);\n  FREE(&(*idata)->buf);\n  mutt_bcache_close(&(*idata)->bcache);\n  FREE(&(*idata)->cmds);\n  FREE(idata);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param idata   Server data\n * @param mailbox Mailbox path\n * @param path    Buffer for the result\n * @param plen    Length of buffer\n * @retval ptr Fixed-up path\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  char delim = '\\0';\n\n  if (idata)\n    delim = idata->delim;\n\n  while (mailbox && *mailbox && i < plen - 1)\n  {\n    if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))\n    {\n      /* use connection delimiter if known. Otherwise use user delimiter */\n      if (!idata)\n        delim = *mailbox;\n\n      while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||\n                          (delim && *mailbox == delim)))\n      {\n        mailbox++;\n      }\n      path[i] = delim;\n    }\n    else\n    {\n      path[i] = *mailbox;\n      mailbox++;\n    }\n    i++;\n  }\n  if (i && path[--i] != delim)\n    i++;\n  path[i] = '\\0';\n\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param idata   Server data\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n * @param dlen    Length of buffer\n */\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  int quoted = 0;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = quoted ? 0 : 1;\n    if (!quoted && ISSPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param dest Buffer for the result\n * @param len  Length of buffer\n * @param mx   Imap mailbox\n * @param path Path relative to the mailbox\n *\n * given ImapMbox and relative path.\n */\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n{\n  struct Url url;\n\n  mutt_account_tourl(&mx->account, &url);\n  url.path = path;\n\n  url_tostring(&url, dest, len, 0);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest Buffer for the result\n * @param dlen Length of the buffer\n * @param src  String to be quoted\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param idata Server data\n * @param dest  Buffer to store safe mailbox name\n * @param dlen  Length of buffer\n * @param src   Mailbox name\n */\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param idata Server data\n * @param s     Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_strdup(s);\n  if (buf)\n  {\n    imap_utf_decode(idata, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  struct Connection *conn = NULL;\n  struct ImapData *idata = NULL;\n  time_t now = time(NULL);\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP)\n    {\n      idata = conn->data;\n      if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)\n      {\n        imap_check(idata, 1);\n      }\n    }\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  bool imap_passive = ImapPassive;\n\n  ImapPassive = true;\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  alarm(ImapKeepalive);\n  while (waitpid(pid, &rc, 0) < 0 && errno == EINTR)\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(ImapKeepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  if (!imap_passive)\n    ImapPassive = false;\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_allow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_disallow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First Account\n * @param a2 Second Account\n * @retval true Accounts match\n */\nint imap_account_match(const struct Account *a1, const struct Account *a2)\n{\n  struct ImapData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);\n  struct ImapData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);\n  const struct Account *a1_canon = a1_idata == NULL ? a1 : &a1_idata->conn->account;\n  const struct Account *a2_canon = a2_idata == NULL ? a2 : &a2_idata->conn->account;\n\n  return mutt_account_match(a1_canon, a2_canon);\n}\n"], "fixing_code": ["/**\n * @file\n * IMAP login authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005,2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_login IMAP login authentication method\n *\n * IMAP login authentication method\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n\n/**\n * imap_auth_login - Plain LOGIN support\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * Send/receive commands to/from an IMAP server\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2011 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_command Send/receive commands to/from an IMAP server\n *\n * Send/receive commands to/from an IMAP server\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_menu.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n\n#define IMAP_CMD_BUFSIZE 512\n\n/**\n * Capabilities - Server capabilities strings that we understand\n *\n * @note This must be kept in the same order as ImapCaps.\n *\n * @note Gmail documents one string but use another, so we support both.\n */\nstatic const char *const Capabilities[] = {\n  \"IMAP4\",     \"IMAP4rev1\",     \"STATUS\",      \"ACL\",\n  \"NAMESPACE\", \"AUTH=CRAM-MD5\", \"AUTH=GSSAPI\", \"AUTH=ANONYMOUS\",\n  \"STARTTLS\",  \"LOGINDISABLED\", \"IDLE\",        \"SASL-IR\",\n  \"ENABLE\",    \"X-GM-EXT-1\",    \"X-GM-EXT1\",   NULL,\n};\n\n/**\n * cmd_queue_full - Is the IMAP command queue full?\n * @param idata Server data\n * @retval true Queue is full\n */\nstatic bool cmd_queue_full(struct ImapData *idata)\n{\n  if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)\n    return true;\n\n  return false;\n}\n\n/**\n * cmd_new - Create and queue a new command control block\n * @param idata IMAP data\n * @retval NULL if the pipeline is full\n * @retval ptr New command\n */\nstatic struct ImapCommand *cmd_new(struct ImapData *idata)\n{\n  struct ImapCommand *cmd = NULL;\n\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"IMAP command queue full\\n\");\n    return NULL;\n  }\n\n  cmd = idata->cmds + idata->nextcmd;\n  idata->nextcmd = (idata->nextcmd + 1) % idata->cmdslots;\n\n  snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", idata->seqno++);\n  if (idata->seqno > 9999)\n    idata->seqno = 0;\n\n  cmd->state = IMAP_CMD_NEW;\n\n  return cmd;\n}\n\n/**\n * cmd_queue - Add a IMAP command to the queue\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Server flags, e.g. #IMAP_CMD_POLL\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If the queue is full, attempts to drain it.\n */\nstatic int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"Draining IMAP command pipeline\\n\");\n\n    const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));\n\n    if (rc < 0 && rc != -2)\n      return rc;\n  }\n\n  struct ImapCommand *cmd = cmd_new(idata);\n  if (!cmd)\n    return IMAP_CMD_BAD;\n\n  if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_CMD_BAD;\n\n  return 0;\n}\n\n/**\n * cmd_handle_fatal - When ImapData is in fatal state, do what we can\n * @param idata Server data\n */\nstatic void cmd_handle_fatal(struct ImapData *idata)\n{\n  idata->status = IMAP_FATAL;\n\n  if ((idata->state >= IMAP_SELECTED) && (idata->reopen & IMAP_REOPEN_ALLOW))\n  {\n    mx_fastclose_mailbox(idata->ctx);\n    mutt_socket_close(idata->conn);\n    mutt_error(_(\"Mailbox %s@%s closed\"), idata->conn->account.login,\n               idata->conn->account.host);\n    idata->state = IMAP_DISCONNECTED;\n  }\n\n  imap_close_connection(idata);\n  if (!idata->recovering)\n  {\n    idata->recovering = true;\n    if (imap_conn_find(&idata->conn->account, 0))\n      mutt_clear_error();\n    idata->recovering = false;\n  }\n}\n\n/**\n * cmd_start - Start a new IMAP command\n * @param idata  Server data\n * @param cmdstr Command string\n * @param flags  Command flags, e.g. #IMAP_CMD_QUEUE\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_start(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (cmdstr && ((rc = cmd_queue(idata, cmdstr, flags)) < 0))\n    return rc;\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if (idata->cmdbuf->dptr == idata->cmdbuf->data)\n    return IMAP_CMD_BAD;\n\n  rc = mutt_socket_send_d(idata->conn, idata->cmdbuf->data,\n                          (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);\n  idata->cmdbuf->dptr = idata->cmdbuf->data;\n\n  /* unidle when command queue is flushed */\n  if (idata->state == IMAP_IDLE)\n    idata->state = IMAP_SELECTED;\n\n  return (rc < 0) ? IMAP_CMD_BAD : 0;\n}\n\n/**\n * cmd_status - parse response line for tagged OK/NO/BAD\n * @param s Status string from server\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nstatic int cmd_status(const char *s)\n{\n  s = imap_next_word((char *) s);\n\n  if (mutt_str_strncasecmp(\"OK\", s, 2) == 0)\n    return IMAP_CMD_OK;\n  if (mutt_str_strncasecmp(\"NO\", s, 2) == 0)\n    return IMAP_CMD_NO;\n\n  return IMAP_CMD_BAD;\n}\n\n/**\n * cmd_parse_expunge - Parse expunge command\n * @param idata Server data\n * @param s     String containing MSN of message to expunge\n *\n * cmd_parse_expunge: mark headers with new sequence ID and mark idata to be\n * reopened at our earliest convenience\n */\nstatic void cmd_parse_expunge(struct ImapData *idata, const char *s)\n{\n  unsigned int exp_msn;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling EXPUNGE\\n\");\n\n  if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > idata->max_msn)\n    return;\n\n  h = idata->msn_index[exp_msn - 1];\n  if (h)\n  {\n    /* imap_expunge_mailbox() will rewrite h->index.\n     * It needs to resort using SORT_ORDER anyway, so setting to INT_MAX\n     * makes the code simpler and possibly more efficient. */\n    h->index = INT_MAX;\n    HEADER_DATA(h)->msn = 0;\n  }\n\n  /* decrement seqno of those above. */\n  for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)\n  {\n    h = idata->msn_index[cur];\n    if (h)\n      HEADER_DATA(h)->msn--;\n    idata->msn_index[cur - 1] = h;\n  }\n\n  idata->msn_index[idata->max_msn - 1] = NULL;\n  idata->max_msn--;\n\n  idata->reopen |= IMAP_EXPUNGE_PENDING;\n}\n\n/**\n * cmd_parse_fetch - Load fetch response into ImapData\n * @param idata Server data\n * @param s     String containing MSN of message to fetch\n *\n * Currently only handles unanticipated FETCH responses, and only FLAGS data.\n * We get these if another client has changed flags for a mailbox we've\n * selected.  Of course, a lot of code here duplicates code in message.c.\n */\nstatic void cmd_parse_fetch(struct ImapData *idata, char *s)\n{\n  unsigned int msn, uid;\n  struct Header *h = NULL;\n  int server_changes = 0;\n\n  mutt_debug(3, \"Handling FETCH\\n\");\n\n  if (mutt_str_atoui(s, &msn) < 0 || msn < 1 || msn > idata->max_msn)\n  {\n    mutt_debug(3, \"#1 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  h = idata->msn_index[msn - 1];\n  if (!h || !h->active)\n  {\n    mutt_debug(3, \"#2 FETCH response ignored for this message\\n\");\n    return;\n  }\n\n  mutt_debug(2, \"Message UID %u updated\\n\", HEADER_DATA(h)->uid);\n  /* skip FETCH */\n  s = imap_next_word(s);\n  s = imap_next_word(s);\n\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Malformed FETCH response\\n\");\n    return;\n  }\n  s++;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      imap_set_flags(idata, h, s, &server_changes);\n      if (server_changes)\n      {\n        /* If server flags could conflict with neomutt's flags, reopen the mailbox. */\n        if (h->changed)\n          idata->reopen |= IMAP_EXPUNGE_PENDING;\n        else\n          idata->check_status = IMAP_FLAGS_PENDING;\n      }\n      return;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &uid) < 0)\n      {\n        mutt_debug(2, \"Illegal UID.  Skipping update.\\n\");\n        return;\n      }\n      if (uid != HEADER_DATA(h)->uid)\n      {\n        mutt_debug(2, \"FETCH UID vs MSN mismatch.  Skipping update.\\n\");\n        return;\n      }\n      s = imap_next_word(s);\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      mutt_debug(2, \"Only handle FLAGS updates\\n\");\n      return;\n    }\n  }\n}\n\n/**\n * cmd_parse_capability - set capability bits according to CAPABILITY response\n * @param idata Server data\n * @param s     Command string with capabilities\n */\nstatic void cmd_parse_capability(struct ImapData *idata, char *s)\n{\n  mutt_debug(3, \"Handling CAPABILITY\\n\");\n\n  s = imap_next_word(s);\n  char *bracket = strchr(s, ']');\n  if (bracket)\n    *bracket = '\\0';\n  FREE(&idata->capstr);\n  idata->capstr = mutt_str_strdup(s);\n\n  memset(idata->capabilities, 0, sizeof(idata->capabilities));\n\n  while (*s)\n  {\n    for (int i = 0; i < CAPMAX; i++)\n    {\n      if (mutt_str_word_casecmp(Capabilities[i], s) == 0)\n      {\n        mutt_bit_set(idata->capabilities, i);\n        mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);\n        break;\n      }\n    }\n    s = imap_next_word(s);\n  }\n}\n\n/**\n * cmd_parse_list - Parse a server LIST command (list mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_list(struct ImapData *idata, char *s)\n{\n  struct ImapList *list = NULL;\n  struct ImapList lb;\n  char delimbuf[5]; /* worst case: \"\\\\\"\\0 */\n  unsigned int litlen;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n    list = (struct ImapList *) idata->cmddata;\n  else\n    list = &lb;\n\n  memset(list, 0, sizeof(struct ImapList));\n\n  /* flags */\n  s = imap_next_word(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"Bad LIST response\\n\");\n    return;\n  }\n  s++;\n  while (*s)\n  {\n    if (mutt_str_strncasecmp(s, \"\\\\NoSelect\", 9) == 0)\n      list->noselect = true;\n    else if (mutt_str_strncasecmp(s, \"\\\\NoInferiors\", 12) == 0)\n      list->noinferiors = true;\n    /* See draft-gahrns-imap-child-mailbox-?? */\n    else if (mutt_str_strncasecmp(s, \"\\\\HasNoChildren\", 14) == 0)\n      list->noinferiors = true;\n\n    s = imap_next_word(s);\n    if (*(s - 2) == ')')\n      break;\n  }\n\n  /* Delimiter */\n  if (mutt_str_strncasecmp(s, \"NIL\", 3) != 0)\n  {\n    delimbuf[0] = '\\0';\n    mutt_str_strcat(delimbuf, 5, s);\n    imap_unquote_string(delimbuf);\n    list->delim = delimbuf[0];\n  }\n\n  /* Name */\n  s = imap_next_word(s);\n  /* Notes often responds with literals here. We need a real tokenizer. */\n  if (imap_get_literal_count(s, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    list->name = idata->buf;\n  }\n  else\n  {\n    imap_unmunge_mbox_name(idata, s);\n    list->name = s;\n  }\n\n  if (list->name[0] == '\\0')\n  {\n    idata->delim = list->delim;\n    mutt_debug(3, \"Root delimiter: %c\\n\", idata->delim);\n  }\n}\n\n/**\n * cmd_parse_lsub - Parse a server LSUB (list subscribed mailboxes)\n * @param idata Server data\n * @param s     Command string with folder list\n */\nstatic void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}\n\n/**\n * cmd_parse_myrights - Set rights bits according to MYRIGHTS response\n * @param idata Server data\n * @param s     Command string with rights info\n */\nstatic void cmd_parse_myrights(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling MYRIGHTS\\n\");\n\n  s = imap_next_word((char *) s);\n  s = imap_next_word((char *) s);\n\n  /* zero out current rights set */\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n\n  while (*s && !isspace((unsigned char) *s))\n  {\n    switch (*s)\n    {\n      case 'a':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_ADMIN);\n        break;\n      case 'e':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      case 'i':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n        break;\n      case 'k':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        break;\n      case 'l':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n        break;\n      case 'p':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n        break;\n      case 'r':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n        break;\n      case 's':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n        break;\n      case 't':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        break;\n      case 'w':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n        break;\n      case 'x':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n\n      /* obsolete rights */\n      case 'c':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELMX);\n        break;\n      case 'd':\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n        mutt_bit_set(idata->ctx->rights, MUTT_ACL_EXPUNGE);\n        break;\n      default:\n        mutt_debug(1, \"Unknown right: %c\\n\", *s);\n    }\n    s++;\n  }\n}\n\n/**\n * cmd_parse_search - store SEARCH response for later use\n * @param idata Server data\n * @param s     Command string with search results\n */\nstatic void cmd_parse_search(struct ImapData *idata, const char *s)\n{\n  unsigned int uid;\n  struct Header *h = NULL;\n\n  mutt_debug(2, \"Handling SEARCH\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if (mutt_str_atoui(s, &uid) < 0)\n      continue;\n    h = (struct Header *) mutt_hash_int_find(idata->uid_hash, uid);\n    if (h)\n      h->matched = true;\n  }\n}\n\n/**\n * cmd_parse_status - Parse status from server\n * @param idata Server data\n * @param s     Command string with status info\n *\n * first cut: just do buffy update. Later we may wish to cache all mailbox\n * information, even that not desired by buffy\n */\nstatic void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n\n/**\n * cmd_parse_enabled - Record what the server has enabled\n * @param idata Server data\n * @param s     Command string containing acceptable encodings\n */\nstatic void cmd_parse_enabled(struct ImapData *idata, const char *s)\n{\n  mutt_debug(2, \"Handling ENABLED\\n\");\n\n  while ((s = imap_next_word((char *) s)) && *s != '\\0')\n  {\n    if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||\n        (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))\n    {\n      idata->unicode = 1;\n    }\n  }\n}\n\n/**\n * cmd_handle_untagged - fallback parser for otherwise unhandled messages\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int cmd_handle_untagged(struct ImapData *idata)\n{\n  unsigned int count = 0;\n  char *s = imap_next_word(idata->buf);\n  char *pn = imap_next_word(s);\n\n  if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))\n  {\n    pn = s;\n    s = imap_next_word(s);\n\n    /* EXISTS and EXPUNGE are always related to the SELECTED mailbox for the\n     * connection, so update that one.\n     */\n    if (mutt_str_strncasecmp(\"EXISTS\", s, 6) == 0)\n    {\n      mutt_debug(2, \"Handling EXISTS\\n\");\n\n      /* new mail arrived */\n      if (mutt_str_atoui(pn, &count) < 0)\n      {\n        mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);\n      }\n\n      if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)\n      {\n        /* Notes 6.0.3 has a tendency to report fewer messages exist than\n         * it should. */\n        mutt_debug(1, \"Message count is out of sync\\n\");\n        return 0;\n      }\n      /* at least the InterChange server sends EXISTS messages freely,\n       * even when there is no new mail */\n      else if (count == idata->max_msn)\n        mutt_debug(3, \"superfluous EXISTS message.\\n\");\n      else\n      {\n        if (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n        {\n          mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mailbox, count);\n          idata->reopen |= IMAP_NEWMAIL_PENDING;\n        }\n        idata->new_mail_count = count;\n      }\n    }\n    /* pn vs. s: need initial seqno */\n    else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)\n      cmd_parse_expunge(idata, pn);\n    else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)\n      cmd_parse_fetch(idata, pn);\n  }\n  else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)\n    cmd_parse_capability(idata, s);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)\n    cmd_parse_capability(idata, pn);\n  else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)\n    cmd_parse_capability(idata, imap_next_word(pn));\n  else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)\n    cmd_parse_list(idata, s);\n  else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)\n    cmd_parse_lsub(idata, s);\n  else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)\n    cmd_parse_myrights(idata, s);\n  else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)\n    cmd_parse_search(idata, s);\n  else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)\n    cmd_parse_status(idata, s);\n  else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)\n    cmd_parse_enabled(idata, s);\n  else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)\n  {\n    mutt_debug(2, \"Handling BYE\\n\");\n\n    /* check if we're logging out */\n    if (idata->status == IMAP_BYE)\n      return 0;\n\n    /* server shut down our connection */\n    s += 3;\n    SKIPWS(s);\n    mutt_error(\"%s\", s);\n    cmd_handle_fatal(idata);\n\n    return -1;\n  }\n  else if (ImapServernoise && (mutt_str_strncasecmp(\"NO\", s, 2) == 0))\n  {\n    mutt_debug(2, \"Handling untagged NO\\n\");\n\n    /* Display the warning message from the server */\n    mutt_error(\"%s\", s + 3);\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_start - Given an IMAP command, send it to the server\n * @param idata  Server data\n * @param cmdstr Command string to send\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * If cmdstr is NULL, sends queued commands.\n */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr)\n{\n  return cmd_start(idata, cmdstr, 0);\n}\n\n/**\n * imap_cmd_step - Reads server responses from an IMAP command\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n *\n * detects tagged completion response, handles untagged messages, can read\n * arbitrarily large strings (using malloc, so don't make it _too_ large!).\n */\nint imap_cmd_step(struct ImapData *idata)\n{\n  size_t len = 0;\n  int c;\n  int rc;\n  int stillrunning = 0;\n  struct ImapCommand *cmd = NULL;\n\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return IMAP_CMD_BAD;\n  }\n\n  /* read into buffer, expanding buffer as necessary until we have a full\n   * line */\n  do\n  {\n    if (len == idata->blen)\n    {\n      mutt_mem_realloc(&idata->buf, idata->blen + IMAP_CMD_BUFSIZE);\n      idata->blen = idata->blen + IMAP_CMD_BUFSIZE;\n      mutt_debug(3, \"grew buffer to %u bytes\\n\", idata->blen);\n    }\n\n    /* back up over '\\0' */\n    if (len)\n      len--;\n    c = mutt_socket_readln(idata->buf + len, idata->blen - len, idata->conn);\n    if (c <= 0)\n    {\n      mutt_debug(1, \"Error reading server response.\\n\");\n      cmd_handle_fatal(idata);\n      return IMAP_CMD_BAD;\n    }\n\n    len += c;\n  }\n  /* if we've read all the way to the end of the buffer, we haven't read a\n   * full line (mutt_socket_readln strips the \\r, so we always have at least\n   * one character free when we've read a full line) */\n  while (len == idata->blen);\n\n  /* don't let one large string make cmd->buf hog memory forever */\n  if ((idata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))\n  {\n    mutt_mem_realloc(&idata->buf, IMAP_CMD_BUFSIZE);\n    idata->blen = IMAP_CMD_BUFSIZE;\n    mutt_debug(3, \"shrank buffer to %u bytes\\n\", idata->blen);\n  }\n\n  idata->lastread = time(NULL);\n\n  /* handle untagged messages. The caller still gets its shot afterwards. */\n  if (((mutt_str_strncmp(idata->buf, \"* \", 2) == 0) ||\n       (mutt_str_strncmp(imap_next_word(idata->buf), \"OK [\", 4) == 0)) &&\n      cmd_handle_untagged(idata))\n  {\n    return IMAP_CMD_BAD;\n  }\n\n  /* server demands a continuation response from us */\n  if (idata->buf[0] == '+')\n    return IMAP_CMD_RESPOND;\n\n  /* Look for tagged command completions.\n   *\n   * Some response handlers can end up recursively calling\n   * imap_cmd_step() and end up handling all tagged command\n   * completions.\n   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)\n   *\n   * Other callers don't even create an idata->cmds entry.\n   *\n   * For both these cases, we default to returning OK */\n  rc = IMAP_CMD_OK;\n  c = idata->lastcmd;\n  do\n  {\n    cmd = &idata->cmds[c];\n    if (cmd->state == IMAP_CMD_NEW)\n    {\n      if (mutt_str_strncmp(idata->buf, cmd->seq, SEQLEN) == 0)\n      {\n        if (!stillrunning)\n        {\n          /* first command in queue has finished - move queue pointer up */\n          idata->lastcmd = (idata->lastcmd + 1) % idata->cmdslots;\n        }\n        cmd->state = cmd_status(idata->buf);\n        /* bogus - we don't know which command result to return here. Caller\n         * should provide a tag. */\n        rc = cmd->state;\n      }\n      else\n        stillrunning++;\n    }\n\n    c = (c + 1) % idata->cmdslots;\n  } while (c != idata->nextcmd);\n\n  if (stillrunning)\n    rc = IMAP_CMD_CONTINUE;\n  else\n  {\n    mutt_debug(3, \"IMAP queue drained\\n\");\n    imap_cmd_finish(idata);\n  }\n\n  return rc;\n}\n\n/**\n * imap_code - Was the command successful\n * @param s IMAP command status\n * @retval 1 Command result was OK\n * @retval 0 If NO or BAD\n */\nbool imap_code(const char *s)\n{\n  return (cmd_status(s) == IMAP_CMD_OK);\n}\n\n/**\n * imap_cmd_trailer - Extra information after tagged command response if any\n * @param idata Server data\n * @retval ptr Extra command information (pointer into idata->buf)\n * @retval \"\"  Error (static string)\n */\nconst char *imap_cmd_trailer(struct ImapData *idata)\n{\n  static const char *notrailer = \"\";\n  const char *s = idata->buf;\n\n  if (!s)\n  {\n    mutt_debug(2, \"not a tagged response\\n\");\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s || ((mutt_str_strncasecmp(s, \"OK\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&\n             (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))\n  {\n    mutt_debug(2, \"not a command completion: %s\\n\", idata->buf);\n    return notrailer;\n  }\n\n  s = imap_next_word((char *) s);\n  if (!s)\n    return notrailer;\n\n  return s;\n}\n\n/**\n * imap_exec - Execute a command and wait for the response from the server\n * @param idata  IMAP data\n * @param cmdstr Command to execute\n * @param flags  Flags (see below)\n * @retval  0 Success\n * @retval -1 Failure\n * @retval -2 OK Failure\n *\n * Also, handle untagged responses.\n *\n * Flags:\n * * IMAP_CMD_FAIL_OK: the calling procedure can handle failure.\n *       This is used for checking for a mailbox on append and login\n * * IMAP_CMD_PASS: command contains a password. Suppress logging.\n * * IMAP_CMD_QUEUE: only queue command, do not execute.\n * * IMAP_CMD_POLL: poll the socket for a response before running imap_cmd_step.\n */\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  int rc;\n\n  rc = cmd_start(idata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return 0;\n\n  if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&\n      (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(1);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  mutt_sig_allow_interrupt(0);\n\n  if (rc == IMAP_CMD_NO && (flags & IMAP_CMD_FAIL_OK))\n    return -2;\n\n  if (rc != IMAP_CMD_OK)\n  {\n    if ((flags & IMAP_CMD_FAIL_OK) && idata->status != IMAP_FATAL)\n      return -2;\n\n    mutt_debug(1, \"command failed: %s\\n\", idata->buf);\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_cmd_finish - Attempt to perform cleanup\n * @param idata Server data\n *\n * Attempts to perform cleanup (eg fetch new mail if detected, do expunge).\n * Called automatically by imap_cmd_step(), but may be called at any time.\n * Called by imap_check_mailbox() just before the index is refreshed, for\n * instance.\n */\nvoid imap_cmd_finish(struct ImapData *idata)\n{\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return;\n  }\n\n  if (!(idata->state >= IMAP_SELECTED) || idata->ctx->closing)\n    return;\n\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    unsigned int count = idata->new_mail_count;\n\n    if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n        (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)\n    {\n      /* read new mail messages */\n      mutt_debug(2, \"Fetching new mail\\n\");\n      /* check_status: curs_main uses imap_check_mailbox to detect\n       *   whether the index needs updating */\n      idata->check_status = IMAP_NEWMAIL_PENDING;\n      imap_read_headers(idata, idata->max_msn + 1, count);\n    }\n    else if (idata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(idata);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))\n        idata->check_status = IMAP_EXPUNGE_PENDING;\n      idata->reopen &=\n          ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n  }\n\n  idata->status = false;\n}\n\n/**\n * imap_cmd_idle - Enter the IDLE state\n * @param idata Server data\n * @retval  0 Success\n * @retval <0 Failure, e.g. #IMAP_CMD_BAD\n */\nint imap_cmd_idle(struct ImapData *idata)\n{\n  int rc;\n\n  if (cmd_start(idata, \"IDLE\", IMAP_CMD_POLL) < 0)\n  {\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  if ((ImapPollTimeout > 0) && (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)\n  {\n    mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);\n    cmd_handle_fatal(idata);\n    return -1;\n  }\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    /* successfully entered IDLE state */\n    idata->state = IMAP_IDLE;\n    /* queue automatic exit when next command is issued */\n    mutt_buffer_printf(idata->cmdbuf, \"DONE\\r\\n\");\n    rc = IMAP_CMD_OK;\n  }\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"error starting IDLE\\n\");\n    return -1;\n  }\n\n  return 0;\n}\n", "/**\n * @file\n * IMAP network mailbox\n *\n * @authors\n * Copyright (C) 1996-1998,2012 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012,2017 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_imap IMAP network mailbox\n *\n * Support for IMAP4rev1, with the occasional nod to IMAP 4.\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"imap.h\"\n#include \"auth.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"buffy.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"pattern.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"tags.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * check_capabilities - Make sure we can log in to this server\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int check_capabilities(struct ImapData *idata)\n{\n  if (imap_exec(idata, \"CAPABILITY\", 0) != 0)\n  {\n    imap_error(\"check_capabilities\", idata->buf);\n    return -1;\n  }\n\n  if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||\n        mutt_bit_isset(idata->capabilities, IMAP4REV1)))\n  {\n    mutt_error(\n        _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * get_flags - Make a simple list out of a FLAGS response\n * @param hflags List to store flags\n * @param s      String containing flags\n * @retval ptr End of the flags\n * @retval ptr NULL Failure\n *\n * return stream following FLAGS response\n */\nstatic char *get_flags(struct ListHead *hflags, char *s)\n{\n  /* sanity-check string */\n  if (mutt_str_strncasecmp(\"FLAGS\", s, 5) != 0)\n  {\n    mutt_debug(1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  /* update caller's flags handle */\n  while (*s && *s != ')')\n  {\n    s++;\n    SKIPWS(s);\n    const char *flag_word = s;\n    while (*s && (*s != ')') && !ISSPACE(*s))\n      s++;\n    const char ctmp = *s;\n    *s = '\\0';\n    if (*flag_word)\n      mutt_list_insert_tail(hflags, mutt_str_strdup(flag_word));\n    *s = ctmp;\n  }\n\n  /* note bad flags response */\n  if (*s != ')')\n  {\n    mutt_debug(1, \"Unterminated FLAGS response: %s\\n\", s);\n    mutt_list_free(hflags);\n\n    return NULL;\n  }\n\n  s++;\n\n  return s;\n}\n\n/**\n * set_flag - append str to flags if we currently have permission according to aclbit\n * @param[in]  idata  Server data\n * @param[in]  aclbit Permissions, e.g. #MUTT_ACL_WRITE\n * @param[in]  flag   Does the email have the flag set?\n * @param[in]  str    Server flag name\n * @param[out] flags  Buffer for server command\n * @param[in]  flsize Length of buffer\n */\nstatic void set_flag(struct ImapData *idata, int aclbit, int flag,\n                     const char *str, char *flags, size_t flsize)\n{\n  if (mutt_bit_isset(idata->ctx->rights, aclbit))\n    if (flag && imap_has_flag(&idata->flags, str))\n      mutt_str_strcat(flags, flsize, str);\n}\n\n/**\n * make_msg_set - Make a message set\n * @param[in]  idata   Server data\n * @param[in]  buf     Buffer to store message set\n * @param[in]  flag    Flags to match, e.g. #MUTT_DELETED\n * @param[in]  changed Matched messages that have been altered\n * @param[in]  invert  Flag matches should be inverted\n * @param[out] pos     Cursor used for multiple calls to this function\n * @retval num Messages in the set\n *\n * @note Headers must be in SORT_ORDER. See imap_exec_msgset() for args.\n * Pos is an opaque pointer a la strtok(). It should be 0 at first call.\n */\nstatic int make_msg_set(struct ImapData *idata, struct Buffer *buf, int flag,\n                        bool changed, bool invert, int *pos)\n{\n  int count = 0;             /* number of messages in message set */\n  unsigned int setstart = 0; /* start of current message range */\n  int n;\n  bool started = false;\n  struct Header **hdrs = idata->ctx->hdrs;\n\n  for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)\n  {\n    bool match = false; /* whether current message matches flag condition */\n    /* don't include pending expunged messages */\n    if (hdrs[n]->active)\n    {\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)\n            match = invert ^ hdrs[n]->deleted;\n          break;\n        case MUTT_FLAG:\n          if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)\n            match = invert ^ hdrs[n]->flagged;\n          break;\n        case MUTT_OLD:\n          if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)\n            match = invert ^ hdrs[n]->old;\n          break;\n        case MUTT_READ:\n          if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)\n            match = invert ^ hdrs[n]->read;\n          break;\n        case MUTT_REPLIED:\n          if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)\n            match = invert ^ hdrs[n]->replied;\n          break;\n        case MUTT_TAG:\n          if (hdrs[n]->tagged)\n            match = true;\n          break;\n        case MUTT_TRASH:\n          if (hdrs[n]->deleted && !hdrs[n]->purge)\n            match = true;\n          break;\n      }\n    }\n\n    if (match && (!changed || hdrs[n]->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = HEADER_DATA(hdrs[n])->uid;\n        if (!started)\n        {\n          mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);\n          started = true;\n        }\n        else\n          mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);\n      }\n      /* tie up if the last message also matches */\n      else if (n == idata->ctx->msgcount - 1)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))\n    {\n      if (HEADER_DATA(hdrs[n - 1])->uid > setstart)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n\n/**\n * compare_flags_for_copy - Compare local flags against the server\n * @param h Header of email\n * @retval true  Flags have changed\n * @retval false Flags match cached server flags\n *\n * The comparison of flags EXCLUDES the deleted flag.\n */\nstatic bool compare_flags_for_copy(struct Header *h)\n{\n  struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;\n\n  if (h->read != hd->read)\n    return true;\n  if (h->old != hd->old)\n    return true;\n  if (h->flagged != hd->flagged)\n    return true;\n  if (h->replied != hd->replied)\n    return true;\n\n  return false;\n}\n\n/**\n * sync_helper - Sync flag changes to the server\n * @param idata Server data\n * @param right ACL, e.g. #MUTT_ACL_DELETE\n * @param flag  Mutt flag, e.g. MUTT_DELETED\n * @param name  Name of server flag\n * @retval >=0 Success, number of messages\n * @retval  -1 Failure\n */\nstatic int sync_helper(struct ImapData *idata, int right, int flag, const char *name)\n{\n  int count = 0;\n  int rc;\n  char buf[LONG_STRING];\n\n  if (!idata->ctx)\n    return -1;\n\n  if (!mutt_bit_isset(idata->ctx->rights, right))\n    return 0;\n\n  if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))\n    return 0;\n\n  snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);\n  rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  buf[0] = '-';\n  rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);\n  if (rc < 0)\n    return rc;\n  count += rc;\n\n  return count;\n}\n\n/**\n * get_mailbox - Split mailbox URI\n * @param path   Mailbox URI\n * @param hidata Server data\n * @param buf    Buffer to store mailbox name\n * @param blen   Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Split up a mailbox URI.  The connection info is stored in the ImapData and\n * the mailbox name is stored in buf.\n */\nstatic int get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)\n{\n  struct ImapMbox mx;\n\n  if (imap_parse_path(path, &mx))\n  {\n    mutt_debug(1, \"Error parsing %s\\n\", path);\n    return -1;\n  }\n  if (!(*hidata = imap_conn_find(&(mx.account), ImapPassive ? MUTT_IMAP_CONN_NONEW : 0)) ||\n      (*hidata)->state < IMAP_AUTHENTICATED)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path(*hidata, mx.mbox, buf, blen);\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", blen);\n  FREE(&mx.mbox);\n\n  return 0;\n}\n\n/**\n * do_search - Perform a search of messages\n * @param search  List of pattern to match\n * @param allpats Must all patterns match?\n * @retval num Number of patterns search that should be done server-side\n *\n * Count the number of patterns that can be done by the server (are full-text).\n */\nstatic int do_search(const struct Pattern *search, int allpats)\n{\n  int rc = 0;\n  const struct Pattern *pat = NULL;\n\n  for (pat = search; pat; pat = pat->next)\n  {\n    switch (pat->op)\n    {\n      case MUTT_BODY:\n      case MUTT_HEADER:\n      case MUTT_WHOLE_MSG:\n        if (pat->stringmatch)\n          rc++;\n        break;\n      case MUTT_SERVERSEARCH:\n        rc++;\n        break;\n      default:\n        if (pat->child && do_search(pat->child, 1))\n          rc++;\n    }\n\n    if (!allpats)\n      break;\n  }\n\n  return rc;\n}\n\n/**\n * compile_search - Convert NeoMutt pattern to IMAP search\n * @param ctx Context\n * @param pat Pattern to convert\n * @param buf Buffer for result\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Convert neomutt Pattern to IMAP SEARCH command containing only elements\n * that require full-text search (neomutt already has what it needs for most\n * match types, and does a better job (eg server doesn't support regexes).\n */\nstatic int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * longest_common_prefix - Find longest prefix common to two strings\n * @param dest  Destination buffer\n * @param src   Source buffer\n * @param start Starting offset into string\n * @param dlen  Destination buffer length\n * @retval num Length of the common string\n *\n * Trim dest to the length of the longest prefix it shares with src.\n */\nstatic size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)\n{\n  size_t pos = start;\n\n  while (pos < dlen && dest[pos] && dest[pos] == src[pos])\n    pos++;\n  dest[pos] = '\\0';\n\n  return pos;\n}\n\n/**\n * complete_hosts - Look for completion matches for mailboxes\n * @param buf Partial mailbox name to complete\n * @param buflen  Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * look for IMAP URLs to complete from defined mailboxes. Could be extended to\n * complete over open connections and account/folder hooks too.\n */\nstatic int complete_hosts(char *buf, size_t buflen)\n{\n  struct Buffy *mailbox = NULL;\n  struct Connection *conn = NULL;\n  int rc = -1;\n  size_t matchlen;\n\n  matchlen = mutt_str_strlen(buf);\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mutt_str_strncmp(buf, mailbox->path, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, mailbox->path, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, mailbox->path, matchlen, buflen);\n    }\n  }\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    struct Url url;\n    char urlstr[LONG_STRING];\n\n    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)\n      continue;\n\n    mutt_account_tourl(&conn->account, &url);\n    /* FIXME: how to handle multiple users on the same host? */\n    url.user = NULL;\n    url.path = NULL;\n    url_tostring(&url, urlstr, sizeof(urlstr), 0);\n    if (mutt_str_strncmp(buf, urlstr, matchlen) == 0)\n    {\n      if (rc)\n      {\n        mutt_str_strfcpy(buf, urlstr, buflen);\n        rc = 0;\n      }\n      else\n        longest_common_prefix(buf, urlstr, matchlen, buflen);\n    }\n  }\n\n  return rc;\n}\n\n/**\n * imap_access - Check permissions on an IMAP mailbox\n * @param path Mailbox path\n * @retval  0 Success\n * @retval <0 Failure\n *\n * TODO: ACL checks. Right now we assume if it exists we can mess with it.\n */\nint imap_access(const char *path)\n{\n  struct ImapData *idata = NULL;\n  struct ImapMbox mx;\n  char buf[LONG_STRING];\n  char mailbox[LONG_STRING];\n  char mbox[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx))\n    return -1;\n\n  idata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n\n  /* we may already be in the folder we're checking */\n  if (mutt_str_strcmp(idata->mailbox, mx.mbox) == 0)\n  {\n    FREE(&mx.mbox);\n    return 0;\n  }\n  FREE(&mx.mbox);\n\n  if (imap_mboxcache_get(idata, mailbox, 0))\n  {\n    mutt_debug(3, \"found %s in cache\\n\", mailbox);\n    return 0;\n  }\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n\n  if (mutt_bit_isset(idata->capabilities, IMAP4REV1))\n    snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);\n  else if (mutt_bit_isset(idata->capabilities, STATUS))\n    snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);\n  else\n  {\n    mutt_debug(2, \"STATUS not supported?\\n\");\n    return -1;\n  }\n\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);\n  if (rc < 0)\n  {\n    mutt_debug(1, \"Can't check STATUS of %s\\n\", mbox);\n    return rc;\n  }\n\n  return 0;\n}\n\n/**\n * imap_create_mailbox - Create a new mailbox\n * @param idata   Server data\n * @param mailbox Mailbox to create\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_create_mailbox(struct ImapData *idata, char *mailbox)\n{\n  char buf[LONG_STRING], mbox[LONG_STRING];\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n  snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n  {\n    mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));\n    return -1;\n  }\n\n  return 0;\n}\n\n/**\n * imap_rename_mailbox - Rename a mailbox\n * @param idata   Server data\n * @param mx      Existing mailbox\n * @param newname New name for mailbox\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)\n{\n  char oldmbox[LONG_STRING];\n  char newmbox[LONG_STRING];\n  char buf[LONG_STRING];\n\n  imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);\n  imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);\n\n  snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_delete_mailbox - Delete a mailbox\n * @param ctx Context\n * @param mx  Mailbox to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)\n{\n  char buf[PATH_MAX], mbox[PATH_MAX];\n  struct ImapData *idata = NULL;\n\n  if (!ctx || !ctx->data)\n  {\n    idata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);\n    if (!idata)\n    {\n      FREE(&mx->mbox);\n      return -1;\n    }\n  }\n  else\n  {\n    idata = ctx->data;\n  }\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);\n  snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_logout_all - close all open connections\n *\n * Quick and dirty until we can make sure we've got all the context we need.\n */\nvoid imap_logout_all(void)\n{\n  struct ConnectionList *head = mutt_socket_head();\n  struct Connection *np, *tmp;\n  TAILQ_FOREACH_SAFE(np, head, entries, tmp)\n  {\n    if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)\n    {\n      TAILQ_REMOVE(head, np, entries);\n      mutt_message(_(\"Closing connection to %s...\"), np->account.host);\n      imap_logout((struct ImapData **) (void *) &np->data);\n      mutt_clear_error();\n      mutt_socket_free(np);\n    }\n  }\n}\n\n/**\n * imap_read_literal - Read bytes bytes from server into file\n * @param fp    File handle for email file\n * @param idata Server data\n * @param bytes Number of bytes to read\n * @param pbar  Progress bar\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Not explicitly buffered, relies on FILE buffering.\n *\n * @note Strips `\\r` from `\\r\\n`.\n *       Apparently even literals use `\\r\\n`-terminated strings ?!\n */\nint imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes,\n                      struct Progress *pbar)\n{\n  char c;\n  bool r = false;\n  struct Buffer *buf = NULL;\n\n  if (DebugLevel >= IMAP_LOG_LTRL)\n    buf = mutt_buffer_alloc(bytes + 10);\n\n  mutt_debug(2, \"reading %ld bytes\\n\", bytes);\n\n  for (unsigned long pos = 0; pos < bytes; pos++)\n  {\n    if (mutt_socket_readchar(idata->conn, &c) != 1)\n    {\n      mutt_debug(1, \"error during read, %ld bytes read\\n\", pos);\n      idata->status = IMAP_FATAL;\n\n      mutt_buffer_free(&buf);\n      return -1;\n    }\n\n    if (r && c != '\\n')\n      fputc('\\r', fp);\n\n    if (c == '\\r')\n    {\n      r = true;\n      continue;\n    }\n    else\n      r = false;\n\n    fputc(c, fp);\n\n    if (pbar && !(pos % 1024))\n      mutt_progress_update(pbar, pos, -1);\n    if (DebugLevel >= IMAP_LOG_LTRL)\n      mutt_buffer_addch(buf, c);\n  }\n\n  if (DebugLevel >= IMAP_LOG_LTRL)\n  {\n    mutt_debug(IMAP_LOG_LTRL, \"\\n%s\", buf->data);\n    mutt_buffer_free(&buf);\n  }\n  return 0;\n}\n\n/**\n * imap_expunge_mailbox - Purge messages from the server\n * @param idata Server data\n *\n * Purge IMAP portion of expunged messages from the context. Must not be done\n * while something has a handle on any headers (eg inside pager or editor).\n * That is, check IMAP_REOPEN_ALLOW.\n */\nvoid imap_expunge_mailbox(struct ImapData *idata)\n{\n  struct Header *h = NULL;\n  int cacheno;\n  short old_sort;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n#endif\n\n  old_sort = Sort;\n  Sort = SORT_ORDER;\n  mutt_sort_headers(idata->ctx, 0);\n\n  for (int i = 0; i < idata->ctx->msgcount; i++)\n  {\n    h = idata->ctx->hdrs[i];\n\n    if (h->index == INT_MAX)\n    {\n      mutt_debug(2, \"Expunging message UID %u.\\n\", HEADER_DATA(h)->uid);\n\n      h->active = false;\n      idata->ctx->size -= h->content->length;\n\n      imap_cache_del(idata, h);\n#ifdef USE_HCACHE\n      imap_hcache_del(idata, HEADER_DATA(h)->uid);\n#endif\n\n      /* free cached body from disk, if necessary */\n      cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n      if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&\n          idata->cache[cacheno].path)\n      {\n        unlink(idata->cache[cacheno].path);\n        FREE(&idata->cache[cacheno].path);\n      }\n\n      mutt_hash_int_delete(idata->uid_hash, HEADER_DATA(h)->uid, h);\n\n      imap_free_header_data((struct ImapHeaderData **) &h->data);\n    }\n    else\n    {\n      h->index = i;\n      /* NeoMutt has several places where it turns off h->active as a\n       * hack.  For example to avoid FLAG updates, or to exclude from\n       * imap_exec_msgset.\n       *\n       * Unfortunately, when a reopen is allowed and the IMAP_EXPUNGE_PENDING\n       * flag becomes set (e.g. a flag update to a modified header),\n       * this function will be called by imap_cmd_finish().\n       *\n       * The mx_update_tables() will free and remove these \"inactive\" headers,\n       * despite that an EXPUNGE was not received for them.\n       * This would result in memory leaks and segfaults due to dangling\n       * pointers in the msn_index and uid_hash.\n       *\n       * So this is another hack to work around the hacks.  We don't want to\n       * remove the messages, so make sure active is on.\n       */\n      h->active = true;\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(idata);\n#endif\n\n  /* We may be called on to expunge at any time. We can't rely on the caller\n   * to always know to rethread */\n  mx_update_tables(idata->ctx, false);\n  Sort = old_sort;\n  mutt_sort_headers(idata->ctx, 1);\n}\n\n/**\n * imap_conn_find - Find an open IMAP connection\n * @param account Account to search\n * @param flags   Flags, e.g. #MUTT_IMAP_CONN_NONEW\n * @retval ptr  Matching connection\n * @retval NULL Failure\n *\n * Find an open IMAP connection matching account, or open a new one if none can\n * be found.\n */\nstruct ImapData *imap_conn_find(const struct Account *account, int flags)\n{\n  struct Connection *conn = NULL;\n  struct Account *creds = NULL;\n  struct ImapData *idata = NULL;\n  bool new = false;\n\n  while ((conn = mutt_conn_find(conn, account)))\n  {\n    if (!creds)\n      creds = &conn->account;\n    else\n      memcpy(&conn->account, creds, sizeof(struct Account));\n\n    idata = conn->data;\n    if (flags & MUTT_IMAP_CONN_NONEW)\n    {\n      if (!idata)\n      {\n        /* This should only happen if we've come to the end of the list */\n        mutt_socket_free(conn);\n        return NULL;\n      }\n      else if (idata->state < IMAP_AUTHENTICATED)\n        continue;\n    }\n    if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)\n      continue;\n    if (idata && idata->status == IMAP_FATAL)\n      continue;\n    break;\n  }\n  if (!conn)\n    return NULL; /* this happens when the initial connection fails */\n\n  if (!idata)\n  {\n    /* The current connection is a new connection */\n    idata = imap_new_idata();\n    if (!idata)\n    {\n      mutt_socket_free(conn);\n      return NULL;\n    }\n\n    conn->data = idata;\n    idata->conn = conn;\n    new = true;\n  }\n\n  if (idata->state == IMAP_DISCONNECTED)\n    imap_open_connection(idata);\n  if (idata->state == IMAP_CONNECTED)\n  {\n    if (imap_authenticate(idata) == IMAP_AUTH_SUCCESS)\n    {\n      idata->state = IMAP_AUTHENTICATED;\n      FREE(&idata->capstr);\n      new = true;\n      if (idata->conn->ssf)\n        mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);\n    }\n    else\n      mutt_account_unsetpass(&idata->conn->account);\n  }\n  if (new && idata->state == IMAP_AUTHENTICATED)\n  {\n    /* capabilities may have changed */\n    imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);\n    /* enable RFC6855, if the server supports that */\n    if (mutt_bit_isset(idata->capabilities, ENABLE))\n      imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);\n    /* get root delimiter, '/' as default */\n    idata->delim = '/';\n    imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);\n    /* we may need the root delimiter before we open a mailbox */\n    imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n  }\n\n  return idata;\n}\n\n/**\n * imap_open_connection - Open an IMAP connection\n * @param idata Server data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_open_connection(struct ImapData *idata)\n{\n  char buf[LONG_STRING];\n\n  if (mutt_socket_open(idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection(idata);\n    return -1;\n  }\n\n  if (mutt_str_strncasecmp(\"* OK\", idata->buf, 4) == 0)\n  {\n    if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&\n        check_capabilities(idata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (SslForceTls || mutt_bit_isset(idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (SslForceTls)\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption(SslStarttls,\n                                      _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (rc == MUTT_YES)\n      {\n        rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);\n        if (rc == -1)\n          goto bail;\n        if (rc != -2)\n        {\n          if (mutt_ssl_starttls(idata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(idata, \"CAPABILITY\", 0))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (SslForceTls && !idata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(idata) != 0)\n      goto bail;\n    FREE(&idata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(idata);\n#endif\nbail:\n  FREE(&idata->capstr);\n  return -1;\n}\n\n/**\n * imap_close_connection - Close an IMAP connection\n * @param idata Server data\n */\nvoid imap_close_connection(struct ImapData *idata)\n{\n  if (idata->state != IMAP_DISCONNECTED)\n  {\n    mutt_socket_close(idata->conn);\n    idata->state = IMAP_DISCONNECTED;\n  }\n  idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;\n  memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);\n}\n\n/**\n * imap_logout - Gracefully log out of server\n * @param idata Server data\n */\nvoid imap_logout(struct ImapData **idata)\n{\n  /* we set status here to let imap_handle_untagged know we _expect_ to\n   * receive a bye response (so it doesn't freak out and close the conn) */\n  (*idata)->status = IMAP_BYE;\n  imap_cmd_start(*idata, \"LOGOUT\");\n  if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)\n  {\n    while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)\n      ;\n  }\n\n  mutt_socket_close((*idata)->conn);\n  imap_free_idata(idata);\n}\n\n/**\n * imap_has_flag - Does the flag exist in the list\n * @param flag_list List of server flags\n * @param flag      Flag to find\n * @retval true Flag exists\n *\n * Do a caseless comparison of the flag against a flag list, return true if\n * found or flag list has '\\*'.\n */\nbool imap_has_flag(struct ListHead *flag_list, const char *flag)\n{\n  if (STAILQ_EMPTY(flag_list))\n    return false;\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, flag_list, entries)\n  {\n    if (mutt_str_strncasecmp(np->data, flag, strlen(np->data)) == 0)\n      return true;\n\n    if (mutt_str_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * imap_exec_msgset - Prepare commands for all messages matching conditions\n * @param idata   ImapData containing context containing header set\n * @param pre     prefix commands\n * @param post    postfix commands\n * @param flag    flag type on which to filter, e.g. MUTT_REPLIED\n * @param changed include only changed messages in message set\n * @param invert  invert sense of flag, eg MUTT_READ matches unread messages\n * @retval num Matched messages\n * @retval -1  Failure\n *\n * pre/post: commands are of the form \"%s %s %s %s\", tag, pre, message set, post\n * Prepares commands for all messages matching conditions\n * (must be flushed with imap_exec)\n */\nint imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,\n                     int flag, int changed, int invert)\n{\n  struct Header **hdrs = NULL;\n  short oldsort;\n  int pos;\n  int rc;\n  int count = 0;\n\n  struct Buffer *cmd = mutt_buffer_new();\n\n  /* We make a copy of the headers just in case resorting doesn't give\n   exactly the original order (duplicate messages?), because other parts of\n   the ctx are tied to the header order. This may be overkill. */\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = idata->ctx->hdrs;\n    idata->ctx->hdrs = mutt_mem_malloc(idata->ctx->msgcount * sizeof(struct Header *));\n    memcpy(idata->ctx->hdrs, hdrs, idata->ctx->msgcount * sizeof(struct Header *));\n\n    Sort = SORT_ORDER;\n    qsort(idata->ctx->hdrs, idata->ctx->msgcount, sizeof(struct Header *),\n          mutt_get_sort_func(SORT_ORDER));\n  }\n\n  pos = 0;\n\n  do\n  {\n    cmd->dptr = cmd->data;\n    mutt_buffer_printf(cmd, \"%s \", pre);\n    rc = make_msg_set(idata, cmd, flag, changed, invert, &pos);\n    if (rc > 0)\n    {\n      mutt_buffer_printf(cmd, \" %s\", post);\n      if (imap_exec(idata, cmd->data, IMAP_CMD_QUEUE))\n      {\n        rc = -1;\n        goto out;\n      }\n      count += rc;\n    }\n  } while (rc > 0);\n\n  rc = count;\n\nout:\n  mutt_buffer_free(&cmd);\n  if (oldsort != Sort)\n  {\n    Sort = oldsort;\n    FREE(&idata->ctx->hdrs);\n    idata->ctx->hdrs = hdrs;\n  }\n\n  return rc;\n}\n\n/**\n * imap_sync_message_for_copy - Update server to reflect the flags of a single message\n * @param[in]  idata        Server data\n * @param[in]  hdr          Header of the email\n * @param[in]  cmd          Buffer for the command string\n * @param[out] err_continue Did the user force a continue?\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Update the IMAP server to reflect the flags for a single message before\n * performing a \"UID COPY\".\n *\n * @note This does not sync the \"deleted\" flag state, because it is not\n *       desirable to propagate that flag into the copy.\n */\nint imap_sync_message_for_copy(struct ImapData *idata, struct Header *hdr,\n                               struct Buffer *cmd, int *err_continue)\n{\n  char flags[LONG_STRING];\n  char *tags;\n  char uid[11];\n\n  if (!compare_flags_for_copy(hdr))\n  {\n    if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n      hdr->changed = false;\n    return 0;\n  }\n\n  snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(hdr)->uid);\n  cmd->dptr = cmd->data;\n  mutt_buffer_addstr(cmd, \"UID STORE \");\n  mutt_buffer_addstr(cmd, uid);\n\n  flags[0] = '\\0';\n\n  set_flag(idata, MUTT_ACL_SEEN, hdr->read, \"\\\\Seen \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->old, \"Old \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->flagged, \"\\\\Flagged \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_WRITE, hdr->replied, \"\\\\Answered \", flags, sizeof(flags));\n  set_flag(idata, MUTT_ACL_DELETE, HEADER_DATA(hdr)->deleted, \"\\\\Deleted \",\n           flags, sizeof(flags));\n\n  if (mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))\n  {\n    /* restore system flags */\n    if (HEADER_DATA(hdr)->flags_system)\n      mutt_str_strcat(flags, sizeof(flags), HEADER_DATA(hdr)->flags_system);\n    /* set custom flags */\n    tags = driver_tags_get_with_hidden(&hdr->tags);\n    if (tags)\n    {\n      mutt_str_strcat(flags, sizeof(flags), tags);\n      FREE(&tags);\n    }\n  }\n\n  mutt_str_remove_trailing_ws(flags);\n\n  /* UW-IMAP is OK with null flags, Cyrus isn't. The only solution is to\n   * explicitly revoke all system flags (if we have permission) */\n  if (!*flags)\n  {\n    set_flag(idata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));\n    set_flag(idata, MUTT_ACL_DELETE, !HEADER_DATA(hdr)->deleted, \"\\\\Deleted \",\n             flags, sizeof(flags));\n\n    /* erase custom flags */\n    if (mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) && HEADER_DATA(hdr)->flags_remote)\n      mutt_str_strcat(flags, sizeof(flags), HEADER_DATA(hdr)->flags_remote);\n\n    mutt_str_remove_trailing_ws(flags);\n\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n  }\n  else\n    mutt_buffer_addstr(cmd, \" FLAGS.SILENT (\");\n\n  mutt_buffer_addstr(cmd, flags);\n  mutt_buffer_addstr(cmd, \")\");\n\n  /* dumb hack for bad UW-IMAP 4.7 servers spurious FLAGS updates */\n  hdr->active = false;\n\n  /* after all this it's still possible to have no flags, if you\n   * have no ACL rights */\n  if (*flags && (imap_exec(idata, cmd->data, 0) != 0) && err_continue &&\n      (*err_continue != MUTT_YES))\n  {\n    *err_continue = imap_continue(\"imap_sync_message: STORE failed\", idata->buf);\n    if (*err_continue != MUTT_YES)\n    {\n      hdr->active = true;\n      return -1;\n    }\n  }\n\n  /* server have now the updated flags */\n  FREE(&HEADER_DATA(hdr)->flags_remote);\n  HEADER_DATA(hdr)->flags_remote = driver_tags_get_with_hidden(&hdr->tags);\n\n  hdr->active = true;\n  if (hdr->deleted == HEADER_DATA(hdr)->deleted)\n    hdr->changed = false;\n\n  return 0;\n}\n\n/**\n * imap_check_mailbox - use the NOOP or IDLE command to poll for new mail\n * @param ctx   Context\n * @param force Don't wait\n * @retval #MUTT_REOPENED  mailbox has been externally modified\n * @retval #MUTT_NEW_MAIL  new mail has arrived\n * @retval 0               no change\n * @retval -1              error\n */\nint imap_check_mailbox(struct Context *ctx, int force)\n{\n  return imap_check(ctx->data, force);\n}\n\n/**\n * imap_check - Check for new mail\n * @param idata Server data\n * @param force Force a refresh\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nint imap_check(struct ImapData *idata, int force)\n{\n  /* overload keyboard timeout to avoid many mailbox checks in a row.\n   * Most users don't like having to wait exactly when they press a key. */\n  int result = 0;\n\n  /* try IDLE first, unless force is set */\n  if (!force && ImapIdle && mutt_bit_isset(idata->capabilities, IDLE) &&\n      (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))\n  {\n    if (imap_cmd_idle(idata) < 0)\n      return -1;\n  }\n  if (idata->state == IMAP_IDLE)\n  {\n    while ((result = mutt_socket_poll(idata->conn, 0)) > 0)\n    {\n      if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n      {\n        mutt_debug(1, \"Error reading IDLE response\\n\");\n        return -1;\n      }\n    }\n    if (result < 0)\n    {\n      mutt_debug(1, \"Poll failed, disabling IDLE\\n\");\n      mutt_bit_unset(idata->capabilities, IDLE);\n    }\n  }\n\n  if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&\n      imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)\n  {\n    return -1;\n  }\n\n  /* We call this even when we haven't run NOOP in case we have pending\n   * changes to process, since we can reopen here. */\n  imap_cmd_finish(idata);\n\n  if (idata->check_status & IMAP_EXPUNGE_PENDING)\n    result = MUTT_REOPENED;\n  else if (idata->check_status & IMAP_NEWMAIL_PENDING)\n    result = MUTT_NEW_MAIL;\n  else if (idata->check_status & IMAP_FLAGS_PENDING)\n    result = MUTT_FLAGS;\n\n  idata->check_status = 0;\n\n  return result;\n}\n\n/**\n * imap_buffy_check - Check for new mail in subscribed folders\n * @param check_stats Check for message stats too\n * @retval num Number of mailboxes with new mail\n * @retval 0   Failure\n *\n * Given a list of mailboxes rather than called once for each so that it can\n * batch the commands and save on round trips.\n */\nint imap_buffy_check(int check_stats)\n{\n  struct ImapData *idata = NULL;\n  struct ImapData *lastdata = NULL;\n  struct Buffy *mailbox = NULL;\n  char name[LONG_STRING];\n  char command[LONG_STRING];\n  char munged[LONG_STRING];\n  int buffies = 0;\n\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    /* Init newly-added mailboxes */\n    if (!mailbox->magic)\n    {\n      if (mx_is_imap(mailbox->path))\n        mailbox->magic = MUTT_IMAP;\n    }\n\n    if (mailbox->magic != MUTT_IMAP)\n      continue;\n\n    if (get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n     * IDLEd elsewhere.\n     * idata->mailbox may be NULL for connections other than the current\n     * mailbox's, and shouldn't expand to INBOX in that case. #3216. */\n    if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&\n        !mutt_bit_isset(idata->capabilities, STATUS))\n    {\n      mutt_debug(2, \"Server doesn't support STATUS\\n\");\n      continue;\n    }\n\n    if (lastdata && idata != lastdata)\n    {\n      /* Send commands to previous server. Sorting the buffy list\n       * may prevent some infelicitous interleavings */\n      if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)\n        mutt_debug(1, \"#1 Error polling mailboxes\\n\");\n\n      lastdata = NULL;\n    }\n\n    if (!lastdata)\n      lastdata = idata;\n\n    imap_munge_mbox_name(idata, munged, sizeof(munged), name);\n    if (check_stats)\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);\n    }\n    else\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);\n    }\n\n    if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)\n    {\n      mutt_debug(1, \"Error queueing command\\n\");\n      return 0;\n    }\n  }\n\n  if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))\n  {\n    mutt_debug(1, \"#2 Error polling mailboxes\\n\");\n    return 0;\n  }\n\n  /* collect results */\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mailbox->magic == MUTT_IMAP && mailbox->new)\n      buffies++;\n  }\n\n  return buffies;\n}\n\n/**\n * imap_status - Get the status of a mailbox\n * @param path  Path of mailbox\n * @param queue true if the command should be queued for the next call\n * @retval -1  Error\n * @retval >=0 Count of messages in mailbox\n *\n * If queue is true, the command will be sent now and be expected to have been\n * run on the next call (for pipelining the postponed count).\n */\nint imap_status(char *path, int queue)\n{\n  static int queued = 0;\n\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  struct ImapStatus *status = NULL;\n\n  if (get_mailbox(path, &idata, buf, sizeof(buf)) < 0)\n    return -1;\n\n  /* We are in the folder we're polling - just return the mailbox count.\n   *\n   * Note that imap_mxcmp() converts NULL to \"INBOX\", so we need to\n   * make sure the idata really is open to a folder. */\n  if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))\n    return idata->ctx->msgcount;\n  else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||\n           mutt_bit_isset(idata->capabilities, STATUS))\n  {\n    imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n    snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");\n    imap_unmunge_mbox_name(idata, mbox);\n  }\n  else\n  {\n    /* Server does not support STATUS, and this is not the current mailbox.\n     * There is no lightweight way to check recent arrivals */\n    return -1;\n  }\n\n  if (queue)\n  {\n    imap_exec(idata, buf, IMAP_CMD_QUEUE);\n    queued = 1;\n    return 0;\n  }\n  else if (!queued)\n    imap_exec(idata, buf, 0);\n\n  queued = 0;\n  status = imap_mboxcache_get(idata, mbox, 0);\n  if (status)\n    return status->messages;\n\n  return 0;\n}\n\n/**\n * imap_mboxcache_get - Open an hcache for a mailbox\n * @param idata  Server data\n * @param mbox   Mailbox to cache\n * @param create Should it be created if it doesn't exist?\n * @retval ptr  Stats of cached mailbox\n * @retval ptr  Stats of new cache entry\n * @retval NULL Not in cache and create is false\n *\n * return cached mailbox stats or NULL if create is 0\n */\nstruct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create)\n{\n  struct ImapStatus *status = NULL;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n  void *uidvalidity = NULL;\n  void *uidnext = NULL;\n#endif\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, &idata->mboxcache, entries)\n  {\n    status = (struct ImapStatus *) np->data;\n\n    if (imap_mxcmp(mbox, status->name) == 0)\n      return status;\n  }\n  status = NULL;\n\n  /* lame */\n  if (create)\n  {\n    struct ImapStatus *scache = mutt_mem_calloc(1, sizeof(struct ImapStatus));\n    scache->name = (char *) mbox;\n    mutt_list_insert_tail(&idata->mboxcache, (char *) scache);\n    status = imap_mboxcache_get(idata, mbox, 0);\n    status->name = mutt_str_strdup(mbox);\n  }\n\n#ifdef USE_HCACHE\n  hc = imap_hcache_open(idata, mbox);\n  if (hc)\n  {\n    uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);\n    uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);\n    if (uidvalidity)\n    {\n      if (!status)\n      {\n        mutt_hcache_free(hc, &uidvalidity);\n        mutt_hcache_free(hc, &uidnext);\n        mutt_hcache_close(hc);\n        return imap_mboxcache_get(idata, mbox, 1);\n      }\n      status->uidvalidity = *(unsigned int *) uidvalidity;\n      status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;\n      mutt_debug(3, \"hcache uidvalidity %u, uidnext %u\\n\", status->uidvalidity,\n                 status->uidnext);\n    }\n    mutt_hcache_free(hc, &uidvalidity);\n    mutt_hcache_free(hc, &uidnext);\n    mutt_hcache_close(hc);\n  }\n#endif\n\n  return status;\n}\n\n/**\n * imap_mboxcache_free - Free the cached ImapStatus\n * @param idata Server data\n */\nvoid imap_mboxcache_free(struct ImapData *idata)\n{\n  struct ImapStatus *status = NULL;\n\n  struct ListNode *np;\n  STAILQ_FOREACH(np, &idata->mboxcache, entries)\n  {\n    status = (struct ImapStatus *) np->data;\n    FREE(&status->name);\n  }\n\n  mutt_list_free(&idata->mboxcache);\n}\n\n/**\n * imap_search - Find a matching mailbox\n * @param ctx Context\n * @param pat Pattern to match\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_search(struct Context *ctx, const struct Pattern *pat)\n{\n  struct Buffer buf;\n  struct ImapData *idata = ctx->data;\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->matched = false;\n\n  if (do_search(pat, 1) == 0)\n    return 0;\n\n  mutt_buffer_init(&buf);\n  mutt_buffer_addstr(&buf, \"UID SEARCH \");\n  if (compile_search(ctx, pat, &buf) < 0)\n  {\n    FREE(&buf.data);\n    return -1;\n  }\n  if (imap_exec(idata, buf.data, 0) < 0)\n  {\n    FREE(&buf.data);\n    return -1;\n  }\n\n  FREE(&buf.data);\n  return 0;\n}\n\n/**\n * imap_subscribe - Subscribe to a mailbox\n * @param path      Mailbox path\n * @param subscribe True: subscribe, false: unsubscribe\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_complete - Try to complete an IMAP folder path\n * @param buf Buffer for result\n * @param buflen Length of buffer\n * @param path Partial mailbox name to complete\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given a partial IMAP folder path, return a string which adds as much to the\n * path as is unique\n */\nint imap_complete(char *buf, size_t buflen, char *path)\n{\n  struct ImapData *idata = NULL;\n  char list[LONG_STRING];\n  char tmp[LONG_STRING];\n  struct ImapList listresp;\n  char completion[LONG_STRING];\n  int clen;\n  size_t matchlen = 0;\n  int completions = 0;\n  struct ImapMbox mx;\n  int rc;\n\n  if (imap_parse_path(path, &mx))\n  {\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* don't open a new socket just for completion. Instead complete over\n   * known mailboxes/hooks/etc */\n  idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    mutt_str_strfcpy(buf, path, buflen);\n    return complete_hosts(buf, buflen);\n  }\n\n  /* reformat path for IMAP list, and append wildcard */\n  /* don't use INBOX in place of \"\" */\n  if (mx.mbox && mx.mbox[0])\n    imap_fix_path(idata, mx.mbox, list, sizeof(list));\n  else\n    list[0] = '\\0';\n\n  /* fire off command */\n  snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\", ImapListSubscribed ? \"LSUB\" : \"LIST\", list);\n\n  imap_cmd_start(idata, tmp);\n\n  /* and see what the results are */\n  mutt_str_strfcpy(completion, NONULL(mx.mbox), sizeof(completion));\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &listresp;\n  do\n  {\n    listresp.name = NULL;\n    rc = imap_cmd_step(idata);\n\n    if (rc == IMAP_CMD_CONTINUE && listresp.name)\n    {\n      /* if the folder isn't selectable, append delimiter to force browse\n       * to enter it on second tab. */\n      if (listresp.noselect)\n      {\n        clen = strlen(listresp.name);\n        listresp.name[clen++] = listresp.delim;\n        listresp.name[clen] = '\\0';\n      }\n      /* copy in first word */\n      if (!completions)\n      {\n        mutt_str_strfcpy(completion, listresp.name, sizeof(completion));\n        matchlen = strlen(completion);\n        completions++;\n        continue;\n      }\n\n      matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);\n      completions++;\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n  idata->cmddata = NULL;\n\n  if (completions)\n  {\n    /* reformat output */\n    imap_qualify_path(buf, buflen, &mx, completion);\n    mutt_pretty_mailbox(buf, buflen);\n\n    FREE(&mx.mbox);\n    return 0;\n  }\n\n  return -1;\n}\n\n/**\n * imap_fast_trash - Use server COPY command to copy deleted messages to trash\n * @param ctx  Context\n * @param dest Mailbox to move to\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_fast_trash(struct Context *ctx, char *dest)\n{\n  char mbox[LONG_STRING];\n  char mmbox[LONG_STRING];\n  char prompt[LONG_STRING];\n  int rc;\n  struct ImapMbox mx;\n  bool triedcreate = false;\n  struct Buffer *sync_cmd = NULL;\n  int err_continue = MUTT_NO;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(dest, &mx))\n  {\n    mutt_debug(1, \"bad destination %s\\n\", dest);\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)\n  {\n    mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->path);\n    return 1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n  if (!*mbox)\n    mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));\n  imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);\n\n  sync_cmd = mutt_buffer_new();\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&\n        ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)\n    {\n      rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);\n      if (rc < 0)\n      {\n        mutt_debug(1, \"could not sync\\n\");\n        goto out;\n      }\n    }\n  }\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);\n    if (!rc)\n    {\n      mutt_debug(1, \"No messages to trash\\n\");\n      rc = -1;\n      goto out;\n    }\n    else if (rc < 0)\n    {\n      mutt_debug(1, \"could not queue copy\\n\");\n      goto out;\n    }\n    else\n    {\n      mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                   rc, mbox);\n    }\n\n    /* let's get it on */\n    rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)\n        break;\n      mutt_debug(3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);\n      if (Confirmcreate && mutt_yesorno(prompt, 1) != MUTT_YES)\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(idata, mbox) < 0)\n        break;\n      triedcreate = true;\n    }\n  } while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error(\"imap_fast_trash\", idata->buf);\n    goto out;\n  }\n\n  rc = 0;\n\nout:\n  mutt_buffer_free(&sync_cmd);\n  FREE(&mx.mbox);\n\n  return (rc < 0) ? -1 : rc;\n}\n\n/**\n * imap_mbox_open - Implements MxOps::mbox_open()\n */\nstatic int imap_mbox_open(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  struct ImapStatus *status = NULL;\n  char buf[PATH_MAX];\n  char bufout[PATH_MAX];\n  int count = 0;\n  struct ImapMbox mx, pmx;\n  int rc;\n\n  if (imap_parse_path(ctx->path, &mx))\n  {\n    mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);\n    return -1;\n  }\n\n  /* we require a connection which isn't currently in IMAP_SELECTED state */\n  idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);\n  if (!idata)\n    goto fail_noidata;\n  if (idata->state < IMAP_AUTHENTICATED)\n    goto fail;\n\n  /* once again the context is new */\n  ctx->data = idata;\n\n  /* Clean up path and replace the one in the ctx */\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  FREE(&(idata->mailbox));\n  idata->mailbox = mutt_str_strdup(buf);\n  imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);\n\n  FREE(&(ctx->path));\n  FREE(&(ctx->realpath));\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  idata->ctx = ctx;\n\n  /* clear mailbox status */\n  idata->status = false;\n  memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));\n  idata->new_mail_count = 0;\n  idata->max_msn = 0;\n\n  mutt_message(_(\"Selecting %s...\"), idata->mailbox);\n  imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);\n\n  /* pipeline ACL test */\n  if (mutt_bit_isset(idata->capabilities, ACL))\n  {\n    snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);\n    imap_exec(idata, bufout, IMAP_CMD_QUEUE);\n  }\n  /* assume we have all rights if ACL is unavailable */\n  else\n  {\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);\n    mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);\n  }\n  /* pipeline the postponed count if possible */\n  pmx.mbox = NULL;\n  if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&\n      mutt_account_match(&pmx.account, &mx.account))\n  {\n    imap_status(Postponed, 1);\n  }\n  FREE(&pmx.mbox);\n\n  if (ImapCheckSubscribed)\n    imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);\n  snprintf(bufout, sizeof(bufout), \"%s %s\", ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);\n\n  idata->state = IMAP_SELECTED;\n\n  imap_cmd_start(idata, bufout);\n\n  status = imap_mboxcache_get(idata, idata->mailbox, 1);\n\n  do\n  {\n    char *pc = NULL;\n\n    rc = imap_cmd_step(idata);\n    if (rc != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf + 2;\n\n    /* Obtain list of available flags here, may be overridden by a\n     * PERMANENTFLAGS tag in the OK response */\n    if (mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0)\n    {\n      /* don't override PERMANENTFLAGS */\n      if (STAILQ_EMPTY(&idata->flags))\n      {\n        mutt_debug(3, \"Getting mailbox FLAGS\\n\");\n        pc = get_flags(&idata->flags, pc);\n        if (!pc)\n          goto fail;\n      }\n    }\n    /* PERMANENTFLAGS are massaged to look like FLAGS, then override FLAGS */\n    else if (mutt_str_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");\n      /* safe to call on NULL */\n      mutt_list_free(&idata->flags);\n      /* skip \"OK [PERMANENT\" so syntax is the same as FLAGS */\n      pc += 13;\n      pc = get_flags(&(idata->flags), pc);\n      if (!pc)\n        goto fail;\n    }\n    /* save UIDVALIDITY for the header cache */\n    else if (mutt_str_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &idata->uid_validity) < 0)\n        goto fail;\n      status->uidvalidity = idata->uid_validity;\n    }\n    else if (mutt_str_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)\n    {\n      mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");\n      pc += 3;\n      pc = imap_next_word(pc);\n      if (mutt_str_atoui(pc, &idata->uidnext) < 0)\n        goto fail;\n      status->uidnext = idata->uidnext;\n    }\n    else\n    {\n      pc = imap_next_word(pc);\n      if (mutt_str_strncasecmp(\"EXISTS\", pc, 6) == 0)\n      {\n        count = idata->new_mail_count;\n        idata->new_mail_count = 0;\n      }\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc == IMAP_CMD_NO)\n  {\n    char *s = imap_next_word(idata->buf); /* skip seq */\n    s = imap_next_word(s);                /* Skip response */\n    mutt_error(\"%s\", s);\n    goto fail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto fail;\n\n  /* check for READ-ONLY notification */\n  if ((mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&\n      !mutt_bit_isset(idata->capabilities, ACL))\n  {\n    mutt_debug(2, \"Mailbox is read-only.\\n\");\n    ctx->readonly = true;\n  }\n\n  /* dump the mailbox flags we've found */\n  if (DebugLevel > 2)\n  {\n    if (STAILQ_EMPTY(&idata->flags))\n      mutt_debug(3, \"No folder flags found\\n\");\n    else\n    {\n      struct ListNode *np;\n      struct Buffer flag_buffer;\n      mutt_buffer_init(&flag_buffer);\n      mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");\n      STAILQ_FOREACH(np, &idata->flags, entries)\n      {\n        mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);\n      }\n      mutt_debug(3, \"%s\\n\", flag_buffer.data);\n      FREE(&flag_buffer.data);\n    }\n  }\n\n  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||\n        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))\n  {\n    ctx->readonly = true;\n  }\n\n  ctx->hdrmax = count;\n  ctx->hdrs = mutt_mem_calloc(count, sizeof(struct Header *));\n  ctx->v2r = mutt_mem_calloc(count, sizeof(int));\n  ctx->msgcount = 0;\n\n  if (count && (imap_read_headers(idata, 1, count) < 0))\n  {\n    mutt_error(_(\"Error opening mailbox\"));\n    goto fail;\n  }\n\n  mutt_debug(2, \"msgcount is %d\\n\", ctx->msgcount);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  if (idata->state == IMAP_SELECTED)\n    idata->state = IMAP_AUTHENTICATED;\nfail_noidata:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_mbox_open_append - Implements MxOps::mbox_open_append()\n */\nstatic int imap_mbox_open_append(struct Context *ctx, int flags)\n{\n  struct ImapData *idata = NULL;\n  char mailbox[PATH_MAX];\n  struct ImapMbox mx;\n  int rc;\n\n  if (imap_parse_path(ctx->path, &mx))\n    return -1;\n\n  /* in APPEND mode, we appear to hijack an existing IMAP connection -\n   * ctx is brand new and mostly empty */\n\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n  {\n    FREE(&mx.mbox);\n    return -1;\n  }\n\n  ctx->data = idata;\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n  FREE(&mx.mbox);\n\n  rc = imap_access(ctx->path);\n  if (rc == 0)\n    return 0;\n\n  if (rc == -1)\n    return -1;\n\n  char buf[PATH_MAX + 64];\n  snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);\n  if (Confirmcreate && mutt_yesorno(buf, 1) != MUTT_YES)\n    return -1;\n\n  if (imap_create_mailbox(idata, mailbox) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_mbox_close - Implements MxOps::mbox_close()\n * @retval 0 Always\n */\nstatic int imap_mbox_close(struct Context *ctx)\n{\n  struct ImapData *idata = ctx->data;\n  /* Check to see if the mailbox is actually open */\n  if (!idata)\n    return 0;\n\n  /* imap_mbox_open_append() borrows the struct ImapData temporarily,\n   * just for the connection, but does not set idata->ctx to the\n   * open-append ctx.\n   *\n   * So when these are equal, it means we are actually closing the\n   * mailbox and should clean up idata.  Otherwise, we don't want to\n   * touch idata - it's still being used.\n   */\n  if (ctx == idata->ctx)\n  {\n    if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)\n    {\n      /* mx_mbox_close won't sync if there are no deleted messages\n       * and the mailbox is unchanged, so we may have to close here */\n      if (!ctx->deleted)\n        imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);\n      idata->state = IMAP_AUTHENTICATED;\n    }\n\n    idata->reopen &= IMAP_REOPEN_ALLOW;\n    FREE(&(idata->mailbox));\n    mutt_list_free(&idata->flags);\n    idata->ctx = NULL;\n\n    mutt_hash_destroy(&idata->uid_hash);\n    FREE(&idata->msn_index);\n    idata->msn_index_size = 0;\n    idata->max_msn = 0;\n\n    for (int i = 0; i < IMAP_CACHE_LEN; i++)\n    {\n      if (idata->cache[i].path)\n      {\n        unlink(idata->cache[i].path);\n        FREE(&idata->cache[i].path);\n      }\n    }\n\n    mutt_bcache_close(&idata->bcache);\n  }\n\n  /* free IMAP part of headers */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* mailbox may not have fully loaded */\n    if (ctx->hdrs[i] && ctx->hdrs[i]->data)\n      imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));\n  }\n\n  return 0;\n}\n\n/**\n * imap_msg_open_new - Implements MxOps::msg_open_new()\n */\nstatic int imap_msg_open_new(struct Context *ctx, struct Message *msg, struct Header *hdr)\n{\n  char tmp[PATH_MAX];\n\n  mutt_mktemp(tmp, sizeof(tmp));\n  msg->fp = mutt_file_fopen(tmp, \"w\");\n  if (!msg->fp)\n  {\n    mutt_perror(tmp);\n    return -1;\n  }\n  msg->path = mutt_str_strdup(tmp);\n  return 0;\n}\n\n/**\n * imap_mbox_check - Implements MxOps::mbox_check()\n * @param ctx        Context\n * @param index_hint Remember our place in the index\n * @retval >0 Success, e.g. #MUTT_REOPENED\n * @retval -1 Failure\n */\nstatic int imap_mbox_check(struct Context *ctx, int *index_hint)\n{\n  int rc;\n  (void) index_hint;\n\n  imap_allow_reopen(ctx);\n  rc = imap_check(ctx->data, 0);\n  imap_disallow_reopen(ctx);\n\n  return rc;\n}\n\n/**\n * imap_sync_mailbox - Sync all the changes to the server\n * @param ctx     Context\n * @param expunge 0 or 1 - do expunge?\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_sync_mailbox(struct Context *ctx, int expunge)\n{\n  struct Context *appendctx = NULL;\n  struct Header *h = NULL;\n  struct Header **hdrs = NULL;\n  int oldsort;\n  int rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (idata->state < IMAP_SELECTED)\n  {\n    mutt_debug(2, \"no mailbox selected\\n\");\n    return -1;\n  }\n\n  /* This function is only called when the calling code expects the context\n   * to be changed. */\n  imap_allow_reopen(ctx);\n\n  rc = imap_check(idata, 0);\n  if (rc != 0)\n    return rc;\n\n  /* if we are expunging anyway, we can do deleted messages very quickly... */\n  if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",\n                          MUTT_DELETED, 1, 0);\n    if (rc < 0)\n    {\n      mutt_error(_(\"Expunge failed\"));\n      goto out;\n    }\n\n    if (rc > 0)\n    {\n      /* mark these messages as unchanged so second pass ignores them. Done\n       * here so BOGUS UW-IMAP 4.7 SILENT FLAGS updates are ignored. */\n      for (int i = 0; i < ctx->msgcount; i++)\n        if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)\n          ctx->hdrs[i]->active = false;\n      mutt_message(ngettext(\"Marking %d message deleted...\",\n                            \"Marking %d messages deleted...\", rc),\n                   rc);\n    }\n  }\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n#endif\n\n  /* save messages with real (non-flag) changes */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    h = ctx->hdrs[i];\n\n    if (h->deleted)\n    {\n      imap_cache_del(idata, h);\n#ifdef USE_HCACHE\n      imap_hcache_del(idata, HEADER_DATA(h)->uid);\n#endif\n    }\n\n    if (h->active && h->changed)\n    {\n#ifdef USE_HCACHE\n      imap_hcache_put(idata, h);\n#endif\n      /* if the message has been rethreaded or attachments have been deleted\n       * we delete the message and reupload it.\n       * This works better if we're expunging, of course. */\n      if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||\n          h->attach_del || h->xlabel_changed)\n      {\n        /* L10N: The plural is choosen by the last %d, i.e. the total number */\n        mutt_message(ngettext(\"Saving changed message... [%d/%d]\",\n                              \"Saving changed messages... [%d/%d]\", ctx->msgcount),\n                     i + 1, ctx->msgcount);\n        if (!appendctx)\n          appendctx = mx_mbox_open(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);\n        if (!appendctx)\n          mutt_debug(1, \"Error opening mailbox in append mode\\n\");\n        else\n          mutt_save_message_ctx(h, 1, 0, 0, appendctx);\n        h->xlabel_changed = false;\n      }\n    }\n  }\n\n#ifdef USE_HCACHE\n  imap_hcache_close(idata);\n#endif\n\n  /* presort here to avoid doing 10 resorts in imap_exec_msgset */\n  oldsort = Sort;\n  if (Sort != SORT_ORDER)\n  {\n    hdrs = ctx->hdrs;\n    ctx->hdrs = mutt_mem_malloc(ctx->msgcount * sizeof(struct Header *));\n    memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));\n\n    Sort = SORT_ORDER;\n    qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));\n  }\n\n  rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");\n  if (rc >= 0)\n    rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");\n\n  if (oldsort != Sort)\n  {\n    Sort = oldsort;\n    FREE(&ctx->hdrs);\n    ctx->hdrs = hdrs;\n  }\n\n  /* Flush the queued flags if any were changed in sync_helper. */\n  if (rc > 0)\n    if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)\n      rc = -1;\n\n  if (rc < 0)\n  {\n    if (ctx->closing)\n    {\n      if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)\n      {\n        rc = 0;\n        idata->state = IMAP_AUTHENTICATED;\n        goto out;\n      }\n    }\n    else\n      mutt_error(_(\"Error saving flags\"));\n    rc = -1;\n    goto out;\n  }\n\n  /* Update local record of server state to reflect the synchronization just\n   * completed.  imap_read_headers always overwrites hcache-origin flags, so\n   * there is no need to mutate the hcache after flag-only changes. */\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;\n    HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;\n    HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;\n    HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;\n    HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;\n    ctx->hdrs[i]->changed = false;\n  }\n  ctx->changed = false;\n\n  /* We must send an EXPUNGE command if we're not closing. */\n  if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))\n  {\n    mutt_message(_(\"Expunging messages from server...\"));\n    /* Set expunge bit so we don't get spurious reopened messages */\n    idata->reopen |= IMAP_EXPUNGE_EXPECTED;\n    if (imap_exec(idata, \"EXPUNGE\", 0) != 0)\n    {\n      idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n      imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);\n      rc = -1;\n      goto out;\n    }\n    idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;\n  }\n\n  if (expunge && ctx->closing)\n  {\n    imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);\n    idata->state = IMAP_AUTHENTICATED;\n  }\n\n  if (MessageCacheClean)\n    imap_cache_clean(idata);\n\n  rc = 0;\n\nout:\n  if (appendctx)\n  {\n    mx_fastclose_mailbox(appendctx);\n    FREE(&appendctx);\n  }\n  return rc;\n}\n\n/**\n * imap_tags_edit - Implements MxOps::tags_edit()\n */\nstatic int imap_tags_edit(struct Context *ctx, const char *tags, char *buf, size_t buflen)\n{\n  char *new = NULL;\n  char *checker = NULL;\n  struct ImapData *idata = (struct ImapData *) ctx->data;\n\n  /* Check for \\* flags capability */\n  if (!imap_has_flag(&idata->flags, NULL))\n  {\n    mutt_error(_(\"IMAP server doesn't support custom flags\"));\n    return -1;\n  }\n\n  *buf = '\\0';\n  if (tags)\n    strncpy(buf, tags, buflen);\n\n  if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)\n    return -1;\n\n  /* each keyword must be atom defined by rfc822 as:\n   *\n   * atom           = 1*<any CHAR except specials, SPACE and CTLs>\n   * CHAR           = ( 0.-127. )\n   * specials       = \"(\" / \")\" / \"<\" / \">\" / \"@\"\n   *                  / \",\" / \";\" / \":\" / \"\\\" / <\">\n   *                  / \".\" / \"[\" / \"]\"\n   * SPACE          = ( 32. )\n   * CTLS           = ( 0.-31., 127.)\n   *\n   * And must be separated by one space.\n   */\n\n  new = buf;\n  checker = buf;\n  SKIPWS(checker);\n  while (*checker != '\\0')\n  {\n    if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator\n        *checker == 40 ||                   // (\n        *checker == 41 ||                   // )\n        *checker == 60 ||                   // <\n        *checker == 62 ||                   // >\n        *checker == 64 ||                   // @\n        *checker == 44 ||                   // ,\n        *checker == 59 ||                   // ;\n        *checker == 58 ||                   // :\n        *checker == 92 ||                   // backslash\n        *checker == 34 ||                   // \"\n        *checker == 46 ||                   // .\n        *checker == 91 ||                   // [\n        *checker == 93)                     // ]\n    {\n      mutt_error(_(\"Invalid IMAP flags\"));\n      return 0;\n    }\n\n    /* Skip duplicate space */\n    while (*checker == ' ' && *(checker + 1) == ' ')\n      checker++;\n\n    /* copy char to new and go the next one */\n    *new ++ = *checker++;\n  }\n  *new = '\\0';\n  new = buf; /* rewind */\n  mutt_str_remove_trailing_ws(new);\n\n  if (mutt_str_strcmp(tags, buf) == 0)\n    return 0;\n  return 1;\n}\n\n/**\n * imap_tags_commit - Implements MxOps::tags_commit()\n *\n * This method update the server flags on the server by\n * removing the last know custom flags of a header\n * and adds the local flags\n *\n * If everything success we push the local flags to the\n * last know custom flags (flags_remote).\n *\n * Also this method check that each flags is support by the server\n * first and remove unsupported one.\n */\nstatic int imap_tags_commit(struct Context *ctx, struct Header *hdr, char *buf)\n{\n  struct Buffer *cmd = NULL;\n  char uid[11];\n\n  struct ImapData *idata = ctx->data;\n\n  if (*buf == '\\0')\n    buf = NULL;\n\n  if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))\n    return 0;\n\n  snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(hdr)->uid);\n\n  /* Remove old custom flags */\n  if (HEADER_DATA(hdr)->flags_remote)\n  {\n    cmd = mutt_buffer_new();\n    if (!cmd)\n    {\n      mutt_debug(1, \"unable to allocate buffer\\n\");\n      return -1;\n    }\n    cmd->dptr = cmd->data;\n    mutt_buffer_addstr(cmd, \"UID STORE \");\n    mutt_buffer_addstr(cmd, uid);\n    mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");\n    mutt_buffer_addstr(cmd, HEADER_DATA(hdr)->flags_remote);\n    mutt_buffer_addstr(cmd, \")\");\n\n    /* Should we return here, or we are fine and we could\n     * continue to add new flags *\n     */\n    if (imap_exec(idata, cmd->data, 0) != 0)\n    {\n      mutt_buffer_free(&cmd);\n      return -1;\n    }\n\n    mutt_buffer_free(&cmd);\n  }\n\n  /* Add new custom flags */\n  if (buf)\n  {\n    cmd = mutt_buffer_new();\n    if (!cmd)\n    {\n      mutt_debug(1, \"fail to remove old flags\\n\");\n      return -1;\n    }\n    cmd->dptr = cmd->data;\n    mutt_buffer_addstr(cmd, \"UID STORE \");\n    mutt_buffer_addstr(cmd, uid);\n    mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");\n    mutt_buffer_addstr(cmd, buf);\n    mutt_buffer_addstr(cmd, \")\");\n\n    if (imap_exec(idata, cmd->data, 0) != 0)\n    {\n      mutt_debug(1, \"fail to add new flags\\n\");\n      mutt_buffer_free(&cmd);\n      return -1;\n    }\n\n    mutt_buffer_free(&cmd);\n  }\n\n  /* We are good sync them */\n  mutt_debug(1, \"NEW TAGS: %d\\n\", buf);\n  driver_tags_replace(&hdr->tags, buf);\n  FREE(&HEADER_DATA(hdr)->flags_remote);\n  HEADER_DATA(hdr)->flags_remote = driver_tags_get_with_hidden(&hdr->tags);\n  return 0;\n}\n\n// clang-format off\n/**\n * struct mx_imap_ops - Mailbox callback functions for IMAP mailboxes\n */\nstruct MxOps mx_imap_ops = {\n  .mbox_open        = imap_mbox_open,\n  .mbox_open_append = imap_mbox_open_append,\n  .mbox_check       = imap_mbox_check,\n  .mbox_sync        = NULL, /* imap syncing is handled by imap_sync_mailbox */\n  .mbox_close       = imap_mbox_close,\n  .msg_open         = imap_msg_open,\n  .msg_open_new     = imap_msg_open_new,\n  .msg_commit       = imap_msg_commit,\n  .msg_close        = imap_msg_close,\n  .tags_edit        = imap_tags_edit,\n  .tags_commit      = imap_tags_commit,\n};\n// clang-format on\n", "/**\n * @file\n * Shared constants/structs that are private to IMAP\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _IMAP_PRIVATE_H\n#define _IMAP_PRIVATE_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <time.h>\n#include \"mutt/list.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct Account;\nstruct Buffer;\nstruct Context;\nstruct Header;\nstruct ImapHeaderData;\nstruct ImapMbox;\nstruct Message;\nstruct Progress;\n\n/* -- symbols -- */\n#define IMAP_PORT 143\n#define IMAP_SSL_PORT 993\n\n/* logging levels */\n#define IMAP_LOG_CMD  2\n#define IMAP_LOG_LTRL 4\n#define IMAP_LOG_PASS 5\n\n/* IMAP command responses. Used in ImapCommand.state too */\n#define IMAP_CMD_OK       0  /**< `<tag> OK ...` */\n#define IMAP_CMD_BAD      -1 /**< `<tag> BAD ...` */\n#define IMAP_CMD_NO       -2 /**< `<tag> NO ...` */\n#define IMAP_CMD_CONTINUE 1  /**< `* ...` */\n#define IMAP_CMD_RESPOND  2  /**< `+` */\n#define IMAP_CMD_NEW      3  /**< ImapCommand.state additions */\n\n/* number of entries in the hash table */\n#define IMAP_CACHE_LEN 10\n\n#define SEQLEN 5\n/* maximum length of command lines before they must be split (for\n * lazy servers) */\n#define IMAP_MAX_CMDLEN 1024\n\n#define IMAP_REOPEN_ALLOW     (1 << 0)\n#define IMAP_EXPUNGE_EXPECTED (1 << 1)\n#define IMAP_EXPUNGE_PENDING  (1 << 2)\n#define IMAP_NEWMAIL_PENDING  (1 << 3)\n#define IMAP_FLAGS_PENDING    (1 << 4)\n\n/* imap_exec flags (see imap_exec) */\n#define IMAP_CMD_FAIL_OK (1 << 0)\n#define IMAP_CMD_PASS    (1 << 1)\n#define IMAP_CMD_QUEUE   (1 << 2)\n#define IMAP_CMD_POLL    (1 << 3)\n\n/* length of \"DD-MMM-YYYY HH:MM:SS +ZZzz\" (null-terminated) */\n#define IMAP_DATELEN 27\n\n/**\n * enum ImapFlags - IMAP server responses\n */\nenum ImapFlags\n{\n  IMAP_FATAL = 1,\n  IMAP_BYE\n};\n\n/**\n * enum ImapState - IMAP connection state\n */\nenum ImapState\n{\n  /* States */\n  IMAP_DISCONNECTED = 0,\n  IMAP_CONNECTED,\n  IMAP_AUTHENTICATED,\n  IMAP_SELECTED,\n\n  /* and pseudo-states */\n  IMAP_IDLE\n};\n\n/**\n * enum ImapNamespace - IMAP namespace types\n */\nenum ImapNamespace\n{\n  IMAP_NS_PERSONAL = 0,\n  IMAP_NS_OTHER,\n  IMAP_NS_SHARED\n};\n\n/**\n * enum ImapCaps - Capabilities we are interested in\n *\n * @note This must be kept in the same order as Capabilities.\n */\nenum ImapCaps\n{\n  IMAP4 = 0,\n  IMAP4REV1,\n  STATUS,\n  ACL,           /**< RFC2086: IMAP4 ACL extension */\n  NAMESPACE,     /**< RFC2342: IMAP4 Namespace */\n  ACRAM_MD5,     /**< RFC2195: CRAM-MD5 authentication */\n  AGSSAPI,       /**< RFC1731: GSSAPI authentication */\n  AUTH_ANON,     /**< AUTH=ANONYMOUS */\n  STARTTLS,      /**< RFC2595: STARTTLS */\n  LOGINDISABLED, /**<           LOGINDISABLED */\n  IDLE,          /**< RFC2177: IDLE */\n  SASL_IR,       /**< SASL initial response draft */\n  ENABLE,        /**< RFC5161 */\n  X_GM_EXT1,     /**< https://developers.google.com/gmail/imap/imap-extensions */\n  X_GM_ALT1 = X_GM_EXT1, /**< Alternative capability string */\n\n  CAPMAX\n};\n\n/* imap_conn_find flags */\n#define MUTT_IMAP_CONN_NONEW    (1 << 0)\n#define MUTT_IMAP_CONN_NOSELECT (1 << 1)\n\n/**\n * struct ImapCache - IMAP-specific message cache\n */\nstruct ImapCache\n{\n  unsigned int uid;\n  char *path;\n};\n\n/**\n * struct ImapStatus - Status of an IMAP mailbox\n */\nstruct ImapStatus\n{\n  char *name;\n\n  unsigned int messages;\n  unsigned int recent;\n  unsigned int uidnext;\n  unsigned int uidvalidity;\n  unsigned int unseen;\n};\n\n/**\n * struct ImapList - Items in an IMAP browser\n */\nstruct ImapList\n{\n  char *name;\n  char delim;\n  bool noselect;\n  bool noinferiors;\n};\n\n/**\n * struct ImapCommand - IMAP command structure\n */\nstruct ImapCommand\n{\n  char seq[SEQLEN + 1];\n  int state;\n};\n\n/**\n * enum ImapCommandType - IMAP command type\n */\nenum ImapCommandType\n{\n  IMAP_CT_NONE = 0,\n  IMAP_CT_LIST,\n  IMAP_CT_STATUS\n};\n\n/**\n * struct ImapData - IMAP-specific server data\n *\n * This data is specific to a Connection to an IMAP server\n */\nstruct ImapData\n{\n  struct Connection *conn;\n  bool recovering;\n  unsigned char state;\n  unsigned char status;\n  /* let me explain capstr: SASL needs the capability string (not bits).\n   * we have 3 options:\n   *   1. rerun CAPABILITY inside SASL function.\n   *   2. build appropriate CAPABILITY string by reverse-engineering from bits.\n   *   3. keep a copy until after authentication.\n   * I've chosen (3) for now. (2) might not be too bad, but it involves\n   * tracking all possible capabilities. bah. (1) I don't like because\n   * it's just no fun to get the same information twice */\n  char *capstr;\n  unsigned char capabilities[(CAPMAX + 7) / 8];\n  unsigned int seqno;\n  time_t lastread; /**< last time we read a command for the server */\n  char *buf;\n  size_t blen;\n\n  /* If nonzero, we can send UTF-8, and the server will use UTF8 rather\n   * than mUTF7 */\n  int unicode;\n\n  /* if set, the response parser will store results for complicated commands\n   * here. */\n  enum ImapCommandType cmdtype;\n  void *cmddata;\n\n  /* command queue */\n  struct ImapCommand *cmds;\n  int cmdslots;\n  int nextcmd;\n  int lastcmd;\n  struct Buffer *cmdbuf;\n\n  /* cache ImapStatus of visited mailboxes */\n  struct ListHead mboxcache;\n\n  /* The following data is all specific to the currently SELECTED mbox */\n  char delim;\n  struct Context *ctx;\n  char *mailbox;\n  unsigned short check_status;\n  unsigned char reopen;\n  unsigned int new_mail_count; /**< Set when EXISTS notifies of new mail */\n  struct ImapCache cache[IMAP_CACHE_LEN];\n  struct Hash *uid_hash;\n  unsigned int uid_validity;\n  unsigned int uidnext;\n  struct Header **msn_index;   /**< look up headers by (MSN-1) */\n  size_t msn_index_size;       /**< allocation size */\n  unsigned int max_msn;        /**< the largest MSN fetched so far */\n  struct BodyCache *bcache;\n\n  /* all folder flags - system AND custom flags */\n  struct ListHead flags;\n#ifdef USE_HCACHE\n  header_cache_t *hcache;\n#endif\n};\n\n/* -- private IMAP functions -- */\n/* imap.c */\nint imap_check(struct ImapData *idata, int force);\nint imap_create_mailbox(struct ImapData *idata, char *mailbox);\nint imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname);\nstruct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create);\nvoid imap_mboxcache_free(struct ImapData *idata);\nint imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,\n                     int flag, int changed, int invert);\nint imap_open_connection(struct ImapData *idata);\nvoid imap_close_connection(struct ImapData *idata);\nstruct ImapData *imap_conn_find(const struct Account *account, int flags);\nint imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes, struct Progress *pbar);\nvoid imap_expunge_mailbox(struct ImapData *idata);\nvoid imap_logout(struct ImapData **idata);\nint imap_sync_message_for_copy(struct ImapData *idata, struct Header *hdr, struct Buffer *cmd, int *err_continue);\nbool imap_has_flag(struct ListHead *flag_list, const char *flag);\n\n/* auth.c */\nint imap_authenticate(struct ImapData *idata);\n\n/* command.c */\nint imap_cmd_start(struct ImapData *idata, const char *cmdstr);\nint imap_cmd_step(struct ImapData *idata);\nvoid imap_cmd_finish(struct ImapData *idata);\nbool imap_code(const char *s);\nconst char *imap_cmd_trailer(struct ImapData *idata);\nint imap_exec(struct ImapData *idata, const char *cmdstr, int flags);\nint imap_cmd_idle(struct ImapData *idata);\n\n/* message.c */\nvoid imap_free_header_data(struct ImapHeaderData **data);\nint imap_read_headers(struct ImapData *idata, unsigned int msn_begin, unsigned int msn_end);\nchar *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes);\nint imap_cache_del(struct ImapData *idata, struct Header *h);\nint imap_cache_clean(struct ImapData *idata);\nint imap_append_message(struct Context *ctx, struct Message *msg);\n\nint imap_msg_open(struct Context *ctx, struct Message *msg, int msgno);\nint imap_msg_close(struct Context *ctx, struct Message *msg);\nint imap_msg_commit(struct Context *ctx, struct Message *msg);\n\n/* util.c */\n#ifdef USE_HCACHE\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path);\nvoid imap_hcache_close(struct ImapData *idata);\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid);\nint imap_hcache_put(struct ImapData *idata, struct Header *h);\nint imap_hcache_del(struct ImapData *idata, unsigned int uid);\n#endif\n\nint imap_continue(const char *msg, const char *resp);\nvoid imap_error(const char *where, const char *msg);\nstruct ImapData *imap_new_idata(void);\nvoid imap_free_idata(struct ImapData **idata);\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen);\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen);\nint imap_get_literal_count(const char *buf, unsigned int *bytes);\nchar *imap_get_qualifier(char *buf);\nint imap_mxcmp(const char *mx1, const char *mx2);\nchar *imap_next_word(char *s);\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);\nvoid imap_unquote_string(char *s);\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s);\nint imap_account_match(const struct Account *a1, const struct Account *a2);\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim);\n\n/* utf7.c */\nvoid imap_utf_encode(struct ImapData *idata, char **s);\nvoid imap_utf_decode(struct ImapData *idata, char **s);\nvoid imap_allow_reopen(struct Context *ctx);\nvoid imap_disallow_reopen(struct Context *ctx);\n\n#ifdef USE_HCACHE\n#define imap_hcache_keylen mutt_str_strlen\n#endif /* USE_HCACHE */\n\n#endif /* _IMAP_PRIVATE_H */\n", "/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"message.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n/**\n * imap_expand_path - Canonicalise an IMAP path\n * @param path Buffer containing path\n * @param len  Buffer length\n * @retval  0 Success\n * @retval -1 Error\n *\n * IMAP implementation of mutt_expand_path. Rewrite an IMAP path in canonical\n * and absolute form.  The buffer is rewritten in place with the canonical IMAP\n * path.\n *\n * Function can fail if imap_parse_path() or url_tostring() fail,\n * of if the buffer isn't large enough.\n */\nint imap_expand_path(char *path, size_t len)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  struct Url url;\n  char fixedpath[LONG_STRING];\n  int rc;\n\n  if (imap_parse_path(path, &mx) < 0)\n    return -1;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  mutt_account_tourl(&mx.account, &url);\n  imap_fix_path(idata, mx.mbox, fixedpath, sizeof(fixedpath));\n  url.path = fixedpath;\n\n  rc = url_tostring(&url, path, len, U_DECODE_PASSWD);\n  FREE(&mx.mbox);\n\n  return rc;\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param output Buffer for the result\n * @param mbox   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n * @param delim  Path delimiter\n */\nvoid imap_get_parent(char *output, const char *mbox, size_t olen, char delim)\n{\n  int n;\n\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != output)\n    mutt_str_strfcpy(output, mbox, olen);\n\n  n = mutt_str_strlen(output);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If output[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then output looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If output == '/', then n-- => n == 0, so the loop ends\n   * immediately\n   */\n  for (n--; n >= 0 && output[n] != delim; n--)\n    ;\n\n  /* We stopped before the beginning. There is a trailing\n   * slash.\n   */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    output[n] = '\\0';\n  }\n  else\n  {\n    output[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param output Buffer for the result\n * @param path   Mailbox whose parent is to be determined\n * @param olen   Length of the buffer\n *\n * Provided an imap path, returns in output the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(char *output, const char *path, size_t olen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n  {\n    mutt_str_strfcpy(output, path, olen);\n    return;\n  }\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mbox, mbox, sizeof(mbox), idata->delim);\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(output, olen, &mx, mbox);\n  FREE(&mx.mbox);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapMbox mx;\n  struct ImapData *idata = NULL;\n  char mbox[LONG_STRING] = \"\";\n\n  if (imap_parse_path(path, &mx) < 0)\n    return;\n\n  idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);\n  if (!idata)\n    return;\n\n  /* Stores a fixed path in mbox */\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &mx, mbox);\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_hcache_namer - Generate a filename for the header cache\n * @param path Path for the header cache file\n * @param dest Buffer for result\n * @param dlen Length of buffer\n * @retval num Chars written to dest\n */\nstatic int imap_hcache_namer(const char *path, char *dest, size_t dlen)\n{\n  return snprintf(dest, dlen, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param idata Server data\n * @param path  Path to the header cache\n * @retval ptr HeaderCache\n * @retval NULL Failure\n */\nheader_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param idata Server data\n */\nvoid imap_hcache_close(struct ImapData *idata)\n{\n  if (!idata->hcache)\n    return;\n\n  mutt_hcache_close(idata->hcache);\n  idata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param idata Server data\n * @param uid   UID to find\n * @retval ptr Email Header\n * @retval NULL Failure\n */\nstruct Header *imap_hcache_get(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n  void *uv = NULL;\n  struct Header *h = NULL;\n\n  if (!idata->hcache)\n    return NULL;\n\n  sprintf(key, \"/%u\", uid);\n  uv = mutt_hcache_fetch(idata->hcache, key, imap_hcache_keylen(key));\n  if (uv)\n  {\n    if (*(unsigned int *) uv == idata->uid_validity)\n      h = mutt_hcache_restore(uv);\n    else\n      mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);\n    mutt_hcache_free(idata->hcache, &uv);\n  }\n\n  return h;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param idata Server data\n * @param h     Email Header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapData *idata, struct Header *h)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", HEADER_DATA(h)->uid);\n  return mutt_hcache_store(idata->hcache, key, imap_hcache_keylen(key), h, idata->uid_validity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param idata Server data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapData *idata, unsigned int uid)\n{\n  char key[16];\n\n  if (!idata->hcache)\n    return -1;\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete(idata->hcache, key, imap_hcache_keylen(key));\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into name,host,port\n * @param path Mailbox path to parse\n * @param mx   An IMAP mailbox\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.  mx.mbox is malloc'd, caller must free it\n */\nint imap_parse_path(const char *path, struct ImapMbox *mx)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n  struct servent *service = NULL;\n  struct Url url;\n  char *c = NULL;\n\n  if (!ImapPort)\n  {\n    service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n  if (!ImapsPort)\n  {\n    service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  memset(&mx->account, 0, sizeof(mx->account));\n  mx->account.port = ImapPort;\n  mx->account.type = MUTT_ACCT_TYPE_IMAP;\n\n  c = mutt_str_strdup(path);\n  url_parse(&url, c);\n  if (url.scheme == U_IMAP || url.scheme == U_IMAPS)\n  {\n    if (mutt_account_fromurl(&mx->account, &url) < 0 || !*mx->account.host)\n    {\n      url_free(&url);\n      FREE(&c);\n      return -1;\n    }\n\n    mx->mbox = mutt_str_strdup(url.path);\n\n    if (url.scheme == U_IMAPS)\n      mx->account.flags |= MUTT_ACCT_SSL;\n\n    url_free(&url);\n    FREE(&c);\n  }\n  /* old PINE-compatibility code */\n  else\n  {\n    url_free(&url);\n    FREE(&c);\n    char tmp[128];\n    if (sscanf(path, \"{%127[^}]}\", tmp) != 1)\n      return -1;\n\n    c = strchr(path, '}');\n    if (!c)\n      return -1;\n    else\n    {\n      /* walk past closing '}' */\n      mx->mbox = mutt_str_strdup(c + 1);\n    }\n\n    c = strrchr(tmp, '@');\n    if (c)\n    {\n      *c = '\\0';\n      mutt_str_strfcpy(mx->account.user, tmp, sizeof(mx->account.user));\n      mutt_str_strfcpy(tmp, c + 1, sizeof(tmp));\n      mx->account.flags |= MUTT_ACCT_USER;\n    }\n\n    const int n = sscanf(tmp, \"%127[^:/]%127s\", mx->account.host, tmp);\n    if (n < 1)\n    {\n      mutt_debug(1, \"NULL host in %s\\n\", path);\n      FREE(&mx->mbox);\n      return -1;\n    }\n\n    if (n > 1)\n    {\n      if (sscanf(tmp, \":%hu%127s\", &(mx->account.port), tmp) >= 1)\n        mx->account.flags |= MUTT_ACCT_PORT;\n      if (sscanf(tmp, \"/%s\", tmp) == 1)\n      {\n        if (mutt_str_strncmp(tmp, \"ssl\", 3) == 0)\n          mx->account.flags |= MUTT_ACCT_SSL;\n        else\n        {\n          mutt_debug(1, \"Unknown connection type in %s\\n\", path);\n          FREE(&mx->mbox);\n          return -1;\n        }\n      }\n    }\n  }\n\n  if ((mx->account.flags & MUTT_ACCT_SSL) && !(mx->account.flags & MUTT_ACCT_PORT))\n    mx->account.port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || !*mx1)\n    mx1 = \"INBOX\";\n  if (!mx2 || !*mx2)\n    mx2 = \"INBOX\";\n  if ((mutt_str_strcasecmp(mx1, \"INBOX\") == 0) &&\n      (mutt_str_strcasecmp(mx2, \"INBOX\") == 0))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path(NULL, mx1, b1, strlen(mx1) + 1);\n  imap_fix_path(NULL, mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_strcmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path Mailbox name to be tidied\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path)\n{\n  struct ImapMbox home, target;\n  struct Url url;\n  char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n\n  if (imap_parse_path(path, &target) < 0)\n    return;\n\n  tlen = mutt_str_strlen(target.mbox);\n  /* check whether we can do '=' substitution */\n  if (mx_is_imap(Folder) && !imap_parse_path(Folder, &home))\n  {\n    hlen = mutt_str_strlen(home.mbox);\n    if (tlen && mutt_account_match(&home.account, &target.account) &&\n        (mutt_str_strncmp(home.mbox, target.mbox, hlen) == 0))\n    {\n      if (hlen == 0)\n        home_match = true;\n      else if (ImapDelimChars)\n      {\n        for (delim = ImapDelimChars; *delim != '\\0'; delim++)\n          if (target.mbox[hlen] == *delim)\n            home_match = true;\n      }\n    }\n    FREE(&home.mbox);\n  }\n\n  /* do the '=' substitution */\n  if (home_match)\n  {\n    *path++ = '=';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target.mbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n  }\n  else\n  {\n    mutt_account_tourl(&target.account, &url);\n    url.path = target.mbox;\n    /* FIXME: That hard-coded constant is bogus. But we need the actual\n     *   size of the buffer from mutt_pretty_mailbox. And these pretty\n     *   operations usually shrink the result. Still... */\n    url_tostring(&url, path, 1024, 0);\n  }\n\n  FREE(&target.mbox);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval num Result: #MUTT_YES, #MUTT_NO, #MUTT_ABORT\n */\nint imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), 0);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\\n\", where, msg);\n}\n\n/**\n * imap_new_idata - Allocate and initialise a new ImapData structure\n * @retval NULL Failure (no mem)\n * @retval ptr New ImapData\n */\nstruct ImapData *imap_new_idata(void)\n{\n  struct ImapData *idata = mutt_mem_calloc(1, sizeof(struct ImapData));\n\n  idata->cmdbuf = mutt_buffer_new();\n  idata->cmdslots = ImapPipelineDepth + 2;\n  idata->cmds = mutt_mem_calloc(idata->cmdslots, sizeof(*idata->cmds));\n\n  STAILQ_INIT(&idata->flags);\n  STAILQ_INIT(&idata->mboxcache);\n\n  return idata;\n}\n\n/**\n * imap_free_idata - Release and clear storage in an ImapData structure\n * @param idata Server data\n */\nvoid imap_free_idata(struct ImapData **idata)\n{\n  if (!idata)\n    return;\n\n  FREE(&(*idata)->capstr);\n  mutt_list_free(&(*idata)->flags);\n  imap_mboxcache_free(*idata);\n  mutt_buffer_free(&(*idata)->cmdbuf);\n  FREE(&(*idata)->buf);\n  mutt_bcache_close(&(*idata)->bcache);\n  FREE(&(*idata)->cmds);\n  FREE(idata);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param idata   Server data\n * @param mailbox Mailbox path\n * @param path    Buffer for the result\n * @param plen    Length of buffer\n * @retval ptr Fixed-up path\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  char delim = '\\0';\n\n  if (idata)\n    delim = idata->delim;\n\n  while (mailbox && *mailbox && i < plen - 1)\n  {\n    if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))\n    {\n      /* use connection delimiter if known. Otherwise use user delimiter */\n      if (!idata)\n        delim = *mailbox;\n\n      while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||\n                          (delim && *mailbox == delim)))\n      {\n        mailbox++;\n      }\n      path[i] = delim;\n    }\n    else\n    {\n      path[i] = *mailbox;\n      mailbox++;\n    }\n    i++;\n  }\n  if (i && path[--i] != delim)\n    i++;\n  path[i] = '\\0';\n\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param idata   Server data\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n * @param dlen    Length of buffer\n */\nvoid imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  int quoted = 0;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = quoted ? 0 : 1;\n    if (!quoted && ISSPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param dest Buffer for the result\n * @param len  Length of buffer\n * @param mx   Imap mailbox\n * @param path Path relative to the mailbox\n *\n * given ImapMbox and relative path.\n */\nvoid imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path)\n{\n  struct Url url;\n\n  mutt_account_tourl(&mx->account, &url);\n  url.path = path;\n\n  url_tostring(&url, dest, len, 0);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest Buffer for the result\n * @param dlen Length of the buffer\n * @param src  String to be quoted\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param idata Server data\n * @param dest  Buffer to store safe mailbox name\n * @param dlen  Length of buffer\n * @param src   Mailbox name\n */\nvoid imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param idata Server data\n * @param s     Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(struct ImapData *idata, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_strdup(s);\n  if (buf)\n  {\n    imap_utf_decode(idata, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  struct Connection *conn = NULL;\n  struct ImapData *idata = NULL;\n  time_t now = time(NULL);\n\n  TAILQ_FOREACH(conn, mutt_socket_head(), entries)\n  {\n    if (conn->account.type == MUTT_ACCT_TYPE_IMAP)\n    {\n      idata = conn->data;\n      if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)\n      {\n        imap_check(idata, 1);\n      }\n    }\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  bool imap_passive = ImapPassive;\n\n  ImapPassive = true;\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  alarm(ImapKeepalive);\n  while (waitpid(pid, &rc, 0) < 0 && errno == EINTR)\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(ImapKeepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  if (!imap_passive)\n    ImapPassive = false;\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_allow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param ctx Context\n */\nvoid imap_disallow_reopen(struct Context *ctx)\n{\n  struct ImapData *idata = NULL;\n  if (!ctx || !ctx->data || ctx->magic != MUTT_IMAP)\n    return;\n\n  idata = ctx->data;\n  if (idata->ctx == ctx)\n    idata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First Account\n * @param a2 Second Account\n * @retval true Accounts match\n */\nint imap_account_match(const struct Account *a1, const struct Account *a2)\n{\n  struct ImapData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);\n  struct ImapData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);\n  const struct Account *a1_canon = a1_idata == NULL ? a1 : &a1_idata->conn->account;\n  const struct Account *a2_canon = a2_idata == NULL ? a2 : &a2_idata->conn->account;\n\n  return mutt_account_match(a1_canon, a2_canon);\n}\n"], "filenames": ["imap/auth_login.c", "imap/command.c", "imap/imap.c", "imap/imap_private.h", "imap/util.c"], "buggy_code_start_loc": [68, 502, 467, 331, 801], "buggy_code_end_loc": [70, 503, 499, 332, 878], "fixing_code_start_loc": [68, 502, 467, 331, 801], "fixing_code_end_loc": [70, 503, 499, 332, 881], "type": "CWE-78", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.", "other": {"cve": {"id": "CVE-2018-14357", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.700", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. Permiten que los servidores IMAP remotos ejecuten comandos arbitrarios mediante caracteres de acento grave; esto est\u00e1 relacionado con el comando mailboxes asociado con una suscripci\u00f3n autom\u00e1tica."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2526", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/185152818541f5cdc059cbff3f3e8b654fc27c1d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725"}}