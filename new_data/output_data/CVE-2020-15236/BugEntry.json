{"buggy_code": ["const qs = require('querystring')\nconst _ = require('lodash')\nconst crypto = require('crypto')\nconst path = require('path')\n\nconst localeSegmentRegex = /^[A-Z]{2}(-[A-Z]{2})?$/i\nconst localeFolderRegex = /^([a-z]{2}(?:-[a-z]{2})?\\/)?(.*)/i\n\nconst contentToExt = {\n  markdown: 'md',\n  html: 'html'\n}\nconst extToContent = _.invert(contentToExt)\n\n/* global WIKI */\n\nmodule.exports = {\n  /**\n   * Parse raw url path and make it safe\n   */\n  parsePath (rawPath, opts = {}) {\n    let pathObj = {\n      locale: WIKI.config.lang.code,\n      path: 'home',\n      private: false,\n      privateNS: '',\n      explicitLocale: false\n    }\n\n    // Clean Path\n    rawPath = _.trim(qs.unescape(rawPath))\n    if (_.startsWith(rawPath, '/')) { rawPath = rawPath.substring(1) }\n    if (rawPath === '') { rawPath = 'home' }\n\n    // Extract Info\n    let pathParts = _.filter(_.split(rawPath, '/'), p => !_.isEmpty(p))\n    if (pathParts[0].length === 1) {\n      pathParts.shift()\n    }\n    if (localeSegmentRegex.test(pathParts[0])) {\n      pathObj.locale = pathParts[0]\n      pathObj.explicitLocale = true\n      pathParts.shift()\n    }\n\n    // Strip extension\n    if (opts.stripExt && pathParts.length > 0) {\n      const lastPart = _.last(pathParts)\n      if (lastPart.indexOf('.') > 0) {\n        pathParts.pop()\n        const lastPartMeta = path.parse(lastPart)\n        pathParts.push(lastPartMeta.name)\n      }\n    }\n\n    pathObj.path = _.join(pathParts, '/')\n    return pathObj\n  },\n  /**\n   * Generate unique hash from page\n   */\n  generateHash(opts) {\n    return crypto.createHash('sha1').update(`${opts.locale}|${opts.path}|${opts.privateNS}`).digest('hex')\n  },\n  /**\n   * Inject Page Metadata\n   */\n  injectPageMetadata(page) {\n    let meta = [\n      ['title', page.title],\n      ['description', page.description],\n      ['published', page.isPublished.toString()],\n      ['date', page.updatedAt],\n      ['tags', page.tags ? page.tags.map(t => t.tag).join(', ') : ''],\n      ['editor', page.editorKey],\n      ['dateCreated', page.createdAt],\n    ]\n    switch (page.contentType) {\n      case 'markdown':\n        return '---\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n---\\n\\n' + page.content\n      case 'html':\n        return '<!--\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n-->\\n\\n' + page.content\n      case 'json':\n        return {\n          ...page.content,\n          _meta: _.fromPairs(meta)\n        }\n      default:\n        return page.content\n    }\n  },\n  /**\n   * Check if path is a reserved path\n   */\n  isReservedPath(rawPath) {\n    const firstSection = _.head(rawPath.split('/'))\n    if (firstSection.length <= 1) {\n      return true\n    } else if (localeSegmentRegex.test(firstSection)) {\n      return true\n    } else if (\n      _.some(WIKI.data.reservedPaths, p => {\n        return p === firstSection\n      })) {\n      return true\n    } else {\n      return false\n    }\n  },\n  /**\n   * Get file extension from content type\n   */\n  getFileExtension(contentType) {\n    return _.get(contentToExt, contentType, 'txt')\n  },\n  /**\n   * Get content type from file extension\n   */\n  getContentType (filePath) {\n    const ext = _.last(filePath.split('.'))\n    return _.get(extToContent, ext, false)\n  },\n  /**\n   * Get Page Meta object from disk path\n   */\n  getPagePath (filePath) {\n    let fpath = filePath\n    if (process.platform === 'win32') {\n      fpath = filePath.replace(/\\\\/g, '/')\n    }\n    let meta = {\n      locale: WIKI.config.lang.code,\n      path: _.initial(fpath.split('.')).join('')\n    }\n    const result = localeFolderRegex.exec(meta.path)\n    if (result[1]) {\n      meta = {\n        locale: result[1].replace('/', ''),\n        path: result[2]\n      }\n    }\n    return meta\n  }\n}\n"], "fixing_code": ["const qs = require('querystring')\nconst _ = require('lodash')\nconst crypto = require('crypto')\nconst path = require('path')\n\nconst localeSegmentRegex = /^[A-Z]{2}(-[A-Z]{2})?$/i\nconst localeFolderRegex = /^([a-z]{2}(?:-[a-z]{2})?\\/)?(.*)/i\n// eslint-disable-next-line no-control-regex\nconst unsafeCharsRegex = /[\\x00-\\x1f\\x80-\\x9f\\\\\"|<>:*?]/\n\nconst contentToExt = {\n  markdown: 'md',\n  html: 'html'\n}\nconst extToContent = _.invert(contentToExt)\n\n/* global WIKI */\n\nmodule.exports = {\n  /**\n   * Parse raw url path and make it safe\n   */\n  parsePath (rawPath, opts = {}) {\n    let pathObj = {\n      locale: WIKI.config.lang.code,\n      path: 'home',\n      private: false,\n      privateNS: '',\n      explicitLocale: false\n    }\n\n    // Clean Path\n    rawPath = _.trim(qs.unescape(rawPath))\n    if (_.startsWith(rawPath, '/')) { rawPath = rawPath.substring(1) }\n    rawPath = rawPath.replace(unsafeCharsRegex, '')\n    if (rawPath === '') { rawPath = 'home' }\n\n    // Extract Info\n    let pathParts = _.filter(_.split(rawPath, '/'), p => {\n      p = _.trim(p)\n      return !_.isEmpty(p) && p !== '..' && p !== '.'\n    })\n    if (pathParts[0].length === 1) {\n      pathParts.shift()\n    }\n    if (localeSegmentRegex.test(pathParts[0])) {\n      pathObj.locale = pathParts[0]\n      pathObj.explicitLocale = true\n      pathParts.shift()\n    }\n\n    // Strip extension\n    if (opts.stripExt && pathParts.length > 0) {\n      const lastPart = _.last(pathParts)\n      if (lastPart.indexOf('.') > 0) {\n        pathParts.pop()\n        const lastPartMeta = path.parse(lastPart)\n        pathParts.push(lastPartMeta.name)\n      }\n    }\n\n    pathObj.path = _.join(pathParts, '/')\n    return pathObj\n  },\n  /**\n   * Generate unique hash from page\n   */\n  generateHash(opts) {\n    return crypto.createHash('sha1').update(`${opts.locale}|${opts.path}|${opts.privateNS}`).digest('hex')\n  },\n  /**\n   * Inject Page Metadata\n   */\n  injectPageMetadata(page) {\n    let meta = [\n      ['title', page.title],\n      ['description', page.description],\n      ['published', page.isPublished.toString()],\n      ['date', page.updatedAt],\n      ['tags', page.tags ? page.tags.map(t => t.tag).join(', ') : ''],\n      ['editor', page.editorKey],\n      ['dateCreated', page.createdAt]\n    ]\n    switch (page.contentType) {\n      case 'markdown':\n        return '---\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n---\\n\\n' + page.content\n      case 'html':\n        return '<!--\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n-->\\n\\n' + page.content\n      case 'json':\n        return {\n          ...page.content,\n          _meta: _.fromPairs(meta)\n        }\n      default:\n        return page.content\n    }\n  },\n  /**\n   * Check if path is a reserved path\n   */\n  isReservedPath(rawPath) {\n    const firstSection = _.head(rawPath.split('/'))\n    if (firstSection.length <= 1) {\n      return true\n    } else if (localeSegmentRegex.test(firstSection)) {\n      return true\n    } else if (\n      _.some(WIKI.data.reservedPaths, p => {\n        return p === firstSection\n      })) {\n      return true\n    } else {\n      return false\n    }\n  },\n  /**\n   * Get file extension from content type\n   */\n  getFileExtension(contentType) {\n    return _.get(contentToExt, contentType, 'txt')\n  },\n  /**\n   * Get content type from file extension\n   */\n  getContentType (filePath) {\n    const ext = _.last(filePath.split('.'))\n    return _.get(extToContent, ext, false)\n  },\n  /**\n   * Get Page Meta object from disk path\n   */\n  getPagePath (filePath) {\n    let fpath = filePath\n    if (process.platform === 'win32') {\n      fpath = filePath.replace(/\\\\/g, '/')\n    }\n    let meta = {\n      locale: WIKI.config.lang.code,\n      path: _.initial(fpath.split('.')).join('')\n    }\n    const result = localeFolderRegex.exec(meta.path)\n    if (result[1]) {\n      meta = {\n        locale: result[1].replace('/', ''),\n        path: result[2]\n      }\n    }\n    return meta\n  }\n}\n"], "filenames": ["server/helpers/page.js"], "buggy_code_start_loc": [7], "buggy_code_end_loc": [77], "fixing_code_start_loc": [8], "fixing_code_end_loc": [83], "type": "CWE-22", "message": "In Wiki.js before version 2.5.151, directory traversal outside of Wiki.js context is possible when a storage module with local asset cache fetching is enabled. A malicious user can potentially read any file on the file system by crafting a special URL that allows for directory traversal. This is only possible when a storage module implementing local asset cache (e.g Local File System or Git) is enabled and that no web application firewall solution (e.g. cloudflare) strips potentially malicious URLs. Commit 084dcd69d1591586ee4752101e675d5f0ac6dcdc fixes this vulnerability by sanitizing the path before it is passed on to the storage module. The sanitization step removes any directory traversal (e.g. `..` and `.`) sequences as well as invalid filesystem characters from the path. As a workaround, disable any storage module with local asset caching capabilities such as Local File System and Git.", "other": {"cve": {"id": "CVE-2020-15236", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-05T15:15:12.047", "lastModified": "2020-10-09T17:06:03.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Wiki.js before version 2.5.151, directory traversal outside of Wiki.js context is possible when a storage module with local asset cache fetching is enabled. A malicious user can potentially read any file on the file system by crafting a special URL that allows for directory traversal. This is only possible when a storage module implementing local asset cache (e.g Local File System or Git) is enabled and that no web application firewall solution (e.g. cloudflare) strips potentially malicious URLs. Commit 084dcd69d1591586ee4752101e675d5f0ac6dcdc fixes this vulnerability by sanitizing the path before it is passed on to the storage module. The sanitization step removes any directory traversal (e.g. `..` and `.`) sequences as well as invalid filesystem characters from the path. As a workaround, disable any storage module with local asset caching capabilities such as Local File System and Git."}, {"lang": "es", "value": "En Wiki.js versiones anteriores a 2.5.151, el salto de directorio fuera del contexto de Wiki.js es posible cuando es habilitado un m\u00f3dulo de almacenamiento con una extracci\u00f3n de cach\u00e9 de activo local.&#xa0;Un usuario malicioso puede leer potencialmente cualquier archivo en el sistema de archivos dise\u00f1ando una URL especial que permita un salto de directorio.&#xa0;Esto solo es posible cuando un m\u00f3dulo de almacenamiento que implementa la cach\u00e9 de activos local (por ejemplo, Local File System o Git) est\u00e1 habilitado y ninguna correcci\u00f3n de firewall de aplicaciones web (por ejemplo, cloudflare) elimina las URL potencialmente maliciosas.&#xa0;Commit 084dcd69d1591586ee4752101e675d5f0ac6dcdc corrige esta vulnerabilidad saneando la ruta antes de pasarla hacia el m\u00f3dulo de almacenamiento.&#xa0;El paso del saneamiento elimina cualquier secuencia de salto de directorio (por ejemplo, \"..\" y \".\"), as\u00ed como los caracteres del sistema de archivos no v\u00e1lidos de la ruta.&#xa0;Como soluci\u00f3n alternativa, deshabilitar cualquier m\u00f3dulo de almacenamiento con capacidades de hacer cache de activos locales como el Local File System o Git"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.80", "versionEndExcluding": "2.5.151", "matchCriteriaId": "648B7617-D52A-4CF4-8081-6A5E7C49415A"}]}]}], "references": [{"url": "https://github.com/Requarks/wiki/commit/084dcd69d1591586ee4752101e675d5f0ac6dcdc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/security/advisories/GHSA-whpv-5xg2-w527", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Requarks/wiki/commit/084dcd69d1591586ee4752101e675d5f0ac6dcdc"}}