{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * mark.c: functions for setting marks and jumping to them\n */\n\n#include \"vim.h\"\n\n/*\n * This file contains routines to maintain and manipulate marks.\n */\n\n/*\n * If a named file mark's lnum is non-zero, it is valid.\n * If a named file mark's fnum is non-zero, it is for an existing buffer,\n * otherwise it is from .viminfo and namedfm[n].fname is the file name.\n * There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing\n * viminfo).\n */\nstatic xfmark_T namedfm[NMARKS + EXTRA_MARKS];\t\t// marks with file nr\n\nstatic void fname2fnum(xfmark_T *fm);\nstatic void fmarks_check_one(xfmark_T *fm, char_u *name, buf_T *buf);\nstatic char_u *mark_line(pos_T *mp, int lead_len);\nstatic void show_one_mark(int, char_u *, pos_T *, char_u *, int current);\nstatic void mark_adjust_internal(linenr_T line1, linenr_T line2, long amount,\n    long amount_after, int adjust_folds);\n\n/*\n * Set named mark \"c\" at current cursor position.\n * Returns OK on success, FAIL if bad name given.\n */\n    int\nsetmark(int c)\n{\n    return setmark_pos(c, &curwin->w_cursor, curbuf->b_fnum);\n}\n\n/*\n * Set named mark \"c\" to position \"pos\".\n * When \"c\" is upper case use file \"fnum\".\n * Returns OK on success, FAIL if bad name given.\n */\n    int\nsetmark_pos(int c, pos_T *pos, int fnum)\n{\n    int\t\ti;\n    buf_T\t*buf;\n\n    // Check for a special key (may cause islower() to crash).\n    if (c < 0)\n\treturn FAIL;\n\n    if (c == '\\'' || c == '`')\n    {\n\tif (pos == &curwin->w_cursor)\n\t{\n\t    setpcmark();\n\t    // keep it even when the cursor doesn't move\n\t    curwin->w_prev_pcmark = curwin->w_pcmark;\n\t}\n\telse\n\t    curwin->w_pcmark = *pos;\n\treturn OK;\n    }\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL)\n\treturn FAIL;\n\n    if (c == '\"')\n    {\n\tbuf->b_last_cursor = *pos;\n\treturn OK;\n    }\n\n    // Allow setting '[ and '] for an autocommand that simulates reading a\n    // file.\n    if (c == '[')\n    {\n\tbuf->b_op_start = *pos;\n\treturn OK;\n    }\n    if (c == ']')\n    {\n\tbuf->b_op_end = *pos;\n\treturn OK;\n    }\n\n    if (c == '<' || c == '>')\n    {\n\tif (c == '<')\n\t    buf->b_visual.vi_start = *pos;\n\telse\n\t    buf->b_visual.vi_end = *pos;\n\tif (buf->b_visual.vi_mode == NUL)\n\t    // Visual_mode has not yet been set, use a sane default.\n\t    buf->b_visual.vi_mode = 'v';\n\treturn OK;\n    }\n\n    if (ASCII_ISLOWER(c))\n    {\n\ti = c - 'a';\n\tbuf->b_namedm[i] = *pos;\n\treturn OK;\n    }\n    if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))\n    {\n\tif (VIM_ISDIGIT(c))\n\t    i = c - '0' + NMARKS;\n\telse\n\t    i = c - 'A';\n\tnamedfm[i].fmark.mark = *pos;\n\tnamedfm[i].fmark.fnum = fnum;\n\tVIM_CLEAR(namedfm[i].fname);\n#ifdef FEAT_VIMINFO\n\tnamedfm[i].time_set = vim_time();\n#endif\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Set the previous context mark to the current position and add it to the\n * jump list.\n */\n    void\nsetpcmark(void)\n{\n    int\t\ti;\n    xfmark_T\t*fm;\n\n    // for :global the mark is set only once\n    if (global_busy || listcmd_busy || (cmdmod.cmod_flags & CMOD_KEEPJUMPS))\n\treturn;\n\n    curwin->w_prev_pcmark = curwin->w_pcmark;\n    curwin->w_pcmark = curwin->w_cursor;\n\n    // If jumplist is full: remove oldest entry\n    if (++curwin->w_jumplistlen > JUMPLISTSIZE)\n    {\n\tcurwin->w_jumplistlen = JUMPLISTSIZE;\n\tvim_free(curwin->w_jumplist[0].fname);\n\tfor (i = 1; i < JUMPLISTSIZE; ++i)\n\t    curwin->w_jumplist[i - 1] = curwin->w_jumplist[i];\n    }\n    curwin->w_jumplistidx = curwin->w_jumplistlen;\n    fm = &curwin->w_jumplist[curwin->w_jumplistlen - 1];\n\n    fm->fmark.mark = curwin->w_pcmark;\n    fm->fmark.fnum = curbuf->b_fnum;\n    fm->fname = NULL;\n#ifdef FEAT_VIMINFO\n    fm->time_set = vim_time();\n#endif\n}\n\n/*\n * To change context, call setpcmark(), then move the current position to\n * where ever, then call checkpcmark().  This ensures that the previous\n * context will only be changed if the cursor moved to a different line.\n * If pcmark was deleted (with \"dG\") the previous mark is restored.\n */\n    void\ncheckpcmark(void)\n{\n    if (curwin->w_prev_pcmark.lnum != 0\n\t    && (EQUAL_POS(curwin->w_pcmark, curwin->w_cursor)\n\t\t|| curwin->w_pcmark.lnum == 0))\n\tcurwin->w_pcmark = curwin->w_prev_pcmark;\n    curwin->w_prev_pcmark.lnum = 0;\t\t// it has been checked\n}\n\n/*\n * move \"count\" positions in the jump list (count may be negative)\n */\n    pos_T *\nmovemark(int count)\n{\n    pos_T\t*pos;\n    xfmark_T\t*jmp;\n\n    cleanup_jumplist(curwin, TRUE);\n\n    if (curwin->w_jumplistlen == 0)\t    // nothing to jump to\n\treturn (pos_T *)NULL;\n\n    for (;;)\n    {\n\tif (curwin->w_jumplistidx + count < 0\n\t\t|| curwin->w_jumplistidx + count >= curwin->w_jumplistlen)\n\t    return (pos_T *)NULL;\n\n\t/*\n\t * if first CTRL-O or CTRL-I command after a jump, add cursor position\n\t * to list.  Careful: If there are duplicates (CTRL-O immediately after\n\t * starting Vim on a file), another entry may have been removed.\n\t */\n\tif (curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t{\n\t    setpcmark();\n\t    --curwin->w_jumplistidx;\t// skip the new entry\n\t    if (curwin->w_jumplistidx + count < 0)\n\t\treturn (pos_T *)NULL;\n\t}\n\n\tcurwin->w_jumplistidx += count;\n\n\tjmp = curwin->w_jumplist + curwin->w_jumplistidx;\n\tif (jmp->fmark.fnum == 0)\n\t    fname2fnum(jmp);\n\tif (jmp->fmark.fnum != curbuf->b_fnum)\n\t{\n\t    // jump to other file\n\t    if (buflist_findnr(jmp->fmark.fnum) == NULL)\n\t    {\t\t\t\t\t     // Skip this one ..\n\t\tcount += count < 0 ? -1 : 1;\n\t\tcontinue;\n\t    }\n\t    if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,\n\t\t\t\t\t\t\t    0, FALSE) == FAIL)\n\t\treturn (pos_T *)NULL;\n\t    // Set lnum again, autocommands my have changed it\n\t    curwin->w_cursor = jmp->fmark.mark;\n\t    pos = (pos_T *)-1;\n\t}\n\telse\n\t    pos = &(jmp->fmark.mark);\n\treturn pos;\n    }\n}\n\n/*\n * Move \"count\" positions in the changelist (count may be negative).\n */\n    pos_T *\nmovechangelist(int count)\n{\n    int\t\tn;\n\n    if (curbuf->b_changelistlen == 0)\t    // nothing to jump to\n\treturn (pos_T *)NULL;\n\n    n = curwin->w_changelistidx;\n    if (n + count < 0)\n    {\n\tif (n == 0)\n\t    return (pos_T *)NULL;\n\tn = 0;\n    }\n    else if (n + count >= curbuf->b_changelistlen)\n    {\n\tif (n == curbuf->b_changelistlen - 1)\n\t    return (pos_T *)NULL;\n\tn = curbuf->b_changelistlen - 1;\n    }\n    else\n\tn += count;\n    curwin->w_changelistidx = n;\n    return curbuf->b_changelist + n;\n}\n\n/*\n * Find mark \"c\" in buffer pointed to by \"buf\".\n * If \"changefile\" is TRUE it's allowed to edit another file for '0, 'A, etc.\n * If \"fnum\" is not NULL store the fnum there for '0, 'A etc., don't edit\n * another file.\n * Returns:\n * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is\n *   in another file which can't be gotten. (caller needs to check lnum!)\n * - NULL if there is no mark called 'c'.\n * - -1 if mark is in other file and jumped there (only if changefile is TRUE)\n */\n    pos_T *\ngetmark_buf(buf_T *buf, int c, int changefile)\n{\n    return getmark_buf_fnum(buf, c, changefile, NULL);\n}\n\n    pos_T *\ngetmark(int c, int changefile)\n{\n    return getmark_buf_fnum(curbuf, c, changefile, NULL);\n}\n\n    pos_T *\ngetmark_buf_fnum(\n    buf_T\t*buf,\n    int\t\tc,\n    int\t\tchangefile,\n    int\t\t*fnum)\n{\n    pos_T\t\t*posp;\n    pos_T\t\t*startp, *endp;\n    static pos_T\tpos_copy;\n\n    posp = NULL;\n\n    // Check for special key, can't be a mark name and might cause islower()\n    // to crash.\n    if (c < 0)\n\treturn posp;\n    if (c > '~')\t\t\t// check for islower()/isupper()\n\t;\n    else if (c == '\\'' || c == '`')\t// previous context mark\n    {\n\tpos_copy = curwin->w_pcmark;\t// need to make a copy because\n\tposp = &pos_copy;\t\t//   w_pcmark may be changed soon\n    }\n    else if (c == '\"')\t\t\t// to pos when leaving buffer\n\tposp = &(buf->b_last_cursor);\n    else if (c == '^')\t\t\t// to where Insert mode stopped\n\tposp = &(buf->b_last_insert);\n    else if (c == '.')\t\t\t// to where last change was made\n\tposp = &(buf->b_last_change);\n    else if (c == '[')\t\t\t// to start of previous operator\n\tposp = &(buf->b_op_start);\n    else if (c == ']')\t\t\t// to end of previous operator\n\tposp = &(buf->b_op_end);\n    else if (c == '{' || c == '}')\t// to previous/next paragraph\n    {\n\tpos_T\tpos;\n\toparg_T\toa;\n\tint\tslcb = listcmd_busy;\n\n\tpos = curwin->w_cursor;\n\tlistcmd_busy = TRUE;\t    // avoid that '' is changed\n\tif (findpar(&oa.inclusive,\n\t\t\t       c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE))\n\t{\n\t    pos_copy = curwin->w_cursor;\n\t    posp = &pos_copy;\n\t}\n\tcurwin->w_cursor = pos;\n\tlistcmd_busy = slcb;\n    }\n    else if (c == '(' || c == ')')\t// to previous/next sentence\n    {\n\tpos_T\tpos;\n\tint\tslcb = listcmd_busy;\n\n\tpos = curwin->w_cursor;\n\tlistcmd_busy = TRUE;\t    // avoid that '' is changed\n\tif (findsent(c == ')' ? FORWARD : BACKWARD, 1L))\n\t{\n\t    pos_copy = curwin->w_cursor;\n\t    posp = &pos_copy;\n\t}\n\tcurwin->w_cursor = pos;\n\tlistcmd_busy = slcb;\n    }\n    else if (c == '<' || c == '>')\t// start/end of visual area\n    {\n\tstartp = &buf->b_visual.vi_start;\n\tendp = &buf->b_visual.vi_end;\n\tif (((c == '<') == LT_POS(*startp, *endp) || endp->lnum == 0)\n\t\t\t\t\t\t\t  && startp->lnum != 0)\n\t    posp = startp;\n\telse\n\t    posp = endp;\n\t/*\n\t * For Visual line mode, set mark at begin or end of line\n\t */\n\tif (buf->b_visual.vi_mode == 'V')\n\t{\n\t    pos_copy = *posp;\n\t    posp = &pos_copy;\n\t    if (c == '<')\n\t\tpos_copy.col = 0;\n\t    else\n\t\tpos_copy.col = MAXCOL;\n\t    pos_copy.coladd = 0;\n\t}\n    }\n    else if (ASCII_ISLOWER(c))\t\t// normal named mark\n    {\n\tposp = &(buf->b_namedm[c - 'a']);\n    }\n    else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))\t// named file mark\n    {\n\tif (VIM_ISDIGIT(c))\n\t    c = c - '0' + NMARKS;\n\telse\n\t    c -= 'A';\n\tposp = &(namedfm[c].fmark.mark);\n\n\tif (namedfm[c].fmark.fnum == 0)\n\t    fname2fnum(&namedfm[c]);\n\n\tif (fnum != NULL)\n\t    *fnum = namedfm[c].fmark.fnum;\n\telse if (namedfm[c].fmark.fnum != buf->b_fnum)\n\t{\n\t    // mark is in another file\n\t    posp = &pos_copy;\n\n\t    if (namedfm[c].fmark.mark.lnum != 0\n\t\t\t\t       && changefile && namedfm[c].fmark.fnum)\n\t    {\n\t\tif (buflist_getfile(namedfm[c].fmark.fnum,\n\t\t\t\t      (linenr_T)1, GETF_SETMARK, FALSE) == OK)\n\t\t{\n\t\t    // Set the lnum now, autocommands could have changed it\n\t\t    curwin->w_cursor = namedfm[c].fmark.mark;\n\t\t    return (pos_T *)-1;\n\t\t}\n\t\tpos_copy.lnum = -1;\t// can't get file\n\t    }\n\t    else\n\t\tpos_copy.lnum = 0;\t// mark exists, but is not valid in\n\t\t\t\t\t// current buffer\n\t}\n    }\n\n    return posp;\n}\n\n/*\n * Search for the next named mark in the current file.\n *\n * Returns pointer to pos_T of the next mark or NULL if no mark is found.\n */\n    pos_T *\ngetnextmark(\n    pos_T\t*startpos,\t// where to start\n    int\t\tdir,\t// direction for search\n    int\t\tbegin_line)\n{\n    int\t\ti;\n    pos_T\t*result = NULL;\n    pos_T\tpos;\n\n    pos = *startpos;\n\n    // When searching backward and leaving the cursor on the first non-blank,\n    // position must be in a previous line.\n    // When searching forward and leaving the cursor on the first non-blank,\n    // position must be in a next line.\n    if (dir == BACKWARD && begin_line)\n\tpos.col = 0;\n    else if (dir == FORWARD && begin_line)\n\tpos.col = MAXCOL;\n\n    for (i = 0; i < NMARKS; i++)\n    {\n\tif (curbuf->b_namedm[i].lnum > 0)\n\t{\n\t    if (dir == FORWARD)\n\t    {\n\t\tif ((result == NULL || LT_POS(curbuf->b_namedm[i], *result))\n\t\t\t&& LT_POS(pos, curbuf->b_namedm[i]))\n\t\t    result = &curbuf->b_namedm[i];\n\t    }\n\t    else\n\t    {\n\t\tif ((result == NULL || LT_POS(*result, curbuf->b_namedm[i]))\n\t\t\t&& LT_POS(curbuf->b_namedm[i], pos))\n\t\t    result = &curbuf->b_namedm[i];\n\t    }\n\t}\n    }\n\n    return result;\n}\n\n/*\n * For an xtended filemark: set the fnum from the fname.\n * This is used for marks obtained from the .viminfo file.  It's postponed\n * until the mark is used to avoid a long startup delay.\n */\n    static void\nfname2fnum(xfmark_T *fm)\n{\n    char_u\t*p;\n\n    if (fm->fname != NULL)\n    {\n\t/*\n\t * First expand \"~/\" in the file name to the home directory.\n\t * Don't expand the whole name, it may contain other '~' chars.\n\t */\n\tif (fm->fname[0] == '~' && (fm->fname[1] == '/'\n#ifdef BACKSLASH_IN_FILENAME\n\t\t    || fm->fname[1] == '\\\\'\n#endif\n\t\t    ))\n\t{\n\t    int len;\n\n\t    expand_env((char_u *)\"~/\", NameBuff, MAXPATHL);\n\t    len = (int)STRLEN(NameBuff);\n\t    vim_strncpy(NameBuff + len, fm->fname + 2, MAXPATHL - len - 1);\n\t}\n\telse\n\t    vim_strncpy(NameBuff, fm->fname, MAXPATHL - 1);\n\n\t// Try to shorten the file name.\n\tmch_dirname(IObuff, IOSIZE);\n\tp = shorten_fname(NameBuff, IObuff);\n\n\t// buflist_new() will call fmarks_check_names()\n\t(void)buflist_new(NameBuff, p, (linenr_T)1, 0);\n    }\n}\n\n/*\n * Check all file marks for a name that matches the file name in buf.\n * May replace the name with an fnum.\n * Used for marks that come from the .viminfo file.\n */\n    void\nfmarks_check_names(buf_T *buf)\n{\n    char_u\t*name;\n    int\t\ti;\n    win_T\t*wp;\n\n    if (buf->b_ffname == NULL)\n\treturn;\n\n    name = home_replace_save(buf, buf->b_ffname);\n    if (name == NULL)\n\treturn;\n\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n\tfmarks_check_one(&namedfm[i], name, buf);\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tfor (i = 0; i < wp->w_jumplistlen; ++i)\n\t    fmarks_check_one(&wp->w_jumplist[i], name, buf);\n    }\n\n    vim_free(name);\n}\n\n    static void\nfmarks_check_one(xfmark_T *fm, char_u *name, buf_T *buf)\n{\n    if (fm->fmark.fnum == 0\n\t    && fm->fname != NULL\n\t    && fnamecmp(name, fm->fname) == 0)\n    {\n\tfm->fmark.fnum = buf->b_fnum;\n\tVIM_CLEAR(fm->fname);\n    }\n}\n\n/*\n * Check a if a position from a mark is valid.\n * Give and error message and return FAIL if not.\n */\n    int\ncheck_mark(pos_T *pos)\n{\n    if (pos == NULL)\n    {\n\temsg(_(e_unknown_mark));\n\treturn FAIL;\n    }\n    if (pos->lnum <= 0)\n    {\n\t// lnum is negative if mark is in another file can can't get that\n\t// file, error message already give then.\n\tif (pos->lnum == 0)\n\t    emsg(_(e_mark_not_set));\n\treturn FAIL;\n    }\n    if (pos->lnum > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_mark_has_invalid_line_number));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * clrallmarks() - clear all marks in the buffer 'buf'\n *\n * Used mainly when trashing the entire buffer during \":e\" type commands\n */\n    void\nclrallmarks(buf_T *buf)\n{\n    static int\t\ti = -1;\n\n    if (i == -1)\t// first call ever: initialize\n\tfor (i = 0; i < NMARKS + 1; i++)\n\t{\n\t    namedfm[i].fmark.mark.lnum = 0;\n\t    namedfm[i].fname = NULL;\n#ifdef FEAT_VIMINFO\n\t    namedfm[i].time_set = 0;\n#endif\n\t}\n\n    for (i = 0; i < NMARKS; i++)\n\tbuf->b_namedm[i].lnum = 0;\n    buf->b_op_start.lnum = 0;\t\t// start/end op mark cleared\n    buf->b_op_end.lnum = 0;\n    buf->b_last_cursor.lnum = 1;\t// '\" mark cleared\n    buf->b_last_cursor.col = 0;\n    buf->b_last_cursor.coladd = 0;\n    buf->b_last_insert.lnum = 0;\t// '^ mark cleared\n    buf->b_last_change.lnum = 0;\t// '. mark cleared\n    buf->b_changelistlen = 0;\n}\n\n/*\n * Get name of file from a filemark.\n * When it's in the current buffer, return the text at the mark.\n * Returns an allocated string.\n */\n    char_u *\nfm_getname(fmark_T *fmark, int lead_len)\n{\n    if (fmark->fnum == curbuf->b_fnum)\t\t    // current buffer\n\treturn mark_line(&(fmark->mark), lead_len);\n    return buflist_nr2name(fmark->fnum, FALSE, TRUE);\n}\n\n/*\n * Return the line at mark \"mp\".  Truncate to fit in window.\n * The returned string has been allocated.\n */\n    static char_u *\nmark_line(pos_T *mp, int lead_len)\n{\n    char_u\t*s, *p;\n    int\t\tlen;\n\n    if (mp->lnum == 0 || mp->lnum > curbuf->b_ml.ml_line_count)\n\treturn vim_strsave((char_u *)\"-invalid-\");\n    // Allow for up to 5 bytes per character.\n    s = vim_strnsave(skipwhite(ml_get(mp->lnum)), Columns * 5);\n    if (s == NULL)\n\treturn NULL;\n    // Truncate the line to fit it in the window.\n    len = 0;\n    for (p = s; *p != NUL; MB_PTR_ADV(p))\n    {\n\tlen += ptr2cells(p);\n\tif (len >= Columns - lead_len)\n\t    break;\n    }\n    *p = NUL;\n    return s;\n}\n\n/*\n * print the marks\n */\n    void\nex_marks(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\ti;\n    char_u\t*name;\n    pos_T\t*posp, *startp, *endp;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n\n    show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, TRUE);\n    for (i = 0; i < NMARKS; ++i)\n\tshow_one_mark(i + 'a', arg, &curbuf->b_namedm[i], NULL, TRUE);\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n    {\n\tif (namedfm[i].fmark.fnum != 0)\n\t    name = fm_getname(&namedfm[i].fmark, 15);\n\telse\n\t    name = namedfm[i].fname;\n\tif (name != NULL)\n\t{\n\t    show_one_mark(i >= NMARKS ? i - NMARKS + '0' : i + 'A',\n\t\t    arg, &namedfm[i].fmark.mark, name,\n\t\t    namedfm[i].fmark.fnum == curbuf->b_fnum);\n\t    if (namedfm[i].fmark.fnum != 0)\n\t\tvim_free(name);\n\t}\n    }\n    show_one_mark('\"', arg, &curbuf->b_last_cursor, NULL, TRUE);\n    show_one_mark('[', arg, &curbuf->b_op_start, NULL, TRUE);\n    show_one_mark(']', arg, &curbuf->b_op_end, NULL, TRUE);\n    show_one_mark('^', arg, &curbuf->b_last_insert, NULL, TRUE);\n    show_one_mark('.', arg, &curbuf->b_last_change, NULL, TRUE);\n\n    // Show the marks as where they will jump to.\n    startp = &curbuf->b_visual.vi_start;\n    endp = &curbuf->b_visual.vi_end;\n    if ((LT_POS(*startp, *endp) || endp->lnum == 0) && startp->lnum != 0)\n\tposp = startp;\n    else\n\tposp = endp;\n    show_one_mark('<', arg, posp, NULL, TRUE);\n    show_one_mark('>', arg, posp == startp ? endp : startp, NULL, TRUE);\n\n    show_one_mark(-1, arg, NULL, NULL, FALSE);\n}\n\n    static void\nshow_one_mark(\n    int\t\tc,\n    char_u\t*arg,\n    pos_T\t*p,\n    char_u\t*name_arg,\n    int\t\tcurrent)\t// in current file\n{\n    static int\tdid_title = FALSE;\n    int\t\tmustfree = FALSE;\n    char_u\t*name = name_arg;\n\n    if (c == -1)\t\t\t    // finish up\n    {\n\tif (did_title)\n\t    did_title = FALSE;\n\telse\n\t{\n\t    if (arg == NULL)\n\t\tmsg(_(\"No marks set\"));\n\t    else\n\t\tsemsg(_(e_no_marks_matching_str), arg);\n\t}\n    }\n    // don't output anything if 'q' typed at --more-- prompt\n    else if (!got_int\n\t    && (arg == NULL || vim_strchr(arg, c) != NULL)\n\t    && p->lnum != 0)\n    {\n\tif (name == NULL && current)\n\t{\n\t    name = mark_line(p, 15);\n\t    mustfree = TRUE;\n\t}\n\tif (!message_filtered(name))\n\t{\n\t    if (!did_title)\n\t    {\n\t\t// Highlight title\n\t\tmsg_puts_title(_(\"\\nmark line  col file/text\"));\n\t\tdid_title = TRUE;\n\t    }\n\t    msg_putchar('\\n');\n\t    if (!got_int)\n\t    {\n\t\tsprintf((char *)IObuff, \" %c %6ld %4d \", c, p->lnum, p->col);\n\t\tmsg_outtrans(IObuff);\n\t\tif (name != NULL)\n\t\t{\n\t\t    msg_outtrans_attr(name, current ? HL_ATTR(HLF_D) : 0);\n\t\t}\n\t    }\n\t    out_flush();\t\t    // show one line at a time\n\t}\n\tif (mustfree)\n\t    vim_free(name);\n    }\n}\n\n/*\n * \":delmarks[!] [marks]\"\n */\n    void\nex_delmarks(exarg_T *eap)\n{\n    char_u\t*p;\n    int\t\tfrom, to;\n    int\t\ti;\n    int\t\tlower;\n    int\t\tdigit;\n    int\t\tn;\n\n    if (*eap->arg == NUL && eap->forceit)\n\t// clear all marks\n\tclrallmarks(curbuf);\n    else if (eap->forceit)\n\temsg(_(e_invalid_argument));\n    else if (*eap->arg == NUL)\n\temsg(_(e_argument_required));\n    else\n    {\n\t// clear specified marks only\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n\t    lower = ASCII_ISLOWER(*p);\n\t    digit = VIM_ISDIGIT(*p);\n\t    if (lower || digit || ASCII_ISUPPER(*p))\n\t    {\n\t\tif (p[1] == '-')\n\t\t{\n\t\t    // clear range of marks\n\t\t    from = *p;\n\t\t    to = p[2];\n\t\t    if (!(lower ? ASCII_ISLOWER(p[2])\n\t\t\t\t: (digit ? VIM_ISDIGIT(p[2])\n\t\t\t\t    : ASCII_ISUPPER(p[2])))\n\t\t\t    || to < from)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_argument_str), p);\n\t\t\treturn;\n\t\t    }\n\t\t    p += 2;\n\t\t}\n\t\telse\n\t\t    // clear one lower case mark\n\t\t    from = to = *p;\n\n\t\tfor (i = from; i <= to; ++i)\n\t\t{\n\t\t    if (lower)\n\t\t\tcurbuf->b_namedm[i - 'a'].lnum = 0;\n\t\t    else\n\t\t    {\n\t\t\tif (digit)\n\t\t\t    n = i - '0' + NMARKS;\n\t\t\telse\n\t\t\t    n = i - 'A';\n\t\t\tnamedfm[n].fmark.mark.lnum = 0;\n\t\t\tnamedfm[n].fmark.fnum = 0;\n\t\t\tVIM_CLEAR(namedfm[n].fname);\n#ifdef FEAT_VIMINFO\n\t\t\tnamedfm[n].time_set = digit ? 0 : vim_time();\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tswitch (*p)\n\t\t{\n\t\t    case '\"': curbuf->b_last_cursor.lnum = 0; break;\n\t\t    case '^': curbuf->b_last_insert.lnum = 0; break;\n\t\t    case '.': curbuf->b_last_change.lnum = 0; break;\n\t\t    case '[': curbuf->b_op_start.lnum    = 0; break;\n\t\t    case ']': curbuf->b_op_end.lnum      = 0; break;\n\t\t    case '<': curbuf->b_visual.vi_start.lnum = 0; break;\n\t\t    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;\n\t\t    case ' ': break;\n\t\t    default:  semsg(_(e_invalid_argument_str), p);\n\t\t\t      return;\n\t\t}\n\t}\n    }\n}\n\n/*\n * print the jumplist\n */\n    void\nex_jumps(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n\n    cleanup_jumplist(curwin, TRUE);\n\n    // Highlight title\n    msg_puts_title(_(\"\\n jump line  col file/text\"));\n    for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i)\n    {\n\tif (curwin->w_jumplist[i].fmark.mark.lnum != 0)\n\t{\n\t    name = fm_getname(&curwin->w_jumplist[i].fmark, 16);\n\n\t    // Make sure to output the current indicator, even when on an wiped\n\t    // out buffer.  \":filter\" may still skip it.\n\t    if (name == NULL && i == curwin->w_jumplistidx)\n\t\tname = vim_strsave((char_u *)\"-invalid-\");\n\t    // apply :filter /pat/ or file name not available\n\t    if (name == NULL || message_filtered(name))\n\t    {\n\t\tvim_free(name);\n\t\tcontinue;\n\t    }\n\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t    {\n\t\tvim_free(name);\n\t\tbreak;\n\t    }\n\t    sprintf((char *)IObuff, \"%c %2d %5ld %4d \",\n\t\ti == curwin->w_jumplistidx ? '>' : ' ',\n\t\ti > curwin->w_jumplistidx ? i - curwin->w_jumplistidx\n\t\t\t\t\t  : curwin->w_jumplistidx - i,\n\t\tcurwin->w_jumplist[i].fmark.mark.lnum,\n\t\tcurwin->w_jumplist[i].fmark.mark.col);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name,\n\t\t\t    curwin->w_jumplist[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t    ui_breakcheck();\n\t}\n\tout_flush();\n    }\n    if (curwin->w_jumplistidx == curwin->w_jumplistlen)\n\tmsg_puts(\"\\n>\");\n}\n\n    void\nex_clearjumps(exarg_T *eap UNUSED)\n{\n    free_jumplist(curwin);\n    curwin->w_jumplistlen = 0;\n    curwin->w_jumplistidx = 0;\n}\n\n/*\n * print the changelist\n */\n    void\nex_changes(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n\n    // Highlight title\n    msg_puts_title(_(\"\\nchange line  col text\"));\n\n    for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i)\n    {\n\tif (curbuf->b_changelist[i].lnum != 0)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    sprintf((char *)IObuff, \"%c %3d %5ld %4d \",\n\t\t    i == curwin->w_changelistidx ? '>' : ' ',\n\t\t    i > curwin->w_changelistidx ? i - curwin->w_changelistidx\n\t\t\t\t\t\t: curwin->w_changelistidx - i,\n\t\t    (long)curbuf->b_changelist[i].lnum,\n\t\t    curbuf->b_changelist[i].col);\n\t    msg_outtrans(IObuff);\n\t    name = mark_line(&curbuf->b_changelist[i], 17);\n\t    if (name == NULL)\n\t\tbreak;\n\t    msg_outtrans_attr(name, HL_ATTR(HLF_D));\n\t    vim_free(name);\n\t    ui_breakcheck();\n\t}\n\tout_flush();\n    }\n    if (curwin->w_changelistidx == curbuf->b_changelistlen)\n\tmsg_puts(\"\\n>\");\n}\n\n#define one_adjust(add) \\\n    { \\\n\tlp = add; \\\n\tif (*lp >= line1 && *lp <= line2) \\\n\t{ \\\n\t    if (amount == MAXLNUM) \\\n\t\t*lp = 0; \\\n\t    else \\\n\t\t*lp += amount; \\\n\t} \\\n\telse if (amount_after && *lp > line2) \\\n\t    *lp += amount_after; \\\n    }\n\n// don't delete the line, just put at first deleted line\n#define one_adjust_nodel(add) \\\n    { \\\n\tlp = add; \\\n\tif (*lp >= line1 && *lp <= line2) \\\n\t{ \\\n\t    if (amount == MAXLNUM) \\\n\t\t*lp = line1; \\\n\t    else \\\n\t\t*lp += amount; \\\n\t} \\\n\telse if (amount_after && *lp > line2) \\\n\t    *lp += amount_after; \\\n    }\n\n/*\n * Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.\n * Must be called before changed_*(), appended_lines() or deleted_lines().\n * May be called before or after changing the text.\n * When deleting lines line1 to line2, use an 'amount' of MAXLNUM: The marks\n * within this range are made invalid.\n * If 'amount_after' is non-zero adjust marks after line2.\n * Example: Delete lines 34 and 35: mark_adjust(34, 35, MAXLNUM, -2);\n * Example: Insert two lines below 55: mark_adjust(56, MAXLNUM, 2, 0);\n *\t\t\t\t   or: mark_adjust(56, 55, MAXLNUM, 2);\n */\n    void\nmark_adjust(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    mark_adjust_internal(line1, line2, amount, amount_after, TRUE);\n}\n\n    void\nmark_adjust_nofold(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    mark_adjust_internal(line1, line2, amount, amount_after, FALSE);\n}\n\n    static void\nmark_adjust_internal(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after,\n    int\t\tadjust_folds UNUSED)\n{\n    int\t\ti;\n    int\t\tfnum = curbuf->b_fnum;\n    linenr_T\t*lp;\n    win_T\t*win;\n    tabpage_T\t*tab;\n    static pos_T initpos = {1, 0, 0};\n\n    if (line2 < line1 && amount_after == 0L)\t    // nothing to do\n\treturn;\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// named marks, lower case and upper case\n\tfor (i = 0; i < NMARKS; i++)\n\t{\n\t    one_adjust(&(curbuf->b_namedm[i].lnum));\n\t    if (namedfm[i].fmark.fnum == fnum)\n\t\tone_adjust_nodel(&(namedfm[i].fmark.mark.lnum));\n\t}\n\tfor (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n\t{\n\t    if (namedfm[i].fmark.fnum == fnum)\n\t\tone_adjust_nodel(&(namedfm[i].fmark.mark.lnum));\n\t}\n\n\t// last Insert position\n\tone_adjust(&(curbuf->b_last_insert.lnum));\n\n\t// last change position\n\tone_adjust(&(curbuf->b_last_change.lnum));\n\n\t// last cursor position, if it was set\n\tif (!EQUAL_POS(curbuf->b_last_cursor, initpos))\n\t    one_adjust(&(curbuf->b_last_cursor.lnum));\n\n\n\t// list of change positions\n\tfor (i = 0; i < curbuf->b_changelistlen; ++i)\n\t    one_adjust_nodel(&(curbuf->b_changelist[i].lnum));\n\n\t// Visual area\n\tone_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));\n\tone_adjust_nodel(&(curbuf->b_visual.vi_end.lnum));\n\n#ifdef FEAT_QUICKFIX\n\t// quickfix marks\n\tqf_mark_adjust(NULL, line1, line2, amount, amount_after);\n\t// location lists\n\tFOR_ALL_TAB_WINDOWS(tab, win)\n\t    qf_mark_adjust(win, line1, line2, amount, amount_after);\n#endif\n\n#ifdef FEAT_SIGNS\n\tsign_mark_adjust(line1, line2, amount, amount_after);\n#endif\n    }\n\n    // previous context mark\n    one_adjust(&(curwin->w_pcmark.lnum));\n\n    // previous pcmark\n    one_adjust(&(curwin->w_prev_pcmark.lnum));\n\n    // saved cursor for formatting\n    if (saved_cursor.lnum != 0)\n\tone_adjust_nodel(&(saved_cursor.lnum));\n\n    /*\n     * Adjust items in all windows related to the current buffer.\n     */\n    FOR_ALL_TAB_WINDOWS(tab, win)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    // Marks in the jumplist.  When deleting lines, this may create\n\t    // duplicate marks in the jumplist, they will be removed later.\n\t    for (i = 0; i < win->w_jumplistlen; ++i)\n\t\tif (win->w_jumplist[i].fmark.fnum == fnum)\n\t\t    one_adjust_nodel(&(win->w_jumplist[i].fmark.mark.lnum));\n\n\tif (win->w_buffer == curbuf)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t\t// marks in the tag stack\n\t\tfor (i = 0; i < win->w_tagstacklen; i++)\n\t\t    if (win->w_tagstack[i].fmark.fnum == fnum)\n\t\t\tone_adjust_nodel(&(win->w_tagstack[i].fmark.mark.lnum));\n\n\t    // the displayed Visual area\n\t    if (win->w_old_cursor_lnum != 0)\n\t    {\n\t\tone_adjust_nodel(&(win->w_old_cursor_lnum));\n\t\tone_adjust_nodel(&(win->w_old_visual_lnum));\n\t    }\n\n\t    // topline and cursor position for windows with the same buffer\n\t    // other than the current window\n\t    if (win != curwin)\n\t    {\n\t\tif (win->w_topline >= line1 && win->w_topline <= line2)\n\t\t{\n\t\t    if (amount == MAXLNUM)\t    // topline is deleted\n\t\t    {\n\t\t\tif (line1 <= 1)\n\t\t\t    win->w_topline = 1;\n\t\t\telse\n\t\t\t    win->w_topline = line1 - 1;\n\t\t    }\n\t\t    else\t\t// keep topline on the same line\n\t\t\twin->w_topline += amount;\n#ifdef FEAT_DIFF\n\t\t    win->w_topfill = 0;\n#endif\n\t\t}\n\t\telse if (amount_after && win->w_topline > line2)\n\t\t{\n\t\t    win->w_topline += amount_after;\n#ifdef FEAT_DIFF\n\t\t    win->w_topfill = 0;\n#endif\n\t\t}\n\t\tif (win->w_cursor.lnum >= line1 && win->w_cursor.lnum <= line2)\n\t\t{\n\t\t    if (amount == MAXLNUM) // line with cursor is deleted\n\t\t    {\n\t\t\tif (line1 <= 1)\n\t\t\t    win->w_cursor.lnum = 1;\n\t\t\telse\n\t\t\t    win->w_cursor.lnum = line1 - 1;\n\t\t\twin->w_cursor.col = 0;\n\t\t    }\n\t\t    else\t\t// keep cursor on the same line\n\t\t\twin->w_cursor.lnum += amount;\n\t\t}\n\t\telse if (amount_after && win->w_cursor.lnum > line2)\n\t\t    win->w_cursor.lnum += amount_after;\n\t    }\n\n#ifdef FEAT_FOLDING\n\t    // adjust folds\n\t    if (adjust_folds)\n\t\tfoldMarkAdjust(win, line1, line2, amount, amount_after);\n#endif\n\t}\n    }\n\n#ifdef FEAT_DIFF\n    // adjust diffs\n    diff_mark_adjust(line1, line2, amount, amount_after);\n#endif\n}\n\n// This code is used often, needs to be fast.\n#define col_adjust(pp) \\\n    { \\\n\tposp = pp; \\\n\tif (posp->lnum == lnum && posp->col >= mincol) \\\n\t{ \\\n\t    posp->lnum += lnum_amount; \\\n\t    if (col_amount < 0 && posp->col <= (colnr_T)-col_amount) \\\n\t\tposp->col = 0; \\\n\t    else if (posp->col < spaces_removed) \\\n\t\tposp->col = col_amount + spaces_removed; \\\n\t    else \\\n\t\tposp->col += col_amount; \\\n\t} \\\n    }\n\n/*\n * Adjust marks in line \"lnum\" at column \"mincol\" and further: add\n * \"lnum_amount\" to the line number and add \"col_amount\" to the column\n * position.\n * \"spaces_removed\" is the number of spaces that were removed, matters when the\n * cursor is inside them.\n */\n    void\nmark_col_adjust(\n    linenr_T\tlnum,\n    colnr_T\tmincol,\n    long\tlnum_amount,\n    long\tcol_amount,\n    int\t\tspaces_removed)\n{\n    int\t\ti;\n    int\t\tfnum = curbuf->b_fnum;\n    win_T\t*win;\n    pos_T\t*posp;\n\n    if ((col_amount == 0L && lnum_amount == 0L)\n\t\t\t\t       || (cmdmod.cmod_flags & CMOD_LOCKMARKS))\n\treturn; // nothing to do\n\n    // named marks, lower case and upper case\n    for (i = 0; i < NMARKS; i++)\n    {\n\tcol_adjust(&(curbuf->b_namedm[i]));\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n    for (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n    {\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n\n    // last Insert position\n    col_adjust(&(curbuf->b_last_insert));\n\n    // last change position\n    col_adjust(&(curbuf->b_last_change));\n\n    // list of change positions\n    for (i = 0; i < curbuf->b_changelistlen; ++i)\n\tcol_adjust(&(curbuf->b_changelist[i]));\n\n    // Visual area\n    col_adjust(&(curbuf->b_visual.vi_start));\n    col_adjust(&(curbuf->b_visual.vi_end));\n\n    // previous context mark\n    col_adjust(&(curwin->w_pcmark));\n\n    // previous pcmark\n    col_adjust(&(curwin->w_prev_pcmark));\n\n    // saved cursor for formatting\n    col_adjust(&saved_cursor);\n\n    /*\n     * Adjust items in all windows related to the current buffer.\n     */\n    FOR_ALL_WINDOWS(win)\n    {\n\t// marks in the jumplist\n\tfor (i = 0; i < win->w_jumplistlen; ++i)\n\t    if (win->w_jumplist[i].fmark.fnum == fnum)\n\t\tcol_adjust(&(win->w_jumplist[i].fmark.mark));\n\n\tif (win->w_buffer == curbuf)\n\t{\n\t    // marks in the tag stack\n\t    for (i = 0; i < win->w_tagstacklen; i++)\n\t\tif (win->w_tagstack[i].fmark.fnum == fnum)\n\t\t    col_adjust(&(win->w_tagstack[i].fmark.mark));\n\n\t    // cursor position for other windows with the same buffer\n\t    if (win != curwin)\n\t\tcol_adjust(&win->w_cursor);\n\t}\n    }\n}\n\n/*\n * When deleting lines, this may create duplicate marks in the\n * jumplist. They will be removed here for the specified window.\n * When \"loadfiles\" is TRUE first ensure entries have the \"fnum\" field set\n * (this may be a bit slow).\n */\n    void\ncleanup_jumplist(win_T *wp, int loadfiles)\n{\n    int\t    i;\n    int\t    from, to;\n\n    if (loadfiles)\n    {\n\t// If specified, load all the files from the jump list. This is\n\t// needed to properly clean up duplicate entries, but will take some\n\t// time.\n\tfor (i = 0; i < wp->w_jumplistlen; ++i)\n\t{\n\t    if ((wp->w_jumplist[i].fmark.fnum == 0) &&\n\t\t    (wp->w_jumplist[i].fmark.mark.lnum != 0))\n\t\tfname2fnum(&wp->w_jumplist[i]);\n\t}\n    }\n\n    to = 0;\n    for (from = 0; from < wp->w_jumplistlen; ++from)\n    {\n\tif (wp->w_jumplistidx == from)\n\t    wp->w_jumplistidx = to;\n\tfor (i = from + 1; i < wp->w_jumplistlen; ++i)\n\t    if (wp->w_jumplist[i].fmark.fnum\n\t\t\t\t\t== wp->w_jumplist[from].fmark.fnum\n\t\t    && wp->w_jumplist[from].fmark.fnum != 0\n\t\t    && wp->w_jumplist[i].fmark.mark.lnum\n\t\t\t\t  == wp->w_jumplist[from].fmark.mark.lnum)\n\t\tbreak;\n\tif (i >= wp->w_jumplistlen)\t    // no duplicate\n\t    wp->w_jumplist[to++] = wp->w_jumplist[from];\n\telse\n\t    vim_free(wp->w_jumplist[from].fname);\n    }\n    if (wp->w_jumplistidx == wp->w_jumplistlen)\n\twp->w_jumplistidx = to;\n    wp->w_jumplistlen = to;\n}\n\n/*\n * Copy the jumplist from window \"from\" to window \"to\".\n */\n    void\ncopy_jumplist(win_T *from, win_T *to)\n{\n    int\t\ti;\n\n    for (i = 0; i < from->w_jumplistlen; ++i)\n    {\n\tto->w_jumplist[i] = from->w_jumplist[i];\n\tif (from->w_jumplist[i].fname != NULL)\n\t    to->w_jumplist[i].fname = vim_strsave(from->w_jumplist[i].fname);\n    }\n    to->w_jumplistlen = from->w_jumplistlen;\n    to->w_jumplistidx = from->w_jumplistidx;\n}\n\n/*\n * Free items in the jumplist of window \"wp\".\n */\n    void\nfree_jumplist(win_T *wp)\n{\n    int\t\ti;\n\n    for (i = 0; i < wp->w_jumplistlen; ++i)\n\tvim_free(wp->w_jumplist[i].fname);\n}\n\n    void\nset_last_cursor(win_T *win)\n{\n    if (win->w_buffer != NULL)\n\twin->w_buffer->b_last_cursor = win->w_cursor;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_marks(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NMARKS + EXTRA_MARKS; i++)\n\tif (namedfm[i].fmark.mark.lnum != 0)\n\t    vim_free(namedfm[i].fname);\n}\n#endif\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n/*\n * Return a pointer to the named file marks.\n */\n    xfmark_T *\nget_namedfm(void)\n{\n    return namedfm;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add information about mark 'mname' to list 'l'\n */\n    static int\nadd_mark(list_T *l, char_u *mname, pos_T *pos, int bufnr, char_u *fname)\n{\n    dict_T\t*d;\n    list_T\t*lpos;\n\n    if (pos->lnum <= 0)\n\treturn OK;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn FAIL;\n\n    if (list_append_dict(l, d) == FAIL)\n    {\n\tdict_unref(d);\n\treturn FAIL;\n    }\n\n    lpos = list_alloc();\n    if (lpos == NULL)\n\treturn FAIL;\n\n    list_append_number(lpos, bufnr);\n    list_append_number(lpos, pos->lnum);\n    list_append_number(lpos, pos->col + 1);\n    list_append_number(lpos, pos->coladd);\n\n    if (dict_add_string(d, \"mark\", mname) == FAIL\n\t    || dict_add_list(d, \"pos\", lpos) == FAIL\n\t    || (fname != NULL && dict_add_string(d, \"file\", fname) == FAIL))\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get information about marks local to a buffer.\n */\n    static void\nget_buf_local_marks(buf_T *buf, list_T *l)\n{\n    char_u\tmname[3] = \"' \";\n    int\t\ti;\n\n    // Marks 'a' to 'z'\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tmname[1] = 'a' + i;\n\tadd_mark(l, mname, &buf->b_namedm[i], buf->b_fnum, NULL);\n    }\n\n    // Mark '' is a window local mark and not a buffer local mark\n    add_mark(l, (char_u *)\"''\", &curwin->w_pcmark, curbuf->b_fnum, NULL);\n\n    add_mark(l, (char_u *)\"'\\\"\", &buf->b_last_cursor, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'[\", &buf->b_op_start, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"']\", &buf->b_op_end, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'^\", &buf->b_last_insert, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'.\", &buf->b_last_change, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'<\", &buf->b_visual.vi_start, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'>\", &buf->b_visual.vi_end, buf->b_fnum, NULL);\n}\n\n/*\n * Get information about global marks ('A' to 'Z' and '0' to '9')\n */\n    static void\nget_global_marks(list_T *l)\n{\n    char_u\tmname[3] = \"' \";\n    int\t\ti;\n    char_u\t*name;\n\n    // Marks 'A' to 'Z' and '0' to '9'\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n    {\n\tif (namedfm[i].fmark.fnum != 0)\n\t    name = buflist_nr2name(namedfm[i].fmark.fnum, TRUE, TRUE);\n\telse\n\t    name = namedfm[i].fname;\n\tif (name != NULL)\n\t{\n\t    mname[1] = i >= NMARKS ? i - NMARKS + '0' : i + 'A';\n\t    add_mark(l, mname, &namedfm[i].fmark.mark,\n\t\t    namedfm[i].fmark.fnum, name);\n\t    if (namedfm[i].fmark.fnum != 0)\n\t\tvim_free(name);\n\t}\n    }\n}\n\n/*\n * getmarklist() function\n */\n    void\nf_getmarklist(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = NULL;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type == VAR_UNKNOWN)\n    {\n\tget_global_marks(rettv->vval.v_list);\n\treturn;\n    }\n\n    buf = tv_get_buf(&argvars[0], FALSE);\n    if (buf == NULL)\n\treturn;\n\n    get_buf_local_marks(buf, rettv->vval.v_list);\n}\n#endif\n", "\" Test for marks\n\n\" Test that a deleted mark is restored after delete-undo-redo-undo.\nfunc Test_Restore_DelMark()\n  enew!\n  call append(0, [\"\ttextline A\", \"\ttextline B\", \"\ttextline C\"])\n  normal! 2gg\n  set nocp viminfo+=nviminfo\n  exe \"normal! i\\<C-G>u\\<Esc>\"\n  exe \"normal! maddu\\<C-R>u\"\n  let pos = getpos(\"'a\")\n  call assert_equal(2, pos[1])\n  call assert_equal(1, pos[2])\n  enew!\nendfunc\n\n\" Test that CTRL-A and CTRL-X updates last changed mark '[, '].\nfunc Test_Incr_Marks()\n  enew!\n  call append(0, [\"123 123 123\", \"123 123 123\", \"123 123 123\"])\n  normal! gg\n  execute \"normal! \\<C-A>`[v`]rAjwvjw\\<C-X>`[v`]rX\"\n  call assert_equal(\"AAA 123 123\", getline(1))\n  call assert_equal(\"123 XXXXXXX\", getline(2))\n  call assert_equal(\"XXX 123 123\", getline(3))\n  enew!\nendfunc\n\nfunc Test_previous_jump_mark()\n  new\n  call setline(1, ['']->repeat(6))\n  normal Ggg\n  call assert_equal(6, getpos(\"''\")[1])\n  normal jjjjj\n  call assert_equal(6, getpos(\"''\")[1])\n  bwipe!\nendfunc\n\nfunc Test_setpos()\n  new Xone\n  let onebuf = bufnr('%')\n  let onewin = win_getid()\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  new Xtwo\n  let twobuf = bufnr('%')\n  let twowin = win_getid()\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n\n  \" for the cursor the buffer number is ignored\n  call setpos(\".\", [0, 2, 1, 0])\n  call assert_equal([0, 2, 1, 0], getpos(\".\"))\n  call setpos(\".\", [onebuf, 3, 3, 0])\n  call assert_equal([0, 3, 3, 0], getpos(\".\"))\n\n  call setpos(\"''\", [0, 1, 3, 0])\n  call assert_equal([0, 1, 3, 0], getpos(\"''\"))\n  call setpos(\"''\", [onebuf, 2, 2, 0])\n  call assert_equal([0, 2, 2, 0], getpos(\"''\"))\n\n  \" buffer-local marks\n  for mark in [\"'a\", \"'\\\"\", \"'[\", \"']\", \"'<\", \"'>\"]\n    call win_gotoid(twowin)\n    call setpos(mark, [0, 2, 1, 0])\n    call assert_equal([0, 2, 1, 0], getpos(mark), \"for mark \" . mark)\n    call setpos(mark, [onebuf, 1, 3, 0])\n    call win_gotoid(onewin)\n    call assert_equal([0, 1, 3, 0], getpos(mark), \"for mark \" . mark)\n  endfor\n\n  \" global marks\n  call win_gotoid(twowin)\n  call setpos(\"'N\", [0, 2, 1, 0])\n  call assert_equal([twobuf, 2, 1, 0], getpos(\"'N\"))\n  call setpos(\"'N\", [onebuf, 1, 3, 0])\n  call assert_equal([onebuf, 1, 3, 0], getpos(\"'N\"))\n\n  \" try invalid column and check virtcol()\n  call win_gotoid(onewin)\n  call setpos(\"'a\", [0, 1, 2, 0])\n  call assert_equal([0, 1, 2, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, -5, 0])\n  call assert_equal([0, 1, 2, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, 0, 0])\n  call assert_equal([0, 1, 1, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, 4, 0])\n  call assert_equal([0, 1, 4, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n  call setpos(\"'a\", [0, 1, 5, 0])\n  call assert_equal([0, 1, 5, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n  call setpos(\"'a\", [0, 1, 21341234, 0])\n  call assert_equal([0, 1, 21341234, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n\n  \" Test with invalid buffer number, line number and column number\n  call cursor(2, 2)\n  call setpos('.', [-1, 1, 1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call setpos('.', [0, -1, 1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call setpos('.', [0, 1, -1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n\n  call assert_fails(\"call setpos('ab', [0, 1, 1, 0])\", 'E474:')\n\n  bwipe!\n  call win_gotoid(twowin)\n  bwipe!\nendfunc\n\nfunc Test_marks_cmd()\n  new Xone\n  call setline(1, ['aaa', 'bbb'])\n  norm! maG$mB\n  w!\n  new Xtwo\n  call setline(1, ['ccc', 'ddd'])\n  norm! $mcGmD\n  exe \"norm! GVgg\\<Esc>G\"\n  w!\n\n  b Xone\n  let a = split(execute('marks'), \"\\n\")\n  call assert_equal(9, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ \" '      2    0 bbb\",\n        \\ ' a      1    0 aaa',\n        \\ ' B      2    2 bbb',\n        \\ ' D      2    0 Xtwo',\n        \\ ' \"      1    0 aaa',\n        \\ ' [      1    0 aaa',\n        \\ ' ]      2    0 bbb',\n        \\ ' .      2    0 bbb'], a)\n\n  b Xtwo\n  let a = split(execute('marks'), \"\\n\")\n  call assert_equal(11, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ \" '      1    0 ccc\",\n        \\ ' c      1    2 ccc',\n        \\ ' B      2    2 Xone',\n        \\ ' D      2    0 ddd',\n        \\ ' \"      2    0 ddd',\n        \\ ' [      1    0 ccc',\n        \\ ' ]      2    0 ddd',\n        \\ ' .      2    0 ddd',\n        \\ ' <      1    0 ccc',\n        \\ ' >      2    0 ddd'], a)\n  norm! Gdd\n  w!\n  let a = split(execute('marks <>'), \"\\n\")\n  call assert_equal(3, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ ' <      1    0 ccc',\n        \\ ' >      2    0 -invalid-'], a)\n\n  b Xone\n  delmarks aB\n  let a = split(execute('marks aBcD'), \"\\n\")\n  call assert_equal(2, len(a))\n  call assert_equal('mark line  col file/text', a[0])\n  call assert_equal(' D      2    0 Xtwo', a[1])\n\n  b Xtwo\n  delmarks cD\n  call assert_fails('marks aBcD', 'E283:')\n\n  call delete('Xone')\n  call delete('Xtwo')\n  %bwipe\nendfunc\n\nfunc Test_marks_cmd_multibyte()\n  new Xone\n  call setline(1, [repeat('\u00e1', &columns)])\n  norm! ma\n\n  let a = split(execute('marks a'), \"\\n\")\n  call assert_equal(2, len(a))\n  let expected = ' a      1    0 ' . repeat('\u00e1', &columns - 16)\n  call assert_equal(expected, a[1])\n\n  bwipe!\nendfunc\n\nfunc Test_delmarks()\n  new\n  norm mx\n  norm `x\n  delmarks x\n  call assert_fails('norm `x', 'E20:')\n\n  \" Deleting an already deleted mark should not fail.\n  delmarks x\n\n  \" getpos() should return all zeros after deleting a filemark.\n  norm mA\n  delmarks A\n  call assert_equal([0, 0, 0, 0], getpos(\"'A\"))\n\n  \" Test deleting a range of marks.\n  norm ma\n  norm mb\n  norm mc\n  norm mz\n  delmarks b-z\n  norm `a\n  call assert_fails('norm `b', 'E20:')\n  call assert_fails('norm `c', 'E20:')\n  call assert_fails('norm `z', 'E20:')\n  call assert_fails('delmarks z-b', 'E475:')\n\n  call assert_fails('delmarks', 'E471:')\n  call assert_fails('delmarks /', 'E475:')\n\n  \" Test delmarks!\n  norm mx\n  norm `x\n  delmarks!\n  call assert_fails('norm `x', 'E20:')\n  call assert_fails('delmarks! x', 'E474:')\n\n  bwipe!\nendfunc\n\nfunc Test_mark_error()\n  call assert_fails('mark', 'E471:')\n  call assert_fails('mark xx', 'E488:')\n  call assert_fails('mark _', 'E191:')\n  call assert_beeps('normal! m~')\n\n  call setpos(\"'k\", [0, 100, 1, 0])\n  call assert_fails(\"normal 'k\", 'E19:')\nendfunc\n\n\" Test for :lockmarks when pasting content\nfunc Test_lockmarks_with_put()\n  new\n  call append(0, repeat(['sky is blue'], 4))\n  normal gg\n  1,2yank r\n  put r\n  normal G\n  lockmarks put r\n  call assert_equal(2, line(\"'[\"))\n  call assert_equal(3, line(\"']\"))\n\n  bwipe!\nendfunc\n\n\" Test for :k command to set a mark\nfunc Test_marks_k_cmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  1,3kr\n  call assert_equal([0, 3, 1, 0], getpos(\"'r\"))\n  close!\nendfunc\n\n\" Test for file marks (A-Z)\nfunc Test_file_mark()\n  new Xone\n  call setline(1, ['aaa', 'bbb'])\n  norm! G$mB\n  w!\n  new Xtwo\n  call setline(1, ['ccc', 'ddd'])\n  norm! GmD\n  w!\n\n  enew\n  normal! `B\n  call assert_equal('Xone', bufname())\n  call assert_equal([2, 3], [line('.'), col('.')])\n  normal! 'D\n  call assert_equal('Xtwo', bufname())\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call delete('Xone')\n  call delete('Xtwo')\nendfunc\n\n\" Test for the getmarklist() function\nfunc Test_getmarklist()\n  new\n  \" global marks\n  delmarks A-Z 0-9 \\\" ^.[]\n  call assert_equal([], getmarklist())\n  call setline(1, ['one', 'two', 'three'])\n  mark A\n  call cursor(3, 5)\n  normal mN\n  call assert_equal([{'file' : '', 'mark' : \"'A\", 'pos' : [bufnr(), 1, 1, 0]},\n        \\ {'file' : '', 'mark' : \"'N\", 'pos' : [bufnr(), 3, 5, 0]}],\n        \\ getmarklist())\n  \" buffer local marks\n  delmarks!\n  call assert_equal([{'mark' : \"''\", 'pos' : [bufnr(), 1, 1, 0]},\n        \\ {'mark' : \"'\\\"\", 'pos' : [bufnr(), 1, 1, 0]}], getmarklist(bufnr()))\n  call cursor(2, 2)\n  normal mr\n  call assert_equal({'mark' : \"'r\", 'pos' : [bufnr(), 2, 2, 0]},\n        \\ bufnr()->getmarklist()[0])\n  call assert_equal([], {}->getmarklist())\n  close!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * mark.c: functions for setting marks and jumping to them\n */\n\n#include \"vim.h\"\n\n/*\n * This file contains routines to maintain and manipulate marks.\n */\n\n/*\n * If a named file mark's lnum is non-zero, it is valid.\n * If a named file mark's fnum is non-zero, it is for an existing buffer,\n * otherwise it is from .viminfo and namedfm[n].fname is the file name.\n * There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing\n * viminfo).\n */\nstatic xfmark_T namedfm[NMARKS + EXTRA_MARKS];\t\t// marks with file nr\n\nstatic void fname2fnum(xfmark_T *fm);\nstatic void fmarks_check_one(xfmark_T *fm, char_u *name, buf_T *buf);\nstatic char_u *mark_line(pos_T *mp, int lead_len);\nstatic void show_one_mark(int, char_u *, pos_T *, char_u *, int current);\nstatic void mark_adjust_internal(linenr_T line1, linenr_T line2, long amount,\n    long amount_after, int adjust_folds);\n\n/*\n * Set named mark \"c\" at current cursor position.\n * Returns OK on success, FAIL if bad name given.\n */\n    int\nsetmark(int c)\n{\n    return setmark_pos(c, &curwin->w_cursor, curbuf->b_fnum);\n}\n\n/*\n * Set named mark \"c\" to position \"pos\".\n * When \"c\" is upper case use file \"fnum\".\n * Returns OK on success, FAIL if bad name given.\n */\n    int\nsetmark_pos(int c, pos_T *pos, int fnum)\n{\n    int\t\ti;\n    buf_T\t*buf;\n\n    // Check for a special key (may cause islower() to crash).\n    if (c < 0)\n\treturn FAIL;\n\n    if (c == '\\'' || c == '`')\n    {\n\tif (pos == &curwin->w_cursor)\n\t{\n\t    setpcmark();\n\t    // keep it even when the cursor doesn't move\n\t    curwin->w_prev_pcmark = curwin->w_pcmark;\n\t}\n\telse\n\t    curwin->w_pcmark = *pos;\n\treturn OK;\n    }\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL)\n\treturn FAIL;\n\n    if (c == '\"')\n    {\n\tbuf->b_last_cursor = *pos;\n\treturn OK;\n    }\n\n    // Allow setting '[ and '] for an autocommand that simulates reading a\n    // file.\n    if (c == '[')\n    {\n\tbuf->b_op_start = *pos;\n\treturn OK;\n    }\n    if (c == ']')\n    {\n\tbuf->b_op_end = *pos;\n\treturn OK;\n    }\n\n    if (c == '<' || c == '>')\n    {\n\tif (c == '<')\n\t    buf->b_visual.vi_start = *pos;\n\telse\n\t    buf->b_visual.vi_end = *pos;\n\tif (buf->b_visual.vi_mode == NUL)\n\t    // Visual_mode has not yet been set, use a sane default.\n\t    buf->b_visual.vi_mode = 'v';\n\treturn OK;\n    }\n\n    if (ASCII_ISLOWER(c))\n    {\n\ti = c - 'a';\n\tbuf->b_namedm[i] = *pos;\n\treturn OK;\n    }\n    if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))\n    {\n\tif (VIM_ISDIGIT(c))\n\t    i = c - '0' + NMARKS;\n\telse\n\t    i = c - 'A';\n\tnamedfm[i].fmark.mark = *pos;\n\tnamedfm[i].fmark.fnum = fnum;\n\tVIM_CLEAR(namedfm[i].fname);\n#ifdef FEAT_VIMINFO\n\tnamedfm[i].time_set = vim_time();\n#endif\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Set the previous context mark to the current position and add it to the\n * jump list.\n */\n    void\nsetpcmark(void)\n{\n    int\t\ti;\n    xfmark_T\t*fm;\n\n    // for :global the mark is set only once\n    if (global_busy || listcmd_busy || (cmdmod.cmod_flags & CMOD_KEEPJUMPS))\n\treturn;\n\n    curwin->w_prev_pcmark = curwin->w_pcmark;\n    curwin->w_pcmark = curwin->w_cursor;\n\n    // If jumplist is full: remove oldest entry\n    if (++curwin->w_jumplistlen > JUMPLISTSIZE)\n    {\n\tcurwin->w_jumplistlen = JUMPLISTSIZE;\n\tvim_free(curwin->w_jumplist[0].fname);\n\tfor (i = 1; i < JUMPLISTSIZE; ++i)\n\t    curwin->w_jumplist[i - 1] = curwin->w_jumplist[i];\n    }\n    curwin->w_jumplistidx = curwin->w_jumplistlen;\n    fm = &curwin->w_jumplist[curwin->w_jumplistlen - 1];\n\n    fm->fmark.mark = curwin->w_pcmark;\n    fm->fmark.fnum = curbuf->b_fnum;\n    fm->fname = NULL;\n#ifdef FEAT_VIMINFO\n    fm->time_set = vim_time();\n#endif\n}\n\n/*\n * To change context, call setpcmark(), then move the current position to\n * where ever, then call checkpcmark().  This ensures that the previous\n * context will only be changed if the cursor moved to a different line.\n * If pcmark was deleted (with \"dG\") the previous mark is restored.\n */\n    void\ncheckpcmark(void)\n{\n    if (curwin->w_prev_pcmark.lnum != 0\n\t    && (EQUAL_POS(curwin->w_pcmark, curwin->w_cursor)\n\t\t|| curwin->w_pcmark.lnum == 0))\n\tcurwin->w_pcmark = curwin->w_prev_pcmark;\n    curwin->w_prev_pcmark.lnum = 0;\t\t// it has been checked\n}\n\n/*\n * move \"count\" positions in the jump list (count may be negative)\n */\n    pos_T *\nmovemark(int count)\n{\n    pos_T\t*pos;\n    xfmark_T\t*jmp;\n\n    cleanup_jumplist(curwin, TRUE);\n\n    if (curwin->w_jumplistlen == 0)\t    // nothing to jump to\n\treturn (pos_T *)NULL;\n\n    for (;;)\n    {\n\tif (curwin->w_jumplistidx + count < 0\n\t\t|| curwin->w_jumplistidx + count >= curwin->w_jumplistlen)\n\t    return (pos_T *)NULL;\n\n\t/*\n\t * if first CTRL-O or CTRL-I command after a jump, add cursor position\n\t * to list.  Careful: If there are duplicates (CTRL-O immediately after\n\t * starting Vim on a file), another entry may have been removed.\n\t */\n\tif (curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t{\n\t    setpcmark();\n\t    --curwin->w_jumplistidx;\t// skip the new entry\n\t    if (curwin->w_jumplistidx + count < 0)\n\t\treturn (pos_T *)NULL;\n\t}\n\n\tcurwin->w_jumplistidx += count;\n\n\tjmp = curwin->w_jumplist + curwin->w_jumplistidx;\n\tif (jmp->fmark.fnum == 0)\n\t    fname2fnum(jmp);\n\tif (jmp->fmark.fnum != curbuf->b_fnum)\n\t{\n\t    // Make a copy, an autocommand may make \"jmp\" invalid.\n\t    fmark_T fmark = jmp->fmark;\n\n\t    // jump to the file with the mark\n\t    if (buflist_findnr(fmark.fnum) == NULL)\n\t    {\t\t\t\t\t     // Skip this one ..\n\t\tcount += count < 0 ? -1 : 1;\n\t\tcontinue;\n\t    }\n\t    if (buflist_getfile(fmark.fnum, fmark.mark.lnum, 0, FALSE) == FAIL)\n\t\treturn (pos_T *)NULL;\n\t    // Set lnum again, autocommands my have changed it\n\t    curwin->w_cursor = fmark.mark;\n\t    pos = (pos_T *)-1;\n\t}\n\telse\n\t    pos = &(jmp->fmark.mark);\n\treturn pos;\n    }\n}\n\n/*\n * Move \"count\" positions in the changelist (count may be negative).\n */\n    pos_T *\nmovechangelist(int count)\n{\n    int\t\tn;\n\n    if (curbuf->b_changelistlen == 0)\t    // nothing to jump to\n\treturn (pos_T *)NULL;\n\n    n = curwin->w_changelistidx;\n    if (n + count < 0)\n    {\n\tif (n == 0)\n\t    return (pos_T *)NULL;\n\tn = 0;\n    }\n    else if (n + count >= curbuf->b_changelistlen)\n    {\n\tif (n == curbuf->b_changelistlen - 1)\n\t    return (pos_T *)NULL;\n\tn = curbuf->b_changelistlen - 1;\n    }\n    else\n\tn += count;\n    curwin->w_changelistidx = n;\n    return curbuf->b_changelist + n;\n}\n\n/*\n * Find mark \"c\" in buffer pointed to by \"buf\".\n * If \"changefile\" is TRUE it's allowed to edit another file for '0, 'A, etc.\n * If \"fnum\" is not NULL store the fnum there for '0, 'A etc., don't edit\n * another file.\n * Returns:\n * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is\n *   in another file which can't be gotten. (caller needs to check lnum!)\n * - NULL if there is no mark called 'c'.\n * - -1 if mark is in other file and jumped there (only if changefile is TRUE)\n */\n    pos_T *\ngetmark_buf(buf_T *buf, int c, int changefile)\n{\n    return getmark_buf_fnum(buf, c, changefile, NULL);\n}\n\n    pos_T *\ngetmark(int c, int changefile)\n{\n    return getmark_buf_fnum(curbuf, c, changefile, NULL);\n}\n\n    pos_T *\ngetmark_buf_fnum(\n    buf_T\t*buf,\n    int\t\tc,\n    int\t\tchangefile,\n    int\t\t*fnum)\n{\n    pos_T\t\t*posp;\n    pos_T\t\t*startp, *endp;\n    static pos_T\tpos_copy;\n\n    posp = NULL;\n\n    // Check for special key, can't be a mark name and might cause islower()\n    // to crash.\n    if (c < 0)\n\treturn posp;\n    if (c > '~')\t\t\t// check for islower()/isupper()\n\t;\n    else if (c == '\\'' || c == '`')\t// previous context mark\n    {\n\tpos_copy = curwin->w_pcmark;\t// need to make a copy because\n\tposp = &pos_copy;\t\t//   w_pcmark may be changed soon\n    }\n    else if (c == '\"')\t\t\t// to pos when leaving buffer\n\tposp = &(buf->b_last_cursor);\n    else if (c == '^')\t\t\t// to where Insert mode stopped\n\tposp = &(buf->b_last_insert);\n    else if (c == '.')\t\t\t// to where last change was made\n\tposp = &(buf->b_last_change);\n    else if (c == '[')\t\t\t// to start of previous operator\n\tposp = &(buf->b_op_start);\n    else if (c == ']')\t\t\t// to end of previous operator\n\tposp = &(buf->b_op_end);\n    else if (c == '{' || c == '}')\t// to previous/next paragraph\n    {\n\tpos_T\tpos;\n\toparg_T\toa;\n\tint\tslcb = listcmd_busy;\n\n\tpos = curwin->w_cursor;\n\tlistcmd_busy = TRUE;\t    // avoid that '' is changed\n\tif (findpar(&oa.inclusive,\n\t\t\t       c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE))\n\t{\n\t    pos_copy = curwin->w_cursor;\n\t    posp = &pos_copy;\n\t}\n\tcurwin->w_cursor = pos;\n\tlistcmd_busy = slcb;\n    }\n    else if (c == '(' || c == ')')\t// to previous/next sentence\n    {\n\tpos_T\tpos;\n\tint\tslcb = listcmd_busy;\n\n\tpos = curwin->w_cursor;\n\tlistcmd_busy = TRUE;\t    // avoid that '' is changed\n\tif (findsent(c == ')' ? FORWARD : BACKWARD, 1L))\n\t{\n\t    pos_copy = curwin->w_cursor;\n\t    posp = &pos_copy;\n\t}\n\tcurwin->w_cursor = pos;\n\tlistcmd_busy = slcb;\n    }\n    else if (c == '<' || c == '>')\t// start/end of visual area\n    {\n\tstartp = &buf->b_visual.vi_start;\n\tendp = &buf->b_visual.vi_end;\n\tif (((c == '<') == LT_POS(*startp, *endp) || endp->lnum == 0)\n\t\t\t\t\t\t\t  && startp->lnum != 0)\n\t    posp = startp;\n\telse\n\t    posp = endp;\n\t/*\n\t * For Visual line mode, set mark at begin or end of line\n\t */\n\tif (buf->b_visual.vi_mode == 'V')\n\t{\n\t    pos_copy = *posp;\n\t    posp = &pos_copy;\n\t    if (c == '<')\n\t\tpos_copy.col = 0;\n\t    else\n\t\tpos_copy.col = MAXCOL;\n\t    pos_copy.coladd = 0;\n\t}\n    }\n    else if (ASCII_ISLOWER(c))\t\t// normal named mark\n    {\n\tposp = &(buf->b_namedm[c - 'a']);\n    }\n    else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))\t// named file mark\n    {\n\tif (VIM_ISDIGIT(c))\n\t    c = c - '0' + NMARKS;\n\telse\n\t    c -= 'A';\n\tposp = &(namedfm[c].fmark.mark);\n\n\tif (namedfm[c].fmark.fnum == 0)\n\t    fname2fnum(&namedfm[c]);\n\n\tif (fnum != NULL)\n\t    *fnum = namedfm[c].fmark.fnum;\n\telse if (namedfm[c].fmark.fnum != buf->b_fnum)\n\t{\n\t    // mark is in another file\n\t    posp = &pos_copy;\n\n\t    if (namedfm[c].fmark.mark.lnum != 0\n\t\t\t\t       && changefile && namedfm[c].fmark.fnum)\n\t    {\n\t\tif (buflist_getfile(namedfm[c].fmark.fnum,\n\t\t\t\t      (linenr_T)1, GETF_SETMARK, FALSE) == OK)\n\t\t{\n\t\t    // Set the lnum now, autocommands could have changed it\n\t\t    curwin->w_cursor = namedfm[c].fmark.mark;\n\t\t    return (pos_T *)-1;\n\t\t}\n\t\tpos_copy.lnum = -1;\t// can't get file\n\t    }\n\t    else\n\t\tpos_copy.lnum = 0;\t// mark exists, but is not valid in\n\t\t\t\t\t// current buffer\n\t}\n    }\n\n    return posp;\n}\n\n/*\n * Search for the next named mark in the current file.\n *\n * Returns pointer to pos_T of the next mark or NULL if no mark is found.\n */\n    pos_T *\ngetnextmark(\n    pos_T\t*startpos,\t// where to start\n    int\t\tdir,\t// direction for search\n    int\t\tbegin_line)\n{\n    int\t\ti;\n    pos_T\t*result = NULL;\n    pos_T\tpos;\n\n    pos = *startpos;\n\n    // When searching backward and leaving the cursor on the first non-blank,\n    // position must be in a previous line.\n    // When searching forward and leaving the cursor on the first non-blank,\n    // position must be in a next line.\n    if (dir == BACKWARD && begin_line)\n\tpos.col = 0;\n    else if (dir == FORWARD && begin_line)\n\tpos.col = MAXCOL;\n\n    for (i = 0; i < NMARKS; i++)\n    {\n\tif (curbuf->b_namedm[i].lnum > 0)\n\t{\n\t    if (dir == FORWARD)\n\t    {\n\t\tif ((result == NULL || LT_POS(curbuf->b_namedm[i], *result))\n\t\t\t&& LT_POS(pos, curbuf->b_namedm[i]))\n\t\t    result = &curbuf->b_namedm[i];\n\t    }\n\t    else\n\t    {\n\t\tif ((result == NULL || LT_POS(*result, curbuf->b_namedm[i]))\n\t\t\t&& LT_POS(curbuf->b_namedm[i], pos))\n\t\t    result = &curbuf->b_namedm[i];\n\t    }\n\t}\n    }\n\n    return result;\n}\n\n/*\n * For an xtended filemark: set the fnum from the fname.\n * This is used for marks obtained from the .viminfo file.  It's postponed\n * until the mark is used to avoid a long startup delay.\n */\n    static void\nfname2fnum(xfmark_T *fm)\n{\n    char_u\t*p;\n\n    if (fm->fname != NULL)\n    {\n\t/*\n\t * First expand \"~/\" in the file name to the home directory.\n\t * Don't expand the whole name, it may contain other '~' chars.\n\t */\n\tif (fm->fname[0] == '~' && (fm->fname[1] == '/'\n#ifdef BACKSLASH_IN_FILENAME\n\t\t    || fm->fname[1] == '\\\\'\n#endif\n\t\t    ))\n\t{\n\t    int len;\n\n\t    expand_env((char_u *)\"~/\", NameBuff, MAXPATHL);\n\t    len = (int)STRLEN(NameBuff);\n\t    vim_strncpy(NameBuff + len, fm->fname + 2, MAXPATHL - len - 1);\n\t}\n\telse\n\t    vim_strncpy(NameBuff, fm->fname, MAXPATHL - 1);\n\n\t// Try to shorten the file name.\n\tmch_dirname(IObuff, IOSIZE);\n\tp = shorten_fname(NameBuff, IObuff);\n\n\t// buflist_new() will call fmarks_check_names()\n\t(void)buflist_new(NameBuff, p, (linenr_T)1, 0);\n    }\n}\n\n/*\n * Check all file marks for a name that matches the file name in buf.\n * May replace the name with an fnum.\n * Used for marks that come from the .viminfo file.\n */\n    void\nfmarks_check_names(buf_T *buf)\n{\n    char_u\t*name;\n    int\t\ti;\n    win_T\t*wp;\n\n    if (buf->b_ffname == NULL)\n\treturn;\n\n    name = home_replace_save(buf, buf->b_ffname);\n    if (name == NULL)\n\treturn;\n\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n\tfmarks_check_one(&namedfm[i], name, buf);\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tfor (i = 0; i < wp->w_jumplistlen; ++i)\n\t    fmarks_check_one(&wp->w_jumplist[i], name, buf);\n    }\n\n    vim_free(name);\n}\n\n    static void\nfmarks_check_one(xfmark_T *fm, char_u *name, buf_T *buf)\n{\n    if (fm->fmark.fnum == 0\n\t    && fm->fname != NULL\n\t    && fnamecmp(name, fm->fname) == 0)\n    {\n\tfm->fmark.fnum = buf->b_fnum;\n\tVIM_CLEAR(fm->fname);\n    }\n}\n\n/*\n * Check a if a position from a mark is valid.\n * Give and error message and return FAIL if not.\n */\n    int\ncheck_mark(pos_T *pos)\n{\n    if (pos == NULL)\n    {\n\temsg(_(e_unknown_mark));\n\treturn FAIL;\n    }\n    if (pos->lnum <= 0)\n    {\n\t// lnum is negative if mark is in another file can can't get that\n\t// file, error message already give then.\n\tif (pos->lnum == 0)\n\t    emsg(_(e_mark_not_set));\n\treturn FAIL;\n    }\n    if (pos->lnum > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_mark_has_invalid_line_number));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * clrallmarks() - clear all marks in the buffer 'buf'\n *\n * Used mainly when trashing the entire buffer during \":e\" type commands\n */\n    void\nclrallmarks(buf_T *buf)\n{\n    static int\t\ti = -1;\n\n    if (i == -1)\t// first call ever: initialize\n\tfor (i = 0; i < NMARKS + 1; i++)\n\t{\n\t    namedfm[i].fmark.mark.lnum = 0;\n\t    namedfm[i].fname = NULL;\n#ifdef FEAT_VIMINFO\n\t    namedfm[i].time_set = 0;\n#endif\n\t}\n\n    for (i = 0; i < NMARKS; i++)\n\tbuf->b_namedm[i].lnum = 0;\n    buf->b_op_start.lnum = 0;\t\t// start/end op mark cleared\n    buf->b_op_end.lnum = 0;\n    buf->b_last_cursor.lnum = 1;\t// '\" mark cleared\n    buf->b_last_cursor.col = 0;\n    buf->b_last_cursor.coladd = 0;\n    buf->b_last_insert.lnum = 0;\t// '^ mark cleared\n    buf->b_last_change.lnum = 0;\t// '. mark cleared\n    buf->b_changelistlen = 0;\n}\n\n/*\n * Get name of file from a filemark.\n * When it's in the current buffer, return the text at the mark.\n * Returns an allocated string.\n */\n    char_u *\nfm_getname(fmark_T *fmark, int lead_len)\n{\n    if (fmark->fnum == curbuf->b_fnum)\t\t    // current buffer\n\treturn mark_line(&(fmark->mark), lead_len);\n    return buflist_nr2name(fmark->fnum, FALSE, TRUE);\n}\n\n/*\n * Return the line at mark \"mp\".  Truncate to fit in window.\n * The returned string has been allocated.\n */\n    static char_u *\nmark_line(pos_T *mp, int lead_len)\n{\n    char_u\t*s, *p;\n    int\t\tlen;\n\n    if (mp->lnum == 0 || mp->lnum > curbuf->b_ml.ml_line_count)\n\treturn vim_strsave((char_u *)\"-invalid-\");\n    // Allow for up to 5 bytes per character.\n    s = vim_strnsave(skipwhite(ml_get(mp->lnum)), Columns * 5);\n    if (s == NULL)\n\treturn NULL;\n    // Truncate the line to fit it in the window.\n    len = 0;\n    for (p = s; *p != NUL; MB_PTR_ADV(p))\n    {\n\tlen += ptr2cells(p);\n\tif (len >= Columns - lead_len)\n\t    break;\n    }\n    *p = NUL;\n    return s;\n}\n\n/*\n * print the marks\n */\n    void\nex_marks(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\ti;\n    char_u\t*name;\n    pos_T\t*posp, *startp, *endp;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n\n    show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, TRUE);\n    for (i = 0; i < NMARKS; ++i)\n\tshow_one_mark(i + 'a', arg, &curbuf->b_namedm[i], NULL, TRUE);\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n    {\n\tif (namedfm[i].fmark.fnum != 0)\n\t    name = fm_getname(&namedfm[i].fmark, 15);\n\telse\n\t    name = namedfm[i].fname;\n\tif (name != NULL)\n\t{\n\t    show_one_mark(i >= NMARKS ? i - NMARKS + '0' : i + 'A',\n\t\t    arg, &namedfm[i].fmark.mark, name,\n\t\t    namedfm[i].fmark.fnum == curbuf->b_fnum);\n\t    if (namedfm[i].fmark.fnum != 0)\n\t\tvim_free(name);\n\t}\n    }\n    show_one_mark('\"', arg, &curbuf->b_last_cursor, NULL, TRUE);\n    show_one_mark('[', arg, &curbuf->b_op_start, NULL, TRUE);\n    show_one_mark(']', arg, &curbuf->b_op_end, NULL, TRUE);\n    show_one_mark('^', arg, &curbuf->b_last_insert, NULL, TRUE);\n    show_one_mark('.', arg, &curbuf->b_last_change, NULL, TRUE);\n\n    // Show the marks as where they will jump to.\n    startp = &curbuf->b_visual.vi_start;\n    endp = &curbuf->b_visual.vi_end;\n    if ((LT_POS(*startp, *endp) || endp->lnum == 0) && startp->lnum != 0)\n\tposp = startp;\n    else\n\tposp = endp;\n    show_one_mark('<', arg, posp, NULL, TRUE);\n    show_one_mark('>', arg, posp == startp ? endp : startp, NULL, TRUE);\n\n    show_one_mark(-1, arg, NULL, NULL, FALSE);\n}\n\n    static void\nshow_one_mark(\n    int\t\tc,\n    char_u\t*arg,\n    pos_T\t*p,\n    char_u\t*name_arg,\n    int\t\tcurrent)\t// in current file\n{\n    static int\tdid_title = FALSE;\n    int\t\tmustfree = FALSE;\n    char_u\t*name = name_arg;\n\n    if (c == -1)\t\t\t    // finish up\n    {\n\tif (did_title)\n\t    did_title = FALSE;\n\telse\n\t{\n\t    if (arg == NULL)\n\t\tmsg(_(\"No marks set\"));\n\t    else\n\t\tsemsg(_(e_no_marks_matching_str), arg);\n\t}\n    }\n    // don't output anything if 'q' typed at --more-- prompt\n    else if (!got_int\n\t    && (arg == NULL || vim_strchr(arg, c) != NULL)\n\t    && p->lnum != 0)\n    {\n\tif (name == NULL && current)\n\t{\n\t    name = mark_line(p, 15);\n\t    mustfree = TRUE;\n\t}\n\tif (!message_filtered(name))\n\t{\n\t    if (!did_title)\n\t    {\n\t\t// Highlight title\n\t\tmsg_puts_title(_(\"\\nmark line  col file/text\"));\n\t\tdid_title = TRUE;\n\t    }\n\t    msg_putchar('\\n');\n\t    if (!got_int)\n\t    {\n\t\tsprintf((char *)IObuff, \" %c %6ld %4d \", c, p->lnum, p->col);\n\t\tmsg_outtrans(IObuff);\n\t\tif (name != NULL)\n\t\t{\n\t\t    msg_outtrans_attr(name, current ? HL_ATTR(HLF_D) : 0);\n\t\t}\n\t    }\n\t    out_flush();\t\t    // show one line at a time\n\t}\n\tif (mustfree)\n\t    vim_free(name);\n    }\n}\n\n/*\n * \":delmarks[!] [marks]\"\n */\n    void\nex_delmarks(exarg_T *eap)\n{\n    char_u\t*p;\n    int\t\tfrom, to;\n    int\t\ti;\n    int\t\tlower;\n    int\t\tdigit;\n    int\t\tn;\n\n    if (*eap->arg == NUL && eap->forceit)\n\t// clear all marks\n\tclrallmarks(curbuf);\n    else if (eap->forceit)\n\temsg(_(e_invalid_argument));\n    else if (*eap->arg == NUL)\n\temsg(_(e_argument_required));\n    else\n    {\n\t// clear specified marks only\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n\t    lower = ASCII_ISLOWER(*p);\n\t    digit = VIM_ISDIGIT(*p);\n\t    if (lower || digit || ASCII_ISUPPER(*p))\n\t    {\n\t\tif (p[1] == '-')\n\t\t{\n\t\t    // clear range of marks\n\t\t    from = *p;\n\t\t    to = p[2];\n\t\t    if (!(lower ? ASCII_ISLOWER(p[2])\n\t\t\t\t: (digit ? VIM_ISDIGIT(p[2])\n\t\t\t\t    : ASCII_ISUPPER(p[2])))\n\t\t\t    || to < from)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_argument_str), p);\n\t\t\treturn;\n\t\t    }\n\t\t    p += 2;\n\t\t}\n\t\telse\n\t\t    // clear one lower case mark\n\t\t    from = to = *p;\n\n\t\tfor (i = from; i <= to; ++i)\n\t\t{\n\t\t    if (lower)\n\t\t\tcurbuf->b_namedm[i - 'a'].lnum = 0;\n\t\t    else\n\t\t    {\n\t\t\tif (digit)\n\t\t\t    n = i - '0' + NMARKS;\n\t\t\telse\n\t\t\t    n = i - 'A';\n\t\t\tnamedfm[n].fmark.mark.lnum = 0;\n\t\t\tnamedfm[n].fmark.fnum = 0;\n\t\t\tVIM_CLEAR(namedfm[n].fname);\n#ifdef FEAT_VIMINFO\n\t\t\tnamedfm[n].time_set = digit ? 0 : vim_time();\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tswitch (*p)\n\t\t{\n\t\t    case '\"': curbuf->b_last_cursor.lnum = 0; break;\n\t\t    case '^': curbuf->b_last_insert.lnum = 0; break;\n\t\t    case '.': curbuf->b_last_change.lnum = 0; break;\n\t\t    case '[': curbuf->b_op_start.lnum    = 0; break;\n\t\t    case ']': curbuf->b_op_end.lnum      = 0; break;\n\t\t    case '<': curbuf->b_visual.vi_start.lnum = 0; break;\n\t\t    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;\n\t\t    case ' ': break;\n\t\t    default:  semsg(_(e_invalid_argument_str), p);\n\t\t\t      return;\n\t\t}\n\t}\n    }\n}\n\n/*\n * print the jumplist\n */\n    void\nex_jumps(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n\n    cleanup_jumplist(curwin, TRUE);\n\n    // Highlight title\n    msg_puts_title(_(\"\\n jump line  col file/text\"));\n    for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i)\n    {\n\tif (curwin->w_jumplist[i].fmark.mark.lnum != 0)\n\t{\n\t    name = fm_getname(&curwin->w_jumplist[i].fmark, 16);\n\n\t    // Make sure to output the current indicator, even when on an wiped\n\t    // out buffer.  \":filter\" may still skip it.\n\t    if (name == NULL && i == curwin->w_jumplistidx)\n\t\tname = vim_strsave((char_u *)\"-invalid-\");\n\t    // apply :filter /pat/ or file name not available\n\t    if (name == NULL || message_filtered(name))\n\t    {\n\t\tvim_free(name);\n\t\tcontinue;\n\t    }\n\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t    {\n\t\tvim_free(name);\n\t\tbreak;\n\t    }\n\t    sprintf((char *)IObuff, \"%c %2d %5ld %4d \",\n\t\ti == curwin->w_jumplistidx ? '>' : ' ',\n\t\ti > curwin->w_jumplistidx ? i - curwin->w_jumplistidx\n\t\t\t\t\t  : curwin->w_jumplistidx - i,\n\t\tcurwin->w_jumplist[i].fmark.mark.lnum,\n\t\tcurwin->w_jumplist[i].fmark.mark.col);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name,\n\t\t\t    curwin->w_jumplist[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t    ui_breakcheck();\n\t}\n\tout_flush();\n    }\n    if (curwin->w_jumplistidx == curwin->w_jumplistlen)\n\tmsg_puts(\"\\n>\");\n}\n\n    void\nex_clearjumps(exarg_T *eap UNUSED)\n{\n    free_jumplist(curwin);\n    curwin->w_jumplistlen = 0;\n    curwin->w_jumplistidx = 0;\n}\n\n/*\n * print the changelist\n */\n    void\nex_changes(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n\n    // Highlight title\n    msg_puts_title(_(\"\\nchange line  col text\"));\n\n    for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i)\n    {\n\tif (curbuf->b_changelist[i].lnum != 0)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    sprintf((char *)IObuff, \"%c %3d %5ld %4d \",\n\t\t    i == curwin->w_changelistidx ? '>' : ' ',\n\t\t    i > curwin->w_changelistidx ? i - curwin->w_changelistidx\n\t\t\t\t\t\t: curwin->w_changelistidx - i,\n\t\t    (long)curbuf->b_changelist[i].lnum,\n\t\t    curbuf->b_changelist[i].col);\n\t    msg_outtrans(IObuff);\n\t    name = mark_line(&curbuf->b_changelist[i], 17);\n\t    if (name == NULL)\n\t\tbreak;\n\t    msg_outtrans_attr(name, HL_ATTR(HLF_D));\n\t    vim_free(name);\n\t    ui_breakcheck();\n\t}\n\tout_flush();\n    }\n    if (curwin->w_changelistidx == curbuf->b_changelistlen)\n\tmsg_puts(\"\\n>\");\n}\n\n#define one_adjust(add) \\\n    { \\\n\tlp = add; \\\n\tif (*lp >= line1 && *lp <= line2) \\\n\t{ \\\n\t    if (amount == MAXLNUM) \\\n\t\t*lp = 0; \\\n\t    else \\\n\t\t*lp += amount; \\\n\t} \\\n\telse if (amount_after && *lp > line2) \\\n\t    *lp += amount_after; \\\n    }\n\n// don't delete the line, just put at first deleted line\n#define one_adjust_nodel(add) \\\n    { \\\n\tlp = add; \\\n\tif (*lp >= line1 && *lp <= line2) \\\n\t{ \\\n\t    if (amount == MAXLNUM) \\\n\t\t*lp = line1; \\\n\t    else \\\n\t\t*lp += amount; \\\n\t} \\\n\telse if (amount_after && *lp > line2) \\\n\t    *lp += amount_after; \\\n    }\n\n/*\n * Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.\n * Must be called before changed_*(), appended_lines() or deleted_lines().\n * May be called before or after changing the text.\n * When deleting lines line1 to line2, use an 'amount' of MAXLNUM: The marks\n * within this range are made invalid.\n * If 'amount_after' is non-zero adjust marks after line2.\n * Example: Delete lines 34 and 35: mark_adjust(34, 35, MAXLNUM, -2);\n * Example: Insert two lines below 55: mark_adjust(56, MAXLNUM, 2, 0);\n *\t\t\t\t   or: mark_adjust(56, 55, MAXLNUM, 2);\n */\n    void\nmark_adjust(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    mark_adjust_internal(line1, line2, amount, amount_after, TRUE);\n}\n\n    void\nmark_adjust_nofold(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    mark_adjust_internal(line1, line2, amount, amount_after, FALSE);\n}\n\n    static void\nmark_adjust_internal(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after,\n    int\t\tadjust_folds UNUSED)\n{\n    int\t\ti;\n    int\t\tfnum = curbuf->b_fnum;\n    linenr_T\t*lp;\n    win_T\t*win;\n    tabpage_T\t*tab;\n    static pos_T initpos = {1, 0, 0};\n\n    if (line2 < line1 && amount_after == 0L)\t    // nothing to do\n\treturn;\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// named marks, lower case and upper case\n\tfor (i = 0; i < NMARKS; i++)\n\t{\n\t    one_adjust(&(curbuf->b_namedm[i].lnum));\n\t    if (namedfm[i].fmark.fnum == fnum)\n\t\tone_adjust_nodel(&(namedfm[i].fmark.mark.lnum));\n\t}\n\tfor (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n\t{\n\t    if (namedfm[i].fmark.fnum == fnum)\n\t\tone_adjust_nodel(&(namedfm[i].fmark.mark.lnum));\n\t}\n\n\t// last Insert position\n\tone_adjust(&(curbuf->b_last_insert.lnum));\n\n\t// last change position\n\tone_adjust(&(curbuf->b_last_change.lnum));\n\n\t// last cursor position, if it was set\n\tif (!EQUAL_POS(curbuf->b_last_cursor, initpos))\n\t    one_adjust(&(curbuf->b_last_cursor.lnum));\n\n\n\t// list of change positions\n\tfor (i = 0; i < curbuf->b_changelistlen; ++i)\n\t    one_adjust_nodel(&(curbuf->b_changelist[i].lnum));\n\n\t// Visual area\n\tone_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));\n\tone_adjust_nodel(&(curbuf->b_visual.vi_end.lnum));\n\n#ifdef FEAT_QUICKFIX\n\t// quickfix marks\n\tqf_mark_adjust(NULL, line1, line2, amount, amount_after);\n\t// location lists\n\tFOR_ALL_TAB_WINDOWS(tab, win)\n\t    qf_mark_adjust(win, line1, line2, amount, amount_after);\n#endif\n\n#ifdef FEAT_SIGNS\n\tsign_mark_adjust(line1, line2, amount, amount_after);\n#endif\n    }\n\n    // previous context mark\n    one_adjust(&(curwin->w_pcmark.lnum));\n\n    // previous pcmark\n    one_adjust(&(curwin->w_prev_pcmark.lnum));\n\n    // saved cursor for formatting\n    if (saved_cursor.lnum != 0)\n\tone_adjust_nodel(&(saved_cursor.lnum));\n\n    /*\n     * Adjust items in all windows related to the current buffer.\n     */\n    FOR_ALL_TAB_WINDOWS(tab, win)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    // Marks in the jumplist.  When deleting lines, this may create\n\t    // duplicate marks in the jumplist, they will be removed later.\n\t    for (i = 0; i < win->w_jumplistlen; ++i)\n\t\tif (win->w_jumplist[i].fmark.fnum == fnum)\n\t\t    one_adjust_nodel(&(win->w_jumplist[i].fmark.mark.lnum));\n\n\tif (win->w_buffer == curbuf)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t\t// marks in the tag stack\n\t\tfor (i = 0; i < win->w_tagstacklen; i++)\n\t\t    if (win->w_tagstack[i].fmark.fnum == fnum)\n\t\t\tone_adjust_nodel(&(win->w_tagstack[i].fmark.mark.lnum));\n\n\t    // the displayed Visual area\n\t    if (win->w_old_cursor_lnum != 0)\n\t    {\n\t\tone_adjust_nodel(&(win->w_old_cursor_lnum));\n\t\tone_adjust_nodel(&(win->w_old_visual_lnum));\n\t    }\n\n\t    // topline and cursor position for windows with the same buffer\n\t    // other than the current window\n\t    if (win != curwin)\n\t    {\n\t\tif (win->w_topline >= line1 && win->w_topline <= line2)\n\t\t{\n\t\t    if (amount == MAXLNUM)\t    // topline is deleted\n\t\t    {\n\t\t\tif (line1 <= 1)\n\t\t\t    win->w_topline = 1;\n\t\t\telse\n\t\t\t    win->w_topline = line1 - 1;\n\t\t    }\n\t\t    else\t\t// keep topline on the same line\n\t\t\twin->w_topline += amount;\n#ifdef FEAT_DIFF\n\t\t    win->w_topfill = 0;\n#endif\n\t\t}\n\t\telse if (amount_after && win->w_topline > line2)\n\t\t{\n\t\t    win->w_topline += amount_after;\n#ifdef FEAT_DIFF\n\t\t    win->w_topfill = 0;\n#endif\n\t\t}\n\t\tif (win->w_cursor.lnum >= line1 && win->w_cursor.lnum <= line2)\n\t\t{\n\t\t    if (amount == MAXLNUM) // line with cursor is deleted\n\t\t    {\n\t\t\tif (line1 <= 1)\n\t\t\t    win->w_cursor.lnum = 1;\n\t\t\telse\n\t\t\t    win->w_cursor.lnum = line1 - 1;\n\t\t\twin->w_cursor.col = 0;\n\t\t    }\n\t\t    else\t\t// keep cursor on the same line\n\t\t\twin->w_cursor.lnum += amount;\n\t\t}\n\t\telse if (amount_after && win->w_cursor.lnum > line2)\n\t\t    win->w_cursor.lnum += amount_after;\n\t    }\n\n#ifdef FEAT_FOLDING\n\t    // adjust folds\n\t    if (adjust_folds)\n\t\tfoldMarkAdjust(win, line1, line2, amount, amount_after);\n#endif\n\t}\n    }\n\n#ifdef FEAT_DIFF\n    // adjust diffs\n    diff_mark_adjust(line1, line2, amount, amount_after);\n#endif\n}\n\n// This code is used often, needs to be fast.\n#define col_adjust(pp) \\\n    { \\\n\tposp = pp; \\\n\tif (posp->lnum == lnum && posp->col >= mincol) \\\n\t{ \\\n\t    posp->lnum += lnum_amount; \\\n\t    if (col_amount < 0 && posp->col <= (colnr_T)-col_amount) \\\n\t\tposp->col = 0; \\\n\t    else if (posp->col < spaces_removed) \\\n\t\tposp->col = col_amount + spaces_removed; \\\n\t    else \\\n\t\tposp->col += col_amount; \\\n\t} \\\n    }\n\n/*\n * Adjust marks in line \"lnum\" at column \"mincol\" and further: add\n * \"lnum_amount\" to the line number and add \"col_amount\" to the column\n * position.\n * \"spaces_removed\" is the number of spaces that were removed, matters when the\n * cursor is inside them.\n */\n    void\nmark_col_adjust(\n    linenr_T\tlnum,\n    colnr_T\tmincol,\n    long\tlnum_amount,\n    long\tcol_amount,\n    int\t\tspaces_removed)\n{\n    int\t\ti;\n    int\t\tfnum = curbuf->b_fnum;\n    win_T\t*win;\n    pos_T\t*posp;\n\n    if ((col_amount == 0L && lnum_amount == 0L)\n\t\t\t\t       || (cmdmod.cmod_flags & CMOD_LOCKMARKS))\n\treturn; // nothing to do\n\n    // named marks, lower case and upper case\n    for (i = 0; i < NMARKS; i++)\n    {\n\tcol_adjust(&(curbuf->b_namedm[i]));\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n    for (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n    {\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n\n    // last Insert position\n    col_adjust(&(curbuf->b_last_insert));\n\n    // last change position\n    col_adjust(&(curbuf->b_last_change));\n\n    // list of change positions\n    for (i = 0; i < curbuf->b_changelistlen; ++i)\n\tcol_adjust(&(curbuf->b_changelist[i]));\n\n    // Visual area\n    col_adjust(&(curbuf->b_visual.vi_start));\n    col_adjust(&(curbuf->b_visual.vi_end));\n\n    // previous context mark\n    col_adjust(&(curwin->w_pcmark));\n\n    // previous pcmark\n    col_adjust(&(curwin->w_prev_pcmark));\n\n    // saved cursor for formatting\n    col_adjust(&saved_cursor);\n\n    /*\n     * Adjust items in all windows related to the current buffer.\n     */\n    FOR_ALL_WINDOWS(win)\n    {\n\t// marks in the jumplist\n\tfor (i = 0; i < win->w_jumplistlen; ++i)\n\t    if (win->w_jumplist[i].fmark.fnum == fnum)\n\t\tcol_adjust(&(win->w_jumplist[i].fmark.mark));\n\n\tif (win->w_buffer == curbuf)\n\t{\n\t    // marks in the tag stack\n\t    for (i = 0; i < win->w_tagstacklen; i++)\n\t\tif (win->w_tagstack[i].fmark.fnum == fnum)\n\t\t    col_adjust(&(win->w_tagstack[i].fmark.mark));\n\n\t    // cursor position for other windows with the same buffer\n\t    if (win != curwin)\n\t\tcol_adjust(&win->w_cursor);\n\t}\n    }\n}\n\n/*\n * When deleting lines, this may create duplicate marks in the\n * jumplist. They will be removed here for the specified window.\n * When \"loadfiles\" is TRUE first ensure entries have the \"fnum\" field set\n * (this may be a bit slow).\n */\n    void\ncleanup_jumplist(win_T *wp, int loadfiles)\n{\n    int\t    i;\n    int\t    from, to;\n\n    if (loadfiles)\n    {\n\t// If specified, load all the files from the jump list. This is\n\t// needed to properly clean up duplicate entries, but will take some\n\t// time.\n\tfor (i = 0; i < wp->w_jumplistlen; ++i)\n\t{\n\t    if ((wp->w_jumplist[i].fmark.fnum == 0) &&\n\t\t    (wp->w_jumplist[i].fmark.mark.lnum != 0))\n\t\tfname2fnum(&wp->w_jumplist[i]);\n\t}\n    }\n\n    to = 0;\n    for (from = 0; from < wp->w_jumplistlen; ++from)\n    {\n\tif (wp->w_jumplistidx == from)\n\t    wp->w_jumplistidx = to;\n\tfor (i = from + 1; i < wp->w_jumplistlen; ++i)\n\t    if (wp->w_jumplist[i].fmark.fnum\n\t\t\t\t\t== wp->w_jumplist[from].fmark.fnum\n\t\t    && wp->w_jumplist[from].fmark.fnum != 0\n\t\t    && wp->w_jumplist[i].fmark.mark.lnum\n\t\t\t\t  == wp->w_jumplist[from].fmark.mark.lnum)\n\t\tbreak;\n\tif (i >= wp->w_jumplistlen)\t    // no duplicate\n\t    wp->w_jumplist[to++] = wp->w_jumplist[from];\n\telse\n\t    vim_free(wp->w_jumplist[from].fname);\n    }\n    if (wp->w_jumplistidx == wp->w_jumplistlen)\n\twp->w_jumplistidx = to;\n    wp->w_jumplistlen = to;\n}\n\n/*\n * Copy the jumplist from window \"from\" to window \"to\".\n */\n    void\ncopy_jumplist(win_T *from, win_T *to)\n{\n    int\t\ti;\n\n    for (i = 0; i < from->w_jumplistlen; ++i)\n    {\n\tto->w_jumplist[i] = from->w_jumplist[i];\n\tif (from->w_jumplist[i].fname != NULL)\n\t    to->w_jumplist[i].fname = vim_strsave(from->w_jumplist[i].fname);\n    }\n    to->w_jumplistlen = from->w_jumplistlen;\n    to->w_jumplistidx = from->w_jumplistidx;\n}\n\n/*\n * Free items in the jumplist of window \"wp\".\n */\n    void\nfree_jumplist(win_T *wp)\n{\n    int\t\ti;\n\n    for (i = 0; i < wp->w_jumplistlen; ++i)\n\tvim_free(wp->w_jumplist[i].fname);\n}\n\n    void\nset_last_cursor(win_T *win)\n{\n    if (win->w_buffer != NULL)\n\twin->w_buffer->b_last_cursor = win->w_cursor;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_marks(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NMARKS + EXTRA_MARKS; i++)\n\tif (namedfm[i].fmark.mark.lnum != 0)\n\t    vim_free(namedfm[i].fname);\n}\n#endif\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n/*\n * Return a pointer to the named file marks.\n */\n    xfmark_T *\nget_namedfm(void)\n{\n    return namedfm;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add information about mark 'mname' to list 'l'\n */\n    static int\nadd_mark(list_T *l, char_u *mname, pos_T *pos, int bufnr, char_u *fname)\n{\n    dict_T\t*d;\n    list_T\t*lpos;\n\n    if (pos->lnum <= 0)\n\treturn OK;\n\n    d = dict_alloc();\n    if (d == NULL)\n\treturn FAIL;\n\n    if (list_append_dict(l, d) == FAIL)\n    {\n\tdict_unref(d);\n\treturn FAIL;\n    }\n\n    lpos = list_alloc();\n    if (lpos == NULL)\n\treturn FAIL;\n\n    list_append_number(lpos, bufnr);\n    list_append_number(lpos, pos->lnum);\n    list_append_number(lpos, pos->col + 1);\n    list_append_number(lpos, pos->coladd);\n\n    if (dict_add_string(d, \"mark\", mname) == FAIL\n\t    || dict_add_list(d, \"pos\", lpos) == FAIL\n\t    || (fname != NULL && dict_add_string(d, \"file\", fname) == FAIL))\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get information about marks local to a buffer.\n */\n    static void\nget_buf_local_marks(buf_T *buf, list_T *l)\n{\n    char_u\tmname[3] = \"' \";\n    int\t\ti;\n\n    // Marks 'a' to 'z'\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tmname[1] = 'a' + i;\n\tadd_mark(l, mname, &buf->b_namedm[i], buf->b_fnum, NULL);\n    }\n\n    // Mark '' is a window local mark and not a buffer local mark\n    add_mark(l, (char_u *)\"''\", &curwin->w_pcmark, curbuf->b_fnum, NULL);\n\n    add_mark(l, (char_u *)\"'\\\"\", &buf->b_last_cursor, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'[\", &buf->b_op_start, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"']\", &buf->b_op_end, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'^\", &buf->b_last_insert, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'.\", &buf->b_last_change, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'<\", &buf->b_visual.vi_start, buf->b_fnum, NULL);\n    add_mark(l, (char_u *)\"'>\", &buf->b_visual.vi_end, buf->b_fnum, NULL);\n}\n\n/*\n * Get information about global marks ('A' to 'Z' and '0' to '9')\n */\n    static void\nget_global_marks(list_T *l)\n{\n    char_u\tmname[3] = \"' \";\n    int\t\ti;\n    char_u\t*name;\n\n    // Marks 'A' to 'Z' and '0' to '9'\n    for (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n    {\n\tif (namedfm[i].fmark.fnum != 0)\n\t    name = buflist_nr2name(namedfm[i].fmark.fnum, TRUE, TRUE);\n\telse\n\t    name = namedfm[i].fname;\n\tif (name != NULL)\n\t{\n\t    mname[1] = i >= NMARKS ? i - NMARKS + '0' : i + 'A';\n\t    add_mark(l, mname, &namedfm[i].fmark.mark,\n\t\t    namedfm[i].fmark.fnum, name);\n\t    if (namedfm[i].fmark.fnum != 0)\n\t\tvim_free(name);\n\t}\n    }\n}\n\n/*\n * getmarklist() function\n */\n    void\nf_getmarklist(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = NULL;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type == VAR_UNKNOWN)\n    {\n\tget_global_marks(rettv->vval.v_list);\n\treturn;\n    }\n\n    buf = tv_get_buf(&argvars[0], FALSE);\n    if (buf == NULL)\n\treturn;\n\n    get_buf_local_marks(buf, rettv->vval.v_list);\n}\n#endif\n", "\" Test for marks\n\n\" Test that a deleted mark is restored after delete-undo-redo-undo.\nfunc Test_Restore_DelMark()\n  enew!\n  call append(0, [\"\ttextline A\", \"\ttextline B\", \"\ttextline C\"])\n  normal! 2gg\n  set nocp viminfo+=nviminfo\n  exe \"normal! i\\<C-G>u\\<Esc>\"\n  exe \"normal! maddu\\<C-R>u\"\n  let pos = getpos(\"'a\")\n  call assert_equal(2, pos[1])\n  call assert_equal(1, pos[2])\n  enew!\nendfunc\n\n\" Test that CTRL-A and CTRL-X updates last changed mark '[, '].\nfunc Test_Incr_Marks()\n  enew!\n  call append(0, [\"123 123 123\", \"123 123 123\", \"123 123 123\"])\n  normal! gg\n  execute \"normal! \\<C-A>`[v`]rAjwvjw\\<C-X>`[v`]rX\"\n  call assert_equal(\"AAA 123 123\", getline(1))\n  call assert_equal(\"123 XXXXXXX\", getline(2))\n  call assert_equal(\"XXX 123 123\", getline(3))\n  enew!\nendfunc\n\nfunc Test_previous_jump_mark()\n  new\n  call setline(1, ['']->repeat(6))\n  normal Ggg\n  call assert_equal(6, getpos(\"''\")[1])\n  normal jjjjj\n  call assert_equal(6, getpos(\"''\")[1])\n  bwipe!\nendfunc\n\nfunc Test_setpos()\n  new Xone\n  let onebuf = bufnr('%')\n  let onewin = win_getid()\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  new Xtwo\n  let twobuf = bufnr('%')\n  let twowin = win_getid()\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n\n  \" for the cursor the buffer number is ignored\n  call setpos(\".\", [0, 2, 1, 0])\n  call assert_equal([0, 2, 1, 0], getpos(\".\"))\n  call setpos(\".\", [onebuf, 3, 3, 0])\n  call assert_equal([0, 3, 3, 0], getpos(\".\"))\n\n  call setpos(\"''\", [0, 1, 3, 0])\n  call assert_equal([0, 1, 3, 0], getpos(\"''\"))\n  call setpos(\"''\", [onebuf, 2, 2, 0])\n  call assert_equal([0, 2, 2, 0], getpos(\"''\"))\n\n  \" buffer-local marks\n  for mark in [\"'a\", \"'\\\"\", \"'[\", \"']\", \"'<\", \"'>\"]\n    call win_gotoid(twowin)\n    call setpos(mark, [0, 2, 1, 0])\n    call assert_equal([0, 2, 1, 0], getpos(mark), \"for mark \" . mark)\n    call setpos(mark, [onebuf, 1, 3, 0])\n    call win_gotoid(onewin)\n    call assert_equal([0, 1, 3, 0], getpos(mark), \"for mark \" . mark)\n  endfor\n\n  \" global marks\n  call win_gotoid(twowin)\n  call setpos(\"'N\", [0, 2, 1, 0])\n  call assert_equal([twobuf, 2, 1, 0], getpos(\"'N\"))\n  call setpos(\"'N\", [onebuf, 1, 3, 0])\n  call assert_equal([onebuf, 1, 3, 0], getpos(\"'N\"))\n\n  \" try invalid column and check virtcol()\n  call win_gotoid(onewin)\n  call setpos(\"'a\", [0, 1, 2, 0])\n  call assert_equal([0, 1, 2, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, -5, 0])\n  call assert_equal([0, 1, 2, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, 0, 0])\n  call assert_equal([0, 1, 1, 0], getpos(\"'a\"))\n  call setpos(\"'a\", [0, 1, 4, 0])\n  call assert_equal([0, 1, 4, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n  call setpos(\"'a\", [0, 1, 5, 0])\n  call assert_equal([0, 1, 5, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n  call setpos(\"'a\", [0, 1, 21341234, 0])\n  call assert_equal([0, 1, 21341234, 0], getpos(\"'a\"))\n  call assert_equal(4, virtcol(\"'a\"))\n\n  \" Test with invalid buffer number, line number and column number\n  call cursor(2, 2)\n  call setpos('.', [-1, 1, 1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call setpos('.', [0, -1, 1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call setpos('.', [0, 1, -1, 0])\n  call assert_equal([2, 2], [line('.'), col('.')])\n\n  call assert_fails(\"call setpos('ab', [0, 1, 1, 0])\", 'E474:')\n\n  bwipe!\n  call win_gotoid(twowin)\n  bwipe!\nendfunc\n\nfunc Test_marks_cmd()\n  new Xone\n  call setline(1, ['aaa', 'bbb'])\n  norm! maG$mB\n  w!\n  new Xtwo\n  call setline(1, ['ccc', 'ddd'])\n  norm! $mcGmD\n  exe \"norm! GVgg\\<Esc>G\"\n  w!\n\n  b Xone\n  let a = split(execute('marks'), \"\\n\")\n  call assert_equal(9, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ \" '      2    0 bbb\",\n        \\ ' a      1    0 aaa',\n        \\ ' B      2    2 bbb',\n        \\ ' D      2    0 Xtwo',\n        \\ ' \"      1    0 aaa',\n        \\ ' [      1    0 aaa',\n        \\ ' ]      2    0 bbb',\n        \\ ' .      2    0 bbb'], a)\n\n  b Xtwo\n  let a = split(execute('marks'), \"\\n\")\n  call assert_equal(11, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ \" '      1    0 ccc\",\n        \\ ' c      1    2 ccc',\n        \\ ' B      2    2 Xone',\n        \\ ' D      2    0 ddd',\n        \\ ' \"      2    0 ddd',\n        \\ ' [      1    0 ccc',\n        \\ ' ]      2    0 ddd',\n        \\ ' .      2    0 ddd',\n        \\ ' <      1    0 ccc',\n        \\ ' >      2    0 ddd'], a)\n  norm! Gdd\n  w!\n  let a = split(execute('marks <>'), \"\\n\")\n  call assert_equal(3, len(a))\n  call assert_equal(['mark line  col file/text',\n        \\ ' <      1    0 ccc',\n        \\ ' >      2    0 -invalid-'], a)\n\n  b Xone\n  delmarks aB\n  let a = split(execute('marks aBcD'), \"\\n\")\n  call assert_equal(2, len(a))\n  call assert_equal('mark line  col file/text', a[0])\n  call assert_equal(' D      2    0 Xtwo', a[1])\n\n  b Xtwo\n  delmarks cD\n  call assert_fails('marks aBcD', 'E283:')\n\n  call delete('Xone')\n  call delete('Xtwo')\n  %bwipe\nendfunc\n\nfunc Test_marks_cmd_multibyte()\n  new Xone\n  call setline(1, [repeat('\u00e1', &columns)])\n  norm! ma\n\n  let a = split(execute('marks a'), \"\\n\")\n  call assert_equal(2, len(a))\n  let expected = ' a      1    0 ' . repeat('\u00e1', &columns - 16)\n  call assert_equal(expected, a[1])\n\n  bwipe!\nendfunc\n\nfunc Test_delmarks()\n  new\n  norm mx\n  norm `x\n  delmarks x\n  call assert_fails('norm `x', 'E20:')\n\n  \" Deleting an already deleted mark should not fail.\n  delmarks x\n\n  \" getpos() should return all zeros after deleting a filemark.\n  norm mA\n  delmarks A\n  call assert_equal([0, 0, 0, 0], getpos(\"'A\"))\n\n  \" Test deleting a range of marks.\n  norm ma\n  norm mb\n  norm mc\n  norm mz\n  delmarks b-z\n  norm `a\n  call assert_fails('norm `b', 'E20:')\n  call assert_fails('norm `c', 'E20:')\n  call assert_fails('norm `z', 'E20:')\n  call assert_fails('delmarks z-b', 'E475:')\n\n  call assert_fails('delmarks', 'E471:')\n  call assert_fails('delmarks /', 'E475:')\n\n  \" Test delmarks!\n  norm mx\n  norm `x\n  delmarks!\n  call assert_fails('norm `x', 'E20:')\n  call assert_fails('delmarks! x', 'E474:')\n\n  bwipe!\nendfunc\n\nfunc Test_mark_error()\n  call assert_fails('mark', 'E471:')\n  call assert_fails('mark xx', 'E488:')\n  call assert_fails('mark _', 'E191:')\n  call assert_beeps('normal! m~')\n\n  call setpos(\"'k\", [0, 100, 1, 0])\n  call assert_fails(\"normal 'k\", 'E19:')\nendfunc\n\n\" Test for :lockmarks when pasting content\nfunc Test_lockmarks_with_put()\n  new\n  call append(0, repeat(['sky is blue'], 4))\n  normal gg\n  1,2yank r\n  put r\n  normal G\n  lockmarks put r\n  call assert_equal(2, line(\"'[\"))\n  call assert_equal(3, line(\"']\"))\n\n  bwipe!\nendfunc\n\n\" Test for :k command to set a mark\nfunc Test_marks_k_cmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  1,3kr\n  call assert_equal([0, 3, 1, 0], getpos(\"'r\"))\n  close!\nendfunc\n\n\" Test for file marks (A-Z)\nfunc Test_file_mark()\n  new Xone\n  call setline(1, ['aaa', 'bbb'])\n  norm! G$mB\n  w!\n  new Xtwo\n  call setline(1, ['ccc', 'ddd'])\n  norm! GmD\n  w!\n\n  enew\n  normal! `B\n  call assert_equal('Xone', bufname())\n  call assert_equal([2, 3], [line('.'), col('.')])\n  normal! 'D\n  call assert_equal('Xtwo', bufname())\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  call delete('Xone')\n  call delete('Xtwo')\nendfunc\n\n\" Test for the getmarklist() function\nfunc Test_getmarklist()\n  new\n  \" global marks\n  delmarks A-Z 0-9 \\\" ^.[]\n  call assert_equal([], getmarklist())\n  call setline(1, ['one', 'two', 'three'])\n  mark A\n  call cursor(3, 5)\n  normal mN\n  call assert_equal([{'file' : '', 'mark' : \"'A\", 'pos' : [bufnr(), 1, 1, 0]},\n        \\ {'file' : '', 'mark' : \"'N\", 'pos' : [bufnr(), 3, 5, 0]}],\n        \\ getmarklist())\n  \" buffer local marks\n  delmarks!\n  call assert_equal([{'mark' : \"''\", 'pos' : [bufnr(), 1, 1, 0]},\n        \\ {'mark' : \"'\\\"\", 'pos' : [bufnr(), 1, 1, 0]}], getmarklist(bufnr()))\n  call cursor(2, 2)\n  normal mr\n  call assert_equal({'mark' : \"'r\", 'pos' : [bufnr(), 2, 2, 0]},\n        \\ bufnr()->getmarklist()[0])\n  call assert_equal([], {}->getmarklist())\n  close!\nendfunc\n\n\" This was using freed memory\nfunc Test_jump_mark_autocmd()\n  next 00\n  edit 0\n  sargument\n  au BufEnter 0 all\n  sil norm \u000f\u000f\n\n  au! BufEnter\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/mark.c", "src/testdir/test_marks.vim", "src/version.c"], "buggy_code_start_loc": [224, 307, 701], "buggy_code_end_loc": [235, 307, 701], "fixing_code_start_loc": [224, 308, 702], "fixing_code_end_loc": [237, 321, 704], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0530.", "other": {"cve": {"id": "CVE-2022-3256", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-22T13:15:09.133", "lastModified": "2023-05-03T12:16:18.170", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0530."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0530"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0530", "matchCriteriaId": "A5742538-65AF-4B5D-A207-72A657EC10DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/8ecfa2c56b4992c7f067b92488aa9acea5a454ad", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8336a3df-212a-4f8d-ae34-76ef1f936bb3", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/8ecfa2c56b4992c7f067b92488aa9acea5a454ad"}}