{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/sched/signal.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic int sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tpr_debug(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic struct proto llcp_sock_proto = {\n\t.name     = \"NFC_LLCP\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_llcp_sock),\n};\n\nstatic int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tpr_debug(\"sk %p backlog %d\\n\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM) ||\n\t    sk->sk_state != LLCP_BOUND) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tpr_debug(\"Socket listening\\n\");\n\tsk->sk_state = LLCP_LISTEN;\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tu32 opt;\n\tint err = 0;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_RW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->rw = (u8) opt;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_MIUX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->miux = cpu_to_be16((u16) opt);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tpr_debug(\"%p rw %d miux %d\\n\", llcp_sock,\n\t\t llcp_sock->rw, llcp_sock->miux);\n\n\treturn err;\n}\n\nstatic int nfc_llcp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint len, err = 0;\n\tu16 miux, remote_miu;\n\tu8 rw;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlocal = llcp_sock->local;\n\tif (!local)\n\t\treturn -ENODEV;\n\n\tlen = min_t(u32, len, sizeof(u32));\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\trw = llcp_sock->rw > LLCP_MAX_RW ? local->rw : llcp_sock->rw;\n\t\tif (put_user(rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tmiux = be16_to_cpu(llcp_sock->miux) > LLCP_MAX_MIUX ?\n\t\t\tbe16_to_cpu(local->miux) : be16_to_cpu(llcp_sock->miux);\n\n\t\tif (put_user(miux, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_MIU:\n\t\tremote_miu = llcp_sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : llcp_sock->remote_miu;\n\n\t\tif (put_user(remote_miu, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_LTO:\n\t\tif (put_user(local->remote_lto / 10, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_RW:\n\t\tif (put_user(llcp_sock->remote_rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nvoid nfc_llcp_accept_unlink(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"state %d\\n\", sk->sk_state);\n\n\tlist_del_init(&llcp_sock->accept_queue);\n\tsk_acceptq_removed(llcp_sock->parent);\n\tllcp_sock->parent = NULL;\n\n\tsock_put(sk);\n}\n\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_sock *llcp_sock_parent = nfc_llcp_sock(parent);\n\n\t/* Lock will be free from unlink */\n\tsock_hold(sk);\n\n\tlist_add_tail(&llcp_sock->accept_queue,\n\t\t      &llcp_sock_parent->accept_queue);\n\tllcp_sock->parent = parent;\n\tsk_acceptq_added(parent);\n}\n\nstruct sock *nfc_llcp_accept_dequeue(struct sock *parent,\n\t\t\t\t     struct socket *newsock)\n{\n\tstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\n\tstruct sock *sk;\n\n\tllcp_parent = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\n\t\t\t\t accept_queue) {\n\t\tsk = &lsk->sk;\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state == LLCP_CLOSED) {\n\t\t\trelease_sock(sk);\n\t\t\tnfc_llcp_accept_unlink(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == LLCP_CONNECTED || !newsock) {\n\t\t\tlist_del_init(&lsk->accept_queue);\n\t\t\tsock_put(sk);\n\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\n\t\t\trelease_sock(sk);\n\n\t\t\tpr_debug(\"Returning sk state %d\\n\", sk->sk_state);\n\n\t\t\tsk_acceptq_removed(parent);\n\n\t\t\treturn sk;\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn NULL;\n}\n\nstatic int llcp_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t    int flags, bool kern)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *new_sk;\n\tlong timeo;\n\tint ret = 0;\n\n\tpr_debug(\"parent %p\\n\", sk);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != LLCP_LISTEN) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\t/* Wait for an incoming connection. */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(new_sk = nfc_llcp_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!timeo) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (ret)\n\t\tgoto error;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tpr_debug(\"new socket %p\\n\", new_sk);\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t     int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\n\n\tif (llcp_sock == NULL || llcp_sock->dev == NULL)\n\t\treturn -EBADFD;\n\n\tpr_debug(\"%p %d %d %d\\n\", sk, llcp_sock->target_idx,\n\t\t llcp_sock->dsap, llcp_sock->ssap);\n\n\tmemset(llcp_addr, 0, sizeof(*llcp_addr));\n\n\tlock_sock(sk);\n\tif (!llcp_sock->dev) {\n\t\trelease_sock(sk);\n\t\treturn -EBADFD;\n\t}\n\tllcp_addr->sa_family = AF_NFC;\n\tllcp_addr->dev_idx = llcp_sock->dev->idx;\n\tllcp_addr->target_idx = llcp_sock->target_idx;\n\tllcp_addr->nfc_protocol = llcp_sock->nfc_protocol;\n\tllcp_addr->dsap = llcp_sock->dsap;\n\tllcp_addr->ssap = llcp_sock->ssap;\n\tllcp_addr->service_name_len = llcp_sock->service_name_len;\n\tmemcpy(llcp_addr->service_name, llcp_sock->service_name,\n\t       llcp_addr->service_name_len);\n\trelease_sock(sk);\n\n\treturn sizeof(struct sockaddr_nfc_llcp);\n}\n\nstatic inline __poll_t llcp_accept_poll(struct sock *parent)\n{\n\tstruct nfc_llcp_sock *llcp_sock, *parent_sock;\n\tstruct sock *sk;\n\n\tparent_sock = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry(llcp_sock, &parent_sock->accept_queue,\n\t\t\t    accept_queue) {\n\t\tsk = &llcp_sock->sk;\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nstatic __poll_t llcp_sock_poll(struct file *file, struct socket *sock,\n\t\t\t\t   poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask = 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tsock_poll_wait(file, sock, wait);\n\n\tif (sk->sk_state == LLCP_LISTEN)\n\t\treturn llcp_accept_poll(sk);\n\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_state == LLCP_CLOSED)\n\t\tmask |= EPOLLHUP;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\tif (sock_writeable(sk) && sk->sk_state == LLCP_CONNECTED)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\telse\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tpr_debug(\"mask 0x%x\\n\", mask);\n\n\treturn mask;\n}\n\nstatic int llcp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint err = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tlocal = llcp_sock->local;\n\tif (local == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t/* Send a DISC */\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_llcp_send_disconnect(llcp_sock);\n\n\tif (sk->sk_state == LLCP_LISTEN) {\n\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\tstruct sock *accept_sk;\n\n\t\tlist_for_each_entry_safe(lsk, n, &llcp_sock->accept_queue,\n\t\t\t\t\t accept_queue) {\n\t\t\taccept_sk = &lsk->sk;\n\t\t\tlock_sock(accept_sk);\n\n\t\t\tnfc_llcp_send_disconnect(lsk);\n\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\trelease_sock(accept_sk);\n\t\t}\n\t}\n\n\tif (llcp_sock->reserved_ssap < LLCP_SAP_MAX)\n\t\tnfc_llcp_put_ssap(llcp_sock->local, llcp_sock->ssap);\n\n\trelease_sock(sk);\n\n\t/* Keep this sock alive and therefore do not remove it from the sockets\n\t * list until the DISC PDU has been actually sent. Otherwise we would\n\t * reply with DM PDUs before sending the DISC one.\n\t */\n\tif (sk->sk_state == LLCP_DISCONNECTING)\n\t\treturn err;\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_llcp_sock_unlink(&local->raw_sockets, sk);\n\telse\n\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\nout:\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t     int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint ret = 0;\n\n\tpr_debug(\"sock %p sk %p flags 0x%x\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tif (addr->service_name_len == 0 && addr->dsap == 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\", addr->dev_idx,\n\t\t addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tret = -EISCONN;\n\t\tgoto error;\n\t}\n\tif (sk->sk_state == LLCP_CONNECTING) {\n\t\tret = -EINPROGRESS;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\tif (dev->dep_link_up == false) {\n\t\tret = -ENOLINK;\n\t\tdevice_unlock(&dev->dev);\n\t\tgoto put_dev;\n\t}\n\tdevice_unlock(&dev->dev);\n\n\tif (local->rf_mode == NFC_RF_INITIATOR &&\n\t    addr->target_idx != local->target_idx) {\n\t\tret = -ENOLINK;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->ssap = nfc_llcp_get_local_ssap(local);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tif (addr->service_name_len == 0)\n\t\tllcp_sock->dsap = addr->dsap;\n\telse\n\t\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->nfc_protocol = addr->nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    addr->service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(addr->service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_release;\n\t}\n\n\tnfc_llcp_sock_link(&local->connecting_sockets, sk);\n\n\tret = nfc_llcp_send_connect(llcp_sock);\n\tif (ret)\n\t\tgoto sock_unlink;\n\n\tsk->sk_state = LLCP_CONNECTING;\n\n\tret = sock_wait_state(sk, LLCP_CONNECTED,\n\t\t\t      sock_sndtimeo(sk, flags & O_NONBLOCK));\n\tif (ret && ret != -EINPROGRESS)\n\t\tgoto sock_unlink;\n\n\trelease_sock(sk);\n\n\treturn ret;\n\nsock_unlink:\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_release:\n\tnfc_llcp_put_ssap(local, llcp_sock->ssap);\n\tnfc_llcp_local_put(llcp_sock->local);\n\tllcp_sock->local = NULL;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint ret;\n\n\tpr_debug(\"sock %p sk %p\", sock, sk);\n\n\tret = sock_error(sk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, addr,\n\t\t\t\t msg->msg_name);\n\n\t\tif (msg->msg_namelen < sizeof(*addr)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\treturn nfc_llcp_send_ui_frame(llcp_sock, addr->dsap, addr->ssap,\n\t\t\t\t\t      msg, len);\n\t}\n\n\tif (sk->sk_state != LLCP_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\n\treturn nfc_llcp_send_i_frame(llcp_sock, msg, len);\n}\n\nstatic int llcp_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n\n\tpr_debug(\"%p %zu\\n\", sk, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_msg(cskb, 0, msg, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, sockaddr,\n\t\t\t\t msg->msg_name);\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n\nstatic const struct proto_ops llcp_sock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_sock_bind,\n\t.connect        = llcp_sock_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = llcp_sock_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = llcp_sock_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.setsockopt     = nfc_llcp_setsockopt,\n\t.getsockopt     = nfc_llcp_getsockopt,\n\t.sendmsg        = llcp_sock_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops llcp_rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_raw_sock_bind,\n\t.connect        = sock_no_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tnfc_llcp_sock_free(llcp_sock);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tsk = sk_alloc(&init_net, PF_NFC, gfp, &llcp_sock_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tllcp_sock = nfc_llcp_sock(sk);\n\n\tsock_init_data(sock, sk);\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_protocol = NFC_SOCKPROTO_LLCP;\n\tsk->sk_type = type;\n\tsk->sk_destruct = llcp_sock_destruct;\n\n\tllcp_sock->ssap = 0;\n\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->rw = LLCP_MAX_RW + 1;\n\tllcp_sock->miux = cpu_to_be16(LLCP_MAX_MIUX + 1);\n\tllcp_sock->send_n = llcp_sock->send_ack_n = 0;\n\tllcp_sock->recv_n = llcp_sock->recv_ack_n = 0;\n\tllcp_sock->remote_ready = 1;\n\tllcp_sock->reserved_ssap = LLCP_SAP_MAX;\n\tnfc_llcp_socket_remote_param_init(llcp_sock);\n\tskb_queue_head_init(&llcp_sock->tx_queue);\n\tskb_queue_head_init(&llcp_sock->tx_pending_queue);\n\tINIT_LIST_HEAD(&llcp_sock->accept_queue);\n\n\tif (sock != NULL)\n\t\tsock->state = SS_UNCONNECTED;\n\n\treturn sk;\n}\n\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock)\n{\n\tkfree(sock->service_name);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tlist_del_init(&sock->accept_queue);\n\n\tsock->parent = NULL;\n\n\tnfc_llcp_local_put(sock->local);\n}\n\nstatic int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct nfc_protocol llcp_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_LLCP,\n\t.proto    = &llcp_sock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = llcp_sock_create\n};\n\nint __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}\n\nvoid nfc_llcp_sock_exit(void)\n{\n\tnfc_proto_unregister(&llcp_nfc_proto);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/sched/signal.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic int sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tpr_debug(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic struct proto llcp_sock_proto = {\n\t.name     = \"NFC_LLCP\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_llcp_sock),\n};\n\nstatic int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\t/* This is going to be a listening socket, dsap must be 0 */\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tkfree(llcp_sock->service_name);\n\t\tllcp_sock->service_name = NULL;\n\t\tllcp_sock->dev = NULL;\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint ret = 0;\n\n\tpr_debug(\"sk %p backlog %d\\n\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM) ||\n\t    sk->sk_state != LLCP_BOUND) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tpr_debug(\"Socket listening\\n\");\n\tsk->sk_state = LLCP_LISTEN;\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tu32 opt;\n\tint err = 0;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_RW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->rw = (u8) opt;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_MIUX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->miux = cpu_to_be16((u16) opt);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tpr_debug(\"%p rw %d miux %d\\n\", llcp_sock,\n\t\t llcp_sock->rw, llcp_sock->miux);\n\n\treturn err;\n}\n\nstatic int nfc_llcp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint len, err = 0;\n\tu16 miux, remote_miu;\n\tu8 rw;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlocal = llcp_sock->local;\n\tif (!local)\n\t\treturn -ENODEV;\n\n\tlen = min_t(u32, len, sizeof(u32));\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\trw = llcp_sock->rw > LLCP_MAX_RW ? local->rw : llcp_sock->rw;\n\t\tif (put_user(rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tmiux = be16_to_cpu(llcp_sock->miux) > LLCP_MAX_MIUX ?\n\t\t\tbe16_to_cpu(local->miux) : be16_to_cpu(llcp_sock->miux);\n\n\t\tif (put_user(miux, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_MIU:\n\t\tremote_miu = llcp_sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : llcp_sock->remote_miu;\n\n\t\tif (put_user(remote_miu, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_LTO:\n\t\tif (put_user(local->remote_lto / 10, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_REMOTE_RW:\n\t\tif (put_user(llcp_sock->remote_rw, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nvoid nfc_llcp_accept_unlink(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"state %d\\n\", sk->sk_state);\n\n\tlist_del_init(&llcp_sock->accept_queue);\n\tsk_acceptq_removed(llcp_sock->parent);\n\tllcp_sock->parent = NULL;\n\n\tsock_put(sk);\n}\n\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_sock *llcp_sock_parent = nfc_llcp_sock(parent);\n\n\t/* Lock will be free from unlink */\n\tsock_hold(sk);\n\n\tlist_add_tail(&llcp_sock->accept_queue,\n\t\t      &llcp_sock_parent->accept_queue);\n\tllcp_sock->parent = parent;\n\tsk_acceptq_added(parent);\n}\n\nstruct sock *nfc_llcp_accept_dequeue(struct sock *parent,\n\t\t\t\t     struct socket *newsock)\n{\n\tstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\n\tstruct sock *sk;\n\n\tllcp_parent = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\n\t\t\t\t accept_queue) {\n\t\tsk = &lsk->sk;\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_state == LLCP_CLOSED) {\n\t\t\trelease_sock(sk);\n\t\t\tnfc_llcp_accept_unlink(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == LLCP_CONNECTED || !newsock) {\n\t\t\tlist_del_init(&lsk->accept_queue);\n\t\t\tsock_put(sk);\n\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\n\t\t\trelease_sock(sk);\n\n\t\t\tpr_debug(\"Returning sk state %d\\n\", sk->sk_state);\n\n\t\t\tsk_acceptq_removed(parent);\n\n\t\t\treturn sk;\n\t\t}\n\n\t\trelease_sock(sk);\n\t}\n\n\treturn NULL;\n}\n\nstatic int llcp_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t    int flags, bool kern)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *new_sk;\n\tlong timeo;\n\tint ret = 0;\n\n\tpr_debug(\"parent %p\\n\", sk);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != LLCP_LISTEN) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\t/* Wait for an incoming connection. */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(new_sk = nfc_llcp_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (!timeo) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (ret)\n\t\tgoto error;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tpr_debug(\"new socket %p\\n\", new_sk);\n\nerror:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t     int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\n\n\tif (llcp_sock == NULL || llcp_sock->dev == NULL)\n\t\treturn -EBADFD;\n\n\tpr_debug(\"%p %d %d %d\\n\", sk, llcp_sock->target_idx,\n\t\t llcp_sock->dsap, llcp_sock->ssap);\n\n\tmemset(llcp_addr, 0, sizeof(*llcp_addr));\n\n\tlock_sock(sk);\n\tif (!llcp_sock->dev) {\n\t\trelease_sock(sk);\n\t\treturn -EBADFD;\n\t}\n\tllcp_addr->sa_family = AF_NFC;\n\tllcp_addr->dev_idx = llcp_sock->dev->idx;\n\tllcp_addr->target_idx = llcp_sock->target_idx;\n\tllcp_addr->nfc_protocol = llcp_sock->nfc_protocol;\n\tllcp_addr->dsap = llcp_sock->dsap;\n\tllcp_addr->ssap = llcp_sock->ssap;\n\tllcp_addr->service_name_len = llcp_sock->service_name_len;\n\tmemcpy(llcp_addr->service_name, llcp_sock->service_name,\n\t       llcp_addr->service_name_len);\n\trelease_sock(sk);\n\n\treturn sizeof(struct sockaddr_nfc_llcp);\n}\n\nstatic inline __poll_t llcp_accept_poll(struct sock *parent)\n{\n\tstruct nfc_llcp_sock *llcp_sock, *parent_sock;\n\tstruct sock *sk;\n\n\tparent_sock = nfc_llcp_sock(parent);\n\n\tlist_for_each_entry(llcp_sock, &parent_sock->accept_queue,\n\t\t\t    accept_queue) {\n\t\tsk = &llcp_sock->sk;\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nstatic __poll_t llcp_sock_poll(struct file *file, struct socket *sock,\n\t\t\t\t   poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\t__poll_t mask = 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tsock_poll_wait(file, sock, wait);\n\n\tif (sk->sk_state == LLCP_LISTEN)\n\t\treturn llcp_accept_poll(sk);\n\n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_state == LLCP_CLOSED)\n\t\tmask |= EPOLLHUP;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\tif (sock_writeable(sk) && sk->sk_state == LLCP_CONNECTED)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\telse\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tpr_debug(\"mask 0x%x\\n\", mask);\n\n\treturn mask;\n}\n\nstatic int llcp_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint err = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tlocal = llcp_sock->local;\n\tif (local == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t/* Send a DISC */\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_llcp_send_disconnect(llcp_sock);\n\n\tif (sk->sk_state == LLCP_LISTEN) {\n\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\tstruct sock *accept_sk;\n\n\t\tlist_for_each_entry_safe(lsk, n, &llcp_sock->accept_queue,\n\t\t\t\t\t accept_queue) {\n\t\t\taccept_sk = &lsk->sk;\n\t\t\tlock_sock(accept_sk);\n\n\t\t\tnfc_llcp_send_disconnect(lsk);\n\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\trelease_sock(accept_sk);\n\t\t}\n\t}\n\n\tif (llcp_sock->reserved_ssap < LLCP_SAP_MAX)\n\t\tnfc_llcp_put_ssap(llcp_sock->local, llcp_sock->ssap);\n\n\trelease_sock(sk);\n\n\t/* Keep this sock alive and therefore do not remove it from the sockets\n\t * list until the DISC PDU has been actually sent. Otherwise we would\n\t * reply with DM PDUs before sending the DISC one.\n\t */\n\tif (sk->sk_state == LLCP_DISCONNECTING)\n\t\treturn err;\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_llcp_sock_unlink(&local->raw_sockets, sk);\n\telse\n\t\tnfc_llcp_sock_unlink(&local->sockets, sk);\n\nout:\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t     int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint ret = 0;\n\n\tpr_debug(\"sock %p sk %p flags 0x%x\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tif (addr->service_name_len == 0 && addr->dsap == 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\", addr->dev_idx,\n\t\t addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tret = -EISCONN;\n\t\tgoto error;\n\t}\n\tif (sk->sk_state == LLCP_CONNECTING) {\n\t\tret = -EINPROGRESS;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\tif (dev->dep_link_up == false) {\n\t\tret = -ENOLINK;\n\t\tdevice_unlock(&dev->dev);\n\t\tgoto put_dev;\n\t}\n\tdevice_unlock(&dev->dev);\n\n\tif (local->rf_mode == NFC_RF_INITIATOR &&\n\t    addr->target_idx != local->target_idx) {\n\t\tret = -ENOLINK;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->ssap = nfc_llcp_get_local_ssap(local);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tnfc_llcp_local_put(llcp_sock->local);\n\t\tllcp_sock->local = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\n\tif (addr->service_name_len == 0)\n\t\tllcp_sock->dsap = addr->dsap;\n\telse\n\t\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->nfc_protocol = addr->nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    addr->service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(addr->service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!llcp_sock->service_name) {\n\t\tret = -ENOMEM;\n\t\tgoto sock_llcp_release;\n\t}\n\n\tnfc_llcp_sock_link(&local->connecting_sockets, sk);\n\n\tret = nfc_llcp_send_connect(llcp_sock);\n\tif (ret)\n\t\tgoto sock_unlink;\n\n\tsk->sk_state = LLCP_CONNECTING;\n\n\tret = sock_wait_state(sk, LLCP_CONNECTED,\n\t\t\t      sock_sndtimeo(sk, flags & O_NONBLOCK));\n\tif (ret && ret != -EINPROGRESS)\n\t\tgoto sock_unlink;\n\n\trelease_sock(sk);\n\n\treturn ret;\n\nsock_unlink:\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tkfree(llcp_sock->service_name);\n\tllcp_sock->service_name = NULL;\n\nsock_llcp_release:\n\tnfc_llcp_put_ssap(local, llcp_sock->ssap);\n\tnfc_llcp_local_put(llcp_sock->local);\n\tllcp_sock->local = NULL;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int llcp_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tint ret;\n\n\tpr_debug(\"sock %p sk %p\", sock, sk);\n\n\tret = sock_error(sk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, addr,\n\t\t\t\t msg->msg_name);\n\n\t\tif (msg->msg_namelen < sizeof(*addr)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\treturn nfc_llcp_send_ui_frame(llcp_sock, addr->dsap, addr->ssap,\n\t\t\t\t\t      msg, len);\n\t}\n\n\tif (sk->sk_state != LLCP_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\n\treturn nfc_llcp_send_i_frame(llcp_sock, msg, len);\n}\n\nstatic int llcp_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t     size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n\n\tpr_debug(\"%p %zu\\n\", sk, len);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_msg(cskb, 0, msg, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, sockaddr,\n\t\t\t\t msg->msg_name);\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n\nstatic const struct proto_ops llcp_sock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_sock_bind,\n\t.connect        = llcp_sock_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = llcp_sock_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = llcp_sock_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.setsockopt     = nfc_llcp_setsockopt,\n\t.getsockopt     = nfc_llcp_getsockopt,\n\t.sendmsg        = llcp_sock_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops llcp_rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.bind           = llcp_raw_sock_bind,\n\t.connect        = sock_no_connect,\n\t.release        = llcp_sock_release,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = llcp_sock_getname,\n\t.poll           = llcp_sock_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = llcp_sock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\n\tpr_debug(\"%p\\n\", sk);\n\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tnfc_llcp_sock_free(llcp_sock);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tsk = sk_alloc(&init_net, PF_NFC, gfp, &llcp_sock_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tllcp_sock = nfc_llcp_sock(sk);\n\n\tsock_init_data(sock, sk);\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_protocol = NFC_SOCKPROTO_LLCP;\n\tsk->sk_type = type;\n\tsk->sk_destruct = llcp_sock_destruct;\n\n\tllcp_sock->ssap = 0;\n\tllcp_sock->dsap = LLCP_SAP_SDP;\n\tllcp_sock->rw = LLCP_MAX_RW + 1;\n\tllcp_sock->miux = cpu_to_be16(LLCP_MAX_MIUX + 1);\n\tllcp_sock->send_n = llcp_sock->send_ack_n = 0;\n\tllcp_sock->recv_n = llcp_sock->recv_ack_n = 0;\n\tllcp_sock->remote_ready = 1;\n\tllcp_sock->reserved_ssap = LLCP_SAP_MAX;\n\tnfc_llcp_socket_remote_param_init(llcp_sock);\n\tskb_queue_head_init(&llcp_sock->tx_queue);\n\tskb_queue_head_init(&llcp_sock->tx_pending_queue);\n\tINIT_LIST_HEAD(&llcp_sock->accept_queue);\n\n\tif (sock != NULL)\n\t\tsock->state = SS_UNCONNECTED;\n\n\treturn sk;\n}\n\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock)\n{\n\tkfree(sock->service_name);\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tlist_del_init(&sock->accept_queue);\n\n\tsock->parent = NULL;\n\n\tnfc_llcp_local_put(sock->local);\n}\n\nstatic int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct nfc_protocol llcp_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_LLCP,\n\t.proto    = &llcp_sock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = llcp_sock_create\n};\n\nint __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}\n\nvoid nfc_llcp_sock_exit(void)\n{\n\tnfc_proto_unregister(&llcp_nfc_proto);\n}\n"], "filenames": ["net/nfc/llcp_sock.c"], "buggy_code_start_loc": [112], "buggy_code_end_loc": [121], "fixing_code_start_loc": [113], "fixing_code_end_loc": [124], "type": "CWE-476", "message": "net/nfc/llcp_sock.c in the Linux kernel before 5.12.10 allows local unprivileged users to cause a denial of service (NULL pointer dereference and BUG) by making a getsockname call after a certain type of failure of a bind call.", "other": {"cve": {"id": "CVE-2021-38208", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.387", "lastModified": "2021-09-21T18:23:56.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/nfc/llcp_sock.c in the Linux kernel before 5.12.10 allows local unprivileged users to cause a denial of service (NULL pointer dereference and BUG) by making a getsockname call after a certain type of failure of a bind call."}, {"lang": "es", "value": "El archivo net/nfc/llcp_sock.c en el kernel de Linux versiones anteriores a 5.12.10, permite a los usuarios locales no privilegiados causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL y BUG) al hacer una llamada getsockname despu\u00e9s de cierto tipo de fallo de una llamada de enlace"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.10", "matchCriteriaId": "FF7FC8F9-201D-4170-B56B-EA6E69B1FB1F"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/08/17/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/08/17/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/08/24/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1992810", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.12.10", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4ac06a1e013cf5fdd963317ffd3b968560f33bba", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4ac06a1e013cf5fdd963317ffd3b968560f33bba"}}